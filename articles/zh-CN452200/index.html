<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏🏽 👩🏻‍🤝‍👨🏽 ⏩ GOSTIM：在一个晚上使用GOST密码进行P2P F2F E2EE IM 🍸 👩🏼‍⚖️ ⭕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="作为PyGOST库（纯Python中的GOST加密原语）的开发人员，我经常遇到有关如何在膝盖上实现最简单的安全消息传递的问题。 许多人认为应用密码术是一件相当简单的事情，对块密码的.encrypt（）调用足以在通信通道上安全发送。 其他人则认为应用密码学是少数人的命运，可以接受的是，富裕的公司（例如...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GOSTIM：在一个晚上使用GOST密码进行P2P F2F E2EE IM</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452200/"> 作为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PyGOST</a>库（纯Python中的GOST加密原语）的开发人员，我经常遇到有关如何在膝盖上实现最简单的安全消息传递的问题。 许多人认为应用密码术是一件相当简单的事情，对块密码的.encrypt（）调用足以在通信通道上安全发送。 其他人则认为应用密码学是少数人的命运，可以接受的是，富裕的公司（例如带有数学奥林匹克竞赛的Telegram） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">无法实现</a>安全协议。 <br><br> 所有这些促使我写这篇文章，以表明加密协议和安全IM的实现并不是一项艰巨的任务。 但是，发明自己的身份验证和密钥协商协议是不值得的。 <br><br><div style="text-align:center;"><img alt="听证会" src="https://habrastorage.org/getpro/habr/post_images/4e2/2bb/f04/4e22bbf0480a8181bcbb2054c6f95815.jpg"></div><br> 本文将使用专有的GOST加密算法PyGOST库和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SIGMA-I</a>身份验证和密钥协议协议（基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IPsec IKE</a>实现）编写<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为点对点</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">朋友到朋友</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">端到端的加密</a>即时通讯程序。带有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PyDERASN</a>库的消息的ASN.1编码（我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">之前</a>已经<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">写过</a> ）。 先决条件：必须非常简单，可以在一个晚上（或工作日）从头开始编写，否则，它不再是一个简单的程序。 它可能有错误，不必要的困难，缺点，而且这是我使用asyncio库的第一个程序。 <br><a name="habracut"></a><br><h2> 设计即时通讯 </h2><br> 首先，您需要了解我们的IM外观。 为简单起见，让它成为一个对等网络，而不会发现任何参与者。 我们将亲自指出到哪个地址：用于与对话者通信的端口。 <br><br> 我了解，目前，假设两台任意计算机之间可以直接通信是对IM在实践中的适用性的重大限制。 但是，开发人员实施各种NAT遍历拐点的人越多，我们在IPv4 Internet上停留的时间就越长，任意计算机之间进行通信的可能性就会降低。 那么，您在家里和工作中可以忍受多少IPv6缺乏？ <br><br> 我们将有一个朋友对朋友的网络：应该事先知道所有可能的对话者。 首先，它极大地简化了一切：介绍自己，发现或未找到名称/密钥，断开连接或继续工作，了解对话者。 其次，在一般情况下，它是安全的并且排除了许多攻击。 <br><br>  IM接口将接近<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">无精打采项目</a>的经典解决方案，我非常喜欢它们的极简主义和Unix-way哲学。 每个对话者的IM程序都会创建一个带有三个Unix域套接字的目录： <br><br><ul><li>  in-发送给对话者的消息记录在其中； </li><li>  out-从对话者收到的消息被从中读取； </li><li> 状态-从中读取信息，我们会发现对话者现在是否已连接，连接地址/端口。 </li></ul><br> 此外，还会创建一个conn套接字，将其写入到哪个主机端口，从而启动与远程对话者的连接。 <br><br><pre> |-爱丽丝
 |  |-在
 |  |-出
 |  `-状态
 |-鲍勃
 |  |-在
 |  |-出
 |  `-状态
 `-conn
</pre><br> 这种方法允许您独立实现IM传输和用户界面，因为没有口味和颜色的朋友，所以您不会取悦所有人。 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tmux</a>和/或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">multitail</a> ，您可以获得具有语法高亮显示的多窗口界面。 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rlwrap，</a>可以获得用于输入消息的GNU Readline兼容字符串。 <br><br> 实际上，无吮吸项目使用FIFO文件。 就个人而言，我无法理解在没有选定线程手工制作的情况下，如何以异步方式竞争性地处理文件（我很长时间以来一直在使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Go</a>语言）。 因此，我决定不使用Unix域套接字。 不幸的是，这使得无法执行echo 2001：470：dead :: babe 6666&gt; conn。 我使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">socat</a>解决了这个问题：echo 2001：470：dead ::宝贝6666 |  socat-UNIX-CONNECT：conn，socat READLINE UNIX-CONNECT：alice / in。 <br><br><h2> 初始不安全协议 </h2><br>  TCP被用作一种传输方式：它保证交付及其顺序。  UDP不能保证一个或另一个（这在应用密码术时将很有用），并且Python中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SCTP</a>支持是开箱即用的。 <br><br> 不幸的是，在TCP中没有消息的概念，而只有字节流。 因此，有必要提出一种消息格式，以便可以在此流中在彼此之间共享消息。 我们可以同意使用换行符。 对于初学者来说，这是合适的，但是，当我们开始加密邮件时，此符号可能会出现在密文中的任何位置。 因此，协议在网络上很流行，首先发送消息的长度（以字节为单位）。 例如，在Python中，开箱即用的是xdrlib，它使您可以使用类似的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">XDR</a>格式。 <br><br> 我们无法正确有效地处理TCP读取-我们简化了代码。 我们以无休止的循环从套接字读取数据，直到解码完整的消息为止。 您也可以将JSON和XML用作此方法的格式。 但是，当添加加密时，则必须对数据进行签名和验证-这将需要逐字节的对象相同表示，而JSON / XML不提供这种表示（转储可能会有所不同）。 <br><br>  XDR适合执行此任务，但是，我选择具有DER编码和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PyDERASN</a>库的ASN.1，因为我们手头有高级对象，使用它们通常更轻松，更方便。 与无模式的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bencode</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MessagePack</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CBOR不同</a> ，ASN.1将根据硬编码的模式自动验证数据。 <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Msg ::= CHOICE { # text MsgText, # handshake [0] EXPLICIT MsgHandshake } class Msg(Choice): schema = (( ("text", MsgText()), ("handshake", MsgHandshake(expl=tag_ctxc(0))), )) # MsgText ::= SEQUENCE { # text UTF8String (SIZE(1..MaxTextLen))} class MsgText(Sequence): schema = (( ("text", UTF8String(bounds=(1, MaxTextLen))), )) # MsgHandshake ::= SEQUENCE { # peerName UTF8String (SIZE(1..256)) } class MsgHandshake(Sequence): schema = (( ("peerName", UTF8String(bounds=(1, 256))), ))</span></span></code> </pre> <br> 收到的消息将为Msg：文本MsgText（到目前为止有一个文本字段）或握手消息MsgHandshake（在其中传输对话者的名称）。 现在看起来过于复杂，但这是对未来的挑战。 <br><br><pre>      ┌─────┐┌─────┐
      │PeerA││PeerB│
      └──┬──┘└──┬──┘
         │信息握手（IdA）│
         │─────────────
         ││
         │信息握手（IdB）│
         │&lt;─────────────
         ││
         │MsgText（）│
         │─────────────
         ││
         │MsgText（）│
         │&lt;─────────────
         ││
</pre><br><br><h2> 没有加密的即时消息 </h2><br> 就像我说过的，对于所有使用套接字的操作，都会使用asyncio库。 声明我们在发布时的期望： <br><br><pre> <code class="python hljs">parser = argparse.ArgumentParser(description=<span class="hljs-string"><span class="hljs-string">"GOSTIM"</span></span>) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--our-name"</span></span>, required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Our peer name"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--their-names"</span></span>, required=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Their peer names, comma-separated"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--bind"</span></span>, default=<span class="hljs-string"><span class="hljs-string">"::1"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Address to listen on"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--port"</span></span>, type=int, default=<span class="hljs-number"><span class="hljs-number">6666</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Port to listen on"</span></span>, ) args = parser.parse_args() OUR_NAME = UTF8String(args.our_name) THEIR_NAMES = set(args.their_names.split(<span class="hljs-string"><span class="hljs-string">","</span></span>))</code> </pre><br> 设置自己的名字（-我们的名字爱丽丝）。 逗号列出了所有预期的对话者（-他们的名字bob，eve）。 对于每个对话者，都会创建一个带有Unix套接字的目录，以及每个in，out状态的协程： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> peer_name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> THEIR_NAMES: makedirs(peer_name, mode=<span class="hljs-number"><span class="hljs-number">0o700</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) out_queue = asyncio.Queue() OUT_QUEUES[peer_name] = out_queue asyncio.ensure_future(asyncio.start_unix_server( partial(unixsock_out_processor, out_queue=out_queue), path.join(peer_name, <span class="hljs-string"><span class="hljs-string">"out"</span></span>), )) in_queue = asyncio.Queue() IN_QUEUES[peer_name] = in_queue asyncio.ensure_future(asyncio.start_unix_server( partial(unixsock_in_processor, in_queue=in_queue), path.join(peer_name, <span class="hljs-string"><span class="hljs-string">"in"</span></span>), )) asyncio.ensure_future(asyncio.start_unix_server( partial(unixsock_state_processor, peer_name=peer_name), path.join(peer_name, <span class="hljs-string"><span class="hljs-string">"state"</span></span>), )) asyncio.ensure_future(asyncio.start_unix_server(unixsock_conn_processor, <span class="hljs-string"><span class="hljs-string">"conn"</span></span>))</code> </pre><br> 来自用户的in套接字中的消息被发送到队列IN_QUEUES： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unixsock_in_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader, writer, in_queue: asyncio.Queue)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> reader.read(MaxTextLen) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> text == <span class="hljs-string"><span class="hljs-string">b""</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> in_queue.put(text.decode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>))</code> </pre><br> 来自对话者的消息被发送到OUT_QUEUES队列，数据从该队列写入out套接字： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unixsock_out_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader, writer, out_queue: asyncio.Queue)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> out_queue.get() writer.write((<span class="hljs-string"><span class="hljs-string">"[%s] %s"</span></span> % (datetime.now(), text)).encode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> writer.drain()</code> </pre><br> 从状态套接字读取时，该程序在PEER_ALIVE词典中查找对话者的地址。 如果还没有与对话者的连接，则会写入一个空行。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unixsock_state_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader, writer, peer_name: str)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> peer_writer = PEER_ALIVES.get(peer_name) writer.write( <span class="hljs-string"><span class="hljs-string">b""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> peer_writer <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> (<span class="hljs-string"><span class="hljs-string">" "</span></span>.join([ str(i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> peer_writer.get_extra_info(<span class="hljs-string"><span class="hljs-string">"peername"</span></span>)[:<span class="hljs-number"><span class="hljs-number">2</span></span>] ]).encode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>) + <span class="hljs-string"><span class="hljs-string">b"\n"</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> writer.drain() writer.close()</code> </pre><br> 将地址写入conn套接字后，将启动连接的“启动器”功能： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unixsock_conn_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader, writer)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> reader.read(<span class="hljs-number"><span class="hljs-number">256</span></span>) writer.close() host, port = data.decode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>).split(<span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> initiator(host=host, port=int(port))</code> </pre><br> 考虑启动器。 首先，他显然打开了与指定主机/端口的连接，并发送一个带有他的名字的握手消息： <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">130</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initiator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(host, port)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">131</span></span> _id = repr((host, port)) <span class="hljs-number"><span class="hljs-number">132</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: dialing"</span></span>, _id) <span class="hljs-number"><span class="hljs-number">133</span></span> reader, writer = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.open_connection(host, port) <span class="hljs-number"><span class="hljs-number">134</span></span> <span class="hljs-comment"><span class="hljs-comment"># Handshake message {{{ 135 writer.write(Msg(("handshake", MsgHandshake(( 136 ("peerName", OUR_NAME), 137 )))).encode()) 138 # }}} 139 await writer.drain()</span></span></code> </pre><br> 然后，它等待远程方的响应。 尝试根据Msg ASN.1方案对接收到的响应进行解码。 我们假定整个消息将由一个TCP段发送，并且在调用.read（）时将以原子方式接收它。 我们验证是否确实收到了握手消息。 <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">141</span></span> <span class="hljs-comment"><span class="hljs-comment"># Wait for Handshake message {{{ 142 data = await reader.read(256) 143 if data == b"": 144 logging.warning("%s: no answer, disconnecting", _id) 145 writer.close() 146 return 147 try: 148 msg, _ = Msg().decode(data) 149 except ASN1Error: 150 logging.warning("%s: undecodable answer, disconnecting", _id) 151 writer.close() 152 return 153 logging.info("%s: got %s message", _id, msg.choice) 154 if msg.choice != "handshake": 155 logging.warning("%s: unexpected message, disconnecting", _id) 156 writer.close() 157 return 158 # }}}</span></span></code> </pre><br> 我们确认与我们交谈的人的名字是我们已知的。 如果不是，则断开连接。 我们检查是否已经与他建立了连接（对话者再次给出了连接到我们的命令）并关闭了它。 带有消息文本的Python字符串放置在IN_QUEUES队列中，但是有一个特殊值None，该值指示msg_sender向协程停止工作，因此她将忘记与过时的TCP连接有关的编写器。 <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">159</span></span> msg_handshake = msg.value <span class="hljs-number"><span class="hljs-number">160</span></span> peer_name = str(msg_handshake[<span class="hljs-string"><span class="hljs-string">"peerName"</span></span>]) <span class="hljs-number"><span class="hljs-number">161</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> peer_name <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> THEIR_NAMES: <span class="hljs-number"><span class="hljs-number">162</span></span> logging.warning(<span class="hljs-string"><span class="hljs-string">"unknown peer name: %s"</span></span>, peer_name) <span class="hljs-number"><span class="hljs-number">163</span></span> writer.close() <span class="hljs-number"><span class="hljs-number">164</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">165</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: session established: %s"</span></span>, _id, peer_name) <span class="hljs-number"><span class="hljs-number">166</span></span> <span class="hljs-comment"><span class="hljs-comment"># Run text message sender, initialize transport decoder {{{ 167 peer_alive = PEER_ALIVES.pop(peer_name, None) 168 if peer_alive is not None: 169 peer_alive.close() 170 await IN_QUEUES[peer_name].put(None) 171 PEER_ALIVES[peer_name] = writer 172 asyncio.ensure_future(msg_sender(peer_name, writer)) 173 # }}}</span></span></code> </pre><br>  msg_sender接受传出消息（从in套接字排队），将它们序列化为MsgText消息，然后通过TCP连接发送它们。 它随时可能中断-我们显然正在拦截它。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg_sender</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(peer_name: str, writer)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> in_queue = IN_QUEUES[peer_name] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> in_queue.get() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> text <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> writer.write(Msg((<span class="hljs-string"><span class="hljs-string">"text"</span></span>, MsgText(( (<span class="hljs-string"><span class="hljs-string">"text"</span></span>, UTF8String(text)), )))).encode()) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> writer.drain() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ConnectionResetError: <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> PEER_ALIVES[peer_name] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: sent %d characters message"</span></span>, peer_name, len(text))</code> </pre><br> 最后，启动器进入一个无穷循环，从套接字读取消息。 检查这是否为文本消息，并将将它们从中发送到相应对话者的out套接字的队列放在OUT_QUEUES中。 您为什么不能只做.read（）并解码消息？ 因为有可能来自用户的几条消息将聚集在操作系统的缓冲区中，并由一个TCP段发送。 我们可以解码第一个，然后随后的一部分可以保留在缓冲区中。 在任何紧急情况下，我们都将关闭TCP连接并停止msg_sender协程（通过将None发送到OUT_QUEUES队列）。 <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">174</span></span> buf = <span class="hljs-string"><span class="hljs-string">b""</span></span> <span class="hljs-number"><span class="hljs-number">175</span></span> <span class="hljs-comment"><span class="hljs-comment"># Wait for test messages {{{ 176 while True: 177 data = await reader.read(MaxMsgLen) 178 if data == b"": 179 break 180 buf += data 181 if len(buf) &gt; MaxMsgLen: 182 logging.warning("%s: max buffer size exceeded", _id) 183 break 184 try: 185 msg, tail = Msg().decode(buf) 186 except ASN1Error: 187 continue 188 buf = tail 189 if msg.choice != "text": 190 logging.warning("%s: unexpected %s message", _id, msg.choice) 191 break 192 try: 193 await msg_receiver(msg.value, peer_name) 194 except ValueError as err: 195 logging.warning("%s: %s", err) 196 break 197 # }}} 198 logging.info("%s: disconnecting: %s", _id, peer_name) 199 IN_QUEUES[peer_name].put(None) 200 writer.close() 66 async def msg_receiver(msg_text: MsgText, peer_name: str) -&gt; None: 67 text = str(msg_text["text"]) 68 logging.info("%s: received %d characters message", peer_name, len(text)) 69 await OUT_QUEUES[peer_name].put(text)</span></span></code> </pre><br> 让我们回到主要代码。 创建所有协程后，在启动程序时，我们将启动TCP服务器。 对于每个已建立的连接，他都会创建一个响应程序协程。 <br><br><pre> <code class="python hljs">logging.basicConfig( level=logging.INFO, format=<span class="hljs-string"><span class="hljs-string">"%(levelname)s %(asctime)s: %(funcName)s: %(message)s"</span></span>, ) loop = asyncio.get_event_loop() server = loop.run_until_complete(asyncio.start_server(responder, args.bind, args.port)) logging.info(<span class="hljs-string"><span class="hljs-string">"Listening on: %s"</span></span>, server.sockets[<span class="hljs-number"><span class="hljs-number">0</span></span>].getsockname()) loop.run_forever()</code> </pre><br> 响应者类似于发起者，并且镜像所有相同的动作，但是为简单起见，读取消息的无限循环立即开始。 现在，握手协议从双方发送一条消息，但是将来，连接的发起方将发送两条消息，此后可以立即发送文本消息。 <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">72</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">responder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader, writer)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">73</span></span> _id = writer.get_extra_info(<span class="hljs-string"><span class="hljs-string">"peername"</span></span>) <span class="hljs-number"><span class="hljs-number">74</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: connected"</span></span>, _id) <span class="hljs-number"><span class="hljs-number">75</span></span> buf = <span class="hljs-string"><span class="hljs-string">b""</span></span> <span class="hljs-number"><span class="hljs-number">76</span></span> msg_expected = <span class="hljs-string"><span class="hljs-string">"handshake"</span></span> <span class="hljs-number"><span class="hljs-number">77</span></span> peer_name = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-number"><span class="hljs-number">78</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-number"><span class="hljs-number">79</span></span> <span class="hljs-comment"><span class="hljs-comment"># Read until we get Msg message {{{ 80 data = await reader.read(MaxMsgLen) 81 if data == b"": 82 logging.info("%s: closed connection", _id) 83 break 84 buf += data 85 if len(buf) &gt; MaxMsgLen: 86 logging.warning("%s: max buffer size exceeded", _id) 87 break 88 try: 89 msg, tail = Msg().decode(buf) 90 except ASN1Error: 91 continue 92 buf = tail 93 # }}} 94 if msg.choice != msg_expected: 95 logging.warning("%s: unexpected %s message", _id, msg.choice) 96 break 97 if msg_expected == "text": 98 try: 99 await msg_receiver(msg.value, peer_name) 100 except ValueError as err: 101 logging.warning("%s: %s", err) 102 break 103 # Process Handshake message {{{ 104 elif msg_expected == "handshake": 105 logging.info("%s: got %s message", _id, msg_expected) 106 msg_handshake = msg.value 107 peer_name = str(msg_handshake["peerName"]) 108 if peer_name not in THEIR_NAMES: 109 logging.warning("unknown peer name: %s", peer_name) 110 break 111 writer.write(Msg(("handshake", MsgHandshake(( 112 ("peerName", OUR_NAME), 113 )))).encode()) 114 await writer.drain() 115 logging.info("%s: session established: %s", _id, peer_name) 116 peer_alive = PEER_ALIVES.pop(peer_name, None) 117 if peer_alive is not None: 118 peer_alive.close() 119 await IN_QUEUES[peer_name].put(None) 120 PEER_ALIVES[peer_name] = writer 121 asyncio.ensure_future(msg_sender(peer_name, writer)) 122 msg_expected = "text" 123 # }}} 124 logging.info("%s: disconnecting", _id) 125 if msg_expected == "text": 126 IN_QUEUES[peer_name].put(None) 127 writer.close()</span></span></code> </pre><br><h2> 安全协议 </h2><br> 是时候保证我们的沟通了。 我们所说的安全性是什么，我们想要什么： <br><br><ul><li> 传输消息的机密性； </li><li> 传输消息的真实性和完整性-必须检测其更改； </li><li> 防止重放攻击-应该检测到消息丢失或重试的事实（我们决定断开连接）； </li><li> 通过预先驱动的公钥识别和验证对话者-我们早先已经决定要建立一个朋友对朋友的网络。 只有经过身份验证，我们才能了解与谁进行通讯； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">完美的前向保密</a>属性（PFS）的存在-我们长期存在的签名密钥的妥协不应该导致读取所有以前的对应关系的可能性。 记录拦截的流量变得无用； </li><li> 消息的有效性/有效性（传输和握手）仅在同一TCP会话内。 不可能从另一个会话（即使使用相同的对话者）插入经过正确签名/验证的消息； </li><li> 被动的观察者应该看不到用户标识符，传输的寿命很长的公钥，也不能从中获取哈希值。 被动观察者的某种匿名性。 </li></ul><br> 令人惊讶的是，几乎每个人都希望在任何握手协议中都达到这一最低要求，而上述的极少数最终还是针对本地协议执行的。 所以现在我们不会发明新事物。 我绝对会建议使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Noise框架</a>来构建协议，但让我们选择一些更简单的方法。 <br><br> 最受欢迎的是两种协议： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TLS</a>是一个复杂的协议，具有悠久的错误，漏洞，漏洞，深思熟虑，复杂性和缺点的历史（但是，它不适用于TLS 1.3）。 但是由于复杂性，我们不考虑它。 </li><li> 带有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IKE的IPsec-</a>尽管也不简单，但没有严重的密码问题。 如果您阅读有关IKEv1和IKEv2的信息，它们的来源是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">STS</a> ，ISO / IEC IS 9798-3和SIGMA（SIGn-and-MAc）协议-足够容易在一个晚上实施。 </li></ul><br>  SIGMA作为STS / ISO协议开发的最后一个环节，效果如何？ 它满足我们的所有要求（包括“隐藏”对话者的标识符），没有已知的密码问题。 这非常简单-从协议消息中删除至少一个元素将导致其不安全。 <br><br> 让我们从最简单的本地协议过渡到SIGMA。 我们感兴趣的最基本的操作是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">键匹配</a> ：这是一个函数，在该函数的输出中，两个参与者将获得相同的值，可用作对称键。 无需赘述：各方分别生成一个临时密钥（仅在同一会话中使用）密钥对（公共密钥和私有密钥），交换公共密钥，调用匹配功能，并向其输入传输其私有密钥和对话者的公共密钥。 <br><br><pre> ┌─────┐┌─────┐
 │PeerA││PeerB│
 └──┬──┘└──┬──┘
    │IDA，PubA│I══╔╔╔
    │──────────────&gt;&gt;│rPrvA，PubA = DHgen（）║
    ││╚═══════════════════╝
    │IdB，PubB│╔════════════════════╗
    │&lt;─────────────│║PrvB，PubB = DHgen（）║
    ││╚═══════════════════╝
    ────┐
        │║密钥= DH（PrvA，PubB）║
    &lt;───┘
    ││
    ││
</pre><br><br> 任何人都可以干预中间并用自己的密钥替换公钥-在此协议中，不会对对话者进行身份验证。 添加具有长寿命密钥的签名。 <br><br><pre> ┌─────┐┌─────┐
 │PeerA││PeerB│
 └──┬──┘└──┬──┘
    │IdA，PubA，符号（SignPrvA，（PubA））│╔═══════════════════════╗
    │────ign ign ign─ign ign ign ign ign ign ign ign SignPrvA，SignPubA = load（）║
    ││║PrvA，PubA = DHgen（）║
    ││││══╝╝╝╝
    │IdB，PubB，符号（SignPrvB，（PubB））│╔═══════════════════════╗
    │&lt;────────────────│ignSignPrvB，SignPubB = load（）║
    ││║PrvB，PubB = DHgen（）║
    ││││══╝╝╝╝
    ────┐╔═════════════════════││
        │║验证（SignPubB，...）││
    &lt;───┘键= DH（PrvA，PubB）║│
    │╚═════════════════════╝│
    ││
</pre><br><br> 这样的签名将不起作用，因为它没有绑定到特定的会话。 这样的消息也适合与其他参与者的会话。 整个上下文应该被订阅。 这也迫使添加来自A的另一个消息。 <br><br> 另外，添加您自己的标识符作为签名非常重要，因为否则，我们可以替换IdXXX，并使用另一个知名对话者的密钥对消息重新签名。 为了防止<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">反射攻击</a> ，签名下的元素必须在含义上明确定义的位置：如果A签名（PubA，PubB），则B必须签名（PubB，PubA）。 这也表明选择序列化数据的结构和格式的重要性。 例如，对以ASN.1 DER编码的集合进行排序：SET OF（PubA，PubB）将与SET OF（PubB，PubA）相同。 <br><br><pre> ┌─────┐┌─────┐
 │PeerA││PeerB│
 └──┬──┘└──┬──┘
    │IDA，PubA│╔══════════════════════════
    │────────ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign ign SignPubA =负载（）║
    ││║PrvA，PubA = DHgen（）║
    ││││══╝╝╝╝
    │IdB，PubB，符号（SignPrvB，（IdB，PubA，PubB））│╔═════════════════════╗
    │SignPrvB，│&lt;────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── SignPubB =负载（）║
    ││║PrvB，PubB = DHgen（）║
    ││││══╝╝╝╝
    │签署（SignPrvA，（IdA，PubB，PubA））│╔═══════════════════╗
    │─────────────────── SignPubB，...）║
    ││║密钥= DH（PrvA，PubB）║
    ││││══╝╝╝
    ││
</pre><br><br> 但是，我们仍然没有“证明”我们已经为此会话开发了相同的通用密钥。 原则上，您可以不执行此步骤-第一个传输连接将无效，但是我们希望在握手完成后，我们可以确保一切都已真正达成共识。 目前，我们已经掌握了ISO / IEC IS 9798-3协议。 <br><br> 我们可以自己签名密钥。 这很危险，因为所使用的签名算法可能会泄漏（每个签名保留位数，但仍会泄漏）。 您可以根据生成的密钥对哈希签名，但是即使生成密钥的哈希泄漏也可能对生成函数产生暴力攻击。  SIGMA使用MAC功能来验证发送方ID。 <br><br><pre> ┌─────┐┌─────┐
 │PeerA││PeerB│
 └──┬──┘└──┬──┘
    │IDA，PubA│╔══════════════════════════
    │────────────────────────│──────│──││── &gt;│║SignPrvA，SignPubA =负载（）║
    ││║PrvA，PubA = DHgen（）║
    ││││══╝╝╝╝
    │IdB，PubB，符号（SignPrvB，（PubA，PubB）），MAC（IdB）│╔═════════════════╗
    │&lt;──────────────────────────││─── ─│SignPrvB，SignPubB = load（）（
    ││║PrvB，PubB = DHgen（）║
    ││││══╝╝╝╝
    ││││══╗╗╗
    │符号（SignPrvA，（PubB，PubA）），MAC（IdA）│║密钥= DH（PrvA，PubB）║
    │────────────────────────│──────│──││── &gt;│║验证（密钥，以dB为单位）║
    ││║验证（SignPubB，...）║
    ││││══╝╝╝
    ││
</pre><br><br> 作为一种优化，有些人可能想重用他们的临时密钥（当然，对于PFS来说，这是令人遗憾的）。 例如，我们生成了一个密钥对，尝试进行连接，但是TCP不可用或在协议中间某处断开。 遗憾的是将熵和处理器资源花费在新对上。 因此，我们引入了所谓的cookie-一个伪随机值，它将在重用短暂的公共密钥时防止可能的意外重放攻击。 由于cookie和临时公共密钥之间的绑定，可以在不需要时从签名中删除对方的公共密钥。 <br><br><pre> ┌─────┐┌─────┐
 │PeerA││PeerB│
 └──┬──┘└──┬──┘
    │IDA，PubA，CookieA│╔═════════════════════════
    │────────────────────────│──────│──││── ────────────────────&gt;&gt;││SignPrvA，SignPubA = load（）║
    ││║PrvA，PubA = DHgen（）║
    ││││══╝╝╝╝
    │IdB，PubB，CookieB，符号（SignPrvB，（CookieA，CookieB，PubB）），MAC（IdB）│Id═══ ═══╗
    │&lt;──────────────────────────────│││────────────── ────────────────────││SignPrvB，SignPubB = load（）║
    ││║PrvB，PubB = DHgen（）║
    ││││══╝╝╝╝
    ││││══╗╗╗
    │符号（SignPrvA，（CookieB，CookieA，PubA）），MAC（IdA）│║密钥= DH（PrvA，PubB）║
    │────────────────────────│──────│──││── ─验证验证验证（密钥，IdB）║
    ││║验证（SignPubB，...）║
    ││││══╝╝╝
    ││
</pre><br><br> 最后，我们想从被动观察者那里获得对话者标识符的私密性。 为此，SIGMA建议先交换临时密钥，然后制定一个用于验证身份验证消息的公用密钥。  SIGMA描述了两个选项： <br><br><ul><li>  SIGMA-I-保护发起者免受主动攻击，保护响应者免受被动攻击：发起者对响应者进行身份验证，如果某些内容不合适，则不会给出其标识。 如果您与他开始主动协议，则被告将提供其身份证明。 被动的观察者将一无所知。 <br>  SIGMA-R-保护响应者免受主动攻击，保护发起者免受被动攻击。 一切都完全相反，但是在此协议中，已经传输了四个握手消息。 <br><br><br> 我们选择SIGMA-I的方式与我们通常从服务器-客户端中获得的结果更相似：只有经过身份验证的服务器才能识别客户端，而且每个人都知道服务器。 另外，由于减少了握手消息，因此更易于实现。 我们添加到协议中的就是消息部分的加密以及标识符A到最后一条消息的加密部分的传输： <br><br><pre> ┌─────┐┌─────┐
 │PeerA││PeerB│
 └──┬──┘└──┬──┘
    │PubA，CookieA│╔══════════════════════════╗
    │────────────────────────│──────│──││── ─ign ign ign ign ign ign ign ign ign ign ,,,,, SignPubA = load（）║
    ││║PrvA，PubA = DHgen（）║<font></font>
   │ │ ╚═══════════════════════════╝<font></font>
   │PubB, CookieB, Enc((IdB, sign(SignPrvB, (CookieA, CookieB, PubB)), MAC(IdB))) │ ╔═══════════════════════════╗<font></font>
   │&lt;─────────────────────────────────────────────────────────────────────────────│ ║SignPrvB, SignPubB = load()║<font></font>
   │ │ ║PrvB, PubB = DHgen() ║<font></font>
   │ │ ╚═══════════════════════════╝<font></font>
   │ │ ╔═════════════════════╗<font></font>
   │ Enc((IdA, sign(SignPrvA, (CookieB, CookieA, PubA)), MAC(IdA))) │ ║Key = DH(PrvA, PubB) ║<font></font>
   │─────────────────────────────────────────────────────────────────────────────&gt;│ ║verify(Key, IdB) ║<font></font>
   │ │ ║verify(SignPubB, ...)║<font></font>
   │ │ ╚═════════════════════╝<font></font>
   │ │<font></font>
</pre><br><br><ul><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">34.10-2012</a>   256- . </li><li>      34.10-2012 VKO. </li><li>   MAC  CMAC.       ,     34.13-2015.        — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> (34.12-2015). </li><li>          .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-256</a> (34.11-2012 256 ). </li></ul><br><br>        .         .         :   ,  ,  (MAC)   , .         ,    , .     , ,  ?          .   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">KDF</a> (key derivation function).  ,     - : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HKDF</a>  ,       .  ,    Python   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">hkdf</a> . HKDF   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HMAC</a> , ,   ,  -.    Python   Wikipedia    .      34.10-2012,   -   -256.         ,      : <br><br><pre> <code class="python hljs">kdf = Hkdf(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, key_session, hash=GOST34112012256) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake1-mac-identity"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake1-enc"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake1-mac"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake2-mac-identity"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake2-enc"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"handshake2-mac"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"transport-initiator-enc"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"transport-initiator-mac"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"transport-responder-enc"</span></span>) kdf.expand(<span class="hljs-string"><span class="hljs-string">b"transport-responder-mac"</span></span>)</code> </pre><br><h2> / </h2><br>     ASN.1         : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Msg</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Choice)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"text"</span></span>, MsgText()), (<span class="hljs-string"><span class="hljs-string">"handshake0"</span></span>, MsgHandshake0(expl=tag_ctxc(<span class="hljs-number"><span class="hljs-number">0</span></span>))), (<span class="hljs-string"><span class="hljs-string">"handshake1"</span></span>, MsgHandshake1(expl=tag_ctxc(<span class="hljs-number"><span class="hljs-number">1</span></span>))), (<span class="hljs-string"><span class="hljs-string">"handshake2"</span></span>, MsgHandshake2(expl=tag_ctxc(<span class="hljs-number"><span class="hljs-number">2</span></span>))), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgText</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"payload"</span></span>, MsgTextPayload()), (<span class="hljs-string"><span class="hljs-string">"payloadMac"</span></span>, MAC()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgTextPayload</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"nonce"</span></span>, Integer(bounds=(<span class="hljs-number"><span class="hljs-number">0</span></span>, float(<span class="hljs-string"><span class="hljs-string">"+inf"</span></span>)))), (<span class="hljs-string"><span class="hljs-string">"ciphertext"</span></span>, OctetString(bounds=(<span class="hljs-number"><span class="hljs-number">1</span></span>, MaxTextLen))), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgHandshake0</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"cookieInitiator"</span></span>, Cookie()), (<span class="hljs-string"><span class="hljs-string">"pubKeyInitiator"</span></span>, PubKey()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgHandshake1</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"cookieResponder"</span></span>, Cookie()), (<span class="hljs-string"><span class="hljs-string">"pubKeyResponder"</span></span>, PubKey()), (<span class="hljs-string"><span class="hljs-string">"ukm"</span></span>, OctetString(bounds=(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>))), (<span class="hljs-string"><span class="hljs-string">"ciphertext"</span></span>, OctetString()), (<span class="hljs-string"><span class="hljs-string">"ciphertextMac"</span></span>, MAC()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MsgHandshake2</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"ciphertext"</span></span>, OctetString()), (<span class="hljs-string"><span class="hljs-string">"ciphertextMac"</span></span>, MAC()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandshakeTBE</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"identity"</span></span>, OctetString(bounds=(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>))), (<span class="hljs-string"><span class="hljs-string">"signature"</span></span>, OctetString(bounds=(<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>))), (<span class="hljs-string"><span class="hljs-string">"identityMac"</span></span>, MAC()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandshakeTBS</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Sequence)</span></span></span><span class="hljs-class">:</span></span> schema = (( (<span class="hljs-string"><span class="hljs-string">"cookieTheir"</span></span>, Cookie()), (<span class="hljs-string"><span class="hljs-string">"cookieOur"</span></span>, Cookie()), (<span class="hljs-string"><span class="hljs-string">"pubKeyOur"</span></span>, PubKey()), )) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cookie</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(OctetString)</span></span></span><span class="hljs-class">:</span></span> bounds = (<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PubKey</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(OctetString)</span></span></span><span class="hljs-class">:</span></span> bounds = (<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MAC</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(OctetString)</span></span></span><span class="hljs-class">:</span></span> bounds = (<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre><br> HandshakeTBS — ,    (to be signed). HandshakeTBE — ,    (to be encrypted).     ukm  MsgHandshake1. 34.10 VKO,      ,   UKM (user keying material) —   . <br><br><h2>     </h2><br>        ,      (  ,     ,       ). <br><br>           ,     -  .    JSON  : <br><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">"our"</span></span>: { <span class="hljs-string"><span class="hljs-string">"prv"</span></span>: <span class="hljs-string"><span class="hljs-string">"21254cf66c15e0226ef2669ceee46c87b575f37f9000272f408d0c9283355f98"</span></span>, <span class="hljs-string"><span class="hljs-string">"pub"</span></span>: <span class="hljs-string"><span class="hljs-string">"938c87da5c55b27b7f332d91b202dbef2540979d6ceaa4c35f1b5bfca6df47df0bdae0d3d82beac83cec3e353939489d9981b7eb7a3c58b71df2212d556312a1"</span></span> }, <span class="hljs-string"><span class="hljs-string">"their"</span></span>: { <span class="hljs-string"><span class="hljs-string">"alice"</span></span>: <span class="hljs-string"><span class="hljs-string">"d361a59c25d2ca5a05d21f31168609deeec100570ac98f540416778c93b2c7402fd92640731a707ec67b5410a0feae5b78aeec93c4a455a17570a84f2bc21fce"</span></span>, <span class="hljs-string"><span class="hljs-string">"bob"</span></span>: <span class="hljs-string"><span class="hljs-string">"aade1207dd85ecd283272e7b69c078d5fae75b6e141f7649ad21962042d643512c28a2dbdc12c7ba40eb704af920919511180c18f4d17e07d7f5acd49787224a"</span></span> } }</code> </pre><br> our —   ,     . their —      .        JSON : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pygost <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gost3410 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pygost.gost34112012256 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GOST34112012256 CURVE = gost3410.GOST3410Curve( *gost3410.CURVE_PARAMS[<span class="hljs-string"><span class="hljs-string">"GostR3410_2001_CryptoPro_A_ParamSet"</span></span>] ) parser = argparse.ArgumentParser(description=<span class="hljs-string"><span class="hljs-string">"GOSTIM"</span></span>) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--keys-gen"</span></span>, action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Generate JSON with our new keypair"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--keys"</span></span>, default=<span class="hljs-string"><span class="hljs-string">"keys.json"</span></span>, required=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, help=<span class="hljs-string"><span class="hljs-string">"JSON with our and their keys"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--bind"</span></span>, default=<span class="hljs-string"><span class="hljs-string">"::1"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Address to listen on"</span></span>, ) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--port"</span></span>, type=int, default=<span class="hljs-number"><span class="hljs-number">6666</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Port to listen on"</span></span>, ) args = parser.parse_args() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.keys_gen: prv_raw = urandom(<span class="hljs-number"><span class="hljs-number">32</span></span>) pub = gost3410.public_key(CURVE, gost3410.prv_unmarshal(prv_raw)) pub_raw = gost3410.pub_marshal(pub) print(json.dumps({ <span class="hljs-string"><span class="hljs-string">"our"</span></span>: {<span class="hljs-string"><span class="hljs-string">"prv"</span></span>: hexenc(prv_raw), <span class="hljs-string"><span class="hljs-string">"pub"</span></span>: hexenc(pub_raw)}, <span class="hljs-string"><span class="hljs-string">"their"</span></span>: {}, })) exit(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Parse and unmarshal our and their keys {{{ with open(args.keys, "rb") as fd: _keys = json.loads(fd.read().decode("utf-8")) KEY_OUR_SIGN_PRV = gost3410.prv_unmarshal(hexdec(_keys["our"]["prv"])) _pub = hexdec(_keys["our"]["pub"]) KEY_OUR_SIGN_PUB = gost3410.pub_unmarshal(_pub) KEY_OUR_SIGN_PUB_HASH = OctetString(GOST34112012256(_pub).digest()) for peer_name, pub_raw in _keys["their"].items(): _pub = hexdec(pub_raw) KEYS[GOST34112012256(_pub).digest()] = { "name": peer_name, "pub": gost3410.pub_unmarshal(_pub), } # }}}</span></span></code> </pre><br>   34.10  —  .  256-  256-  . PyGOST     ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> ,     (urandom(32))    ,  gost3410.prv_unmarshal().      ,  gost3410.public_key().   34.10 —   ,            ,  gost3410.pub_marshal(). <br><br>   JSON ,  , ,   ,  gost3410.pub_unmarshal().             ,              . -256   gost34112012256.GOST34112012256(),   hashlib  -. <br><br>    ? ,    :  cookie (128-  ),    34.10,     VKO   . <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">395</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initiator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(host, port)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">396</span></span> _id = repr((host, port)) <span class="hljs-number"><span class="hljs-number">397</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: dialing"</span></span>, _id) <span class="hljs-number"><span class="hljs-number">398</span></span> reader, writer = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.open_connection(host, port) <span class="hljs-number"><span class="hljs-number">399</span></span> <span class="hljs-comment"><span class="hljs-comment"># Generate our ephemeral public key and cookie, send Handshake 0 message {{{ 400 cookie_our = Cookie(urandom(16)) 401 prv = gost3410.prv_unmarshal(urandom(32)) 402 pub_our = gost3410.public_key(CURVE, prv) 403 pub_our_raw = PubKey(gost3410.pub_marshal(pub_our)) 404 writer.write(Msg(("handshake0", MsgHandshake0(( 405 ("cookieInitiator", cookie_our), 406 ("pubKeyInitiator", pub_our_raw), 407 )))).encode()) 408 # }}} 409 await writer.drain()</span></span></code> </pre><br><ul><li>      Msg ; </li><li>    handshake1; </li><li>          ; </li><li>       TBE  . </li></ul><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">423</span></span> logging.info(<span class="hljs-string"><span class="hljs-string">"%s: got %s message"</span></span>, _id, msg.choice) <span class="hljs-number"><span class="hljs-number">424</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msg.choice != <span class="hljs-string"><span class="hljs-string">"handshake1"</span></span>: <span class="hljs-number"><span class="hljs-number">425</span></span> logging.warning(<span class="hljs-string"><span class="hljs-string">"%s: unexpected message, disconnecting"</span></span>, _id) <span class="hljs-number"><span class="hljs-number">426</span></span> writer.close() <span class="hljs-number"><span class="hljs-number">427</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">428</span></span> <span class="hljs-comment"><span class="hljs-comment"># }}} 429 msg_handshake1 = msg.value 430 # Validate Handshake message {{{ 431 cookie_their = msg_handshake1["cookieResponder"] 432 pub_their_raw = msg_handshake1["pubKeyResponder"] 433 pub_their = gost3410.pub_unmarshal(bytes(pub_their_raw)) 434 ukm_raw = bytes(msg_handshake1["ukm"]) 435 ukm = ukm_unmarshal(ukm_raw) 436 key_session = kek_34102012256(CURVE, prv, pub_their, ukm, mode=2001) 437 kdf = Hkdf(None, key_session, hash=GOST34112012256) 438 key_handshake1_mac_identity = kdf.expand(b"handshake1-mac-identity") 439 key_handshake1_enc = kdf.expand(b"handshake1-enc") 440 key_handshake1_mac = kdf.expand(b"handshake1-mac")</span></span></code> </pre><br> UKM  64-  (urandom(8)),       ,  gost3410_vko.ukm_unmarshal(). VKO   34.10-2012 256-  gost3410_vko.kek_34102012256() (KEK — key encryption key). <br><br>      256-   .        HKDF .   GOST34112012256  hashlib ,        Hkdf .  (  Hkdf)   ,     -               . kdf.expand()       256-,     . <br><br>   TBE  TBS   : <br><br><ul><li>    MAC   ; </li><li>  ; </li><li>  TBE ; </li><li>            ; </li><li>    MAC   ; </li><li>    TBS ,    cookie        .      . </li></ul><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">441</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-number"><span class="hljs-number">442</span></span> peer_name = validate_tbe( <span class="hljs-number"><span class="hljs-number">443</span></span> msg_handshake1, <span class="hljs-number"><span class="hljs-number">444</span></span> key_handshake1_mac_identity, <span class="hljs-number"><span class="hljs-number">445</span></span> key_handshake1_enc, <span class="hljs-number"><span class="hljs-number">446</span></span> key_handshake1_mac, <span class="hljs-number"><span class="hljs-number">447</span></span> cookie_our, <span class="hljs-number"><span class="hljs-number">448</span></span> cookie_their, <span class="hljs-number"><span class="hljs-number">449</span></span> pub_their_raw, <span class="hljs-number"><span class="hljs-number">450</span></span> ) <span class="hljs-number"><span class="hljs-number">451</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> err: <span class="hljs-number"><span class="hljs-number">452</span></span> logging.warning(<span class="hljs-string"><span class="hljs-string">"%s: %s, disconnecting"</span></span>, _id, err) <span class="hljs-number"><span class="hljs-number">453</span></span> writer.close() <span class="hljs-number"><span class="hljs-number">454</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">455</span></span> <span class="hljs-comment"><span class="hljs-comment"># }}} 128 def validate_tbe( 129 msg_handshake: Union[MsgHandshake1, MsgHandshake2], 130 key_mac_identity: bytes, 131 key_enc: bytes, 132 key_mac: bytes, 133 cookie_their: Cookie, 134 cookie_our: Cookie, 135 pub_key_our: PubKey, 136 ) -&gt; str: 137 ciphertext = bytes(msg_handshake["ciphertext"]) 138 mac_tag = mac(GOST3412Kuznechik(key_mac).encrypt, KUZNECHIK_BLOCKSIZE, ciphertext) 139 if not compare_digest(mac_tag, bytes(msg_handshake["ciphertextMac"])): 140 raise ValueError("invalid MAC") 141 plaintext = ctr( 142 GOST3412Kuznechik(key_enc).encrypt, 143 KUZNECHIK_BLOCKSIZE, 144 ciphertext, 145 8 * b"\x00", 146 ) 147 try: 148 tbe, _ = HandshakeTBE().decode(plaintext) 149 except ASN1Error: 150 raise ValueError("can not decode TBE") 151 key_sign_pub_hash = bytes(tbe["identity"]) 152 peer = KEYS.get(key_sign_pub_hash) 153 if peer is None: 154 raise ValueError("unknown identity") 155 mac_tag = mac( 156 GOST3412Kuznechik(key_mac_identity).encrypt, 157 KUZNECHIK_BLOCKSIZE, 158 key_sign_pub_hash, 159 ) 160 if not compare_digest(mac_tag, bytes(tbe["identityMac"])): 161 raise ValueError("invalid identity MAC") 162 tbs = HandshakeTBS(( 163 ("cookieTheir", cookie_their), 164 ("cookieOur", cookie_our), 165 ("pubKeyOur", pub_key_our), 166 )) 167 if not gost3410.verify( 168 CURVE, 169 peer["pub"], 170 GOST34112012256(tbs.encode()).digest(), 171 bytes(tbe["signature"]), 172 ): 173 raise ValueError("invalid signature") 174 return peer["name"]</span></span></code> </pre><br>    , 34.13-2015   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   </a>  34.12-2015.      ,  MAC-.  PyGOST  gost3413.mac().       (     ),   , ,  .   hardcode-  ? 34.12-2015    128-  ,    64- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> —    28147-89,               . <br><br>   gost.3412.GOST3412Kuznechik(key)      .encrypt()/.decrypt() ,     34.13 . MAC   : gost3413.mac(GOST3412Kuznechik(key).encrypt, KUZNECHIK_BLOCKSIZE, ciphertext).      MAC-     (==)  ,        , ,   ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BEAST</a>   TLS.  Python   hmac.compare_digest   . <br><br>         .   ,      ,    .  34.13-2015  : ECB, CTR, OFB, CBC, CFB.        .   ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a> ( CCM, OCB, GCM  ) —       MAC.   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> (CTR):       ,  ,    ,          (   CBC,      ). <br><br>   .mac(), .ctr()     : ciphertext = gost3413.ctr(GOST3412Kuznechik(key).encrypt, KUZNECHIK_BLOCKSIZE, plaintext, iv).    ,     .           (    ),      .   handshake        . <br><br>   gost3410.verify() :        (      GOSTIM ),    ( ,         ,    ), 34.11-2012     . <br><br> ,       handshake2  ,           ,  :      ,  .… <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">456</span></span> <span class="hljs-comment"><span class="hljs-comment"># Prepare and send Handshake 2 message {{{ 457 tbs = HandshakeTBS(( 458 ("cookieTheir", cookie_their), 459 ("cookieOur", cookie_our), 460 ("pubKeyOur", pub_our_raw), 461 )) 462 signature = gost3410.sign( 463 CURVE, 464 KEY_OUR_SIGN_PRV, 465 GOST34112012256(tbs.encode()).digest(), 466 ) 467 key_handshake2_mac_identity = kdf.expand(b"handshake2-mac-identity") 468 mac_tag = mac( 469 GOST3412Kuznechik(key_handshake2_mac_identity).encrypt, 470 KUZNECHIK_BLOCKSIZE, 471 bytes(KEY_OUR_SIGN_PUB_HASH), 472 ) 473 tbe = HandshakeTBE(( 474 ("identity", KEY_OUR_SIGN_PUB_HASH), 475 ("signature", OctetString(signature)), 476 ("identityMac", MAC(mac_tag)), 477 )) 478 tbe_raw = tbe.encode() 479 key_handshake2_enc = kdf.expand(b"handshake2-enc") 480 key_handshake2_mac = kdf.expand(b"handshake2-mac") 481 ciphertext = ctr( 482 GOST3412Kuznechik(key_handshake2_enc).encrypt, 483 KUZNECHIK_BLOCKSIZE, 484 tbe_raw, 485 8 * b"\x00", 486 ) 487 mac_tag = mac( 488 GOST3412Kuznechik(key_handshake2_mac).encrypt, 489 KUZNECHIK_BLOCKSIZE, 490 ciphertext, 491 ) 492 writer.write(Msg(("handshake2", MsgHandshake2(( 493 ("ciphertext", OctetString(ciphertext)), 494 ("ciphertextMac", MAC(mac_tag)), 495 )))).encode()) 496 # }}} 497 await writer.drain() 498 logging.info("%s: session established: %s", _id, peer_name)</span></span></code> </pre><br>   ,     (   ,  ,    ),       MAC-: <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">499</span></span> <span class="hljs-comment"><span class="hljs-comment"># Run text message sender, initialize transport decoder {{{ 500 key_initiator_enc = kdf.expand(b"transport-initiator-enc") 501 key_initiator_mac = kdf.expand(b"transport-initiator-mac") 502 key_responder_enc = kdf.expand(b"transport-responder-enc") 503 key_responder_mac = kdf.expand(b"transport-responder-mac") ... 509 asyncio.ensure_future(msg_sender( 510 peer_name, 511 key_initiator_enc, 512 key_initiator_mac, 513 writer, 514 )) 515 encrypter = GOST3412Kuznechik(key_responder_enc).encrypt 516 macer = GOST3412Kuznechik(key_responder_mac).encrypt 517 # }}} 519 nonce_expected = 0 520 # Wait for test messages {{{ 521 while True: 522 data = await reader.read(MaxMsgLen) ... 530 msg, tail = Msg().decode(buf) ... 537 try: 538 await msg_receiver( 539 msg.value, 540 nonce_expected, 541 macer, 542 encrypter, 543 peer_name, 544 ) 545 except ValueError as err: 546 logging.warning("%s: %s", err) 547 break 548 nonce_expected += 1 549 # }}}</span></span></code> </pre><br> msg_sender    ,    TCP-.      nonce,          .           . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg_sender</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(peer_name: str, key_enc: bytes, key_mac: bytes, writer)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> nonce = <span class="hljs-number"><span class="hljs-number">0</span></span> encrypter = GOST3412Kuznechik(key_enc).encrypt macer = GOST3412Kuznechik(key_mac).encrypt in_queue = IN_QUEUES[peer_name] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> in_queue.get() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> text <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> ciphertext = ctr( encrypter, KUZNECHIK_BLOCKSIZE, text.encode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>), long2bytes(nonce, <span class="hljs-number"><span class="hljs-number">8</span></span>), ) payload = MsgTextPayload(( (<span class="hljs-string"><span class="hljs-string">"nonce"</span></span>, Integer(nonce)), (<span class="hljs-string"><span class="hljs-string">"ciphertext"</span></span>, OctetString(ciphertext)), )) mac_tag = mac(macer, KUZNECHIK_BLOCKSIZE, payload.encode()) writer.write(Msg((<span class="hljs-string"><span class="hljs-string">"text"</span></span>, MsgText(( (<span class="hljs-string"><span class="hljs-string">"payload"</span></span>, payload), (<span class="hljs-string"><span class="hljs-string">"payloadMac"</span></span>, MAC(mac_tag)), )))).encode()) nonce += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>     msg_receiver,    : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg_receiver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( msg_text: MsgText, nonce_expected: int, macer, encrypter, peer_name: str, )</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> payload = msg_text[<span class="hljs-string"><span class="hljs-string">"payload"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> int(payload[<span class="hljs-string"><span class="hljs-string">"nonce"</span></span>]) != nonce_expected: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"unexpected nonce value"</span></span>) mac_tag = mac(macer, KUZNECHIK_BLOCKSIZE, payload.encode()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> compare_digest(mac_tag, bytes(msg_text[<span class="hljs-string"><span class="hljs-string">"payloadMac"</span></span>])): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"invalid MAC"</span></span>) plaintext = ctr( encrypter, KUZNECHIK_BLOCKSIZE, bytes(payload[<span class="hljs-string"><span class="hljs-string">"ciphertext"</span></span>]), long2bytes(nonce_expected, <span class="hljs-number"><span class="hljs-number">8</span></span>), ) text = plaintext.decode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> OUT_QUEUES[peer_name].put(text)</code> </pre><br><h2> 结论 </h2><br> GOSTIM       (    ,  )!      <a href=""></a> (-256 : 995bbd368c04e50a481d138c5fa2e43ec7c89bc77743ba8dbabee1fde45de120).     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GoGOST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PyDERASN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NNCP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GoVPN</a> , GOSTIM   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GPLv3+</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> , Python/Go-,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> « „“</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN452200/">https://habr.com/ru/post/zh-CN452200/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN452186/index.html">最稀有和最昂贵的编程语言</a></li>
<li><a href="../zh-CN452188/index.html">Spring Boot中的Json序列化单元测试</a></li>
<li><a href="../zh-CN452190/index.html">加速使用WebAssembly 20x Web应用程序</a></li>
<li><a href="../zh-CN452192/index.html">这是什么 JavaScript对象的内部操作</a></li>
<li><a href="../zh-CN452198/index.html">每个QA工程师应该对Selenium 4了解什么？</a></li>
<li><a href="../zh-CN452202/index.html">冲刺回顾：底部-底部</a></li>
<li><a href="../zh-CN452204/index.html">当我写我的第一个AI时</a></li>
<li><a href="../zh-CN452206/index.html">E-实验。 还是科学如何帮助设计界面</a></li>
<li><a href="../zh-CN452210/index.html">一个小时内用MySQL在Python上使用VK进行Bot训练，第2部分</a></li>
<li><a href="../zh-CN452212/index.html">初创企业如何前往美国：3种真实的签证选择，其功能和统计数据</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>