<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍴 📄 ◼️ Koleksi serentak dalam 10 menit 📚 🐼 🌮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foto oleh Robert V. Ruggiero 

 Topiknya bukan baru. Tetapi menanyakan pertanyaan, "Apa koleksi bersamaan dan kapan menggunakannya?" pada wawancara at...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Koleksi serentak dalam 10 menit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473352/"><img src="https://habrastorage.org/webt/kb/ml/25/kbml25hqd_fuejwsjqee8tcczkc.jpeg" alt="gambar"><br>  <sup>Foto oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Robert V. Ruggiero</a></sup> <br><br>  Topiknya bukan baru.  Tetapi menanyakan pertanyaan, "Apa koleksi bersamaan dan kapan menggunakannya?"  pada wawancara atau review kode, saya hampir selalu mendapatkan jawaban yang terdiri dari satu kalimat: "mereka benar-benar melindungi kita dari kondisi ras" (yang tidak mungkin bahkan dalam teori).  Atau: "ini seperti koleksi biasa, tetapi semua yang ada di dalamnya terkunci", yang juga tidak sesuai dengan kenyataan. <br><br>  Tujuan artikel ini adalah untuk melihat topik dalam 10 menit.  Ini akan berguna untuk berkenalan singkat dengan beberapa kehalusan.  Atau untuk menyegarkan ingatan Anda sebelum wawancara. <br><a name="habracut"></a><br>  Pertama-tama, kita akan melihat isi <i>System.Collections.Concurrent</i> namespace.  Kemudian kita membahas perbedaan utama antara koleksi konkuren dan klasik, perhatikan beberapa poin yang tidak jelas.  Sebagai kesimpulan, kami membahas kemungkinan jebakan dan kapan jenis koleksi apa yang layak digunakan. <br><br><h2>  Apa yang ada di System.Collections.Concurrent </h2><br>  Intellisense memberi tahu Anda sedikit: <br><br><img src="https://habrastorage.org/webt/sg/sz/ln/sgszlno_zqfuxizry5q5rll48m8.png" alt="gambar"><br><br>  Mari kita bahas secara singkat tujuan setiap kelas. <br><br>  <b>ConcurrentDictionary</b> : Kumpulan thread-aman, tujuan umum yang berlaku untuk berbagai skenario. <br><br>  <b>ConcurrentBag, ConcurrentStack, ConcurrentQueue</b> : Koleksi Tujuan Khusus.  “Spesialisasi” terdiri dari poin-poin berikut: <br><br><ul><li>  Kurangnya API untuk mengakses elemen sewenang-wenang </li><li>  <i>Stack</i> and <i>Queue</i> (seperti yang kita semua tahu) memiliki urutan tertentu untuk menambahkan dan mengekstraksi elemen </li><li>  <i>ConcurrentBag</i> untuk setiap utas memiliki koleksi sendiri untuk menambahkan item.  Saat mengambil, itu "mencuri" elemen dari aliran tetangga jika koleksi kosong untuk aliran saat ini </li></ul><br>  <b>IProducerConsumerCollection</b> - kontrak yang digunakan oleh kelas <i>BlockingCollection</i> (lihat di bawah).  Diimplementasikan oleh koleksi <i>ConcurrentStack</i> , <i>ConcurrentQueue,</i> dan <i>ConcurrentBag</i> . <br><br>  <b>BlockingCollection</b> - digunakan dalam skenario ketika beberapa utas mengisi koleksi, sementara yang lain mengekstrak elemen darinya.  Contoh khas adalah antrian tugas yang diisi ulang.  Jika koleksi kosong pada saat permintaan elemen berikutnya, maka pembaca masuk ke status menunggu elemen baru (polling).  Dengan memanggil metode <i>CompleteAdding ()</i> , kami dapat menunjukkan bahwa koleksi tidak akan diisi ulang, maka ketika membaca polling tidak akan dilakukan.  Anda dapat memeriksa status koleksi menggunakan properti <i>IsAddingCompleted</i> ( <i>true</i> jika data tidak lagi ditambahkan) dan <i>IsCompleted</i> ( <i>true</i> jika data tidak lagi ditambahkan dan koleksi kosong). <br><br>  <b>Partitioner, OrderablePartitioner, EnumerablePartitionerOptions</b> - konstruksi dasar untuk mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">segmentasi koleksi</a> .  Digunakan oleh metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Parallel.ForEach</a> untuk menentukan cara mendistribusikan item di seluruh thread pemrosesan. <br><br>  Nanti di artikel, kita akan fokus pada koleksi: <i>ConcurrentDictionary</i> dan <i>ConcurrentBag / Stack / Queue</i> . <br><br><h2>  Perbedaan antara koleksi konkuren dan klasik </h2><br><h3>  Perlindungan negara internal </h3><br>  Koleksi klasik dirancang dengan kinerja maksimal, jadi metode instan mereka tidak menjamin keamanan benang. <br><br>  Sebagai contoh, lihat kode sumber untuk metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dictionary.Add</a> . <br>  Kita dapat melihat baris berikut (kode disederhanakan agar mudah dibaca): <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._buckets == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prime = HashHelpers.GetPrime(capacity); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._buckets = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[prime]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._entries = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;TKey, TValue&gt;.Entry[prime]; }</code> </pre> <br>  Seperti yang dapat kita lihat, kondisi internal kamus tidak dilindungi.  Saat menambahkan item dari beberapa utas, skenario berikut ini dimungkinkan: <br><br><ol><li>  Utas 1 disebut <i>Tambah</i> , eksekusi berhenti segera setelah memasuki kondisi <i>if</i> </li><li>  Thread 2 disebut <i>Tambah</i> , menginisialisasi koleksi, menambahkan item </li><li>  Stream 1 kembali bekerja, menginisialisasi ulang koleksi, sehingga menghancurkan data yang ditambahkan oleh stream 2. </li></ol><br>  Artinya, koleksi klasik tidak cocok untuk merekam dari berbagai aliran. <br><br><h3>  API toleran terhadap keadaan koleksi saat ini. </h3><br>  Seperti yang kita ketahui, kunci duplikat tidak dapat ditambahkan ke <i>Kamus</i> .  Jika kita memanggil <i>Tambah</i> dua kali dengan kunci yang sama, panggilan kedua akan membuang <i>ArgumentException</i> . <br><br>  Perlindungan ini berguna dalam skenario single-threaded.  Tetapi dengan multithreading, kami tidak dapat memastikan keadaan koleksi saat ini.  Secara alami, cek seperti berikut ini menyelamatkan kami hanya jika kami terus-menerus mengunci diri: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dictionary.ContainsKey(key)) { dictionary.Add(key, “Hello”); }</code> </pre><br>  API berbasis pengecualian adalah opsi yang buruk dan tidak akan memungkinkan perilaku yang stabil dan dapat diprediksi dalam skenario multi-utas.  Alih-alih, Anda memerlukan API yang tidak membuat asumsi tentang keadaan koleksi saat ini, tidak memberikan pengecualian, dan menyerahkan keputusan tentang diterimanya status kepada penelepon. <br><br>  Dalam koleksi bersamaan, API dibangun di atas pola <i>TryXXX</i> .  Alih-alih biasa <i>Tambahkan</i> , <i>Dapatkan</i> dan <i>Hapus,</i> kami menggunakan metode <i>TryAdd</i> , <i>TryGetValue</i> dan <i>TryRemove</i> .  Dan, jika metode ini menghasilkan <i>false</i> , maka kami memutuskan apakah ini situasi yang luar biasa atau tidak. <br><br>  Perlu dicatat bahwa koleksi klasik sekarang juga memiliki metode yang toleran terhadap negara.  Tetapi dalam koleksi klasik, API seperti itu adalah tambahan yang bagus, dan dalam koleksi bersamaan, itu adalah suatu keharusan. <br><br><h3>  API meminimalkan kondisi balapan </h3><br>  Pertimbangkan operasi pembaruan elemen paling sederhana: <br><br><pre> <code class="java hljs">dictionary[key] += <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Untuk semua kesederhanaannya, kode melakukan tiga tindakan: ia mendapat nilai dari koleksi, menambahkan 1, menulis nilai baru.  Dalam eksekusi multi-utas, ada kemungkinan bahwa kode mengambil nilai, melakukan kenaikan, dan kemudian dengan aman menghapus nilai yang ditulis oleh utas lain saat kenaikan berjalan. <br><br>  Untuk mengatasi masalah tersebut, API koleksi bersamaan berisi sejumlah metode pembantu.  Misalnya, metode <i>TryUpdate</i> , yang mengambil tiga parameter: kunci, nilai baru, dan nilai saat ini yang diharapkan.  Jika nilai dalam koleksi tidak sesuai dengan yang diharapkan, maka pembaruan tidak akan dilakukan dan metode akan kembali <i>salah</i> . <br><br>  Pertimbangkan contoh lain.  Secara harfiah setiap baris kode berikut (termasuk <i>Console.WriteLine</i> ) dapat menyebabkan masalah dengan eksekusi multi-utas: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dictionary.ContainsKey(key)) { dictionary[key] += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dictionary.Add(key, <span class="hljs-number"><span class="hljs-number">1</span></span>); } Console.WriteLine(dictionary[key]);</code> </pre><br>  Menambah atau memperbarui nilai, dan kemudian melakukan operasi dengan hasilnya, adalah tugas yang cukup umum.  Oleh karena itu, kamus bersamaan memiliki metode <i>AddOrUpdate</i> , yang melakukan urutan tindakan dalam satu panggilan dan aman utas: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = dictionary.AddOrUpdate(key, <span class="hljs-number"><span class="hljs-number">1</span></span>, (itemKey, itemValue) =&gt; itemValue + <span class="hljs-number"><span class="hljs-number">1</span></span>); Console.WriteLine(result);</code> </pre><br>  Ada satu hal yang perlu diketahui. <br><br>  Penerapan metode <i>AddOrUpdate</i> memanggil metode <i>TryUpdate</i> yang dijelaskan di atas dan meneruskan nilai saat ini dari koleksi ke sana.  Jika pembaruan gagal (utas tetangga telah mengubah nilainya), maka upaya tersebut diulangi dan delegasi pembaruan yang ditransmisikan dipanggil lagi dengan nilai saat ini yang diperbarui.  Artinya, <i>delegasi pembaruan dapat dipanggil beberapa kali</i> , jadi tidak boleh mengandung efek samping. <br><br><h3>  Kunci algoritma gratis dan kunci granular </h3><br>  Microsoft melakukan pekerjaan besar pada kinerja koleksi bersamaan, dan tidak hanya membungkus semua operasi dengan kunci.  Mempelajari sumbernya, Anda dapat melihat banyak contoh penggunaan kunci granular, penggunaan algoritma yang kompeten, bukan kunci, serta penggunaan instruksi khusus dan primitif sinkronisasi yang lebih "ringan" daripada <i>Monitor</i> . <br><br><h2>  Apa koleksi bersamaan tidak memberikan </h2><br>  Dari contoh di atas, jelas bahwa koleksi konkuren tidak memberikan perlindungan lengkap terhadap kondisi ras dan kami harus merancang kode kami sesuai.  Tapi itu belum semua, ada beberapa poin yang perlu diketahui. <br><br><h3>  Polimorfisme dengan koleksi klasik </h3><br>  Koleksi bersamaan, seperti yang klasik, mengimplementasikan antarmuka <i>IDictionary</i> , <i>ICollection</i> , dan <i>IEnumerable</i> .  Tetapi bagian dari API dari antarmuka ini tidak dapat didefinisikan dengan aman menurut definisi.  Misalnya, metode <i>Tambahkan</i> , yang kita bahas di atas. <br><br>  Pengumpulan serentak menerapkan kontrak semacam itu tanpa pengaman benang.  Dan untuk "menyembunyikan" API tidak aman, mereka menggunakan implementasi eksplisit dari antarmuka.  Ini patut diingat ketika kita meneruskan koleksi bersamaan ke metode yang mengambil input, misalnya, ICollection. <br><br>  Juga, koleksi bersamaan tidak mematuhi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prinsip substitusi Liskov</a> sehubungan dengan koleksi klasik. <br><br>  Misalnya, konten koleksi klasik tidak dapat diubah selama <i>iterasi</i> , kode berikut akan melempar <i>InvalidOperationException</i> untuk kelas <i>Daftar</i> : <br><br><pre> <code class="java hljs">foreach (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element in list) { list.Remove(element); }</code> </pre><br>  Jika kita berbicara tentang koleksi bersamaan, maka modifikasi pada saat pencacahan tidak mengarah pada pengecualian, sehingga kita dapat melakukan membaca dan menulis secara simultan dari aliran yang berbeda. <br><br>  Selain itu, koleksi bersamaan secara berbeda menerapkan kemungkinan modifikasi selama enumerasi.  <i>ConcurrentDictionary</i> hanya tidak melakukan pemeriksaan dan tidak menjamin hasil iterasi, dan <i>ConcurrentStack / Antrian / Tas</i> mengunci dan membuat salinan dari kondisi saat ini, yang iterate melalui. <br><br><h3>  Kemungkinan masalah kinerja </h3><br>  Kami sebutkan di atas bahwa <i>ConcurrentBag</i> dapat "mencuri" elemen dari utas tetangga.  Ini dapat menyebabkan masalah kinerja jika Anda menulis dan membaca ke <i>ConcurrentBag</i> dari utas yang berbeda. <br><br>  Juga, koleksi bersamaan memaksakan kunci lengkap ketika menanyakan keadaan seluruh koleksi ( <i>Count</i> , <i>IsEmpty</i> , <i>GetEnumerator</i> , <i>ToArray</i> , dll.) Dan karena itu secara signifikan lebih lambat daripada rekan-rekan klasik mereka. <br><br>  Kesimpulan: menggunakan koleksi bersamaan hanya layak jika mereka benar-benar diperlukan, karena pilihan ini tidak "gratis". <br><br><h2>  Kapan koleksi jenis apa yang digunakan </h2><br><ul><li>  Skrip berulir tunggal: hanya koleksi klasik dengan kinerja terbaik. </li><li>  Rekam dari berbagai aliran: hanya koleksi bersamaan yang melindungi keadaan internal dan memiliki API yang sesuai untuk perekaman kompetitif. </li><li>  Membaca dari berbagai utas: tidak ada rekomendasi yang pasti.  Koleksi bersamaan dapat menciptakan masalah kinerja dengan permintaan negara intensif untuk seluruh koleksi.  Namun, untuk koleksi klasik, Microsoft tidak menjamin kinerja bahkan untuk operasi baca.  Misalnya, implementasi internal koleksi mungkin memiliki properti malas yang dimulai saat membaca data dan, oleh karena itu, dimungkinkan untuk menghancurkan keadaan internal saat membaca dari beberapa utas.  Pilihan rata-rata yang bagus adalah menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">koleksi tidak berubah</a> . </li><li>  Dan membaca dan menulis dari berbagai utas: koleksi bersamaan yang unik, baik yang menerapkan perlindungan negara dan API yang aman. </li></ul><br><h2>  Kesimpulan </h2><br>  Dalam artikel ini, kami secara singkat mempelajari koleksi bersamaan, kapan menggunakannya dan spesifikasinya apa.  Tentu saja, artikel tersebut tidak menguras topik, dan dengan kerja serius dengan koleksi multithreaded, Anda harus menggali lebih dalam.  Cara termudah untuk melakukan ini adalah dengan melihat kode sumber koleksi yang digunakan.  Ini informatif dan sama sekali tidak rumit, kodenya sangat, sangat mudah dibaca. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473352/">https://habr.com/ru/post/id473352/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473342/index.html">"Jalan panjang sedang menunggu Anda ..." atau menyelesaikan masalah perkiraan di C # menggunakan Ml.NET (DataScience)</a></li>
<li><a href="../id473344/index.html">Konser dan acara KudaGo di cermin Anda</a></li>
<li><a href="../id473346/index.html">Membuat API REST dengan Node.js dan Oracle Database. Bagian 2</a></li>
<li><a href="../id473348/index.html">Ide inersia (SGDm), gagasan scaling (Adagrad) dan regularisasi dalam pembelajaran mesin menggunakan masalah klasifikasi sebagai contoh</a></li>
<li><a href="../id473350/index.html">Membuat API REST dengan Node.js dan Oracle Database. Bagian 3</a></li>
<li><a href="../id473354/index.html">Tentang keanehan habrostatistics</a></li>
<li><a href="../id473358/index.html">Instal dan konfigurasikan Nexus Sonatype menggunakan infrastruktur sebagai pendekatan kode</a></li>
<li><a href="../id473362/index.html">Pengalaman GSoC: Bagaimana Dua (Tiga) Siswa Benar-Benar Meningkatkan Kode CRIU</a></li>
<li><a href="../id473364/index.html">Ada goby, berayun: daftar periksa untuk e-commerce di musim penjualan</a></li>
<li><a href="../id473366/index.html">Apa yang ada di tv pintar saya untuk Anda? Atau apa yang bisa dijejalkan ke TV?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>