<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎫 🧙🏿 🐒 Rétro-ingénierie du firmware de l'appareil en utilisant l'exemple d'un «rhinocéros» clignotant. 2e partie 👩‍🎤 ✳️ 🚮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous présentons à votre attention la deuxième partie de l'article sur la rétro-ingénierie du firmware du dispositif Flashing Rhino basé sur un atelier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rétro-ingénierie du firmware de l'appareil en utilisant l'exemple d'un «rhinocéros» clignotant. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/inforion/blog/412561/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ny/yo/jz/nyyojzktr_-hcfv4j7ygq_eaiuu.png"></div><br>  Nous présentons à votre attention la deuxième partie de l'article sur la rétro-ingénierie du firmware du dispositif Flashing Rhino basé sur un atelier à la conférence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SMARTRHINO-2018</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dans la première partie de l'</a> article, le micrologiciel du périphérique a été chargé dans le désassembleur IDA et une analyse initiale des commandes de protocole du périphérique a été effectuée.  Les commandes individuelles ont été testées sur un appareil fonctionnel. <br><br>  Dans la deuxième partie, une analyse des tâches restantes du firmware sera effectuée. <br><br>  Permettez-moi de vous rappeler qu'après avoir analysé la tâche Bluetooth en termes de contrôle des LED, il a été décidé de passer à la tâche LED, car la tâche initiale consiste à créer une application pour contrôler les LED, et pour cela une compréhension détaillée du fonctionnement du firmware est nécessaire. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le fichier du firmware</a> est disponible pour étude indépendante. <br><br>  <i>Toutes les informations sont fournies à des fins éducatives uniquement.</i> <br><br>  Sous le chat, il y a beaucoup de rhinocéros clignotants. <br><a name="habracut"></a><br><h2>  Tâche LED </h2><br>  <i>En bref: une analyse complète de la tâche responsable de la commutation des LED.</i>  <i>Analyse des types de données et des variables globales.</i> <br><br>  La tâche LED est représentée par la fonction <b>x_leds_task</b> , située à <code>0x08005A08</code> . <br><br>  En plus des étranges lignes «J'ai une super puissance ...» dans la fonction principale de la tâche LED, vous pouvez faire attention à la ligne <b>«teinte&gt; max: changer l'éclat \ r \ n»</b> . <br><br><img src="https://habrastorage.org/webt/6j/7u/qv/6j7uqvcupizmfsbqca81as5dwlw.png"><br><br>  En même temps, nous voyons une situation familière - (WORD *) (v26 + 4).  Dans le menu contextuel de la variable v26, sélectionnez l'élément "Convertir en struct *", puis indiquez la structure créée précédemment: <br><br><img src="https://habrastorage.org/webt/6a/2i/jv/6a2ijvqm631yl3ce5z6uom02znw.png"><br><br>  Étant donné que <code>v5 = v26</code> , nous répétons l'opération <i>«Convertir en struct *»</i> pour la variable v5. <br><br>  Nous continuons de structurer le code et les données.  Définissez la représentation hexadécimale partout.  Renommer: <br><br><ul><li>  v5 - <b>led</b> ; </li><li>  v6 - <b>idx</b> ; </li><li>  v8 - <b>hue_1</b> ; </li><li>  v9 - <b>hue_2</b> ; </li><li>  v26 - <b>_led</b> ; </li></ul><br>  Le code s'améliore.  Mais certaines variables font toujours mal à l'œil, par exemple, la variable v23: <br><br><img src="https://habrastorage.org/webt/pz/cp/ch/pzcpchfjgrlwgwwtbun85x6weve.png"><br><br><img src="https://habrastorage.org/webt/k1/4k/fi/k14kfil99uzjgtwdpimtjcrl-ye.png"><br><br><div class="spoiler">  <b class="spoiler_title">Apparemment, la v23 est un tableau de 4 octets.</b> <div class="spoiler_text">  idx est l'indice de la LED;  cet index est ajouté à l'adresse de base;  de cette façon, l'accès est fait aux éléments avec les mêmes déplacements - c'est ainsi que se comportent les tableaux. <br></div></div><br>  On assigne le type <code>char v23[4]</code> et on le renomme <b>leds_smth</b> , le code devient plus joli: <br><br><img src="https://habrastorage.org/webt/3a/zp/vv/3azpvvasy-8oabd8be6tshcy6z8.png"><br><br>  Vous pouvez également noter que le résultat de la fonction x_queue_recv est retourné à la variable v25: <br><br><pre> <code class="cpp hljs">x_queue_recv(&amp;v25, leds_queue, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  Mais il se peut que la façon dont les données dont vous avez besoin se <i>trouvent</i> dans la structure <i>_led</i> ne soit pas claire.  Le fait est que les variables v25 et _led <b><i>sont situées à proximité de la pile</i></b> - cela peut être compris par le fait que dans la décompilation, elles sont écrites sur des lignes adjacentes.  L'emplacement des variables sur la pile peut être vu dans une fenêtre séparée si vous double-cliquez sur la variable: <br><br><img src="https://habrastorage.org/webt/gm/1z/qs/gm1zqsoxvvppvneguj76arsppdu.png"><br><br>  Il s'agit probablement d'une structure, ou le compilateur a effectué une optimisation.  Ainsi, on peut affirmer que les données de la tâche Bluetooth sont transmises à la tâche LED.  Pour le savoir plus précisément, je vais vérifier sur l'appareil - pour la LED zéro via Bluetooth j'enverrai les valeurs <b>0x208</b> , <b>0x2D0</b> , <b>0x398</b> , <b>0x3E9</b> , qui pourraient être remarquées dans le code: <br><br><img src="https://habrastorage.org/webt/f-/1k/ds/f-1kdsphlzdbhuc4q6dwtfk6zge.png"><br><br>  Les résultats de la vérification de la valeur de teinte sur l'appareil: <br><br><ul><li>  0x208 - les LED ont cessé de commuter en douceur et ont été réglées dans les couleurs: rouge, vert, bleu, violet; </li><li>  0x2D0 - les LED ont recommencé à commuter; </li><li>  0x398 - rien n'a changé; </li><li>  0x3E9 - rien n'a changé. </li></ul><br>  Si vous regardez à nouveau le code, vous pouvez voir que la valeur 0x398 peut être associée logiquement à une valeur inférieure à 0x167 (différentes valeurs sont définies pour l'élément de tableau <i>leds_smth</i> ).  Par conséquent, je vais effectuer cette vérification: d'abord, je vais mettre la première LED sur vert (teinte = 0x78, <code>LED 010078FF20</code> ), tandis que les trois autres LED continuent de changer de couleur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5h/mp/dc/5hmpdckwscpkhlgvth05w1xvmuy.gif"></div><br>  Maintenant, je vais <code>LED 010398FFFF</code> protocole Bluetooth <code>LED 010398FFFF</code> - après cela, la première LED est passée en mode de commutation de couleur générale. <br><br>  Ainsi, la valeur de teinte de 0x398 réinitialise la valeur de couleur statique, ce qui signifie que le tableau leds_smth contient des drapeaux (0 ou 1) pour les LED à occuper: <br><br><ul><li>  0 - la LED n'est pas occupée, participe à une commutation de couleur fluide ( <b>teinte = 0x398</b> ); </li><li>  1 - la LED est occupée, l'utilisateur a défini une couleur statique ( <b>teinte &lt;= 0x167</b> ). </li></ul><br>  Renommez leds_smth en <b>leds_busy</b> . <br><br>  Le but du bloc de code suivant devrait maintenant devenir clair: <br><br><img src="https://habrastorage.org/webt/sb/x8/mf/sbx8mfnnah6gziclrsqmgdcmpu0.png"><br><br>  Le cycle des lignes 83-101 effectue une mosaïque de couleurs lisse avec une étape de changement de couleur de 5: <code>v12 += 5</code> .  Si la LED a une couleur statique allumée, alors cette LED ne participe pas à la mosaïque.  Après le cycle, il y a des lignes d'inclusion à court terme de toutes les LED. <br><br>  Renommer: <br><br><ul><li>  sub_800678A - <b>x_led_set_hsv</b> ; </li><li>  v12 - <b>hue_step</b> ; </li><li>  v13, v17, v18, v19 - <b>led0_busy</b> , <b>led1_busy</b> , <b>led2_busy</b> , <b>led3_busy</b> ; </li><li>  v11, v20, v21, v22 - <b>teinte0</b> , <b>teinte1</b> , <b>teinte2</b> , <b>teinte3</b> ; </li><li>  dword_200004C4 - <b>led_control</b> . </li></ul><br>  La fonction sub_80039FE effectue vraisemblablement un timeout (sinon les LED n'ont pas commuté en douceur, mais instantanément), appelons-la <b>x_sleep</b> , et la variable v16 est <b>led_timeout</b> . <br><br>  Le but de la fonction sub_8006934 n'est pas encore évident, mais il est utilisé partout après avoir défini la couleur sur les LED - vous pouvez l'appeler <b>x_led_fix_color</b> . <br><br>  Après ces renommages, il est facile de comprendre la fonction <b>sub_8006944</b> (appelée dans la branche hue &lt;= 0x167): <br><br><img src="https://habrastorage.org/webt/nf/8a/j-/nf8aj-jzfsk9livqh_zxpwtojgq.png"><br><br>  Il effectue simplement une vérification supplémentaire pour déterminer la couleur de la LED.  Renommez la fonction sub_8006944 en <b>x_led_set_hsv_wrap</b> (suffixe <i>_wrap</i> - une explication qu'il s'agit d'un «wrapper» sur une autre fonction) et définissez-lui le prototype suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_led_set_hsv_wrap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_control, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">signed</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span></span></code> </pre> <br>  Revenons d'un niveau à la fonction x_leds_task.  Une fois de plus en regardant le code, vous pouvez constater que la branche "teinte&gt; 0x3E8" a commencé à ressembler à ceci: <br><br><img src="https://habrastorage.org/webt/sh/tm/5j/shtm5jrmecd3quimykrcgognngs.png"><br><br>  En d'autres termes, une valeur de teinte supérieure à 0x3E8 devrait modifier le délai d'expiration de la mosaïque colorée.  Je vérifierai en envoyant certaines valeurs à l'appareil: <br><br><ul><li>  teinte = 0x3E9 - les LED ont commencé à basculer rapidement: <br><br><img src="https://habrastorage.org/webt/1z/an/to/1zantozqcbgf0ho69jmgbvdd8v8.gif"><br></li><li>  hue = 0xFFFF - les LED ont commencé à basculer très lentement: <br><br><img src="https://habrastorage.org/webt/jr/ty/sn/jrtysngekw8_1ise6uwd0kikrhc.gif"><br></li></ul><br>  Lorsque vous quittez le cycle principal de la tâche LED, la fonction <b>sub_8003C44</b> est <b>utilisée</b> , qui est également utilisée dans la fonction sub_8005070: <br><br><img src="https://habrastorage.org/webt/ow/ws/ql/owwsqly9wu0bhmwzhu3r7buky5s.png"><br><br>  Renommer: <br><br><ul><li>  sub_8005070 - <b>x_freeMsg</b> ; </li><li>  sub_8003C44 - <b>x_free_queue</b> . </li></ul><br>  Plus loin dans la tâche LED, la branche suivante ne peut qu'attirer l'attention: <br><br><img src="https://habrastorage.org/webt/iu/q6/rr/iuq6rrf54hzoupmpslmnp0r8pcu.png"><br><br>  Vous pouvez essayer d'exécuter la commande <code>LED B816D8D90000FFFF</code> .  Mais si vous vous souvenez que seuls 2 caractères sont pris comme index LED, une tentative pour atteindre ce code sera évidemment infructueuse.  Laissez ce fil pour plus tard.  Renommez la fonction sub_8004AE8 en <b>x_mad_blinking</b> , et il est temps de corriger la signature de la fonction <b>x_printf</b> (la dernière fois que j'ai écrit la mauvaise signature): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_printf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *format, ...)</span></span></span></span></code> </pre> <br>  Le cycle principal de la tâche LED a été démonté, mais il y a toujours un code au tout début de la tâche. <br><br>  Regardons le code: <br><br><img src="https://habrastorage.org/webt/kt/xx/wn/ktxxwnzjvx9eqkkuiydzlro3vz4.png"><br><br>  À la ligne 49, il est très probable que les LED soient vérifiées pour la disponibilité et, en cas d'erreur, un appel est effectué vers la fonction sub_8004BBC, qui désactive les interruptions et démarre une boucle infinie dans laquelle la ligne «../Drivers/STM32F0xx_HAL_Driver/Src/stm32f0xx_hal_gpio.c» est utilisée.  Il s'agit très probablement d'une fonction d' <b>affirmation</b> ou similaire. <br><br>  Renommer: <br><br><ul><li>  sub_8004BBC - <b>x_gpio_assert</b> ; </li><li>  sub_800698C - <b>x_check_gpio</b> . </li></ul><br>  Le but de la fonction <b>sub_8006968</b> deviendra clair si vous regardez attentivement l'appareil lorsqu'il est allumé: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i8/ap/t4/i8apt4kjg6rrbu73wzya5noyx6m.gif"></div><br>  Les quatre LED s'allument ensemble en premier rouge, puis vert, puis bleu.  Après cela, ils sont définis par couleur: 0-rouge, 1-vert, 2-bleu, 3-violet.  Et c'est seulement alors qu'ils commencent à changer de mosaïque. <br><br>  Étant donné que la mosaïque commence dans le cycle de tâches principal, il est logique que les lignes 58-61 avant le cycle principal soient responsables de l'inclusion à court terme de différentes couleurs sur les LED, et les lignes 52-56 sont chargées de définir le rouge-vert-bleu sur toutes les LED à la fois.  Renommez la fonction sub_8006968 en <b>x_led_all_set_rgb</b> (RGB - purement sur une intuition, selon les arguments passés). <br><br><h2>  Curiosités dans la tâche LED </h2><br>  <i>En bref: définir la fonctionnalité du code contenant des lignes étranges.</i>  <i>Génération d'un mot de passe pour l'appareil.</i> <br><br>  Passons maintenant au tout début de la fonction x_leds_task: <br><br><img src="https://habrastorage.org/webt/k1/64/2j/k1642jmvbxu5d0a7vs5lrtd3pru.png"><br><br>  <b>"Eraze"</b> , <b>"gen"</b> , <b>"flash"</b> , <b>"reset"</b> - pourquoi tout cela ??? <br><br>  Essayons de le comprendre. <br><br>  Soit sub_80066BC <b>x_leds_task_init</b> . <br><br>  Regardons sub_8006B38: <br><br><img src="https://habrastorage.org/webt/qa/80/ez/qa80ezojcnsyo_vz_q1hru7whz8.png"><br><br>  Memset d'eau pure, d'accord? <br><br><img src="https://habrastorage.org/webt/pf/oa/tf/pfoatfwwwasjk338b3lphqiiya4.png"><br><br>  Retour à x_leds_task.  Quelque chose ne va pas avec le type de variable v24: <br><br><img src="https://habrastorage.org/webt/vg/ag/8u/vgag8ujkoylag2iryzujjvjldfu.png"><br><br>  L'IDA a fait une petite erreur avec le type, mais un commentaire avec une marque de pile nous aide.  Entre les variables v24 et v25 jusqu'à 12 octets (0x44 - 0x38).  Par conséquent, nous renommons v24 en <b>buf</b> et attribuons le type <code>unsigned __int8 buf[12]</code> (Ida avertira que le nouveau type de données est plus grand que l'ancien - nous sommes d'accord). <br><br>  Ensuite.  Fonction sub_8004CE4: <br><br><img src="https://habrastorage.org/webt/sc/qg/tw/scqgtwrqr1vzlaubtsqstydsqmu.png"><br><br>  Renommez <i>a1</i> en <b>buf</b> , <i>v1</i> en <b>_buf</b> . <br><br>  Fonction sub_8006B26: <br><br><img src="https://habrastorage.org/webt/gs/du/ff/gsduffmdls272wqpmmv6_klqxdm.png"><br><br>  L'avez-vous reconnue? <br><br><div class="spoiler">  <b class="spoiler_title">Et si sans maquillage?</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/8k/1d/p9/8k1dp9nmxkl0xjktjtsk_cp2vem.png"><br>  Bien sûr, <b>memcpy</b> .  Renommer. <br></div></div><br>  Le but de la fonction sub_8004CE4 est alors d'obtenir des données à l'adresse <b>0x08007C00</b> .  Soit dit en passant, cette adresse est dans la plage d'adresses de la mémoire flash du microcontrôleur (et du firmware, en particulier).  Renommez sub_8004CE4 en <b>x_read_data_0x08007C00</b> . <br><br>  Ligne de fonction X_leds_task 36: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">65</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0x19</span></span> )</code> </pre> <br>  Modifiez l'affichage des données (touche R sur le numéro 65, touche H sur le numéro 0x19): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-string"><span class="hljs-string">'A'</span></span> &gt; <span class="hljs-number"><span class="hljs-number">25</span></span> )</code> </pre> <br>  Après un peu de réflexion, vous pouvez comprendre qu'il s'agit d'un tel test de la gamme de l'alphabet latin AZ. <br><br>  Ensuite, en utilisant les invites sous forme de chaînes de format, renommez: <br><br><ul><li>  sub_8004C10 - <b>x_erase</b> ; </li><li>  sub_80059C8 - <b>x_gen</b> ; </li><li>  sub_8004C84 - <b>x_flash</b> . </li></ul><br>  La fonction sub_8003C66 ne fait rien de remarquable - elle n'augmente que certaines variables globales - renommez sub_8003C66 en <b>x_smth_inc</b> . <br><br>  La fonction <b>x_erase</b> n'accepte aucun argument - cela peut être vérifié dans le désassembleur: <br><br><img src="https://habrastorage.org/webt/rv/p3/_i/rvp3_iqmhzsegjqyi3mugvpxnis.png"><br><br>  Dans x_erase, l'adresse familière 0x08007C00 est utilisée et trois fonctions inconnues sont accessibles: <br><br><img src="https://habrastorage.org/webt/ys/nb/_b/ysnb_bfgd19htkrnmbyo5hudr0m.png"><br><br>  Un <b>rapide coup d'œil</b> sur ces trois fonctions, nous voyons qu'elles accèdent à des adresses dans la plage <b>0x40022000 - 0x400223FF</b> .  La documentation du microcontrôleur indique clairement qu'il s'agit de la gamme <b>«FLASH Interface»</b> .  Autrement dit, la fonction x_erase efface un morceau de mémoire flash - génial! <br><br>  Apparemment, la fonction x_flash écrit dans la mémoire flash, après avoir vérifié la longueur de la ligne à écrire (au fait, les arguments a2 et a3 sont superflus ici - nous allons aider Idea): <br><br><img src="https://habrastorage.org/webt/ki/di/zi/kidizigfv5lb6bwg24aspkgvxmw.png"><br><br>  Et tout cela se passe dans le "dispositif d'éclairage" ??? <br><br>  Et la fonction <b>x_gen</b> ?  Après un rapide coup d'œil et en renommant les variables, cela ressemblera à ceci: <br><br><img src="https://habrastorage.org/webt/v3/js/nb/v3jsnb8jb36wstn3obcln2c3pvk.png"><br><br>  La fonction <b>sub_8006CB4</b> ressemble à ceci: <br><br><img src="https://habrastorage.org/webt/ub/h1/rk/ubh1rki0ikjrygsiqcx9vuwylxc.png"><br><br>  Et <b>sub_8006D10</b> - comme ceci: <br><br><img src="https://habrastorage.org/webt/gp/qy/oc/gpqyocts_ubcd4u3ep9koyrcb0o.png"><br><br>  Ne retenez pas le désir de rechercher sur Internet ces constantes indécemment belles: <b>0xABCD</b> , <b>0x1234</b> , <b>0xE66D</b> , <b>0xDEEC</b> , <b>0x4C957F2D</b> et <b>0x5851F42D</b> .  Si Internet n'est pas encore complètement banni, vous trouverez probablement ces constantes dans la source <b>des fonctions aléatoires</b> .  Pas étonnant que la fonction parent s'appelle x_gen. <br><br>  C'est aussi une situation très typique: appelez srand () avant la boucle, et appelez random () dans la boucle, alors renommez-le: <br><br><ul><li>  sub_8006D10 - x_rand; </li><li>  sub_8006CB4 - x_srand. </li></ul><br>  Un lecteur curieux, en examinant la fonction <b>sub_8005098</b> , peut découvrir d' <i>où vient la graine</i> pour la fonction srand. <br><br>  Ainsi, la fonction x_gen génère <b>une chaîne aléatoire de la taille spécifiée</b> . <br><br>  Une fois la ligne générée écrite dans la mémoire flash, l'appareil redémarre: <br><br><img src="https://habrastorage.org/webt/a9/ta/rr/a9tarrhqqc-jj7g-e-dplvr67py.png"><br><br>  Cela ressemble à une sorte de redémarrage bizarre.  Mais si nous regardons la liste des tâches de cet appareil, nous trouverons «watchdogTask» parmi eux.  Évidemment, s'il y a une "tâche bloquée", le chien de garde redémarre. <br><br>  La tâche LED à l'exception du mode MadBlinking peut être considérée comme analysée. <br><br>  Regardons à travers les lignes quelles sont les autres tâches du système: <br><br><img src="https://habrastorage.org/webt/fz/yj/yk/fzyjykt6djuq8v20hjpuw5l0xow.png"><br><br>  Après avoir restauré les liens vers les chaînes dans le code, vous pouvez voir cette image: <br><br><img src="https://habrastorage.org/webt/ha/bl/ks/hablksetvyb0rskx6veqrxbt_z0.png"><br><br>  Tout d'abord, il existe un lien vers une chaîne avec le nom de tâche, puis un lien vers la fonction de tâche principale.  Et ils sont utilisés dans la fonction <b>principale</b> , où ces tâches sont lancées: <br><br><img src="https://habrastorage.org/webt/oc/ah/qd/ocahqdn8usagpkr-isbabunuwms.png"><br><br>  Exécutons les renommages manquants: <br><br><ul><li>  sub_80050FC - <b>x_sensor_task</b> ; </li><li>  sub_8004AAC - <b>x_watchdogTask</b> ; </li><li>  sub_8005440 - <b>x_uartRxTask</b> . </li></ul><br><h2>  Tâche de surveillance </h2><br>  Le chien de garde des tâches ne fait rien de particulièrement intéressant: <br><br><img src="https://habrastorage.org/webt/m-/65/5w/m-655wpo6oboqmrob1tonwaoska.png"><br><br>  Renommer: <br><br><ul><li>  dword_200003F8 - <b>wd_variable</b> ; </li><li>  sub_8001050 - <b>x_update_wd_var</b> . </li></ul><br><h2>  Tâche UART </h2><br>  <i>En bref: recherchez des données et des fonctions qui ont des liens à partir de différentes fonctions.</i>  <i>Détermination de leur objet.</i> <br><br>  Un rapide coup d'œil à la tâche UART vous permet de détecter l'envoi de données vers une file d'attente inconnue définie par la variable <b>unk_200003EC</b> : <br><br><img src="https://habrastorage.org/webt/8j/ei/zz/8jeizzxpvgu5opijgopamebser0.png"><br><br>  Après avoir restauré les liens vers cette variable via la recherche binaire, nous verrons qu'en plus de x_uartRxTask, elle est utilisée dans le principal (là, la file d'attente est créée, apparemment) et dans la fonction inconnue jusqu'ici <b>sub_80051EC</b> : <br><br><img src="https://habrastorage.org/webt/g2/md/sg/g2mdsgx9wwhzpklgcacelye8rb8.png"><br><br>  Renommer: <br><br><ul><li>  sub_80051EC - <b>x_recvMsg_uart_queue</b> ; </li><li>  unk_200003EC - <b>uart_queue</b> . </li></ul><br>  Voir les références croisées à x_recvMsg_uart_queue: <br><br><ul><li>  sub_8005250; </li><li>  x_bluetooth_task. </li></ul><br>  Tout d'abord, consultez la fonction <b>sub_8005250</b> : <br><br><img src="https://habrastorage.org/webt/z1/8z/yj/z18zyj09grly6nwhuycpftjbrcu.png"><br><br>  Après réflexion, renommez: <br><br><ul><li>  unk_2000034C - <b>cmd_count</b> ; </li><li>  a1 - <b>cmd</b> ; </li><li>  v4 - <b>_cmd</b> ; </li><li>  v6 est <b>rsp</b> ; </li><li>  sub_8005250 - <b>x_bluetooth_cmd</b> . </li></ul><br>  Voyons maintenant où x_bluetooth_cmd est toujours utilisé.  Tous les liens supplémentaires uniquement à partir de la tâche Bluetooth, il est temps d'y revenir. <br><br><h2>  Retour à la tâche Bluetooth </h2><br>  <i>En bref: l'analyse finale de la tâche Bluetooth.</i>  <i>Recherchez une autorisation sans mot de passe.</i> <br><br><img src="https://habrastorage.org/webt/mb/2b/-e/mb2b-eatekfev7dil5vfk3_s-es.png"><br><br>  Si vous regardez les endroits où la fonction <b>sub_8006A84</b> est <b>utilisée</b> , et que vous n'êtes pas trop paresseux et que vous regardez dans ses entrailles, il n'y aura aucun doute - c'est <b>calloc</b> .  C'est logique - pour recevoir des données dans le tampon, vous devez d'abord créer ce tampon. <br><br>  Maintenant <b>sub_8006DBC</b> .  Regardons-le (les variables ont déjà été renommées): <br><br><img src="https://habrastorage.org/webt/kt/hw/31/kthw31aeqzwyae4jvnoqf5u6yl4.png"><br><br>  En rappelant les fonctions de la bibliothèque C standard pour travailler avec des chaînes, nous verrons <b>strstr</b> (rechercher une sous-chaîne) ici et la renommer hardiment. <br><br>  Passons en revue le code de la fonction x_bluetooth_task - <i>peut</i> - <i>être que quelque chose a changé ici depuis la dernière visite</i> .  Dans le processus, nous nommons les variables: <br><br><ul><li>  v2 - <b>_state</b> ; </li><li>  v3 - <b>data_len</b> . </li></ul><br>  Il y a une fonction <b>sub_80052E2 juste à</b> côté.  Par analogie avec les fonctions qui tirent des nombres d'une commande Bluetooth, il extrait une chaîne d'une longueur spécifiée - appelons-la <b>x_get_str</b> . <br><br>  Nous continuons: <br><br><ul><li>  <b>v26</b> - <b>isEcho</b> ; </li><li>  v6 - <b>meow_str</b> ; </li><li>  v10 - <b>uart_cmd_byte</b> ; </li><li>  v11 - <b>uart_cmd_str</b> ; </li><li>  v12 - <b>str_0</b> ; </li><li>  v13 - <b>str_1</b> ; </li><li>  v14 - <b>format_str</b> ; </li><li>  sub_8000F5C - <b>x_blink_small_led</b> . </li></ul><br>  Terminez avec un changement de nom rapide: <br><br><ul><li>  v19 - <b>mot de passe</b> ;  (car il y a des lignes sur l'autorisation et le mot de passe à côté) </li><li>  sub_8004CC0 - <b>x_check_password</b> ; </li><li>  sub_8006AF4 - <b>x_free</b> (puisque mot de passe, cmd et bt_args sont des pointeurs vers des objets dynamiques (vérifiez cela!), la mémoire doit être libérée après leur utilisation); </li><li>  sub_8006DAC - <b>x_strcpy</b> (vérifiez-le!). </li></ul><br>  <b>Explorez</b> maintenant les branches <b>READ</b> , <b>WRIT</b> , <b>AUTP</b> , <b>SETP</b> . <br><br>  Comme l'a montré un test sur un appareil en cours d'exécution, une autorisation est requise pour les commandes READ, WRIT, SETP.  Une tentative d'autorisation avec la commande AUTP nous amène à la fonction <b>x_check_password</b> pour vérifier le mot de passe: <br><br><img src="https://habrastorage.org/webt/vt/pw/6b/vtpw6b3h64bivcvzdlalldoo45k.png"><br><br>  Il s'avère que la longueur du mot de passe doit être de 8 caractères et le mot de passe est comparé (dans la fonction sub_8006B08) avec des octets à l'adresse <b>0x08007C00</b> - où la chaîne générée de caractères aléatoires AZ est stockée. <br><br>  Il s'avère que, sans connaître le mot de passe, nous ne pouvons pas nous connecter à l'appareil.  Eh bien, ou presque ne peut pas ... <br><br>  Faites attention à l'endroit où la variable <b>auth_flag</b> est <b>utilisée</b> : <br><br><img src="https://habrastorage.org/webt/8h/ng/l0/8hngl0dqritcx8yzk1jbvkqpq34.png"><br><br>  Il s'avère qu'il est utilisé non seulement dans la tâche Bluetooth.  Et ici, nous n'avons tout simplement pas encore regardé la tâche Sensor.  On y va. <br><br><h2>  Tâche du capteur </h2><br>  <i>En bref: que fait le bouton tactile?</i> <br><br>  Conformément aux meilleures pratiques de programmation, l'ensemble de la tâche Capteur tient dans un seul écran IDA.  Et cela ne peut que se réjouir: <br><br><img src="https://habrastorage.org/webt/mq/13/3v/mq133vs_uxqmyldfhmicajpxiak.png"><br><br>  Ligne à ligne ... <br><br><ul><li>  "TSC% d \ r \ n" - cette ligne devrait vous faire penser au contrôleur de détection tactile pour les microcontrôleurs STM32; </li><li>  "AUTH BTN \ r \ n" - bouton d'autorisation ??? </li><li>  "SET AUTH% d \ r \ n" - définir l'indicateur d'autorisation? </li></ul><br>  Voyons comment l'appareil se comportera si vous appuyez sur le bouton tactile (avez-vous réalisé que le rhinocéros sur la jambe a un bouton tactile?): <br><br><img src="https://habrastorage.org/webt/0p/ig/bp/0pigbpj4pj5gdrn1onololc_zfk.gif"><br><br>  En appuyant brièvement, la petite LED rouge s'allume.  Avec une pression longue, cette LED s'allume pendant longtemps. <br><br>  Si nous corrélons cela avec le code, nous pouvons supposer que la fonction <b>sub_8000708</b> est une fonction pour obtenir l'heure actuelle.  Ensuite, si la différence entre l'heure actuelle et le début du toucher du capteur est supérieure à 1000 (1 seconde), la LED s'allume pendant <b>0xEA60</b> millisecondes (1 minute).  Mais la variable auth_flag est d'un grand intérêt, qui est mise à 1 avec un appui long sur le bouton tactile, donnant à l' <s>attaquant l'</s> accès à l'administrateur du "luminaire" l'accès à des fonctions privilégiées. <br><br>  Ainsi, après autorisation «par bouton», vous pouvez lire le mot de passe stocké dans l'appareil (commande READ), écrire dans la RAM (fonction WRIT) ou définir un nouveau mot de passe (SETP). <br><br><h2>  Clignotement fou </h2><br>  <i>En bref: une étrange branche de code Mad Blinking peut-elle être exécutée?</i> <br><br>  Revenons à la tâche Bluetooth et faisons un nouveau changement de nom. <br><br><ul><li>  v21 - <b>vip_smth</b> (on ne sait pas encore ce qu'il y a); </li><li>  v22 - <b>vip_str</b> (chaîne de taille inconnue, extraite des arguments); </li><li>  v23 - <b>mad_led</b> - attribuez "Convertir en struct *" et spécifiez <i>struct_LED</i> . </li></ul><br>  Et ici, nous voyons le numéro <b>0xB816D8D9</b> (il a été trouvé dans la première partie de l'article dans la tâche Bluetooth) comme index de la LED.  Ce code sera exécuté si la vérification est effectuée: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( sub_8005520(vip_str, vip_smth) == <span class="hljs-number"><span class="hljs-number">0x46F70674</span></span> )</code> </pre> <br>  Renommez sub_8005520 en <b>x_vip_check</b> et jetez-y un œil: <br><br><img src="https://habrastorage.org/webt/dl/h9/tx/dlh9txqyu5n1t4orgprpptbk8oc.png"><br><br>  Étant donné que le premier argument est une chaîne (au moins la chaîne est passée à cette fonction), ce code montre que le deuxième argument est la longueur de cette chaîne (ou la longueur qui doit être traitée).  Renommer: <br><br><ul><li>  a1 - <b>str</b> ; </li><li>  a2 - <b>len</b> . </li></ul><br>  Regardons la fonction <b>sub_8000254</b> : <br><br><img src="https://habrastorage.org/webt/y-/ql/js/y-qljsey4clq4lowsdbrblnkyf8.png"><br><br>  Regardez maintenant <b>sub_8000148</b> .  Voici son début: <br><br><img src="https://habrastorage.org/webt/l7/xz/cr/l7xzcrdgjq0n5a82enkalsukqse.png"><br><br>  Ce n'est qu'un tiers de la fonction ... Mmmm ... Miam!  Un creuseur expérimenté verra facilement ici ... <br><br><div class="spoiler">  <b class="spoiler_title">Quoi?</b> <div class="spoiler_text">  opération de division entière. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Comment le dénicher?</b> <div class="spoiler_text">  Si vous faites un effort, vous pouvez accéder à <b>x_printf</b> à partir de la fonction <b>sub_8000254</b> (via plusieurs autres fonctions).  Un point important à souligner à ce stade est que généralement toutes <i>les fonctions standard sont assez standard</i> .  Cela signifie que vous pouvez essayer de trouver dans le domaine public au moins du code source de la fonction étudiée, afin que l'étude soit plus productive. <br><br>  Donc, nous prenons la source de printf, puis nous regardons <b>vfprintf</b> , en le comparant avec le code du firmware étudié.  <b>En utilisant le</b> code source, nous <b>sortons de la</b> fonction <b>itoa</b> et concluons que la fonction <b>sub_8000254</b> est l'opérateur <b>opérateur%</b> (en prenant le reste de la division), et cette terrible fonction longue n'est rien de plus que de prendre la partie entière de la division (opération div). <br></div></div><br>  Une question légitime peut se poser - pourquoi?  Le fait est qu'il ne peut pas y avoir d'opérations DIV, MOD dans un microcontrôleur particulier, par conséquent, le compilateur substitue l'appel de fonctions individuelles à la place de ces opérateurs.  Au fait, voici quelques autres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonctions mathématiques</a> . <br><br>  N'oubliez pas de renommer en creusant. <br><br>  Ainsi, la fonction <b>x_vip_check</b> , calcule ... Et ce sera votre <b><i>devoir</i></b> . <br><br>  Soit dit en passant, si vous exécutez la commande <b>VIP</b> correcte, nous obtenons un «rhinocéros dans la discothèque»: <br><br><img src="https://habrastorage.org/webt/ah/ty/sc/ahtyscents-3j77aqcxfa0_hrtq.gif"><br><br><h2>  Bref rapport sur le firmware </h2><br>  Le firmware de l'appareil est basé sur le système d'exploitation en temps réel FreeRTOS.  Le système a les tâches suivantes: <br><br><ol><li>  <b>Tâche Bluetooth</b> .  Traite les commandes qui se présentent sous forme de texte via Bluetooth. </li><li>  <b>Tâche LED</b> .  Contrôle les LED de couleur en fonction des commandes Bluetooth. </li><li>  <b>Tâche du capteur</b> .  Allume la LED rouge, permet une autorisation à court terme sans mot de passe sur l'appareil. </li><li>  <b>Tâche UART</b> .  Vous permet d'interagir avec le module Bluetooth via le port UART interne (utilisé pour initialiser Bluetooth). </li><li>  <b>Tâche de surveillance</b> .  Garde la trace des gels. </li></ol><br>  L'étude n'a pas pris en compte la possibilité de lire les données du port UART (contacts Tx / GND). <br><br><h2>  Résumé </h2><br>  Lors de la master class lors de la conférence, seule la fonctionnalité principale de contrôle des LED a été démontée.  Les participants les plus actifs ont été présentés avec leurs «rhinocéros» expérimentaux. <br><br>  À mon avis, les «rhinocéros» ont produit un plan décent pour un cours de formation sur l'ingénierie inverse et la recherche de vulnérabilité.  Une caractéristique de la disposition peut être la possibilité de changer le firmware autant de fois que vous le souhaitez, chaque cours a son propre firmware.  Contrairement à l'analyse d'un fichier exécutable, le firmware inversé vous permet de mieux comprendre: <br><br><ul><li>  comment travailler avec l'IDA; </li><li>  principes d'interaction entre le firmware et l'appareil; </li><li>  Principes de fonctionnement du RTOS. </li></ul><br>  Un grand merci à tous ceux qui ont lu jusqu'à la fin! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr412561/">https://habr.com/ru/post/fr412561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr412551/index.html">Copiez le texte du presse-papiers sur les appareils Android via ADB</a></li>
<li><a href="../fr412553/index.html">Le condensé des événements pour les professionnels des RH dans le domaine des TI pour juin 2018</a></li>
<li><a href="../fr412555/index.html">Engrenage magnétique pour moteur sans balais</a></li>
<li><a href="../fr412557/index.html">Comment créer votre propre bot sans compétences en programmation et le connecter à Yandex.Alice</a></li>
<li><a href="../fr412559/index.html">Le contrat intelligent comme menace pour la sécurité du démarrage de la blockchain</a></li>
<li><a href="../fr412565/index.html">BD sur les administrateurs système: toute la vie a défilé devant mes yeux</a></li>
<li><a href="../fr412571/index.html">Histoires de réussite de Kubernetes en production. Partie 9: Clusters CERN et 210 K8s</a></li>
<li><a href="../fr412573/index.html">Ce qui ne va pas avec le retour des Geektimes à Habr</a></li>
<li><a href="../fr412575/index.html">Chaque année, la musique pop devient de plus en plus monotone, car les mêmes personnes la composent</a></li>
<li><a href="../fr412579/index.html">Marvel: Infinity War ou Comment collecter des données pour votre projet en quelques minutes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>