<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â›¹ğŸ» ğŸ˜› ğŸš Kode Jaringan Age of Empires: 1.500 pemanah per modem 28,8 kbps âœï¸ ğŸ§‘ğŸ½â€ğŸ¤â€ğŸ§‘ğŸ½ ğŸ›•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan penerjemah: artikel ini sudah berusia 17 tahun, dan menarik hanya dari sudut pandang historis. Sangat menarik untuk mempelajari bagaimana para...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kode Jaringan Age of Empires: 1.500 pemanah per modem 28,8 kbps</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417703/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eaa/c7f/fd7/eaac7ffd7c6a997f72a9cdd4cf67e982.png" alt="gambar"></div><br>  <i>Catatan penerjemah: artikel ini sudah berusia 17 tahun, dan menarik hanya dari sudut pandang historis.</i>  <i>Sangat menarik untuk mempelajari bagaimana para pengembang berhasil mencapai permainan online yang lancar di era modem 28.8k dan Pentium pertama.</i> <br><br>  Artikel ini berbicara tentang arsitektur dan implementasi, serta beberapa pelajaran yang didapat dari membuat kode multi-pengguna (jaringan) untuk game <em>Age of Empires 1 dan 2</em> .  Itu juga menguraikan pendekatan arsitektur jaringan saat ini dan masa depan yang digunakan oleh Ensemble Studios di mesin permainan mereka. <br><br><h2>  Multiplayer Age of Empires: persyaratan struktur </h2><br>  Pada awal bekerja pada kode multi-pemain <em>Age of Empires</em> pada tahun 1996, kami menetapkan diri kami tujuan yang sangat spesifik yang diperlukan untuk penerapan gameplay yang diperlukan. <br><a name="habracut"></a><br><ul><li>  Pertempuran skala besar dan epik dalam sejarah dengan banyak unit militer yang berbeda </li><li>  Mendukung hingga 8 pemain dalam mode multi-pemain </li><li>  Simulasi permainan yang lancar melalui LAN, melalui koneksi modem langsung dan melalui Internet </li><li>  Dukungan platform target: Pentium 90 dengan RAM 16 MB dan modem 28,8 kbps </li><li>  Sistem komunikasi harus bekerja dengan mesin yang ada (Genie) </li><li>  Stabil 15 frame per detik pada mesin dengan konfigurasi minimal </li></ul><br>  Mesin Genie sudah siap, dan gameplay dalam mode single-user mulai mengambil bentuknya.  Mesin Genie adalah mesin loop game single-threaded dua dimensi.  Sprite diberikan dalam 256 warna dalam dunia yang dikomposisi ubin.  Peta yang dihasilkan secara acak diisi dengan ribuan objek: dari pohon yang dapat ditebang hingga rusa yang berlari kencang.  Perkiraan rincian (setelah optimasi) waktu untuk melakukan tugas engine: 30% untuk rendering grafik, 30% untuk AI dan jalur pencarian, 30% untuk melakukan simulasi dan tugas resmi. <br><br>  Sudah pada tahap yang cukup awal, mesinnya relatif stabil, dan komunikasi multi-pengguna harus bekerja dengan kode yang sudah jadi tanpa perlu perubahan signifikan dalam arsitektur (kerja) yang ada. <br><br>  Untuk menyulitkan tugas, waktu yang dibutuhkan untuk menyelesaikan setiap langkah simulasi bisa sangat bervariasi: waktu rendering tergantung pada apakah pengguna menonton unit, menggulir atau melihat area yang belum dijelajahi, dan jalur panjang atau perencanaan strategis AI secara signifikan mempengaruhi waktu eksekusi pergerakan game. : osilasi hingga 200 ms. <br><br>  Perhitungan singkat menunjukkan bahwa transfer bahkan set kecil data tentang unit dan upaya untuk memperbaruinya secara real time sangat membatasi jumlah unit dan objek yang dengannya pemain dapat berinteraksi.  Jika Anda hanya mentransfer koordinat X dan Y, status, aksi, arah tampilan dan kerusakan, maka dalam permainan tidak boleh lebih dari 250 unit ponsel. <br><br>  Kami ingin para pemain dapat menghancurkan kota-kota Yunani dengan ketapel, pemanah, dan prajurit, sementara pada saat yang sama mengepung pengepungan dengan triremes dari laut.  Jelas, kami membutuhkan beberapa pendekatan lain. <br><br><h2>  Simulasi simultan </h2><br>  Alih-alih mentransmisikan keadaan masing-masing unit permainan, kami ingin melakukan simulasi yang benar-benar identik pada setiap mesin, melewati masing-masing set perintah yang sama yang diberikan oleh para pemain pada waktu yang sama.  Komputer para pemain, pada dasarnya, harus menyinkronkan gameplay dalam tradisi terbaik dari film perang, memungkinkan pemain untuk mengeluarkan perintah, dan kemudian mengeksekusi mereka dengan cara yang sama dan pada saat yang sama, memastikan identitas permainan. <br><br>  Awalnya, sinkronisasi yang rumit seperti itu sulit untuk diimplementasikan, tetapi sebagai hasilnya, ini membawa keuntungan yang tidak terduga di bidang lain. <br><br>  <strong>Peningkatan model dasar</strong> <br><br>  Pada tingkat konseptual yang paling sederhana, menerapkan simulasi simultan tampak sangat mudah.  Dalam beberapa game yang menggunakan simulasi dengan langkah tetap (kunci-langkah) dan timing konstan, bahkan bisa sangat mungkin. <br><br>  Karena dengan pendekatan ini, ia harus bertanggung jawab untuk memindahkan ratusan atau ribuan objek secara bersamaan, sistem harus tetap dapat bertahan bahkan dengan fluktuasi keterlambatan 20 hingga 1000 milidetik dan berhasil memproses perubahan selama pemrosesan bingkai. <br><br>  Mengirim perintah pemain, mengonfirmasi semua pesan dan kemudian memprosesnya sebelum pindah ke langkah berikutnya akan menjadi mimpi buruk dari sudut pandang proses permainan, dengan menunggu terus-menerus dan pertukaran tim yang lambat.  Kami membutuhkan skema yang dapat melanjutkan pemrosesan game secara paralel dengan latar belakang menunggu selesainya proses pertukaran data. <br><br>  Tandai [Terrano] menggunakan sistem untuk menandai perintah yang harus dieksekusi melalui dua "gerakan pertukaran data" di masa depan (gerakan pertukaran data di <em>AoE</em> dipisahkan dari kerangka rendering sendiri). <br><br>  Artinya, perintah yang diberikan selama kursus 1000 ditugaskan untuk dieksekusi selama kursus 1002 (lihat Gambar 1).  Selama 1001, perintah yang diberikan selama 0999 dieksekusi. Ini memungkinkan kami untuk menerima, mengkonfirmasi, dan menyiapkan pesan untuk diproses, sementara permainan terus menggambar animasi dan melakukan simulasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01d/163/10f/01d16310f6b5958701fbde3e8480790a.jpg"></div><br>  <i>Gambar 1. Markup perintah yang akan dieksekusi melalui dua "gerakan pertukaran data".</i> <br><br>  Biasanya gerakan membutuhkan waktu 200 ms, dan tim dikirim selama giliran ini.  Setelah 200 ms, langkah itu berhenti dan langkah baru dimulai.  Pada setiap saat pertandingan, tim diproses dalam satu langkah, diterima dan disimpan untuk langkah berikutnya, dan kemudian dikirim untuk dieksekusi dua langkah kemudian. <br><br><h2>  "Kontrol kecepatan" </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc5/133/4b0/fc51334b03798cffa22b0a18938e9ce3.jpg"></div><br>  <i>Gambar 2. Kontrol kecepatan.</i> <br><br>  Karena simulasi harus selalu memiliki input yang persis sama, sebuah gim dapat berjalan tidak lebih cepat dari mesin paling lambat yang mengatur proses pertukaran data, membuat gerakan dan mengirim perintah baru.  Kami menyebut sistem yang mengubah durasi goresan untuk mempertahankan animasi dan permainan yang lancar dalam kondisi penundaan pertukaran data variabel dan kecepatan pemrosesan "Kontrol Kecepatan". <br><br>  Gameplay dapat dirasakan "pengereman" karena dua alasan: jika frame rate satu mesin jatuh (atau lebih rendah dari yang lain), maka mesin lain memproses perintah mereka, memberikan semuanya pada waktu yang ditentukan dan sebagai akibatnya mereka harus menunggu langkah selanjutnya.  Dalam hal ini, jeda apa pun segera terlihat.  Selain itu, permainan diperlambat oleh keterlambatan pertukaran data - pemain harus menunggu sampai mesin menerima data yang cukup untuk menyelesaikan gerakan. <br><br>  Setiap klien menghitung frame rate yang dianggap dapat secara konstan dicapai, yang dihitung dengan rata-rata waktu pemrosesan beberapa frame.  Karena nilai ini berubah selama permainan tergantung pada ruang lingkup, jumlah unit, ukuran peta, dan faktor lainnya, nilai itu ditransmisikan dalam setiap pesan tentang penyelesaian langkah. <br><br>  Selain itu, setiap klien juga mengukur "waktu ping" dari dirinya sendiri ke klien lain dan sebaliknya.  Dia juga mengirim ping rata-rata ke klien terpanjang dalam pesan tentang penyelesaian langkah (total, 2 byte digunakan untuk mengontrol kecepatan). <br><br>  Dalam setiap gerakan, mesin yang ditunjuk oleh tuan rumah menganalisis pesan penyelesaian, menghitung laju bingkai yang diperlukan dan koreksi untuk keterlambatan pengiriman data melalui Internet.  Kemudian tuan rumah mengirim frame rate baru dan durasi pertukaran data.  Gambar 3-5 menunjukkan bagaimana aliran pertukaran data dipecah dalam kondisi yang berbeda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34d/ce4/48d/34dce448d5683dd1e449b7d2cf25d505.jpg"></div><br>  <i>Gambar 3. Alur pertukaran data umum.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b9/6b4/1a8/3b96b41a83ee28f6d94164f87f8a8df6.jpg"></div><br>  <i>Gambar 4. Transmisi data latensi tinggi melalui Internet pada kecepatan mesin normal.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/645/4d5/bd1/6454d5bd11e1ca0b16971e8a3e27cf9f.jpg"></div><br>  <i>Gambar 5. Kecepatan mesin rendah dengan penundaan transfer data normal.</i> <br><br>  "Kemajuan pertukaran data", yang kira-kira sama dengan waktu ping untuk perjalanan pulang pergi untuk pesan, dibagi dengan jumlah kerangka simulasi yang dapat diselesaikan oleh mesin paling lambat rata-rata selama waktu ini. <br><br>  Durasi pertukaran data tertimbang, sehingga dapat dengan cepat meningkat sesuai dengan perubahan latensi pengiriman data melalui Internet dan perlahan-lahan menurun ke kecepatan rata-rata terbaik yang dapat terus dipertahankan.  Biasanya permainan melambat dan melambat hanya pada saat-saat puncak terburuk - penundaan transmisi perintah meningkat, tetapi tetap mulus (dan hanya meningkat beberapa milidetik per belokan), karena permainan secara bertahap mengurangi penundaan ke kecepatan terbaik.  Ini menciptakan kehalusan gameplay sebaik mungkin, sementara pada saat yang sama memberikan penyesuaian terhadap kondisi yang berubah. <br><br><h2>  Pengiriman terjamin </h2><br>  UDP digunakan di lapisan jaringan, dan setiap klien terlibat dalam pemesanan perintah, pengakuan kehilangan, dan pengiriman ulang.  Setiap pesan menggunakan sepasang byte, yang menunjukkan arah pelaksanaan eksekusi perintah, dan nomor seri pesan.  Jika pesan diterima setelah pindah, itu ditolak, dan pesan masuk disimpan untuk dieksekusi.  Karena sifat UDP, Mark menggunakan prinsip berikut saat menerima pesan: "Jika ragu, Anda harus mempertimbangkan pesan yang hilang.  Jika pesan diterima rusak, penerima segera mengirim permintaan untuk pengiriman kembali pesan yang hilang.  Jika konfirmasi penerimaan diterima lebih lambat dari perkiraan waktu, pengirim cukup mengirim pesan lagi, tanpa menunggu sinyal tentang kehilangannya. " <br><br><h2>  Manfaat tersembunyi </h2><br>  Karena hasil yang dihitung oleh permainan bergantung pada semua pengguna yang melakukan simulasi identik, itu sangat sulit bagi klien (atau aliran data klien) untuk meretas dan menipu.  Simulasi apa pun yang dilakukan secara berbeda ditandai sebagai "tidak sinkron" dan permainan berhenti.  Masih mungkin untuk menipu secara lokal untuk pengungkapan informasi, tetapi kebocoran seperti itu relatif mudah diperbaiki dalam tambalan dan revisi berikutnya.  Keamanan telah menjadi kemenangan terbesar kami. <br><br><h2>  Masalah tersembunyi </h2><br>  Pada awalnya, mungkin tampak bahwa eksekusi yang sama dari dua contoh kode yang sama mudah diimplementasikan, tetapi tidak.  Pada tahap awal proyek, Manajer Produk Microsoft Tim Znamenachek mengatakan kepada Mark: "Setiap proyek memiliki satu bug persisten yang tidak menyerah sampai selesai.  Saya pikir dalam kasus kami itu akan tidak sinkron. "  Dan dia benar.  Kesulitan menemukan kesalahan sinkronisasi dikalikan dengan setiap perubahan kecil.  Rusa, yang posisinya sedikit berbeda saat membuat peta acak, akan bergerak sedikit berbeda, dan beberapa menit kemudian pemburu akan bergerak sedikit keluar dari jalan atau kehilangan tombak, sebagai akibat dari pulang tanpa daging.  Oleh karena itu, apa yang kadang-kadang tampak hanya perbedaan dalam jumlah makanan yang ada memiliki alasan yang sangat sulit dilacak. <br><br>  Meskipun kami memeriksa dunia, objek, mencari jalur, membidik, dan semua sistem lain dengan checksum, selalu ada sesuatu yang tidak dapat kami perhitungkan.  Volume pelacakan pesan dan dump objek dunia yang besar (masing-masing 50 MB) membuat masalahnya semakin rumit.  Sebagian dari kesulitannya adalah konseptual - programmer tidak terbiasa menulis kode yang menggunakan jumlah panggilan generator nomor acak yang sama dalam simulasi (ya, nomor acak juga dihasilkan dan disinkronkan). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d29/1c3/690/d291c3690fef6c18cc65aec724dafe31.png" alt="gambar"></div><br><h2>  Pelajaran yang dipetik </h2><br>  Saat mengembangkan bagian jaringan <em>Age of Empires,</em> kami menerima beberapa pelajaran yang dapat diterapkan pada pengembangan sistem multi-pengguna game apa pun. <br><br>  <strong><em>Pelajari pengguna Anda.</em></strong>  Mempelajari pengguna adalah langkah paling penting dalam memahami harapannya mengenai kecepatan multipemain, rem yang dirasakan, dan keterlambatan dalam mengirimkan perintah.  Setiap genre bersifat individual, dan Anda perlu memahami apa yang sesuai dengan gaya permainan dan manajemen Anda. <br><br>  Pada tahap awal proses pengembangan, Mark dan desainer utama menunda penundaan pertukaran data (prototipe ini direvisi beberapa kali selama proses pengembangan).  Karena mereka memainkan permainan pemain tunggal, sangat mudah untuk mensimulasikan berbagai tingkat keterlambatan transfer tim dan mendapatkan umpan balik pemain ("kontrol tampaknya baik / lambat / berkedut / hanya mengerikan"). <br><br>  Untuk game dengan genre RTS, keterlambatan pengiriman perintah 250 milidetik bahkan tidak terlihat, pada 250-500 ms gameplaynya cukup dapat dimainkan, dan remnya menjadi terlihat pada 500 ms dan lebih tinggi.  Menarik juga untuk dicatat bahwa pemain terbiasa dengan "kecepatan permainan" dan harapan mental akan penundaan antara klik mouse dan reaksi unit.  Respons tertunda yang konstan lebih baik daripada lompatan dalam keterlambatan transmisi perintah (misalnya, dari 80 hingga 500 ms) - dalam kasus ini, keterlambatan konstan 500 ms dianggap dapat dimainkan, dan yang dapat diubah tampak "gelisah" dan menyulitkan permainan. <br><br>  Programer ini dipaksa untuk mengarahkan upaya mereka untuk memastikan kelancaran - lebih baik untuk memilih durasi stroke yang lebih lama dan memastikan bahwa semuanya akan lancar dan konstan daripada melakukan operasi secepat mungkin, dihadapkan dengan perlambatan teratur.  Semua perubahan kecepatan harus bertahap, dan tingkat pertumbuhan harus sekecil mungkin. <br><br>  Kami juga mengukur kebutuhan pengguna untuk sistem - biasanya mereka memberi perintah (bergerak, menyerang, memotong pohon) kira-kira setiap satu setengah hingga dua detik, kadang-kadang dengan puncak 3-4 tim per detik selama pertempuran sengit.  Karena aksi aktif dalam game kami terus berkembang, persyaratan tertinggi untuk pertukaran data muncul di tengah dan menjelang akhir game. <br><br>  Jika Anda meluangkan waktu untuk mempelajari perilaku pengguna, Anda akan melihat fitur-fitur lain tentang cara mereka bermain, dan ini akan membantu dalam menyiapkan permainan jaringan.  Di <em>AoE</em> selama serangan, pengguna dengan cepat mengklik mouse (klik-klik-klik-klik - maju-maju-maju-maju!), Yang menyebabkan puncak besar dalam jumlah perintah yang dikeluarkan.  Selain itu, mereka mengirim kelompok besar unit yang perlu membuka jalan - juga puncak besar dalam persyaratan untuk transmisi data melalui jaringan.  Filter sederhana, memotong perintah berulang pada satu titik, secara signifikan mengurangi dampak negatif dari perilaku ini. <br><br>  Secara umum, pengguna pemantauan akan memungkinkan Anda untuk: <br><br><ul><li>  Cari tahu harapan pengguna tentang penundaan game </li><li>  Aspek multi-pemain prototipe pada tahap awal pengembangan </li><li>  Lihat perilaku yang merugikan kecepatan mode multi-pengguna. </li></ul><br>  <strong><em>Pengukuran adalah hal yang paling penting.</em></strong>  Jika Anda memperkenalkan metrik pada tahap awal pekerjaan, maka Anda akan mempelajari hal-hal menakjubkan tentang sistem pertukaran data Anda.  Jadikan metrik dapat dibaca oleh penguji dan gunakan untuk memahami apa yang terjadi di dalam mesin jaringan. <br><br>  Pelajaran: Bagian dari masalah pertukaran data di AoE muncul ketika Markus menyimpulkan metrik terlalu dini, dan tidak memeriksa lagi tingkat pesan (panjang dan frekuensi) setelah menyiapkan kode akhir.  Hal-hal yang tidak terduga seperti balapan acak antara AI, jalur yang sulit dihitung, dan paket perintah yang tidak terstruktur dapat menyebabkan masalah kinerja yang sangat besar, bahkan ketika sistem bekerja dengan baik. <br><br>  Buat sistem memberitahukan penguji dan pengembang tentang apa yang tampaknya merupakan kondisi batas yang berlebihan - pemrogram dan penguji akan melihat dalam proses pengembangan tugas yang memuat sistem;  ini akan memecahkan masalah pada tahap awal kemunculannya. <br><br>  Luangkan waktu untuk menjelaskan kepada penguji bagaimana sistem pertukaran data bekerja, tunjukkan dan jelaskan metrik kepada mereka - Anda mungkin terkejut bahwa mereka akan memperhatikan ketika kegagalan aneh terjadi dalam kode jaringan. <br><br>  Secara umum, metrik harus memiliki properti berikut: <br><br><ul><li>  Jadilah manusia yang mudah dibaca dan dimengerti oleh penguji </li><li>  Tunjukkan kemacetan, rem, dan masalah </li><li>  Dampak kecil pada eksekusi dan terus diluncurkan. </li></ul><br>  <strong><em>Pelatihan pengembang.</em></strong>  Sangat sulit untuk mengajar programmer yang terbiasa membuat aplikasi pengguna tunggal untuk memikirkan pemisahan antara memberi, menerima dan memproses perintah.  Sangat mudah untuk melupakan bahwa Anda dapat meminta sesuatu yang tidak terjadi, atau apa yang bisa terjadi beberapa detik setelah perintah itu dikeluarkan.  Perintah harus diperiksa kebenarannya saat mengirim dan setelah menerima. <br><br>  Dalam model sinkron, programmer juga harus mempertimbangkan bahwa di dalam simulasi, kode tidak boleh bergantung pada faktor lokal (seperti ketersediaan waktu luang, peralatan khusus, atau pengaturan yang berbeda).  Eksekusi kode pada semua mesin harus cocok.  Misalnya, keberadaan bunyi medan acak dalam simulasi dapat menyebabkan perilaku permainan yang berbeda. <br><br>  <strong><em>Pelajaran lainnya.</em></strong>  Ini seharusnya menjadi akal sehat yang biasa - tetapi jika Anda bergantung pada jaringan pihak ketiga (dalam kasus kami, ini adalah DirectPlay), kemudian tulis aplikasi pengujian independen yang mengonfirmasikan bahwa ketika pemilik mengklaim "pengiriman terjamin", pesan benar-benar mendapatkan "pesanan paket dijamin" sebenarnya ada, dan bahwa produk tidak memiliki hambatan tersembunyi atau perilaku aneh saat memproses data yang dikirimkan dalam game Anda. <br><br>  Bersiaplah untuk membuat aplikasi simulasi dan simulator uji stres.  Pada akhirnya, kami menciptakan tiga aplikasi tes minimal yang berbeda yang digunakan untuk mempelajari masalah individual dan penting: banjir koneksi, masalah dengan koneksi simultan saat memilih lawan, dan kehilangan paket yang dijamin. <br><br>  Uji dengan modem (dan, jika beruntung, dengan simulator modem) sedini mungkin;  Lanjutkan pengujian modem (betapapun menyakitkannya) selama proses pengembangan.     (      â€” , ,  , ,       - ?),        dialup-,     LAN.           ,       LAN. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4b/f84/6f8/f4bf846f89de72b3374179b174094cc8.jpg" alt="gambar"></div><br><h2>   <em>Age of Empires 2</em> </h2><br>  <em>Age of Empires 2: The Age of Kings</em>     ,   ,         The Zone.      ,    DirectPlay   ,       ,    <em>Age of Empires</em> . <br><br>        ,     ,      Â«Â» .      -.        ,      ,    .      .            ,   ,        ,        . <br><br>       ()  The Zone    <em>Age of Empires</em>   .  <em>Age of Kings</em>   ,             .      ,    ,        ,        .         .   The Zone  ,         .              - The Zone. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b89/ec7/ef8/b89ec7ef8b25272c8d6e35e6b1593f7d.jpg" alt="gambar"></div><br><h2>  RTS3:  </h2><br> RTS3 â€”      Ensemble   <i>(. .:     Age of Mythology)</i> .  RTS3     ,     Age of Empires,          . <br><br><ul><li>     <em>Age of Empires 1</em>  <em>2</em> .   ,    ,    ,   . </li><li> 3D: RTS3 â€”             . </li><li>   â€”     . </li><li>  TCP/IP:    â€” - TCP/IP   56 /. </li><li>    â€”     ,      NAT. </li></ul><br>      RTS3         ,    <em>Age of Empires 1</em>  <em>2</em> â€”   â€”    RTS3       .  <em>AOE/AOK</em>         DirectPlay,   RTS3     ,        . <br><br>      ,                  .    ,             ,         .   Genie    ,       â€”  BANG!       ,               . <br><br>   <em>Age of Kings</em> ,       ,             .   ,         ,           . <br><br><h2>    RTS3 </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66a/92d/4a9/66a92d4a984730fcf03a9a392945afb7.jpg"></div><br> <i> 6.  -   RTS3.</i> <br><br> <strong><em>- .</em></strong>   RTS3   - (.  6).         -,    ,   ,        . <br><br>              .         .          ,       (,    ,         -).     (  Channels, TimeSync  ..)   ,               . <br><br> <strong><em> .</em></strong>  Genie    peer-to-peer,             Â«Â».  RTS3     ,            . <br><br>           Â«Â» ( 7).         .      <em>Age 1</em>  <em>2</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f35/d91/d21/f35d91d21ae3a744d54db202a3710ed4.jpg"></div><br> <i> 7.  Â«Â»    .</i> <br><br>  Peer-to-peer: <br><br><ul><li>       Â«-Â»  Â«--Â». </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak ada tautan lemah pusat - jika klien (bahkan tuan rumah) terputus dari sesi, permainan dapat dilanjutkan. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kerugian peer-to-peer: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lebih banyak senyawa aktif dalam sistem (jumlah dari n = 0 hingga k-1 (n)), yaitu, lebih banyak mata rantai potensial dan kemungkinan penundaan yang lebih tinggi. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ketidakmampuan untuk mendukung beberapa konfigurasi NAT dalam skema semacam itu. </font></font></li></ul><br> <strong><em>Net.lib.</em></strong>      RTS3     ,     ,         ,       ,        .    ,    ,     ,    ,       ,     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abf/0cc/057/abf0cc057404cbf9c580d39155c9aff9.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 8. Empat lapisan layanan dalam model jaringan kami.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RTS3 didasarkan pada mesin BANG kami! generasi baru yang menggunakan arsitektur modular dengan pustaka komponen seperti suara, rendering, dan jaringan. Subsistem jaringan terintegrasi di sini sebagai komponen, tetapi terhubung ke mesin BANG! (serta dengan berbagai alat di rumah). Model jaringan kami dibagi menjadi empat lapisan layanan, yang hampir, tetapi tidak sepenuhnya, tidak mirip dengan model jaringan OSI yang digunakan dalam game (lihat Gambar 8). </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Socks Level 1</font></font></u> <br><br>  , Socks,   API     C.             .     .  Socks                  . <br><br> <u>Link,  2</u> <br><br>  2, Link,    .    ,   Link, Listener, NetworkAddress  Packet,    ,          (.  9). <br><br><ul><li> <strong>Packet ():</strong>      â€”  ,    / (    )     . </li><li> <strong>Link ():</strong>      .       ,           .  send  receive  ,    ,      void*. </li><li> <strong>Listener ():</strong>  .           . </li><li> <strong>Data stream ( ):</strong>        , , ,   . </li><li> <strong>Net Address ( ):</strong>   ,   . </li><li> <strong>Ping:</strong>   .    ,     . </li><li><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a4/8a3/f76/0a48a3f7672c524404eab911ebd7d062.jpg"></div><br> <i> 9.  Link.</i> </li></ul><br> <u>Multiplayer,  3</u> <br>   â€”       ,   API net.lib.  ,    RTS3      ,          / â€” ,    . <br><br>       BANG!  ,     .  API   ,      ,        . <br><br><ul><li> <strong>Client ():</strong>      .       ()     (  ).    ,    . </li><li> <strong>Session ():</strong>  ,   ,  ,    .       .        host()  join(),    ,   ,     .       / ,           . </li><li> <strong>Channel  Ordered Channel:</strong>        .              .      TimeSync,            . </li><li> <strong>Shared Data:</strong>        .        ,     ,                . </li><li> <strong>Time Sync:</strong>           . </li></ul><br> <u>Game Communications,  4</u> <br><br>      RTS3.    ,       ,     .               ,       ,    . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ac/d8a/f3b/0acd8af3b2f9d73984b7afda314f0e6e.jpg" alt="gambar"></div><br><h2>      </h2><br>  <strong><em>Sistem sinkronisasi ditingkatkan.</em></strong>  Tidak ada tim pengembangan <em>Age of Empires yang</em> dapat mengatakan bahwa kita tidak memerlukan alat sinkronisasi yang lebih baik.  Seperti dalam proyek apa pun, ketika menganalisis proses pengembangan di post-mortem, ternyata sebagian besar waktu dihabiskan untuk beberapa bidang, tetapi bisa jadi jauh lebih sedikit jika kita menanganinya terlebih dahulu.  Pada awal pengembangan RTS3, di bagian atas daftar bidang tersebut adalah sinkronisasi debugging. <br><br>  Sistem pelacakan sinkronisasi RTS3 terutama ditujukan untuk mengenali bug sinkronisasi dengan cepat.  Prioritas lainnya adalah penyederhanaan penggunaan, kemampuan untuk memproses sejumlah besar data yang disinkronkan secara sewenang-wenang melewati sistem, kemampuan untuk sepenuhnya mengkompilasi kode sinkronisasi dalam versi rilis, dan akhirnya, kemampuan untuk benar-benar mengubah konfigurasi pengujian dengan mengubah variabel alih-alih mengkompilasi ulang sepenuhnya. <br><br>  Pemeriksaan sinkronisasi di RTS3 dilakukan menggunakan dua set makro: <br><br> <code>#define syncRandCode(userinfo) <br> gSync-&gt;addCodeSync(cRandSync, userinfo, __FILE__, __LINE__) <br></code> <br><br> <code>#define syncRandData(userinfo, <br> v) gSync-&gt;addDataSync(cRandSync, v, userinfo, __FILE__, __LINE__)</code> <br> <br>  Kedua makro ini menerima parameter string userinfo, yang merupakan nama atau indikasi elemen tersinkronisasi tertentu.  Misalnya, panggilan sinkronisasi mungkin terlihat seperti ini: <br><br> <code>syncRandCode("syncing the random seed", seed);</code> <br> <br>  <em><strong>Perintah konsol sinkron dan variabel konfigurasi.</strong></em>  Seperti yang dapat dikonfirmasi oleh pengembang mod <em>Quake</em> , perintah konsol dan variabel konfigurasi sangat penting untuk proses pengembangan.  Perintah konsol adalah panggilan fungsi sederhana yang dibuat menggunakan file konfigurasi peluncuran, konsol dalam gim, atau UI, yang menjalankan fungsi gim sewenang-wenang.  Variabel konfigurasi dinamai tipe data yang disediakan melalui fungsi sederhana dapatkan, atur, tetapkan, dan alihkan, yang kami gunakan untuk semua jenis pengujian dan pengaturan parameter konfigurasi. <br><br>  Paul menciptakan versi multiplayer yang kompatibel dari sistem perintah konsol kami dan konfigurasi variabel.  Dengan bantuan mereka, kita dapat dengan mudah mengubah variabel konfigurasi reguler (misalnya, enableCheating) menjadi variabel konfigurasi multipemain dengan menambahkan tanda pada definisi variabel konfigurasi.  Jika flag ini diaktifkan, maka variabel konfigurasi ditransfer di dalam game multi-pemain, dan keputusan dalam-game yang disinkronkan (misalnya, atas izin transfer sumber daya gratis) dapat didasarkan pada nilainya.  Perintah konsol multi-pemain memiliki prinsip yang sama - panggilan ke perintah konsol multi-pemain ditransmisikan melalui jaringan dan dijalankan secara serempak pada semua mesin klien. <br><br>  Dengan menggunakan dua alat ini, pengembang dapat menggunakan sistem multipemain tanpa menulis kode.  Mereka dapat dengan cepat menambahkan pengujian dan alat konfigurasi baru dan dengan mudah mengintegrasikannya dalam lingkungan jaringan. <br><br><h2>  Untuk meringkas </h2><br>  Simulasi tersinkronisasi dan model peer to peer telah berhasil digunakan dalam seri game Age of Empires.  Meskipun sangat penting menginvestasikan waktu dalam menciptakan alat dan teknologi untuk memecahkan masalah utama dari pendekatan ini (seperti sinkronisasi dan metrik jaringan), kelayakan arsitektur ini dalam genre strategi waktu nyata telah dibuktikan oleh pengalaman.  Perbaikan selanjutnya yang kami lakukan pada RTS3 menghasilkan fakta bahwa gameplay multi-pemain hampir tidak dapat dibedakan dari pemain tunggal, bahkan dalam kondisi koneksi jaringan yang paling mengerikan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417703/">https://habr.com/ru/post/id417703/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417689/index.html">Mobio Talks dengan Appnext CEO tentang CPI Market dan Tren Aplikasi Mobile</a></li>
<li><a href="../id417691/index.html">Rak buku kami adalah programmer C #. Bagaimana dengan kamu?</a></li>
<li><a href="../id417697/index.html">Editor gambar sederhana di VueJS</a></li>
<li><a href="../id417699/index.html">Western Digital menutup pabrik HDD lain karena permintaan yang lebih rendah</a></li>
<li><a href="../id417701/index.html">Dari skrip sederhana hingga aplikasi client-server do-it-yourself di WCF: mengapa saya suka bekerja di CM</a></li>
<li><a href="../id417705/index.html">Bagaimana produsen kartu grafis memengaruhi profitabilitas penambangan GPU</a></li>
<li><a href="../id417707/index.html">CSS-in-JS - mitos dan kenyataan (ditata-komponen sebagai contoh)</a></li>
<li><a href="../id417709/index.html">Di mana dan bagaimana pengembang menilai pemberi kerja mereka? Layanan penilaian perusahaan di industri TI</a></li>
<li><a href="../id417711/index.html">Apa yang harus dibaca di Swift dalam bahasa Rusia?</a></li>
<li><a href="../id417715/index.html">Selamat tinggal Google Maps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>