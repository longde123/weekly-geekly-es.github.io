<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôâ üîù ‚ôãÔ∏è Nous √©crivons un syst√®me d'exploitation sur Rust. Organisation de la page de la m√©moire ü§æüèæ ü•´ üìö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous pr√©sentons les pages , un sch√©ma de gestion de la m√©moire tr√®s courant que nous appliquons √©galement dans notre syst√®me d'explo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous √©crivons un syst√®me d'exploitation sur Rust. Organisation de la page de la m√©moire</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436606/">  Dans cet article, nous pr√©sentons les <i>pages</i> , un sch√©ma de gestion de la m√©moire tr√®s courant que nous appliquons √©galement dans notre syst√®me d'exploitation.  L'article explique pourquoi l'isolement de la m√©moire est n√©cessaire, comment fonctionne la <i>segmentation</i> , ce qu'est <i>la m√©moire virtuelle</i> et comment les pages r√©solvent le probl√®me de fragmentation.  Nous explorons √©galement le sch√©ma des tables de pages √† plusieurs niveaux dans l'architecture x86_64. <br><br>  Ce blog est publi√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> .  Si vous avez des questions ou des probl√®mes, ouvrez-y la demande correspondante. <br><a name="habracut"></a><br><h1>  Protection de la m√©moire </h1><br>  L'une des t√¢ches principales du syst√®me d'exploitation est d'isoler les programmes les uns des autres.  Par exemple, un navigateur ne doit pas interf√©rer avec un √©diteur de texte.  Il existe diff√©rentes approches en fonction du mat√©riel et de la mise en ≈ìuvre du syst√®me d'exploitation. <br><br>  Par exemple, certains processeurs ARM Cortex-M (dans les syst√®mes embarqu√©s) ont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><i>une unit√© de protection de la m√©moire</i></a> (MPU) qui d√©finit un petit nombre (par exemple, 8) de zones de m√©moire avec diff√©rentes autorisations d'acc√®s (par exemple, aucun acc√®s, lecture seule, lecture et enregistrements).  Chaque fois que la m√©moire est acc√©d√©e, le MPU s'assure que l'adresse est dans la zone avec les autorisations correctes, sinon il l√®ve une exception.  En modifiant la port√©e et les autorisations d'acc√®s, le syst√®me d'exploitation garantit que chaque processus n'a acc√®s qu'√† sa m√©moire afin d'isoler les processus les uns des autres. <br><br>  Sur x86, deux approches diff√©rentes de protection de la m√©moire sont prises en charge: la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">segmentation</a> et la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pagination</a> . <br><br><h1>  Segmentation </h1><br>  La segmentation a √©t√© impl√©ment√©e en 1978, initialement pour augmenter la quantit√© de m√©moire adressable.  √Ä cette √©poque, le processeur ne prenait en charge que les adresses 16 bits, ce qui limitait la quantit√© de m√©moire adressable √† 64 Ko.  Pour augmenter ce volume, des registres de segments suppl√©mentaires ont √©t√© introduits, chacun contenant une adresse de d√©calage.  Le CPU ajoute automatiquement ce d√©calage √† chaque acc√®s √† la m√©moire, adressant ainsi jusqu'√† 1 Mo de m√©moire. <br><br>  Le CPU s√©lectionne automatiquement le registre de segment en fonction du type d'acc√®s √† la m√©moire: le registre de segment de code <code>CS</code> est utilis√© pour recevoir des instructions et le registre de segment de pile <code>SS</code> est utilis√© pour les op√©rations de pile (push / pop).  D'autres instructions utilisent le registre de segment de donn√©es <code>DS</code> ou le registre de segment <code>ES</code> option.  Plus tard, deux registres de segment suppl√©mentaires <code>FS</code> et <code>GS</code> ont √©t√© ajout√©s pour une utilisation gratuite. <br><br>  Dans la premi√®re version de segmentation, les registres contenaient directement le d√©calage et le contr√¥le d'acc√®s n'√©tait pas effectu√©.  Avec l'av√®nement du <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mode prot√©g√©, le</a></i> m√©canisme a chang√©.  Lorsque la CPU fonctionne dans ce mode, les descripteurs de segment stockent l'index dans une table de descripteurs locale ou globale qui, en plus de l'adresse de d√©calage, contient la taille du segment et les autorisations d'acc√®s.  En chargeant des tables de descripteurs globales / locales distinctes pour chaque processus, le syst√®me d'exploitation peut isoler les processus les uns des autres. <br><br>  En changeant les adresses m√©moire avant l'acc√®s r√©el, la segmentation a impl√©ment√© une m√©thode qui est maintenant utilis√©e presque partout: c'est <i>la m√©moire virtuelle</i> . <br><br><h3>  M√©moire virtuelle </h3><br>  L'id√©e de la m√©moire virtuelle est d'abstraire des adresses de m√©moire d'un p√©riph√©rique physique.  Au lieu d'acc√©der directement au p√©riph√©rique de stockage, une √©tape de conversion est d'abord effectu√©e.  En cas de segmentation, l'adresse de d√©calage du segment actif est ajout√©e au stade de la traduction.  Imaginez un programme qui acc√®de √† l'adresse m√©moire <code>0x1234000</code> dans un segment avec un d√©calage de <code>0x1111000</code> : en r√©alit√©, l'adresse passe √† <code>0x2345000</code> . <br><br>  Pour distinguer deux types d'adresses, les adresses avant la conversion sont appel√©es <i>virtuelles</i> et les adresses apr√®s la conversion sont appel√©es <i>physiques</i> .  Il existe une diff√©rence importante entre elles: les adresses physiques sont uniques et font toujours r√©f√©rence au m√™me emplacement unique en m√©moire.  Les adresses virtuelles, en revanche, d√©pendent de la fonction de traduction.  Deux adresses virtuelles diff√©rentes peuvent bien faire r√©f√©rence √† la m√™me adresse physique.  De plus, des adresses virtuelles identiques peuvent faire r√©f√©rence √† diff√©rentes adresses physiques apr√®s la conversion. <br><br>  Un exemple d'utilisation utile de cette propri√©t√© est le lancement parall√®le du m√™me programme deux fois: <br><br><img src="https://habrastorage.org/webt/qm/zz/nz/qmzznz4rei5d-xxygzcabu2latw.png"><br><br>  Ici, le m√™me programme s'ex√©cute deux fois, mais avec des fonctions de conversion diff√©rentes.  La premi√®re instance a un d√©calage de segment de 100, donc ses adresses virtuelles 0-150 sont converties en adresses physiques 100-250.  La deuxi√®me instance a un d√©calage de 300, qui traduit les adresses virtuelles 0-150 en adresses physiques 300-450.  Cela permet aux deux programmes d'ex√©cuter le m√™me code et d'utiliser les m√™mes adresses virtuelles sans interf√©rer l'un avec l'autre. <br><br>  Un autre avantage est que les programmes peuvent d√©sormais √™tre plac√©s √† des endroits arbitraires sur la m√©moire physique.  Ainsi, le syst√®me d'exploitation utilise la totalit√© de la m√©moire disponible sans avoir besoin de recompiler les programmes. <br><br><h3>  Fragmentation </h3><br>  La diff√©rence entre les adresses virtuelles et physiques est une r√©elle r√©alisation de segmentation.  Mais il y a un probl√®me.  Imaginez que nous voulons ex√©cuter la troisi√®me copie du programme que nous avons vu ci-dessus: <br><br><img src="https://habrastorage.org/webt/rr/np/1m/rrnp1m95lefyki9vwhnwe4uocom.png"><br><br>  Bien qu'il y ait plus qu'assez d'espace dans la m√©moire physique, la troisi√®me copie ne tient nulle part.  Le probl√®me est qu'il a besoin d'un fragment de m√©moire <i>continu</i> et nous ne pouvons pas utiliser de sections libres s√©par√©es. <br><br>  Une fa√ßon de lutter contre la fragmentation consiste √† suspendre l'ex√©cution du programme, √† rapprocher les parties de m√©moire utilis√©es, √† mettre √† jour la conversion, puis √† reprendre l'ex√©cution: <br><br><img src="https://habrastorage.org/webt/hd/rm/zo/hdrmzooae2xt4huangnbzebq3o0.png"><br><br>  Il y a maintenant suffisamment d'espace pour lancer la troisi√®me instance. <br><br>  L'inconv√©nient de cette d√©fragmentation est la n√©cessit√© de copier de grandes quantit√©s de m√©moire, ce qui r√©duit les performances.  Cette proc√©dure doit √™tre effectu√©e r√©guli√®rement jusqu'√† ce que la m√©moire soit devenue trop fragment√©e.  Les performances deviennent impr√©visibles, les programmes s'arr√™tent √† tout moment et peuvent cesser de r√©pondre. <br><br>  La fragmentation est l'une des raisons pour lesquelles la segmentation n'est pas utilis√©e dans la plupart des syst√®mes.  En fait, il n'est plus pris en charge m√™me en mode 64 bits sur x86.  Au lieu de la segmentation, des pages sont utilis√©es qui √©liminent compl√®tement le probl√®me de fragmentation. <br><br><h1>  Organisation de la page de la m√©moire </h1><br>  L'id√©e est de diviser l'espace de la m√©moire virtuelle et physique en petits blocs de taille fixe.  Les blocs de m√©moire virtuelle sont appel√©s pages et les blocs d'espace d'adressage physique sont appel√©s cadres.  Chaque page est mapp√©e individuellement √† un cadre, ce qui vous permet de diviser de grandes zones de m√©moire entre des cadres physiques non adjacents. <br><br>  L'avantage devient √©vident si vous r√©p√©tez l'exemple avec un espace m√©moire fragment√©, mais cette fois en utilisant des pages au lieu de la segmentation: <br><br><img src="https://habrastorage.org/webt/29/rg/95/29rg95blzryjql4qjy_txkbx2uo.png"><br><br>  Dans cet exemple, la taille de la page est de 50 octets, c'est-√†-dire que chacune des zones de m√©moire est divis√©e en trois pages.  Chaque page est mapp√©e sur un cadre distinct, de sorte qu'une r√©gion contigu√´ de m√©moire virtuelle peut √™tre mapp√©e sur des cadres physiques isol√©s.  Cela vous permet d'ex√©cuter la troisi√®me instance du programme sans d√©fragmentation. <br><br><h3>  Fragmentation cach√©e </h3><br>  Par rapport √† la segmentation, une organisation de pagination utilise de nombreuses petites zones de m√©moire de taille fixe au lieu de plusieurs grandes zones de taille variable.  Chaque cadre a la m√™me taille, donc la fragmentation due √† des cadres trop petits n'est pas possible. <br><br>  Mais ce n'est qu'une <i>apparence</i> .  En fait, il existe une forme cach√©e de fragmentation, la soi-disant <i>fragmentation interne</i> car toutes les zones de m√©moire ne sont pas exactement un multiple de la taille de la page.  Imaginez dans l'exemple ci-dessus, un programme de taille 101: il aura toujours besoin de trois pages de taille 50, donc cela prendra 49 octets de plus que ce dont vous avez besoin.  Pour plus de clart√©, la fragmentation due √† la segmentation est appel√©e <i>fragmentation externe</i> . <br><br>  Il n'y a rien de bon dans la fragmentation interne, mais souvent c'est un moindre mal que la fragmentation externe.  De la m√©moire suppl√©mentaire est toujours consomm√©e, mais vous n'avez plus besoin de la d√©fragmenter et le volume de fragmentation est pr√©visible (en moyenne, une demi-page pour chaque zone de m√©moire). <br><br><h3>  Tableaux de pages </h3><br>  Nous avons vu que chacune des millions de pages possibles est mapp√©e individuellement √† un cadre.  Ces informations de traduction d'adresse doivent √™tre stock√©es quelque part.  Lors de la segmentation, des registres de segment s√©par√©s sont utilis√©s pour chaque zone m√©moire active, ce qui est impossible dans le cas des pages, car il y en a beaucoup plus que des registres.  Au lieu de cela, il utilise une structure appel√©e <i>table de pages</i> . <br><br>  Pour l'exemple ci-dessus, les tableaux ressembleront √† ceci: <br><br><img src="https://habrastorage.org/webt/ij/g0/93/ijg093nmmxzlvn8fkj3n2fxvujg.png"><br><br>  Comme vous pouvez le voir, chaque instance du programme a sa propre table de pages.  Un pointeur vers la table active actuelle est stock√© dans un registre sp√©cial de la CPU.  Sur <code>x86</code> il s'appelle <code>CR3</code> .  Avant de d√©marrer chaque instance du programme, le syst√®me d'exploitation doit y charger un pointeur vers la table de pages appropri√©e. <br><br>  A chaque acc√®s √† la m√©moire, la CPU lit le pointeur de table dans le registre et recherche la trame correspondante dans la table.  Il s'agit d'une fonction enti√®rement mat√©rielle qui s'ex√©cute de mani√®re totalement transparente pour un programme en cours d'ex√©cution.  Pour acc√©l√©rer le processus, de nombreuses architectures de processeurs disposent d'un cache sp√©cial qui se souvient des r√©sultats des derni√®res conversions. <br><br>  Selon l'architecture, des attributs tels que les autorisations peuvent √©galement √™tre stock√©s dans le champ indicateur de la table de pages.  Dans l'exemple ci-dessus, l'indicateur <code>r/w</code> rend la page lisible et inscriptible. <br><br><h3>  Tableaux de pages en couches </h3><br>  Les tables de page simples ont un probl√®me avec les grands espaces d'adressage: la m√©moire est gaspill√©e.  Par exemple, le programme utilise quatre pages virtuelles <code>0</code> , <code>1_000_000</code> , <code>1_000_050</code> et <code>1_000_100</code> (nous utilisons <code>_</code> comme s√©parateur de chiffres): <br><br><img src="https://habrastorage.org/webt/oh/hc/2d/ohhc2dbnzmw-3qfq1bjmjsksydg.png"><br><br>  Seuls quatre cadres physiques sont requis, mais il y a plus d'un million d'enregistrements dans le tableau des pages.  Nous ne pouvons pas ignorer les enregistrements vides, car le processeur pendant le processus de conversion ne pourra pas acc√©der directement √† l'enregistrement correct (par exemple, il n'est plus garanti que la quatri√®me page utilise le quatri√®me enregistrement). <br><br>  Pour r√©duire la perte de m√©moire, vous pouvez utiliser une <b>organisation √† deux niveaux</b> .  L'id√©e est que nous utilisons diff√©rentes tables pour diff√©rents domaines.  Une table suppl√©mentaire, appel√©e table de pages de <i>deuxi√®me niveau</i> , convertit entre les zones d'adresse et les tables de pages de premier niveau. <br><br>  Ceci est mieux expliqu√© par l'exemple.  Nous d√©finissons que chaque table de page de niveau 1 est responsable d'une zone de taille <code>10_000</code> .  Dans l'exemple ci-dessus, les tableaux suivants existeront: <br><br><img src="https://habrastorage.org/webt/7w/3s/qk/7w3sqkqe6zbpna2z4kcnsxqokco.png"><br><br>  La page 0 tombe dans la premi√®re zone de <code>10_000</code> octets, elle utilise donc le premier enregistrement dans la table de pages du deuxi√®me niveau.  Cette entr√©e pointe vers le tableau de page T1 de premier niveau, qui d√©termine que la page 0 fait r√©f√©rence au cadre 0. <br><br>  Les pages <code>1_000_000</code> , <code>1_000_050</code> et <code>1_000_100</code> tombent dans la r√©gion du 100e octet de <code>10_000</code> , elles utilisent donc le 100e enregistrement du tableau de pages de niveau 2. Cet enregistrement pointe vers un autre premier tableau de niveau T2, qui traduit trois pages en cadres 100, 150 et 200. Remarque que l'adresse de page dans les tables du premier niveau ne contient pas de d√©calage de r√©gion, par cons√©quent, par exemple, l'enregistrement pour la page <code>1_000_050</code> n'est que de <code>50</code> . <br><br>  Nous avons encore 100 entr√©es vides dans le tableau de deuxi√®me niveau, mais c'est beaucoup moins que le million pr√©c√©dent.  La raison de ces √©conomies est que vous n'avez pas besoin de cr√©er des tables de pages de premier niveau pour des zones de m√©moire <code>10_000</code> entre <code>10_000</code> et <code>1_000_000</code> . <br><br>  Le principe des tables √† deux niveaux peut √™tre √©tendu √† trois, quatre niveaux ou plus.  En g√©n√©ral, un tel syst√®me est appel√© une table de pages √† <i>plusieurs niveaux</i> ou <i>hi√©rarchique</i> . <br><br>  Connaissant l'organisation des pages et les tables √† plusieurs niveaux, vous pouvez voir comment l'organisation des pages est impl√©ment√©e dans l'architecture x86_64 (nous supposons que le processeur s'ex√©cute en mode 64 bits). <br><br><h1>  Organisation de la page sur x86_64 </h1><br>  L'architecture x86_64 utilise une table √† quatre niveaux avec une taille de page de 4 Ko.  Quel que soit le niveau, chaque table de pages comporte 512 √©l√©ments.  Chaque enregistrement a une taille de 8 octets, donc la taille des tables est de 512 √ó 8 octets = 4 Ko. <br><br><img src="https://habrastorage.org/webt/tp/o9/x-/tpo9x-ibzvx7spvyvspck7_rtrq.png"><br><br>  Comme vous pouvez le voir, chaque index de table contient 9 bits, ce qui est logique, car les tables ont 2 ^ 9 = 512 entr√©es.  Les 12 derniers bits sont le d√©calage de page de 4 kilo-octets (2 ^ 12 octets = 4 Ko).  Les bits 48 √† 64 sont ignor√©s, donc x86_64 n'est en fait pas un syst√®me 64 bits, mais ne prend en charge que les adresses 48 bits.  Il est pr√©vu d'√©tendre la taille de l'adresse √† 57 bits via une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">table de pages √† 5 niveaux</a> , mais un tel processeur n'a pas encore √©t√© cr√©√©. <br><br>  Bien que les bits 48 √† 64 soient ignor√©s, ils ne peuvent pas √™tre d√©finis sur des valeurs arbitraires.  Tous les bits de cette plage doivent √™tre des copies du bit 47 afin de conserver des adresses uniques et de permettre une extension future, par exemple, vers une table de pages √† 5 niveaux.  Cela s'appelle une extension de signe, car elle est tr√®s similaire √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une extension de signe dans du code suppl√©mentaire</a> .  Si l'adresse n'est pas correctement d√©velopp√©e, le CPU l√®ve une exception. <br><br><h3>  Exemple de conversion </h3><br>  Voyons un exemple du fonctionnement de la traduction d'adresses: <br><br><img src="https://habrastorage.org/webt/zj/ox/fe/zjoxfeno1sahwas8h-ffyxechgm.png"><br><br>  L'adresse physique de la table de pages active actuelle des pages de niveau 4, qui est la table racine des pages de pages de ce niveau, est stock√©e dans le <code>CR3</code> .  Chaque entr√©e de table de pages pointe ensuite sur le cadre physique de la table de niveau suivant.  Une entr√©e de tableau de niveau 1 indique le cadre affich√©.  Veuillez noter que toutes les adresses dans les tables de pages sont physiques et non virtuelles, car sinon le CPU devra convertir ces adresses (ce qui peut conduire √† une r√©cursion infinie). <br><br>  La hi√©rarchie ci-dessus convertit deux pages (en bleu).  D'apr√®s les indices, nous pouvons conclure que les adresses virtuelles de ces pages sont <code>0x803fe7f000</code> et <code>0x803FE00000</code> .  Voyons ce qui se passe lorsqu'un programme essaie de lire la m√©moire √† l'adresse <code>0x803FE7F5CE</code> .  Tout d'abord, convertissez l'adresse en binaire et d√©terminez les index de table de pages et le d√©calage de l'adresse: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/600/d08/367/600d08367d49e110f1852796c23f9754.png"><br><br>  En utilisant ces index, nous pouvons maintenant parcourir la hi√©rarchie des tables de pages et trouver le cadre correspondant: <br><br><ul><li>  Lisez l'adresse de la table de quatri√®me niveau dans le <code>CR3</code> . </li><li>  L'indice du quatri√®me niveau est 1, nous examinons donc l'enregistrement avec l'indice 1 dans ce tableau.  Elle dit qu'une table de niveau 3 est stock√©e √† 16 Ko. </li><li>  Nous chargeons la table de troisi√®me niveau √† partir de cette adresse et examinons l'enregistrement avec l'index 0, qui pointe vers la table de deuxi√®me niveau √† 24 Ko. </li><li>  L'index du deuxi√®me niveau est 511, nous recherchons donc le dernier enregistrement sur cette page pour conna√Ætre l'adresse du tableau du premier niveau. </li><li>  √Ä partir de l'entr√©e avec l'index 127 dans la table de premier niveau, nous d√©couvrons enfin que la page correspond √† un cadre de 12 Ko ou 0xc000 au format hexad√©cimal. </li><li>  La derni√®re √©tape consiste √† ajouter un d√©calage √† l'adresse de trame pour obtenir l'adresse physique: 0xc000 + 0x5ce = 0xc5ce. </li></ul><br><img src="https://habrastorage.org/webt/mo/iq/-g/moiq-grelw6eyagqsuygebpugkm.png"><br><br>  Pour la page du tableau du premier niveau, l'indicateur <code>r</code> est sp√©cifi√©, c'est-√†-dire que seule la lecture est autoris√©e.  Une exception sera lev√©e au niveau mat√©riel si nous essayons d'enregistrer l√†-bas.  Les autorisations des tables de niveau sup√©rieur s'√©tendent aux niveaux inf√©rieurs, donc si nous d√©finissons l'indicateur de lecture seule au troisi√®me niveau, aucune page de niveau inf√©rieur ult√©rieure ne sera accessible en √©criture, m√™me si les indicateurs permettant l'√©criture y sont indiqu√©s. <br><br>  Bien que cet exemple utilise une seule instance de chaque table, g√©n√©ralement dans chaque espace d'adressage, il existe plusieurs instances de chaque niveau.  Maximum: <br><br><ul><li>  une table du quatri√®me niveau, </li><li>  512 tables du troisi√®me niveau (puisqu'il y a 512 enregistrements dans la table du quatri√®me niveau), </li><li>  512 * 512 tables de deuxi√®me niveau (puisque chacune des tables de troisi√®me niveau a 512 entr√©es), et </li><li>  512 * 512 * 512 tables du premier niveau (512 enregistrements pour chaque table du deuxi√®me niveau). </li></ul><br><h3>  Format de table de page </h3><br>  Dans l'architecture x86_64, les tables de pages sont essentiellement des tableaux de 512 entr√©es.  Dans la syntaxe Rust: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(align(4096))]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PageTable</span></span></span></span> { entries: [PageTableEntry; <span class="hljs-number"><span class="hljs-number">512</span></span>], }</code> </pre> <br>  Comme indiqu√© dans l'attribut <code>repr</code> , les tableaux doivent √™tre align√©s sur la page, c'est-√†-dire sur la bordure de 4 Ko.  Cette exigence garantit que le tableau remplit toujours de mani√®re optimale la page enti√®re, ce qui rend les entr√©es tr√®s compactes. <br><br>  La taille de chaque enregistrement est de 8 octets (64 bits) et le format suivant: <br><br><table><thead><tr><th>  Bit (s) </th><th>  Le titre </th><th>  Valeur </th></tr></thead><tbody><tr><td>  0 </td><td>  pr√©sent </td><td>  page en m√©moire </td></tr><tr><td>  1 </td><td>  accessible en √©criture </td><td>  enregistrement autoris√© </td></tr><tr><td>  2 </td><td>  accessible √† l'utilisateur </td><td>  si le bit n'est pas d√©fini, seul le noyau a acc√®s √† la page </td></tr><tr><td>  3 </td><td>  √©crire via la mise en cache </td><td>  √©crire directement dans la m√©moire </td></tr><tr><td>  4 </td><td>  d√©sactiver le cache </td><td>  d√©sactiver le cache pour cette page </td></tr><tr><td>  5 </td><td>  acc√©d√© </td><td>  Le CPU d√©finit ce bit lorsque la page est en cours d'utilisation. </td></tr><tr><td>  6 </td><td>  sale </td><td>  Le CPU d√©finit ce bit lors de l'√©criture sur la page </td></tr><tr><td>  7 </td><td>  √©norme page / null </td><td>  le bit z√©ro dans P1 et P4 cr√©e des pages de 1 Ko dans P3, une page de 2 Mo dans P2 </td></tr><tr><td>  8 </td><td>  global </td><td>  la page n'est pas remplie depuis le cache lors de la commutation de l'espace d'adressage (le bit PGE du registre CR4 doit √™tre d√©fini) </td></tr><tr><td>  9-11 </td><td>  disponible </td><td>  OS peut les utiliser librement </td></tr><tr><td>  12-51 </td><td>  adresse physique </td><td>  adresse physique 52 bits align√©e sur la page du cadre ou du tableau de pages suivant </td></tr><tr><td>  52-62 </td><td>  disponible </td><td>  OS peut les utiliser librement </td></tr><tr><td>  63 </td><td>  pas d'ex√©cution </td><td>  interdit l'ex√©cution de code sur cette page (le bit NXE doit √™tre d√©fini dans le registre EFER) </td></tr></tbody></table><br>  Nous voyons que seuls les bits 12-51 sont utilis√©s pour stocker l'adresse physique de la trame, et le reste fonctionne comme des drapeaux ou peut √™tre librement utilis√© par le syst√®me d'exploitation.  Cela est possible car nous pointons toujours soit vers une adresse align√©e sur 4096 octets, soit vers une page de tableaux align√©e, soit vers le d√©but du cadre correspondant.  Cela signifie que les bits 0-11 sont toujours nuls, donc ils ne peuvent pas √™tre stock√©s, ils sont simplement r√©initialis√©s au niveau mat√©riel avant d'utiliser l'adresse.  Il en va de m√™me pour les bits 52 √† 63, car l'architecture x86_64 ne prend en charge que les adresses physiques 52 bits (et uniquement les adresses virtuelles 48 bits). <br><br>  Examinons de plus pr√®s les drapeaux disponibles: <br><br><ul><li>  Le drapeau <code>present</code> distingue les pages affich√©es des pages non affich√©es.  Il peut √™tre utilis√© pour enregistrer temporairement des pages sur le disque lorsque la m√©moire principale est pleine.  Lors du prochain acc√®s √† la page, une exception PageFault sp√©ciale se produit, √† laquelle le syst√®me d'exploitation r√©pond en √©changeant la page du disque - le programme continue. </li><li>  Les indicateurs en <code>writable</code> et <code>no execute</code> d√©terminent si le contenu de la page est accessible en √©criture ou contient des instructions ex√©cutables, respectivement. </li><li>  Les drapeaux <code>accessed</code> et <code>dirty</code> sont automatiquement d√©finis par le processeur lors de la lecture ou de l'√©criture sur la page.  Le syst√®me d'exploitation peut utiliser ces informations, par exemple, s'il √©change des pages ou lorsqu'il v√©rifie si le contenu de la page a chang√© depuis le dernier pompage sur le disque. </li><li>  Les indicateurs d' <code>write through caching</code> et de <code>disable cache</code> vous permettent de g√©rer le cache pour chaque page individuellement. </li><li>  L'indicateur <code>user accessible</code> rend la page accessible pour le code √† partir de l'espace utilisateur, sinon elle n'est disponible que pour le noyau.  Cette fonction peut √™tre utilis√©e pour acc√©l√©rer les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">appels syst√®me</a> tout en conservant le mappage d'adresses pour le noyau pendant l'ex√©cution du programme utilisateur.  Cependant, la vuln√©rabilit√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Spectre</a> permet √† ces pages d'√™tre lues par des programmes depuis l'espace utilisateur. </li><li>  <code>global</code>  ,                (.   TLB )     (address space switch).     user <code>accessible</code>        . </li><li>  <code>huge page</code>     ,      2  3     .      512 :     2  = 512 √ó 4 ,      1  = 512 √ó 2 .             . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'architecture x86_64 d√©finit le format </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des tables de pages</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et de leurs </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enregistrements</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous n'avons donc pas √† cr√©er ces structures nous-m√™mes.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tampon de traduction associatif (TLB) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En raison des quatre niveaux, chaque traduction d'adresse n√©cessite quatre acc√®s √† la m√©moire. Pour des raisons de performances, x86_64 met en cache les derni√®res traductions dans le soi-disant tampon de traduction associatif (TLB). Cela vous permet d'ignorer la conversion si elle est toujours dans le cache. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contrairement aux autres caches de processeur, TLB n'est pas compl√®tement transparent, ne met pas √† jour ni ne supprime les conversions lors de la modification du contenu des tableaux de pages. Cela signifie que le noyau doit mettre √† jour le TLB lui-m√™me chaque fois qu'il modifie la table de pages. Pour ce faire, il existe une instruction CPU sp√©ciale appel√©e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>invlpg</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(invalider la page), qui supprime la traduction de la page sp√©cifi√©e du TLB, de sorte que la prochaine fois, elle sera recharg√©e √† partir de la table des pages. TLB est compl√®tement effac√© par le rechargement du registre</font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui imite un commutateur d'espace d'adressage. </font><font style="vertical-align: inherit;">Les deux options sont disponibles </font><font style="vertical-align: inherit;">via le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">module tlb</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans Rust. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est important de ne pas oublier de nettoyer le TLB apr√®s chaque changement de table de pages, sinon le CPU continuera √† utiliser l'ancienne traduction, ce qui entra√Ænera des erreurs impr√©visibles tr√®s difficiles √† d√©boguer.</font></font><br><br><h1>  Impl√©mentation </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous n'avons pas mentionn√© une chose: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">notre c≈ìur prend d√©j√† en charge l'organisation des pages</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Le chargeur de d√©marrage de l'article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬´Minimal Kernel on Rust¬ª</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a d√©j√† √©tabli une hi√©rarchie √† quatre niveaux qui mappe chaque page de notre noyau √† un cadre physique, car l'organisation des pages est requise en mode 64 bits sur x86_64. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela signifie que dans notre c≈ìur, toutes les adresses m√©moire sont virtuelles. L'acc√®s au tampon VGA √† l'adresse </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'a fonctionn√© que parce que l'identifiant du chargeur de d√©marrage a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traduit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cette page en m√©moire, c'est-√†-dire qu'il a mapp√© la page virtuelle </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur le cadre physique </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gr√¢ce √† l'organisation des pages, le noyau est d√©j√† relativement s√ªr: chaque acc√®s au-del√† de la m√©moire autoris√©e provoque une erreur de page et ne permet pas d'√©crire dans la m√©moire physique. </font><font style="vertical-align: inherit;">Le chargeur a m√™me d√©fini les autorisations d'acc√®s correctes pour chaque page: seules les pages avec du code seront ex√©cutables, et seules les pages avec des donn√©es sont disponibles pour l'√©criture</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erreurs de page (PageFault) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essayons d'appeler PageFault en acc√©dant √† la m√©moire en dehors du noyau. </font><font style="vertical-align: inherit;">Tout d'abord, cr√©ez un gestionnaire d'erreurs et enregistrez-le dans notre IDT pour voir une exception sp√©cifique au lieu d'une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">double erreur de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> type g√©n√©ral:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/interrupts.rs lazy_static! { static ref IDT: InterruptDescriptorTable = { let mut idt = InterruptDescriptorTable::new(); [‚Ä¶] idt.page_fault.set_handler_fn(page_fault_handler); // new idt }; } use x86_64::structures::idt::PageFaultErrorCode; extern "x86-interrupt" fn page_fault_handler( stack_frame: &amp;mut ExceptionStackFrame, _error_code: PageFaultErrorCode, ) { use crate::hlt_loop; use x86_64::registers::control::Cr2; println!("EXCEPTION: PAGE FAULT"); println!("Accessed Address: {:?}", Cr2::read()); println!("{:#?}", stack_frame); hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la page √©choue, le CPU d√©finit automatiquement la casse </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>CR2</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il contient l'adresse virtuelle de la page √† l'origine de l'√©chec. Pour lire et afficher cette adresse, utilisez la fonction </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cr2::read</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En r√®gle g√©n√©rale, le type </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PageFaultErrorCode</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donne plus d'informations sur le type d'acc√®s √† la m√©moire qui a provoqu√© l'erreur, mais un </font><font style="vertical-align: inherit;">code d'erreur non valide est transmis en </font><font style="vertical-align: inherit;">raison du </font><font style="vertical-align: inherit;">bogue </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LLVM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous ignorerons donc ces informations pour l'instant. L'ex√©cution du programme ne peut pas se poursuivre tant que nous n'avons pas r√©solu l'erreur de page </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hlt_loop</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons acc√®s √† la m√©moire en dehors du noyau:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use blog_os::interrupts::PICS; println!("Hello World{}", "!"); // set up the IDT first, otherwise we would enter a boot loop instead of // invoking our page fault handler blog_os::gdt::init(); blog_os::interrupts::init_idt(); unsafe { PICS.lock().initialize() }; x86_64::instructions::interrupts::enable(); // new let ptr = 0xdeadbeaf as *mut u32; unsafe { *ptr = 42; } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s le d√©marrage, nous voyons que le gestionnaire d'erreur de page est appel√©: Le </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/81e/aad/666/81eaad666e7980ce90867ffe3fcb0be3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">registre </font></font><code>CR2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contient vraiment l'adresse √† laquelle </font></font><code>0xdeadbeaf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous voulions acc√©der. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le pointeur d'instruction actuel est </font></font><code>0x20430a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous savons donc que cette adresse pointe vers une page de code. </font><font style="vertical-align: inherit;">Les pages de codes sont affich√©es par le chargeur en lecture seule, donc la lecture √† partir de cette adresse fonctionne et l'√©criture provoquera une erreur. </font><font style="vertical-align: inherit;">Essayez de changer le pointeur </font></font><code>0xdeadbeaf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>0x20430a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Note: The actual address might be different for you. Use the address that // your page fault handler reports. let ptr = 0x20430a as *mut u32; // read from a code page -&gt; works unsafe { let x = *ptr; } // write to a code page -&gt; page fault unsafe { *ptr = 42; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si nous commentons la derni√®re ligne, nous pouvons nous assurer que la lecture fonctionne et que l'√©criture provoque une erreur PageFault. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acc√®s aux tableaux de pages </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetez maintenant un ≈ìil aux tables de pages du noyau: </font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use x86_64::registers::control::Cr3; let (level_4_page_table, _) = Cr3::read(); println!("Level 4 page table at: {:?}", level_4_page_table.start_address()); [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cr3::read</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retourne du registre la </font></font><code>CR3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">table active actuelle des pages du quatri√®me niveau. Un couple revient </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PhysFrame</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cr3Flags</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nous ne sommes int√©ress√©s que par le premier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s le d√©marrage, on voit ce r√©sultat: </font></font><br><br> <code>Level 4 page table at: PhysAddr(0x1000)</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, actuellement, la table active des pages du quatri√®me niveau est stock√©e en </font><font style="vertical-align: inherit;">m√©moire </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">physique</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† l'adresse </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indiqu√©e par le type </font></font><code>PhysAddr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Maintenant, la question est: comment acc√©der √† cette table depuis le noyau? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec l'organisation des pages, l'acc√®s direct √† la m√©moire physique n'est pas possible, sinon les programmes pourront facilement contourner la protection et acc√©der √† la m√©moire des autres programmes. Ainsi, le seul moyen d'acc√©der √† ces informations consiste √† utiliser une page virtuelle, qui est traduite en un cadre physique sur</font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il s'agit d'un probl√®me typique car le noyau doit acc√©der r√©guli√®rement aux tables de pages, par exemple, lors de l'allocation d'une pile pour un nouveau thread. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les solutions √† ce probl√®me seront d√©crites en d√©tail dans le prochain article. Pour l'instant, disons simplement que le chargeur utilise une m√©thode appel√©e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tables de pages r√©cursives</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La derni√®re page de l'espace d'adressage virtuel est </font></font><code>0xffff_ffff_ffff_f000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous l'utilisons pour lire certaines entr√©es de ce tableau:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { let level_4_table_pointer = 0xffff_ffff_ffff_f000 as *const u64; for i in 0..10 { let entry = unsafe { *level_4_table_pointer.offset(i) }; println!("Entry {}: {:#x}", i, entry); } [‚Ä¶] }</span></span></code> </pre> <br>          <code>u64</code> .     ,       8  (64 ),  <code>u64</code>     .    <code>for</code>   10  .            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code> offset</code></a>   . <br><br>     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/725/8b0/9cb/7258b09cb744af09041bb3a2ee05fd54.png"><br><br>    ,  <code>0x2023</code>  0    <code>present</code> , <code>writable</code> , <code>accessed</code>     <code>0x2000</code> .  1    <code>0x6e2000</code>      ,  <code>dirty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Les entr√©es 2 √† 9 √©tant manquantes, ces plages d'adresses virtuelles ne sont mapp√©es √† aucune adresse physique. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au lieu de travailler directement avec des pointeurs dangereux, vous pouvez utiliser un type </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>PageTable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { use x86_64::structures::paging::PageTable; let level_4_table_ptr = 0xffff_ffff_ffff_f000 as *const PageTable; let level_4_table = unsafe {&amp;*level_4_table_ptr}; for i in 0..10 { println!("Entry {}: {:?}", i, level_4_table[i]); } [‚Ä¶] }</span></span></code> </pre> <br>     <code>0xffff_ffff_ffff_f000</code>  ,       Rust.  - ,      ,      .        <code>&amp;PageTable</code> ,        ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> . <br><br> <code>x86_64</code>       ,     : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/70a/d89/73d/70ad8973d35a531c7ad5943ef5144ef8.png"><br><br>   ‚Äî      0   1     3.       ,  <code>0x2000</code>  <code>0x6e5000</code>    ,         .       . <br><br><h1>  R√©sum√© </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'article pr√©sente deux m√©thodes de protection de la m√©moire: la segmentation et l'organisation des pages. La premi√®re m√©thode utilise des zones de m√©moire de taille variable et souffre d'une fragmentation externe, la seconde utilise des pages de taille fixe et permet un contr√¥le beaucoup plus pr√©cis des droits d'acc√®s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une organisation de page stocke les informations de traduction de page dans des tableaux d'un ou plusieurs niveaux. L'architecture x86_64 utilise des tables √† quatre niveaux avec une taille de page de 4 Ko. L'√©quipement contourne automatiquement les tables de pages et met en cache les r√©sultats de la conversion dans le tampon de traduction associatif (TLB). Lors du changement de tables de pages, il doit √™tre forc√© √† nettoyer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons appris que notre c≈ìur prend d√©j√† en charge l'organisation des pages et que l'acc√®s non autoris√© √† la m√©moire supprime PageFault. </font><font style="vertical-align: inherit;">Nous avons essay√© d'acc√©der aux tables de pages actuellement actives, mais nous avons r√©ussi √† acc√©der uniquement √† la table de quatri√®me niveau, car les adresses de page stockent des adresses physiques, et nous ne pouvons pas y acc√©der directement √† partir du noyau.</font></font><br><br><h1>  Et ensuite? </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'article suivant est bas√© sur les fondements fondamentaux que nous avons maintenant appris. </font><font style="vertical-align: inherit;">Pour acc√©der aux tables de pages √† partir du noyau, une technique avanc√©e appel√©e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tables de pages r√©cursives</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est utilis√©e pour parcourir la hi√©rarchie des tables et impl√©menter la traduction d'adresses programmatique. </font><font style="vertical-align: inherit;">L'article explique √©galement comment cr√©er de nouvelles traductions dans des tableaux de pages.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436606/">https://habr.com/ru/post/fr436606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436594/index.html">Au revoir Chevy Volt: Histoires et l√©gendes de l'hybride rechargeable</a></li>
<li><a href="../fr436596/index.html">Les d√©veloppeurs full-stack sont en fait bloqu√©s √† mi-niveau. √âpargnez-vous de la souffrance - ne suivez pas cette voie</a></li>
<li><a href="../fr436598/index.html">Un pas de g√©ant pour une machine d'√©checs</a></li>
<li><a href="../fr436600/index.html">Droits d'auteur d√©pass√©s et chor√©graphie: les cr√©ateurs de Fortnite poursuivis en justice pour avoir dans√© des personnages de jeux de PA</a></li>
<li><a href="../fr436602/index.html">Module cargo Dawn: 20 ans en orbite</a></li>
<li><a href="../fr436608/index.html">[SAP] SAPUI5 pour les nuls: un exercice complet √©tape par √©tape</a></li>
<li><a href="../fr436610/index.html">Fonctionnement de la sp√©cificit√© CSS dans un navigateur</a></li>
<li><a href="../fr436612/index.html">Brian Krebs: base de donn√©es de comptes m√©ga-fuites contenant des centaines de millions d'enregistrements, 2-3 ans</a></li>
<li><a href="../fr436614/index.html">Tesla r√©duira de 7% le nombre d'employ√©s permanents dans le monde</a></li>
<li><a href="../fr436616/index.html">Comment Singapour travaille avec l'innovation: de la r√©glementation gouvernementale aux bo√Ætes de nuit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>