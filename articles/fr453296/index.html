<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🎨 👨🏿‍🍳 👵🏿 Gérer l'asynchronie en PHP: des promesses aux coroutines 🤸 🧑🏿‍🤝‍🧑🏾 🍻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qu'est-ce que l'asynchronie? En bref, l'asynchronie signifie effectuer plusieurs tâches sur une période de temps spécifique. PHP s'exécute dans un seu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gérer l'asynchronie en PHP: des promesses aux coroutines</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/453296/"><p><img src="https://habrastorage.org/webt/ud/ah/t9/udaht9uat9o8n1cj2y_uwpzhbqw.jpeg"></p><br><p>  Qu'est-ce que l'asynchronie?  En bref, l'asynchronie signifie effectuer plusieurs tâches sur une période de temps spécifique.  PHP s'exécute dans un seul thread, ce qui signifie qu'un seul morceau de code PHP peut être exécuté à un moment donné.  Cela peut sembler une limitation, mais cela nous donne en fait plus de liberté.  En conséquence, nous n'avons pas à faire face à toute la complexité associée à la programmation multithread.  Mais d'un autre côté, il y a un ensemble de problèmes.  Nous devons faire face à l'asynchronie.  Nous devons en quelque sorte le gérer et le coordonner. </p><br><p>  <em>Présentation de la traduction d'un article du blog du développeur backend Skyeng Sergey Zhuk.</em> </p><a name="habracut"></a><br><p>  Par exemple, lorsque nous exécutons deux requêtes HTTP parallèles, nous disons qu'elles "s'exécutent en parallèle".  C'est généralement facile et simple à faire, mais des problèmes surviennent lorsque nous devons rationaliser les réponses de ces demandes, par exemple, lorsqu'une demande nécessite des données reçues d'une autre demande.  C'est donc dans la gestion asynchrone que réside la plus grande difficulté.  Il existe plusieurs façons de résoudre ce problème. </p><br><blockquote>  Il n'y a actuellement pas de support intégré pour les abstractions de haut niveau pour la gestion de l'asynchronie en PHP, et nous devons utiliser des bibliothèques tierces telles que ReactPHP et Amp.  Dans les exemples de cet article, j'utilise ReactPHP. </blockquote><br><h3>  Promesses </h3><br><p>  Pour mieux comprendre l'idée des promesses, un exemple concret vous sera utile.  Imaginez que vous êtes chez McDonald's et que vous souhaitez passer une commande.  Vous payez de l'argent et commencez ainsi la transaction.  En réponse à cette transaction, vous vous attendez à obtenir un hamburger et des frites.  Mais la caissière ne rend pas immédiatement la nourriture.  Au lieu de cela, vous recevez un chèque avec le numéro de commande.  Considérez ce chèque comme une promesse pour une future commande.  Vous pouvez maintenant prendre ce chèque et commencer à penser à votre délicieux déjeuner.  Le hamburger et les frites attendus ne sont pas encore prêts, vous devez donc vous lever et attendre que votre commande soit terminée.  Dès que son numéro apparaît à l'écran, vous échangez le chèque contre votre commande.  Ce sont les promesses: </p><br><blockquote>  <i>Remplace la valeur future.</i> </blockquote><p>  Une promesse est une représentation d'une signification future, une enveloppe indépendante du temps que nous enroulons autour d'une signification.  Peu nous importe que la valeur soit déjà là ou pas encore.  Nous continuons de penser à lui de la même manière.  Imaginez que nous ayons trois requêtes HTTP asynchrones qui sont exécutées «en parallèle», de sorte qu'elles seront terminées à environ un moment donné.  Mais nous voulons en quelque sorte coordonner et organiser leurs réponses.  Par exemple, nous voulons imprimer ces réponses dès qu'elles sont reçues, mais avec une légère restriction: n'imprimez pas la deuxième réponse avant d'avoir reçu la première.  Ici, je veux dire que si <b>$ promesse1</b> est remplie, nous l'imprimons.  Mais si <b>$ promesse2</b> est remplie en premier, nous ne l'imprimons pas, car <b>$ promesse1 est</b> toujours en cours.  Imaginez que nous essayons d'adapter trois demandes concurrentes de telle sorte que pour l'utilisateur final, elles ressemblent à une demande rapide. </p><br><p>  Alors, comment pouvons-nous résoudre ce problème avec des promesses?  Tout d'abord, nous avons besoin d'une fonction qui renvoie une promesse.  Nous pouvons recueillir trois de ces promesses, puis les rassembler.  Voici un faux code pour cela: </p><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fakeResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $url, callable $callback)</span></span></span><span class="hljs-function"> </span></span>{ $callback(<span class="hljs-string"><span class="hljs-string">"response for $url"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $url)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callable $resolve)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($url)</span></span></span><span class="hljs-function"> </span></span>{ fakeResponse($url, $resolve); }); }</code> </pre> <br><p>  Ici, j'ai deux fonctions: <br>  <b>fakeResponse (chaîne $ url, callable $ callback)</b> contient une réponse codée en dur et autorise le rappel spécifié avec cette réponse; <br>  <b>makeRequest (string $ url)</b> renvoie une promesse qui utilise <b>fakeResponse ()</b> pour indiquer que la demande est terminée. </p><br><p>  A partir du code client, nous appelons simplement la fonction <b>makeRequest ()</b> et obtenons les promesses: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url1'</span></span>); $promise2 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url2'</span></span>); $promise3 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url3'</span></span>);</code> </pre> <br><p>  C'était simple, mais maintenant nous devons trier ces réponses d'une manière ou d'une autre.  Encore une fois, nous voulons que la réponse de la deuxième promesse ne soit imprimée qu'après l'achèvement de la première.  Pour résoudre ce problème, vous pouvez construire une chaîne de promesses: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise2; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise3; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Complete'</span></span>; });</code> </pre> <br><p>  Dans le code ci-dessus, nous commençons par <b>$ promise1</b> .  Une fois terminé, nous imprimons sa valeur.  Peu nous importe le temps que cela prend: moins d’une seconde ou d’une heure.  Dès que la promesse sera terminée, nous imprimerons sa valeur.  Et puis nous attendons <b>$ promesse2</b> .  Et ici, nous pouvons avoir deux scénarios: </p><br><p>  <b>$ promise2 est</b> déjà terminé et nous imprimons immédiatement sa valeur; <br>  <b>$ promise2 est</b> toujours en train de se réaliser et nous attendons. </p><br><p>  Grâce à l'enchaînement des promesses, nous n'avons plus à nous soucier de la réalisation ou non d'une promesse.  Promis ne dépend pas du temps, et de ce fait il nous cache ses états (en cours, déjà terminés ou annulés). </p><br><p>  C'est ainsi que vous pouvez contrôler l'asynchronie avec les promesses.  Et cela a l'air génial, la chaîne de promesses est beaucoup plus jolie et plus compréhensible qu'un tas de rappels imbriqués. </p><br><h3>  Générateurs </h3><br><p>  En PHP, les générateurs sont un support de langage intégré pour les fonctions qui peuvent être suspendues puis poursuivies.  Lorsque l'exécution de code à l'intérieur d'un tel générateur s'arrête, cela ressemble à un petit programme bloqué.  Mais en dehors de ce programme, en dehors du générateur, tout le reste continue de fonctionner.  C'est toute la magie et la puissance des générateurs. </p><br><p>  Nous pouvons littéralement suspendre le générateur localement pour attendre la fin de la promesse.  L'idée de base est d'utiliser ensemble les promesses et les générateurs.  Ils prennent le contrôle de l'asynchronie, et nous appelons simplement yield lorsque nous devons suspendre le générateur.  Voici le même programme, mais maintenant nous connectons des générateurs et des promesses: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... ReactKernel::start(function () { $promise1 = makeRequest('url1'); $promise2 = makeRequest('url2'); $promise3 = makeRequest('url3'); var_dump(yield $promise1); var_dump(yield $promise2); var_dump(yield $promise3); });</span></span></code> </pre> <br><blockquote>  <i>Pour ce code, j'utilise la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">recoilphp / recoil</a> , qui vous permet d'appeler <b>ReactKernel :: start ()</b> .</i>  <i>Recoil permet d'utiliser des générateurs PHP pour exécuter les promesses asynchrones ReactPHP.</i> </blockquote><p>  Ici, nous effectuons toujours trois requêtes en parallèle, mais maintenant nous trions les réponses à l'aide du mot clé <b>yield</b> .  Et encore une fois, nous affichons les résultats à la fin de chaque promesse, mais seulement après la précédente. </p><br><h3>  Coroutines </h3><br><p>  Les coroutines sont un moyen de diviser une opération ou un processus en morceaux, avec une certaine exécution à l'intérieur de chacun de ces morceaux.  En conséquence, il s'avère qu'au lieu d'effectuer l'opération entière à la fois (ce qui peut entraîner un gel notable de l'application), elle sera effectuée progressivement jusqu'à ce que toute la quantité de travail nécessaire soit terminée. </p><br><p>  Maintenant que nous avons des générateurs interruptibles et renouvelables, nous pouvons les utiliser pour écrire du code asynchrone avec des promesses sous une forme synchrone plus familière.  En utilisant des générateurs PHP et des promesses, vous pouvez complètement vous débarrasser des rappels.  L'idée est que lorsque nous donnons une promesse (en utilisant l'appel de rendement), une coroutine y souscrit.  Corutin marque une pause et attend que la promesse soit terminée (terminée ou annulée).  Dès que la promesse sera terminée, coroutine continuera de se réaliser.  Une fois terminée, la promesse coroutine renvoie la valeur reçue au contexte du générateur à l'aide de l'appel <b>Generator :: send ($ value)</b> .  Si la promesse échoue, Corutin lève une exception via le générateur à l'aide de l'appel <b>Generator :: throw ()</b> .  En l'absence de rappels, nous pouvons écrire du code asynchrone qui ressemble presque à celui synchrone habituel. </p><br><p>  <b>Exécution séquentielle</b> </p><br><p>  Lors de l'utilisation de coroutine, l'ordre d'exécution en code asynchrone est désormais important.  Le code est exécuté exactement à l'endroit où le mot clé yield est appelé, puis mis en pause jusqu'à ce que la promesse soit terminée.  Considérez le code suivant: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... ReactKernel::start(function () { echo 'Response 1: ', yield makeRequest('url1'), PHP_EOL; echo 'Response 2: ', yield makeRequest('url2'), PHP_EOL; echo 'Response 3: ', yield makeRequest('url3'), PHP_EOL; });</span></span></code> </pre> <br><p>  <b>Promise1:</b> s'affiche <b>ici</b> , puis l'exécution s'interrompt et attend.  Dès que la promesse de <b>makeRequest ('url1')</b> est terminée, nous imprimons son résultat et passons à la ligne de code suivante. </p><br><p>  <b>Gestion des erreurs</b> </p><br><p>  La norme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Promises / A +</a> Promise indique que chaque promesse contient les méthodes <b>then () et catch ()</b> .  Cette interface vous permet de créer des chaînes à partir de promesses et éventuellement de détecter des erreurs.  Considérez le code suivant: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> operation()-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> anotherOperation($result); })-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> yetAnotherOperation($result); })-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $result; });</code> </pre> <br><p>  Ici, nous avons une chaîne de promesses qui transmet le résultat de chaque promesse précédente à la suivante.  Mais il n'y a pas de bloc <b>catch ()</b> dans cette chaîne, il n'y a pas de gestion d'erreur ici.  Lorsqu'une promesse dans une chaîne échoue, l'exécution de code se déplace vers le gestionnaire d'erreurs le plus proche de la chaîne.  Dans notre cas, cela signifie que la promesse en suspens sera ignorée et que toute erreur rejetée disparaîtra à jamais.  Avec les coroutines, la gestion des erreurs apparaît au premier plan.  Si une opération asynchrone échoue, une exception sera levée: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>\<span class="hljs-title"><span class="hljs-title">RejectedPromise</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... function failedOperation() { return new RejectedPromise(new RuntimeException('Something went wrong')); } ReactKernel::start(function () { try { yield failedOperation(); } catch (Throwable $error) { echo $error-&gt;getMessage() . PHP_EOL; } });</span></span></code> </pre> <br><h3>  Rendre le code asynchrone lisible </h3><br><p>  Les générateurs ont un effet secondaire vraiment important que nous pouvons utiliser pour contrôler l'asynchronie et qui résout le problème de lisibilité du code asynchrone.  Il est difficile pour nous de comprendre comment le code asynchrone sera exécuté car le thread d'exécution bascule constamment entre les différentes parties du programme.  Cependant, notre cerveau fonctionne essentiellement de manière synchrone et monothread.  Par exemple, nous planifions notre journée de manière très cohérente: en faire une, puis une autre, etc.  Mais le code asynchrone ne fonctionne pas de la façon dont nos cerveaux sont habitués à penser.  Même une simple chaîne de promesses peut ne pas sembler très lisible: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise2; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise3; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Complete'</span></span>; });</code> </pre> <br><p>  Nous devons le démonter mentalement afin de comprendre ce qui se passe là-bas.  Nous avons donc besoin d'un modèle différent pour contrôler l'asynchronie.  Et en bref, les générateurs fournissent un moyen d'écrire du code asynchrone pour qu'il ressemble à synchrone. </p><br><p>  Les promesses et les générateurs combinent le meilleur des deux mondes: nous obtenons du code asynchrone avec de grandes performances, mais en même temps, il ressemble à synchrone, linéaire et séquentiel.  Les coroutines vous permettent de masquer l'asynchronie, qui devient déjà un détail d'implémentation.  Et notre code ressemble en même temps à notre cerveau est habitué à penser - linéairement et séquentiellement. </p><br><p>  Si nous parlons de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ReactPHP</a> , alors nous pouvons utiliser la bibliothèque RecoilPHP pour écrire des promesses sous forme de coroutine.  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Amp, les</a> coroutines sont disponibles dès la sortie de la boîte. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453296/">https://habr.com/ru/post/fr453296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453280/index.html">Dette technique</a></li>
<li><a href="../fr453286/index.html">L'erreur la plus chère de ma vie: les détails de l'attaque du port de la carte SIM</a></li>
<li><a href="../fr453290/index.html">Data Science Digest (mai 2019)</a></li>
<li><a href="../fr453292/index.html">"Un petit livre sur les trous noirs"</a></li>
<li><a href="../fr453294/index.html">Réagir Chargement paresseux</a></li>
<li><a href="../fr453298/index.html">Été: temps de mise à niveau ... vous</a></li>
<li><a href="../fr453300/index.html">Shaders de jeu 3D pour débutants</a></li>
<li><a href="../fr453302/index.html">La première heure de vie avec Yandex.Module</a></li>
<li><a href="../fr453304/index.html">Avantages clés de Zextras PowerStore</a></li>
<li><a href="../fr453306/index.html">Kubernetes prendra le contrôle du monde. Quand et comment?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>