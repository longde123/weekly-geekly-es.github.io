<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüé® üë®üèø‚Äçüç≥ üëµüèø G√©rer l'asynchronie en PHP: des promesses aux coroutines ü§∏ üßëüèø‚Äçü§ù‚Äçüßëüèæ üçª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qu'est-ce que l'asynchronie? En bref, l'asynchronie signifie effectuer plusieurs t√¢ches sur une p√©riode de temps sp√©cifique. PHP s'ex√©cute dans un seu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>G√©rer l'asynchronie en PHP: des promesses aux coroutines</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/453296/"><p><img src="https://habrastorage.org/webt/ud/ah/t9/udaht9uat9o8n1cj2y_uwpzhbqw.jpeg"></p><br><p>  Qu'est-ce que l'asynchronie?  En bref, l'asynchronie signifie effectuer plusieurs t√¢ches sur une p√©riode de temps sp√©cifique.  PHP s'ex√©cute dans un seul thread, ce qui signifie qu'un seul morceau de code PHP peut √™tre ex√©cut√© √† un moment donn√©.  Cela peut sembler une limitation, mais cela nous donne en fait plus de libert√©.  En cons√©quence, nous n'avons pas √† faire face √† toute la complexit√© associ√©e √† la programmation multithread.  Mais d'un autre c√¥t√©, il y a un ensemble de probl√®mes.  Nous devons faire face √† l'asynchronie.  Nous devons en quelque sorte le g√©rer et le coordonner. </p><br><p>  <em>Pr√©sentation de la traduction d'un article du blog du d√©veloppeur backend Skyeng Sergey Zhuk.</em> </p><a name="habracut"></a><br><p>  Par exemple, lorsque nous ex√©cutons deux requ√™tes HTTP parall√®les, nous disons qu'elles "s'ex√©cutent en parall√®le".  C'est g√©n√©ralement facile et simple √† faire, mais des probl√®mes surviennent lorsque nous devons rationaliser les r√©ponses de ces demandes, par exemple, lorsqu'une demande n√©cessite des donn√©es re√ßues d'une autre demande.  C'est donc dans la gestion asynchrone que r√©side la plus grande difficult√©.  Il existe plusieurs fa√ßons de r√©soudre ce probl√®me. </p><br><blockquote>  Il n'y a actuellement pas de support int√©gr√© pour les abstractions de haut niveau pour la gestion de l'asynchronie en PHP, et nous devons utiliser des biblioth√®ques tierces telles que ReactPHP et Amp.  Dans les exemples de cet article, j'utilise ReactPHP. </blockquote><br><h3>  Promesses </h3><br><p>  Pour mieux comprendre l'id√©e des promesses, un exemple concret vous sera utile.  Imaginez que vous √™tes chez McDonald's et que vous souhaitez passer une commande.  Vous payez de l'argent et commencez ainsi la transaction.  En r√©ponse √† cette transaction, vous vous attendez √† obtenir un hamburger et des frites.  Mais la caissi√®re ne rend pas imm√©diatement la nourriture.  Au lieu de cela, vous recevez un ch√®que avec le num√©ro de commande.  Consid√©rez ce ch√®que comme une promesse pour une future commande.  Vous pouvez maintenant prendre ce ch√®que et commencer √† penser √† votre d√©licieux d√©jeuner.  Le hamburger et les frites attendus ne sont pas encore pr√™ts, vous devez donc vous lever et attendre que votre commande soit termin√©e.  D√®s que son num√©ro appara√Æt √† l'√©cran, vous √©changez le ch√®que contre votre commande.  Ce sont les promesses: </p><br><blockquote>  <i>Remplace la valeur future.</i> </blockquote><p>  Une promesse est une repr√©sentation d'une signification future, une enveloppe ind√©pendante du temps que nous enroulons autour d'une signification.  Peu nous importe que la valeur soit d√©j√† l√† ou pas encore.  Nous continuons de penser √† lui de la m√™me mani√®re.  Imaginez que nous ayons trois requ√™tes HTTP asynchrones qui sont ex√©cut√©es ¬´en parall√®le¬ª, de sorte qu'elles seront termin√©es √† environ un moment donn√©.  Mais nous voulons en quelque sorte coordonner et organiser leurs r√©ponses.  Par exemple, nous voulons imprimer ces r√©ponses d√®s qu'elles sont re√ßues, mais avec une l√©g√®re restriction: n'imprimez pas la deuxi√®me r√©ponse avant d'avoir re√ßu la premi√®re.  Ici, je veux dire que si <b>$ promesse1</b> est remplie, nous l'imprimons.  Mais si <b>$ promesse2</b> est remplie en premier, nous ne l'imprimons pas, car <b>$ promesse1 est</b> toujours en cours.  Imaginez que nous essayons d'adapter trois demandes concurrentes de telle sorte que pour l'utilisateur final, elles ressemblent √† une demande rapide. </p><br><p>  Alors, comment pouvons-nous r√©soudre ce probl√®me avec des promesses?  Tout d'abord, nous avons besoin d'une fonction qui renvoie une promesse.  Nous pouvons recueillir trois de ces promesses, puis les rassembler.  Voici un faux code pour cela: </p><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fakeResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $url, callable $callback)</span></span></span><span class="hljs-function"> </span></span>{ $callback(<span class="hljs-string"><span class="hljs-string">"response for $url"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $url)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callable $resolve)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($url)</span></span></span><span class="hljs-function"> </span></span>{ fakeResponse($url, $resolve); }); }</code> </pre> <br><p>  Ici, j'ai deux fonctions: <br>  <b>fakeResponse (cha√Æne $ url, callable $ callback)</b> contient une r√©ponse cod√©e en dur et autorise le rappel sp√©cifi√© avec cette r√©ponse; <br>  <b>makeRequest (string $ url)</b> renvoie une promesse qui utilise <b>fakeResponse ()</b> pour indiquer que la demande est termin√©e. </p><br><p>  A partir du code client, nous appelons simplement la fonction <b>makeRequest ()</b> et obtenons les promesses: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url1'</span></span>); $promise2 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url2'</span></span>); $promise3 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url3'</span></span>);</code> </pre> <br><p>  C'√©tait simple, mais maintenant nous devons trier ces r√©ponses d'une mani√®re ou d'une autre.  Encore une fois, nous voulons que la r√©ponse de la deuxi√®me promesse ne soit imprim√©e qu'apr√®s l'ach√®vement de la premi√®re.  Pour r√©soudre ce probl√®me, vous pouvez construire une cha√Æne de promesses: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise2; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise3; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Complete'</span></span>; });</code> </pre> <br><p>  Dans le code ci-dessus, nous commen√ßons par <b>$ promise1</b> .  Une fois termin√©, nous imprimons sa valeur.  Peu nous importe le temps que cela prend: moins d‚Äôune seconde ou d‚Äôune heure.  D√®s que la promesse sera termin√©e, nous imprimerons sa valeur.  Et puis nous attendons <b>$ promesse2</b> .  Et ici, nous pouvons avoir deux sc√©narios: </p><br><p>  <b>$ promise2 est</b> d√©j√† termin√© et nous imprimons imm√©diatement sa valeur; <br>  <b>$ promise2 est</b> toujours en train de se r√©aliser et nous attendons. </p><br><p>  Gr√¢ce √† l'encha√Ænement des promesses, nous n'avons plus √† nous soucier de la r√©alisation ou non d'une promesse.  Promis ne d√©pend pas du temps, et de ce fait il nous cache ses √©tats (en cours, d√©j√† termin√©s ou annul√©s). </p><br><p>  C'est ainsi que vous pouvez contr√¥ler l'asynchronie avec les promesses.  Et cela a l'air g√©nial, la cha√Æne de promesses est beaucoup plus jolie et plus compr√©hensible qu'un tas de rappels imbriqu√©s. </p><br><h3>  G√©n√©rateurs </h3><br><p>  En PHP, les g√©n√©rateurs sont un support de langage int√©gr√© pour les fonctions qui peuvent √™tre suspendues puis poursuivies.  Lorsque l'ex√©cution de code √† l'int√©rieur d'un tel g√©n√©rateur s'arr√™te, cela ressemble √† un petit programme bloqu√©.  Mais en dehors de ce programme, en dehors du g√©n√©rateur, tout le reste continue de fonctionner.  C'est toute la magie et la puissance des g√©n√©rateurs. </p><br><p>  Nous pouvons litt√©ralement suspendre le g√©n√©rateur localement pour attendre la fin de la promesse.  L'id√©e de base est d'utiliser ensemble les promesses et les g√©n√©rateurs.  Ils prennent le contr√¥le de l'asynchronie, et nous appelons simplement yield lorsque nous devons suspendre le g√©n√©rateur.  Voici le m√™me programme, mais maintenant nous connectons des g√©n√©rateurs et des promesses: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... ReactKernel::start(function () { $promise1 = makeRequest('url1'); $promise2 = makeRequest('url2'); $promise3 = makeRequest('url3'); var_dump(yield $promise1); var_dump(yield $promise2); var_dump(yield $promise3); });</span></span></code> </pre> <br><blockquote>  <i>Pour ce code, j'utilise la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">recoilphp / recoil</a> , qui vous permet d'appeler <b>ReactKernel :: start ()</b> .</i>  <i>Recoil permet d'utiliser des g√©n√©rateurs PHP pour ex√©cuter les promesses asynchrones ReactPHP.</i> </blockquote><p>  Ici, nous effectuons toujours trois requ√™tes en parall√®le, mais maintenant nous trions les r√©ponses √† l'aide du mot cl√© <b>yield</b> .  Et encore une fois, nous affichons les r√©sultats √† la fin de chaque promesse, mais seulement apr√®s la pr√©c√©dente. </p><br><h3>  Coroutines </h3><br><p>  Les coroutines sont un moyen de diviser une op√©ration ou un processus en morceaux, avec une certaine ex√©cution √† l'int√©rieur de chacun de ces morceaux.  En cons√©quence, il s'av√®re qu'au lieu d'effectuer l'op√©ration enti√®re √† la fois (ce qui peut entra√Æner un gel notable de l'application), elle sera effectu√©e progressivement jusqu'√† ce que toute la quantit√© de travail n√©cessaire soit termin√©e. </p><br><p>  Maintenant que nous avons des g√©n√©rateurs interruptibles et renouvelables, nous pouvons les utiliser pour √©crire du code asynchrone avec des promesses sous une forme synchrone plus famili√®re.  En utilisant des g√©n√©rateurs PHP et des promesses, vous pouvez compl√®tement vous d√©barrasser des rappels.  L'id√©e est que lorsque nous donnons une promesse (en utilisant l'appel de rendement), une coroutine y souscrit.  Corutin marque une pause et attend que la promesse soit termin√©e (termin√©e ou annul√©e).  D√®s que la promesse sera termin√©e, coroutine continuera de se r√©aliser.  Une fois termin√©e, la promesse coroutine renvoie la valeur re√ßue au contexte du g√©n√©rateur √† l'aide de l'appel <b>Generator :: send ($ value)</b> .  Si la promesse √©choue, Corutin l√®ve une exception via le g√©n√©rateur √† l'aide de l'appel <b>Generator :: throw ()</b> .  En l'absence de rappels, nous pouvons √©crire du code asynchrone qui ressemble presque √† celui synchrone habituel. </p><br><p>  <b>Ex√©cution s√©quentielle</b> </p><br><p>  Lors de l'utilisation de coroutine, l'ordre d'ex√©cution en code asynchrone est d√©sormais important.  Le code est ex√©cut√© exactement √† l'endroit o√π le mot cl√© yield est appel√©, puis mis en pause jusqu'√† ce que la promesse soit termin√©e.  Consid√©rez le code suivant: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... ReactKernel::start(function () { echo 'Response 1: ', yield makeRequest('url1'), PHP_EOL; echo 'Response 2: ', yield makeRequest('url2'), PHP_EOL; echo 'Response 3: ', yield makeRequest('url3'), PHP_EOL; });</span></span></code> </pre> <br><p>  <b>Promise1:</b> s'affiche <b>ici</b> , puis l'ex√©cution s'interrompt et attend.  D√®s que la promesse de <b>makeRequest ('url1')</b> est termin√©e, nous imprimons son r√©sultat et passons √† la ligne de code suivante. </p><br><p>  <b>Gestion des erreurs</b> </p><br><p>  La norme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Promises / A +</a> Promise indique que chaque promesse contient les m√©thodes <b>then () et catch ()</b> .  Cette interface vous permet de cr√©er des cha√Ænes √† partir de promesses et √©ventuellement de d√©tecter des erreurs.  Consid√©rez le code suivant: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> operation()-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> anotherOperation($result); })-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> yetAnotherOperation($result); })-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $result; });</code> </pre> <br><p>  Ici, nous avons une cha√Æne de promesses qui transmet le r√©sultat de chaque promesse pr√©c√©dente √† la suivante.  Mais il n'y a pas de bloc <b>catch ()</b> dans cette cha√Æne, il n'y a pas de gestion d'erreur ici.  Lorsqu'une promesse dans une cha√Æne √©choue, l'ex√©cution de code se d√©place vers le gestionnaire d'erreurs le plus proche de la cha√Æne.  Dans notre cas, cela signifie que la promesse en suspens sera ignor√©e et que toute erreur rejet√©e dispara√Ætra √† jamais.  Avec les coroutines, la gestion des erreurs appara√Æt au premier plan.  Si une op√©ration asynchrone √©choue, une exception sera lev√©e: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>\<span class="hljs-title"><span class="hljs-title">RejectedPromise</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... function failedOperation() { return new RejectedPromise(new RuntimeException('Something went wrong')); } ReactKernel::start(function () { try { yield failedOperation(); } catch (Throwable $error) { echo $error-&gt;getMessage() . PHP_EOL; } });</span></span></code> </pre> <br><h3>  Rendre le code asynchrone lisible </h3><br><p>  Les g√©n√©rateurs ont un effet secondaire vraiment important que nous pouvons utiliser pour contr√¥ler l'asynchronie et qui r√©sout le probl√®me de lisibilit√© du code asynchrone.  Il est difficile pour nous de comprendre comment le code asynchrone sera ex√©cut√© car le thread d'ex√©cution bascule constamment entre les diff√©rentes parties du programme.  Cependant, notre cerveau fonctionne essentiellement de mani√®re synchrone et monothread.  Par exemple, nous planifions notre journ√©e de mani√®re tr√®s coh√©rente: en faire une, puis une autre, etc.  Mais le code asynchrone ne fonctionne pas de la fa√ßon dont nos cerveaux sont habitu√©s √† penser.  M√™me une simple cha√Æne de promesses peut ne pas sembler tr√®s lisible: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise2; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise3; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Complete'</span></span>; });</code> </pre> <br><p>  Nous devons le d√©monter mentalement afin de comprendre ce qui se passe l√†-bas.  Nous avons donc besoin d'un mod√®le diff√©rent pour contr√¥ler l'asynchronie.  Et en bref, les g√©n√©rateurs fournissent un moyen d'√©crire du code asynchrone pour qu'il ressemble √† synchrone. </p><br><p>  Les promesses et les g√©n√©rateurs combinent le meilleur des deux mondes: nous obtenons du code asynchrone avec de grandes performances, mais en m√™me temps, il ressemble √† synchrone, lin√©aire et s√©quentiel.  Les coroutines vous permettent de masquer l'asynchronie, qui devient d√©j√† un d√©tail d'impl√©mentation.  Et notre code ressemble en m√™me temps √† notre cerveau est habitu√© √† penser - lin√©airement et s√©quentiellement. </p><br><p>  Si nous parlons de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ReactPHP</a> , alors nous pouvons utiliser la biblioth√®que RecoilPHP pour √©crire des promesses sous forme de coroutine.  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Amp, les</a> coroutines sont disponibles d√®s la sortie de la bo√Æte. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453296/">https://habr.com/ru/post/fr453296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453280/index.html">Dette technique</a></li>
<li><a href="../fr453286/index.html">L'erreur la plus ch√®re de ma vie: les d√©tails de l'attaque du port de la carte SIM</a></li>
<li><a href="../fr453290/index.html">Data Science Digest (mai 2019)</a></li>
<li><a href="../fr453292/index.html">"Un petit livre sur les trous noirs"</a></li>
<li><a href="../fr453294/index.html">R√©agir Chargement paresseux</a></li>
<li><a href="../fr453298/index.html">√ât√©: temps de mise √† niveau ... vous</a></li>
<li><a href="../fr453300/index.html">Shaders de jeu 3D pour d√©butants</a></li>
<li><a href="../fr453302/index.html">La premi√®re heure de vie avec Yandex.Module</a></li>
<li><a href="../fr453304/index.html">Avantages cl√©s de Zextras PowerStore</a></li>
<li><a href="../fr453306/index.html">Kubernetes prendra le contr√¥le du monde. Quand et comment?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>