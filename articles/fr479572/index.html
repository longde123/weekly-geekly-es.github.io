<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏏️ 😷 🤚🏽 Comment Netflix Microservices gère les données Pub-Sub 👨🏿‍🚒 🧑🏿‍🤝‍🧑🏾 🚹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La traduction de l'article a été préparée spécialement pour les étudiants du cours «High Load Architect» . 
 



 Présentation 
 Dans l'architecture d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment Netflix Microservices gère les données Pub-Sub</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/479572/">  <i>La traduction de l'article a été préparée spécialement pour les étudiants du cours <a href="https://otus.pw/RCke/">«High Load Architect»</a> .</i> <i><br></i> <br><br><img src="https://habrastorage.org/webt/ro/7u/1i/ro7u1is2mtzuzuuuzpdm07pgzc8.png"><br><hr><br><h3>  Présentation </h3><br>  Dans l'architecture de microservice Netflix, le transfert d'ensembles de données d'un à plusieurs points de terminaison peut être extrêmement difficile.  Ces ensembles de données peuvent contenir tout, d'une configuration de service aux résultats du traitement par lots.  Pour optimiser l'accès, une base de données résidente est souvent nécessaire et les modifications doivent être envoyées immédiatement après la mise à jour des données. <br><br>  Un exemple qui reflète le besoin de distribution distribuée d'un ensemble de données ressemble à ceci: à tout moment, Netflix effectue un grand nombre de tests A / B.  Ces tests couvrent plusieurs services et commandes, et les opérateurs de test devraient pouvoir se reconfigurer à la volée.  Cela nécessite également la capacité de détecter les nœuds qui n'ont pas pu obtenir la dernière configuration de test et la possibilité de revenir aux anciennes versions en cas de problème. <a name="habracut"></a><br><br>  Un autre exemple d'un ensemble de données qui doit être distribué est la séquence de sortie d'un modèle d'apprentissage automatique: les résultats de son travail peuvent être utilisés par plusieurs équipes, mais les équipes ML ne sont pas nécessairement intéressées à soutenir des services d'accès ininterrompus dans une situation critique.  Au lieu de la situation où chaque équipe doit créer des sauvegardes afin de pouvoir revenir en arrière de manière succincte, une attention particulière est accordée pour garantir que plusieurs équipes peuvent utiliser les résultats d'une seule équipe. <br><br>  Sans assistance au niveau de l'infrastructure, chaque équipe essaie finalement de mettre en œuvre sa propre solution, mais cela se fait avec différentes équipes avec un succès variable.  Les ensembles de données eux-mêmes sont de tailles différentes, de quelques octets à quelques gigaoctets.  Il est important de créer la capacité de surveiller les performances des processus et de détecter les dysfonctionnements à l'aide d'outils spéciaux afin que les opérateurs puissent rapidement apporter des modifications sans avoir à créer leur propre solution. <br><br><img src="https://habrastorage.org/webt/96/wa/uw/96wauwyjpxs3xx0kljnxvxcmk2i.png"><br>  <i>Diffusion des données</i> <br><br>  Chez Netflix, nous utilisons un système de données pub / sub interne appelé Gutenberg.  Gutenberg vous permet de distribuer des ensembles de données avec gestion des versions - les destinataires s'abonnent aux données et reçoivent leurs dernières versions lors de leur publication.  Chaque version de l'ensemble de données reste inchangée et contient une représentation complète des données, c'est-à-dire qu'il n'y a aucune dépendance par rapport aux versions précédentes.  Gutenberg vous permet d'afficher d'anciennes versions de données au cas où vous auriez besoin, par exemple, de déboguer, de résoudre rapidement un problème de données ou de recycler un modèle d'apprentissage automatique.  Dans cet article, nous parlerons de l'architecture de haut niveau de Gutenberg. <br><br><h4>  Modèle de données </h4><br><img src="https://habrastorage.org/webt/7g/7z/b6/7g7zb66okgkinf1xxzvlyxk-60w.png"><br>  <i>1 sujet -&gt; plusieurs versions</i> <br><br>  Le design de haut niveau de Gutenberg est le thème.  L'éditeur publie des données dans le sujet et les destinataires en extraient.  La publication dans le sujet est ajoutée en tant que version distincte.  Celles-ci sont caractérisées par une politique de stockage spécifique qui détermine le nombre de versions, selon le cas d'utilisation.  Par exemple, vous pouvez configurer un thème pour stocker 10 versions ou les versions des 10 derniers jours. <br><br>  Chaque version contient des métadonnées (clés et valeurs) et un pointeur de données.  Le pointeur de données peut être considéré comme des métadonnées spéciales indiquant où les données publiées sont réellement stockées.  Aujourd'hui, Gutenberg prend en charge les pointeurs de données directs (si la charge utile est écrite dans la valeur du pointeur de données lui-même) et les pointeurs de données S3 (si la charge utile est stockée dans S3).  Les pointeurs de données directs sont généralement utilisés lorsque les données sont petites (moins de 1 Mo), et S3 est utilisé comme stockage de sauvegarde au cas où le volume de données est important. <br><br><img src="https://habrastorage.org/webt/z7/we/mp/z7wemphye670skkx23aemtfkdyi.png"><br>  <i>1 sujet -&gt; de nombreux sets publiés</i> <br><br>  Gutenberg offre la possibilité d'envoyer une publication à un ensemble spécifique d'utilisateurs destinataires - par exemple, un ensemble peut être groupé par région, application ou cluster spécifique.  Cela peut être utilisé pour contrôler la qualité des modifications de données ou pour limiter l'ensemble de données afin qu'un sous-ensemble d'applications puisse s'y abonner.  Les éditeurs déterminent la zone de publication d'une version particulière des données et peuvent ajouter des zones aux données précédemment publiées.  Veuillez noter que cela signifie que le concept de la dernière version des données dépend d'un domaine spécifique - les deux applications peuvent recevoir les dernières versions différentes des données en fonction de la zone de publication définie par l'éditeur.  Le service Gutenberg mappe les applications destinataires aux zones de publication avant de décider quoi envoyer comme dernière version. <br><br><h3>  Cas d'utilisation </h3><br>  Le cas d'utilisation le plus courant pour Gutenberg est de distribuer des données de différentes tailles d'un éditeur à plusieurs destinataires.  Souvent, les données sont stockées dans la mémoire du destinataire et utilisées comme «cache partagé», où elles restent toujours disponibles pendant l'exécution du code du destinataire et sont remplacées atomiquement sous le capot si nécessaire.  Un grand nombre de ces cas d'utilisation peuvent être regroupés en «configurations», telles que la configuration du cache <a href="https://medium.com/netflix-techblog/distributing-content-to-open-connect-3e3e391d4dc9">Open Connect Appliance</a> , les ID de type d'appareil pris en charge, les métadonnées de méthode de paiement prises en charge et les configurations de test A / B.  Gutenberg fournit une abstraction entre la publication et la réception de ces données, permettant aux éditeurs de parcourir librement leur application sans affecter les destinataires en aval.  Dans certains cas, la publication se fait à l'aide d'une interface utilisateur gérée par Gutenberg, et les équipes n'ont pas du tout besoin de toucher leur propre application de publication. <br><br>  Une autre utilisation du système Gutenberg est un référentiel de données versionnées.  Ceci est utile pour les applications d'apprentissage automatique où les équipes construisent et forment des modèles basés sur des données historiques, voient comment elles changent au fil du temps, puis modifient certains paramètres et réexécutent l'application.  Le plus souvent dans les calculs par lots, Gutenberg est utilisé pour stocker et distribuer les résultats de ces calculs sous différentes versions d'ensembles de données.  Les cas d'utilisation en ligne s'abonnent à des rubriques pour fournir des données en temps réel à partir des derniers ensembles de versions, tandis que les systèmes autonomes peuvent utiliser des données historiques des mêmes rubriques, par exemple, pour enseigner un modèle d'apprentissage automatique. <br><br>  Il est important de noter que Gutenberg n'est pas conçu comme un système d'événements, il est uniquement destiné au contrôle de version et à la distribution de données.  En particulier, des publications fréquentes ne signifient pas que l'abonné est tenu de recevoir chaque version.  Lorsqu'il demande une mise à jour, il recevra la dernière version, même si pour le moment sa version actuelle est loin derrière la version actuelle.  Les systèmes de pub-sub ou d'événement traditionnels conviennent mieux aux petits messages qui sont envoyés séquentiellement.  Autrement dit, les destinataires peuvent créer une idée de l'ensemble des données en consommant l'intégralité (compressée) du flux d'événements.  Cependant, Gutenberg est destiné à publier et à utiliser une représentation complète et immuable d'un ensemble de données. <br><br><h3>  Développement et architecture </h3><br>  Gutenberg se compose d'un service gRPC et d'une API REST, ainsi que d'une bibliothèque client Java qui utilise l'API gRPC. <br><br><img src="https://habrastorage.org/webt/lw/bz/m_/lwbzm_dd871-cgpebuwlmorejd4.png"><br>  <i>Architecture de haut niveau</i> <br><br><h3>  Client </h3><br>  La bibliothèque cliente Gutenberg gère des tâches telles que la gestion d'un abonnement, le chargement / déchargement S3, <a href="https://github.com/Netflix/atlas">les</a> métriques <a href="https://github.com/Netflix/atlas">Atlas</a> et les paramètres qui peuvent être configurés à l'aide des propriétés <a href="https://github.com/Netflix/archaius">Archaius</a> .  Elle interagit avec le service Gutenberg via gRPC, en utilisant <a href="https://github.com/Netflix/eureka">Eureka</a> pour découvrir les services. <br><br><h3>  Publication </h3><br>  Les éditeurs utilisent généralement des API de haut niveau pour publier des chaînes, des fichiers et des tableaux d'octets.  Selon la taille des données, elles peuvent être publiées en tant que pointeur direct sur les données ou téléchargées sur S3, puis publiées en tant que pointeur de données S3.  Le client peut télécharger la charge utile vers S3 au nom de l'éditeur ou publier uniquement les métadonnées de charge utile déjà présentes dans S3. <br><br>  Les pointeurs de données directs sont automatiquement répliqués globalement.  Les données publiées dans S3 sont, par défaut, téléchargées par l'éditeur dans plusieurs domaines, bien que cela puisse également être personnalisé. <br><br><h3>  Gestion des abonnements </h3><br>  La bibliothèque cliente fournit la gestion des abonnements des destinataires.  Cela permet aux utilisateurs de créer des abonnements pour certains sujets à partir desquels la bibliothèque extrait des données (par exemple, de S3) afin de les transférer vers le destinataire défini par l'utilisateur.  Les abonnements fonctionnent selon le modèle d'enquête - ils demandent une nouvelle mise à jour au service toutes les 30 secondes, en envoyant la version qu'ils ont reçue en dernier.  Les clients abonnés n'utiliseront pas une version plus ancienne des données que celle dont ils disposent actuellement si elle n'est pas corrigée (voir «tolérance aux pannes» ci-dessous).  La logique de demande répétée est câblée et configurable.  Par exemple, les utilisateurs peuvent configurer Gutenberg pour utiliser des versions plus anciennes des données si le processus de téléchargement est interrompu ou pour traiter la dernière version des données au démarrage, le plus souvent afin de travailler avec des modifications de données incompatibles avec les commentaires.  Gutenberg fournit également un abonnement préconfiguré qui stocke les dernières données et sous le capot les met à jour atomiquement lorsque les changements arrivent.  Cela répond à la plupart des cas d'utilisation d'abonnement où les abonnés ne se soucient que de la valeur actuelle à un moment donné, ce qui permet aux utilisateurs de spécifier une valeur par défaut, par exemple, pour un sujet qui n'a jamais été publié auparavant (par exemple, si le thème est utilisé pour la configuration), ou s'il y a une erreur selon le sujet (pour éviter de bloquer le lancement du service quand il y a une valeur par défaut valide). <br><br><h3>  API du destinataire </h3><br>  Gutenberg fournit également des API clientes de haut niveau, qui sous le capot ont des API gRPC de bas niveau et offrent des fonctionnalités supplémentaires et la transparence de l'exécution des requêtes.  Un exemple est le téléchargement de données pour un thème et une version spécifiques, qui sont largement utilisés par les composants connectés à <a href="https://github.com/Netflix/hollow">Netflix Hollow</a> .  Un autre exemple est la réception de la dernière version d'un sujet à un certain moment - un cas d'utilisation courant pour le débogage ou l'enseignement de modèles d'apprentissage automatique. <br><br><h3>  Durabilité et "transparence" du client </h3><br>  Gutenberg a été conçu dans le but de permettre aux services destinataires de démarrer avec succès, plutôt que de garantir qu'ils commencent avec les données les plus récentes.  Pour cette raison, la bibliothèque cliente a été construite avec une logique de sauvegarde pour gérer les états lorsqu'elle ne peut pas interagir avec le service Gutenberg.  Si les requêtes HTTP échouent, le client charge le cache de métadonnées de sauvegarde de la rubrique publiée à partir de S3 et travaille avec lui.  Ce cache contient toutes les informations permettant de décider d'appliquer ou non la mise à jour et de récupérer les données (à partir des métadonnées de publication elles-mêmes ou de S3).  Cela permet aux clients de récupérer des données (qui sont potentiellement obsolètes, selon l'état actuel du cache de sauvegarde) sans utiliser le service. <br><br>  L'un des avantages de fournir une bibliothèque cliente est la possibilité d'obtenir des métriques qui peuvent être utilisées pour signaler des problèmes d'infrastructure en général et des erreurs dans des applications spécifiques.  Aujourd'hui, ces mesures sont utilisées par l'équipe de Gutenberg pour surveiller notre distribution SLI des publications et des alertes en cas de problèmes typiques.  Certains clients utilisent également ces mesures pour signaler des erreurs spécifiques à l'application, par exemple, des échecs de publication individuels ou un refus de sujet particulier. <br><br><h3>  Serveur </h3><br>  Gutenberg est une application <a href="https://github.com/Netflix/governator">Governator</a> / Tomcat qui fournit des points de terminaison gRPC et REST.  Il utilise le cluster Cassandra répliqué à l'échelle mondiale pour stocker et distribuer les métadonnées de publication dans chaque région.  Les instances qui traitent les demandes des destinataires sont mises à l'échelle séparément des instances qui traitent les demandes de publication.  Il y a environ 1 000 fois plus de demandes de publication que de demandes de publication.  De plus, cela vous permet de supprimer la dépendance du fait de la publication à la réception, de sorte qu'une augmentation soudaine des publications n'affectera pas la réception, et vice versa. <br><br>  Chaque instance du cluster de demandes de destinataires traite son propre cache en mémoire des publications récentes, en le retirant de Cassandra toutes les quelques secondes.  Cela est nécessaire pour traiter un grand nombre de demandes de réception provenant de clients signés sans transférer de trafic vers le cluster Cassandra.  De plus, les caches avec un petit pool de requêtes ttl protègent contre les pics de requête qui pourraient potentiellement ralentir Cassandra à un point tel qu'il affecte toute la région.  Nous avons eu des situations où des erreurs soudaines coïncidant avec la redistribution de grands clusters ont provoqué des interruptions du service Gutenberg.  De plus, nous utilisons le <a href="https://github.com/Netflix/concurrency-limits">limiteur de concurrence</a> adaptatif trouvé dans l'application d'origine pour supprimer les applications avec un comportement incorrect sans affecter les autres. <br><br>  Dans les cas où les données sont publiées dans S3 dans plusieurs régions, le serveur décide quel segment renvoyer au client pour téléchargement, en fonction de l'emplacement du client.  Il permet également au service de fournir au client un segment dans la région «la plus proche» ou de forcer le client à se déplacer vers une autre région si la région actuelle est déconnectée pour une raison ou une autre. <br><br>  Avant de renvoyer les données d'abonnement aux destinataires, Gutenberg vérifie d'abord la cohérence des données.  Si la vérification échoue et que l'abonné a déjà reçu des données, le service ne renvoie rien, ce qui signifie en fait que la mise à jour n'est pas disponible.  Si le client abonné n'a pas encore reçu de données (cela signifie généralement qu'il vient de démarrer), le service demande l'historique du sujet et renvoie la dernière valeur qui réussit le contrôle de cohérence.  Cela est dû au fait que nous observons des retards épisodiques dans la réplication au niveau de Cassandra, où au moment où les abonnés demandent de nouvelles données, les métadonnées associées à la dernière version publiée n'étaient que partiellement répliquées.  Cela peut amener le client à recevoir des données incomplètes, ce qui entraînera alors des erreurs de demande de données ou des erreurs dans la logique métier.  La réalisation de ces vérifications de cohérence sur le serveur protège les destinataires des alertes de cohérence possibles qui accompagnent le choix d'un service d'entrepôt de données. <br><br>  La capacité de surveiller les publications de sujets et de sites qui utilisent ces sujets est une fonction importante pour l'audit et la collecte d'informations sur l'utilisation.  Pour collecter ces données, le service intercepte les demandes des éditeurs et des destinataires (les deux demandes de mise à jour des données des abonnés et des autres) et les indexe dans Elasticsearch à l'aide du <a href="https://medium.com/netflix-techblog/keystone-real-time-stream-processing-platform-a3ee651812a">pipeline de</a> données <a href="https://medium.com/netflix-techblog/keystone-real-time-stream-processing-platform-a3ee651812a">Keystone</a> .  Nous avons donc la possibilité d'obtenir des données pour le suivi des sujets qui sont utilisés et qui ne sont plus là.  Nous publions des liens détaillés vers le tableau de bord Kibana à partir de l'interface utilisateur interne afin que les propriétaires de thèmes puissent gérer indépendamment leurs abonnés. <br><br>  Outre les clusters qui gèrent les demandes des éditeurs et des destinataires, le service Gutenberg lance un autre cluster qui traite les demandes périodiques.  En particulier, il résout deux problèmes: <br><br><ol><li>  Toutes les quelques minutes, toutes les dernières publications et métadonnées sont collectées et envoyées à S3.  Cela lance le démarrage du cache de sauvegarde, qui est utilisé par le client, comme décrit ci-dessus. </li><li>  Le garbage collector supprime les versions des rubriques qui ne répondent pas à leurs politiques de rétention.  Il supprime également les données qui lui sont associées (par exemple, les objets S3) et contribue à garantir un cycle de vie des données bien défini. </li></ol><br><h3>  Tolérance aux pannes </h3><br><h4>  Snap </h4><br>  Les déploiements infructueux se produisent dans le monde du développement d'applications, et les restaurations aux versions antérieures sont une stratégie courante pour résoudre de tels problèmes.  L'architecture pilotée par les données complique la situation, car le comportement est déterminé par des données qui évoluent avec le temps. <br><br>  Les données distribuées par Gutenberg influencent et dans de nombreux cas contrôlent le comportement du système.  Cela signifie qu'en cas de problème, vous avez besoin d'un moyen de revenir à une bonne version éprouvée des données.  Pour atténuer la situation, Gutenberg permet de "lier" le thème à une version spécifique.  Les broches remplacent la dernière version des données et forcent le client à mettre à niveau vers cette version, ce qui vous permet de résoudre rapidement une situation critique, plutôt que d'essayer de comprendre comment publier la dernière version de travail.  Vous pouvez même appliquer une liaison à la zone de publication afin que seuls les destinataires de cette zone puissent utiliser les données.  Les broches remplacent également les données publiées lors de la liaison active, mais lorsque la broche est supprimée, les clients recevront la dernière version, qui peut être la dernière version épinglée ou une nouvelle version publiée alors que l'ancienne était épinglée. <br><br><h3>  Déploiement séquentiel </h3><br>  Lors du déploiement d'un nouveau code, il est souvent recommandé de créer de nouveaux assemblys avec un sous-ensemble de trafic, de les déployer progressivement ou de réduire d'une autre manière les risques de déploiement en le ralentissant.  ,    ,    . <br><br>   ,   Gutenberg, —         <a href="https://medium.com/netflix-techblog/global-continuous-delivery-with-spinnaker-2a6896c23ba7">Spinnaker</a> .       ,         .      ,            .     , ,       ,      ,      ,    . ,           AWS-  . <br><br><h4>  </h4><br> Gutenberg   Netflix     .    Gutenberg       ,              6 .      –           ,        1-2   ,        12 . <br><br>    24-    ,      ,     .   ,         200,          7.    -    ,      ,      Hollow.     ,       ,      ,     – 60,     – 4. <br><br><h4>   </h4><br>   ,      Gutenberg: <br><br><ul><li> <b>  </b> :    Gutenberg   Java-,        Node.JS  Python-.       ,   REST API Gutenberg   .     ,       Node.JS  Python. </li><li> <b>   </b> :     Gutenberg               .        Gutenberg. </li><li> <b>  </b> :            ,     . ,                  . </li><li> <b> </b> : ,   Gutenberg,    Gutenberg     .            ,        . </li><li> <b> </b> :      ,     ,            .           ,   Elasticsearch. </li><li> <b>  </b> :   Netflix –       .           ,    Gutenberg  ,           . </li></ul><br>  <i>C’est tout.</i> <i>    <a href="https://otus.pw/RCke/"></a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479572/">https://habr.com/ru/post/fr479572/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479562/index.html">Créer la structure d'un bot multi-plateforme simple</a></li>
<li><a href="../fr479564/index.html">ClickHouse + Graphite: comment réduire considérablement la consommation d'espace disque</a></li>
<li><a href="../fr479566/index.html">Système de suppression de potentiel ou reverse engineering de la Matrice + preuve de temps simultané</a></li>
<li><a href="../fr479568/index.html">Je travaille en tant que programmeur dans une entreprise, mais je veux rencontrer mes 50 ans différemment</a></li>
<li><a href="../fr479570/index.html">Points d'entrée Python</a></li>
<li><a href="../fr479574/index.html">4 aspects de la gestion des services ITIL</a></li>
<li><a href="../fr479578/index.html">Externalisation de l'impression: comment vérifier que l'entrepreneur ne facture pas les montants des factures</a></li>
<li><a href="../fr479580/index.html">Golden canon grid: histoire d'horreur pour frontend</a></li>
<li><a href="../fr479584/index.html">Systèmes généraux de détection et de prévention des intrusions</a></li>
<li><a href="../fr479586/index.html">Efros Config Inspector profite même à ceux qui ne l'utilisent pas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>