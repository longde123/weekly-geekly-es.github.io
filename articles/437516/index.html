<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☮️ ☘️ 🤛🏼 Buscando errores en el SDK de Amazon Web Services para el código fuente de .NET ⚙️ 📃 🈁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saludos a todos los fanáticos de criticar el código de otra persona. :) Hoy, en nuestro laboratorio, el nuevo material de investigación es el código f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buscando errores en el SDK de Amazon Web Services para el código fuente de .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/437516/"><p><img src="https://habrastorage.org/getpro/habr/post_images/188/292/f27/188292f271dd0648b09f848dbe66efa6.png" alt="Imagen 1"></p><br>  Saludos a todos los fanáticos de criticar el código de otra persona.  :) Hoy, en nuestro laboratorio, el nuevo material de investigación es el código fuente del proyecto AWS SDK para .NET.  En un momento, escribimos un artículo sobre cómo verificar AWS SDK para C ++.  Entonces no había nada particularmente interesante.  Veamos cómo nos complacerá la versión .NET del AWS SDK.  Una buena oportunidad para demostrar una vez más las capacidades del analizador PVS-Studio, así como hacer que el mundo sea un poco más perfecto. <br><a name="habracut"></a><br>  El SDK .NET de Amazon Web Services (AWS) es un kit de herramientas para desarrolladores diseñado para crear aplicaciones basadas en .NET en la infraestructura de AWS y simplificar enormemente el proceso de escritura de código.  El SDK incluye suites API .NET para varios servicios de AWS como Amazon S3, Amazon EC2, DynamoDB y otros.  El código fuente del SDK está alojado en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . <br><br>  Como dije, en un momento escribimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un artículo</a> sobre cómo verificar AWS SDK para C ++.  El artículo resultó ser pequeño: solo hubo un par de errores en 512 mil líneas de código.  Esta vez estamos lidiando con una cantidad de código mucho mayor, que incluye aproximadamente 34 mil archivos cs, y el número total de líneas de código (excluyendo los vacíos) es de 5 millones impresionantes.  Una pequeña parte del código (200 mil líneas en 664 archivos cs) cae en las pruebas, no las consideré. <br><br>  Si la calidad del código .NET de la versión del SDK es aproximadamente la misma que la de C ++ (dos errores por 512 KLOC), entonces deberíamos obtener aproximadamente 10 veces más errores.  Este, por supuesto, es un método de cálculo muy inexacto que no tiene en cuenta las características del lenguaje y muchos otros factores, pero no creo que el lector ahora quiera profundizar en debates aburridos.  En cambio, propongo ir directamente a los resultados. <br><br>  La verificación se realizó con PVS-Studio versión 6.27.  Increíblemente, el analizador pudo detectar alrededor de 40 errores en el SDK de AWS para el código .NET que vale la pena mencionar.  Esto indica no solo la alta calidad del código SDK (aproximadamente 4 errores por 512 KLOC), sino también la calidad comparable del trabajo C # del analizador PVS-Studio en comparación con C ++.  Gran resultado! <br><br>  Los autores del AWS SDK para .NET son geniales.  De proyecto a proyecto, demuestran una increíble calidad de código.  Esto puede servir como un buen ejemplo para otros equipos.  Pero, por supuesto, no sería el desarrollador de un analizador estático si no hubiera insertado mis 5 kopecks.  :) Ya estamos trabajando con el equipo de Amazon Lumberyard en el uso de PVS-Studio.  Pero como se trata de una empresa muy grande con un montón de divisiones en todo el mundo, es muy probable que el SDK de AWS para el equipo .NET nunca haya oído hablar de PVS-Studio.  En cualquier caso, en el código SDK no encontré ningún signo de uso de nuestro analizador, aunque esto no significa nada.  Sin embargo, el equipo, como mínimo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">utiliza el</a> analizador integrado en Visual Studio.  Esto es bueno, pero las comprobaciones de código se pueden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mejorar</a> :). <br><br>  Como resultado, logré encontrar algunos errores en el código SDK y, finalmente, es hora de compartirlos. <br><br>  <b>Error en la logica</b> <br><br>  <b>Advertencia de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3008</a> [CWE-563] La variable 'this.linker.s3.region' tiene valores asignados dos veces sucesivamente.  Quizás esto sea un error.  Líneas de verificación: 116, 114. AWSSDK.DynamoDBv2.Net45 S3Link.cs 116 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Region { get { .... } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(value)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = <span class="hljs-string"><span class="hljs-string">"us-east-1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = value; } }</code> </pre> <br>  El analizador advierte de reasignar el valor de la misma variable.  A partir del código, queda claro que esto se debe a un error que viola la lógica de operación: el valor de la variable <i>this.linker.s3.region</i> siempre será igual al <i>valor</i> , independientemente de la condición <i>if (String.IsNullOrEmpty (valor))</i> .  En el cuerpo del bloque <i>if</i> , se omitió el <i>retorno</i> .  El código debe repararse de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Region { get { .... } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(value)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = <span class="hljs-string"><span class="hljs-string">"us-east-1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = value; } }</code> </pre> <br>  <b>Recursión infinita</b> <br><br>  <b>Advertencia de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3110</a> [CWE-674] Posible recursión infinita dentro de la propiedad 'OnFailure'.  AWSSDK.ElasticMapReduce.Net45 ResizeJobFlowStep.cs 171 <br><br><pre> <code class="cpp hljs">OnFailure? onFailure = null; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OnFailure? OnFailure { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.OnFailure; } <span class="hljs-comment"><span class="hljs-comment">// &lt;= set { this.onFailure = value; } }</span></span></code> </pre> <br>  Un ejemplo clásico de error tipográfico que causa una recursión infinita en el <i>get</i> <i>getor de la</i> propiedad <i>OnFailure</i> .  En lugar de devolver el valor del campo privado, <i>onFailure se</i> refiere a la propiedad <i>OnFailure</i> .  Opción corregida: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OnFailure? OnFailure { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onFailure; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onFailure = value; } }</code> </pre> <br>  Usted pregunta: "¿Cómo funcionó?"  Hasta ahora, de ninguna manera.  La propiedad no se usa en ningún lado, pero es temporal.  En un momento, alguien comenzará a usarlo y definitivamente obtendrá un resultado inesperado.  Para evitar estos errores tipográficos, se recomienda no utilizar identificadores que difieran solo en el caso de la primera letra. <br><br>  Otra nota de este diseño es el uso de un identificador que coincide completamente con el nombre del tipo <i>OnFailure</i> .  Desde el punto de vista del compilador, esto es bastante aceptable, pero dificulta la percepción humana del código. <br><br>  Otro error similar: <br><br>  <b>Advertencia de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3110</a> [CWE-674] Posible recursión infinita dentro de la propiedad 'SSES3'.  AWSSDK.S3.Net45 InventoryEncryption.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SSES3 sSES3; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SSES3 SSES3 { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SSES3; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SSES3 = value; } }</code> </pre> <br>  La situación es idéntica a la descrita anteriormente.  Solo aquí, se producirá una recursión infinita al acceder a la propiedad <i>SSES3</i> tanto <i>para</i> leer como para escribir.  Opción corregida: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SSES3 SSES3 { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sSES3; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sSES3 = value; } }</code> </pre> <br>  <b>Prueba de atención plena</b> <br><br>  La siguiente es una tarea de un programador que está interesado en usar la técnica Copiar-Pegar.  Mire cómo se ve el código en el editor de Visual Studio e intente encontrar el error. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bfa/71b/1ab/bfa71b1ab4af941c43e5349df51b1614.png" alt="Cuadro 3"></p><br>  <b>Advertencia de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3029</a> Las expresiones condicionales de las declaraciones 'if' ubicadas una junto a la otra son idénticas.  Líneas de verificación: 91, 95. AWSSDK.AppSync.Net45 CreateApiKeyResponseUnmarshaller.cs 91 <br><br>  <i>Reduje</i> el cuerpo del método <i>UnmarshallException</i> , eliminando todo lo innecesario.  Ahora puede ver que verificaciones idénticas se suceden una tras otra: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override AmazonServiceException </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnmarshallException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorResponse.Code != null &amp;&amp; errorResponse.Code.Equals(<span class="hljs-string"><span class="hljs-string">"LimitExceededException"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitExceededException(errorResponse.Message, innerException, errorResponse.Type, errorResponse.Code, errorResponse.RequestId, statusCode); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorResponse.Code != null &amp;&amp; errorResponse.Code.Equals(<span class="hljs-string"><span class="hljs-string">"LimitExceededException"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitExceededException(errorResponse.Message, innerException, errorResponse.Type, errorResponse.Code, errorResponse.RequestId, statusCode); } .... }</code> </pre> <br>  Puede parecer que el error no es grave, solo un cheque adicional.  Pero a menudo, este patrón puede indicar problemas más serios en el código cuando no se realiza alguna verificación necesaria. <br><br>  Hay algunos errores más similares en el código. <br><br>  <b>Advertencias de PVS-Studio:</b> <br><br><ul><li>  V3029 Las expresiones condicionales de las declaraciones 'if' ubicadas una junto a la otra son idénticas.  Verificación de líneas: 75, 79. AWSSDK.CloudDirectory.Net45 CreateSchemaResponseUnmarshaller.cs 75 </li><li>  V3029 Las expresiones condicionales de las declaraciones 'if' ubicadas una junto a la otra son idénticas.  Líneas de verificación: 105, 109. AWSSDK.CloudDirectory.Net45 GetSchemaAsJsonResponseUnmarshaller.cs 105 </li><li>  V3029 Las expresiones condicionales de las declaraciones 'if' ubicadas una junto a la otra son idénticas.  Líneas de verificación: 201, 205. AWSSDK.CodeCommit.Net45 PostCommentForPullRequestResponseUnmarshaller.cs 201 </li><li>  V3029 Las expresiones condicionales de las declaraciones 'if' ubicadas una junto a la otra son idénticas.  Verificación de líneas: 101, 105. AWSSDK.CognitoIdentityProvider.Net45 VerifySoftwareTokenResponseUnmarshaller.cs 101 </li><li>  V3029 Las expresiones condicionales de las declaraciones 'if' ubicadas una junto a la otra son idénticas.  Líneas de verificación: 72, 76. AWSSDK.Glue.Net45 UpdateConnectionResponseUnmarshaller.cs 72 </li><li>  V3029 Las expresiones condicionales de las declaraciones 'if' ubicadas una junto a la otra son idénticas.  Líneas de verificación: 123, 127. AWSSDK.Neptune.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 123 </li><li>  V3029 Las expresiones condicionales de las declaraciones 'if' ubicadas una junto a la otra son idénticas.  Líneas de verificación: 167, 171. AWSSDK.Neptune.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 167 </li><li>  V3029 Las expresiones condicionales de las declaraciones 'if' ubicadas una junto a la otra son idénticas.  Líneas de verificación: 127, 131. AWSSDK.RDS.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 127 </li><li>  V3029 Las expresiones condicionales de las declaraciones 'if' ubicadas una junto a la otra son idénticas.  Líneas de verificación: 171, 175. AWSSDK.RDS.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 171 </li><li>  V3029 Las expresiones condicionales de las declaraciones 'if' ubicadas una junto a la otra son idénticas.  Verifique las líneas: 99, 103. AWSSDK.Rekognition.Net45 RecognizeCelebritiesResponseUnmarshaller.cs 99 </li></ul><br>  <b>Que eres</b> <br><br>  <b>Advertencia de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3062</a> Se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usa</a> un objeto 'attributeName' como argumento de su propio método.  Considere verificar el primer argumento real del método 'Contiene'.  AWSSDK.MobileAnalytics.Net45 CustomEvent.cs 261 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Dictionary that stores attribute for this event only. /// &lt;/summary&gt; private Dictionary&lt;string,string&gt; _attributes = new Dictionary&lt;string,string&gt;(); /// &lt;summary&gt; /// Gets the attribute. /// &lt;/summary&gt; /// &lt;param name="attributeName"&gt;Attribute name.&lt;/param&gt; /// &lt;returns&gt;The attribute. Return null of attribute doesn't /// exist.&lt;/returns&gt; public string GetAttribute(string attributeName) { if(string.IsNullOrEmpty(attributeName)) { throw new ArgumentNullException("attributeName"); } string ret = null; lock(_lock) { if(attributeName.Contains(attributeName)) // &lt;= ret = _attributes[attributeName]; } return ret; }</span></span></code> </pre> <br>  El analizador detectó un error en el método <i>GetAttribute</i> : se verifica que la cadena se contenga.  De la descripción del método, se deduce que si se encuentra el nombre del atributo (clave <i>attributeName</i> ) (en el diccionario <i>_attributes</i> ), el valor del atributo debe devolverse, de lo contrario, será <i>nulo</i> .  En realidad, dado que la condición <i>attributeName.Contains (attributeName)</i> siempre <i>es</i> verdadera, se intenta devolver un valor mediante una clave que puede no encontrarse en el diccionario.  Luego, en lugar de devolver <i>nulo, se</i> <i>lanzará</i> <i>una</i> <i>KeyNotFoundException</i> . <br><br>  Intentemos arreglar este código.  Para comprender mejor cómo hacer esto, eche un vistazo a otro método: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Determines whether this instance has attribute the specified /// attributeName. /// &lt;/summary&gt; /// &lt;param name="attributeName"&gt;Attribute name.&lt;/param&gt; /// &lt;returns&gt;Return true if the event has the attribute, else /// false.&lt;/returns&gt; public bool HasAttribute(string attributeName) { if(string.IsNullOrEmpty(attributeName)) { throw new ArgumentNullException("attributeName"); } bool ret = false; lock(_lock) { ret = _attributes.ContainsKey(attributeName); } return ret; }</span></span></code> </pre> <br>  Este método verifica si el nombre del atributo (clave <i>attributeName</i> ) <i>existe</i> en el diccionario <i>_attributes</i> .  <i>Volvamos</i> al método <i>GetAttribute</i> y <i>arreglemos</i> el error: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> attributeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(attributeName)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"attributeName"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret = null; lock(_lock) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_attributes.ContainsKey(attributeName)) ret = _attributes[attributeName]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br>  Ahora el método hace exactamente lo que se indica en la descripción. <br><br>  Y un pequeño comentario más a este fragmento de código.  Noté que los autores usan el <i>bloqueo</i> cuando trabajan con el diccionario <i>_attributes</i> .  Claramente, esto es necesario con acceso multiproceso, pero la construcción de la <i>cerradura</i> es bastante lenta y engorrosa.  En lugar de <i>Diccionario</i> en este caso, podría ser más conveniente usar una versión segura del subproceso del diccionario: <i>ConcurrentDictionary</i> .  Entonces la necesidad de <i>bloqueo</i> desaparece.  Aunque, tal vez no conozco ninguna característica del proyecto. <br><br>  <b>Comportamiento sospechoso</b> <br><br>  <b>Advertencia de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3063</a> [CWE-571] Una parte de la expresión condicional siempre es verdadera si se evalúa: string.IsNullOrEmpty (inferredIndexName).  AWSSDK.DynamoDBv2.PCL ContextInternal.cs 802 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetQueryIndexName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> inferredIndexName = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(specifiedIndexName) &amp;&amp; indexNames.Count == <span class="hljs-number"><span class="hljs-number">1</span></span>) { inferredIndexName = indexNames[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexNames.Contains(specifiedIndexName, StringComparer.Ordinal)) { inferredIndexName = specifiedIndexName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(inferredIndexName) &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// &lt;= indexNames.Count &gt; 0) throw new InvalidOperationException("Local Secondary Index range key conditions are used but no index could be inferred from model. Specified index name = " + specifiedIndexName); .... }</span></span></code> </pre> <br>  El analizador alertó la <i>verificación string.IsNullOrEmpty (inferredIndexName)</i> .  De hecho, la cadena <i>inferredIndexName se</i> asigna como <i>nula</i> , luego el valor de esta variable no se cambia en ninguna parte y, por alguna razón, se verifica si es <i>nula</i> o una cadena vacía.  Parece sospechoso  Echemos un vistazo de cerca al fragmento de código dado.  Deliberadamente no lo reduje para una mejor comprensión de la situación.  Por lo tanto, en la primera <i>instrucción if</i> (y también en la siguiente), la variable IndexIndexName <i>especificada</i> se verifica de alguna manera.  Dependiendo del resultado de las comprobaciones, la variable <i>inferredIndexName</i> recibe un nuevo valor.  Ahora prestemos atención a la tercera <i>declaración if</i> .  El cuerpo de esta declaración (lanzando una excepción) se ejecutará si <i>indexNames.Count&gt; 0</i> , ya que la primera parte de la condición es <i>string.IsNullOrEmpty (inferredIndexName)</i> siempre es verdadero.  Quizás las variables <i>especificadas</i> como <i>IndexIndex</i> y <i>inferredIndexName</i> simplemente se confunden.  O la tercera verificación debe ser sin <i>otra cosa</i> , representando una <i>declaración if</i> independiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(specifiedIndexName) &amp;&amp; indexNames.Count == <span class="hljs-number"><span class="hljs-number">1</span></span>) { inferredIndexName = indexNames[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexNames.Contains(specifiedIndexName, StringComparer.Ordinal)) { inferredIndexName = specifiedIndexName; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(inferredIndexName) &amp;&amp; indexNames.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(....);</code> </pre> <br>  En este caso, es difícil dar una respuesta inequívoca sobre las opciones para corregir este código.  Pero definitivamente es necesario que el autor lo inspeccione. <br><br>  <b>NullReferenceException</b> <br><br>  <b>Advertencia de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3095</a> [CWE-476] El objeto 'conditionValues' se usó antes de que se verificara como nulo.  Líneas de verificación: 228, 238. AWSSDK.Core.Net45 JsonPolicyWriter.cs 228 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeConditions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { IList&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; conditionValues = keyEntry.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; .... if (conditionValues != null &amp;&amp; conditionValues.Count != 0) { .... } .... } }</span></span></code> </pre> <br>  Clásicos del género.  La variable <i>conditionValues ​​se</i> usa sin verificar primero <i>null</i> .  Además, más adelante en el código se realiza dicha verificación, pero es demasiado tarde.  :) <br><br>  El código se puede arreglar de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeConditions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { IList&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; conditionValues = keyEntry.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues != null &amp;&amp; conditionValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues != null &amp;&amp; conditionValues.Count != <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } .... } }</code> </pre> <br>  Se encontraron algunos errores más similares en el código. <br><br>  <b>Advertencias de PVS-Studio:</b> <br><br><ul><li>  V3095 [CWE-476] El objeto 'ts.Listeners' se usó antes de que se verificara como nulo.  Líneas de verificación: 140, 143. AWSSDK.Core.Net45 Logger.Diagnostic.cs 140 </li><li>  V3095 [CWE-476] El objeto 'obj' se usó antes de que se verificara como nulo.  Líneas de verificación: 743, 745. AWSSDK.Core.Net45 JsonMapper.cs 743 </li><li>  V3095 [CWE-476] El objeto 'multipartUploadMultipartUploadpartsList' se usó antes de que se verificara contra nulo.  Verifique las líneas: 65, 67. AWSSDK.S3.Net45 CompleteMultipartUploadRequestMarshaller.cs 65 </li></ul><br>  La siguiente advertencia es muy similar en significado, pero la situación es inversa a la que se discutió anteriormente. <br><br>  <b>Advertencia de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3125</a> [CWE-476] El objeto 'estado' se usó después de que se verificó contra nulo.  Líneas de verificación: 139, 127. AWSSDK.Core.Net45 RefreshingAWSCredentials.cs 139 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateToGeneratedCredentials</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( CredentialsRefreshState state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> errorMessage; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShouldUpdate) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == null) errorMessage = <span class="hljs-string"><span class="hljs-string">"Unable to generate temporary credentials"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AmazonClientException(errorMessage); } state.Expiration -= PreemptExpiryTime; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Uno de los fragmentos de código contiene una comprobación de la variable de <i>estado</i> para <i>nulo</i> .  Además, según el código, la variable de <i>estado</i> se usa para cancelar la suscripción del evento <i>PreemptExpiryTime</i> , mientras que la comprobación de <i>nulo</i> ya no se realiza y <i>es posible</i> una <i>NullReferenceException</i> .  Opción de código más seguro: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateToGeneratedCredentials</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( CredentialsRefreshState state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> errorMessage; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShouldUpdate) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == null) errorMessage = <span class="hljs-string"><span class="hljs-string">"Unable to generate temporary credentials"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AmazonClientException(errorMessage); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state != null) state.Expiration -= PreemptExpiryTime; .... }</code> </pre> <br>  Hay otros errores similares en el código. <br><br>  <b>Advertencias de PVS-Studio:</b> <br><br><ul><li>  V3125 [CWE-476] El objeto 'wrapRequest.Content' se usó después de que se verificó contra nulo.  Líneas de verificación: 395, 383. AWSSDK.Core.Net45 HttpHandler.cs 395 </li><li>  V3125 [CWE-476] El objeto 'datasetUpdates' se usó después de que se verificó contra nulo.  Líneas de verificación: 477, 437. AWSSDK.CognitoSync.Net45 Dataset.cs 477 </li><li>  V3125 [CWE-476] El objeto 'cORSConfigurationCORSConfigurationcORSRulesListValue' se usó después de que se verificó contra nulo.  Líneas de verificación: 125, 111. AWSSDK.S3.Net45 PutCORSConfigurationRequestMarshaller.cs 125 </li><li>  V3125 [CWE-476] El objeto 'lifecycleConfigurationLifecycleConfigurationrulesListValue' se usó después de que se verificó contra nulo.  Líneas de verificación: 157, 68. AWSSDK.S3.Net45 PutLifecycleConfigurationRequestMarshaller.cs 157 </li><li>  V3125 [CWE-476] El objeto 'this.Key' se usó después de que se verificó contra nulo.  Líneas de verificación: 199, 183. AWSSDK.S3.Net45 S3PostUploadRequest.cs 199 </li></ul><br>  <b>Realidad incontestada</b> <br><br>  <b>Advertencia de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3009</a> [CWE-393] Es extraño que este método siempre devuelva el mismo valor de 'verdadero'.  AWSSDK.Core.Net45 Lexer.cs 651 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State19</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'"'</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'\\'</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  El método siempre devuelve <i>verdadero</i> .  Veamos cuán crítico es esto para el código de llamada.  Seguí el uso del método <i>State19</i> .  Participa en el llenado de la matriz de controladores <i>fsm_handler_table</i> junto con otros métodos similares (hay 28 de ellos con nombres, respectivamente, de <i>State1</i> a <i>State28</i> ).  Es importante señalar aquí que, además de <i>State19</i> , también se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">emitieron</a> advertencias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3009</a> [CWE-393] para algunos otros manejadores.  Estos son los controladores: <i>Estado23, Estado26, Estado27, Estado28</i> .  Alertas emitidas por el analizador para ellos: <br><br><ul><li>  V3009 [CWE-393] Es extraño que este método siempre devuelva el mismo valor de 'verdadero'.  AWSSDK.Core.Net45 Lexer.cs 752 </li><li>  V3009 [CWE-393] Es extraño que este método siempre devuelva el mismo valor de 'verdadero'.  AWSSDK.Core.Net45 Lexer.cs 810 </li><li>  V3009 [CWE-393] Es extraño que este método siempre devuelva el mismo valor de 'verdadero'.  AWSSDK.Core.Net45 Lexer.cs 822 </li><li>  V3009 [CWE-393] Es extraño que este método siempre devuelva el mismo valor de 'verdadero'.  AWSSDK.Core.Net45 Lexer.cs 834 </li></ul><br>  Así es como se ve la declaración y la inicialización de la matriz del controlador: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StateHandler[] fsm_handler_table; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PopulateFsmTables</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fsm_handler_table = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StateHandler[<span class="hljs-number"><span class="hljs-number">28</span></span>] { State1, State2, .... State19, .... State23, .... State26, State27, State28 };</code> </pre> <br>  Para completar, veamos el código de uno de los manejadores, ante el cual el analizador no tenía quejas, por ejemplo, <i>Estado2</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State2</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Y así es como se llaman los controladores: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextToken</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { handler = fsm_handler_table[state - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! handler (fsm_context)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw new JsonException (input_char); .... } .... }</span></span></code> </pre> <br>  Como puede ver, se lanzará una excepción si <i>se</i> devuelve <i>falso</i> .  En nuestro caso, para los manejadores <i>State19, State23, State26, State27</i> y <i>State28</i> esto nunca sucederá.  Parece sospechoso  Por otro lado, hasta cinco controladores tienen un comportamiento similar (siempre devuelve <i>verdadero</i> ), por lo que tal vez esto fue intencionado y no es el resultado de un error tipográfico. <br><br>  ¿Por qué me detengo en todo esto con tanto detalle?  Esta situación es muy indicativa en el sentido de que un analizador estático a menudo solo puede indicar un diseño sospechoso.  E incluso una persona (no una máquina) que no tiene suficiente conocimiento sobre el proyecto, después de haber estudiado el código, todavía no puede dar una respuesta exhaustiva sobre la presencia de un error.  El desarrollador debe estudiar el código. <br><br>  <b>Verificaciones sin sentido</b> <br><br>  <b>Advertencia de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3022</a> [CWE-571] La expresión 'doLog' siempre es verdadera.  AWSSDK.Core.Net45 StoredProfileAWSCredentials.cs 235 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidCredentialsExistInSharedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var doLog = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { doLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InvalidDataException) { doLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doLog) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... } .... }</span></span></code> </pre> <br>  Presta atención a la variable <i>doLog</i> .  Después de la inicialización con <i>falso</i> , en el código esta variable se volverá <i>verdadera</i> en todos los casos.  Entonces la verificación <i>if (doLog)</i> siempre es verdadera.  Quizás hubo una rama anterior en este método en la que a la variable <i>doLog</i> no <i>se</i> le asignó ningún valor, luego, en el momento de la verificación, podría contener el valor <i>falso</i> obtenido durante la inicialización.  Pero ahora no existe tal rama. <br><br>  Otro error similar: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Advertencia de</a> <b>PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3022 La</a> expresión '! Resultado' siempre es falsa.  AWSSDK.CognitoSync.PCL SQLiteLocalStorage.cs 353 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PutValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = PutValueHelper(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!result) &lt;= { _logger.DebugFormat(<span class="hljs-string"><span class="hljs-string">"{0}"</span></span>, @<span class="hljs-string"><span class="hljs-string">"Cognito Sync - SQLiteStorage - Put Value Failed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { UpdateLastModifiedTimestamp(....); } .... }</code> </pre> <br>  El analizador afirma que el valor de la variable de <i>resultado</i> siempre es <i>verdadero</i> .  Esto solo es posible si el método <i>PutValueHelper</i> siempre devolverá <i>verdadero</i> .  Echa un vistazo a este método: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PutValueHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record == null) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br>  De hecho, el método volverá <i>verdadero</i> bajo cualquier condición.  Además, el analizador emitió una advertencia para este método.  <b>Advertencia de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3009</a> [CWE-393] Es extraño que este método siempre devuelva el mismo valor de 'verdadero'.  SQLiteLocalStorage.cs 1016 <br><br>  Deliberadamente no cité esta advertencia antes cuando estaba considerando otros errores de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3009</a> , pero la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">guardé</a> para este caso.  Por lo tanto, el analizador tenía razón al indicar el error <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3022</a> en el código de llamada. <br><br>  <b>Copiar y pegar.</b>  <b>De nuevo</b> <br><br>  <b>Advertencia de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3001</a> Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subexpresiones</a> idénticas 'this.token == JsonToken.String' a la izquierda y a la derecha de '||'  operador  AWSSDK.Core.Net45 JsonReader.cs 343 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.ObjectEnd || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.ArrayEnd || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.String || <span class="hljs-comment"><span class="hljs-comment">// &lt;= this.token == JsonToken.Boolean || this.token == JsonToken.Double || this.token == JsonToken.Int || this.token == JsonToken.UInt || this.token == JsonToken.Long || this.token == JsonToken.ULong || this.token == JsonToken.Null || this.token == JsonToken.String // &lt;= )) { .... } .... }</span></span></code> </pre> <br>  Compare dos <i>veces el</i> campo <i>this.token</i> con el valor <i>JsonToken.String</i> de la enumeración <i>JsonToken</i> .  Probablemente una de las comparaciones debería contener un valor de enumeración diferente.  Si es así, entonces se ha cometido un grave error. <br><br>  <b>Refactorización + descuido?</b> <br><br>  <b>Advertencia de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3025</a> [CWE-685] Formato incorrecto.  Se espera un número diferente de elementos de formato al llamar a la función 'Formatear'.  Argumentos no utilizados: AWSConfigs.AWSRegionKey.  AWSSDK.Core.Net45 AWSRegion.cs 116 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstanceProfileAWSRegion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Format(CultureInfo.InvariantCulture, <span class="hljs-string"><span class="hljs-string">"EC2 instance metadata was not available or did not contain region information."</span></span>, AWSConfigs.AWSRegionKey)); } .... }</code> </pre> <br>  Probablemente, la cadena de formato para el método <i>string.Format</i> contenía previamente el especificador de salida <i>{0}</i> , para el cual se estableció el argumento <i>AWSConfigs.AWSRegionKey</i> .  Luego se cambió la línea, el especificador desapareció, pero olvidaron eliminar el argumento.  El fragmento de código anterior funciona sin errores (se generaría una excepción en el caso contrario, un especificador sin argumento), pero se ve feo.  El código debe arreglarse de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( <span class="hljs-string"><span class="hljs-string">"EC2 instance metadata was not available or did not contain region information."</span></span>); }</code> </pre> <br>  <b>Inseguro</b> <br><br>  <b>Advertencia de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3083</a> [CWE-367] Invocación insegura del evento 'mOnSyncSuccess', es posible NullReferenceException.  Considere asignar un evento a una variable local antes de invocarlo.  AWSSDK.CognitoSync.PCL Dataset.cs 827 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FireSyncSuccessEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Record&gt; records)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mOnSyncSuccess != null) { mOnSyncSuccess(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SyncSuccessEventArgs(records)); } }</code> </pre> <br>  Una situación bastante común de una llamada insegura al controlador de eventos.  Entre verificar la variable <i>mOnSyncSuccess</i> para <i>nulo</i> y llamar al controlador, se puede cancelar la suscripción de un evento y su valor se convertirá en cero.  La probabilidad de tal escenario es pequeña, pero aún es mejor hacer que el código sea más seguro: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FireSyncSuccessEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Record&gt; records)</span></span></span><span class="hljs-function"> </span></span>{ mOnSyncSuccess?.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SyncSuccessEventArgs(records)); }</code> </pre> <br>  Hay otros errores similares en el código. <br><br>  <b>Advertencias de PVS-Studio:</b> <br><br><ul><li>  V3083 [CWE-367] Invocación insegura del evento 'mOnSyncFailure', NullReferenceException es posible.  Considere asignar un evento a una variable local antes de invocarlo.  AWSSDK.CognitoSync.PCL Dataset.cs 839 </li><li>  V3083 [CWE-367] Invocación de evento insegura, NullReferenceException es posible.  Considere asignar un evento a una variable local antes de invocarlo.  AWSSDK.Core.PCL AmazonServiceClient.cs 332 </li><li>  V3083 [CWE-367] Invocación de evento insegura, NullReferenceException es posible.  Considere asignar un evento a una variable local antes de invocarlo.  AWSSDK.Core.PCL AmazonServiceClient.cs 344 </li><li>  V3083 [CWE-367] Invocación de evento insegura, NullReferenceException es posible.  Considere asignar un evento a una variable local antes de invocarlo.  AWSSDK.Core.PCL AmazonServiceClient.cs 357 </li><li>  V3083 [CWE-367] Invocación insegura del evento 'mExceptionEvent', NullReferenceException es posible.  Considere asignar un evento a una variable local antes de invocarlo.  AWSSDK.Core.PCL AmazonServiceClient.cs 366 </li><li>  V3083 [CWE-367] Invocación de evento insegura, NullReferenceException es posible.  Considere asignar un evento a una variable local antes de invocarlo.  AWSSDK.Core.PCL AmazonWebServiceRequest.cs 78 </li><li>  V3083 [CWE-367] La ​​invocación insegura del evento 'OnRead', NullReferenceException es posible.  Considere asignar un evento a una variable local antes de invocarlo.  AWSSDK.Core.PCL EventStream.cs 97 </li><li>  V3083 [CWE-367] Invocación de evento insegura, NullReferenceException es posible.  Considere asignar un evento a una variable local antes de invocarlo.  AWSSDK.Core.Android NetworkReachability.cs 57 </li><li>  V3083 [CWE-367] Invocación de evento insegura, NullReferenceException es posible.  Considere asignar un evento a una variable local antes de invocarlo.  AWSSDK.Core.Android NetworkReachability.cs 94 </li><li>  V3083 [CWE-367] Invocación de evento insegura, NullReferenceException es posible.  Considere asignar un evento a una variable local antes de invocarlo.  AWSSDK.Core.iOS NetworkReachability.cs 54 </li></ul><br>  <b>Clase inacabada</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Advertencia de</a> <b>PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3126</a> Tipo 'JsonData' que implementa la interfaz IEquatable &lt;T&gt; no anula el método 'GetHashCode'.  AWSSDK.Core.Net45 JsonData.cs 26 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonData</span></span></span><span class="hljs-class"> :</span></span> IJsonWrapper, IEquatable&lt;JsonData&gt; { .... }</code> </pre> <br>  La clase <i>JsonData</i> contiene mucho código, por lo que no lo di en su totalidad, limitándome solo a la declaración.  Esta clase realmente no contiene un método anulado <i>GetHashCode</i> , que no es seguro ya que puede conducir a un comportamiento erróneo cuando se usa el tipo <i>JsonData</i> para trabajar, por ejemplo, con colecciones.  Probablemente no haya ningún problema en este momento, pero la estrategia para usar este tipo puede cambiar en el futuro.  Este error se describe con más detalle en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> . <br><br>  <b>Conclusión</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esos son todos los errores interesantes que logré detectar en AWS SDK para código .NET usando el analizador estático PVS-Studio. </font><font style="vertical-align: inherit;">Una vez más, enfatizo la calidad del proyecto. </font><font style="vertical-align: inherit;">Encontré un número muy pequeño de errores para 5 millones de líneas de código. </font><font style="vertical-align: inherit;">Aunque, probablemente, un análisis más exhaustivo de las advertencias emitidas me permitiría agregar algunos errores más a esta lista. </font><font style="vertical-align: inherit;">Pero también es muy probable que clasifique en vano algunas de las advertencias descritas como errores. </font><font style="vertical-align: inherit;">En este caso, solo el desarrollador, que está en el contexto del código que se verifica, siempre saca conclusiones inequívocas.</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si desea compartir este artículo con una audiencia de habla inglesa, utilice el enlace a la traducción: Sergey Khrenov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Búsqueda de errores en el código fuente del SDK de Amazon Web Services para .NET</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437516/">https://habr.com/ru/post/437516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437504/index.html">Pequeños componentes: ¿qué podría salir mal? Utilizamos el principio de responsabilidad exclusiva.</a></li>
<li><a href="../437508/index.html">CVE-2019-6111 y otras vulnerabilidades scp</a></li>
<li><a href="../437510/index.html">¿Qué sucede cuando envías SMS?</a></li>
<li><a href="../437512/index.html">¿Qué son las funciones puras en JavaScript?</a></li>
<li><a href="../437514/index.html">Búsqueda de errores en el código fuente del SDK de Amazon Web Services para .NET</a></li>
<li><a href="../437518/index.html">Ataque de escarabajos</a></li>
<li><a href="../437520/index.html">“¡Mi luz es un espejo! - dime, muéstrame mi doble ... ": diseña un buen marco y obtén el segundo como regalo</a></li>
<li><a href="../437522/index.html">Colonia Capítulo 22: Decisión final</a></li>
<li><a href="../437524/index.html">Crea una IA de ajedrez simple: 5 sencillos pasos</a></li>
<li><a href="../437526/index.html">Representación volumétrica en WebGL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>