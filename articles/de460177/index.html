<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò∏Ô∏è üßñüèº üöñ Drahtloser Wasserlecksensor auf nRF52832, DIY-Projekt üòÆ üå•Ô∏è üë©üèø‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gr√º√üe an alle Leser des DIY- oder Do-it-yourself-Bereichs auf Habr! Heute m√∂chte ich √ºber mein n√§chstes Projekt sprechen. In diesem Artikel geht es um...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Drahtloser Wasserlecksensor auf nRF52832, DIY-Projekt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460177/">  Gr√º√üe an alle Leser des DIY- oder Do-it-yourself-Bereichs auf Habr!  Heute m√∂chte ich √ºber mein n√§chstes Projekt sprechen. In diesem Artikel geht es um einen batteriebetriebenen Wasserleckdetektor.  Wie in fr√ºheren Projekten l√§uft dieses Ger√§t auf dem Mikrocontroller nRF52832.  Es gibt drei Versionen dieses Sensors. In allen drei Versionen werden vorgefertigte Module mit nRF52832 verwendet. In diesem Artikel wird auf die mittlere Version eingegangen, die das YJ-17103-Modul von HOLYIOT verwendet. <br><br><img src="https://habrastorage.org/webt/cu/jp/np/cujpnppmqhppnxx4ytplarqgfgs.jpeg"><br><a name="habracut"></a><br>  Der Fl√ºssigkeitsdetektor ist auf dem Chip SN74LVC1G00 | implementiert  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datashit</a> .  Ich werde kurz das Schaltungsdesign und das Funktionsprinzip beschreiben.  Die Sensorelektrode Nr. 1 ist mit Masse verbunden, die Sensorelektrode Nr. 2 ist √ºber einen 100-Ohm-Widerstand mit den Beinen A und B des SN74LVC1G00-Chips verbunden, 3,3 V √ºber einen 1-M-Widerstand sind ebenfalls mit dieser Leitung verbunden, und der Schaltung wird ebenfalls eine Kapazit√§t hinzugef√ºgt.  Wenn kein Kontakt mit der Fl√ºssigkeit auf den Schenkeln der Mikroschaltung A und B besteht, ist die logische Einheit auf dem Schenkel Y, der mit dem MK-Schenkel verbunden ist (programmgesteuert konfiguriert, um eine Unterbrechung √ºber den eingebauten Komparator zu erkennen), logisch Null.  Sobald Kontakt mit der Fl√ºssigkeit auftritt und die Beine A und B niedrig sind, wird auch das Signal am Bein Y des Mikroschaltkreises SN74LVC1G00 invertiert, was zu einer Unterbrechung f√ºhrt, die wiederum den MK aus dem Schlaf entfernt.  In Zukunft kann der Chip SN74LVC1G00 durch den Chip SN74LVC1G14 | ersetzt werden  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datashit</a> und vielleicht auch nicht :).  Der Nachweis von Fl√ºssigkeit aus den MK-Beinen durch den eingebauten Komparator ist nicht geplant. <br><br>  Wie alle meine anderen Projekte ist auch dieses ein Arduino-Projekt und wie alle Projekte des letzten Jahres (ungef√§hr) wurde dieses auch f√ºr das Mysensors-Projekt erstellt.  Wie in meinen anderen Artikeln werde ich in diesem Artikel ein wenig auf das Thema Mysensoren eingehen. <br><br>  Mysensors ist eine Open-Source-Community von Entwicklern.  Dieses Protokoll wurde von der Community entwickelt, um Funk- und Kabelnetzwerke zu erstellen.  Das Projekt wurde urspr√ºnglich f√ºr die Arduino-Plattform entwickelt.  Ein Standard-Mysensors-Netzwerk besteht aus einem Gate (Gateway), Retransformatoren und Endger√§ten (Knoten).  In einem Netzwerk k√∂nnen bis zu 254 Ger√§te vorhanden sein. Jedes der Ger√§te kann mit bis zu 254 Sensoren, Sensoren und Bet√§tigungseinheiten ausgestattet sein.  Der Netzwerkbetrieb, die Datenverarbeitung, die Skriptausf√ºhrung und die Interaktion in anderen Ger√§ten werden mit dem UD-Controller ausgef√ºhrt.  Einige der Controller (Majordomo) unterst√ºtzen die Arbeit mit mehreren Netzwerken und Mysensoren (Multi-Gate), sodass es viel mehr Netzwerke geben kann als eines, das von einem Controller gesteuert wird. <br><br>  <b>Unterst√ºtzte Hardwareplattformen</b> : Linux / Raspberry Pi / Orange Pi |  ATMega 328P |  ESP8266 |  ESP32 |  nRF5x (Cortex M0, M4) |  Atmel SAMD verwendet in Arduino Zero (Cortex M0) |  Teensy3 (MK66FX1M0VMD18) |  STM32F1. <br><br>  <b>Unterst√ºtzte</b> Funksender: NRF24L01 |  RFM69 |  RFM95 (LoRa) |  nRF5x <br><br>  <b>Unterst√ºtzte drahtgebundene Kommunikationsart</b> : RS485 <br><br>  <b>Unterst√ºtzte Kommunikation zwischen Gate und Controller</b> : MQTT |  Serielle USB |  Wifi |  Ethernet |  GSM <br><br>  Zur√ºck zum Lecksensor.  Das Ger√§t wird mit CR2430-, CR2450- oder CR2477-Batterien betrieben.  Der Schlafverbrauch betr√§gt weniger als 3ŒºA.  √úbertragungsgeschwindigkeit - 250 Kbit / s, 10-15 ms.  Der Stromverbrauch zum Zeitpunkt der √úbertragung betr√§gt nicht mehr als 8 mA.  Theoretisch entspricht die Batterielebensdauer einer einzelnen Batterie ungef√§hr der Selbstentladungszeit der Batterie.  In der Praxis ist nat√ºrlich alles weniger rosig, da der Ladezustand registriert, pr√§sentiert und regelm√§√üig gesendet wird, so dass die Batterielebensdauer eher dem Wert entspricht - Selbstentladungszeit / 2 :).  Die Stromversorgung erfolgt direkt √ºber die Batterie, der Batteriestand wird direkt √ºber den VDD-Pin gesteuert.  Im Sensor ist eine RGB-LED installiert, um die Registrierung des Sensors im Netzwerk anzuzeigen, Servicemodi anzuzeigen und die Lecksuche anzuzeigen.  Nat√ºrlich darf die LED √ºberhaupt nicht oder nur teilweise verwendet werden. <br><br>  Die Ger√§teplatine wurde f√ºr die weitere Herstellung nach der LUT-Methode hergestellt.  Aufgrund der Nuancen dieser Option ist es daher eine gr√∂√üere Breite der Gleise, gr√∂√üere Abst√§nde zwischen den Gleisen, gr√∂√üere Fl√§chen f√ºr Zwischenschicht√ºberg√§nge (zum bequemeren Bohren von L√∂chern), mangelndes Ausf√ºllen leerer Fl√§chen aufgrund der kleinen Fl√§che der Platte.  Sp√§ter wurde eine Option f√ºr einen Auftrag in der Produktion gemacht. <br><br><img src="https://habrastorage.org/webt/t3/nt/fl/t3ntflgy-mpiiijyx9ch2kr_dro.png"><br><br>  Das Ger√§tegeh√§use besteht aus zwei Teilen.  Die obere Abdeckung mit Platz f√ºr die Montage der Platine und der untere Teil (Bad) mit 2 L√∂chern f√ºr Stahlkontaktschrauben (Abdichtung mit Silikondichtmittel f√ºr den Schraubenkopf m√∂glich oder nicht erforderlich) und zwei Rohren f√ºr Kn√∂pfe (Reset und Modi) auf der Platine.  Der Druck wurde auf einem ANICUBIC PHOTON SLA 3D-Drucker durchgef√ºhrt.  Nach dem Drucken wurden die Schleifpapiere 320 und 1000 so verarbeitet, dass sie in die Fugen des Deckels und der Unterseite des K√∂rpers passten. <br><br><img src="https://habrastorage.org/webt/wo/6a/lp/wo6alplsifb0q1chfytor46xijm.png"><br><br><img src="https://habrastorage.org/webt/ln/as/rc/lnasrcwqmv4sp26y-e-qrjt5-n4.png"><br><br><div class="spoiler">  <b class="spoiler_title">Sensorfotos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/xs/yc/ar/xsycarves23jwawofy3qaqqpux0.jpeg"><br><br><img src="https://habrastorage.org/webt/sj/1i/yz/sj1iyz35chjsvv1zmvbivm3fnx4.jpeg"><br><br><img src="https://habrastorage.org/webt/sj/ra/kx/sjrakx6tb17aoe6pseqgrn8ls2m.jpeg"><br><br><img src="https://habrastorage.org/webt/vx/jf/9_/vxjf9_zdw6uw3wa3nlgr6_rijdk.jpeg"><br><br><img src="https://habrastorage.org/webt/bk/tl/el/bktlelcpzcd77cmrlugwyc0t_ta.jpeg"><br><br><img src="https://habrastorage.org/webt/of/ng/fh/ofngfhmlz_ax3fy-e1jajaueq0q.jpeg"><br><br><img src="https://habrastorage.org/webt/hf/cy/fa/hfcyfaxvkcrbplypfjh2wbf2wrw.jpeg"><br><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Testcode</b> <div class="spoiler_text">  wl_standart_test.ino <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> button_flag; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> send_flag; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> detection; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> nosleep; byte timer; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AckG; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AckB; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AckL; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> PRESENT_ACK; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> flag_lq; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> SLEEP_TIME = <span class="hljs-number"><span class="hljs-number">172800000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//48 hours //unsigned long SLEEP_TIME = 3600000; //1 hour unsigned long oldmillis; unsigned long newmillis; unsigned long interrupt_time; unsigned long SLEEP_TIME_W; uint16_t currentBatteryPercent; uint16_t batteryVoltage = 0; uint16_t battery_vcc_min = 2300; uint16_t battery_vcc_max = 3000; int16_t linkQuality; #define MY_DISABLED_SERIAL #define MY_RADIO_NRF5_ESB #define MY_RF24_PA_LEVEL (NRF5_PA_MAX) //#define MY_PASSIVE_NODE #define MY_NODE_ID 86 #define MY_PARENT_NODE_ID 0 #define MY_PARENT_NODE_IS_STATIC #define MY_TRANSPORT_UPLINK_CHECK_DISABLED #define INTR_PIN 3 //(PORT0, gpio 5) #include &lt;MySensors.h&gt; // see https://www.mysensors.org/download/serial_api_20 #define W_L_SENS_CHILD_ID 0 #define LINK_QUALITY_CHILD_ID 253 MyMessage sensMsg(W_L_SENS_CHILD_ID, V_VAR1); //MyMessage voltMsg(CHILD_ID_VOLT, V_VOLTAGE); void preHwInit() { pinMode(POWER_PIN, OUTPUT); digitalWrite(POWER_PIN, HIGH); wait(3000); pinMode(RED_LED, OUTPUT); digitalWrite(RED_LED, HIGH); pinMode(GREEN_LED, OUTPUT); digitalWrite(GREEN_LED, HIGH); pinMode(BLUE_LED, OUTPUT); digitalWrite(BLUE_LED, HIGH); pinMode(PIN_BUTTON, INPUT); pinMode(W_L_SENS, INPUT); //pinMode(24, OUTPUT); //pinMode(20, OUTPUT); } void before() { NRF_POWER-&gt;DCDCEN = 1; NRF_UART0-&gt;ENABLE = 0; digitalWrite(BLUE_LED, LOW); sleep(50); digitalWrite(BLUE_LED, HIGH); } void presentation() { sendSketchInfo("EFEKTA ST WL Sensor", "1.1"); present(W_L_SENS_CHILD_ID, S_CUSTOM, "SWITCH STATUS"); present(LINK_QUALITY_CHILD_ID, S_CUSTOM, "LINK_QUALITY"); } void setup() { digitalWrite(BLUE_LED, LOW); wait(100); digitalWrite(BLUE_LED, HIGH); wait(200); digitalWrite(BLUE_LED, LOW); wait(100); digitalWrite(BLUE_LED, HIGH); lpComp(); detection = false; SLEEP_TIME_W = SLEEP_TIME; wait(100); sendBatteryStatus(); wait(100); send(sensMsg.set(detection), 1); wait(2000, 1, V_VAR1); } void loop() { if (nosleep == 0) { oldmillis = millis(); sleep(SLEEP_TIME_W); } if (detection) { if (digitalRead(PIN_BUTTON) == 1 &amp;&amp; button_flag == 0 &amp;&amp; digitalRead(W_L_SENS) == 0) { //back side button detection button_flag = 1; nosleep = 1; } if (digitalRead(PIN_BUTTON) == 1 &amp;&amp; button_flag == 1 &amp;&amp; digitalRead(W_L_SENS) == 0) { digitalWrite(GREEN_LED, LOW); wait(10); digitalWrite(GREEN_LED, HIGH); wait(50); } if (digitalRead(PIN_BUTTON) == 0 &amp;&amp; button_flag == 1 &amp;&amp; digitalRead(W_L_SENS) == 0) { nosleep = 0; button_flag = 0; digitalWrite(GREEN_LED, HIGH); lpComp_reset(); } if (digitalRead(W_L_SENS) == 1 &amp;&amp; digitalRead(PIN_BUTTON) == 0) { //sens detection newmillis = millis(); interrupt_time = newmillis - oldmillis; SLEEP_TIME_W = SLEEP_TIME_W - interrupt_time; send(sensMsg.set(detection), 1); wait(3000, 1, V_VAR1); if (AckG == 1) { while (timer &lt; 10) { timer++; digitalWrite(BLUE_LED, LOW); wait(20); digitalWrite(BLUE_LED, HIGH); wait(30); } timer = 0; AckG = 0; wait(200); } else { while (timer &lt; 10) { timer++; digitalWrite(RED_LED, LOW); wait(20); digitalWrite(RED_LED, HIGH); wait(30); } timer = 0; send(sensMsg.set(detection), 1); wait(3000, 1, V_VAR1); if (AckG == 1) { while (timer &lt; 10) { timer++; digitalWrite(BLUE_LED, LOW); wait(20); digitalWrite(BLUE_LED, HIGH); wait(30); } timer = 0; AckG = 0; } else { while (timer &lt; 10) { timer++; digitalWrite(RED_LED, LOW); wait(20); digitalWrite(RED_LED, HIGH); wait(30); } timer = 0; } lpComp_reset(); } } if (SLEEP_TIME_W &lt; 60000) { SLEEP_TIME_W = SLEEP_TIME; sendBatteryStatus(); } } else { //if (detection == -1) { SLEEP_TIME_W = SLEEP_TIME; sendBatteryStatus(); } } void receive(const MyMessage &amp; message) { if (message.type == V_VAR1) { if (message.sensor == W_L_SENS_CHILD_ID) { if (mGetCommand(message) == 1) { if (message.isAck()) { AckG = 1; } else { } } } } if (message.type == I_BATTERY_LEVEL) { if (message.sensor == 255) { if (mGetCommand(message) == 3) { if (message.isAck()) { AckB = 1; } else { } } } } if (message.type == V_VAR1) { if (message.sensor == 255) { if (mGetCommand(message) == 1) { if (message.isAck()) { AckL = 1; } else { } } } } } void sendBatteryStatus() { wait(100); batteryVoltage = hwCPUVoltage(); wait(20); if (batteryVoltage &gt; battery_vcc_max) { currentBatteryPercent = 100; } else if (batteryVoltage &lt; battery_vcc_min) { currentBatteryPercent = 0; } else { currentBatteryPercent = (100 * (batteryVoltage - battery_vcc_min)) / (battery_vcc_max - battery_vcc_min); } sendBatteryLevel(currentBatteryPercent, 1); wait(3000, C_INTERNAL, I_BATTERY_LEVEL); if (AckB == 1) { AckB = 0; flag_lq = 1; } else { sendBatteryLevel(currentBatteryPercent, 1); wait(3000, C_INTERNAL, I_BATTERY_LEVEL); if (AckB == 1) { AckB = 0; flag_lq = 1; } } //send(powerMsg.set(batteryVoltage), 1); //wait(2000, 1, V_VAR1); //sleep(10000); // if (flag_lq == 1) { linkQuality = calculationRxQuality(); wait(50); sendSignalStrength(linkQuality, 1); wait(2000, 1, V_VAR1); if (AckL == 1) { AckL = 0; } else { sendSignalStrength(linkQuality, 1); wait(2000, 1, V_VAR1); if (AckL == 1) { AckG = 0; } } flag_lq = 0; } } void lpComp() { NRF_LPCOMP-&gt;PSEL = INTR_PIN; NRF_LPCOMP-&gt;ANADETECT = 1; NRF_LPCOMP-&gt;INTENSET = B0100; NRF_LPCOMP-&gt;ENABLE = 1; NRF_LPCOMP-&gt;TASKS_START = 1; NVIC_SetPriority(LPCOMP_IRQn, 15); NVIC_ClearPendingIRQ(LPCOMP_IRQn); NVIC_EnableIRQ(LPCOMP_IRQn); } void s_lpComp() { if ((NRF_LPCOMP-&gt;ENABLE) &amp;&amp; (NRF_LPCOMP-&gt;EVENTS_READY)) { NRF_LPCOMP-&gt;INTENCLR = B0100; } } void r_lpComp() { NRF_LPCOMP-&gt;INTENSET = B0100; } #if __CORTEX_M == 0x04 #define NRF5_RESET_EVENT(event) \ event = 0; \ (void)event #else #define NRF5_RESET_EVENT(event) event = 0 #endif void lpComp_reset () { s_lpComp(); detection = false; NRF_LPCOMP-&gt;EVENTS_UP = 0; r_lpComp(); } //****************************** very experimental ******************************* bool sendSignalStrength(const int16_t level, const bool ack) { return _sendRoute(build(_msgTmp, GATEWAY_ADDRESS, NODE_SENSOR_ID, C_SET, V_VAR1, ack).set(level)); } int16_t calculationRxQuality() { int16_t nRFRSSI_temp = transportGetReceivingRSSI(); int16_t nRFRSSI = map(nRFRSSI_temp, -85, -40, 0, 100); if (nRFRSSI &lt; 0) { nRFRSSI = 0; } if (nRFRSSI &gt; 100) { nRFRSSI = 100; } return nRFRSSI; } //****************************** very experimental ******************************* extern "C" { void LPCOMP_IRQHandler(void) { detection = true; NRF5_RESET_EVENT(NRF_LPCOMP-&gt;EVENTS_UP); NRF_LPCOMP-&gt;EVENTS_UP = 0; MY_HW_RTC-&gt;CC[0] = (MY_HW_RTC-&gt;COUNTER + 2); } }</span></span></code> </pre> <br>  MyBoardNRF5.h <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _MYBOARDNRF5_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MYBOARDNRF5_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __cplusplus extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// __cplusplus #define PINS_COUNT (32u) #define NUM_DIGITAL_PINS (32u) #define NUM_ANALOG_INPUTS (8u) #define NUM_ANALOG_OUTPUTS (8u) #define PIN_LED1 (27) #define PIN_LED2 (25) #define PIN_LED3 (26) #define RED_LED (PIN_LED1) #define GREEN_LED (PIN_LED2) #define BLUE_LED (PIN_LED3) #define PIN_BUTTON (14) #define W_L_SENS (8) #define POWER_PIN (7) #define PIN_SERIAL_RX (12) #define PIN_SERIAL_TX (11) #ifdef __cplusplus } #endif #endif</span></span></span></span></code> </pre><br></div></div><br>  Der nRF52832 ist programmgesteuert f√ºr den Betrieb im Energiesparmodus (DC-DC-Modus) konfiguriert. Der MC wird durch ein Signal vom Mikrokreis SN74LVC1G00 √ºber den internen LPCOMP-Komparator aus dem Ruhezustand geweckt.  Das Ger√§t verf√ºgt au√üerdem √ºber eine Uhrentaste zum Implementieren von Servicemodi, z. B. Ger√§tekopplung, Zur√ºcksetzen des Ger√§ts usw.  Der Knopf ist auf den gleichen MK-Fu√ü wie der Lecksucher gewickelt.  Beide Leitungen sind durch Schottky-Dioden getrennt.  Der Chip SN74LVC1G00 im √úberwachungsmodus verbraucht nichts.  Die Energieverwaltung der Mikroschaltung erfolgt √ºber die Beine des MK. <br><br>  Derzeit ist die Entwicklung einer Steuerung f√ºr Wasserleckagen, mit der diese Sensoren arbeiten sollen, fast abgeschlossen. <br><br><div class="spoiler">  <b class="spoiler_title">Video zeigt den Leckagesensor</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/5jZt3NWf9GA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-Projekt</a> <br>  (Gerber-Dateien, Software, Fallmodelle, Komponentenliste) <br><br>  Ein Ort, an dem Sie immer gerne allen helfen, die sich mit MYSENSORS vertraut machen m√∂chten (Installation von Boards, Arbeit mit nRF5-Mikrocontrollern in der Arduino IDE-Umgebung, Tipps zur Arbeit mit dem mysensors-Protokoll, Er√∂rterung neuer Copyright-Projekte - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegramm-Chat @mysensors_rus</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460177/">https://habr.com/ru/post/de460177/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460163/index.html">Wie es schien</a></li>
<li><a href="../de460165/index.html">Hintergrund: Quantenfinger-Kryptographie</a></li>
<li><a href="../de460169/index.html">Das R-Handbuch war k√ºrzlich die am h√§ufigsten zitierte nicht-akademische Ver√∂ffentlichung in wissenschaftlichen Arbeiten.</a></li>
<li><a href="../de460173/index.html">Entwicklung f√ºr Docker. Lokale Umgebung. Teil 2 - Nginx + PHP + MySql + phpMyAdmin</a></li>
<li><a href="../de460175/index.html">Semiotik im Marketing: Was bedeutet das f√ºr Ihre Marke?</a></li>
<li><a href="../de460179/index.html">LEAN + AGILE = AGILEAN oder wir sammeln das Ganze in Teilen</a></li>
<li><a href="../de460181/index.html">Verbessern Sie Ihre JavaScript-Kenntnisse, indem Sie den Quellcode analysieren</a></li>
<li><a href="../de460185/index.html">Onlinedienst "Geschwindigkeitsanalyse bei Unf√§llen per Video"</a></li>
<li><a href="../de460187/index.html">Stellen Sie sich Ihre Daten vor, bevor Sie sie erfassen.</a></li>
<li><a href="../de460189/index.html">14 besten Kanban Board Tools im Jahr 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>