<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé∞ üç† üêº Redis Scaling y Failover para servicios DirectumRX üë¥üèæ üëÉüèæ üë©üèø‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Redis es un sistema de gesti√≥n de base de datos de clase NoSQL (DBMS no relacional) que est√° completamente en RAM. Para acceder a los datos, se utiliz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Redis Scaling y Failover para servicios DirectumRX</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/469543/">  Redis es un sistema de gesti√≥n de base de datos de clase NoSQL (DBMS no relacional) que est√° completamente en RAM.  Para acceder a los datos, se utiliza el modelo "clave" - ‚Äã‚Äã"valor".  Tal DBMS se usa a menudo para almacenar cach√©s en servicios escalables, para almacenar im√°genes y datos peque√±os. <br><br>  Redis DBMS es ampliamente utilizado debido a: <br><br><ul><li>  alta velocidad, porque  todos los datos se almacenan en la RAM; </li><li>  multiplataforma; </li><li>  distribuci√≥n bajo la licencia BSD (se aplica al software de c√≥digo abierto). </li></ul><br>  La amplitud de distribuci√≥n y aplicabilidad de Redis se puede estimar por la gran cantidad de documentaci√≥n con todo tipo de casos en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio web oficial del proyecto</a> . <br><br>  Si usa la escala horizontal de los servicios de DirectumRX, debe usar la instalaci√≥n a prueba de fallas de Redis para que funcione correctamente con el servicio de almacenamiento DirectumRX y el servicio de acceso web DirectumRX. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/740/12b/060/74012b060e74628af35c33d4fa96b3bb.jpg" alt="imagen"><br><br>  Redis almacenar√° datos operativos, cach√©s y otra informaci√≥n que sea necesaria para la operaci√≥n de los servicios en modo de escala para que el proceso de interacci√≥n del usuario con el sistema no dependa de la instalaci√≥n con la que est√° trabajando actualmente. <br><br>  Redis no almacenar√° datos confidenciales y no estar√° bajo una gran carga.  Pero en el caso de una falla de Redis, los usuarios experimentar√°n muchos errores al cambiar entre instalaciones. <br><br>  En el sitio web oficial de Redis, hay 2 formas de garantizar la escala horizontal y la tolerancia a fallos: <br><br><ol><li>  Usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Redis Sentiel</a> . </li><li>  Usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Redis Cluster</a> . </li></ol><br>  Considere personalizar estas opciones. <br><br><h2>  Configurar Redis Sentiel </h2><br>  La opci√≥n que usa Redis Sentiel (Redis Tracking Node) se implement√≥ en Redis 2.4 y consiste en usar el servicio adicional Redis Sentiel para monitorear la disponibilidad del asistente.  Tambi√©n realiza la configuraci√≥n de nodos de r√©plica en caso de falla del asistente.  Determina cu√°l de los nodos SLAVE se convertir√° en MAESTRO y realizar√° la reconfiguraci√≥n sobre la marcha. <br><br>  Implementa el esquema cl√°sico: <br><br><img width="467" src="https://habrastorage.org/getpro/habr/post_images/093/10e/efb/09310eefbd3eb3c05d23b9e227bb5d7a.jpg" alt="imagen"><br><br>  Puede haber muchos nodos SLAVE (hasta 1000 seg√∫n el sitio web oficial), para un trabajo productivo se recomienda utilizar al menos dos nodos SLAVE. <br><br>  Normalmente, el esquema se configura de tal manera que el servicio Redis Sentiel se configura en los nodos MAESTRO y ESCLAVO, y si el nodo MAESTRO falla, los nodos de monitoreo restantes deciden introducir un nuevo MAESTRO. <br><br>  La versi√≥n actual de Redis est√° disponible para su descarga desde el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio web oficial del desarrollador del producto</a> .  Sin embargo, el sitio de distribuci√≥n solo est√° disponible para Linux.  En un momento, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el proyecto de</a> Microsoft para portar Redis a Windows se estaba desarrollando, pero en la actualidad el proyecto detuvo el desarrollo en la versi√≥n 3.2.100, por lo que en este art√≠culo consideraremos la opci√≥n de implementaci√≥n m√°s relevante: en Linux. <br><br>  Como nodos de prueba, utilizaremos dos hosts virtuales redis1 y redis2 con la distribuci√≥n Linux instalada de Debian 10. <br><br>  Primero, actualice las listas de paquetes desde el repositorio predeterminado e instale Redis: <br><br><pre><code class="bash hljs">apt-get update &amp;&amp; apt-get upgrade apt install redis-server</code> </pre> <br>  Comprueba la versi√≥n: <br><br><pre> <code class="bash hljs">root@redis1:/home/user<span class="hljs-comment"><span class="hljs-comment"># redis-server -v Redis server v=5.0.3 sha=00000000:0 malloc=jemalloc-5.1.0 bits=64 build=afa0decbb6de285f</span></span></code> </pre> <br>  Deje que redis1 act√∫e como un nodo MAESTRO y redis2 act√∫e como un nodo ESCLAVO. <br><br>  Para hacer esto, escribimos en los archivos de configuraci√≥n de Redis los par√°metros necesarios que le permitir√°n crear una r√©plica (a√∫n no tolerante a fallas). <br><br>  Para redis1 en el archivo de configuraci√≥n /etc/redis/redis.conf, especifique: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ,   MASTER     . requirepass TestPass</span></span></code> </pre> <br>  Para redis2 en el archivo de configuraci√≥n /etc/redis/redis.conf, especifique: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   MASTER  . slaveof redis1 6379 #      . masterauth TestPass #   ,         . requirepass TestPass</span></span></code> </pre> <br>  Reinicie los servicios de redis-server en ambos nodos: <br><br><pre> <code class="bash hljs">root@redis1:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># /etc/init.d/redis-server stop [ ok ] Stopping redis-server (via systemctl): redis-server.service. root@redis1:/etc/redis# /etc/init.d/redis-server start [ ok ] Starting redis-server (via systemctl): redis-server.service. root@redis2:/etc/redis# /etc/init.d/redis-server stop [ ok ] Stopping redis-server (via systemctl): redis-server.service. root@redis2:/etc/redis# /etc/init.d/redis-server start [ ok ] Starting redis-server (via systemctl): redis-server.service.</span></span></code> </pre> <br>  Verificamos en el lado MAESTRO que los nodos se convirtieron en r√©plicas y recibieron los roles necesarios: <br><br><pre> <code class="bash hljs">root@redis1:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -a TestPass info replication Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. # Replication role:master connected_slaves:1 slave0:ip=192.168.9.96,port=6379,state=online,offset=28,lag=0 master_replid:56b0a702d5823d107b0ca1ca2c80f8ef650a4b28 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:28 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:28</span></span></code> </pre> <br>  En el lado ESCLAVO, vemos la misma situaci√≥n: <br><pre> <code class="bash hljs">root@redis2:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -a TestPass info replication Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. # Replication role:slave master_host:redis1 master_port:6379 master_link_status:up master_last_io_seconds_ago:4 master_sync_in_progress:0 slave_repl_offset:14 slave_priority:100 slave_read_only:1 connected_slaves:0 master_replid:56b0a702d5823d107b0ca1ca2c80f8ef650a4b28 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:14 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:14</span></span></code> </pre> <br>  Ahora debe configurar la r√©plica para que se restaure autom√°ticamente en caso de falla de uno de los nodos.  Para hacer esto, necesitamos el servicio de seguimiento Redis Sentinel. <br><br>  Seg√∫n la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> , el servicio de monitoreo de Redis Sentinel puede realizar las siguientes operaciones: <br><br><ol><li>  Comprueba la disponibilidad de los nodos MAESTRO y ESCLAVO y puede enviar alertas sobre la inaccesibilidad de los nodos. </li><li>  Si el nodo MAESTRO falla, el nodo testigo puede poner el nodo ESCLAVO en modo MAESTRO, as√≠ como reconfigurar los nodos ESCLAVO restantes y comenzar a trabajar con el nuevo MAESTRO. </li><li>  Realiza cambios en los archivos de configuraci√≥n de los nodos MAESTRO y ESCLAVO. </li></ol><br>  Para la pureza del experimento, colocaremos un servicio de testigos en una VM redis3 separada. <br><br>  Conectamos el repositorio de Redis de la misma manera e instalamos el paquete redis-sentinel: <br><br><pre> <code class="bash hljs">apt install redis-sentinel</code> </pre> <br>  Despu√©s de la instalaci√≥n, debe realizar la configuraci√≥n en el archivo de configuraci√≥n del nodo de supervisi√≥n /etc/redis/sentinel.conf: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    redis1   6379. #   1 -      , #        MASTER-. #       , #     MASTER-. sentinel monitor master01 redis1 6379 1 #  3 ,       . sentinel down-after-milliseconds master01 3000 #    MASTER- sentinel failover-timeout master01 6000 # ,  SLAVE-   . #    ,    , #      . sentinel parallel-syncs master01 1 #    . bind 192.168.9.97 127.0.0.1 ::1 #    MASTER-. sentinel auth-pass master01 TestPass</span></span></code> </pre><br>  Reinicie el servicio despu√©s de realizar la configuraci√≥n: <br><br><pre> <code class="bash hljs">root@redis3:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># /etc/init.d/redis-sentinel restart [ ok ] Restarting redis-sentinel (via systemctl): redis-sentinel.service.</span></span></code> </pre> <br>  Compruebe que el servicio de seguimiento vio MASTER y SLAVE: <br><br><pre> <code class="bash hljs">root@redis3:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -p 26379 info sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=master01,status=ok,address=192.168.9.95:6379,slaves=1,sentinels=1</span></span></code> </pre> <br>  Comenzamos los experimentos. <br><br>  Simulamos una falla, detenemos el servicio redis-server en el nodo redis1 y obtenemos la informaci√≥n actual del nodo testigo: <br><br><pre> <code class="bash hljs">root@redis3:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -p 26379 info sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=master01,status=ok,address=192.168.9.96:6379,slaves=1,sentinels=1</span></span></code> </pre> <br>  Vemos que MASTER ha cambiado. <br><br>  Restauraremos el funcionamiento del nodo redis1 y verificaremos su estado: <br><br><pre> <code class="bash hljs">root@redis3:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -h redis1 -p 6379 -a TestPass info replication Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. # Replication role:slave master_host:192.168.9.96 master_port:6379 master_link_status:up master_last_io_seconds_ago:1 master_sync_in_progress:0 slave_repl_offset:15977 slave_priority:100 slave_read_only:1 connected_slaves:0 master_replid:6c0c7d0eedccede56f211f2db74a98c4d0ff6d56 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:15977 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:15977</span></span></code> </pre> <br>  Vemos que el nodo recibi√≥ el rol ESCLAVO, y el nodo redis2 es un nodo MAESTRO. <br><br>  Simule la falla del nodo redis2 y verifique el estado del nodo testigo: <br><br><pre> <code class="bash hljs">root@redis3:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -p 26379 info sentinel # Sentinel sentinel_masters:1 sentinel_tilt:0 sentinel_running_scripts:0 sentinel_scripts_queue_length:0 sentinel_simulate_failure_flags:0 master0:name=master01,status=ok,address=192.168.9.95:6379,slaves=1,sentinels=1</span></span></code> </pre> <br>  Y el estado del nodo redis1: <br><br><pre> <code class="bash hljs">root@redis3:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis<span class="hljs-comment"><span class="hljs-comment"># redis-cli -h redis1 -p 6379 -a TestPass info replication Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. # Replication role:master connected_slaves:0 master_replid:6e9d67d6460815b925319c2bafb58bf2c435cffb master_replid2:6c0c7d0eedccede56f211f2db74a98c4d0ff6d56 master_repl_offset:33610 second_repl_offset:26483 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:33610</span></span></code> </pre> <br>  Genial, el mecanismo funciona.  Pero ahora ha surgido la pregunta de c√≥mo conectaremos nuestros servicios DirectumRX, porque necesitan una direcci√≥n de nodo √∫nico.  Resolveremos la situaci√≥n utilizando el servicio HAProxy. <br><br><h2>  Redis Node Proxying </h2><br>  Cualquier servicio proxy tcp puede actuar como un proxy inverso para los nodos Redis.  En este art√≠culo, consideraremos el uso de HAProxy, ya que es una herramienta especializada dise√±ada para proporcionar alta disponibilidad y equilibrio de carga, y es utilizada por servicios en l√≠nea universalmente conocidos.  Lea m√°s sobre HAProxy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la p√°gina del desarrollador</a> . <br><br>  Instale HAProxy en el nodo redis3: <br><br><pre> <code class="bash hljs">root@redis3:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/redis<span class="hljs-comment"><span class="hljs-comment"># apt install haproxy</span></span></code> </pre> <br>  En el archivo de configuraci√≥n de HAProxy /etc/haproxy/haproxy.cfg, agregue la configuraci√≥n para las solicitudes de proxy a los nodos de Redis: <br><br><pre> <code class="bash hljs">‚Ä¶ frontend ft_redis <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> *:6379 name redis mode tcp default_backend bk_redis backend bk_redis mode tcp option tcp-check tcp-check connect <span class="hljs-comment"><span class="hljs-comment">#  ,         . tcp-check send AUTH\ TestPass\r\n tcp-check expect string +OK tcp-check send PING\r\n tcp-check expect string +PONG tcp-check send info\ replication\r\n #    MASTER, .. SLAVE      . tcp-check expect string role:master tcp-check send QUIT\r\n tcp-check expect string +OK server Redis1 redis1:6379 check inter 3s server Redis2 redis2:6379 check inter 3s</span></span></code> </pre><br>  En esta configuraci√≥n, se indica que enviaremos cualquier solicitud que llegue a todas las interfaces de la m√°quina virtual actual en la direcci√≥n del puerto 6379. Transferiremos las solicitudes al nodo que responder√° que tiene el rol MAESTRO. <br><br>  Reinicie el servicio de haproxy: <br><br><pre> <code class="bash hljs">root@redis3:/etc/haproxy<span class="hljs-comment"><span class="hljs-comment"># /etc/init.d/haproxy restart</span></span></code> </pre> <br>  Intentemos conectarnos usando el cliente redis-cli y creemos una clave de prueba: <br><br><pre> <code class="bash hljs">root@redis3:/etc/haproxy<span class="hljs-comment"><span class="hljs-comment"># redis-cli -p 6379 -a TestPass Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe. 127.0.0.1:6379&gt; SET TestKey "Some test string" OK 127.0.0.1:6379&gt; GET TestKey "Some test string" 127.0.0.1:6379&gt; info keyspace # Keyspace db0:keys=1,expires=0,avg_ttl=0</span></span></code> </pre> <br>  Detenga el nodo redis1 y vuelva a consultar la lista de claves: <br><br><pre> <code class="bash hljs">127.0.0.1:6379&gt; info keyspace Error: Server closed the connection (3.01s) 127.0.0.1:6379&gt; info keyspace <span class="hljs-comment"><span class="hljs-comment"># Keyspace db0:keys=1,expires=0,avg_ttl=0 (2.01s) 127.0.0.1:6379&gt; GET TestKey "Some test string"</span></span></code> </pre><br>  Vemos que durante alg√∫n tiempo la conexi√≥n se desconect√≥, pero luego la conexi√≥n se restableci√≥ nuevamente y todos los datos permanecieron en su lugar. <br><br>  Ahora es suficiente registrar la direcci√≥n del proxy inverso en los archivos de configuraci√≥n de los servicios de DirectumRX para conectarse a Redis. <br><br><h2>  Configurar Redis Cluster </h2><br>  La opci√≥n de agrupaci√≥n en cl√∫ster de Redis, implementada para la versi√≥n redis 3.0 y superior, es una soluci√≥n para crear y administrar un cl√∫ster con segmentaci√≥n y replicaci√≥n de datos.  Realiza tareas de gesti√≥n de nodos, replicaci√≥n, sincronizaci√≥n de datos en nodos y garantiza el acceso de la aplicaci√≥n del cliente al nodo MAESTRO en caso de falla de uno de varios nodos MAESTROS. <br><br><img width="500" src="https://habrastorage.org/getpro/habr/post_images/86e/5c6/e56/86e5c6e56fe5541c36297e978c4c34d4.png" alt="imagen"><br><br>  Redis Cluster funciona en modo multimaestro, cada nodo MAESTRO puede tener uno o m√°s nodos ESCLAVO (hasta 1000). <br><br>  El escalado es la funci√≥n principal del cl√∫ster.  Adem√°s, el cl√∫ster puede garantizar la tolerancia a fallas del servicio Redis: <br><br><ul><li>  si algunos nodos no funcionan, el cl√∫ster redistribuye la carga de ellos a otros nodos; </li><li>  Si los nodos clave no funcionan, todo el cl√∫ster finaliza. </li></ul><br>  Puede surgir una situaci√≥n cuando el Cliente 2 escribe en el nodo M2.  M2 responde "OK" e intenta escribir en S2.  Al mismo tiempo, M2 no espera la finalizaci√≥n correcta del intercambio de datos con S2, sino que responde al cliente de inmediato.  En este caso, la r√©plica S2 puede no tener todos los datos.  Por lo tanto, se recomienda usar varias r√©plicas de SLAVE. <br><br>  Tambi√©n puede surgir una situaci√≥n cuando M1, M3 dejan de "ver" M2 y el cliente contin√∫a escribiendo datos en M2.  Si la indisponibilidad continuar√° por un tiempo bastante largo (par√°metro cluster-node-timeout), en este caso S2 se pondr√° en modo MASTER y M2 dejar√° de funcionar por s√≠ solo. <br><br>  La documentaci√≥n oficial recomienda usar 6 nodos, una instancia de Redis por nodo, lo que permite <i>una</i> mayor confiabilidad, pero nadie proh√≠be usar tres nodos con la siguiente topolog√≠a de conexi√≥n: <br><br><img width="573" src="https://habrastorage.org/getpro/habr/post_images/3c1/56a/860/3c156a860e5728015e9631b3bb5854a1.jpg" alt="imagen"><br><br>  Si falla uno de los nodos f√≠sicos, las r√©plicas de SLAVE correspondientes entrar√°n en modo MAESTRO y la operaci√≥n no se interrumpir√°. <br><br>  Implementamos 3 m√°quinas virtuales (redis1, redis2 y redis3) en el banco de pruebas, cada una de las cuales ejecutar√° 2 instancias de Redis. <br><br>  La aplicaci√≥n cliente se conectar√° a un puerto espec√≠fico especificado en el archivo de configuraci√≥n del cliente, por lo tanto, los pares MAESTRO - ESCLAVO deber√≠an funcionar en los mismos puertos. <br><br>  Para el par M1 - S1 usaremos el puerto 6381 <br>  Para el par M2 - S2 usaremos el puerto 6382 <br>  Para el par M3 - S3 usaremos el puerto 6383 <br><br>  Prepara los archivos de configuraci√≥n <br><br>  En redis1: <br><br><pre> <code class="bash hljs">cp /etc/redis/redis.conf /etc/redis/m1_redis.conf cp /etc/redis/redis.conf /etc/redis/s2_redis.conf mv /etc/redis/redis.conf /etc/redis/redis.bak</code> </pre> <br>  En redis2: <br><br><pre> <code class="bash hljs">cp /etc/redis/redis.conf /etc/redis/m2_redis.conf cp /etc/redis/redis.conf /etc/redis/s3_redis.conf mv /etc/redis/redis.conf /etc/redis/redis.bak</code> </pre> <br>  En redis3: <br><br><pre> <code class="bash hljs">cp /etc/redis/redis.conf /etc/redis/m3_redis.conf cp /etc/redis/redis.conf /etc/redis/s1_redis.conf mv /etc/redis/redis.conf /etc/redis/redis.bak</code> </pre> <br>  Complete los archivos de configuraci√≥n de acuerdo con la plantilla: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> &lt;IP- &gt; protected-mode no <span class="hljs-comment"><span class="hljs-comment">#      ,    . port &lt;&gt; pidfile /var/run/redis_&lt;&gt;.pid # &lt;yes/no&gt; -   Redis Cluster cluster-enabled yes # ,      : #  ,  ,    . #         . cluster-config-file nodes-&lt;&gt;.conf #  ,  master-   , #          slaves #    . cluster-node-timeout 15000</span></span></code> </pre> <br>  Vamos a lanzar los nodos Redis: <br><br>  Nodo redis1: <br><br><pre> <code class="bash hljs">root@redis1:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-server /etc/redis/m1_redis.conf root@redis1:/etc/redis# redis-server /etc/redis/s2_redis.conf</span></span></code> </pre> <br>  Redis2 nodo: <br><br><pre> <code class="bash hljs">root@redis2:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-server /etc/redis/m2_redis.conf root@redis2:/etc/redis# redis-server /etc/redis/s3_redis.conf</span></span></code> </pre> <br>  Redis3 nodo: <br><br><pre> <code class="bash hljs">root@redis3:/etc/redis<span class="hljs-comment"><span class="hljs-comment"># redis-server /etc/redis/m3_redis.conf root@redis3:/etc/redis# redis-server /etc/redis/s1_redis.conf</span></span></code> </pre> <br>  Para configurar el cl√∫ster, debe usar la utilidad de cliente redis-cli, pas√°ndole una lista de ip: pares de servidores de puertos que desempe√±ar√°n los roles de MAESTRO y ESCLAVO: <br><br><pre> <code class="bash hljs">redis-cli --cluster create redis1-ip:6381 redis2-ip:6382 redis3-ip:6383 redis1-ip:6382 redis2-ip:6383 redis3-ip:6381 --cluster-replicas 1</code> </pre> <br>  , donde la opci√≥n --cluster-replicas 1 le indica cu√°ntos ESCLAVOS tendr√° cada maestro, y se seleccionan autom√°ticamente de la lista de r√©plicas transferidas. <br><br><pre> <code class="bash hljs">root@redis1:~/redis/src<span class="hljs-comment"><span class="hljs-comment"># redis-cli --cluster create 192.168.9.51:6381 192.168.9.52:6382 192.168.9.53:6383 192.168.9.51:6382 192.168.9.52:6383 192.168.9.53:6381 --cluster-replicas 1 &gt;&gt;&gt; Performing hash slots allocation on 6 nodes... Master[0] -&gt; Slots 0 - 5460 Master[1] -&gt; Slots 5461 - 10922 Master[2] -&gt; Slots 10923 - 16383 Adding replica 192.168.9.52:6383 to 192.168.9.51:6381 Adding replica 192.168.9.51:6382 to 192.168.9.52:6382 Adding replica 192.168.9.53:6381 to 192.168.9.53:6383 &gt;&gt;&gt; Trying to optimize slaves allocation for anti-affinity [OK] Perfect anti-affinity obtained! M: e92cb96fd6c20db7509662a248902e3751ebe95f 192.168.9.51:6381 slots:[0-5460] (5461 slots) master M: d499af3672b3063c7239572ec311ad3160f280ae 192.168.9.52:6382 slots:[5461-10922] (5462 slots) master M: 3a41475e1613519c3ecdec695736a898262a24a5 192.168.9.53:6383 slots:[10923-16383] (5461 slots) master S: 182e5cffc9c31c231de69ddbaf507ec1fe17bb09 192.168.9.51:6382 replicates d499af3672b3063c7239572ec311ad3160f280ae S: 44f656062259005adea58bc5ad024071a050e192 192.168.9.52:6383 replicates 3a41475e1613519c3ecdec695736a898262a24a5 S: 485ffb786e9763955e6f10ffc59247690ad9bc11 192.168.9.53:6381 replicates e92cb96fd6c20db7509662a248902e3751ebe95f Can I set the above configuration? (type 'yes' to accept): yes &gt;&gt;&gt; Nodes configuration updated &gt;&gt;&gt; Assign a different config epoch to each node &gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster Waiting for the cluster to join ..... &gt;&gt;&gt; Performing Cluster Check (using node 192.168.9.51:6381) M: e92cb96fd6c20db7509662a248902e3751ebe95f 192.168.9.51:6381 slots:[0-5460] (5461 slots) master 1 additional replica(s) M: d499af3672b3063c7239572ec311ad3160f280ae 192.168.9.52:6382 slots:[5461-10922] (5462 slots) master 1 additional replica(s) S: 485ffb786e9763955e6f10ffc59247690ad9bc11 192.168.9.53:6381 slots: (0 slots) slave replicates e92cb96fd6c20db7509662a248902e3751ebe95f S: 182e5cffc9c31c231de69ddbaf507ec1fe17bb09 192.168.9.51:6382 slots: (0 slots) slave replicates d499af3672b3063c7239572ec311ad3160f280ae S: 44f656062259005adea58bc5ad024071a050e192 192.168.9.52:6383 slots: (0 slots) slave replicates 3a41475e1613519c3ecdec695736a898262a24a5 M: 3a41475e1613519c3ecdec695736a898262a24a5 192.168.9.53:6383 slots:[10923-16383] (5461 slots) master 1 additional replica(s) [OK] All nodes agree about slots configuration. &gt;&gt;&gt; Check for open slots... &gt;&gt;&gt; Check slots coverage... [OK] All 16384 slots covered.</span></span></code> </pre> <br>  El cl√∫ster est√° construido correctamente.  Mostraremos informaci√≥n sobre el cl√∫ster: <br><br><pre> <code class="bash hljs">root@redis1:~/redis/src<span class="hljs-comment"><span class="hljs-comment"># redis-cli -c -h 192.168.9.51 -p 6381 192.168.9.51:6381&gt; CLUSTER INFO cluster_state:ok cluster_slots_assigned:16384 cluster_slots_ok:16384 cluster_slots_pfail:0 cluster_slots_fail:0 cluster_known_nodes:6 cluster_size:3 cluster_current_epoch:6 cluster_my_epoch:1 cluster_stats_messages_ping_sent:1254 cluster_stats_messages_pong_sent:1243 cluster_stats_messages_sent:2497 cluster_stats_messages_ping_received:1238 cluster_stats_messages_pong_received:1254 cluster_stats_messages_meet_received:5 cluster_stats_messages_received:2497 192.168.9.51:6381&gt;</span></span></code> </pre> <br>  Para probar una r√©plica espec√≠fica, como con Redis Sentiel, puede usar el comando de replicaci√≥n INFO: <br><br><pre> <code class="bash hljs">root@redis1:~/redis/src<span class="hljs-comment"><span class="hljs-comment"># redis-cli -c -h 192.168.9.51 -p 6381 192.168.9.51:6381&gt; INFO replication # Replication role:master connected_slaves:1 slave0:ip=192.168.9.53,port=6381,state=online,offset=1946,lag=0 master_replid:59cd95d394dad9d0e49042637fdfd5290db4abfe master_replid2:0000000000000000000000000000000000000000 master_repl_offset:1946 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:1946 192.168.9.51:6381&gt;</span></span></code> </pre> <br>  Intentemos crear varias claves y verifiquemos que estas claves aparecieron en las r√©plicas: <br><br><pre> <code class="bash hljs">192.168.9.51:6381&gt; SET key1 test1 -&gt; Redirected to slot [9189] located at 192.168.9.52:6382 OK 192.168.9.52:6382&gt; SET key2 test2 -&gt; Redirected to slot [4998] located at 192.168.9.51:6381 OK 192.168.9.51:6381&gt; SET key3 test3 OK 192.168.9.51:6381&gt;</code> </pre> <br>  Compruebe en M2: <br><br><pre> <code class="bash hljs">root@redis2:/home/user<span class="hljs-comment"><span class="hljs-comment"># redis-cli -c -h 192.168.9.52 -p 6382 192.168.9.52:6382&gt; GET key1 "test1" 192.168.9.52:6382&gt; GET key2 -&gt; Redirected to slot [4998] located at 192.168.9.51:6381 "test2" 192.168.9.51:6381&gt; GET key3 "test3" 192.168.9.51:6381&gt;</span></span></code> </pre> <br>  Y en el M3: <br><br><pre> <code class="bash hljs">root@redis3:/home/user<span class="hljs-comment"><span class="hljs-comment"># redis-cli -c -h 192.168.9.53 -p 6383 192.168.9.53:6383&gt; GET key1 -&gt; Redirected to slot [9189] located at 192.168.9.52:6382 "test1" 192.168.9.52:6382&gt; GET key2 -&gt; Redirected to slot [4998] located at 192.168.9.51:6381 "test2" 192.168.9.51:6381&gt; GET key3 "test3" 192.168.9.51:6381&gt;</span></span></code> </pre> <br>  Desactivaremos el nodo redis1 y comprobaremos c√≥mo funciona S1: <br><br><pre> <code class="bash hljs">192.168.9.52:6382&gt; CLUSTER NODES &lt;b&gt;182e5cffc9c31c231de69ddbaf507ec1fe17bb09 192.168.9.51:6382@16382 slave,fail d499af3672b3063c7239572ec311ad3160f280ae 1569509904727 1569509900000 4 connected&lt;/b&gt; 485ffb786e9763955e6f10ffc59247690ad9bc11 &lt;i&gt;192.168.9.53:6381@16381 master&lt;/i&gt; - 0 1569510017272 7 connected 0-5460 44f656062259005adea58bc5ad024071a050e192 192.168.9.52:6383@16383 slave 3a41475e1613519c3ecdec695736a898262a24a5 0 1569510018274 5 connected &lt;b&gt;e92cb96fd6c20db7509662a248902e3751ebe95f 192.168.9.51:6381@16381 master,fail - 1569509906731 1569509901721 1 connected&lt;/b&gt; 3a41475e1613519c3ecdec695736a898262a24a5 192.168.9.53:6383@16383 master - 0 1569510019275 3 connected 10923-16383 d499af3672b3063c7239572ec311ad3160f280ae 192.168.9.52:6382@16382 myself,master - 0 1569510017000 2 connected 5461-10922</code> </pre> <br>  Vemos informaci√≥n sobre la falla de M1 y S2 y que S3 ha cambiado al modo MAESTRO. <br><br>  Verifique d√≥nde est√°n almacenadas las claves: <br><br><pre> <code class="bash hljs">192.168.9.52:6382&gt; GET key1 <span class="hljs-string"><span class="hljs-string">"test1"</span></span> 192.168.9.52:6382&gt; GET key2 -&gt; Redirected to slot [4998] located at 192.168.9.53:6381 <span class="hljs-string"><span class="hljs-string">"test2"</span></span> 192.168.9.53:6381&gt; GET key3 <span class="hljs-string"><span class="hljs-string">"test3"</span></span> 192.168.9.53:6381&gt;</code> </pre><br>  Las claves que se almacenaron anteriormente en redis1 ahora est√°n disponibles en redis3. <br><br>  Restaure el funcionamiento del nodo redis1 y verifique el estado de los nodos M1 y S2: <br><br><pre> <code class="bash hljs">192.168.9.53:6381&gt; CLUSTER NODES &lt;i&gt;e92cb96fd6c20db7509662a248902e3751ebe95f 192.168.9.51:6381@16381 slave 485ffb786e9763955e6f10ffc59247690ad9bc11 0 1569511658217 7 connected 182e5cffc9c31c231de69ddbaf507ec1fe17bb09 192.168.9.51:6382@16382 slave d499af3672b3063c7239572ec311ad3160f280ae 0 1569511657000 4 connected&lt;/i&gt; d499af3672b3063c7239572ec311ad3160f280ae 192.168.9.52:6382@16382 master - 0 1569511656000 2 connected 5461-10922 3a41475e1613519c3ecdec695736a898262a24a5 192.168.9.53:6383@16383 master - 0 1569511656000 3 connected 10923-16383 485ffb786e9763955e6f10ffc59247690ad9bc11 192.168.9.53:6381@16381 myself,master - 0 1569511656000 7 connected 0-5460 44f656062259005adea58bc5ad024071a050e192 192.168.9.52:6383@16383 slave 3a41475e1613519c3ecdec695736a898262a24a5 0 1569511657216 5 connected</code> </pre> <br>  La salud de M1 y S2 se ha recuperado, pero ahora M1 est√° en modo ESCLAVO. <br><br>  Y las claves tambi√©n est√°n en el nodo redis3: <br><br><pre> <code class="bash hljs">192.168.9.53:6383&gt; GET key1 -&gt; Redirected to slot [9189] located at 192.168.9.52:6382 <span class="hljs-string"><span class="hljs-string">"test1"</span></span> 192.168.9.52:6382&gt; GET key2 -&gt; Redirected to slot [4998] located at 192.168.9.53:6381 <span class="hljs-string"><span class="hljs-string">"test2"</span></span> 192.168.9.53:6383&gt; GET key3 -&gt; Redirected to slot [935] located at 192.168.9.53:6381 <span class="hljs-string"><span class="hljs-string">"test3"</span></span></code> </pre> <br>  El cl√∫ster est√° configurado y se prueba la recuperaci√≥n de Redis. <br><br>  Para acceder a los servicios de DirectumRX, tambi√©n necesitar√° configurar proxies inversos, como en el caso de configurar Redis Sentiel. <br><br><h2>  En lugar de una conclusi√≥n </h2><br>  Este art√≠culo no consider√≥ otra forma de aumentar la tolerancia a fallas de Redis: usar un administrador de recursos de cl√∫ster de terceros, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pacemaker</a> .  En este caso, ser√° posible sobrevivir con dos nodos, sin embargo, existe una alta probabilidad de p√©rdida de datos en caso de emergencia. <br><br>  Para un proxy inverso (en este caso, HAProxy), tambi√©n es deseable proporcionar tolerancia a fallas, pero este problema tambi√©n estaba m√°s all√° del alcance de este art√≠culo.  Si est√° interesado en el tema, estas opciones de implementaci√≥n tambi√©n se pueden considerar en art√≠culos separados con ajuste y prueba paso a paso de los resultados. <br><br>  Puede encontrar los enlaces a continuaci√≥n para obtener m√°s informaci√≥n sobre el tema: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tutorial de cl√∫ster de Redis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentaci√≥n de Redis Sentinel</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Manual de configuraci√≥n de HAProxy</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/469543/">https://habr.com/ru/post/469543/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../469529/index.html">La representaci√≥n de texto te odia</a></li>
<li><a href="../469531/index.html">"Comparar lenguajes de programaci√≥n en una base mejor-peor es una ocupaci√≥n completamente idiota".</a></li>
<li><a href="../469533/index.html">Problemas y amenazas de la identificaci√≥n biom√©trica.</a></li>
<li><a href="../469537/index.html">Conociendo a Swift con Snake</a></li>
<li><a href="../469541/index.html">Montaje y despliegue de los mismos microservicios con werf y GitLab CI</a></li>
<li><a href="../469545/index.html">Novedades en el kernel 5.3 de Linux: controladores de gr√°ficos, virtualizaci√≥n y modificaciones en el subsistema de red</a></li>
<li><a href="../469549/index.html">¬øC√≥mo hicimos la tarifa para Windows VPS por 99 rublos?</a></li>
<li><a href="../469551/index.html">VDS con una tarjeta de video: sabemos mucho sobre perversiones</a></li>
<li><a href="../469555/index.html">Emisi√≥n: Mosc√∫ Kubernetes Meetup # 6</a></li>
<li><a href="../469557/index.html">Vista de reciclador gen√©rico o c√≥mo no escribir c√≥digo repetitivo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>