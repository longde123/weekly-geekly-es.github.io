<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ©Ô∏è ‚õîÔ∏è üßóüèº Elbrus besteigen - Aufkl√§rung im Kampf. Technischer Teil 2. Interrupts, Ausnahmen, Systemtimer üßó üë®üèΩ‚Äçü§ù‚Äçüë®üèª üïê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir erkunden Elbrus weiter, indem wir Embox darauf portieren . 

 Dieser Artikel ist Teil zwei eines technischen Artikels zur Elbrus-Architektur. Der ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elbrus besteigen - Aufkl√§rung im Kampf. Technischer Teil 2. Interrupts, Ausnahmen, Systemtimer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/447744/"><img src="https://habrastorage.org/webt/ic/4z/5o/ic4z5olelesc04boln85goculk4.png" align="right" width="320">  Wir erkunden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elbrus</a> weiter, indem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wir Embox</a> darauf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">portieren</a> . <br><br>  Dieser Artikel ist Teil zwei eines technischen Artikels zur Elbrus-Architektur.  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erste Teil</a> befasste sich mit Stapeln, Registern und so weiter.  Bevor Sie diesen Teil lesen, empfehlen wir Ihnen, den ersten Teil zu studieren, da er sich mit den grundlegenden Dingen der Elbrus-Architektur befasst.  Dieser Abschnitt konzentriert sich auf Timer, Interrupts und Ausnahmen.  Dies ist wiederum keine offizielle Dokumentation.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wenden</a> Sie sich dazu an die Entwickler von Elbrus am <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ICST</a> . <a name="habracut"></a><br>  Um zum Studium von Elbrus zu gelangen, wollten wir den Timer schnell starten, da pr√§ventives Multitasking, wie Sie wissen, ohne ihn nicht funktioniert.  Um dies zu tun, schien es genug zu sein, den Interrupt-Controller und den Timer selbst zu implementieren, aber wir stie√üen auf <s>unerwartete</s> erwartete Schwierigkeiten, wohin w√ºrden wir ohne sie gehen.  Sie begannen nach Debugging-Funktionen zu suchen und stellten fest, dass die Entwickler sich darum k√ºmmerten, indem sie mehrere Befehle einf√ºhrten, mit denen Sie verschiedene Ausnahmesituationen ausl√∂sen k√∂nnen.  Beispielsweise k√∂nnen Sie eine Ausnahme einer besonderen Art √ºber die Register PSR (Prozessorstatusregister) und UPSR (Benutzerprozessorstatusregister) generieren.  F√ºr PSR ist das Bit exc_last_wish das Ausnahmeflag exc_last_wish, wenn von der Prozedur zur√ºckgekehrt wird, und f√ºr UPSR ist exc_d_interrupt das Flag f√ºr verz√∂gerte Unterbrechungen, das durch die VFDI-Operation erzeugt wird (Flag f√ºr verz√∂gerte Unterbrechungen pr√ºfen). <br><br>  Der Code lautet wie folgt: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> UPSR_DI (1 &lt;&lt; 3) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   .h  */</span></span></span><span class="hljs-meta"> rrs %upsr, %r1 ors %r1, UPSR_DI, %r1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* upsr |= UPSR_DI; */</span></span></span><span class="hljs-meta"> rws %r1, %upsr vfdi </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*      */</span></span></span></span></code> </pre> <br>  Gestartet.  Aber nichts ist passiert, das System hing irgendwo, nichts wurde an die Konsole ausgegeben.  Eigentlich haben wir dies gesehen, als wir versucht haben, den Interrupt √ºber den Timer zu starten, aber dann gab es viele Komponenten, und hier war klar, dass etwas den sequentiellen Fortschritt unseres Programms unterbrach und die Steuerung auf die Ausnahmetabelle √ºbertragen wurde (in Bezug auf die Elbrus-Architektur ist es richtiger, nicht √ºber die Tabelle zu sprechen Unterbrechungen und √ºber die Ausnahmetabelle).  Wir gingen davon aus, dass der Prozessor dennoch eine Ausnahme ausl√∂ste, aber es gab einen ‚ÄûM√ºll‚Äú, bei dem er die Kontrolle √ºbertrug.  Wie sich herausstellte, √ºbertr√§gt er die Kontrolle genau an die Stelle, an der wir das Embox-Image abgelegt haben, was bedeutet, dass es einen Einstiegspunkt gab - die Eingabefunktion. <br><br>  Zur √úberpr√ºfung haben wir Folgendes durchgef√ºhrt.  Startete einen Z√§hler f√ºr Eintr√§ge in entry ().  Anf√§nglich beginnen alle CPUs mit ausgeschalteten Interrupts, gehen in entry (), danach lassen wir nur einen Kern aktiv, der Rest geht in eine Endlosschleife.  Nachdem der Z√§hler der Anzahl der CPUs entspricht, betrachten wir alle nachfolgenden Treffer im Eintrag als Ausnahmen.  Ich erinnere Sie daran, dass es vorher so war, wie es in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unserem allerersten Artikel √ºber Elbrus beschrieben wurde</a> <br><br><pre> <code class="cpp hljs"> cpuid = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;last_cpuid); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cpuid &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* copy of trap table */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;_t_entry, <span class="hljs-number"><span class="hljs-number">0x1800</span></span>); kernel_start();</code> </pre> <br>  Hab das getan <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Since we enable exceptions only when all CPUs except the main one * reached the idle state (cpu_idle), we can rely that order and can * guarantee exceptions happen strictly after all CPUS entries. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt;= CPU_COUNT) { <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of expection or interrupt */</span></span> e2k_trap_handler(regs); ... } <span class="hljs-comment"><span class="hljs-comment">/* It wasn't exception, so we decide this usual program execution, * that is, Embox started on CPU0 or CPU1 */</span></span> e2k_wait_all(); entries_count = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;entries_count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> cpu_idle(); } e2k_kernel_start(); }</code> </pre> <br>  Und schlie√ülich sahen wir die Reaktion auf das Eingeben des Interrupts (nur mit Hilfe von printf haben wir eine Zeile gedruckt). <br><br>  Hier ist zu erkl√§ren, dass wir anfangs in der ersten Version erwartet hatten, die Ausnahmetabelle zu kopieren, aber erstens stellte sich heraus, dass sie an unserer Adresse war, und zweitens konnten wir nicht die richtige Kopie erstellen.  Ich musste Linker-Skripte, den Einstiegspunkt in das System und den Interrupt-Handler neu schreiben, das hei√üt, ich brauchte den Assembler-Teil etwas sp√§ter. <br><br>  So sieht nun der Teil des ge√§nderten Teils des Skript-Linkers aus: <br><br><pre> <code class="cpp hljs">.text : { _start = .; _t_entry = .; <span class="hljs-comment"><span class="hljs-comment">/* Interrupt handler */</span></span> *(.ttable_entry0) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x800</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Syscall handler */</span></span> *(.ttable_entry1) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* longjmp handler */</span></span> *(.ttable_entry2) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x1800</span></span>; _t_entry_end = .; *(.e2k_entry) *(.cpu_idle) <span class="hljs-comment"><span class="hljs-comment">/* text */</span></span> }</code> </pre><br>  Das hei√üt, wir haben den Eintragsabschnitt f√ºr die Ausnahmetabelle entfernt.  Dort befindet sich auch der Abschnitt cpu_idle f√ºr die nicht verwendeten CPUs. <br><br>  So sieht die Eingabefunktion f√ºr unseren aktiven Kernel aus, auf dem Embox ausgef√ºhrt wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e2k_kernel_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> psr; <span class="hljs-comment"><span class="hljs-comment">/*    CPU ‚Äú‚Äù */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (idled_cpus_count &lt; CPU_COUNT - <span class="hljs-number"><span class="hljs-number">1</span></span>) ; ... <span class="hljs-comment"><span class="hljs-comment">/*     ,     */</span></span> e2k_upsr_write(e2k_upsr_read() &amp; ~UPSR_FE); kernel_start(); <span class="hljs-comment"><span class="hljs-comment">/*   Embox */</span></span> }</code> </pre> <br>  Nun, gem√§√ü der VFDI-Anweisung wurde eine Ausnahme ausgel√∂st.  Jetzt m√ºssen Sie seine Nummer erhalten, um sicherzustellen, dass dies die richtige Ausnahme ist.  Zu diesem Zweck verf√ºgt Elbrus √ºber TIR-Interrupt-Informationsregister (Trap Info-Register).  Sie enthalten Informationen zu den letzten Befehlen, dh zum letzten Teil der Ablaufverfolgung.  Trace sammelt sich w√§hrend der Programmausf√ºhrung und "friert" ein, wenn ein Interrupt eingegeben wird.  TIR umfasst die Teile Low (64 Bit) und High (64 Bit).  Das niedrige Wort enth√§lt die Ausnahmeflags, und das hohe Wort enth√§lt einen Zeiger auf den Befehl, der zur Ausnahme gef√ºhrt hat, und die aktuelle TIR-Nummer.  Dementsprechend ist in unserem Fall exc_d_interrupt das 4. Bit. <br><br>  Hinweis Wir haben immer noch einige Missverst√§ndnisse hinsichtlich der Tiefe (Anzahl) der TIRs.  Die Dokumentation enth√§lt: <br><blockquote>  ‚ÄûDie TIR-Speichertiefe, dh die Anzahl der Trap-Info-Register, wird bestimmt <br>  TIR_NUM-Makro, das der Anzahl der Prozessor-Pipeline-Stufen entspricht, die f√ºr erforderlich sind <br>  Ausgabe aller m√∂glichen besonderen Situationen.  TIR_NUM = 19; ‚Äù </blockquote>  In der Praxis sehen wir die Tiefe = 1 und verwenden daher nur das TIR0-Register. <br><br>  Die Spezialisten des MCST haben uns erkl√§rt, dass alles korrekt ist und es nur TIR0 f√ºr ‚Äûgenaue‚Äú Interrupts geben wird, aber f√ºr andere Situationen kann es etwas anderes geben.  Aber da wir nur √ºber Timer-Interrupts sprechen, st√∂rt uns das nicht. <br><br>  Ok, jetzt schauen wir uns an, was erforderlich ist, um den Ausnahmebehandler korrekt einzugeben / zu beenden.  Tats√§chlich ist es notwendig, am Eingang zu speichern und die folgenden 5 Register am Ausgang wiederherzustellen.  Drei Steuer√ºbertragungsvorbereitungsregister sind ctpr [1,2,3], und zwei Zyklussteuerregister sind ILCR (Register der Anfangswerte des Zyklusz√§hlers) und LSR (Register des Zyklusstatus). <br><br><pre> <code class="cpp hljs">.type ttable_entry0,@function ttable_entry0: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">1</span></span>; rrd %ctpr1, %dr1 rrd %ctpr2, %dr2 rrd %ctpr3, %dr3 rrd %ilcr, %dr4 rrd %lsr, %dr5 <span class="hljs-comment"><span class="hljs-comment">/* sizeof pt_regs */</span></span> getsp -(<span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">8</span></span>), %dr0 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr1, [%dr0 + PT_CTRP1] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr1 = ctpr1 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + PT_CTRP2] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr2 = ctpr2 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + PT_CTRP3] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr3 = ctpr3 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + PT_ILCR] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ilcr = ilcr */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + PT_LSR] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;lsr = lsr */</span></span> disp %ctpr1, e2k_entry ct %ctpr1</code> </pre> <br>  Das ist alles, nachdem Sie den Ausnahmebehandler beendet haben, m√ºssen Sie diese 5 Register wiederherstellen. <br><br>  Wir machen das mit einem Makro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESTORE_COMMON_REGS(regs) \ ({ \ uint64_t ctpr1 = regs-&gt;ctpr1, ctpr2 = regs-&gt;ctpr2, \ ctpr3 = regs-&gt;ctpr3, lsr = regs-&gt;lsr, \ ilcr = regs-&gt;ilcr; \ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ctpr2 is restored first because of tight time constraints \ * on restoring ctpr2 and aaldv. */</span></span></span><span class="hljs-meta"> \ E2K_SET_DSREG(ctpr1, ctpr1); \ E2K_SET_DSREG(ctpr2, ctpr2); \ E2K_SET_DSREG(ctpr3, ctpr3); \ E2K_SET_DSREG(lsr, lsr); \ E2K_SET_DSREG(ilcr, ilcr); \ })</span></span></code> </pre> <br>  Es ist auch wichtig, nach der Wiederherstellung der Register nicht zu vergessen, die DONE-Operation aufzurufen (R√ºckkehr vom Hardware-Interrupt-Handler).  Diese Operation ist insbesondere notwendig, um die unterbrochenen Steuer√ºbertragungsoperationen korrekt zu verarbeiten.  Wir machen das mit einem Makro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_DONE \ do { \ asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"{nop 3} {done}"</span></span></span><span class="hljs-meta"> ::: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ctpr3"</span></span></span><span class="hljs-meta">); \ } while (0)</span></span></code> </pre> <br>  Tats√§chlich kehren wir mit diesen beiden Makros direkt im C-Code vom Interrupt zur√ºck. <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of expection or interrupt */</span></span> e2k_trap_handler(regs); RESTORE_COMMON_REGS(regs); E2K_DONE;</code> </pre> <br><h3>  Externe Interrupts </h3><br>  Beginnen wir mit der Aktivierung externer Interrupts.  In Elbrus wird APIC (oder besser gesagt sein Analog) als Interrupt-Controller verwendet, Embox hatte diesen Treiber bereits.  Daher war es m√∂glich, einen System-Timer daf√ºr abzurufen.  Es gibt zwei Timer, von denen einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PIT</a> sehr √§hnlich ist, der andere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LAPIC-Timer</a> ist ebenfalls Standard, daher macht es keinen Sinn, dar√ºber zu sprechen.  Sowohl das als auch das sahen einfach aus, und das und das gab es bereits in Embox, aber der Treiber des LAPIC-Timers sah perspektivischer aus, abgesehen davon, dass die Implementierung des PIT-Timers uns nicht standardisierter erschien.  Daher schien es einfacher zu vervollst√§ndigen.  Dar√ºber hinaus wurden in der offiziellen Dokumentation die Register APIC und LAPIC beschrieben, die sich geringf√ºgig von den Originalen unterschieden.  Sie mitzubringen macht keinen Sinn, wie Sie im Original sehen k√∂nnen. <br><br>  Zus√§tzlich zum Zulassen von Interrupts in APIC m√ºssen Sie die Interrupt-Behandlung √ºber die PSR / UPSR-Register aktivieren.  Beide Register haben Flags zum Aktivieren externer Interrupts und nicht maskierbarer Interrupts.  <i>ABER</i> hier ist es sehr wichtig zu beachten, dass das PSR-Register <i>lokal</i> f√ºr die Funktion ist (dies wurde im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten technischen Teil</a> besprochen).  Wenn Sie es in einer Funktion festlegen, wird es beim Aufrufen aller nachfolgenden Funktionen vererbt. Wenn Sie jedoch von der Funktion zur√ºckkehren, kehrt es in den urspr√ºnglichen Zustand zur√ºck.  Daher die Frage, aber wie man Interrupts verwaltet? <br><br>  Wir verwenden die folgende L√∂sung.  Mit dem PSR-Register k√∂nnen Sie die Verwaltung √ºber UPSR aktivieren, das bereits global ist (was wir ben√∂tigen).  Daher aktivieren wir die Steuerung √ºber UPSR direkt (wichtig!) Vor der Embox-Core-Login-Funktion: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* PSR is local register and makes sense only within a function, * so we set it here before kernel start. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"rrs %%psr, %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=r"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(psr) :)</span></span></span></span>; psr |= (PSR_IE | PSR_NMIE | PSR_UIE); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"rws %0, %%psr"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ri"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(psr))</span></span></span></span>; kernel_start();</code> </pre> <br>  Irgendwie zuf√§llig habe ich nach dem Refactoring diese Zeilen genommen und in eine separate Funktion eingef√ºgt ... Und das Register ist lokal f√ºr die Funktion.  Es ist klar, dass alles kaputt ist :) <br><br>  Also scheint alles im Prozessor eingeschaltet zu sein, gehe zum Interrupt-Controller. <br><br>  Wie wir oben gesehen haben, befinden sich Informationen √ºber die Ausnahmenummer im TIR-Register.  Ferner meldet das 32. Bit in diesem Register, dass ein externer Interrupt aufgetreten ist. <br><br>  Nach dem Einschalten des Timers folgten einige Tage der Qual, da keine Unterbrechung erzielt werden konnte.  Der Grund war am√ºsant genug.  Es gibt 64-Bit-Zeiger in Elbrus, und die Adresse des Registers in APIC wurde in uint32_t eingegeben. Deshalb haben wir sie verwendet.  Es stellte sich jedoch heraus, dass Sie, wenn Sie beispielsweise 0xF0000000 in einen Zeiger umwandeln m√ºssen, nicht 0xF0000000, sondern 0xFFFFFFFFF0000000 erhalten.  Das hei√üt, der Compiler erweitert Ihr vorzeichenloses int-Zeichen. <br><br>  Hier war es nat√ºrlich notwendig, uintptr_t zu verwenden, da, wie sich herausstellte, im C99-Standard diese Art der Konvertierung implementierungsdefiniert ist. <br><br>  Nachdem wir endlich das erh√∂hte 32. Bit in TIR gesehen hatten, begannen wir zu suchen, wie wir die Interrupt-Nummer erhalten k√∂nnen.  Es stellte sich als recht einfach heraus, obwohl dies √ºberhaupt nicht wie bei x86 ist, ist dies einer der Unterschiede zwischen den LAPIC-Implementierungen.  F√ºr Elbrus m√ºssen Sie in das spezielle LAPIC-Register gelangen, um die Interrupt-Nummer zu erhalten: <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APIC_VECT (0xFEE00000 + 0xFF0)</span></span></code> </pre> <br>  Dabei ist 0xFEE00000 die Basisadresse der LAPIC-Register. <br><br>  Es stellte sich heraus, dass sowohl der System-Timer als auch der LAPIC-Timer erfasst wurden. <br><br><h3>  Fazit </h3><br>  Die Informationen in den ersten beiden technischen Teilen des Artikels √ºber die Elbrus-Architektur reichen aus, um Hardware-Interrupts und pr√§ventives Multitasking in jedem Betriebssystem zu implementieren.  Tats√§chlich zeugen die angegebenen Screenshots davon. <br><br><img src="https://habrastorage.org/webt/qm/qz/3p/qmqz3pbvuvohscm_qon1edf5jno.png"><br><br>  Dies ist nicht der letzte technische Teil der Elbrus-Architektur.  Jetzt beherrschen wir das Memory Management (MMU) in Elbrus und hoffen, bald dar√ºber sprechen zu k√∂nnen.  Wir ben√∂tigen dies nicht nur f√ºr die Implementierung virtueller Adressr√§ume, sondern auch f√ºr die normale Arbeit mit Peripherieger√§ten, da Sie durch diesen Mechanismus das Caching eines bestimmten Bereichs des Adressraums deaktivieren oder aktivieren k√∂nnen. <br><br>  Alles, was im Artikel geschrieben steht, befindet sich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Embox-</a> Repository.  Sie k√∂nnen auch erstellen und ausf√ºhren, wenn nat√ºrlich eine Hardwareplattform vorhanden ist.  Zwar wird hierf√ºr ein Compiler ben√∂tigt, der nur beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MCST erh√§ltlich ist</a> .  Dort k√∂nnen offizielle Unterlagen angefordert werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447744/">https://habr.com/ru/post/de447744/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447732/index.html">Hunderassen-ID: Vollst√§ndige Zyklusentwicklung vom Keras-Programm zur Android-App. auf dem Spielmarkt</a></li>
<li><a href="../de447734/index.html">Warum Front-End die Prinzipien der Benutzeroberfl√§che verstehen sollte</a></li>
<li><a href="../de447736/index.html">Drohnenvideo - ein neuer Trend in sozialen Netzwerken</a></li>
<li><a href="../de447738/index.html">Julian Assange von der britischen Polizei festgenommen</a></li>
<li><a href="../de447742/index.html">Was ist die DevOps-Methodik und wer braucht sie?</a></li>
<li><a href="../de447750/index.html">Neue Prozessoren f√ºr Rechenzentren - wir analysieren die Ank√ºndigungen der letzten Monate</a></li>
<li><a href="../de447752/index.html">Wie wir CAD COMPASS-3D ‚Üí Teil 3 √ºbertaktet haben</a></li>
<li><a href="../de447754/index.html">Men√ºleisten-App f√ºr macOS</a></li>
<li><a href="../de447756/index.html">Neuer Gartner Quadrant f√ºr Application Monitoring Solutions (APM)</a></li>
<li><a href="../de447758/index.html">Hacking-Geschichte eines klassischen Dendy- oder Contra-Spiels f√ºr 100 Leben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>