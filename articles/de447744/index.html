<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛩️ ⛔️ 🧗🏼 Elbrus besteigen - Aufklärung im Kampf. Technischer Teil 2. Interrupts, Ausnahmen, Systemtimer 🧗 👨🏽‍🤝‍👨🏻 🕐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir erkunden Elbrus weiter, indem wir Embox darauf portieren . 

 Dieser Artikel ist Teil zwei eines technischen Artikels zur Elbrus-Architektur. Der ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elbrus besteigen - Aufklärung im Kampf. Technischer Teil 2. Interrupts, Ausnahmen, Systemtimer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/447744/"><img src="https://habrastorage.org/webt/ic/4z/5o/ic4z5olelesc04boln85goculk4.png" align="right" width="320">  Wir erkunden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elbrus</a> weiter, indem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wir Embox</a> darauf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">portieren</a> . <br><br>  Dieser Artikel ist Teil zwei eines technischen Artikels zur Elbrus-Architektur.  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erste Teil</a> befasste sich mit Stapeln, Registern und so weiter.  Bevor Sie diesen Teil lesen, empfehlen wir Ihnen, den ersten Teil zu studieren, da er sich mit den grundlegenden Dingen der Elbrus-Architektur befasst.  Dieser Abschnitt konzentriert sich auf Timer, Interrupts und Ausnahmen.  Dies ist wiederum keine offizielle Dokumentation.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wenden</a> Sie sich dazu an die Entwickler von Elbrus am <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ICST</a> . <a name="habracut"></a><br>  Um zum Studium von Elbrus zu gelangen, wollten wir den Timer schnell starten, da präventives Multitasking, wie Sie wissen, ohne ihn nicht funktioniert.  Um dies zu tun, schien es genug zu sein, den Interrupt-Controller und den Timer selbst zu implementieren, aber wir stießen auf <s>unerwartete</s> erwartete Schwierigkeiten, wohin würden wir ohne sie gehen.  Sie begannen nach Debugging-Funktionen zu suchen und stellten fest, dass die Entwickler sich darum kümmerten, indem sie mehrere Befehle einführten, mit denen Sie verschiedene Ausnahmesituationen auslösen können.  Beispielsweise können Sie eine Ausnahme einer besonderen Art über die Register PSR (Prozessorstatusregister) und UPSR (Benutzerprozessorstatusregister) generieren.  Für PSR ist das Bit exc_last_wish das Ausnahmeflag exc_last_wish, wenn von der Prozedur zurückgekehrt wird, und für UPSR ist exc_d_interrupt das Flag für verzögerte Unterbrechungen, das durch die VFDI-Operation erzeugt wird (Flag für verzögerte Unterbrechungen prüfen). <br><br>  Der Code lautet wie folgt: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> UPSR_DI (1 &lt;&lt; 3) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   .h  */</span></span></span><span class="hljs-meta"> rrs %upsr, %r1 ors %r1, UPSR_DI, %r1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* upsr |= UPSR_DI; */</span></span></span><span class="hljs-meta"> rws %r1, %upsr vfdi </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*      */</span></span></span></span></code> </pre> <br>  Gestartet.  Aber nichts ist passiert, das System hing irgendwo, nichts wurde an die Konsole ausgegeben.  Eigentlich haben wir dies gesehen, als wir versucht haben, den Interrupt über den Timer zu starten, aber dann gab es viele Komponenten, und hier war klar, dass etwas den sequentiellen Fortschritt unseres Programms unterbrach und die Steuerung auf die Ausnahmetabelle übertragen wurde (in Bezug auf die Elbrus-Architektur ist es richtiger, nicht über die Tabelle zu sprechen Unterbrechungen und über die Ausnahmetabelle).  Wir gingen davon aus, dass der Prozessor dennoch eine Ausnahme auslöste, aber es gab einen „Müll“, bei dem er die Kontrolle übertrug.  Wie sich herausstellte, überträgt er die Kontrolle genau an die Stelle, an der wir das Embox-Image abgelegt haben, was bedeutet, dass es einen Einstiegspunkt gab - die Eingabefunktion. <br><br>  Zur Überprüfung haben wir Folgendes durchgeführt.  Startete einen Zähler für Einträge in entry ().  Anfänglich beginnen alle CPUs mit ausgeschalteten Interrupts, gehen in entry (), danach lassen wir nur einen Kern aktiv, der Rest geht in eine Endlosschleife.  Nachdem der Zähler der Anzahl der CPUs entspricht, betrachten wir alle nachfolgenden Treffer im Eintrag als Ausnahmen.  Ich erinnere Sie daran, dass es vorher so war, wie es in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unserem allerersten Artikel über Elbrus beschrieben wurde</a> <br><br><pre> <code class="cpp hljs"> cpuid = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;last_cpuid); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cpuid &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* copy of trap table */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;_t_entry, <span class="hljs-number"><span class="hljs-number">0x1800</span></span>); kernel_start();</code> </pre> <br>  Hab das getan <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Since we enable exceptions only when all CPUs except the main one * reached the idle state (cpu_idle), we can rely that order and can * guarantee exceptions happen strictly after all CPUS entries. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt;= CPU_COUNT) { <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of expection or interrupt */</span></span> e2k_trap_handler(regs); ... } <span class="hljs-comment"><span class="hljs-comment">/* It wasn't exception, so we decide this usual program execution, * that is, Embox started on CPU0 or CPU1 */</span></span> e2k_wait_all(); entries_count = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;entries_count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> cpu_idle(); } e2k_kernel_start(); }</code> </pre> <br>  Und schließlich sahen wir die Reaktion auf das Eingeben des Interrupts (nur mit Hilfe von printf haben wir eine Zeile gedruckt). <br><br>  Hier ist zu erklären, dass wir anfangs in der ersten Version erwartet hatten, die Ausnahmetabelle zu kopieren, aber erstens stellte sich heraus, dass sie an unserer Adresse war, und zweitens konnten wir nicht die richtige Kopie erstellen.  Ich musste Linker-Skripte, den Einstiegspunkt in das System und den Interrupt-Handler neu schreiben, das heißt, ich brauchte den Assembler-Teil etwas später. <br><br>  So sieht nun der Teil des geänderten Teils des Skript-Linkers aus: <br><br><pre> <code class="cpp hljs">.text : { _start = .; _t_entry = .; <span class="hljs-comment"><span class="hljs-comment">/* Interrupt handler */</span></span> *(.ttable_entry0) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x800</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Syscall handler */</span></span> *(.ttable_entry1) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* longjmp handler */</span></span> *(.ttable_entry2) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x1800</span></span>; _t_entry_end = .; *(.e2k_entry) *(.cpu_idle) <span class="hljs-comment"><span class="hljs-comment">/* text */</span></span> }</code> </pre><br>  Das heißt, wir haben den Eintragsabschnitt für die Ausnahmetabelle entfernt.  Dort befindet sich auch der Abschnitt cpu_idle für die nicht verwendeten CPUs. <br><br>  So sieht die Eingabefunktion für unseren aktiven Kernel aus, auf dem Embox ausgeführt wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e2k_kernel_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> psr; <span class="hljs-comment"><span class="hljs-comment">/*    CPU “” */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (idled_cpus_count &lt; CPU_COUNT - <span class="hljs-number"><span class="hljs-number">1</span></span>) ; ... <span class="hljs-comment"><span class="hljs-comment">/*     ,     */</span></span> e2k_upsr_write(e2k_upsr_read() &amp; ~UPSR_FE); kernel_start(); <span class="hljs-comment"><span class="hljs-comment">/*   Embox */</span></span> }</code> </pre> <br>  Nun, gemäß der VFDI-Anweisung wurde eine Ausnahme ausgelöst.  Jetzt müssen Sie seine Nummer erhalten, um sicherzustellen, dass dies die richtige Ausnahme ist.  Zu diesem Zweck verfügt Elbrus über TIR-Interrupt-Informationsregister (Trap Info-Register).  Sie enthalten Informationen zu den letzten Befehlen, dh zum letzten Teil der Ablaufverfolgung.  Trace sammelt sich während der Programmausführung und "friert" ein, wenn ein Interrupt eingegeben wird.  TIR umfasst die Teile Low (64 Bit) und High (64 Bit).  Das niedrige Wort enthält die Ausnahmeflags, und das hohe Wort enthält einen Zeiger auf den Befehl, der zur Ausnahme geführt hat, und die aktuelle TIR-Nummer.  Dementsprechend ist in unserem Fall exc_d_interrupt das 4. Bit. <br><br>  Hinweis Wir haben immer noch einige Missverständnisse hinsichtlich der Tiefe (Anzahl) der TIRs.  Die Dokumentation enthält: <br><blockquote>  „Die TIR-Speichertiefe, dh die Anzahl der Trap-Info-Register, wird bestimmt <br>  TIR_NUM-Makro, das der Anzahl der Prozessor-Pipeline-Stufen entspricht, die für erforderlich sind <br>  Ausgabe aller möglichen besonderen Situationen.  TIR_NUM = 19; ” </blockquote>  In der Praxis sehen wir die Tiefe = 1 und verwenden daher nur das TIR0-Register. <br><br>  Die Spezialisten des MCST haben uns erklärt, dass alles korrekt ist und es nur TIR0 für „genaue“ Interrupts geben wird, aber für andere Situationen kann es etwas anderes geben.  Aber da wir nur über Timer-Interrupts sprechen, stört uns das nicht. <br><br>  Ok, jetzt schauen wir uns an, was erforderlich ist, um den Ausnahmebehandler korrekt einzugeben / zu beenden.  Tatsächlich ist es notwendig, am Eingang zu speichern und die folgenden 5 Register am Ausgang wiederherzustellen.  Drei Steuerübertragungsvorbereitungsregister sind ctpr [1,2,3], und zwei Zyklussteuerregister sind ILCR (Register der Anfangswerte des Zykluszählers) und LSR (Register des Zyklusstatus). <br><br><pre> <code class="cpp hljs">.type ttable_entry0,@function ttable_entry0: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">1</span></span>; rrd %ctpr1, %dr1 rrd %ctpr2, %dr2 rrd %ctpr3, %dr3 rrd %ilcr, %dr4 rrd %lsr, %dr5 <span class="hljs-comment"><span class="hljs-comment">/* sizeof pt_regs */</span></span> getsp -(<span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">8</span></span>), %dr0 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr1, [%dr0 + PT_CTRP1] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr1 = ctpr1 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + PT_CTRP2] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr2 = ctpr2 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + PT_CTRP3] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr3 = ctpr3 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + PT_ILCR] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ilcr = ilcr */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + PT_LSR] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;lsr = lsr */</span></span> disp %ctpr1, e2k_entry ct %ctpr1</code> </pre> <br>  Das ist alles, nachdem Sie den Ausnahmebehandler beendet haben, müssen Sie diese 5 Register wiederherstellen. <br><br>  Wir machen das mit einem Makro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESTORE_COMMON_REGS(regs) \ ({ \ uint64_t ctpr1 = regs-&gt;ctpr1, ctpr2 = regs-&gt;ctpr2, \ ctpr3 = regs-&gt;ctpr3, lsr = regs-&gt;lsr, \ ilcr = regs-&gt;ilcr; \ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ctpr2 is restored first because of tight time constraints \ * on restoring ctpr2 and aaldv. */</span></span></span><span class="hljs-meta"> \ E2K_SET_DSREG(ctpr1, ctpr1); \ E2K_SET_DSREG(ctpr2, ctpr2); \ E2K_SET_DSREG(ctpr3, ctpr3); \ E2K_SET_DSREG(lsr, lsr); \ E2K_SET_DSREG(ilcr, ilcr); \ })</span></span></code> </pre> <br>  Es ist auch wichtig, nach der Wiederherstellung der Register nicht zu vergessen, die DONE-Operation aufzurufen (Rückkehr vom Hardware-Interrupt-Handler).  Diese Operation ist insbesondere notwendig, um die unterbrochenen Steuerübertragungsoperationen korrekt zu verarbeiten.  Wir machen das mit einem Makro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_DONE \ do { \ asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"{nop 3} {done}"</span></span></span><span class="hljs-meta"> ::: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ctpr3"</span></span></span><span class="hljs-meta">); \ } while (0)</span></span></code> </pre> <br>  Tatsächlich kehren wir mit diesen beiden Makros direkt im C-Code vom Interrupt zurück. <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of expection or interrupt */</span></span> e2k_trap_handler(regs); RESTORE_COMMON_REGS(regs); E2K_DONE;</code> </pre> <br><h3>  Externe Interrupts </h3><br>  Beginnen wir mit der Aktivierung externer Interrupts.  In Elbrus wird APIC (oder besser gesagt sein Analog) als Interrupt-Controller verwendet, Embox hatte diesen Treiber bereits.  Daher war es möglich, einen System-Timer dafür abzurufen.  Es gibt zwei Timer, von denen einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PIT</a> sehr ähnlich ist, der andere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LAPIC-Timer</a> ist ebenfalls Standard, daher macht es keinen Sinn, darüber zu sprechen.  Sowohl das als auch das sahen einfach aus, und das und das gab es bereits in Embox, aber der Treiber des LAPIC-Timers sah perspektivischer aus, abgesehen davon, dass die Implementierung des PIT-Timers uns nicht standardisierter erschien.  Daher schien es einfacher zu vervollständigen.  Darüber hinaus wurden in der offiziellen Dokumentation die Register APIC und LAPIC beschrieben, die sich geringfügig von den Originalen unterschieden.  Sie mitzubringen macht keinen Sinn, wie Sie im Original sehen können. <br><br>  Zusätzlich zum Zulassen von Interrupts in APIC müssen Sie die Interrupt-Behandlung über die PSR / UPSR-Register aktivieren.  Beide Register haben Flags zum Aktivieren externer Interrupts und nicht maskierbarer Interrupts.  <i>ABER</i> hier ist es sehr wichtig zu beachten, dass das PSR-Register <i>lokal</i> für die Funktion ist (dies wurde im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten technischen Teil</a> besprochen).  Wenn Sie es in einer Funktion festlegen, wird es beim Aufrufen aller nachfolgenden Funktionen vererbt. Wenn Sie jedoch von der Funktion zurückkehren, kehrt es in den ursprünglichen Zustand zurück.  Daher die Frage, aber wie man Interrupts verwaltet? <br><br>  Wir verwenden die folgende Lösung.  Mit dem PSR-Register können Sie die Verwaltung über UPSR aktivieren, das bereits global ist (was wir benötigen).  Daher aktivieren wir die Steuerung über UPSR direkt (wichtig!) Vor der Embox-Core-Login-Funktion: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* PSR is local register and makes sense only within a function, * so we set it here before kernel start. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"rrs %%psr, %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=r"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(psr) :)</span></span></span></span>; psr |= (PSR_IE | PSR_NMIE | PSR_UIE); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"rws %0, %%psr"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ri"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(psr))</span></span></span></span>; kernel_start();</code> </pre> <br>  Irgendwie zufällig habe ich nach dem Refactoring diese Zeilen genommen und in eine separate Funktion eingefügt ... Und das Register ist lokal für die Funktion.  Es ist klar, dass alles kaputt ist :) <br><br>  Also scheint alles im Prozessor eingeschaltet zu sein, gehe zum Interrupt-Controller. <br><br>  Wie wir oben gesehen haben, befinden sich Informationen über die Ausnahmenummer im TIR-Register.  Ferner meldet das 32. Bit in diesem Register, dass ein externer Interrupt aufgetreten ist. <br><br>  Nach dem Einschalten des Timers folgten einige Tage der Qual, da keine Unterbrechung erzielt werden konnte.  Der Grund war amüsant genug.  Es gibt 64-Bit-Zeiger in Elbrus, und die Adresse des Registers in APIC wurde in uint32_t eingegeben. Deshalb haben wir sie verwendet.  Es stellte sich jedoch heraus, dass Sie, wenn Sie beispielsweise 0xF0000000 in einen Zeiger umwandeln müssen, nicht 0xF0000000, sondern 0xFFFFFFFFF0000000 erhalten.  Das heißt, der Compiler erweitert Ihr vorzeichenloses int-Zeichen. <br><br>  Hier war es natürlich notwendig, uintptr_t zu verwenden, da, wie sich herausstellte, im C99-Standard diese Art der Konvertierung implementierungsdefiniert ist. <br><br>  Nachdem wir endlich das erhöhte 32. Bit in TIR gesehen hatten, begannen wir zu suchen, wie wir die Interrupt-Nummer erhalten können.  Es stellte sich als recht einfach heraus, obwohl dies überhaupt nicht wie bei x86 ist, ist dies einer der Unterschiede zwischen den LAPIC-Implementierungen.  Für Elbrus müssen Sie in das spezielle LAPIC-Register gelangen, um die Interrupt-Nummer zu erhalten: <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APIC_VECT (0xFEE00000 + 0xFF0)</span></span></code> </pre> <br>  Dabei ist 0xFEE00000 die Basisadresse der LAPIC-Register. <br><br>  Es stellte sich heraus, dass sowohl der System-Timer als auch der LAPIC-Timer erfasst wurden. <br><br><h3>  Fazit </h3><br>  Die Informationen in den ersten beiden technischen Teilen des Artikels über die Elbrus-Architektur reichen aus, um Hardware-Interrupts und präventives Multitasking in jedem Betriebssystem zu implementieren.  Tatsächlich zeugen die angegebenen Screenshots davon. <br><br><img src="https://habrastorage.org/webt/qm/qz/3p/qmqz3pbvuvohscm_qon1edf5jno.png"><br><br>  Dies ist nicht der letzte technische Teil der Elbrus-Architektur.  Jetzt beherrschen wir das Memory Management (MMU) in Elbrus und hoffen, bald darüber sprechen zu können.  Wir benötigen dies nicht nur für die Implementierung virtueller Adressräume, sondern auch für die normale Arbeit mit Peripheriegeräten, da Sie durch diesen Mechanismus das Caching eines bestimmten Bereichs des Adressraums deaktivieren oder aktivieren können. <br><br>  Alles, was im Artikel geschrieben steht, befindet sich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Embox-</a> Repository.  Sie können auch erstellen und ausführen, wenn natürlich eine Hardwareplattform vorhanden ist.  Zwar wird hierfür ein Compiler benötigt, der nur beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MCST erhältlich ist</a> .  Dort können offizielle Unterlagen angefordert werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447744/">https://habr.com/ru/post/de447744/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447732/index.html">Hunderassen-ID: Vollständige Zyklusentwicklung vom Keras-Programm zur Android-App. auf dem Spielmarkt</a></li>
<li><a href="../de447734/index.html">Warum Front-End die Prinzipien der Benutzeroberfläche verstehen sollte</a></li>
<li><a href="../de447736/index.html">Drohnenvideo - ein neuer Trend in sozialen Netzwerken</a></li>
<li><a href="../de447738/index.html">Julian Assange von der britischen Polizei festgenommen</a></li>
<li><a href="../de447742/index.html">Was ist die DevOps-Methodik und wer braucht sie?</a></li>
<li><a href="../de447750/index.html">Neue Prozessoren für Rechenzentren - wir analysieren die Ankündigungen der letzten Monate</a></li>
<li><a href="../de447752/index.html">Wie wir CAD COMPASS-3D → Teil 3 übertaktet haben</a></li>
<li><a href="../de447754/index.html">Menüleisten-App für macOS</a></li>
<li><a href="../de447756/index.html">Neuer Gartner Quadrant für Application Monitoring Solutions (APM)</a></li>
<li><a href="../de447758/index.html">Hacking-Geschichte eines klassischen Dendy- oder Contra-Spiels für 100 Leben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>