<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßö üíáüèª üë©üèª‚Äç‚öïÔ∏è Kotlin kompilieren: JetBrains VS ANTLR VS JavaCC ‚ôªÔ∏è üëò ‚úãüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie schnell analysiert Kotlin und was macht es aus? JavaCC oder ANTLR? Sind JetBrains-Quellcodes geeignet? 

 Vergleichen, phantasieren und wundern. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin kompilieren: JetBrains VS ANTLR VS JavaCC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433000/"><img src="https://habrastorage.org/webt/cv/to/y3/cvtoy3lpibs4fm_1asygxcsdgse.jpeg" width="300" align="left"><br>  Wie schnell analysiert Kotlin und was macht es aus?  JavaCC oder ANTLR?  Sind JetBrains-Quellcodes geeignet? <br><br>  Vergleichen, phantasieren und wundern. <br><a name="habracut"></a><br><h1>  tl; dr </h1><br>  <i>JetBrains sind zu schwer zu ziehen, ANTLR ist ein Hype, aber unerwartet langsam, und JavaCC ist zu fr√ºh, um es abzuschreiben.</i> <br><br>  Analysieren einer einfachen Kotlin-Datei mit drei verschiedenen Implementierungen: <br><table><tbody><tr><th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr></tbody></table><br><h4>  Ein sch√∂ner sonniger Tag ... </h4><br>  Ich beschloss, einen √úbersetzer in GLSL aus einer geeigneten Sprache zu erstellen.  Die Idee war, Shader direkt in die Idee zu programmieren und "kostenlose" IDE-Unterst√ºtzung zu erhalten - Syntax, Debug und Unit-Tests.  Es stellte sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wirklich sehr praktisch heraus</a> . <br><br>  Seitdem ist die Idee, Kotlin zu verwenden, geblieben - Sie k√∂nnen den Namen vec3 darin verwenden, er ist strenger und in der IDE bequemer.  Dar√ºber hinaus ist es Hype.  Obwohl dies aus Sicht meines internen Managers alles unzureichende Gr√ºnde sind, kam die Idee so oft zur√ºck, dass ich mich entschied, sie einfach durch Implementierung loszuwerden. <br><br>  <em>Warum nicht Java?</em>  <em>Es gibt keine Operator√ºberladung, daher unterscheidet sich die Syntax der Vektorarithmetik zu stark von der, die Sie in Game Dev gewohnt sind</em> <br><br><h4>  Jetbrains </h4><br>  Die Jungs von JetBrains haben ihren Compiler-Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf den Github</a> hochgeladen.  Wie man es benutzt, k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier sehen</a> . <br><br>  Zuerst habe ich ihren Parser zusammen mit dem Analysator verwendet, da Sie zum √úbersetzen in eine andere Sprache wissen m√ºssen, welcher Typ die Variable ist, ohne den Typ <code>val x = vec3()</code> explizit anzugeben.  Hier ist der Typ f√ºr den Leser offensichtlich, aber im AST sind diese Informationen nicht so einfach zu erhalten, insbesondere wenn sich rechts eine andere Variable oder ein Funktionsaufruf befindet. <br><br>  Hier war ich entt√§uscht.  Der erste Start des Parsers f√ºr eine primitive Datei dauert 3 Sekunden (DREI SEKUNDEN). <br><br> <code><b>Kotlin JetBrains parser</b> <br> first call elapsed : 3254.482ms <br> min time in next 10 calls: 70.071ms <br> min time in next 100 calls: 29.973ms <br> min time in next 1000 calls: 16.655ms <br> Whole time for 1111 calls: 40.888756 seconds <br></code> <br>  Eine solche Zeit hat die folgenden offensichtlichen Unannehmlichkeiten: <br><br><ol><li>  weil es plus drei Sekunden dauert, um ein Spiel oder eine Anwendung zu starten. </li><li>  W√§hrend der Entwicklung verwende ich eine Hot-Shader-√úberladung und sehe das Ergebnis sofort nach dem √Ñndern des Codes. </li><li>  Ich starte die Anwendung oft neu und bin froh, dass sie schnell genug startet (ein oder zwei Sekunden). </li></ol><br>  Plus drei Sekunden zum Aufw√§rmen des Parsers - das ist nicht akzeptabel.  Nat√ºrlich wurde sofort klar, dass bei nachfolgenden Aufrufen die Analysezeit auf 50 ms und sogar auf 20 ms abf√§llt, was die Unannehmlichkeit Nr. 2 aus dem Ausdruck (fast) beseitigt.  Aber die anderen beiden gehen nirgendwo hin.  Zus√§tzlich sind 50 ms pro Datei plus 2500 ms pro 50 Dateien (ein Shader besteht aus 1-2 Dateien).  Was ist, wenn es Android ist?  (Hier geht es nur um Zeit.) <br><br>  <i>Bemerkenswert ist die verr√ºckte Arbeit von JIT.</i>  <i>Die Analysezeit f√ºr eine einfache Datei sinkt von 70 ms auf 16 ms.</i>  <i>Dies bedeutet zum einen, dass die JIT selbst Ressourcen verbraucht, und zum anderen kann das Ergebnis einer anderen JVM sehr unterschiedlich sein.</i> <br><br>  Um herauszufinden, woher diese Zahlen stammen, gab es eine Option: Verwenden Sie den Parser ohne Analysator.  Schlie√ülich muss ich nur die Typen anordnen, und dies kann relativ einfach durchgef√ºhrt werden, w√§hrend der JetBrains-Analysator etwas viel Komplexeres ausf√ºhrt und viel mehr Informationen sammelt.  Und dann sinkt die Startzeit um die H√§lfte (aber fast eineinhalb Sekunden sind immer noch anst√§ndig), und die Zeit f√ºr nachfolgende Anrufe ist bereits viel interessanter - von 8 ms in den ersten zehn auf 0,9 ms irgendwo in den Tausenden. <br><br>  <code><b>Kotlin JetBrains parser (without analyzer)</b></code> <code><a href="">() <br> first call elapsed : 1423.731ms <br> min time in next 10 calls: 8.275ms <br> min time in next 100 calls: 2.323ms <br> min time in next 1000 calls: 0.974ms <br> Whole time for 1111 calls: 3.6884801 seconds <br></a></code> <code><a href="">()</a> <br> first call elapsed : 1423.731ms <br> min time in next 10 calls: 8.275ms <br> min time in next 100 calls: 2.323ms <br> min time in next 1000 calls: 0.974ms <br> Whole time for 1111 calls: 3.6884801 seconds <br></code> <br>  <em>Ich musste genau solche Zahlen sammeln.</em>  <em>Die erste Startzeit ist wichtig, wenn die ersten Shader geladen werden.</em>  <em>Dies ist wichtig, da Sie den Benutzer hier nicht ablenken k√∂nnen, w√§hrend die Shader im Hintergrund geladen sind. Er wartet nur.</em>  <em>Ein R√ºckgang der Laufzeit ist wichtig, um die Dynamik selbst zu sehen, wie JIT funktioniert und wie effizient wir Shader in eine warme Anwendung laden k√∂nnen.</em> <em><br></em> <br>  Der Hauptgrund, sich haupts√§chlich mit dem JetBrains-Parser zu befassen, war der Wunsch, den Typ zu verwenden.  Da das Ablehnen jedoch zur besprochenen Option wird, k√∂nnen Sie versuchen, andere Parser zu verwenden.  Dar√ºber hinaus sind Nicht-JetBrains h√∂chstwahrscheinlich viel kleiner, weniger umweltintensiv und einfacher durch die Unterst√ºtzung und Einbeziehung von Code in das Projekt. <br><br><h4>  ANTLR </h4><br>  Es gab keinen Parser auf JavaCC, aber auf dem Hype ANTLR gibt es erwartungsgem√§√ü ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei</a> ). <br><br>  Was jedoch unerwartet war, war Geschwindigkeit.  Die gleichen 3s zum Laden (erster Anruf) und fantastische 140 ms f√ºr nachfolgende Anrufe.  Hier dauert nicht nur der erste Start unangenehm lange, sondern die Situation wird auch nicht korrigiert.  Anscheinend haben die Jungs von JetBrains etwas Magie gemacht, indem sie JIT ihren Code auf diese Weise optimieren lie√üen.  Weil ANTLR im Laufe der Zeit √ºberhaupt nicht optimiert wird. <br><br>  <code><b>Kotlin ANTLR parser</b></code> <code><a href="">() <br> first call elapsed : 3705.101ms <br> min time in next 10 calls: 139.596ms <br> min time in next 100 calls: 138.279ms <br> min time in next 1000 calls: 137.20099ms <br> Whole time for 1111 calls: 161.90619 seconds <br></a></code> <code><a href="">()</a> <br> first call elapsed : 3705.101ms <br> min time in next 10 calls: 139.596ms <br> min time in next 100 calls: 138.279ms <br> min time in next 1000 calls: 137.20099ms <br> Whole time for 1111 calls: 161.90619 seconds <br></code> <br><h4>  Javacc </h4><br>  Im Allgemeinen sind wir √ºberrascht, die Dienste von ANTLR abzulehnen.  Das Parsen muss nicht so lange dauern!  Es gibt keine kosmischen Mehrdeutigkeiten in Kotlins Grammatik und ich habe sie auf praktisch leere Dateien √ºberpr√ºft.  Es ist also Zeit, das alte JavaCC aufzudecken, die √Ñrmel hochzukrempeln und trotzdem "es selbst zu tun und wie es geht". <br><br>  Diesmal waren die Zahlen zu erwarten, wenn auch im Vergleich zu den Alternativen - unerwartet angenehm. <br><br>  <code><b>Kotlin JavaCC parser</b></code> <code><a href="">() <br> first call elapsed : 19.024ms <br> min time in next 10 calls: 1.952ms <br> min time in next 100 calls: 0.379ms <br> min time in next 1000 calls: 0.114ms <br> Whole time for 1111 calls: 0.38707677 seconds <br></a></code> <code><a href="">()</a> <br> first call elapsed : 19.024ms <br> min time in next 10 calls: 1.952ms <br> min time in next 100 calls: 0.379ms <br> min time in next 1000 calls: 0.114ms <br> Whole time for 1111 calls: 0.38707677 seconds <br></code> <br>  <i>Pl√∂tzliche Profis Ihres JavaCC-Parsers</i> <br>  Anstatt einen eigenen Parser zu schreiben, m√∂chte ich nat√ºrlich eine vorgefertigte L√∂sung verwenden.  Bestehende haben jedoch gro√üe Nachteile: <br><br>  - Leistung (Pausen beim Lesen eines neuen Shaders sind nicht akzeptabel, sowie drei Sekunden Aufw√§rmen zu Beginn) <br>  - eine riesige Kotlin-Laufzeit, ich bin mir nicht einmal sicher, ob es m√∂glich ist, den Parser mit seiner Verwendung in das Endprodukt zu packen <br>  - √úbrigens, in der aktuellen L√∂sung mit Groovy das gleiche Problem - die Laufzeit erstreckt sich <br><br>  W√§hrend der resultierende JavaCC-Parser ist <br><br>  + ausgezeichnete Geschwindigkeit sowohl am Start als auch im Prozess <br>  + nur ein paar Klassen des Parsers selbst <br><br><h4>  Schlussfolgerungen </h4><br>  JetBrains sind zu schwer zu ziehen, ANTLR ist ein Hype, aber unerwartet langsam, und JavaCC ist zu fr√ºh, um es abzuschreiben. <br><br>  Analysieren einer einfachen Kotlin-Datei mit drei verschiedenen Implementierungen: <br><br><table><tbody><tr><th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr></tbody></table><br>  Irgendwann entschied ich mich, die Gr√∂√üe des Glases mit allen Abh√§ngigkeiten zu betrachten.  JetBrains sind wie erwartet gro√üartig, <strike>aber die ANTLR-Laufzeit beeindruckt durch ihre Gr√∂√üe</strike> . <br>  <i>UPDATE: Anfangs habe ich 15 MB geschrieben, aber wie in den Kommentaren vorgeschlagen, sinkt die Gr√∂√üe auf den erwarteten Wert, wenn Sie antlr4-runtime anstelle von antlr4 verbinden.</i>  <i>Obwohl der JavaCC-Parser selbst zehnmal kleiner als ANTLR bleibt (wenn Sie den gesamten Code mit Ausnahme der Parser selbst entfernen).</i> <br>  Die Gr√∂√üe des Glases als solches ist nat√ºrlich f√ºr Mobiltelefone wichtig.  Dies ist jedoch auch f√ºr den Desktop von Bedeutung, da es sich tats√§chlich um die Menge an zus√§tzlichem Code handelt, die Fehler enthalten kann, die von der IDE indiziert werden sollten. Dies wirkt sich genau auf die Geschwindigkeit des ersten Ladens und die Geschwindigkeit des Aufw√§rmens aus.  Dar√ºber hinaus gibt es f√ºr komplexen Code wenig Hoffnung, in eine andere Sprache zu √ºbersetzen. <br>  Ich fordere Sie nicht auf, Kilobyte zu z√§hlen, und ich sch√§tze die Zeit und die Bequemlichkeit des Programmierers, aber es lohnt sich trotzdem, √ºber Einsparungen nachzudenken, da Projekte so ungeschickt und schwierig zu warten sind. <br><br>  <i>Ein paar Worte zu ANTLR und JavaCC</i> <br><br>  Ein ernstes Merkmal von ANTLR ist die Trennung von Grammatik und Code.  Es w√§re gut, wenn es nicht so teuer bezahlen m√ºsste.  Ja, und dies ist nur f√ºr "Serienentwickler von Grammatiken" von Bedeutung, und f√ºr Endprodukte ist dies nicht so wichtig, da selbst die vorhandene Grammatik noch fertig sein muss, um Ihren Code zu schreiben.  Wenn wir Geld sparen und eine Grammatik von Drittanbietern verwenden, ist dies m√∂glicherweise nur unpraktisch, muss jedoch noch gr√ºndlich verstanden werden und transformiert den Baum f√ºr sich.  Im Allgemeinen mischt JavaCC nat√ºrlich Fliegen und Schnitzel, aber ist das wirklich wichtig und ist es so schlimm? <br><br>  Ein weiteres Merkmal von ANTLR sind die vielen Zielplattformen.  Aber hier k√∂nnen Sie von der anderen Seite schauen - der Code unter JavaCC ist sehr einfach.  Und es ist sehr einfach ... ausgestrahlt!  Richtig mit Ihrem benutzerdefinierten Code - zumindest in C #, zumindest in JS. <br><br><h4>  PS </h4><br>  Der gesamte Code ist hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/kravchik/yast</a> <br><br>  Das Ergebnis der Analyse ist ein auf YastNode erstellter Baum (dies ist in der Tat eine sehr einfache Klasse - eine Karte mit praktischen Methoden und einem Bezeichner).  Aber YastNode ist nicht wirklich ein "sph√§rischer Knoten im luftleeren Raum".  Es ist diese Klasse, die ich aktiv benutze, basierend darauf habe ich mehrere Werkzeuge gesammelt - einen Typierer, mehrere √úbersetzer und einen Optimierer / Inliner. <br><br>  Der JavaCC-Parser enth√§lt noch nicht die gesamte Grammatik, es sind noch 10 Prozent √ºbrig. Es scheint jedoch nicht, dass sie die Leistung beeintr√§chtigen k√∂nnten. Ich habe die Geschwindigkeit beim Hinzuf√ºgen von Regeln √ºberpr√ºft und sie hat sich nicht merklich ge√§ndert.  Au√üerdem habe ich bereits viel mehr getan, als ich brauchte, und versuche nur, das unerwartete Ergebnis des Prozesses zu teilen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433000/">https://habr.com/ru/post/de433000/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432990/index.html">Edison Sprachaktivierte Holzlampe. Ausgabepreis 5 USD</a></li>
<li><a href="../de432992/index.html">Er setzte seine Kopfh√∂rer auf und starb: Wir haben es mit dem seltsamen Tod eines Sch√ºlers in Rimbau zu tun</a></li>
<li><a href="../de432994/index.html">Vivaldi 2.2 - Quantit√§t in Qualit√§t umwandeln</a></li>
<li><a href="../de432996/index.html">Ein paar W√∂rterb√ºcher Interna in CPython (und PyPy)</a></li>
<li><a href="../de432998/index.html">Weihnachtsgeschichte</a></li>
<li><a href="../de433002/index.html">Komm selbst ... oder die Kommunikationsregeln in einem Team</a></li>
<li><a href="../de433004/index.html">Eine robuste Cloud-Migrationsstrategie f√ºr 2019: 7 Tipps</a></li>
<li><a href="../de433008/index.html">USB-Ger√§te sind eine "pl√∂tzliche" Bedrohung</a></li>
<li><a href="../de433010/index.html">Haben Sie eine Idee: Berechtigungssystem f√ºr npm-Pakete</a></li>
<li><a href="../de433012/index.html">Vielleicht lebe ich nur wegen ihr: Warum verlassen sich Patienten mit Apnoe auf ein Programm, das von einem Hacker geschrieben wurde?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>