<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’˜ ğŸš¦ ğŸ· Pembuatan angka efektif dalam interval yang diberikan ğŸ…ğŸ¿ ğŸ”¢ ğŸ˜•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebagian besar tulisan saya tentang pembuatan angka acak terutama berkaitan dengan properti dari berbagai skema generasi. Ini mungkin ternyata tidak t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pembuatan angka efektif dalam interval yang diberikan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455702/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg" alt="gambar"></div><br>  Sebagian besar tulisan saya tentang pembuatan angka acak terutama berkaitan dengan properti dari berbagai skema generasi.  Ini mungkin ternyata tidak terduga, tetapi kinerja algoritma pengacakan tidak tergantung pada skema generasi yang dipilih, tetapi pada faktor-faktor lain.  Dalam posting ini (yang saya terinspirasi oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang</a> sangat bagus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oleh Daniel Lemyr</a> ), kami akan memeriksa alasan utama untuk penurunan kinerja generasi nomor acak, yang sering melebihi kinerja mesin PRN. <br><br>  Bayangkan situasi ini: <br><br>  Sebagai pekerjaan rumah, Juan dan Sasha menerapkan algoritma acak yang sama di C ++, yang akan berjalan di komputer universitas yang sama dan dengan satu set data.  Kode mereka hampir identik dan hanya berbeda dalam generasi angka acak.  Juan sedang terburu-buru untuk pelajaran musiknya, jadi dia hanya memilih angin puyuh Mersenne.  Sasha, di sisi lain, menghabiskan beberapa jam ekstra untuk meneliti.  Sasha melakukan tolok ukur beberapa PRNG tercepat, yang baru-baru ini ia pelajari dari jejaring sosial, dan memilih yang tercepat.  Pada pertemuan itu, Sasha tidak sabar untuk menyombongkan diri, dan dia bertanya kepada Juan: "PRNG apa yang kamu gunakan?" <br><br>  "Secara pribadi, saya baru saja mengambil pusaran Mersenne - itu dibangun ke dalam bahasa dan tampaknya bekerja dengan cukup baik." <br><br>  "Ha!" Jawab Sasha.  â€œSaya menggunakan <code>jsf32</code> .  Ini jauh lebih cepat daripada angin puyuh Mersenne yang lama dan lambat!  Program saya berjalan dalam 3 menit 15 detik! " <br><br>  "Hmm, tidak buruk, tapi milikku bisa melakukannya dalam waktu kurang dari satu menit," kata Juan dan mengangkat bahu.  â€œKalau begitu, aku harus pergi ke konser.  Maukah Anda ikut dengan saya? " <br><br>  "Tidak," jawab Sasha.  "Aku ... eh ... perlu melihat kodeku lagi." <br><br>  Situasi fiksi yang canggung ini <em>tidak</em> terlalu fiksi;  ini didasarkan pada hasil nyata.  Jika algoritma acak Anda tidak berjalan secepat yang kami inginkan, dan bottleneck tampaknya menjadi nomor acak, maka, anehnya, masalahnya mungkin bukan pada generator angka acak! <br><a name="habracut"></a><br><h3>  Pendahuluan: Angka Acak dalam Praktek </h3><br>  Kebanyakan generator angka acak modern berkualitas tinggi menciptakan kata-kata mesin yang diisi dengan bit acak, yaitu, mereka biasanya menghasilkan angka dalam interval [0..2 <sup>32</sup> ] atau [0..2 <sup>64</sup> ).  Tetapi dalam banyak kasus penggunaan, pengguna membutuhkan angka dalam interval tertentu - misalnya, untuk melempar dadu atau memilih kartu bermain acak, angka diperlukan dalam interval konstan kecil.  Namun, banyak algoritma, dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencampuran</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengambilan sampel reservoir</a> hingga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon pencarian biner acak,</a> membutuhkan angka yang diambil dari interval lain. <br><br><h3>  Metode </h3><br>  Kami akan melihat banyak metode yang berbeda.  Untuk menyederhanakan diskusi, alih-alih menghasilkan angka dalam interval [ <em>i</em> .. <em>j</em> ) atau [ <em>i</em> .. <em>j</em> ], kita akan menghasilkan angka dalam interval [0 .. <em>k</em> ).  Dengan skema seperti itu, kita dapat, misalnya, menghasilkan angka dalam interval [ <em>i</em> .. <em>j</em> ) dengan mengatur <em>k</em> = <em>j</em> - <em>i</em> , menghasilkan angka dalam interval [0 .. <em>k</em> ), dan kemudian menambahkan <em>i</em> ke dalamnya. <br><br><h4>  Alat C ++ bawaan </h4><br>  Banyak bahasa memiliki alat bawaan untuk mendapatkan angka acak dalam interval yang ditentukan.  Sebagai contoh, untuk menghapus kartu dari tumpukan dengan 52 kartu dalam bahasa scripting seperti Perl dan Python, kita dapat menulis <code>int(rand(52))</code> dan <code>random.randint(0,52)</code> .  [Catatan  Pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">CryptoPirate</a> : <i>Menurut saya ada kesalahan di sini, dalam Python randint (a, b) menghasilkan angka dari a ke b termasuk b.</i>  <i>Dan karena ada 52 kartu di dek dan yang pertama adalah "0", itu harus acak.randint (0,51)</i> .] Dalam C ++, kita dapat menggunakan <code>uniform_int_distribution</code> dengan <code>uniform_int_distribution</code> sama. <br><br>  Kode C ++ untuk mengimplementasikan pendekatan ini sederhana: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt; dist(<span class="hljs-number"><span class="hljs-number">0</span></span>, range<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dist(rng); }</code> </pre> <br>  Biasanya, salah satu teknik yang dijelaskan di bawah ini digunakan dalam alat bawaan, tetapi sebagian besar pengguna hanya menggunakan alat ini, tidak memikirkan apa yang terjadi "di bawah tenda," percaya bahwa alat ini dirancang dengan benar dan cukup efektif.  Dalam C ++, alat bawaan lebih kompleks karena mereka harus dapat bekerja dengan mesin generasi yang sewenang-wenang - generator yang menghasilkan nilai dalam kisaran dari -3 hingga 17 bisa sangat valid dan dapat digunakan dengan <code>std::uniform_int_distribution</code> untuk membuat angka dalam interval apa pun, misalnya [0..1000).  Artinya, alat C ++ bawaan terlalu rumit untuk sebagian besar kasus di mana mereka digunakan. <br><br><h4>  Sisa klasik dari divisi (condong) </h4><br>  Mari kita beralih dari pendekatan yang terlalu disederhanakan ke pendekatan yang terlalu sederhana. <br><br>  Ketika saya mempelajari pemrograman, kami menghasilkan angka dalam interval (misalnya, untuk memilih kartu dalam setumpuk 52 kartu) menggunakan operator sisanya.  Untuk mendapatkan nomor dalam interval [0..52), kami menulis <code>rand() % 52</code> . <br><br>  Dalam C ++, pendekatan ini dapat diimplementasikan sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rng() % range; }</code> </pre> <br>  Terlepas dari kesederhanaan pendekatan ini, ini menunjukkan alasan bahwa mendapatkan angka pada interval yang tepat biasanya merupakan tugas yang lambat - ini membutuhkan pembagian (untuk menghitung sisanya yang diperoleh oleh <code>%</code> operator).  Membagi biasanya setidaknya urutan besarnya lebih lambat dari operasi aritmatika lainnya, sehingga operasi aritmatika tunggal membutuhkan waktu lebih lama dari semua pekerjaan yang dilakukan oleh PRNG cepat. <br><br>  Namun selain kecepatan rendah, ia juga <em>condong</em> .  Untuk memahami mengapa <code>rand() % 52</code> mengembalikan angka miring, misalkan <code>rand()</code> membuat angka dalam interval [0..2 <sup>32</sup> ), dan perhatikan bahwa 52 tidak membagi 2 <sup>32</sup> sepenuhnya, ia membaginya 82 595 524 kali dengan sisanya. 48. Yaitu, jika kita menggunakan <code>rand() % 52</code> , maka kita akan memiliki 82 595 525 cara untuk memilih 48 kartu pertama dari tumpukan dan hanya 82 595 524 cara untuk memilih empat kartu terakhir.  Dengan kata lain, ada kemiringan 0,00000121% terhadap empat kartu terakhir ini (mungkin ini adalah raja!).  Ketika saya masih mahasiswa dan menulis pekerjaan rumah tentang melempar dadu atau menggambar kartu, biasanya tidak ada yang peduli tentang distorsi sekecil itu, tetapi dengan peningkatan interval, distorsi tumbuh secara linear.  Untuk PRNG 32-bit, interval terbatas kurang dari 2 <sup>24</sup> memiliki kemiringan kurang dari 0,5%, tetapi di atas 2 <sup>31</sup> kemiringan 50% - beberapa angka akan kembali dua kali lebih sering daripada yang lain. <br><br>  Dalam artikel ini, kami terutama akan mempertimbangkan teknik yang menggunakan strategi untuk menghilangkan kesalahan sistematis, tetapi mungkin layak dikatakan bahwa untuk PRNG 64-bit, nilai miring pada aplikasi biasa cenderung diabaikan. <br><br>  Masalah lain mungkin beberapa generator memiliki bit rendah yang lemah.  Misalnya, keluarga GPRS Xoroshiro + dan Xoshiro + memiliki bit rendah yang tidak lulus tes statistik.  Ketika kita mengeksekusi <code>% 52</code> (karena 52 genap), kita meneruskan bit orde rendah langsung ke output. <br><br><h4>  Mengalikan angka floating point (condong) </h4><br>  Teknik umum lainnya adalah penggunaan PRNG yang menghasilkan angka floating point dalam interval [0..1) dengan konversi selanjutnya dari angka-angka ini ke interval yang diinginkan.  Pendekatan ini digunakan dalam Perl, <a href="">disarankan untuk</a> menggunakan <code>int(rand(10))</code> untuk menghasilkan integer dalam interval [0..10) dengan menghasilkan angka titik-mengambang diikuti dengan pembulatan ke bawah. <br><br>  Dalam C ++, pendekatan ini ditulis seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rng_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> zeroone = <span class="hljs-number"><span class="hljs-number">0x1</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>p<span class="hljs-number"><span class="hljs-number">-32</span></span> * rng(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> range * zeroone; }</code> </pre> <br>  (Perhatikan bahwa <code>0x1.0p-32</code> adalah konstanta titik-mengambang biner untuk 2 <sup>-32</sup> , yang kami gunakan untuk mengonversi bilangan bulat acak dalam interval [0..2 <sup>32</sup> ) menjadi dua kali lipat dalam interval unit;  alih-alih, kita dapat melakukan konversi seperti itu menggunakan <code>ldexp(rng(), -32)</code> , tetapi ketika saya membandingkan pendekatan ini, ternyata lebih lambat.) <br><br>  Pendekatan ini sama miringnya dengan sisa klasik pembagian, tetapi kemiringan tampak berbeda.  Sebagai contoh, jika kita memilih angka dalam interval [0..52), maka angka 0, 13, 26, dan 39 akan muncul sekali lebih jarang daripada yang lain. <br><br>  Versi ini, ketika digeneralisasikan ke 64 bit, bahkan lebih tidak menyenangkan, karena memerlukan tipe floating point yang mantissanya setidaknya 64 bit.  Pada mesin x86 dengan Linux dan macOS, kita dapat menggunakan <code>long double</code> untuk memanfaatkan peningkatan angka floating-point x86 presisi yang memiliki mantissa 64-bit, tetapi <code>long double</code> tidak secara universal diangkut ke semua sistem - dalam beberapa sistem, <code>long double</code> setara dengan <code>double</code> . <br><br>  Ada sisi baiknya - pendekatan ini lebih cepat daripada solusi residual untuk PRNG dengan bit rendah yang lemah. <br><br><h4>  Multiplikasi Integer (Miring) </h4><br>  Metode multiplikasi dapat disesuaikan dengan aritmatika fixed daripada floating point.  Bahkan, kami hanya terus-menerus mengalikan dengan <sup>32</sup> , <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br>  Tampaknya versi ini membutuhkan aritmatika 64-bit, pada prosesor x86, kompiler yang baik akan mengkompilasi kode ini menjadi instruksi <code>mult</code> -bit 32-bit (yang memberi kita dua nilai output 32-bit, salah satunya adalah nilai balik).  Versi ini bisa diharapkan cepat, tetapi miring persis seperti metode mengalikan angka floating point. <br><br><h4>  Jatuhkan divisi (tidak condong) </h4><br>  Kita dapat memodifikasi skema perkalian floating point menjadi skema berbasis divisi.  Alih-alih mengalikan <code>x * range / 2**32</code> kami menghitung <code>x / (2**32 / range)</code> .  Karena kami bekerja dengan bilangan bulat aritmatika, pembulatan dalam versi ini akan dilakukan secara berbeda, dan terkadang menghasilkan nilai di luar interval yang diinginkan.  Jika kita membuang nilai-nilai ini (misalnya, membuangnya dan menghasilkan nilai-nilai baru), maka sebagai hasilnya kita mendapatkan teknik tanpa distorsi. <br><br>  Misalnya, dalam kasus mengeluarkan kartu menggunakan PRNG 32-bit, kita dapat menghasilkan nomor 32-bit dan membaginya dengan 2 32/52 = 82 595 524 untuk memilih kartu.  Teknik ini berfungsi jika nilai acak dari PRNG 32-bit kurang dari 52 Ã— 82595524 = 2 32/32 - 48. Jika nilai acak dari PRNR adalah salah satu dari 48 nilai terakhir dari bagian atas interval generator, maka Anda harus membuangnya dan mencari yang lain. <br><br>  Kode kami untuk versi ini menggunakan trik dengan membagi 2 <sup>32</sup> berdasarkan <code>range</code> tanpa menggunakan matematika 64-bit.  Untuk perhitungan langsung <code>2**32 / range</code> kita perlu merepresentasikan angka 2 <sup>32</sup> , yang terlalu besar (per satu!) Untuk direpresentasikan sebagai integer 32-bit.  Sebagai gantinya, kami memperhitungkan bahwa untuk bilangan bulat tak bertanda, kisaran operasi negasi unary menghitung nilai positif dari <code>range</code> 2 <sup>32</sup> ;  membagi nilai ini dengan <code>range</code> , kami mendapat respons yang kurang dari <code>2**32 / range</code> . <br><br>  Oleh karena itu, kode C ++ untuk menghasilkan angka menggunakan pembagian dan penurunan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates divisor = 2**32 / range uint32_t divisor = ((-range) / range) + 1; if (divisor == 0) // overflow, it's really 2**32 return 0; for (;;) { uint32_t val = rng() / divisor; if (val &lt; range) return val; } }</span></span></code> </pre> <br>  Tentu saja, pendekatan ini membutuhkan dua operasi lambat berdasarkan divisi, yang biasanya lebih lambat daripada operasi aritmatika lainnya, jadi Anda seharusnya tidak mengharapkannya cepat. <br><br><h4>  Sisa dari divisi (ganda) tanpa distorsi - teknik OpenBSD </h4><br>  Kita juga dapat mengambil pendekatan jatuhkan untuk menghilangkan kemiringan dalam metode pembagian divisi klasik.  Dalam contoh dengan bermain kartu, kita perlu lagi menjatuhkan 48 nilai.  Dalam versi ini, alih-alih membuang 48 nilai <em>terakhir</em> , kami (setara) membuang 48 nilai <em>pertama</em> . <br><br>  Berikut ini adalah implementasi dari pendekatan ini dalam C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br>  Teknik ini menghilangkan kemiringan, tetapi membutuhkan dua operasi pembagian yang memakan waktu dengan sisa dari masing-masing nilai output (dan Anda mungkin memerlukan generator internal untuk membuat beberapa angka).  Oleh karena itu, harus diharapkan bahwa metode ini akan menjadi sekitar dua kali lebih lambat daripada pendekatan kemiringan klasik. <br><br>  <a href=""><code> arc4random_uniform</code> OpenBSD <code> arc4random_uniform</code></a> (yang juga digunakan pada OS X dan iOS) menggunakan strategi ini. <br><br><h4>  Sisa pembagian (tunggal) tanpa metodologi miring - Jawa </h4><br>  Java menggunakan pendekatan yang berbeda untuk menghasilkan angka dalam interval yang hanya menggunakan satu operasi pembagian sisa, dengan pengecualian kasus yang cukup jarang membuang hasil.  Kode: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rng_t&amp; rng, uint32_t range)</span></span></span><span class="hljs-function"> </span></span>{ uint32_t x, r; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng(); r = x % range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x - r &gt; (-range)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre> <br>  Untuk memahami mengapa opsi ini berfungsi, Anda perlu berpikir sedikit.  Berbeda dengan versi sebelumnya yang didasarkan pada residu, yang menghilangkan bias dengan menghapus bagian dari nilai terendah dari mesin pembangkitan internal, versi ini memfilter nilai dari bagian atas interval mesin. <br><br><h4>  Perkalian bilangan bulat miring - Metode Lemira </h4><br>  Dalam banyak cara yang sama kita menghilangkan bias dari sisa metode pembagian, kita dapat menghilangkan bias dari teknik multiplikasi bilangan bulat.  Teknik ini ditemukan oleh Lemyr. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br><h4>  Drop bitmask (no skew) - Teknik Apple </h4><br>  Dalam pendekatan terakhir kami, operasi divisi dan sisanya sepenuhnya dihilangkan.  Sebagai gantinya, ia menggunakan operasi masking sederhana untuk mendapatkan angka acak dalam interval [0..2 <sup><em>k</em></sup> ), di mana <em>k</em> adalah nilai terkecil, sehingga 2 <sup><em>k</em></sup> lebih besar dari interval.  Jika nilainya terlalu besar untuk interval kami, kami membuangnya dan mencoba untuk mendapatkan yang lain.  Kode ditunjukkan di bawah ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask = ~<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); --range; mask &gt;&gt;= __builtin_clz(range|<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng() &amp; mask; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x &gt; range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br>  Pendekatan ini diadopsi oleh Apple ketika (dalam rilis macOS Sierra) melakukan <a href="">revisi sendiri terhadap</a> kode <code>arc4random_uniform</code> . <br><br><h3>  Membandingkan teknik dasar </h3><br>  Sekarang kami memiliki beberapa pendekatan yang dapat dievaluasi.  Sayangnya, ketika kita khawatir tentang biaya operasi divisi tunggal, pembandingan menjadi hal yang tidak sepele.  Tidak ada patokan yang dapat memperhitungkan semua faktor yang mempengaruhi bidang aplikasi, dan tidak ada jaminan bahwa opsi terbaik untuk aplikasi Anda tentu akan menjadi yang terbaik untuk tambang. <br><br>  Kami menggunakan tiga tolok ukur dan menguji teknik dengan banyak PRNG yang berbeda. <br><br><h4>  Benchmark Large-Shuffle </h4><br>  Mungkin tolok ukur yang paling jelas adalah pencampuran.  Dalam tolok ukur ini, kami mensimulasikan melakukan pencampuran skala besar.  Untuk mengurutkan array ukuran <em>N,</em> kita harus menghasilkan angka dalam interval [0 .. <em>N</em> ), [0 .. ( <em>N</em> -1)), ..., [0..1).  Dalam tolok ukur ini, kita akan menganggap bahwa <em>N</em> adalah angka maksimum yang mungkin (untuk <code>uint32_t</code> adalah 2 <sup>32</sup> -1).  Kode: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; }</code> </pre> <br>  Perhatikan bahwa kami "menggunakan" setiap angka dengan menambahkannya ke <code>sum</code> (sehingga tidak akan dibuang dengan optimasi), tetapi kami tidak melakukan pencampuran apa pun untuk fokus pada generasi angka. <br><br>  Untuk pengujian generasi 64-bit, kami memiliki tes yang serupa, tetapi akan tidak praktis untuk melakukan tes yang sesuai dengan pencampuran array ukuran 2 <sup>64</sup> - 1 (karena akan membutuhkan ribuan tahun untuk menyelesaikan benchmark yang lebih besar ini).  Sebagai gantinya, kami melintasi seluruh interval 64-bit, tetapi menghasilkan jumlah nilai output yang sama seperti pada uji 32-bit.  Kode: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bound = (<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(i)&lt;&lt;<span class="hljs-number"><span class="hljs-number">32</span></span>) | i; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bval = bounded_rand(rng, bound ); assert(bval &lt; bound); sum += bval; }</code> </pre> <br><h5>  Hasil vortex Mersenne </h5><br>  Hasil yang ditunjukkan di bawah ini menunjukkan kinerja tolok ukur ini untuk masing-masing metode yang kami teliti ketika menggunakan Mersenne vortex dan mengujinya pada 32-bit (menggunakan <code>std::mt19937</code> dari <code>libstdc++</code> ) dan kode 64-bit yang serupa (menggunakan <code>std:mt19937_64</code> dari <code>libstdc++</code> )  Hasilnya adalah rata-rata geometris 15 run dengan nilai seed yang berbeda, yang kemudian dinormalisasi sehingga metode pembagian divisi klasik memiliki waktu run tunggal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9f/3eb/53f/b9f3eb53f894a14ac2698f44090b23a6.svg"></div><br>  Tampaknya kami memiliki jawaban yang jelas tentang kinerja - tampaknya Anda dapat membangun teknik untuk kesempurnaan mereka, dan bertanya pada diri sendiri apa yang dipikirkan pengembang <code>libstdc++</code> ketika mereka menulis implementasi yang mengerikan untuk angka 32-bit.  Tetapi, seperti yang sering terjadi dengan pembandingan, situasinya lebih rumit daripada yang terlihat dari hasil ini.  Pertama, ada risiko bahwa hasilnya mungkin spesifik untuk pusaran Mersenne, jadi kami akan memperluas banyak PRNG yang diuji.  Kedua, mungkin ada masalah dengan benchmark itu sendiri.  Mari kita berurusan dengan pertanyaan pertama. <br><br><h5>  Hasil dari berbagai PRNG </h5><br>  Kami akan menguji <code>arc4_rand32</code> 32-bit dengan <code>arc4_rand32</code> , <code>chacha8r</code> , <code>gjrand32</code> , <code>jsf32</code> , <code>mt19937</code> , <code>pcg32</code> , <code>pcg32_fast</code> , <code>sfc32</code> , <code>splitmix32</code> , <code>xoroshiro64+</code> , <code>xorshift*64/32</code> <code>xoshiro128+</code> , <code>xoshiro128+</code> dan <code>xoshiro128**</code> , dan <code>gjrand64</code> dengan <code>gjrand64</code> <code>jsf64</code> , <code>mcg128</code> , <code>mcg128_fast</code> , <code>mt19937_64</code> , <code>pcg64</code> , <code>pcg64_fast</code> , <code>sfc64</code> , <code>splitmix64</code> , <code>xoroshiro128+</code> , <code>xorshift*128/64</code> <code>xoshiro256+</code> , <code>xoshiro256+</code> dan <code>xoshiro256*</code> .  Kit ini akan memberi kita beberapa PRN lambat dan banyak yang sangat cepat. <br><br>  Inilah hasilnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2dc/8c8/f1a/2dc8c8f1af9aa517a92260e7cbd3a73e.svg"></div><br>  Kita bisa melihat perbedaan utama dari hasil dengan vortex Mersenne.  PRNG lebih cepat menggeser kesetimbangan ke arah kode terikat, dan oleh karena itu perbedaan antara pendekatan yang berbeda menjadi lebih jelas, terutama dalam kasus PRNR 64-bit.  Dengan serangkaian <code>libstc++</code> lebih luas <code>libstc++</code> implementasi <code>libstc++</code> tidak lagi tampak mengerikan. <br><br><h5>  Kesimpulan </h5><br>  Dalam benchmark ini dengan margin yang signifikan, pendekatan yang didasarkan pada multiplikasi dengan bias menang dalam kecepatan.  Ada banyak situasi di mana batas-batasnya akan relatif kecil dibandingkan dengan ukuran PRNG, dan kinerja sangat penting.  Dalam situasi seperti itu, sedikit bias tidak mungkin memiliki efek yang nyata, tetapi kecepatan PRNG akan memiliki.  Salah satu contohnya adalah Quicksort dengan titik referensi acak.  Dari metode yang miring, teknik bitmask terlihat menjanjikan. <br><br>  Tetapi sebelum membuat kesimpulan yang serius, kita perlu menunjukkan masalah besar dari tolok ukur ini - sebagian besar waktu dihabiskan untuk batas yang sangat tinggi, yang kemungkinan besar memberikan kepentingan berlebihan pada interval besar.  Karena itu, kita perlu menuju ke benchmark kedua. <br><br><h4>  Benchmark Small-Shuffle </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmark ini mirip dengan yang sebelumnya, tetapi melakukan jauh lebih sedikit "pencampuran array" (beberapa). </font><font style="vertical-align: inherit;">Kode:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; } }</code> </pre> <br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hasil vortex Mersenne </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/d3b/4bd/6c5d3b4bdb5f2e45cd805a051d79ab9a.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hasil dari berbagai PRNG </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/9ae/8c0/45a9ae8c040cb4d297fe82f00fa06e3c.svg"></div><br><h5>  Kesimpulan </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark ini menghindari terlalu banyak penekanan pada batas besar dan lebih akurat mencerminkan kasus penggunaan dunia nyata, tetapi sekarang benar-benar membuang batas besar. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark untuk semua interval </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penghitungan ini bertujuan untuk menghindari kerugian dari dua yang sebelumnya; </font><font style="vertical-align: inherit;">ia melakukan pengujian pada setiap ukuran kekuatan dua sehingga setiap ukuran hadir, tetapi pengaruhnya tidak berlebihan.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bit = <span class="hljs-number"><span class="hljs-number">1</span></span>; bit != <span class="hljs-number"><span class="hljs-number">0</span></span>; bit &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">0x1000000</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bound = bit | (i &amp; (bit - <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, bound); assert(bval &lt; bound); sum += bval; } }</code> </pre> <br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hasil vortex Mersenne </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/65c/447/f3465c447f9b19b430bb43533a655c2f.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hasil dari berbagai PRNG </font></font></h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64b/c58/2a2/64bc582a2fde24fd0faedbeaabb9f64c.svg"></div><br><h5>  Kesimpulan </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Banyak temuan kami yang tidak berubah. </font><font style="vertical-align: inherit;">Metode condong cepat jika kita bisa tahan dengan kesalahan, dan skema bitmask tampaknya menjadi pilihan rata-rata yang baik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat mengakhiri ini jika kita tidak ingin kembali, melihat kode kita secara kritis dan mengubahnya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lakukan peningkatan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hingga saat ini, semua metode eliminasi condong memerlukan penggunaan operasi sisa divisi tambahan, itulah sebabnya mereka dilakukan jauh lebih lambat daripada metode condong. </font><font style="vertical-align: inherit;">Akan sangat membantu jika kita dapat mengurangi keuntungan ini.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penurunan Berbasis Ambang Lebih Cepat </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beberapa algoritme kami memiliki kode menggunakan nilai ambang, misalnya: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika </font></font><code>range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kecil dibandingkan dengan interval output PRNG, paling sering angkanya akan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jauh lebih besar dari</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ambang. </font><font style="vertical-align: inherit;">Artinya, jika kita dapat menambahkan perkiraan awal ambang batas, yang mungkin sedikit lebih banyak, kita akan menghemat operasi mahal dengan mengambil sisa divisi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode berikut menangani tugas ini:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> r = rng(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (r &lt; t) r = rng(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r % range; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perubahan ini dapat diterapkan pada "Mod ganda tanpa distorsi" (lihat di atas), dan "perkalian integer tanpa distorsi". </font><font style="vertical-align: inherit;">Gagasan itu ditemukan oleh Lemir, yang menerapkannya pada metode kedua (tetapi tidak pada metode pertama).</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hasil Benchmark Acak Besar </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimalisasi ini mengarah ke peningkatan yang signifikan dalam hasil benchmark 64-bit (di mana mod bahkan lebih lambat), tetapi sebenarnya sedikit menurunkan kinerja dalam benchmark 32-bit. </font><font style="vertical-align: inherit;">Meskipun ada perbaikan, metode bitmask masih menang.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb4/61d/b52/bb461db52be4a7d983dd7f97844179c0.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hasil Tolok Ukur Kecil </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sisi lain, perubahan ini secara signifikan mempercepat benchmark shuffle kecil untuk metode perkalian bilangan bulat dan metode pembagian sisa ganda. </font><font style="vertical-align: inherit;">Dalam kedua kasus, kinerjanya bergeser lebih dekat ke hasil opsi tanpa distorsi. </font><font style="vertical-align: inherit;">Kinerja metode residu ganda (OpenBSD) sekarang hampir sama dengan kinerja metode residu tunggal (Java).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/2bd/fe2/f072bdfe2660cf0f8789b124a8f02646.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hasil benchmark untuk semua interval </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami melihat peningkatan yang serupa dalam tolok ukur untuk semua interval. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/219/b1d/add/219b1daddfa6a55a2cb485b3ae774016.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sepertinya kita dapat mengumumkan pemenang universal baru: metode yang dioptimalkan untuk mengalikan bilangan bulat Lemire tanpa miring. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimasi sisa divisi </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biasanya, perhitungan </font></font><code>a % b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membutuhkan pembagian, tetapi dalam situasi di mana </font></font><code>a &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hasilnya sederhana </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan pembagian tidak diperlukan. </font><font style="vertical-align: inherit;">Dan ketika </font></font><code>a/2 &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, hasilnya sederhana </font></font><code>a - b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Karena itu, alih-alih komputasi</font></font><br><br><pre> <code class="cpp hljs">a %= b;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kita bisa memenuhi </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) { a -= b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) a %= b; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biaya pembagian sangat signifikan sehingga meningkatkan biaya kode yang lebih kompleks ini dapat membenarkan dirinya sendiri dengan menghemat waktu karena kurangnya pembagian. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hasil Benchmark Acak Besar </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menambahkan pengoptimalan ini sangat meningkatkan hasil tolok ukur besar-acak. </font><font style="vertical-align: inherit;">Sekali lagi ini lebih terlihat dalam kode 64-bit, di mana operasi mengambil sisanya lebih mahal. </font><font style="vertical-align: inherit;">Metode double-sisa (gaya OpenBSD) menunjukkan versi dengan optimisasi hanya untuk satu operasi sisa dan untuk keduanya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e1a/669/c56e1a669836477e46f870bd1bc7a6c9.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam tolok ukur ini, topeng bit masih menjadi pemenang, tetapi batas antara itu dan pendekatan Lemira telah menyempit secara signifikan. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hasil Tolok Ukur Kecil </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menambahkan pengoptimalan ini tidak meningkatkan kinerja patokan shuffle kecil, jadi pertanyaannya hanya apakah itu menambah biaya yang signifikan. </font><font style="vertical-align: inherit;">Dalam beberapa kasus, tidak, dalam kasus lain, biaya sedikit meningkat.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/4db/b65/6fa4dbb65b9a3f6c6f9e8ba4f7b455db.svg"></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hasil benchmark untuk semua interval </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam tolok ukur untuk semua interval, perubahan juga kecil. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0e/ae7/758/e0eae77583cc457a9e923540ad954257.svg"></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bonus: hasil perbandingan PRSP </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alasan utama untuk menggunakan banyak PRNG untuk menguji skema angka dalam interval adalah untuk menghindari distorsi hasil yang tidak disengaja karena kekhasan pengoperasian skema PRNG individu. </font><font style="vertical-align: inherit;">Tapi kita bisa menggunakan hasil tes internal yang sama untuk membandingkan skema generasi itu sendiri.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRNG dengan output 32-bit </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grafik di bawah ini menunjukkan kinerja berbagai skema generasi 32-bit, rata-rata untuk semua metode dan lima belas langkah, dinormalisasi dengan kinerja 32-bit Mersenne vortex: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di satu sisi, saya senang melihat bahwa </font></font><code>pcg32_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini sangat cepat - hanya dikalahkan oleh versi kecil Xoroshiro (yang tidak lulus tes statistik). </font><font style="vertical-align: inherit;">Tetapi ini juga menunjukkan mengapa saya jarang marah karena kinerja PRSP tujuan umum modern berkinerja tinggi - perbedaan antara metode yang berbeda sangat tidak signifikan. </font><font style="vertical-align: inherit;">Secara khusus, empat sirkuit tercepat berbeda dalam kinerja kurang dari 5%, dan saya percaya bahwa ini hanya disebabkan oleh "noise".</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PRNG dengan output angka 64-bit </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grafik menunjukkan kinerja berbagai skema generasi 64-bit yang dirata-rata di antara semua teknik dan lima belas proses dinormalisasi dengan kinerja 32-bit Mersenne vortex. Mungkin tampak aneh bahwa normalisasi dilakukan menggunakan vortex Mersenne 32-bit, tetapi ini memungkinkan kita untuk melihat biaya tambahan menggunakan generasi 64-bit dalam kasus di mana generasi 32-bit sudah cukup.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/16c/b24/92816cb249e7f76c4ed4e11c65f67475.svg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil ini mengkonfirmasi bahwa ini </font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sangat cepat, tetapi empat teknik terakhir lagi hanya berbeda sekitar 5%, sehingga sulit untuk memilih dari metode tercepat. </font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>pcg64_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus lebih lambat </font></font><code>mcg128_fast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena generator dasarnya adalah generator kongruen linier 128-bit (LCG) dan generator kongruen multiplikatif 128-bit (MCG, MCG). Terlepas dari kenyataan bahwa mereka bukan teknik tercepat dalam set ini, mereka </font></font><code>pcg64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masih 20% lebih cepat dari 64-bit Mersenne vortex. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi mungkin yang lebih penting, hasil ini juga menunjukkan bahwa jika Anda tidak membutuhkan output 64-bit, maka PRNG 64-bit biasanya lebih lambat daripada 32-bit.</font></font><br><br><h3>  Kesimpulan </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari tolok ukur kami, kami dapat melihat bahwa transisi dari PRNG yang digunakan secara standar (misalnya, vortex Mersenne 32-bit) ke PRNP yang lebih cepat mengurangi waktu eksekusi benchmark sebesar 45%. </font><font style="vertical-align: inherit;">Tetapi transisi dari metode standar untuk menemukan angka dalam interval ke metode tercepat kami memungkinkan kami untuk mengurangi waktu benchmark sekitar 66%; </font><font style="vertical-align: inherit;">dengan kata lain, hingga sepertiga dari waktu aslinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode tercepat (tanpa distorsi) adalah metode Lemira (dengan optimasi tambahan saya). </font><font style="vertical-align: inherit;">Ini dia:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = -range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) { t -= range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) t %= range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t) { x = rng(); m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menggunakan metode Lemira akan meningkatkan kinerja sebagian besar algoritma acak lebih dari bergerak dari mesin generasi cepat ke yang lebih cepat. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lampiran: Catatan Pengujian </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode semua tes diposting di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Secara total, saya menguji 23 metode untuk </font></font><code>bounded_rand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan 26 PRN yang berbeda (13 PRN 32-bit dan 13 64-bit), dalam dua kompiler (GCC 8 dan LLVM 6), yang memberi saya 26 * 23 * 2 = 1196 file yang dapat dieksekusi, masing-masing di mana itu dilakukan dengan 15 biji yang sama, yang memberikan 1196 * 15 = 17.940 tes berjalan unik, di mana masing-masing tiga tolok ukur digabungkan. Pada dasarnya, saya menjalankan tes pada mesin 48-core dengan empat prosesor 2,1 GHz Xeon E7-4830v3. Melakukan serangkaian uji penuh memerlukan waktu prosesor kurang dari sebulan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada akhirnya, kita kembali ke situasi dari pengantar artikel. Bayangkan bahwa Sasha digunakan </font></font><code>jsf32.STD-libc++</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan Juan -</font></font><code>mt19937.BIASED_FP_MULT_SCALE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dalam benchmark 3, yang terakhir membutuhkan waktu 69,6% lebih sedikit. </font><font style="vertical-align: inherit;">Artinya, waktu dari situasi fiksi ini didasarkan pada data dari kenyataan.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455702/">https://habr.com/ru/post/id455702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455692/index.html">ASZP: restyling atau teater dimulai dengan gantungan</a></li>
<li><a href="../id455694/index.html">Arsitektur Penagihan Generasi Selanjutnya: Transisi ke Tarantool</a></li>
<li><a href="../id455696/index.html">Keadaan elektronik masa depan. Bagian 2</a></li>
<li><a href="../id455698/index.html">Buku "Bagaimana JavaScript Bekerja"</a></li>
<li><a href="../id455700/index.html">4 trik yang membantu kami mengoptimalkan frontend</a></li>
<li><a href="../id455710/index.html">Mengapa kita di Leroy Merlin membutuhkan departemen pengembangan Rusia kita sendiri untuk 200 orang</a></li>
<li><a href="../id455714/index.html">Ekspor Formulir Google secara otomatis ke Notion menggunakan IFTTT dan Django</a></li>
<li><a href="../id455716/index.html">15 Praktik Terbaik untuk Menyebarkan Perangkat Lunak Business Intelligence</a></li>
<li><a href="../id455720/index.html">Bagaimana kami membangun UI untuk sistem iklan</a></li>
<li><a href="../id455722/index.html">Python menghabiskan banyak memori atau cara mengurangi ukuran objek?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>