<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🎤 🕴🏼 🤾🏿 Vorschlag: try - integrierte Fehlerprüfungsfunktion ▫️ 🤳🏼 👨‍👩‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zusammenfassung 


 Es wird ein neues try Konstrukt vorgeschlagen, das speziell entwickelt wurde, um Ausdrücke zu eliminieren, die üblicherweise mit d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vorschlag: try - integrierte Fehlerprüfungsfunktion</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472758/"><h2 id="kratkoe-soderzhanie">  Zusammenfassung </h2><br><p> Es wird ein neues <code>try</code> Konstrukt vorgeschlagen, das speziell entwickelt wurde, um Ausdrücke zu eliminieren, die üblicherweise mit der Fehlerbehandlung in Go verbunden sind.  Dies ist die einzige Änderung in der Sprache.  Autoren unterstützen die Verwendung von <code>defer</code> und Standardbibliotheksfunktionen, um Fehler anzureichern oder zu verpacken.  Diese kleine Erweiterung eignet sich für die meisten Szenarien, praktisch ohne die Sprache zu komplizieren. </p><br><p>  Das <code>try</code> Konstrukt ist leicht zu erklären, leicht zu implementieren, diese Funktionalität ist orthogonal zu anderen Sprachkonstrukten und vollständig abwärtskompatibel.  Es ist auch erweiterbar, wenn wir es in Zukunft wollen. </p><br><p>  Der Rest dieses Dokuments ist wie folgt organisiert: Nach einer kurzen Einführung geben wir eine Definition der integrierten Funktion und erläutern deren Verwendung in der Praxis.  Im Diskussionsteil werden alternative Vorschläge und das aktuelle Design besprochen.  Am Ende werden die Schlussfolgerungen und der Umsetzungsplan mit Beispielen sowie einem Abschnitt mit Fragen und Antworten gegeben. </p><a name="habracut"></a><br><h2 id="vvedenie">  Einleitung </h2><br><p>  Auf der letzten Gophercon-Konferenz in Denver stellten Mitglieder des Go-Teams (Russ Cox, Marcel van Lohuizen) einige neue Ideen vor, wie die mühsame manuelle Fehlerbehandlung in Go ( <a href="">Entwurfsentwurf</a> ) reduziert werden kann.  Seitdem haben wir sehr viel Feedback erhalten. </p><br><p>  Wie Russ Cox in seiner <a href="">Überprüfung des Problems</a> erklärte, ist es unser Ziel, die Fehlerbehandlung einfacher zu gestalten, indem wir die Menge an Code reduzieren, die speziell für die Fehlerprüfung verwendet wird.  Wir möchten auch das Schreiben von Fehlerbehandlungscode komfortabler gestalten und die Wahrscheinlichkeit erhöhen, dass Entwickler noch Zeit für die Korrektur der Fehlerbehandlung verwenden.  Gleichzeitig möchten wir den Fehlerbehandlungscode im Programmcode deutlich sichtbar lassen. </p><br><p>  Die im Entwurfsentwurf diskutierten Ideen konzentrieren sich auf die neue unäre <code>check</code> , die die explizite Überprüfung des Fehlerwerts vereinfacht, der aus einem Ausdruck (normalerweise einem Funktionsaufruf) erhalten wird, sowie auf die Deklaration von Fehlerbehandlungsroutinen ( <code>handle</code> ) und eine Reihe von Regeln, die diese beiden neuen Sprachkonstrukte verbinden. </p><br><p>  Die meisten Rückmeldungen konzentrierten sich auf die Details und die Komplexität des <code>handle</code> , und die Idee eines <code>check</code> Bedieners erwies sich als attraktiver.  Tatsächlich haben mehrere Mitglieder der Community die Idee eines <code>check</code> aufgegriffen und erweitert.  Hier sind einige Beiträge, die unserem Angebot am ähnlichsten sind: </p><br><ul><li>  Der erste schriftliche Vorschlag (uns bekannt), das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prüfkonstrukt</a> anstelle des Operators zu verwenden, wurde von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PeterRK</a> in seinem Beitrag <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schlüsselelemente der Fehlerbehandlung vorgeschlagen</a> </li><li>  Vor nicht allzu langer Zeit schlug <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Markus</a> zwei neue Schlüsselwörter vor: <code>guard</code> und <code>must</code> die Verwendung von <code>defer</code> , um Fehler in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="># 31442 zu verpacken</a> </li><li>  Auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pjebs</a> schlug ein <code>must</code> Konstrukt in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="># 32219 vor</a> </li></ul><br><p>  Der aktuelle Vorschlag war zwar im Detail unterschiedlich, stützte sich jedoch auf diese drei und im Allgemeinen auf die Rückmeldungen zu dem im letzten Jahr vorgeschlagenen Entwurfsentwurf. </p><br><p>  Um das Bild zu vervollständigen, möchten wir darauf hinweisen, dass auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Wiki-Seite</a> noch mehr Vorschläge zur Fehlerbehandlung zu finden sind.  Es ist auch erwähnenswert, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liam Breck</a> umfangreiche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anforderungen</a> an den Fehlerbehandlungsmechanismus gestellt hat. </p><br><p>  Schließlich haben wir nach der Veröffentlichung dieses Vorschlags erfahren, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ryan Hileman</a> <code>try</code> fünf Jahren mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">og rewriter-Tool implementiert</a> und erfolgreich in realen Projekten eingesetzt hat.  Siehe ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://news.ycombinator.com/item?id=20101417</a> ). </p><br><h2 id="vstroennaya-funkciya-try">  Eingebaute Try-Funktion </h2><br><h3 id="predlozhenie">  Angebot </h3><br><p>  Wir empfehlen, ein neues funktionsähnliches Sprachelement namens <code>try</code> hinzuzufügen, das mit einer Signatur aufgerufen wird </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(expr)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T1, T2, ... Tn)</span></span></span></span></code> </pre> <br><p>  <code>expr</code> bedeutet <code>expr</code> einen Ausdruck eines Eingabeparameters (normalerweise ein Funktionsaufruf), der n + 1 Werte der Typen <code>T1, T2, ... Tn</code> und <code>error</code> für den letzten Wert zurückgibt.  Wenn <code>expr</code> ein einzelner Wert ist (n = 0), muss dieser Wert vom Typ <code>error</code> und <code>try</code> gibt kein Ergebnis zurück.  Das Aufrufen von <code>try</code> mit einem Ausdruck, der nicht den letzten Wert des Typfehlers <code>error</code> führt zu einem Kompilierungsfehler. </p><br><p>  Das <code>try</code> Konstrukt kann nur in einer Funktion verwendet werden, die mindestens einen Wert zurückgibt und deren letzter Rückgabewert vom Typ <code>error</code> .  Das Aufrufen von <code>try</code> in anderen Kontexten führt zu einem Kompilierungsfehler. </p><br><p>  Rufen Sie <code>try</code> mit der Funktion <code>f()</code> wie im Beispiel auf </p><br><pre> <code class="go hljs">x1, x2, … xn = try(f())</code> </pre> <br><p>  führt zu folgendem Code: </p><br><pre> <code class="go hljs">t1, … tn, te := f() <span class="hljs-comment"><span class="hljs-comment">// t1, … tn,  ()   if te != nil { err = te //  te    error return //     } x1, … xn = t1, … tn //     //    </span></span></code> </pre><br><p>  Mit anderen Worten, wenn der letzte von <code>expr</code> zurückgegebene <code>expr</code> <code>nil</code> , geben Sie einfach die ersten n Werte zurück und entfernen Sie die letzte <code>nil</code> . </p><br><p>  Wenn der letzte von <code>expr</code> Wert nicht <code>nil</code> , dann: </p><br><ul><li>  Der <code>error</code> der einschließenden Funktion (im oben genannten Pseudocode <code>err</code> , obwohl dies ein beliebiger Bezeichner oder ein unbenannter Rückgabewert sein kann) empfängt den von <code>expr</code> zurückgegebenen <code>expr</code> </li><li>  Es gibt einen Ausgang aus der Hüllkurvenfunktion </li><li>  Wenn die umschließende Funktion zusätzliche Rückgabeparameter enthält, behalten diese Parameter die Werte bei, die vor dem <code>try</code> Aufruf in ihnen enthalten waren. </li><li>  Wenn die umschließende Funktion zusätzliche unbenannte Rückgabeparameter hat, werden die entsprechenden Nullwerte für sie zurückgegeben (was identisch ist mit dem Speichern ihrer ursprünglichen Nullwerte, mit denen sie initialisiert werden). </li></ul><br><p>  Wenn <code>try</code> wie im obigen Beispiel in mehreren Zuweisungen verwendet wird und ein Fehler ungleich Null (im Folgenden nicht null - ca. Per.) Festgestellt wird, wird die Zuweisung (nach Benutzervariablen) nicht ausgeführt, und keine der Variablen auf der linken Seite der Zuweisung ändert sich.  Das heißt, <code>try</code> verhält sich wie ein Funktionsaufruf: Die Ergebnisse sind nur verfügbar, wenn <code>try</code> die Kontrolle an den Aufrufer zurückgibt (im Gegensatz zum Fall mit einer Rückgabe von der umschließenden Funktion).  Wenn die Variablen auf der linken Seite der Zuweisung Rückgabeparameter sind, führt die Verwendung von <code>try</code> zu einem Verhalten, das sich von dem typischen Code unterscheidet, der jetzt auftritt.  Wenn beispielsweise <code>a,b, err</code> als Rückgabeparameter einer umschließenden Funktion bezeichnet werden, lautet der folgende Code: </p><br><pre> <code class="go hljs">a, b, err = f() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br><p>  weist den Variablen <code>a, b</code> und <code>err</code> immer Werte zu, unabhängig davon, ob der Aufruf von <code>f()</code> einen Fehler zurückgegeben hat oder nicht.  Gegenteilige Herausforderung </p><br><pre> <code class="go hljs">a, b = try(f())</code> </pre> <br><p>  Lassen Sie im Fehlerfall <code>a</code> und <code>b</code> unverändert.  Trotz der Tatsache, dass dies eine subtile Nuance ist, glauben wir, dass solche Fälle ziemlich selten sind.  Wenn ein bedingungsloses Zuweisungsverhalten erforderlich ist, müssen Sie <code>if</code> Ausdrücke weiterhin verwenden. </p><br><h3 id="ispolzovanie">  Verwenden Sie </h3><br><p>  Die Definition von <code>try</code> Ihnen explizit, wie Sie es verwenden: Viele <code>if</code> Ausdrücke, die nach Fehlern <code>try</code> können durch <code>try</code> .  Zum Beispiel: </p><br><pre> <code class="go hljs">f, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> …, err <span class="hljs-comment"><span class="hljs-comment">//       }</span></span></code> </pre> <br><p>  kann vereinfacht werden </p><br><pre> <code class="go hljs">f := try(os.Open(filename))</code> </pre> <br><p>  Wenn die aufrufende Funktion keinen Fehler <code>try</code> kann <code>try</code> nicht verwendet werden (siehe Abschnitt Diskussion).  In diesem Fall sollte der Fehler auf jeden Fall lokal verarbeitet werden (da keine Fehlerrückgabe erfolgt), und in diesem Fall bleibt der geeignete Mechanismus zur Überprüfung auf Fehler bestehen. </p><br><p>  Generell ist es unser Ziel, nicht alle möglichen Fehlerprüfungen durch eine <code>try</code> zu ersetzen.  Code, der eine andere Semantik erfordert, kann und sollte weiterhin verwendet werden, <code>if</code> Ausdrücke und explizite Variablen mit Fehlerwerten. </p><br><h3 id="testirovanie-i-try">  Testen und versuchen </h3><br><p>  Bei einem unserer früheren Versuche, eine Spezifikation zu schreiben (siehe Abschnitt Design-Iteration unten), wurde <code>try</code> entwickelt, um in Panik zu geraten, wenn ein Fehler auftritt, wenn er innerhalb einer Funktion ohne Rückgabefehler verwendet wird.  Dies ermöglichte die Verwendung von <code>try</code> in Unit-Tests basierend auf dem <code>testing</code> der Standardbibliothek. </p><br><p>  Als eine der Optionen ist es möglich, Testfunktionen mit Signaturen im Testpaket zu verwenden </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestXxx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*testing.T)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkXxx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*testing.B)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><p>  um die Verwendung von <code>try</code> in Tests zu ermöglichen.  Eine Testfunktion, die einen Fehler ungleich Null zurückgibt, ruft implizit <code>t.Fatal(err)</code> oder <code>b.Fatal(err)</code> .  Dies ist eine kleine Bibliotheksänderung, bei der je nach Kontext unterschiedliche Verhaltensweisen (Rückkehr oder Panik) für den <code>try</code> vermieden werden müssen. </p><br><p>  Einer der Nachteile dieses Ansatzes besteht darin, dass <code>t.Fatal</code> und <code>b.Fatal</code> die Zeilennummer, auf die der Test fiel, nicht zurückgeben können.  Ein weiterer Nachteil ist, dass wir auch die Untertests irgendwie ändern müssen.  Die Lösung für dieses Problem ist eine offene Frage;  In diesem Dokument werden keine spezifischen Änderungen am <code>testing</code> . </p><br><p>  Siehe auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="># 21111</a> , in dem vorgeschlagen wird, Beispielfunktionen zu erlauben, einen Fehler zurückzugeben. </p><br><h3 id="obrabotka-oshibok">  Fehlerbehandlung </h3><br><p>  Der ursprüngliche <a href="">Entwurfsentwurf</a> befasste sich hauptsächlich mit der Sprachunterstützung für Umbruch- oder Erweiterungsfehler.  Der Entwurf schlug ein neues Schlüsselworthandle und eine neue Methode zum <em>Deklarieren von Fehlerbehandlungsroutinen vor</em> .  Dieses neue Sprachkonstrukt zog aufgrund der nicht trivialen Semantik Probleme wie Fliegen auf sich, insbesondere wenn man seine Auswirkungen auf den Ausführungsfluss berücksichtigt.  Insbesondere die <code>handle</code> hat sich kläglich mit der <code>defer</code> gekreuzt, wodurch die neue Sprachfunktion nicht orthogonal zu allem anderen war. </p><br><p>  Dieser Vorschlag reduziert den ursprünglichen Entwurfsentwurf auf das Wesentliche.  Wenn eine Anreicherung oder ein Fehlerumbruch erforderlich ist, gibt es zwei Ansätze: Anhängen an <code>if err != nil { return err}</code> oder "Deklarieren" eines Fehlerbehandlers innerhalb des <code>defer</code> Ausdrucks: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      -   err = … // /  } }()</span></span></code> </pre> <br><p>  In diesem Beispiel ist <code>err</code> der Name des Rückgabeparameters vom Typ <code>error</code> einschließenden Funktion. </p><br><p>  In der Praxis stellen wir uns solche Hilfsfunktionen vor wie </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleErrorf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err *error, format </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, args ...</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { *err = fmt.Errorf(format + <span class="hljs-string"><span class="hljs-string">": %v"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(args, *err)...) } }</code> </pre><br><p>  oder ähnliches.  Das <code>fmt</code> Paket kann für solche Helfer zu einem natürlichen Ort werden (es bietet bereits <code>fmt.Errorf</code> ).  Mithilfe von Hilfsprogrammen wird die Definition eines Fehlerbehandlers in vielen Fällen auf eine einzelne Zeile reduziert.  Um beispielsweise den Fehler aus der Funktion "Kopieren" zu bereichern, können Sie schreiben </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> fmt.HandleErrorf(&amp;err, <span class="hljs-string"><span class="hljs-string">"copy %s %s"</span></span>, src, dst)</code> </pre><br><p>  Wenn <code>fmt.HandleErrorf</code> implizit Fehlerinformationen hinzufügt, ist eine solche Konstruktion ziemlich einfach zu lesen und hat den Vorteil, dass sie implementiert werden kann, ohne neue Elemente der Sprachsyntax hinzuzufügen. </p><br><p>  Der Hauptnachteil dieses Ansatzes besteht darin, dass der zurückgegebene Fehlerparameter benannt werden muss, was möglicherweise zu einer weniger genauen API führt (siehe FAQ zu diesem Thema).  Wir glauben, dass wir uns daran gewöhnen werden, wenn der geeignete Schreibstil für Code festgelegt ist. </p><br><h3 id="effektivnost-defer">  Effizienzverschiebung </h3><br><p>  Ein wichtiger Gesichtspunkt bei der Verwendung von <code>defer</code> als Fehlerbehandlungsroutine ist die Effizienz.  Der <code>defer</code> Ausdruck wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">langsam angesehen</a> .  Wir möchten nicht zwischen effizientem Code und guter Fehlerbehandlung wählen.  Unabhängig von diesem Vorschlag diskutierten die Go-Laufzeit- und Compilerteams alternative Implementierungsmethoden und wir glauben, dass wir typische Methoden zur Verwendung von Defer anwenden können, um Fehler zu behandeln, deren Effizienz mit dem vorhandenen „manuellen“ Code vergleichbar ist.  Wir hoffen, in Go 1.14 eine schnellere Implementierung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Defer</a> hinzufügen zu können (siehe auch Ticket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL 171158</a> , was der erste Schritt in diese Richtung ist). </p><br><h3 id="specialnye-sluchai-go-tryf-defer-tryf">  Sonderfälle <code>go try(f), defer try(f)</code> </h3><br><p>  Das <code>try</code> Konstrukt sieht aus wie eine Funktion, und aus diesem Grund wird erwartet, dass es überall dort verwendet werden kann, wo ein Funktionsaufruf akzeptabel ist.  Wenn der <code>try</code> Aufruf jedoch in der <code>go</code> Anweisung verwendet wird, werden die Dinge kompliziert: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> try(f())</code> </pre><br><p>  Hier wird <code>f()</code> ausgeführt, wenn der go-Ausdruck in der aktuellen Goroutine ausgeführt wird. Die Ergebnisse des Aufrufs von <code>f</code> werden als zu <code>try</code> Argumente übergeben, die in der neuen Goroutine beginnen.  Wenn <code>f</code> einen Fehler ungleich Null zurückgibt, wird erwartet, dass <code>try</code> von der umschließenden Funktion zurückkehrt.  Es gibt jedoch keine Funktion (und es gibt keinen Rückgabeparameter vom Typ <code>error</code> ), weil  Der Code wird in einer separaten Goroutine ausgeführt.  Aus diesem Grund schlagen wir vor, <code>try</code> in einem <code>go</code> Ausdruck zu deaktivieren. </p><br><p>  Situation mit </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> try(f())</code> </pre><br><p>  sieht ähnlich aus, aber hier bedeutet die Semantik von <code>defer</code> , dass die Ausführung von <code>try</code> verzögert wird, bis sie von der umschließenden Funktion zurückkehrt.  Wie zuvor wird <code>f()</code> ausgewertet, wenn der Aufschub <code>defer</code> , und seine Ergebnisse werden an den zurückgestellten <code>try</code> . </p><br><p>  <code>try</code> überprüft den Fehler <code>f()</code> erst im allerletzten Moment zurückgegeben wird, bevor er von der umschließenden Funktion zurückkehrt.  Ohne das <code>try</code> ändern, kann ein solcher Fehler einen anderen Fehlerwert überschreiben, den die umschließende Funktion zurückzugeben versucht.  Dies verwirrt bestenfalls, im schlimmsten Fall führt es zu Fehlern.  Aus diesem Grund schlagen wir vor, dass Sie den Aufruf von <code>try</code> in der <code>defer</code> Anweisung verbieten.  Wir können diese Entscheidung jederzeit überdenken, wenn eine solche Semantik angemessen angewendet wird. </p><br><p>  Schließlich kann <code>try</code> wie die anderen integrierten Konstrukte nur als Aufruf verwendet werden.  Es kann nicht als Wertfunktion oder in einem Variablenzuweisungsausdruck wie in <code>f := try</code> (genau wie <code>f := print</code> und <code>f := new</code> verboten sind). </p><br><h2 id="obsuzhdenie">  Die Diskussion </h2><br><h3 id="iteracii-dizayna">  Design-Iterationen </h3><br><p>  Das Folgende ist eine kurze Diskussion früherer Entwürfe, die zum aktuellen Minimalvorschlag führten.  Wir hoffen, dass dies Aufschluss über ausgewählte Designentscheidungen gibt. </p><br><p>  Unsere erste Iteration dieses Satzes wurde von zwei Ideen aus dem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Schlüsselelemente der Fehlerbehandlung“</a> inspiriert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> nämlich der Verwendung der integrierten Funktion anstelle des Operators und der üblichen Go-Funktion zur Behandlung von Fehlern anstelle des neuen Sprachkonstrukts.  Im Gegensatz zu dieser Veröffentlichung hatte unser Fehlerbehandler einen festen <code>func(error) error</code> Signaturfunktion <code>func(error) error</code> , um die Sache zu vereinfachen.  Ein Fehlerbehandler wird von der <code>try</code> Funktion aufgerufen <code>try</code> wenn ein Fehler aufgetreten ist, bevor <code>try</code> die umschließende Funktion beendet.  Hier ist ein Beispiel: </p><br><pre> <code class="go hljs">handler := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"foo failed: %v"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">//   } f := try(os.Open(filename), handler) //     </span></span></code> </pre><br><p>  Dieser Ansatz ermöglichte zwar die Definition effektiver benutzerdefinierter Fehlerbehandlungsroutinen, warf jedoch auch viele Fragen auf, die offensichtlich nicht die richtigen Antworten hatten: Was sollte passieren, wenn nil an die Bearbeiter übergeben wird?  Sollten Sie <code>try</code> Panik <code>try</code> geraten, oder dies als Mangel an Handler betrachten?  Was ist, wenn der Handler mit einem Fehler ungleich Null aufgerufen wird und dann ein Null-Ergebnis zurückgibt?  Bedeutet dies, dass der Fehler "abgebrochen" wird?  Oder sollte eine umschließende Funktion einen leeren Fehler zurückgeben?  Es gab auch Zweifel, dass die optionale Übertragung eines Fehlerbehandlers Entwickler dazu ermutigen würde, Fehler zu ignorieren, anstatt sie zu korrigieren.  Es wäre auch einfach, überall die richtige Fehlerbehandlung durchzuführen, aber eine einmalige Verwendung von <code>try</code> überspringen.  Und dergleichen. </p><br><p>  In der nächsten Iteration wurde die Möglichkeit, einen benutzerdefinierten Fehlerbehandler zu übergeben, zugunsten der Verwendung von <code>defer</code> zum Umschließen von Fehlern entfernt.  Dies schien ein besserer Ansatz zu sein, da dadurch Fehlerbehandler im Quellcode viel deutlicher wahrgenommen wurden.  Dieser Schritt beseitigte auch alle Probleme bezüglich der optionalen Übertragung von Handlerfunktionen, verlangte jedoch, dass die zurückgegebenen Parameter mit dem <code>error</code> benannt werden, wenn ein Zugriff erforderlich war (wir entschieden, dass dies normal war).  Um <code>try</code> nicht nur für Funktionen nützlich zu machen, die Fehler zurückgeben, war es außerdem erforderlich, das Verhalten von <code>try</code> kontextsensitiv zu machen: Wenn <code>try</code> auf Paketebene verwendet wurde oder wenn es in einer Funktion aufgerufen wurde, die keinen Fehler zurückgibt, wird <code>try</code> automatisch in Panik versetzt, wenn ein Fehler festgestellt wurde.  (Und als Nebeneffekt wurde aufgrund dieser Eigenschaft das Sprachkonstrukt in diesem Satz als <code>must</code> statt <code>try</code> .) Das kontextsensitive Verhalten von <code>try</code> (oder <code>must</code> ) schien natürlich und auch sehr nützlich: Es würde viele benutzerdefinierte Funktionen eliminieren, die in Ausdrücken verwendet werden Paketvariablen initialisieren.  Es eröffnete auch die Möglichkeit, <code>try</code> in Unit-Tests mit dem Testpaket zu verwenden. </p><br><p>  Das kontextsensitive Verhalten von <code>try</code> war jedoch mit Fehlern behaftet: Beispielsweise konnte sich das Verhalten einer Funktion, die <code>try</code> verwendet, beim Hinzufügen oder Entfernen eines Rückgabefehlers zur Funktionssignatur leise ändern (Panik oder nicht).  Dies schien eine zu gefährliche Eigenschaft.  Die naheliegende Lösung bestand darin, die <code>try</code> Funktionalität in zwei separate <code>must</code> and- <code>try</code> Funktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufzuteilen</a> (sehr ähnlich der in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="># 31442 vorgeschlagenen</a> ).  Dies würde jedoch zwei integrierte Funktionen erfordern, während nur <code>try</code> direkt mit einer besseren Unterstützung der Fehlerbehandlung zusammenhängt. </p><br><p>  Daher haben wir in der aktuellen Iteration beschlossen, anstelle der zweiten integrierten Funktion die duale Semantik von <code>try</code> zu entfernen und daher die Verwendung nur in Funktionen zuzulassen, die einen Fehler zurückgeben. </p><br><h3 id="osobennosti-predlozhennogo-dizayna">  Merkmale des vorgeschlagenen Entwurfs </h3><br><p>  Dieser Vorschlag ist recht kurz und scheint im Vergleich zum letztjährigen Entwurf einen Schritt zurück zu sein.  Wir glauben, dass die ausgewählten Lösungen gerechtfertigt sind: </p><br><ul><li><p>  Das Wichtigste zuerst: <code>try</code> hat genau die gleiche Semantik wie die im Original vorgeschlagene <code>check</code> Anweisung ohne <code>handle</code> .  Dies bestätigt die Treue des ursprünglichen Entwurfs in einem der wichtigen Aspekte. </p><br></li><li><p>  Die Auswahl einer integrierten Funktion anstelle von Operatoren hat mehrere Vorteile.  Es ist kein neues Schlüsselwort wie <code>check</code> erforderlich, wodurch das Design nicht mit vorhandenen Parsern kompatibel wäre.  Es ist auch nicht erforderlich, die Syntax von Ausdrücken mit einem neuen Operator zu erweitern.  Das Hinzufügen einer neuen integrierten Funktion ist relativ trivial und völlig orthogonal zu anderen Merkmalen der Sprache. </p><br></li><li><p>  Die Verwendung einer Inline-Funktion anstelle eines Operators erfordert die Verwendung von Klammern.  Wir sollten <code>try(f())</code> anstelle von <code>try f()</code> schreiben.  Dies ist der (kleine) Preis, den wir für die Abwärtskompatibilität mit vorhandenen Parsern zahlen müssen.  Dies macht das Design jedoch auch mit zukünftigen Versionen kompatibel: Wenn wir auf dem Weg entscheiden, dass das Übergeben einer Fehlerbehandlungsfunktion in irgendeiner Form oder das Hinzufügen eines zusätzlichen Parameters zu diesem Zweck eine gute Idee ist, ist das Hinzufügen eines zusätzlichen Arguments zum <code>try</code> Aufruf trivial. </p><br></li><li><p>  Wie sich herausstellte, hat die Notwendigkeit, Klammern zu schreiben, seine Vorteile.  In komplexeren Ausdrücken mit mehreren <code>try</code> verbessern Klammern die Lesbarkeit, indem sie sich nicht mehr mit der Priorität von Operatoren befassen müssen, wie in den folgenden Beispielen: </p><br></li></ul><br><pre> <code class="go hljs">info := try(try(os.Open(file)).Stat()) <span class="hljs-comment"><span class="hljs-comment">//   try info := try (try os.Open(file)).Stat() //  try   info := try (try (os.Open(file)).Stat()) //  try  </span></span></code> </pre><br><p>     <code>try</code> ,      :       <code>try</code> , ..   <code>try</code>   (receiver)  <code>.Stat</code> (  <code>os.Open</code> ). </p><br><p>     <code>try</code> ,        :    <code>os.Open(file)</code> ..       <code>try</code> (  ,   <code>try</code>    <code>os</code> ,   ,   <code>try</code>      <code>try</code> ). </p><br><p>           , ..      . </p><br><ul><li>           .   ,          .   ,      ,      ,     . </li></ul><br><h2 id="vyvody">  Schlussfolgerungen </h2><br><p>       <a href="">  </a>         .    ,      .            <code>defer</code> ,           . </p><br><p>  Go         -  ,         . ,   Go     <code>append</code> .     <code>append</code>         ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>     .    ,       .  ,        <code>try</code> . </p><br><p>          ,     ,   Go      : <code>panic</code>  <code>recover</code> .   <code>error</code>   <code>try</code>   . </p><br><p>  , <code>try</code>     ,     ,      —      —   ,     .        Go: </p><br><ul><li>       </li><li>     , <code>try</code>       </li><li>      </li><li>    - </li></ul><br><p>        ,    ,       .     <code>if</code> -. </p><br><h2 id="realizaciya">  Implementierung </h2><br><p>   : </p><br><ul><li>   Go. </li><li>     <code>try</code> . ,            .      . </li><li>  <code>go/types</code>  <code>try</code> .   . </li><li>    <code>gccgo</code> . ( ,  ). </li><li>      . </li></ul><br><p>    -  ,     . ,        .           . </p><br><p> Robert Griesemer    <code>go/types</code> ,     () <code>cmd/compile</code> .    ,         Go 1.14,  1  2019. </p><br><p> , Ian Lance Taylor    <code>gccgo</code> ,    . </p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Go 2,  !"</a> ,                . </p><br><p> 1 ,    ,      ,    Go 1.14  . </p><br><p>  Beispiele </p><br><p>  <code>CopyFile</code>     : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src, dst </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } }() r := try(os.Open(src)) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> r.Close() w := try(os.Create(dst)) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { w.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { os.Remove(dst) <span class="hljs-comment"><span class="hljs-comment">//    “try”    } }() try(io.Copy(w, r)) try(w.Close()) return nil }</span></span></code> </pre><br><p>   ,    " ",  <code>defer</code>  : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> fmt.HandleErrorf(&amp;err, <span class="hljs-string"><span class="hljs-string">"copy %s %s"</span></span>, src, dst)</code> </pre><br><p>           (  <code>defer</code> -),        <code>defer</code>     ,    . </p><br><p>  <code>printSum</code>          </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { x := try(strconv.Atoi(a)) y := try(strconv.Atoi(b)) fmt.Println(<span class="hljs-string"><span class="hljs-string">"result:"</span></span>, x + y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><p>   : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { fmt.Println( <span class="hljs-string"><span class="hljs-string">"result:"</span></span>, try(strconv.Atoi(a)) + try(strconv.Atoi(b)), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><p>  <code>main</code>  <a href="">   </a>      : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">localMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { hex := try(ioutil.ReadAll(os.Stdin)) data := try(parseHexdump(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(hex))) try(os.Stdout.Write(data)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := localMain(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }</code> </pre><br><p> -   <code>try</code>      ,        : </p><br><pre> <code class="plaintext hljs">n, err := src.Read(buf) if err == io.EOF { break } try(err)</code> </pre><br><h2 id="voprosy-i-otvety">  Fragen und Antworten </h2><br><p> ,     . </p><br><p> <strong>:        ?</strong> </p><br><p> :        <code>check</code>  <code>handle</code> ,     .  ,  <code>handle</code>          <code>defer</code> ,   <code>handle</code>   . </p><br><p> <strong>:  try   ?</strong> </p><br><p> :    <code>try</code>     Go     .       -  ,           .          ,     .        ,     "  ".  <code>try</code>     , ..          . </p><br><p> <strong>:  <code>try</code>  try?</strong> </p><br><p> :    ,  <code>check</code> , <code>must</code>  <code>do</code> .   <code>try</code>            ,           . <code>try</code>       <code>check</code> (,        ),  -       .         .         <code>must</code>          ; <code>try</code> —  . ,  Rust  Swift   <code>try</code>       (   ).         . </p><br><p> <strong>:      <code>?</code>   Rust?</strong> </p><br><p> : Go      ;  ,           Go (        ;   -   ).         ,     <code>?</code> ,      .   , ,   ,     (package, interface, if, append, recover, ...),  ,        (struct, var, func, int, len, image,  ..). Rust   <code>?</code>     <code>try</code>   —      Go,    ,   (   )   . ,  <code>?</code>      .    ,   ,     (,   ..)  .       .       ,   . </p><br><p> <strong>:       ( error)  ,  defer   ,   go doc.    ?</strong> </p><br><p> :     <code>go doc</code>   ,       -   ( <code>_</code> ) ,         . ,  <code>func f() (_ A, _ B, err error)</code>    <code>go doc</code>  <code>func f() (A, B, error)</code> .      ,   ,     ,      .  ,         ,     . ,   ,    ,       -,       (deferred) .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jonathan Geddes</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   <code>try()</code>        . </p><br><p> <strong>:     defer    ?</strong> </p><br><p> :    <code>defer</code>          . ,  ,       defer         "" . .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL 171758</a> ,     defer   30%. </p><br><p> <strong>:           ?</strong> </p><br><p> :  ,        . ,         ( ,    ),      .     <code>defer</code>              ,     .   <code>defer</code> -   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://golang.org/issue/29934</a> (   Go 2),    . </p><br><p> <strong>:  ,   try,    error.  ,       ?</strong> </p><br><p> :           <code>error</code> (  )   ,  ,     <code>nil</code> .           <code>try</code> . (      ,  .     - ). </p><br><p> <strong>:    Go  ,     try   ?</strong> </p><br><p> :  <code>try</code>     ,   <code>try</code> .    <code>super return</code> -, <code>try</code>      <code>Go</code>        . <code>try</code>       .     <em></em>  . </p><br><p> <strong>:     try   ,         .   ?</strong> </p><br><p> : <code>try</code>        ;       ,     .       <code>try</code>    ( ),     .   , <code>if</code>   . </p><br><p> <strong>:   ,       .    try,    defer    .   ?</strong> </p><br><p> :         ,       .     . </p><br><p> <strong>:  <code>try</code>     (  <code>catch</code> )?</strong> </p><br><p> : <code>try</code> —   ("")      ,  ,      (    )   . <code>try</code>   ;       .        .     "" .     ,        .  , <code>try</code> —      .   ,  ,       <code>throw</code>  <code>try-catch</code>     Go. ,         (,    ),     (   )     ,      .    ""      <code>try-catch</code> ,       . ,    ,      .  Go    .     <code>panic</code> ,       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472758/">https://habr.com/ru/post/de472758/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472746/index.html">Terminalserver für Admin; Keine einzige SSH-Lücke</a></li>
<li><a href="../de472748/index.html">Semantischer Browser oder Leben ohne Websites</a></li>
<li><a href="../de472750/index.html">OK, brauche ich wirklich Kubernetes?</a></li>
<li><a href="../de472752/index.html">CSE: Kubernetes für alle in vCloud</a></li>
<li><a href="../de472754/index.html">Wie man in einem Monat Englisch spricht. 9 einfache und bewährte Schritte</a></li>
<li><a href="../de472760/index.html">Reduzieren Sie die Rechenzeit von einigen Jahren auf Minuten. Quantenmaschinelles Lernen verstehen</a></li>
<li><a href="../de472762/index.html">Technische Analyse des checkm8-Exploits</a></li>
<li><a href="../de472766/index.html">Parametrierung aus Datei in py.test</a></li>
<li><a href="../de472768/index.html">So stellen Sie ein, entlassen und kehren vom Management zur Entwicklung zurück: Video von Badoo Techleads Meetup # 5</a></li>
<li><a href="../de472770/index.html">Schnittstellenorganisation in Unity mit UI Canvas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>