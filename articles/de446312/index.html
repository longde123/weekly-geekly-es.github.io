<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëãüèº ‚úäüèø üèîÔ∏è Externe Interrupts im x86-System. Teil 1. Unterbrechen Sie die Controller-Evolution ü§òüèº üìú üò±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel wird der Interrupt-√úbermittlungsprozess von externen Ger√§ten im x86-System beschrieben. Es versucht Fragen zu beantworten wie: 



-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Externe Interrupts im x86-System. Teil 1. Unterbrechen Sie die Controller-Evolution</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446312/">  In diesem Artikel wird der Interrupt-√úbermittlungsprozess von externen Ger√§ten im x86-System beschrieben.  Es versucht Fragen zu beantworten wie: <br><br><ul><li>  Was ist Bild und wof√ºr ist es? </li><li>  Was ist APIC und wof√ºr ist es?  Was ist der Zweck von LAPIC und I / O APIC? </li><li>  Was sind die Unterschiede zwischen APIC, xAPIC und x2APIC? </li><li>  Was ist MSI?  Was sind die Unterschiede zwischen MSI und MSI-X? </li><li>  Welche Rolle spielen die Tabellen $ PIR, MPtable und ACPI? </li></ul><br>  Wenn Sie die Antwort auf eine dieser Fragen wissen m√∂chten oder einfach nur etwas √ºber die Entwicklung von Interrupt-Controllern wissen m√∂chten, sind Sie herzlich willkommen. <br><a name="habracut"></a><br><h3>  Einf√ºhrung </h3><br>  F√ºr diejenigen, die nicht wissen, was ein Interrupt ist, hier ein Zitat aus Wikipedia: <br><blockquote> Bei der Systemprogrammierung ist ein Interrupt ein Signal an den Prozessor, das von Hardware oder Software ausgegeben wird und ein Ereignis anzeigt, das sofortige Aufmerksamkeit erfordert.  Ein Interrupt warnt den Prozessor vor einem Zustand mit hoher Priorit√§t, der die Unterbrechung des aktuellen Codes erfordert, den der Prozessor ausf√ºhrt.  Der Prozessor reagiert, indem er seine aktuellen Aktivit√§ten unterbricht, seinen Status speichert und eine Funktion ausf√ºhrt, die als Interrupt-Handler (oder Interrupt-Serviceroutine ISR) bezeichnet wird, um das Ereignis zu behandeln.  Diese Unterbrechung ist vor√ºbergehend, und nach Abschluss des Interrupt-Handlers nimmt der Prozessor die normalen Aktivit√§ten wieder auf. <br><br>  Es gibt zwei Arten von Interrupts: Hardware-Interrupts und Software-Interrupts (Softirqs): <br><br><ul><li>  Hardware-Interrupts werden von Ger√§ten verwendet, um zu kommunizieren, dass sie vom Betriebssystem beachtet werden m√ºssen.  Intern werden Hardware-Interrupts mithilfe elektronischer Warnsignale implementiert, die von einem externen Ger√§t, das entweder Teil des Computers selbst ist, wie z. B. einem Festplattencontroller oder einem externen Peripherieger√§t, an den Prozessor gesendet werden.  Wenn Sie beispielsweise eine Taste auf der Tastatur dr√ºcken oder die Maus bewegen, werden Hardware-Interrupts ausgel√∂st, die dazu f√ºhren, dass der Prozessor den Tastenanschlag oder die Mausposition liest.  Das Einleiten eines Hardware-Interrupts wird als Interrupt-Anforderung (IRQ) bezeichnet. </li><li>  Ein Software-Interrupt wird entweder durch einen Ausnahmezustand im Prozessor selbst oder durch einen speziellen Befehl im Befehlssatz verursacht, der bei seiner Ausf√ºhrung einen Interrupt verursacht.  Ersteres wird h√§ufig als Trap oder Ausnahme bezeichnet und wird f√ºr Fehler oder Ereignisse verwendet, die w√§hrend der Programmausf√ºhrung auftreten und so au√üergew√∂hnlich sind, dass sie nicht im Programm selbst behandelt werden k√∂nnen.  Beispielsweise wird eine Ausnahme zum Teilen durch Null ausgel√∂st, wenn der arithmetischen Logikeinheit des Prozessors befohlen wird, eine Zahl durch Null zu teilen, da dieser Befehl ein Fehler ist und unm√∂glich ist. </li></ul></blockquote><br>  Dieser Artikel befasst sich mit Hardware / externen Interrupts IRQ. <br><br>  Was ist der Zweck von Interrupts?  Beispielsweise m√∂chten wir eine Aktion mit einem eingehenden Paket von der Netzwerkkarte ausf√ºhren, sobald das Paket eintrifft.  Wenn Sie die Netzwerkkarte nicht st√§ndig fragen m√∂chten: "Ist mein Paket angekommen?"  und verschwenden Sie Ihre Prozessorzeit, k√∂nnen Sie externe Hardware-Interrupt-IRQ verwenden.  Die Interrupt-Leitung eines Ger√§ts sollte mit der INTR-Leitung der CPU verbunden sein. Nach dem Empfang jedes Pakets sendet die Netzwerkkarte ein Signal √ºber diese Leitung.  Die CPU erkennt dieses Signal und wei√ü, dass die Netzwerkkarte Informationen daf√ºr enth√§lt.  Erst danach liest die CPU das eingehende Paket. <br><br>  Aber was sollen wir tun, wenn es viele externe Ger√§te gibt?  Es w√§re sehr unproduktiv, f√ºr alle eine Menge INTR-Pins auf der CPU zu erstellen. <br><br><img src="https://habrastorage.org/webt/vg/3q/3v/vg3q3v7kx8vjttp43xo99o8pccs.png"><br><br>  Um dieses Problem zu l√∂sen, wurde ein spezieller Chip erfunden - ein Interrupt-Controller. <br><br><h3>  Pic </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wiki</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">osdev</a> ) <br><br>  Der erste Interrupt-Controller-Chip war der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel 8259 PIC</a> .  Es hatte 8 Eingangsleitungen (IRQ0-7) und 1 Ausgangsleitung (die den Interrupt-Controller mit der INTR-Leitung der CPU verbindet).  Wenn eines der Ger√§te auf seinen Eingangsleitungen unterbrochen wird, sendet der 8259 ein Signal √ºber die INTR-Leitung.  Danach wei√ü die CPU, dass ein Ger√§t seine sofortige Aufmerksamkeit erfordert, und der Prozessor fragt den PIC, welche der 8 Eingangsleitungen (IRQx) die Quelle dieses Interrupts war.  Diese Abfrage hat einen gewissen Overhead, aber jetzt haben wir 8 Interrupt-Leitungen anstelle von 1. <br><br><img src="https://habrastorage.org/webt/le/yf/6e/leyf6enogyzp6flpijo2d0x1w9g.png"><br><br>  Bald waren 8 Zeilen nicht mehr genug.  Um die Gesamtzahl der Interrupt-Leitungen zu erh√∂hen, wurden zwei 8259-Controller (Master und Slave) in einer Kaskade (Dual PIC) angeschlossen. <br><br>  IRQs von 0 bis 7 werden mit dem ersten Intel 8259 PIC (Master) und IRQs von 8 bis 15 mit dem zweiten Intel 8259 PIC (Master) verarbeitet.  Nur der Master ist an die CPU angeschlossen und kann √ºber die eingehenden Interrupts signalisieren.  Wenn auf den Leitungen 8-15 ein Interrupt auftritt, signalisiert der zweite PIC (Slave) dem Master auf der Leitung IRQ2 dies, und danach signalisiert der Master der CPU.  Dieser kaskadierte Interrupt entfernt 1 der 16 Leitungen, macht jedoch insgesamt 15 Interrupts f√ºr alle externen Ger√§te. <br><br><img src="https://habrastorage.org/webt/xj/yn/dh/xjyndhabujjwz0alrbx831zfzt8.png"><br><br>  Dieses Schema wurde von der Community √ºbernommen, und wenn jemand √ºber PIC (Programm Interrupt Controller) spricht, meint er dieses Dual-PIC-System.  Nach einiger Zeit wurden die 8259-Controller verbessert und erhielten einen neuen Namen: 8259A.  Bei diesen Controllern war das DUAL PIC-System im Chipsatz enthalten.  Zu einer Zeit, als der Hauptbus f√ºr die Verbindung externer Ger√§te die ISA war, war dieses System ausreichend.  Es war nur erforderlich, dass verschiedene Ger√§te nicht mit derselben IRQ-Leitung verbunden waren, da ISA-Interrupts nicht gemeinsam genutzt werden k√∂nnen. <br><br>  Die Ger√§te-Interrupt-Zuordnung war so ziemlich Standard: <br><br>  Beispiel (von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ): <br>  IRQ 0 - Systemtimer <br>  IRQ 1 - Tastaturcontroller <br>  IRQ 2 - Kaskade (Interrupt vom Slave-Controller) <br>  IRQ 3 - serielle Schnittstelle COM2 <br>  IRQ 4 - serielle Schnittstelle COM1 <br>  IRQ 5 - Parallelport 2 und 3 oder Soundkarte <br>  IRQ 6 - Diskettenregler <br>  IRQ 7 - Parallelport 1 <br>  IRQ 8 - RTC-Timer <br>  IRQ 9 - ACPI <br>  IRQ 10 - offen / SCSI / NIC <br>  IRQ 11 - offen / SCSI / NIC <br>  IRQ 12 - Mauscontroller <br>  IRQ 13 - Mathe-Co-Prozessor <br>  IRQ 14 - ATA-Kanal 1 <br>  IRQ 15 - ATA-Kanal 2 <br><br>  Die Konfiguration und Arbeit mit 8259 Chips erfolgt √ºber E / A-Ports: <br><div class="scrollable-table"><table><tbody><tr><th>  Chip </th><th>  Registrieren </th><th>  E / A-Port </th></tr><tr><td>  Meisterbild </td><td>  Befehl </td><td>  0x0020 </td></tr><tr><td>  Meisterbild </td><td>  Daten </td><td>  0x0021 </td></tr><tr><td>  Sklavenbild </td><td>  Befehl </td><td>  0x00A0 </td></tr><tr><td>  Sklavenbild </td><td>  Daten </td><td>  0x00A1 </td></tr></tbody></table></div><br>  Die vollst√§ndige Dokumentation des 8259A finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Der PCI-Bus ersetzte sp√§ter den ISA-Bus.  Leider begann die Anzahl der Ger√§te die Anzahl von 15 zu √ºberschreiten. Anstelle des statischen ISA-Busses k√∂nnen auch Ger√§te im PCI-Bus dynamisch zum System hinzugef√ºgt werden, was m√∂glicherweise zu noch mehr Problemen f√ºhren kann.  Gl√ºcklicherweise k√∂nnen Interrupts im PCI-Bus gemeinsam genutzt werden, sodass viele Ger√§te an eine Interrupt-Leitung IRQ angeschlossen werden k√∂nnen.  Um das Problem des Fehlens von Interrupt-Leitungen zu l√∂sen, wurde beschlossen, Interrupts von allen PCI-Ger√§ten zu PIRQ-Leitungen zu gruppieren (Programmable Interrupt Request). <br><br>  Angenommen, wir haben 4 freie Interrupt-Leitungen am PIC-Controller und 20 PCI-Ger√§te.  Wir k√∂nnen Interrupts von 5 Ger√§ten zu einer PIRQx-Leitung kombinieren und diese PIRQx-Leitungen mit dem PIC-Controller verbinden.  In diesem Fall muss der Prozessor bei einem Interrupt auf einer der PIRQx-Leitungen alle an diese Leitung angeschlossenen Ger√§te nach dem Interrupt fragen, um zu wissen, wer daf√ºr verantwortlich ist, aber am Ende l√∂st er das Problem.  Das Ger√§t, das PCI-Interrupt-Leitungen mit PIRQ-Leitungen verbindet, wird h√§ufig als PIR-Router bezeichnet. <br><br>  Bei dieser Methode muss sichergestellt werden, dass PIRQx-Leitungen keine Verbindung zu Leitungen mit ISA-Interrupts herstellen (da dies zu Konflikten f√ºhrt) und dass PIRQx-Leitungen ausgeglichen sind (je mehr Ger√§te wir mit einer Leitung verbinden, desto mehr Ger√§te ben√∂tigt die CPU abfragen, wann √ºberpr√ºft werden muss, welches Ger√§t f√ºr den Interrupt verantwortlich ist). <br><br><img src="https://habrastorage.org/webt/u_/jr/u9/u_jru9pemdeda2xvvbqihvgtp3y.png"><br><br>  <b>Hinweis</b> : Auf dem Bild ist die Zuordnung von PCI-Ger√§t -&gt; PIR abstrakt dargestellt, da sie im realen Fall etwas komplizierter ist.  In der realen Welt verf√ºgt jedes PCI-Ger√§t √ºber 4 Interrupt-Leitungen (INTA, INTB, INTC, INTD) und bis zu 8 Funktionen, wobei jede Funktion nur einen dieser INTx-Interrupts haben kann.  Welche INTx-Leitung von jeder Funktion verwendet wird, h√§ngt von der Chipsatzkonfiguration ab. <br><br>  Funktionen sind von Natur aus separate logische Bl√∂cke.  Beispielsweise kann ein PCI-Ger√§t eine Smbus-Controller-Funktion, eine SATA-Controller-Funktion und eine LPC-Bridge-Funktion haben.  Aus Sicht eines Betriebssystems (OS) ist jede Funktion wie ein separates Ger√§t mit einem eigenen Konfigurationsbereich (PCI-Konfiguration). <br><br>  Informationen √ºber ein PIC-Controller-Interrupt-Routing werden vom BIOS mit Hilfe der Tabelle $ PIR und √ºber die Register 3Ch (INT_LN Interrupt Line (R / W)) und 3Dh (INT_PN Interrupt Pin (RO)) von an das Betriebssystem gesendet den PCI-Konfigurationsraum f√ºr jede Funktion. <br><br>  Eine Spezifikation f√ºr die $ PIR-Tabelle wurde k√ºrzlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der Microsoft-Website ver√∂ffentlicht</a> , ist jedoch derzeit nicht verf√ºgbar.  Es ist m√∂glich, den Inhalt der Tabelle anhand der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PCI-BIOS-Spezifikation</a> [4.2.2.  Holen Sie sich PCI Interrupt Routing Options] oder von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> (der letzte Link ist auf Russisch, aber Sie k√∂nnen versuchen, "PCI IRQ Routing Table Specification" zu googeln) <br><br><h3>  Apic </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Osdev</a> ) <br><br>  Die letzte Methode funktionierte, bis Multiprozessorsysteme eintrafen.  Von Natur aus kann der PIC nur Interrupts an eine CPU senden, und in einem Multiprozessorsystem ist es erw√ºnscht, CPUs auf ausgeglichene Weise zu laden.  Die L√∂sung f√ºr dieses Problem war die neue APIC-Schnittstelle (Advanced PIC). <br><br>  F√ºr jeden Prozessor wurde ein spezieller Controller namens LAPIC (Local APIC) sowie der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">E / A-APIC-</a> Controller zum Weiterleiten von Interrupts von externen Ger√§ten hinzugef√ºgt.  Alle diese Steuerungen sind in einem gemeinsamen Bus mit dem Namen APIC zusammengefasst (beachten Sie, dass moderne Systeme f√ºr diese Aufgabe einen Standardsystembus anstelle eines separaten APIC-Busses verwenden). <br><br>  Wenn ein externer Interrupt am E / A-APIC-Eingang eintrifft, sendet die Steuerung eine Interrupt-Nachricht an den LAPIC einer der System-CPUs.  Auf diese Weise hilft der E / A-APIC-Controller, die Interrupt-Last zwischen den Prozessoren auszugleichen. <br><br>  Der erste APIC-Chip war der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">82489DX</a> , ein separater Chip, der einen verbundenen LAPIC- und E / A-APIC in sich hatte.  F√ºr ein Doppelprozessorsystem wurden drei solcher Chips ben√∂tigt: zwei f√ºr LAPIC und einer f√ºr I / O APIC.  Sp√§ter wurde die LAPIC-Funktionalit√§t direkt in die Prozessoren integriert, und der E / A-APIC-Teil wurde vom 82093AA-Chip getrennt. <br><br>  Der E / A-APIC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">82093AA</a> hatte 24 Eing√§nge und die APIC-Architektur konnte bis zu 16 CPUs unterst√ºtzen.  Die Interrupts 0-15 wurden f√ºr alte ISA-Interrupts zur Kompatibilit√§t mit √§lteren Systemen belassen, und die Interrupts 16-23 waren f√ºr alle PCI-Ger√§te vorgesehen.  Mit dieser Abgrenzung k√∂nnten alle Konflikte zwischen ISA- und PCI-Interrupts leicht vermieden werden.  Mit der erh√∂hten Anzahl freier Interrupt-Leitungen wurde es auch m√∂glich, die Anzahl der PIRQx-Leitungen zu erh√∂hen. <br><br><img src="https://habrastorage.org/webt/mc/ra/hj/mcrahjn-owk9qrcmyiixcmhomcq.png"><br><br>  Die E / A-APIC- und LAPIC-Programmierung erfolgt mit Hilfe von MMIO.  LAPIC-Register werden normalerweise an der Adresse 0xFEE00000 und E / A-APIC-Register an der Adresse 0xFE0000 abgelegt, obwohl es m√∂glich ist, sie neu zu konfigurieren. <br><br>  Wie im PIC-Fall wurden separate Chips am Anfang sp√§ter Teil des Chipsatzes. <br><br>  Die APIC-Architektur wurde sp√§ter modernisiert und ihre neue Variante hie√ü xAPIC (x - erweitert).  Bei voller Abw√§rtskompatibilit√§t wurde die Gesamtzahl der m√∂glichen CPUs im System auf 256 erh√∂ht. <br><br>  Der n√§chste Schritt in der Architekturentwicklung wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">x2APIC genannt</a> .  Die Anzahl der m√∂glichen CPUs im System wurde auf 2 ^ 32 erh√∂ht.  Diese Controller k√∂nnen in einem Abw√§rtskompatibilit√§tsmodus mit xAPIC oder im neuen x2APIC-Modus arbeiten.  In diesem neuen Modus erfolgt die Controller-Programmierung nicht √ºber MMIO, sondern √ºber MSR-Register (die viel schneller sind).  Laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Link</a> ist f√ºr diesen Modus IOMMU-Unterst√ºtzung erforderlich. <br><br>  Es ist zu beachten, dass es m√∂glich ist, mehrere E / A-APIC-Controller im System zu haben.  Zum Beispiel einer f√ºr 24 Interrupts in einer Southbridge und der andere f√ºr 32 Interrupts in einer Northbridge.  Im Kontext von I / O APIC werden Interrupts normalerweise als GSI (Global System Interrupt) bezeichnet.  Das oben genannte System hat also GSIs 0-55. <br><br>  Wie k√∂nnen wir feststellen, ob eine CPU √ºber ein internes LAPIC verf√ºgt und welche APIC-Architektur sie unterst√ºtzt?  Es ist m√∂glich, diese Fragen zu beantworten, indem Bit-Flags von der CPUID √ºberpr√ºft werden. <br>  Damit das Betriebssystem LAPIC und I / O APIC erkennen kann, sollte das BIOS Informationen √ºber diese entweder √ºber eine MPtable (alte Methode) oder √ºber eine ACPI-Tabelle (in diesem Fall eine MADT-Tabelle) anzeigen.  Neben allgemeinen Informationen sollten sowohl die MPtable als auch die ACPI (in diesem Fall eine DSDT-Tabelle) Informationen zum Interrupt-Routing enthalten.  Dies bedeutet Informationen dar√ºber, welches Ger√§t welche Interrupt-Leitung verwendet (√§hnlich der $ PIR-Tabelle). <br><br>  Sie k√∂nnen √ºber die MPtable in der offiziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20121002210153/">Spezifikation</a> lesen.  Fr√ºher war die Spezifikation auf der Intel-Website, aber derzeit ist sie nur in einer Archivversion zu finden.  Die ACPI-Spezifikation finden Sie auf der UEFI-Website (aktuelle Version ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.2</a> ).  Es ist zu beachten, dass mit ACPI das Interrupt-Routing f√ºr Systeme ohne APIC deklariert werden kann (anstatt eine separate $ PIR-Tabelle bereitzustellen). <br><br><h3>  Msi </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiki</a> ) <br><br>  Die letzte Variante von APIC war gut, aber nicht ohne Nachteile.  Alle Interrupt-Leitungen von Ger√§ten machten das System sehr kompliziert und erh√∂hten somit die Fehlerwahrscheinlichkeit.  Der PCI-Express-Bus ersetzte den PCI-Bus, wodurch alle Interrupt-Systeme vollst√§ndig vereinfacht wurden.  Es gibt √ºberhaupt keine Interrupt-Leitungen.  Aus Gr√ºnden der Abw√§rtskompatibilit√§t werden Interrupt-Signale (INTx #) mit einer separaten Art von Nachrichten emuliert.  Bei PCI-Interrupt-Leitungen wurde die Verbindung mit physischen Dr√§hten hergestellt.  Bei PCI-Express-Interrupt-Leitungen ist eine Verbindung logisch und wird √ºber PCI-Express-Bridges hergestellt.  Diese Unterst√ºtzung √§lterer INTx-Interrupts besteht jedoch nur aus Gr√ºnden der Abw√§rtskompatibilit√§t mit dem PCI-Bus.  PCI Express f√ºhrt eine v√∂llig neue Methode zur Interrupt-Zustellung ein - MSI (Message Signaled Interrupts).  Bei diesem Verfahren signalisiert ein Ger√§t den Interrupt einfach durch Schreiben an eine spezielle Stelle im MMIO-Bereich der CPUs LAPIC. <br><br><img src="https://habrastorage.org/webt/8z/qw/7h/8zqw7him-vupzm_wi5glkqtr1ja.png"><br><br>  Fr√ºher konnte ein einzelnes PCI-Ger√§t (dh alle seine Funktionen) nur 4 Interrupts haben, jetzt konnten jedoch bis zu 32 Interrupts adressiert werden. <br><br>  Bei MSI gibt es keine gemeinsame Nutzung von Interrupt-Leitungen: Jeder Interrupt entspricht nat√ºrlich seinem Ger√§t. <br><br>  MSI-Interrupts l√∂sen auch ein weiteres Problem.  Stellen wir uns zum Beispiel eine Situation vor, in der ein Ger√§t eine Speicherschreibtransaktion ausf√ºhrt und √ºber den Interrupt signalisieren m√∂chte, dass es abgeschlossen ist.  Eine Schreibtransaktion auf dem Bus kann jedoch w√§hrend der √úbertragung verz√∂gert werden (und das Ger√§t konnte nichts davon wissen).  In diesem Fall kommt das Signal √ºber den Interrupt zuerst an die CPU, sodass der Prozessor noch nicht g√ºltige Daten liest.  Wenn MSI verwendet wird, werden Informationen √ºber das MSI auf die gleiche Weise wie Datennachrichten √ºbertragen und k√∂nnen daher nicht fr√ºher eingehen. <br><br>  Es ist zu beachten, dass MSI-Interrupts ohne LAPIC nicht funktionieren k√∂nnen, MSIs jedoch E / A-APIC ersetzen k√∂nnen (eine weitere Vereinfachung des Designs). <br><br>  Nach einiger Zeit wurde die MSI-Methode auf MSI-X erweitert.  Jetzt kann jedes Ger√§t bis zu 2048 Interrupts haben.  Es ist jetzt auch m√∂glich anzugeben, welche CPU welchen Interrupt verarbeiten soll.  Dies kann f√ºr Hochlastger√§te wie z. B. Netzwerkkarten sehr n√ºtzlich sein. <br><br>  F√ºr die MSI-Unterst√ºtzung ist keine separate BIOS-Tabelle erforderlich.  Das Ger√§t sollte jedoch seine MSI-Unterst√ºtzung √ºber eine der Funktionen in seinem PCI-Konfigurationsbereich anzeigen.  Au√üerdem sollte ein Ger√§tetreiber die erforderliche Unterst√ºtzung f√ºr die Arbeit mit dem MSI enthalten. <br><br><h3>  Fazit </h3><br>  In diesem Artikel haben wir Informationen zur Interrupt-Controller-Entwicklung untersucht und allgemeines theoretisches Wissen √ºber die Interrupt-√úbermittlung von externen Ger√§ten im x86-System erhalten. <br><br>  Im n√§chsten Teil werden wir √ºben und sehen, wie jeder der oben genannten Interrupt-Controller unter Linux aktiviert wird. <br><br>  Im dritten Teil werden wir uns den Coreboot-Code ansehen und herausfinden, welche Einstellungen im Chipsatz f√ºr ein korrektes Interrupt-Routing erforderlich sind. <br><br><h4>  Links: </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Interrupt Controller (Sachen in der Mitte)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was machen die verschiedenen Interrupts in PCIe?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reduzierung der Interrupt-Latenz durch die Verwendung von Interrupts mit Nachrichtensignalen</a> </li></ul><br><h4>  Anerkannte Segmente </h4><br>  Besonderer Dank geht an Jacob Garber von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Coreboot-</a> Community, der mir bei dieser Artikel√ºbersetzung geholfen hat. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446312/">https://habr.com/ru/post/de446312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446300/index.html">Wie koordiniert man den Flug der Sonde in die Stratosph√§re (was wir beim Start in der Praxis erleben werden)?</a></li>
<li><a href="../de446302/index.html">9 Zitate aus dem Habraseminar 2019 f√ºr Blogger, Unternehmer und HR</a></li>
<li><a href="../de446304/index.html">Physikalisch nicht klonbare Funktionen: Schutz der Elektronik vor illegalem Kopieren</a></li>
<li><a href="../de446306/index.html">Atomkriege der fernen Vergangenheit?</a></li>
<li><a href="../de446308/index.html">Lebt die Rekrutierung von Empfehlungen in der IT?</a></li>
<li><a href="../de446316/index.html">Nur Platz! Ein riesiges St√ºck Titan in 6,5 Tagen</a></li>
<li><a href="../de446320/index.html">Wie der 3D-Scanner es erm√∂glichte, die vollst√§ndige Steuerbaugruppe der Br√ºcke aufzugeben</a></li>
<li><a href="../de446322/index.html">Kryptographie in Java. Keytool-Dienstprogramm</a></li>
<li><a href="../de446324/index.html">Navigation in DataGrip mit Yandex.Navigator</a></li>
<li><a href="../de446326/index.html">Verkehrsprobleme l√∂sen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>