<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ì üíØ üîô Escribir una extensi√≥n de navegador segura üôåüèΩ üßò üñçÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A diferencia de la arquitectura com√∫n de "cliente-servidor", las aplicaciones descentralizadas se caracterizan por: 


- No es necesario almacenar una...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribir una extensi√≥n de navegador segura</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/451796/"><p><img src="https://habrastorage.org/webt/nt/7v/c8/nt7vc8scuypj0o2ngtj1n6fqjlw.png"></p><br><p>  A diferencia de la arquitectura com√∫n de "cliente-servidor", las aplicaciones descentralizadas se caracterizan por: </p><br><ul><li>  No es necesario almacenar una base de datos con nombres de usuario y contrase√±as.  La informaci√≥n de acceso es almacenada exclusivamente por los propios usuarios, y la confirmaci√≥n de su autenticidad ocurre a nivel de protocolo. </li><li>  No es necesario usar un servidor.  La l√≥gica de la aplicaci√≥n se puede ejecutar en una red blockchain, donde es posible almacenar la cantidad requerida de datos. </li></ul><br><p>  Hay 2 repositorios relativamente seguros para las claves de usuario: billeteras de hardware y extensiones de navegador.  La mayor√≠a de las billeteras de hardware son lo m√°s seguras posible, pero son dif√≠ciles de usar y est√°n lejos de ser gratuitas, pero las extensiones del navegador son la combinaci√≥n perfecta de seguridad y facilidad de uso, y tambi√©n pueden ser completamente gratuitas para los usuarios finales. </p><br><p>  Dado todo esto, quer√≠amos hacer la extensi√≥n m√°s segura, lo que simplifica el desarrollo de aplicaciones descentralizadas, proporcionando una API simple para trabajar con transacciones y firmas. <br>  Le contaremos sobre esta experiencia a continuaci√≥n. </p><br><p>  <strong>El art√≠culo proporcionar√° instrucciones paso a paso sobre c√≥mo escribir una extensi√≥n del navegador, con ejemplos de c√≥digo y capturas de pantalla.</strong>  Puede encontrar todo el c√≥digo en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio</a> .  Cada confirmaci√≥n corresponde l√≥gicamente a una secci√≥n de este art√≠culo. </p><a name="habracut"></a><br><h2 id="kratkaya-istoriya-brauzernyh-rasshireniy">  Una breve historia de las extensiones del navegador </h2><br><p>  Las extensiones del navegador han existido durante bastante tiempo.  En Internet Explorer, aparecieron en 1999, en Firefox, en 2004.  Sin embargo, durante mucho tiempo no hubo un est√°ndar √∫nico para las extensiones. </p><br><p>  Podemos decir que apareci√≥ junto con extensiones en la cuarta versi√≥n de Google Chrome.  Por supuesto, no hab√≠a una especificaci√≥n entonces, pero fue la API de Chrome la que se convirti√≥ en su base: habiendo conquistado una gran parte del mercado de navegadores y teniendo una tienda de aplicaciones incorporada, Chrome en realidad estableci√≥ el est√°ndar para las extensiones del navegador. </p><br><p>  Mozilla ten√≠a su propio est√°ndar, pero, al ver la popularidad de las extensiones para Chrome, la compa√±√≠a decidi√≥ hacer una API compatible.  En 2015, por iniciativa de Mozilla, se cre√≥ un grupo especial dentro del Consorcio World Wide Web (W3C) para trabajar en las especificaciones de las extensiones entre navegadores. </p><br><p> Basado en las extensiones API ya existentes para Chrome.  El trabajo fue apoyado por Microsoft (Google se neg√≥ a participar en el desarrollo del est√°ndar) y, como resultado, apareci√≥ un borrador de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificaci√≥n</a> . </p><br><p>  Formalmente, la especificaci√≥n es compatible con Edge, Firefox y Opera (tenga en cuenta que Chrome no est√° en esta lista).  Pero, de hecho, el est√°ndar es en gran medida compatible con Chrome, ya que en realidad est√° escrito en funci√≥n de sus extensiones.  Lea m√°s sobre la API de WebExtensions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><h2 id="struktura-rasshireniya">  Estructura de extensi√≥n </h2><br><p>  El √∫nico archivo que se requiere para la extensi√≥n es el manifiesto (manifest.json).  √âl es el "punto de entrada" a la extensi√≥n. </p><br><h3 id="manifest">  Manifiesto </h3><br><p>  Por especificaci√≥n, el archivo de manifiesto es un archivo JSON v√°lido.  Una descripci√≥n completa de las claves de manifiesto con informaci√≥n sobre qu√© claves son compatibles en qu√© navegador se puede encontrar <a href="">aqu√≠</a> . </p><br><p>  Las claves que no est√°n en la especificaci√≥n "pueden" ignorarse (tanto Chrome como Firefox informan errores, pero las extensiones contin√∫an funcionando). </p><br><p>  Y me gustar√≠a llamar la atenci√≥n sobre algunos puntos. </p><br><ol><li>  <strong>fondo</strong> : un objeto que incluye los siguientes campos: <br><ol><li>  <strong>scripts</strong> : una serie de scripts que se ejecutar√°n en el contexto de fondo (hablaremos de esto un poco m√°s adelante); </li><li>  <strong>p√°gina</strong> : en lugar de los scripts que se ejecutar√°n en una p√°gina en blanco, puede especificar html con contenido.  En este caso, el campo de secuencia de comandos se ignorar√° y las secuencias de comandos deber√°n insertarse en la p√°gina con el contenido; </li><li>  <strong>persistente</strong> : un indicador binario, si no se especifica, el navegador "matar√°" el proceso en segundo plano cuando considere que no est√° haciendo nada, y se reiniciar√° si es necesario.  De lo contrario, la p√°gina se descargar√° solo cuando se cierre el navegador.  No es compatible con Firefox. </li></ol></li><li>  <strong>content_scripts</strong> : una matriz de objetos que le permite cargar diferentes scripts en diferentes p√°ginas web.  Cada objeto contiene los siguientes campos importantes: <br><ol><li>  <strong>coincidencias</strong> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">patr√≥n de URL</a> mediante el cual se determina si se incluir√° o no un script de contenido espec√≠fico. </li><li>  <strong>js</strong> : una lista de scripts que se cargar√°n en esta coincidencia; </li><li> <strong>exclude_matches</strong> : excluye las URL de <code>match</code> campo de coincidencia que coincide con este campo. </li></ol></li><li>  <strong>page_action</strong> : de hecho, es el objeto el responsable del icono que aparece junto a la barra de direcciones en el navegador y la interacci√≥n con √©l.  Tambi√©n le permite mostrar una ventana emergente, que se configura con HTML, CSS y JS. <br><ol><li>  <strong>default_popup</strong> : la ruta al archivo HTML con una interfaz emergente puede contener CSS y JS. </li></ol></li><li>  <strong>permisos</strong> : una matriz para administrar los derechos de extensi√≥n.  Hay 3 tipos de derechos que se describen en detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠.</a> </li><li>  <strong>web_accessible_resources</strong> : recursos de extensi√≥n que una p√°gina web puede solicitar, por ejemplo, im√°genes, JS, CSS, archivos HTML. </li><li>  <strong>externally_connectable</strong> : aqu√≠ puede especificar expl√≠citamente los ID de otras extensiones y los dominios de las p√°ginas web desde las que puede conectarse.  Un dominio puede ser de segundo nivel o superior.  No funciona en Firefox. </li></ol><br><h2 id="kontekst-vypolneniya">  Contexto de ejecuci√≥n </h2><br><p>  La extensi√≥n tiene tres contextos de ejecuci√≥n de c√≥digo, es decir, la aplicaci√≥n consta de tres partes con diferentes niveles de acceso a la API del navegador. </p><br><h3 id="extension-context">  Contexto de extensi√≥n </h3><br><p>  La mayor√≠a de las API est√°n disponibles aqu√≠.  En este contexto, "vivir": </p><br><ol><li>  <strong>P√°gina de fondo</strong> : parte ‚Äúbackend‚Äù de la extensi√≥n.  El archivo se indica en el manifiesto mediante la tecla "fondo". </li><li>  <strong>P√°gina</strong> emergente: p√°gina emergente que aparece cuando hace clic en el icono de extensi√≥n.  En el manifiesto, <code>browser_action</code> -&gt; <code>default_popup</code> . </li><li>  <strong>P√°gina personalizada: p√°gina de</strong> extensi√≥n, "viva" en una pesta√±a separada del formulario <code>chrome-extension://&lt;id_&gt;/customPage.html</code> . </li></ol><br><p>  Este contexto existe independientemente de las ventanas y pesta√±as del navegador.  <strong>La p√°gina de</strong> fondo existe en una sola copia y siempre funciona (la excepci√≥n es la p√°gina del evento, cuando el script de fondo se inicia en un evento y muere despu√©s de ejecutarse).  <strong>La p√°gina</strong> emergente existe cuando la ventana emergente est√° abierta, y la <strong>p√°gina personalizada</strong> , mientras la pesta√±a con ella est√° abierta.  No hay acceso a otras pesta√±as y sus contenidos desde este contexto. </p><br><h3 id="content-script-context">  Contexto del gui√≥n de contenido </h3><br><p>  El archivo de secuencia de comandos de contenido se inicia junto con cada pesta√±a del navegador.  Tiene acceso a parte de la API de extensi√≥n y al √°rbol DOM de la p√°gina web.  Los guiones de contenido son responsables de interactuar con la p√°gina.  Las extensiones que manipulan el √°rbol DOM lo hacen en secuencias de comandos de contenido, por ejemplo, bloqueadores de anuncios o traductores.  Adem√°s, el script de contenido puede comunicarse con la p√°gina a trav√©s de <code>postMessage</code> est√°ndar. </p><br><h3 id="web-page-context">  Contexto de la p√°gina web </h3><br><p>  Esta es en realidad la p√°gina web en s√≠.  No tiene nada que ver con la extensi√≥n y no tiene acceso all√≠, a menos que el dominio de esta p√°gina no se especifique expl√≠citamente en el manifiesto (m√°s sobre esto a continuaci√≥n). </p><br><h2 id="obmen-soobscheniyami">  Mensajer√≠a </h2><br><p>  Las diferentes partes de la aplicaci√≥n deben intercambiar mensajes entre s√≠.  Para hacer esto, hay una API <code>runtime.sendMessage</code> para enviar un mensaje de <code>background</code> y <code>tabs.sendMessage</code> para enviar un mensaje a una p√°gina (secuencia de comandos de contenido, ventana emergente o p√°gina web si hay una <code>runtime.sendMessage</code> <code>externally_connectable</code> ).  El siguiente es un ejemplo al acceder a la API de Chrome. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     JSON   const msg = {a: 'foo', b: 'bar'}; // extensionId   ,      ''  ( ui   ) chrome.runtime.sendMessage(extensionId, msg); //    chrome.runtime.onMessage.addListener((msg) =&gt; console.log(msg)) //       id chrome.tabs.sendMessage(tabId, msg) //      id , ,   chrome.tabs.query( {currentWindow: true, active : true}, function(tabArray){ tabArray.forEach(tab =&gt; console.log(tab.id)) } )</span></span></code> </pre> <br><p>  Para una comunicaci√≥n completa, puede crear conexiones a trav√©s de <code>runtime.connect</code> .  En respuesta, obtenemos <code>runtime.Port</code> , en el que, mientras est√° abierto, puede enviar cualquier cantidad de mensajes.  En el lado del cliente, por ejemplo, <code>contentscript</code> , se ve as√≠: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   extensionId        .    const port = chrome.runtime.connect({name: "knockknock"}); port.postMessage({joke: "Knock knock"}); port.onMessage.addListener(function(msg) { if (msg.question === "Who's there?") port.postMessage({answer: "Madame"}); else if (msg.question === "Madame who?") port.postMessage({answer: "Madame... Bovary"});</span></span></code> </pre><br><p>  Servidor o fondo: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    '' .  , popup    chrome.runtime.onConnect.addListener(function(port) { console.assert(port.name === "knockknock"); port.onMessage.addListener(function(msg) { if (msg.joke === "Knock knock") port.postMessage({question: "Who's there?"}); else if (msg.answer === "Madame") port.postMessage({question: "Madame who?"}); else if (msg.answer === "Madame... Bovary") port.postMessage({question: "I don't get it."}); }); }); //     .     ,      chrome.runtime.onConnectExternal.addListener(function(port) { ... });</span></span></code> </pre> <br><p>  Tambi√©n hay un evento <code>onDisconnect</code> y un m√©todo de <code>disconnect</code> . </p><br><h2 id="shema-prilozheniya">  Esquema de la aplicaci√≥n </h2><br><p>  Hagamos una extensi√≥n de navegador que almacene claves privadas, proporcione acceso a informaci√≥n p√∫blica (la direcci√≥n, la clave p√∫blica se comunica con la p√°gina y permite que aplicaciones de terceros soliciten una firma de transacci√≥n. </p><br><h2 id="razrabotka-prilozheniya">  Desarrollo de aplicaciones </h2><br><p>  Nuestra aplicaci√≥n debe interactuar con el usuario y proporcionar una p√°gina API para los m√©todos de llamada (por ejemplo, para firmar transacciones).  No funcionar√° solo con el <code>contentscript</code> , ya que solo tiene acceso al DOM, pero no a la p√°gina JS.  No podemos conectarnos a trav√©s de <code>runtime.connect</code> , porque la API es necesaria en todos los dominios y solo se pueden especificar algunos espec√≠ficos en el manifiesto.  Como resultado, el esquema se ver√° as√≠: </p><br><p><img src="https://habrastorage.org/webt/fa/b3/gx/fab3gxq823kwybj9yk_kv8wlogy.png"></p><br><p>  Habr√° otro script: <code>inpage</code> , que inyectaremos en la p√°gina.  Se ejecutar√° en su contexto y proporcionar√° una API para trabajar con la extensi√≥n. </p><br><h3 id="nachalo">  Inicio </h3><br><p>  Todo el c√≥digo de extensi√≥n del navegador est√° disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> .  En el proceso de descripci√≥n, habr√° enlaces a confirmaciones. </p><br><p>  Comencemos con el manifiesto: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-comment"><span class="hljs-comment">//   , .        chrome://extensions/?id=&lt;id &gt; "name": "Signer", "description": "Extension demo", "version": "0.0.1", "manifest_version": 2, // ,     background,     "background": { "scripts": ["background.js"] }, //  html   popup "browser_action": { "default_title": "My Extension", "default_popup": "popup.html" }, //  . //    :   url   http  https   // contenscript context   contentscript.js.         "content_scripts": [ { "matches": [ "http://*/*", "https://*/*" ], "js": [ "contentscript.js" ], "run_at": "document_start", "all_frames": true } ], //    localStorage  idle api "permissions": [ "storage", // "unlimitedStorage", //"clipboardWrite", "idle" //"activeTab", //"webRequest", //"notifications", //"tabs" ], //   ,       .      fetche'   xhr "web_accessible_resources": ["inpage.js"] }</span></span></code> </pre> <br><p>  Cree background.js, popup.js, inpage.js y contentscript.js vac√≠os.  Agregue popup.html, y nuestra aplicaci√≥n ya se puede descargar en Google Chrome y aseg√∫rese de que funcione. </p><br><p>  Para verificar esto, puede tomar el c√≥digo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desde aqu√≠</a> .  Adem√°s de lo que hicimos, el enlace est√° configurado para construir el proyecto usando webpack.  Para agregar una aplicaci√≥n al navegador, en chrome: // extensiones debe seleccionar cargar desempaquetado y la carpeta con la extensi√≥n correspondiente, en nuestro caso, dist. </p><br><p><img src="https://habrastorage.org/webt/ws/ng/qz/wsngqza3qdcjtxycbcwk4awpfqm.png"></p><br><p>  Ahora nuestra extensi√≥n est√° instalada y funcionando.  Puede ejecutar herramientas de desarrollador para diferentes contextos de la siguiente manera: </p><br><p>  ventana emergente -&gt; </p><br><p><img src="https://habrastorage.org/webt/m3/pr/9d/m3pr9dww991nvn9jsfwj8mvndqq.png"></p><br><p>  El acceso a la consola del script de contenido se realiza a trav√©s de la consola de la p√°gina en la que se inicia. <img src="https://habrastorage.org/webt/3t/gn/6v/3tgn6vao3ilxdwyz9zxraegz9vo.png"></p><br><p>  <strong>Mensajer√≠a</strong> </p><br><p>  Entonces, necesitamos establecer dos canales de comunicaci√≥n: inpage &lt;-&gt; background y popup &lt;-&gt; background.  Puede, por supuesto, simplemente enviar mensajes al puerto e inventar su protocolo, pero prefiero el enfoque que vi en el proyecto de metamask de c√≥digo abierto. </p><br><p>  Esta es una extensi√≥n del navegador para trabajar con la red Ethereum.  En √©l, diferentes partes de la aplicaci√≥n se comunican a trav√©s de RPC utilizando la biblioteca dnode.  Le permite organizar un intercambio de manera r√°pida y conveniente si proporciona un flujo de nodejs como transporte (es decir, un objeto que implementa la misma interfaz): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"dnode/browser"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//           ,         // C // API,     const dnode = Dnode({ hello: (cb) =&gt; cb(null, "world") }) // ,     dnode.  nodejs .     'readable-stream' connectionStream.pipe(dnode).pipe(connectionStream) //  const dnodeClient = Dnode() //         API    //    world dnodeClient.once('remote', remote =&gt; { remote.hello(((err, value) =&gt; console.log(value))) })</span></span></code> </pre> <br><p>  Ahora crearemos una clase de aplicaci√≥n.  Crear√° objetos API para ventanas emergentes y p√°ginas web, y tambi√©n crear√° dnode para ellos: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dnode/browser'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   API  ui popupApi(){ return { hello: cb =&gt; cb(null, 'world') } } //   API   pageApi(){ return { hello: cb =&gt; cb(null, 'world') } } //  popup ui connectPopup(connectionStream){ const api = this.popupApi(); const dnode = Dnode(api); connectionStream.pipe(dnode).pipe(connectionStream); dnode.on('remote', (remote) =&gt; { console.log(remote) }) } //   connectPage(connectionStream, origin){ const api = this.popupApi(); const dnode = Dnode(api); connectionStream.pipe(dnode).pipe(connectionStream); dnode.on('remote', (remote) =&gt; { console.log(origin); console.log(remote) }) } }</span></span></code> </pre> <br><p>  De aqu√≠ en adelante, en lugar del objeto global de Chrome, usamos extensi√≥nApi, que se refiere a Chrome en el navegador de Google y al navegador en otros.  Esto se hace para la compatibilidad entre navegadores, pero simplemente chrome.runtime.connect podr√≠a usarse en el marco de este art√≠culo. </p><br><p>  Cree la instancia de la aplicaci√≥n en el script de fondo: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignerApp(); <span class="hljs-comment"><span class="hljs-comment">// onConnect    '' (contentscript, popup,   ) extensionApi.runtime.onConnect.addListener(connectRemote); function connectRemote(remotePort) { const processName = remotePort.name; const portStream = new PortStream(remotePort); //      ,          ,   ui if (processName === 'contentscript'){ const origin = remotePort.sender.url app.connectPage(portStream, origin) }else{ app.connectPopup(portStream) } }</span></span></code> </pre> <br><p>  Dado que dnode funciona con transmisiones y obtenemos el puerto, se necesita una clase de adaptador.  Se realiza utilizando la biblioteca de flujo legible, que implementa flujos de nodejs en el navegador: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Duplex} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'readable-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortStream</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Duplex</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(port){ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>({<span class="hljs-attr"><span class="hljs-attr">objectMode</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._port = port; port.onMessage.addListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); port.onDisconnect.addListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onDisconnect.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) } _onMessage(msg) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Buffer.isBuffer(msg)) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> msg._isBuffer; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Buffer(msg); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(msg) } } _onDisconnect() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.destroy() } _read(){} _write(msg, encoding, cb) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Buffer.isBuffer(msg)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = msg.toJSON(); data._isBuffer = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._port.postMessage(data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._port.postMessage(msg) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cb(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'PortStream - disconnected'</span></span>)) } cb() } }</code> </pre> <br><p>  Ahora cree una conexi√≥n en la interfaz de usuario: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dnode/browser'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; setupUi().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupUi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,       ,   stream,  dnode const backgroundPort = extensionApi.runtime.connect({name: 'popup'}); const connectionStream = new PortStream(backgroundPort); const dnode = Dnode(); connectionStream.pipe(dnode).pipe(connectionStream); const background = await new Promise(resolve =&gt; { dnode.once('remote', api =&gt; { resolve(api) }) }); //   API    if (DEV_MODE){ global.background = background; } }</span></span></code> </pre> <br><p>  Luego creamos una conexi√≥n en el script de contenido: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PostMessageStream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'post-message-stream'</span></span>; setupConnection(); injectScript(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backgroundPort = extensionApi.runtime.connect({<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'contentscript'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backgroundStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PortStream(backgroundPort); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pageStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PostMessageStream({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'content'</span></span>, <span class="hljs-attr"><span class="hljs-attr">target</span></span>: <span class="hljs-string"><span class="hljs-string">'page'</span></span>, }); pageStream.pipe(backgroundStream).pipe(pageStream); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">injectScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// inject in-page script let script = document.createElement('script'); script.src = extensionApi.extension.getURL('inpage.js'); const container = document.head || document.documentElement; container.insertBefore(script, container.children[0]); script.onload = () =&gt; script.remove(); } catch (e) { console.error('Injection failed.', e); } }</span></span></code> </pre> <br><p>  Como no necesitamos la API en el script de contenido, sino directamente en la p√°gina, hacemos dos cosas: </p><br><ol><li>  Creamos dos corrientes.  Uno es hacia la p√°gina, encima de postMessage.  Para esto usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este paquete</a> de los creadores de metamask.  La segunda secuencia es en segundo plano en la parte superior del puerto recibido de <code>runtime.connect</code> .  Pip ellos.  Ahora la p√°gina tendr√° una secuencia en segundo plano. </li><li>  Inyecte el script en el DOM.  Bombeamos el script (se permiti√≥ el acceso al mismo en el manifiesto) y creamos una etiqueta de <code>script</code> con su contenido dentro: </li></ol><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PostMessageStream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'post-message-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; setupConnection(); injectScript(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    const backgroundPort = extensionApi.runtime.connect({name: 'contentscript'}); const backgroundStream = new PortStream(backgroundPort); //    const pageStream = new PostMessageStream({ name: 'content', target: 'page', }); pageStream.pipe(backgroundStream).pipe(pageStream); } function injectScript(){ try { // inject in-page script let script = document.createElement('script'); script.src = extensionApi.extension.getURL('inpage.js'); const container = document.head || document.documentElement; container.insertBefore(script, container.children[0]); script.onload = () =&gt; script.remove(); } catch (e) { console.error('Injection failed.', e); } }</span></span></code> </pre> <br><p>  Ahora cree un objeto api en inpage y comience globalmente: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PostMessageStream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'post-message-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dnode/browser'</span></span>; setupInpageApi().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupInpageApi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    const connectionStream = new PostMessageStream({ name: 'page', target: 'content', }); const dnode = Dnode(); connectionStream.pipe(dnode).pipe(connectionStream); //   API const pageApi = await new Promise(resolve =&gt; { dnode.once('remote', api =&gt; { resolve(api) }) }); //   window global.SignerApp = pageApi; }</span></span></code> </pre> <br><p>  Estamos listos para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la llamada a procedimiento remoto (RPC) con una API separada para la p√°gina y la interfaz de usuario</a> .  Al conectar una nueva p√°gina al fondo, podemos ver esto: </p><br><p><img src="https://habrastorage.org/webt/cy/r_/pm/cyr_pmgm-u5hes5lefaf85gk91m.png"></p><br><p>  API vac√≠a y origen.  En el lado de la p√°gina, podemos llamar a la funci√≥n hello de esta manera: </p><br><p><img src="https://habrastorage.org/webt/3p/fd/tv/3pfdtv17ejnjzh94uajezgz0lce.png"></p><br><p>  Trabajar con funciones de devoluci√≥n de llamada en JS moderno es una mala idea, por lo tanto, escribiremos un peque√±o ayudante para crear un nodo que le permita pasar API a utilidades en un objeto. </p><br><p>  Los objetos API ahora se ver√°n as√≠: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ popupApi() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">hello</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; <span class="hljs-string"><span class="hljs-string">"world"</span></span> } } ... }</code> </pre> <br><p>  Obtener un objeto de forma remota de la siguiente manera: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {cbToPromise, transformMethods} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../../src/utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pageApi = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { dnode.once(<span class="hljs-string"><span class="hljs-string">'remote'</span></span>, remoteApi =&gt; { <span class="hljs-comment"><span class="hljs-comment">//      callback  promise resolve(transformMethods(cbToPromise, remoteApi)) }) });</span></span></code> </pre> <br><p>  Una llamada a funci√≥n devuelve una promesa: </p><br><p><img src="https://habrastorage.org/webt/g7/qq/og/g7qqogo60hrjqm5pre7f5miehs0.png"></p><br><p>  Una versi√≥n con funciones asincr√≥nicas est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><p>  En general, el enfoque con RPC y transmisiones parece bastante flexible: podemos usar la multiplexaci√≥n de vapor y crear varias API diferentes para diferentes tareas.  En principio, dnode se puede usar en cualquier lugar, lo principal es envolver el transporte en forma de una secuencia de nodejs. </p><br><p>  Una alternativa es el formato JSON, que implementa el protocolo JSON RPC 2. Sin embargo, funciona con transportes espec√≠ficos (TCP y HTTP (S)), que no es aplicable en nuestro caso. </p><br><h3 id="vnutrenniy-steyt-i-localstorage">  Almacenamiento interno estatal y local </h3><br><p>  Tendremos que almacenar el estado interno de la aplicaci√≥n, al menos, claves para firmar.  Podemos agregar f√°cilmente el estado a la aplicaci√≥n y los m√©todos para cambiarlo en la API emergente: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store = { <span class="hljs-attr"><span class="hljs-attr">keys</span></span>: [], }; } addKey(key){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.keys.push(key) } removeKey(index){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.keys.splice(index,<span class="hljs-number"><span class="hljs-number">1</span></span>) } popupApi(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">addKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (key) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addKey(key), <span class="hljs-attr"><span class="hljs-attr">removeKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (index) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.removeKey(index) } } ... }</code> </pre> <br><p>  En segundo plano, envolveremos todo en una funci√≥n y escribiremos el objeto de la aplicaci√≥n en la ventana para que pueda trabajar con √©l desde la consola: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; setupApp(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignerApp(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DEV_MODE) { global.app = app; } extensionApi.runtime.onConnect.addListener(connectRemote); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectRemote</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">remotePort</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processName = remotePort.name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> portStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PortStream(remotePort); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (processName === <span class="hljs-string"><span class="hljs-string">'contentscript'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> origin = remotePort.sender.url; app.connectPage(portStream, origin) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { app.connectPopup(portStream) } } }</code> </pre> <br><p>  Agregue algunas claves de la consola de la interfaz de usuario y vea qu√© sucedi√≥ con el estado: </p><br><p><img src="https://habrastorage.org/webt/n7/xr/eb/n7xrebxybxbquxx8z8uozgwpfqm.png"></p><br><p>  El estado debe ser persistente para que cuando reinicie las claves no se pierdan. </p><br><p>  Lo almacenaremos en localStorage, sobrescribiendo con cada cambio.  Posteriormente, el acceso a √©l tambi√©n ser√° necesario para la interfaz de usuario, y tambi√©n quiero suscribirme a los cambios.  En base a esto, ser√° conveniente hacer un almacenamiento observable y suscribirse a sus cambios. </p><br><p>  Utilizaremos la biblioteca mobx ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/mobxjs/mobx</a> ).  La elecci√≥n recay√≥ en ella, ya que no ten√≠a que trabajar con ella, pero realmente quer√≠a estudiarla. </p><br><p>  Agregue la inicializaci√≥n del estado inicial y haga que la tienda sea observable: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {observable, action} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(initState = {}) { <span class="hljs-comment"><span class="hljs-comment">//  store      ,       proxy,      this.store = observable.object({ keys: initState.keys || [], }); } // ,   observable    @action addKey(key) { this.store.keys.push(key) } @action removeKey(index) { this.store.keys.splice(index, 1) } ... }</span></span></code> </pre> <br><p>  "Under the hood" mobx reemplaz√≥ todos los campos de la tienda con proxy e intercepta todas las llamadas a ellos.  Puede suscribirse a estas apelaciones. </p><br><p>  Adem√°s, a menudo utilizar√© el t√©rmino "al cambiar", aunque esto no es del todo correcto.  Mobx rastrea el acceso a los campos.  Se utilizan los captadores y establecedores de objetos proxy que crea la biblioteca. </p><br><p>  Los decoradores de acci√≥n tienen dos prop√≥sitos: </p><br><ol><li>  En modo estricto con la bandera enforceActions mobx proh√≠be cambiar el estado directamente.  Se considera una buena pr√°ctica trabajar en modo estricto. </li><li>  Incluso si la funci√≥n cambia el estado varias veces, por ejemplo, cambiamos varios campos a varias l√≠neas de c√≥digo, los observadores reciben una notificaci√≥n solo cuando est√° completa.  Esto es especialmente importante para el frontend, donde las actualizaciones de estado innecesarias conducen a la representaci√≥n innecesaria de elementos.  En nuestro caso, ni el primero ni el segundo son particularmente relevantes, sin embargo, seguiremos las mejores pr√°cticas.  Los decoradores decidieron suspender todas las funciones que cambian el estado de los campos observados. </li></ol><br><p>  En segundo plano, agregue la inicializaci√≥n y guarde el estado en localStorage: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {reaction, toJS} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  . /  / localStorage  JSON    'store' import {loadState, saveState} from "./utils/localStorage"; const DEV_MODE = process.env.NODE_ENV !== 'production'; setupApp(); function setupApp() { const initState = loadState(); const app = new SignerApp(initState); if (DEV_MODE) { global.app = app; } // Setup state persistence //  reaction  ,     .    ,    const localStorageReaction = reaction( () =&gt; toJS(app.store), // -  saveState // ,      ,    ); extensionApi.runtime.onConnect.addListener(connectRemote); function connectRemote(remotePort) { const processName = remotePort.name; const portStream = new PortStream(remotePort); if (processName === 'contentscript') { const origin = remotePort.sender.url app.connectPage(portStream, origin) } else { app.connectPopup(portStream) } } }</span></span></code> </pre> <br><p>  La funci√≥n de reacci√≥n es interesante aqu√≠.  Ella tiene dos argumentos: </p><br><ol><li>  Selector de datos. </li><li>  Un controlador que se llamar√° con estos datos cada vez que cambie. </li></ol><br><p>  A diferencia de redux, donde obtenemos expl√≠citamente el estado como argumento, mobx recuerda a qu√© observable nos referimos dentro del selector, y solo al cambiarlos llama al controlador. </p><br><p>  Es importante comprender exactamente c√≥mo mobx decide a qu√© observable nos estamos suscribiendo.  Si escrib√≠ el selector en el c√≥digo como este <code>() =&gt; app.store</code> , entonces la reacci√≥n nunca se llamar√°, ya que el repositorio en s√≠ no es observable, solo sus campos son tales. </p><br><p>  Si escribiera as√≠ <code>() =&gt; app.store.keys</code> , entonces no volver√≠a a pasar nada, ya que al agregar / eliminar elementos de la matriz, el enlace no cambiar√°. </p><br><p>  Por primera vez, Mobx realiza la funci√≥n de un selector y monitorea solo aquellos observables a los que tenemos acceso.  Esto se hace a trav√©s de getters proxy.      <code>toJS</code> .    ,        .         ‚Äì ,  . </p><br><p>   popup    .         localStorage: </p><br><p><img src="https://habrastorage.org/webt/fr/dh/6t/frdh6tc_bt_v3zywmgjrnptngcw.png"></p><br><p>   background-    . </p><br><p>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </p><br><h2 id="bezopasnoe-hranenie-privatnyh-klyuchey">     </h2><br><p>       :    ,   ,        .   localStorage        . </p><br><p>       locked,        .        locked  . </p><br><p> Mobx      ,       .  ‚Äî   computed properties.     view   : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {observable, action} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     .  crypto-js import {encrypt, decrypt} from "./utils/cryptoUtils"; export class SignerApp { constructor(initState = {}) { this.store = observable.object({ //     .   null -  locked password: null, vault: initState.vault, //    .     view  . get locked(){ return this.password == null }, get keys(){ return this.locked ? undefined : SignerApp._decryptVault(this.vault, this.password) }, get initialized(){ return this.vault !== undefined } }) } //      @action initVault(password){ this.store.vault = SignerApp._encryptVault([], password) } @action lock() { this.store.password = null } @action unlock(password) { this._checkPassword(password); this.store.password = password } @action addKey(key) { this._checkLocked(); this.store.vault = SignerApp._encryptVault(this.store.keys.concat(key), this.store.password) } @action removeKey(index) { this._checkLocked(); this.store.vault = SignerApp._encryptVault([ ...this.store.keys.slice(0, index), ...this.store.keys.slice(index + 1) ], this.store.password ) } ... //    api // private _checkPassword(password) { SignerApp._decryptVault(this.store.vault, password); } _checkLocked() { if (this.store.locked){ throw new Error('App is locked') } } //   /  static _encryptVault(obj, pass){ const jsonString = JSON.stringify(obj) return encrypt(jsonString, pass) } static _decryptVault(str, pass){ if (str === undefined){ throw new Error('Vault not initialized') } try { const jsonString = decrypt(str, pass) return JSON.parse(jsonString) }catch (e) { throw new Error('Wrong password') } } }</span></span></code> </pre> <br><p>        .   .    locked        .   API     . </p><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   rypto-js</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CryptoJS <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'crypto-js'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      .        5000  function strengthenPassword(pass, rounds = 5000) { while (rounds-- &gt; 0){ pass = CryptoJS.SHA256(pass).toString() } return pass } export function encrypt(str, pass){ const strongPass = strengthenPassword(pass); return CryptoJS.AES.encrypt(str, strongPass).toString() } export function decrypt(str, pass){ const strongPass = strengthenPassword(pass) const decrypted = CryptoJS.AES.decrypt(str, strongPass); return decrypted.toString(CryptoJS.enc.Utf8) }</span></span></code> </pre> <br><p>    idle API,       ‚Äî  . , ,   <code>idle</code> , <code>active</code>  <code>locked</code> .  idle   ,  locked ,    .        localStorage: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {reaction, toJS} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {loadState, saveState} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/localStorage"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IDLE_INTERVAL = <span class="hljs-number"><span class="hljs-number">30</span></span>; setupApp(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initState = loadState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignerApp(initState); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DEV_MODE) { global.app = app; } <span class="hljs-comment"><span class="hljs-comment">//     ,    , reaction   reaction( () =&gt; ({ vault: app.store.vault }), saveState ); //  ,    extensionApi.idle.setDetectionInterval(IDLE_INTERVAL); //             extensionApi.idle.onStateChanged.addListener(state =&gt; { if (['locked', 'idle'].indexOf(state) &gt; -1) { app.lock() } }); // Connect to other contexts extensionApi.runtime.onConnect.addListener(connectRemote); function connectRemote(remotePort) { const processName = remotePort.name; const portStream = new PortStream(remotePort); if (processName === 'contentscript') { const origin = remotePort.sender.url app.connectPage(portStream, origin) } else { app.connectPopup(portStream) } } }</span></span></code> </pre> <br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </p><br><h3 id="tranzakcii">  Transacciones </h3><br><p> ,     :      .     WAVES   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">waves-transactions</a> . </p><br><p>       ,   ,  ‚Äî    ,    : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {action, observable, reaction} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {signTx} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@waves/waves-transactions'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {decrypt, encrypt} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/cryptoUtils"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ ... @action newMessage(data, origin) { <span class="hljs-comment"><span class="hljs-comment">//       id, ,    . const message = observable.object({ id: uuid(), // ,  uuid origin, // Origin      data, // status: 'new', //   : new, signed, rejected  failed timestamp: Date.now() }); console.log(`new message: ${JSON.stringify(message, null, 2)}`); this.store.messages.push(message); //     mobx   .        return new Promise((resolve, reject) =&gt; { reaction( () =&gt; message.status, //    (status, reaction) =&gt; { //       reaction,        switch (status) { case 'signed': resolve(message.data); break; case 'rejected': reject(new Error('User rejected message')); break; case 'failed': reject(new Error(message.err.message)); break; default: return } reaction.dispose() } ) }) } @action approve(id, keyIndex = 0) { const message = this.store.messages.find(msg =&gt; msg.id === id); if (message == null) throw new Error(`No msg with id:${id}`); try { message.data = signTx(message.data, this.store.keys[keyIndex]); message.status = 'signed' } catch (e) { message.err = { stack: e.stack, message: e.message }; message.status = 'failed' throw e } } @action reject(id) { const message = this.store.messages.find(msg =&gt; msg.id === id); if (message == null) throw new Error(`No msg with id:${id}`); message.status = 'rejected' } ... }</span></span></code> </pre> <br><p>         ,  <code>observable</code>    <code>store.messages</code> . </p><br><p>    <code>observable</code> ,  mobx        messages.     ,       ,      . </p><br><p>    ,      .    reaction,    ""   . </p><br><p>   <code>approve</code>  <code>reject</code>  :     ,   ,  . </p><br><p> Approve  reject    API UI, newMessage ‚Äî  API : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ ... popupApi() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">addKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (key) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addKey(key), <span class="hljs-attr"><span class="hljs-attr">removeKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (index) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.removeKey(index), <span class="hljs-attr"><span class="hljs-attr">lock</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lock(), <span class="hljs-attr"><span class="hljs-attr">unlock</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (password) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unlock(password), <span class="hljs-attr"><span class="hljs-attr">initVault</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (password) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initVault(password), <span class="hljs-attr"><span class="hljs-attr">approve</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (id, keyIndex) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.approve(id, keyIndex), <span class="hljs-attr"><span class="hljs-attr">reject</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (id) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reject(id) } } pageApi(origin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">signTransaction</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (txParams) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newMessage(txParams, origin) } } ... }</code> </pre> <br><p>     : </p><br><p><img src="https://habrastorage.org/webt/jt/bp/nu/jtbpnu9tbhryijukstktnti3wbu.png"></p><br><p>    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  UI</a> . </p><br><h2 id="ui"> UI </h2><br><p>      .   UI   <code>observable</code>     API ,     .  <code>observable</code>   API,   background: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {cbToPromise, setupDnode, transformMethods} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {initApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./ui/index"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; setupUi().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupUi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,     const backgroundPort = extensionApi.runtime.connect({name: 'popup'}); const connectionStream = new PortStream(backgroundPort); //   observable   background'a let backgroundState = observable.object({}); const api = { //  ,    observable updateState: async state =&gt; { Object.assign(backgroundState, state) } }; //  RPC  const dnode = setupDnode(connectionStream, api); const background = await new Promise(resolve =&gt; { dnode.once('remote', remoteApi =&gt; { resolve(transformMethods(cbToPromise, remoteApi)) }) }); //   background observable   background.state = backgroundState; if (DEV_MODE) { global.background = background; } //   await initApp(background) }</span></span></code> </pre><br><p>       .  react-. Background-     props. , ,       store  ,       : </p><br><pre> <code class="plaintext hljs">import {render} from 'react-dom' import App from './App' import React from "react"; //    background     props export async function initApp(background){ render( &lt;App background={background}/&gt;, document.getElementById('app-content') ); }</code> </pre><br><p>   mobx       .     observer   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mobx-react</a>  ,         observable,    .    mapStateToProps  connect,   redux.    " ": </p><br><pre> <code class="plaintext hljs">import React, {Component, Fragment} from 'react' import {observer} from "mobx-react"; import Init from './components/Initialize' import Keys from './components/Keys' import Sign from './components/Sign' import Unlock from './components/Unlock' @observer //          render,    observable     export default class App extends Component { //              , //   observable   background    ,    render() { const {keys, messages, initialized, locked} = this.props.background.state; const {lock, unlock, addKey, removeKey, initVault, deleteVault, approve, reject} = this.props.background; return &lt;Fragment&gt; {!initialized ? &lt;Init onInit={initVault}/&gt; : locked ? &lt;Unlock onUnlock={unlock}/&gt; : messages.length &gt; 0 ? &lt;Sign keys={keys} message={messages[messages.length - 1]} onApprove={approve} onReject={reject}/&gt; : &lt;Keys keys={keys} onAdd={addKey} onRemove={removeKey}/&gt; } &lt;div&gt; {!locked &amp;&amp; &lt;button onClick={() =&gt; lock()}&gt;Lock App&lt;/button&gt;} {initialized &amp;&amp; &lt;button onClick={() =&gt; deleteVault()}&gt;Delete all keys and init&lt;/button&gt;} &lt;/div&gt; &lt;/Fragment&gt; } }</code> </pre> <br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  UI</a> . </p><br><p>          UI      UI.     <code>getState</code>  <code>reaction</code> ,  <code>remote.updateState</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {action, observable, reaction} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {signTx} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@waves/waves-transactions'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {decrypt, encrypt} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/cryptoUtils"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">// public getState() { return { keys: this.store.keys, messages: this.store.newMessages, initialized: this.store.initialized, locked: this.store.locked } } ... // connectPopup(connectionStream) { const api = this.popupApi(); const dnode = setupDnode(connectionStream, api); dnode.once('remote', (remote) =&gt; { //  reaction   ,          ui  const updateStateReaction = reaction( () =&gt; this.getState(), (state) =&gt; remote.updateState(state), //     . fireImmediatly   reaction    . //  ,    . Delay   debounce {fireImmediately: true, delay: 500} ); //      dnode.once('end', () =&gt; updateStateReaction.dispose()) }) } ... }</span></span></code> </pre> <br><p>    <code>remote</code>  <code>reaction</code>   ,      UI. </p><br><p>   ‚Äî       : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">// Reaction    . reaction( () =&gt; app.store.newMessages.length &gt; 0 ? app.store.newMessages.length.toString() : '', text =&gt; extensionApi.browserAction.setBadgeText({text}), {fireImmediately: true} ); ... }</span></span></code> </pre> <br><p> ,  . -    : </p><br><p><img src="https://habrastorage.org/webt/yo/cz/9b/yocz9bncoevwxrict_3dl_vphek.png"></p><br><p><img src="https://habrastorage.org/webt/ee/8e/uj/ee8eujkmg5iwgfholkyxneqsim4.png"></p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </p><br><p>  <strong>Conclusi√≥n</strong> </p><br><p>      ,     ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> .         . </p><br><p>        ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </p><br><p> <strong>,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">siemarell</a></strong> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/451796/">https://habr.com/ru/post/451796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451784/index.html">Unidades h√≠bridas para almacenamiento empresarial. Experiencia con Seagate EXOS</a></li>
<li><a href="../451786/index.html">Ejecute pruebas instrumentales en el laboratorio de pruebas de Firebase. Parte 1: proyecto iOS</a></li>
<li><a href="../451790/index.html">Los peligros de la recopilaci√≥n de datos en el juego</a></li>
<li><a href="../451792/index.html">Cuatro detectores de JavaScript que lo atrapan en las tiendas en l√≠nea</a></li>
<li><a href="../451794/index.html">P√≠xeles de sangr√≠a de textura</a></li>
<li><a href="../451798/index.html">Migraci√≥n de datos con mongoDB y Spring Boot</a></li>
<li><a href="../451800/index.html">Hacer un m√≥dem sonar simple</a></li>
<li><a href="../451802/index.html">.Net Community of Raiffeisenbank invita a UPD mitap Broadcast</a></li>
<li><a href="../451806/index.html">iOS Digest No. 5 (27 de abril - 16 de mayo)</a></li>
<li><a href="../451812/index.html">Ahora los buenos desarrolladores se miden por vistas y suscriptores, y esto es malo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>