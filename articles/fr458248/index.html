<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏾 🙌🏻 🙅 Simplifiez votre code avec Rocket Science: l'opérateur de vaisseau spatial de C ++ 20 ⛄️ 💆🏼 🤘🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ 20 ajoute un nouvel opérateur, surnommé affectueusement l'opérateur "vaisseau spatial": <=> . Il y a un moment, notre propre marque Simon a publi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Simplifiez votre code avec Rocket Science: l'opérateur de vaisseau spatial de C ++ 20</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/458248/"> C ++ 20 ajoute un nouvel opérateur, surnommé affectueusement l'opérateur "vaisseau spatial": <code>&lt;=&gt;</code> .  Il y a un moment, notre propre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">marque Simon a publié un article</a> détaillant certaines informations concernant ce nouvel opérateur ainsi que des informations conceptuelles sur ce qu'il est et ce qu'il fait.  Le but de cet article est d'explorer quelques applications concrètes de cet étrange nouvel opérateur et de son homologue associé, l' <code>operator==</code> (oui, il a été changé, pour le mieux!), Tout en fournissant quelques lignes directrices pour son utilisation dans le code de tous les jours. <br><br><img src="https://habrastorage.org/webt/ny/pa/bp/nypabpd9lxsd9ifx_f7_zitj7ti.png"><a name="habracut"></a><br><br><h2>  Comparaisons </h2><br>  Il n'est pas rare de voir du code comme celui-ci: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value == rhs.value; }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value;  }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;        }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt; rhs);    } };</code> </pre> <br>  <i>Remarque: les lecteurs aux yeux d'aigle remarqueront que c'est en fait encore moins verbeux qu'il ne devrait l'être dans le code pré-C ++ 20 car ces fonctions devraient en fait toutes être des amis non membres, plus à ce sujet plus tard.</i> <br><br>  C'est beaucoup de code passe-partout à écrire juste pour m'assurer que mon type est comparable à quelque chose du même type.  Eh bien, OK, nous nous en occupons pendant un certain temps.  Vient ensuite quelqu'un qui écrit ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(is_lt(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  La première chose que vous remarquerez est que ce programme ne se compilera pas. <br><br> <code>error C3615: constexpr function 'is_lt' cannot result in a constant expression</code> <br> <br>  Ah!  Le problème est que nous avons oublié <code>constexpr</code> sur notre fonction de comparaison, drat!  Donc, on va et ajoute <code>constexpr</code> à tous les opérateurs de comparaison.  Quelques jours plus tard, quelqu'un va ajouter un assistant <code>is_gt</code> mais remarque que tous les opérateurs de comparaison n'ont pas de spécification d'exception et passent par le même processus fastidieux d'ajout de <code>noexcept</code> à chacune des 5 surcharges. <br><br>  C'est là que le nouvel opérateur de vaisseau spatial de C ++ 20 intervient pour nous aider.  Voyons comment l' <code>IntWrapper</code> originale peut être écrite dans un monde C ++ 20: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  La première différence que vous remarquerez peut-être est la nouvelle inclusion de <code>&lt;compare&gt;</code> .  L'en-tête <code>&lt;compare&gt;</code> est chargé de remplir le compilateur avec tous les types de catégorie de comparaison nécessaires pour que l'opérateur du vaisseau spatial retourne un type approprié pour notre fonction par défaut.  Dans l'extrait ci-dessus, le type de retour <code>auto</code> sera déduit de <code>std::strong_ordering</code> . <br><br>  Non seulement nous avons supprimé 5 lignes superflues, mais nous n'avons même pas besoin de définir quoi que ce soit, le compilateur le fait pour nous!  Notre <code>is_lt</code> reste inchangé et fonctionne juste tout en étant <code>constexpr</code> même si nous n'avons pas explicitement spécifié cela dans notre <code>operator&lt;=&gt;</code> défaut <code>operator&lt;=&gt;</code> .  C'est bien beau, mais certaines personnes peuvent se gratter la tête pour savoir pourquoi <code>is_lt</code> est toujours autorisé à compiler même s'il n'utilise même pas du tout l'opérateur du vaisseau spatial.  Explorons la réponse à cette question. <br><br><h2>  Réécrire des expressions </h2><br>  En C ++ 20, le compilateur est introduit dans un nouveau concept appelé expressions «réécrites».  L'opérateur du vaisseau spatial, avec l' <code>operator==</code> , fait partie des deux premiers candidats soumis à des expressions réécrites.  Pour un exemple plus concret de réécriture d'expression, décomposons l'exemple fourni dans <code>is_lt</code> . <br><br>  Pendant la résolution de surcharge, le compilateur va sélectionner parmi un ensemble de candidats viables, qui correspondent tous à l'opérateur que nous recherchons.  Le processus de collecte des candidats est très légèrement modifié pour le cas des opérations relationnelles et d'équivalence où le compilateur doit également rassembler des candidats spéciaux réécrits et synthétisés ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[over.match.oper] /3.4</a> ). <br><br>  Pour notre expression <code>a &lt; b</code> la norme stipule que nous pouvons rechercher le type de a pour un <code>operator&lt;=&gt;</code> ou un <code>operator&lt;=&gt;</code> fonction de portée d'espace de noms <code>operator&lt;=&gt;</code> qui accepte son type.  Donc, le compilateur le fait et il constate qu'en fait, le type de <code>IntWrapper::operator&lt;=&gt;</code> .  Le compilateur est alors autorisé à utiliser cet opérateur et à réécrire l'expression <code>a &lt; b</code> as <code>(a &lt;=&gt; b) &lt; 0</code> .  Cette expression réécrite est ensuite utilisée comme candidate à une résolution de surcharge normale. <br><br>  Vous pouvez vous demander pourquoi cette expression réécrite est valide et correcte.  La justesse de l'expression découle en fait de la sémantique fournie par l'opérateur du vaisseau spatial.  Le <code>&lt;=&gt;</code> est une comparaison à trois qui implique que vous obtenez non seulement un résultat binaire, mais un ordre (dans la plupart des cas) et si vous avez un ordre, vous pouvez exprimer cet ordre en termes d'opérations relationnelles.  Un exemple rapide, l'expression 4 &lt;=&gt; 5 en C ++ 20 vous donnera le résultat <code>std::strong_ordering::less</code> .  Le résultat <code>std::strong_ordering::less</code> implique que <code>4</code> n'est pas seulement différent de <code>5</code> mais qu'il est strictement inférieur à cette valeur, ce qui rend l'application de l'opération <code>(4 &lt;=&gt; 5) &lt; 0</code> correcte et exacte pour décrire notre résultat. <br><br>  En utilisant les informations ci-dessus, le compilateur peut prendre n'importe quel opérateur relationnel généralisé (c'est-à-dire <code>&lt;</code> , <code>&gt;</code> , etc.) et le réécrire en termes d'opérateur de vaisseau spatial.  Dans la norme, l'expression réécrite est souvent appelée <code>(a &lt;=&gt; b) @ 0</code> où le <code>@</code> représente toute opération relationnelle. <br><br><h2>  Synthétiser des expressions </h2><br>  Les lecteurs ont peut-être remarqué la mention subtile des expressions "synthétisées" ci-dessus et ils jouent également un rôle dans ce processus de réécriture d'opérateur.  Considérons une fonction de prédicat différente: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_gt_42</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> &lt; a; }</code> </pre> <br>  Si nous utilisons notre définition d'origine pour <code>IntWrapper</code> ce code ne sera pas compilé. <br><br> <code>error C2677: binary '&lt;': no global operator found which takes type 'const IntWrapper' (or there is no acceptable conversion)</code> <br> <br>  Cela a du sens dans la version pré-C ++ 20, et la façon de résoudre ce problème serait d'ajouter quelques fonctions supplémentaires à <code>IntWrapper</code> qui prennent un côté gauche d' <code>int</code> .  Si vous essayez de créer cet exemple avec un compilateur C ++ 20 et notre définition C ++ 20 d' <code>IntWrapper</code> vous remarquerez peut-être que, là encore, «ça marche» - un autre gratte-tête.  Examinons pourquoi le code ci-dessus est toujours autorisé à compiler en C ++ 20. <br><br>  Pendant la résolution de surcharge, le compilateur rassemblera également ce que la norme appelle des candidats «synthétisés» ou une expression réécrite avec l'ordre des paramètres inversé.  Dans l'exemple ci-dessus, le compilateur essaiera d'utiliser l'expression réécrite <code>(42 &lt;=&gt; a) &lt; 0</code> mais il trouvera qu'il n'y a pas de conversion d' <code>IntWrapper</code> en <code>int</code> pour satisfaire le côté gauche afin que l'expression réécrite soit supprimée.  Le compilateur évoque également l'expression «synthétisée» <code>0 &lt; (a &lt;=&gt; 42)</code> et constate qu'il y a une conversion de <code>int</code> en <code>IntWrapper</code> via son constructeur de conversion, donc ce candidat est utilisé. <br><br>  Le but des expressions synthétisées est d'éviter le désordre d'avoir à écrire le passe-partout des fonctions <code>friend</code> pour combler les lacunes où votre objet pourrait être converti à partir d'autres types.  Les expressions synthétisées sont généralisées à <code>0 @ (b &lt;=&gt; a)</code> . <br><br><h2>  Types plus complexes </h2><br>  L'opérateur de vaisseau spatial généré par le compilateur ne s'arrête pas aux membres uniques des classes, il générera un ensemble correct de comparaisons pour tous les sous-objets de vos types: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Basics</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f;  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d;  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Basics&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arrays</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai[<span class="hljs-number"><span class="hljs-number">1</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ac[<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> af[<span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ad[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arrays&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bases</span></span></span><span class="hljs-class"> :</span></span> Basics, Arrays {  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Bases&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases a = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases b = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a == b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a != b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &lt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &lt;= b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &gt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &gt;= b); }</code> </pre> <br>  Le compilateur sait comment développer les membres des classes qui sont des tableaux dans leurs listes de sous-objets et les comparer récursivement.  Bien sûr, si vous vouliez écrire vous-même le corps de ces fonctions, vous bénéficiez toujours des expressions de réécriture du compilateur pour vous. <br><br><h2>  Ressemble à un canard, nage comme un canard et quacks comme <code>operator==</code> </h2><br>  Certaines personnes très intelligentes du comité de normalisation ont remarqué que l'opérateur du vaisseau spatial effectuera toujours une comparaison lexicographique des éléments, quoi qu'il arrive.  Des comparaisons lexicographiques inconditionnelles peuvent conduire à un code généré inefficace avec l'opérateur d'égalité en particulier. <br><br>  L'exemple canonique compare deux chaînes.  Si vous avez la chaîne <code>"foobar"</code> et que vous la comparez à la chaîne <code>"foo"</code> utilisant == on s'attendrait à ce que cette opération soit presque constante.  L'algorithme de comparaison de chaînes efficace est donc: <br><br><ul><li>  Comparez d'abord la taille des deux chaînes, si les tailles diffèrent, retournez <code>false</code> , sinon </li><li>  parcourez chaque élément des deux chaînes à l'unisson et comparez jusqu'à ce que l'on diffère ou que la fin soit atteinte, renvoyez le résultat. </li></ul><br>  Selon les règles de l'opérateur de vaisseau spatial, nous devons commencer par la comparaison approfondie de chaque élément jusqu'à ce que nous trouvions celui qui est différent.  Dans notre exemple de <code>"foobar"</code> et <code>"foo"</code> uniquement en comparant <code>'b'</code> à <code>'\0'</code> , vous retournez finalement <code>false</code> . <br><br>  Pour lutter contre cela, il y avait un document, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1185R2,</a> qui détaille un moyen pour le compilateur de réécrire et de générer l' <code>operator==</code> indépendamment de l'opérateur du vaisseau spatial.  Notre <code>IntWrapper</code> pourrait s'écrire comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default;  bool operator==(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Encore une étape ... cependant, il y a de bonnes nouvelles;  vous n'avez pas réellement besoin d'écrire le code ci-dessus, car il suffit d'écrire <code>auto operator&lt;=&gt;(const IntWrapper&amp;) const = default</code> pour que le compilateur génère implicitement l' <code>operator==</code> séparé <code>operator==</code> et plus efficace <code>operator==</code> pour vous! <br><br>  Le compilateur applique une règle de «réécriture» légèrement modifiée spécifique à <code>==</code> et <code>!=</code> Où ces opérateurs sont réécrits en termes d' <code>operator==</code> et non d' <code>operator&lt;=&gt;</code> .  Cela signifie que <code>!=</code> Bénéficie également de l'optimisation. <br><br><h2>  L'ancien code ne se cassera pas </h2><br>  À ce stade, vous pourriez penser, OK si le compilateur est autorisé à effectuer cette opération de réécriture d'opérateur ce qui se passe lorsque j'essaie de déjouer le compilateur: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }</code> </pre> <br>  La réponse est que non.  Le modèle de résolution de surcharge en C ++ a cette arène où tous les candidats se battent, et dans cette bataille spécifique, nous avons 3 candidats: <br><br><ul><li> <code>IntWrapper::operator&lt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> <li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> </ul><br>  (réécrit) <br><br><ul><li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; b, const IntWrapper&amp; a)</code> </li> </ul><br>  (synthétisé) <br><br>  Si nous avions accepté les règles de résolution de surcharge en C ++ 17, le résultat de cet appel aurait été ambigu, mais les règles de résolution de surcharge C ++ 20 ont été modifiées pour permettre au compilateur de résoudre cette situation à la surcharge la plus logique. <br><br>  Il y a une phase de résolution de surcharge où le compilateur doit effectuer une série de bris d'égalité.  En C ++ 20, il y a un nouveau bris d'égalité qui stipule que nous devons préférer les surcharges qui ne sont pas réécrites ou synthétisées, ce qui fait de notre surcharge <code>IntWrapper::operator&lt;</code> le meilleur candidat et résout l'ambiguïté.  Ce même mécanisme empêche les candidats synthétisés de piétiner des expressions réécrites régulières. <br><br><h2>  Pensées de clôture </h2><br>  L'opérateur de vaisseau spatial est un ajout bienvenu au C ++ et c'est l'une des fonctionnalités qui simplifiera et vous aidera à écrire <i>moins de</i> code, et, parfois, moins c'est plus.  Alors, attachez-vous à l'opérateur de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vaisseau spatial</a> de C ++ 20! <br><br>  Nous vous invitons à sortir et essayer l'opérateur de vaisseau spatial, il est disponible dès maintenant dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Visual Studio 2019</a> sous <code>/std:c++latest</code> !  Remarque: les modifications introduites via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1185R2</a> seront disponibles dans Visual Studio 2019 version 16.2.  Veuillez garder à l'esprit que l'opérateur du vaisseau spatial fait partie de C ++ 20 et est soumis à certaines modifications jusqu'à ce que C ++ 20 soit finalisé. <br><br>  Comme toujours, nous apprécions vos commentaires.  N'hésitez pas à envoyer vos commentaires par e-mail à <a href="">visualcpp@microsoft.com</a> , via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Twitter @visualc</a> ou Facebook à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Microsoft Visual Cpp</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">N'hésitez</a> pas non plus à me suivre sur Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@starfreakclone</a> . <br><br>  Si vous rencontrez d'autres problèmes avec MSVC dans VS 2019, veuillez nous en informer via l'option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Signaler un problème</a> , à partir du programme d'installation ou de l'IDE Visual Studio lui-même.  Pour des suggestions ou des rapports de bogues, faites-le nous savoir via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DevComm.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458248/">https://habr.com/ru/post/fr458248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458230/index.html">Comment l'IA, les drones et les caméras assurent la sécurité de nos routes et de nos ponts</a></li>
<li><a href="../fr458240/index.html">Comment l'intelligence artificielle, les drones et les caméras assurent la sécurité des routes et des ponts</a></li>
<li><a href="../fr458242/index.html">Le nouvel opérateur de vaisseau spatial en C ++ 20</a></li>
<li><a href="../fr458244/index.html">Une liste interminable et ridicule de ce que vous devez savoir pour utiliser en toute sécurité les réseaux Wi-Fi publics</a></li>
<li><a href="../fr458246/index.html">Coïncidences aléatoires dans la vie, ou comment il s'est avéré qu'on vous a présenté un gâteau dans une usine de tracteurs</a></li>
<li><a href="../fr458250/index.html">BTRFS pour les plus petits</a></li>
<li><a href="../fr458252/index.html">Modèle mathématique d'un radiotélescope super long</a></li>
<li><a href="../fr458256/index.html">N'est-il pas temps pour le lavage de cerveau?</a></li>
<li><a href="../fr458260/index.html">Une autre façon d'optimiser les images Docker pour les applications Java</a></li>
<li><a href="../fr458262/index.html">Concepteur en ligne de la salle de réunion - sélection de la solution optimale pour la visioconférence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>