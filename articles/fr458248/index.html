<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèæ üôåüèª üôÖ Simplifiez votre code avec Rocket Science: l'op√©rateur de vaisseau spatial de C ++ 20 ‚õÑÔ∏è üíÜüèº ü§òüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ 20 ajoute un nouvel op√©rateur, surnomm√© affectueusement l'op√©rateur "vaisseau spatial": <=> . Il y a un moment, notre propre marque Simon a publi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Simplifiez votre code avec Rocket Science: l'op√©rateur de vaisseau spatial de C ++ 20</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/458248/"> C ++ 20 ajoute un nouvel op√©rateur, surnomm√© affectueusement l'op√©rateur "vaisseau spatial": <code>&lt;=&gt;</code> .  Il y a un moment, notre propre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">marque Simon a publi√© un article</a> d√©taillant certaines informations concernant ce nouvel op√©rateur ainsi que des informations conceptuelles sur ce qu'il est et ce qu'il fait.  Le but de cet article est d'explorer quelques applications concr√®tes de cet √©trange nouvel op√©rateur et de son homologue associ√©, l' <code>operator==</code> (oui, il a √©t√© chang√©, pour le mieux!), Tout en fournissant quelques lignes directrices pour son utilisation dans le code de tous les jours. <br><br><img src="https://habrastorage.org/webt/ny/pa/bp/nypabpd9lxsd9ifx_f7_zitj7ti.png"><a name="habracut"></a><br><br><h2>  Comparaisons </h2><br>  Il n'est pas rare de voir du code comme celui-ci: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value == rhs.value; }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value;  }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;        }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt; rhs);    } };</code> </pre> <br>  <i>Remarque: les lecteurs aux yeux d'aigle remarqueront que c'est en fait encore moins verbeux qu'il ne devrait l'√™tre dans le code pr√©-C ++ 20 car ces fonctions devraient en fait toutes √™tre des amis non membres, plus √† ce sujet plus tard.</i> <br><br>  C'est beaucoup de code passe-partout √† √©crire juste pour m'assurer que mon type est comparable √† quelque chose du m√™me type.  Eh bien, OK, nous nous en occupons pendant un certain temps.  Vient ensuite quelqu'un qui √©crit ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(is_lt(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  La premi√®re chose que vous remarquerez est que ce programme ne se compilera pas. <br><br> <code>error C3615: constexpr function 'is_lt' cannot result in a constant expression</code> <br> <br>  Ah!  Le probl√®me est que nous avons oubli√© <code>constexpr</code> sur notre fonction de comparaison, drat!  Donc, on va et ajoute <code>constexpr</code> √† tous les op√©rateurs de comparaison.  Quelques jours plus tard, quelqu'un va ajouter un assistant <code>is_gt</code> mais remarque que tous les op√©rateurs de comparaison n'ont pas de sp√©cification d'exception et passent par le m√™me processus fastidieux d'ajout de <code>noexcept</code> √† chacune des 5 surcharges. <br><br>  C'est l√† que le nouvel op√©rateur de vaisseau spatial de C ++ 20 intervient pour nous aider.  Voyons comment l' <code>IntWrapper</code> originale peut √™tre √©crite dans un monde C ++ 20: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  La premi√®re diff√©rence que vous remarquerez peut-√™tre est la nouvelle inclusion de <code>&lt;compare&gt;</code> .  L'en-t√™te <code>&lt;compare&gt;</code> est charg√© de remplir le compilateur avec tous les types de cat√©gorie de comparaison n√©cessaires pour que l'op√©rateur du vaisseau spatial retourne un type appropri√© pour notre fonction par d√©faut.  Dans l'extrait ci-dessus, le type de retour <code>auto</code> sera d√©duit de <code>std::strong_ordering</code> . <br><br>  Non seulement nous avons supprim√© 5 lignes superflues, mais nous n'avons m√™me pas besoin de d√©finir quoi que ce soit, le compilateur le fait pour nous!  Notre <code>is_lt</code> reste inchang√© et fonctionne juste tout en √©tant <code>constexpr</code> m√™me si nous n'avons pas explicitement sp√©cifi√© cela dans notre <code>operator&lt;=&gt;</code> d√©faut <code>operator&lt;=&gt;</code> .  C'est bien beau, mais certaines personnes peuvent se gratter la t√™te pour savoir pourquoi <code>is_lt</code> est toujours autoris√© √† compiler m√™me s'il n'utilise m√™me pas du tout l'op√©rateur du vaisseau spatial.  Explorons la r√©ponse √† cette question. <br><br><h2>  R√©√©crire des expressions </h2><br>  En C ++ 20, le compilateur est introduit dans un nouveau concept appel√© expressions ¬´r√©√©crites¬ª.  L'op√©rateur du vaisseau spatial, avec l' <code>operator==</code> , fait partie des deux premiers candidats soumis √† des expressions r√©√©crites.  Pour un exemple plus concret de r√©√©criture d'expression, d√©composons l'exemple fourni dans <code>is_lt</code> . <br><br>  Pendant la r√©solution de surcharge, le compilateur va s√©lectionner parmi un ensemble de candidats viables, qui correspondent tous √† l'op√©rateur que nous recherchons.  Le processus de collecte des candidats est tr√®s l√©g√®rement modifi√© pour le cas des op√©rations relationnelles et d'√©quivalence o√π le compilateur doit √©galement rassembler des candidats sp√©ciaux r√©√©crits et synth√©tis√©s ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[over.match.oper] /3.4</a> ). <br><br>  Pour notre expression <code>a &lt; b</code> la norme stipule que nous pouvons rechercher le type de a pour un <code>operator&lt;=&gt;</code> ou un <code>operator&lt;=&gt;</code> fonction de port√©e d'espace de noms <code>operator&lt;=&gt;</code> qui accepte son type.  Donc, le compilateur le fait et il constate qu'en fait, le type de <code>IntWrapper::operator&lt;=&gt;</code> .  Le compilateur est alors autoris√© √† utiliser cet op√©rateur et √† r√©√©crire l'expression <code>a &lt; b</code> as <code>(a &lt;=&gt; b) &lt; 0</code> .  Cette expression r√©√©crite est ensuite utilis√©e comme candidate √† une r√©solution de surcharge normale. <br><br>  Vous pouvez vous demander pourquoi cette expression r√©√©crite est valide et correcte.  La justesse de l'expression d√©coule en fait de la s√©mantique fournie par l'op√©rateur du vaisseau spatial.  Le <code>&lt;=&gt;</code> est une comparaison √† trois qui implique que vous obtenez non seulement un r√©sultat binaire, mais un ordre (dans la plupart des cas) et si vous avez un ordre, vous pouvez exprimer cet ordre en termes d'op√©rations relationnelles.  Un exemple rapide, l'expression 4 &lt;=&gt; 5 en C ++ 20 vous donnera le r√©sultat <code>std::strong_ordering::less</code> .  Le r√©sultat <code>std::strong_ordering::less</code> implique que <code>4</code> n'est pas seulement diff√©rent de <code>5</code> mais qu'il est strictement inf√©rieur √† cette valeur, ce qui rend l'application de l'op√©ration <code>(4 &lt;=&gt; 5) &lt; 0</code> correcte et exacte pour d√©crire notre r√©sultat. <br><br>  En utilisant les informations ci-dessus, le compilateur peut prendre n'importe quel op√©rateur relationnel g√©n√©ralis√© (c'est-√†-dire <code>&lt;</code> , <code>&gt;</code> , etc.) et le r√©√©crire en termes d'op√©rateur de vaisseau spatial.  Dans la norme, l'expression r√©√©crite est souvent appel√©e <code>(a &lt;=&gt; b) @ 0</code> o√π le <code>@</code> repr√©sente toute op√©ration relationnelle. <br><br><h2>  Synth√©tiser des expressions </h2><br>  Les lecteurs ont peut-√™tre remarqu√© la mention subtile des expressions "synth√©tis√©es" ci-dessus et ils jouent √©galement un r√¥le dans ce processus de r√©√©criture d'op√©rateur.  Consid√©rons une fonction de pr√©dicat diff√©rente: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_gt_42</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> &lt; a; }</code> </pre> <br>  Si nous utilisons notre d√©finition d'origine pour <code>IntWrapper</code> ce code ne sera pas compil√©. <br><br> <code>error C2677: binary '&lt;': no global operator found which takes type 'const IntWrapper' (or there is no acceptable conversion)</code> <br> <br>  Cela a du sens dans la version pr√©-C ++ 20, et la fa√ßon de r√©soudre ce probl√®me serait d'ajouter quelques fonctions suppl√©mentaires √† <code>IntWrapper</code> qui prennent un c√¥t√© gauche d' <code>int</code> .  Si vous essayez de cr√©er cet exemple avec un compilateur C ++ 20 et notre d√©finition C ++ 20 d' <code>IntWrapper</code> vous remarquerez peut-√™tre que, l√† encore, ¬´√ßa marche¬ª - un autre gratte-t√™te.  Examinons pourquoi le code ci-dessus est toujours autoris√© √† compiler en C ++ 20. <br><br>  Pendant la r√©solution de surcharge, le compilateur rassemblera √©galement ce que la norme appelle des candidats ¬´synth√©tis√©s¬ª ou une expression r√©√©crite avec l'ordre des param√®tres invers√©.  Dans l'exemple ci-dessus, le compilateur essaiera d'utiliser l'expression r√©√©crite <code>(42 &lt;=&gt; a) &lt; 0</code> mais il trouvera qu'il n'y a pas de conversion d' <code>IntWrapper</code> en <code>int</code> pour satisfaire le c√¥t√© gauche afin que l'expression r√©√©crite soit supprim√©e.  Le compilateur √©voque √©galement l'expression ¬´synth√©tis√©e¬ª <code>0 &lt; (a &lt;=&gt; 42)</code> et constate qu'il y a une conversion de <code>int</code> en <code>IntWrapper</code> via son constructeur de conversion, donc ce candidat est utilis√©. <br><br>  Le but des expressions synth√©tis√©es est d'√©viter le d√©sordre d'avoir √† √©crire le passe-partout des fonctions <code>friend</code> pour combler les lacunes o√π votre objet pourrait √™tre converti √† partir d'autres types.  Les expressions synth√©tis√©es sont g√©n√©ralis√©es √† <code>0 @ (b &lt;=&gt; a)</code> . <br><br><h2>  Types plus complexes </h2><br>  L'op√©rateur de vaisseau spatial g√©n√©r√© par le compilateur ne s'arr√™te pas aux membres uniques des classes, il g√©n√©rera un ensemble correct de comparaisons pour tous les sous-objets de vos types: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Basics</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f;  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d;  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Basics&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arrays</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai[<span class="hljs-number"><span class="hljs-number">1</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ac[<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> af[<span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ad[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arrays&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bases</span></span></span><span class="hljs-class"> :</span></span> Basics, Arrays {  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Bases&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases a = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases b = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a == b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a != b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &lt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &lt;= b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &gt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &gt;= b); }</code> </pre> <br>  Le compilateur sait comment d√©velopper les membres des classes qui sont des tableaux dans leurs listes de sous-objets et les comparer r√©cursivement.  Bien s√ªr, si vous vouliez √©crire vous-m√™me le corps de ces fonctions, vous b√©n√©ficiez toujours des expressions de r√©√©criture du compilateur pour vous. <br><br><h2>  Ressemble √† un canard, nage comme un canard et quacks comme <code>operator==</code> </h2><br>  Certaines personnes tr√®s intelligentes du comit√© de normalisation ont remarqu√© que l'op√©rateur du vaisseau spatial effectuera toujours une comparaison lexicographique des √©l√©ments, quoi qu'il arrive.  Des comparaisons lexicographiques inconditionnelles peuvent conduire √† un code g√©n√©r√© inefficace avec l'op√©rateur d'√©galit√© en particulier. <br><br>  L'exemple canonique compare deux cha√Ænes.  Si vous avez la cha√Æne <code>"foobar"</code> et que vous la comparez √† la cha√Æne <code>"foo"</code> utilisant == on s'attendrait √† ce que cette op√©ration soit presque constante.  L'algorithme de comparaison de cha√Ænes efficace est donc: <br><br><ul><li>  Comparez d'abord la taille des deux cha√Ænes, si les tailles diff√®rent, retournez <code>false</code> , sinon </li><li>  parcourez chaque √©l√©ment des deux cha√Ænes √† l'unisson et comparez jusqu'√† ce que l'on diff√®re ou que la fin soit atteinte, renvoyez le r√©sultat. </li></ul><br>  Selon les r√®gles de l'op√©rateur de vaisseau spatial, nous devons commencer par la comparaison approfondie de chaque √©l√©ment jusqu'√† ce que nous trouvions celui qui est diff√©rent.  Dans notre exemple de <code>"foobar"</code> et <code>"foo"</code> uniquement en comparant <code>'b'</code> √† <code>'\0'</code> , vous retournez finalement <code>false</code> . <br><br>  Pour lutter contre cela, il y avait un document, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1185R2,</a> qui d√©taille un moyen pour le compilateur de r√©√©crire et de g√©n√©rer l' <code>operator==</code> ind√©pendamment de l'op√©rateur du vaisseau spatial.  Notre <code>IntWrapper</code> pourrait s'√©crire comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default;  bool operator==(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Encore une √©tape ... cependant, il y a de bonnes nouvelles;  vous n'avez pas r√©ellement besoin d'√©crire le code ci-dessus, car il suffit d'√©crire <code>auto operator&lt;=&gt;(const IntWrapper&amp;) const = default</code> pour que le compilateur g√©n√®re implicitement l' <code>operator==</code> s√©par√© <code>operator==</code> et plus efficace <code>operator==</code> pour vous! <br><br>  Le compilateur applique une r√®gle de ¬´r√©√©criture¬ª l√©g√®rement modifi√©e sp√©cifique √† <code>==</code> et <code>!=</code> O√π ces op√©rateurs sont r√©√©crits en termes d' <code>operator==</code> et non d' <code>operator&lt;=&gt;</code> .  Cela signifie que <code>!=</code> B√©n√©ficie √©galement de l'optimisation. <br><br><h2>  L'ancien code ne se cassera pas </h2><br>  √Ä ce stade, vous pourriez penser, OK si le compilateur est autoris√© √† effectuer cette op√©ration de r√©√©criture d'op√©rateur ce qui se passe lorsque j'essaie de d√©jouer le compilateur: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }</code> </pre> <br>  La r√©ponse est que non.  Le mod√®le de r√©solution de surcharge en C ++ a cette ar√®ne o√π tous les candidats se battent, et dans cette bataille sp√©cifique, nous avons 3 candidats: <br><br><ul><li> <code>IntWrapper::operator&lt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> <li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> </ul><br>  (r√©√©crit) <br><br><ul><li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; b, const IntWrapper&amp; a)</code> </li> </ul><br>  (synth√©tis√©) <br><br>  Si nous avions accept√© les r√®gles de r√©solution de surcharge en C ++ 17, le r√©sultat de cet appel aurait √©t√© ambigu, mais les r√®gles de r√©solution de surcharge C ++ 20 ont √©t√© modifi√©es pour permettre au compilateur de r√©soudre cette situation √† la surcharge la plus logique. <br><br>  Il y a une phase de r√©solution de surcharge o√π le compilateur doit effectuer une s√©rie de bris d'√©galit√©.  En C ++ 20, il y a un nouveau bris d'√©galit√© qui stipule que nous devons pr√©f√©rer les surcharges qui ne sont pas r√©√©crites ou synth√©tis√©es, ce qui fait de notre surcharge <code>IntWrapper::operator&lt;</code> le meilleur candidat et r√©sout l'ambigu√Øt√©.  Ce m√™me m√©canisme emp√™che les candidats synth√©tis√©s de pi√©tiner des expressions r√©√©crites r√©guli√®res. <br><br><h2>  Pens√©es de cl√¥ture </h2><br>  L'op√©rateur de vaisseau spatial est un ajout bienvenu au C ++ et c'est l'une des fonctionnalit√©s qui simplifiera et vous aidera √† √©crire <i>moins de</i> code, et, parfois, moins c'est plus.  Alors, attachez-vous √† l'op√©rateur de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vaisseau spatial</a> de C ++ 20! <br><br>  Nous vous invitons √† sortir et essayer l'op√©rateur de vaisseau spatial, il est disponible d√®s maintenant dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Visual Studio 2019</a> sous <code>/std:c++latest</code> !  Remarque: les modifications introduites via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1185R2</a> seront disponibles dans Visual Studio 2019 version 16.2.  Veuillez garder √† l'esprit que l'op√©rateur du vaisseau spatial fait partie de C ++ 20 et est soumis √† certaines modifications jusqu'√† ce que C ++ 20 soit finalis√©. <br><br>  Comme toujours, nous appr√©cions vos commentaires.  N'h√©sitez pas √† envoyer vos commentaires par e-mail √† <a href="">visualcpp@microsoft.com</a> , via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Twitter @visualc</a> ou Facebook √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Microsoft Visual Cpp</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">N'h√©sitez</a> pas non plus √† me suivre sur Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@starfreakclone</a> . <br><br>  Si vous rencontrez d'autres probl√®mes avec MSVC dans VS 2019, veuillez nous en informer via l'option <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Signaler un probl√®me</a> , √† partir du programme d'installation ou de l'IDE Visual Studio lui-m√™me.  Pour des suggestions ou des rapports de bogues, faites-le nous savoir via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DevComm.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458248/">https://habr.com/ru/post/fr458248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458230/index.html">Comment l'IA, les drones et les cam√©ras assurent la s√©curit√© de nos routes et de nos ponts</a></li>
<li><a href="../fr458240/index.html">Comment l'intelligence artificielle, les drones et les cam√©ras assurent la s√©curit√© des routes et des ponts</a></li>
<li><a href="../fr458242/index.html">Le nouvel op√©rateur de vaisseau spatial en C ++ 20</a></li>
<li><a href="../fr458244/index.html">Une liste interminable et ridicule de ce que vous devez savoir pour utiliser en toute s√©curit√© les r√©seaux Wi-Fi publics</a></li>
<li><a href="../fr458246/index.html">Co√Øncidences al√©atoires dans la vie, ou comment il s'est av√©r√© qu'on vous a pr√©sent√© un g√¢teau dans une usine de tracteurs</a></li>
<li><a href="../fr458250/index.html">BTRFS pour les plus petits</a></li>
<li><a href="../fr458252/index.html">Mod√®le math√©matique d'un radiot√©lescope super long</a></li>
<li><a href="../fr458256/index.html">N'est-il pas temps pour le lavage de cerveau?</a></li>
<li><a href="../fr458260/index.html">Une autre fa√ßon d'optimiser les images Docker pour les applications Java</a></li>
<li><a href="../fr458262/index.html">Concepteur en ligne de la salle de r√©union - s√©lection de la solution optimale pour la visioconf√©rence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>