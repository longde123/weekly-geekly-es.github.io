<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🍳 🔺 🧕🏽 Verteilte Grafikverarbeitung mit Spark GraphX ◀️ ⛈️ ⚔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Einfachheit ist Voraussetzung für Zuverlässigkeit" von Edsger Dijkstra 

 Prolog 
 Grafiken sind eine so klare und leicht verständliche Datenstruktur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verteilte Grafikverarbeitung mit Spark GraphX</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415939/"><img src="https://spark.apache.org/docs/latest/img/graphx_logo.png" alt="Bild"><br><br>  <i>"Einfachheit ist Voraussetzung für Zuverlässigkeit" von Edsger Dijkstra</i> <br><br><h3>  Prolog </h3><br>  Grafiken sind eine so klare und leicht verständliche Datenstruktur, dass sie seit der Zeit von Leonhard Euler gezwungen sind, den Verstand der Menschheit über heterogene Aufgaben zu brechen, wie man alle sieben Brücken von Königsberg durchqueren kann, ohne sie zweimal zu durchlaufen, oder als reisender Vermittler am meisten zu finden profitable Route. <br><a name="habracut"></a><br>  Seit Euler hat sich viel geändert: Transistoren, Programmiersprachen und verteiltes Rechnen sind erschienen.  Es ist der letzte Teil dieser Liste, der das Speichern und Verarbeiten von Diagrammen erheblich vereinfacht hat.  Genau das wird in diesem Artikel besprochen. <br><br>  Wenn Sie mit den grundlegenden Apache Spark-Konzepten wie RDD, Treiberprogramm, Worker-Knoten usw. nicht vertraut sind, empfehlen wir Ihnen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> von Databricks zu lesen, bevor Sie mit diesem Artikel fortfahren. <br><br>  Für mich ist der beste Weg, mit einer Technologie umzugehen, zu versuchen, etwas darauf zu schreiben.  In diesem Artikel werden wir die Ähnlichkeit eines „sozialen Netzwerks“ anhand der Grundkonzepte der Graphentheorie analysieren. <br><br><h3>  Einen Code schreiben </h3><br>  Die von mir gewählte Methode zum Speichern unseres „sozialen Netzwerks“ war äußerst einfach und intuitiv: tsv-Dateien auf der Festplatte, natürlich können dies Dateien in jedem anderen Format wie Parquet, Avro sein.  Der Speicherort der Dateien spielt keine Rolle, ob es sich um HDFS oder S3 handelt, auch wenn wir etwas ändern müssen. Spark SQL erledigt die Hauptarbeit für uns.  Die Netzwerkstruktur sieht wie folgt aus: Die erste Datei besteht aus zwei Benutzer-IDs und deren Namen, die zweite Benutzer-ID-Datei und einer Liste von Peers.  Apache Spark unterstützt die folgenden Programmiersprachen Java, Scala und Python als APIs.  Ich habe den zweiten gewählt. <br><br>  Ich möchte sofort die beliebte Frage beantworten, ob es sich lohnt, Spark GraphX ​​zum Speichern von Diagrammen zu verwenden, wenn Sie viele Einfüge- / Aktualisierungsvorgänge haben. Die Antwort lautet: Nein, alle RDD-Änderungsvorgänge erzwingen das Ändern des gesamten RDD im Cluster. Dies ist nicht die optimale Lösung. Spezielle sind für diesen Fall geeignet NoSql-Lösung wie Neo4J, Titan oder sogar Cassandra, Hbase.  Nichts hindert Sie daran, Spark GraphX ​​speziell für die Verarbeitung von Diagrammen zu verwenden und die Daten selbst aus der Datenbank zu laden, z. B. per Sheduler oder in einem ereignisgesteuerten Stil. <br><br>  Dann fangen wir an, Code zu schreiben.  Zuerst müssen wir das Diagramm in den Speicher laden, die Quelldateien nehmen und die erforderlichen Eckpunkte und Kanten herausziehen (hier sind die Hauptpunkte, ein Link zur vollständigen Liste mit dem Quellcode befindet sich am Ende des Artikels): <br><br><pre><code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verts</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">RDD</span></span>[(<span class="hljs-type"><span class="hljs-type">VertexId</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>)] = sc.textFile(<span class="hljs-type"><span class="hljs-type">USER_NAMES</span></span>) .flatMap(<span class="hljs-type"><span class="hljs-type">InputDataFlow</span></span>.parseNames) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edges</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">RDD</span></span>[<span class="hljs-type"><span class="hljs-type">Edge</span></span>[<span class="hljs-type"><span class="hljs-type">PartitionID</span></span>]] = sc.textFile(<span class="hljs-type"><span class="hljs-type">USER_GRAPH</span></span>) .flatMap(<span class="hljs-type"><span class="hljs-type">InputDataFlow</span></span>.makeEdges)</code> </pre> <br><h3>  Pregel </h3><br>  Der Hauptmechanismus für die Graphiteration in GraphX ​​ist der Pregel-Algorithmus.  Der Algorithmus wurde von Google entwickelt. Das Pregel-Modell verwendet die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übertragung von Nachrichten</a> zwischen den Scheitelpunkten im Diagramm.  Die Nachricht, die eine Reihe von Iterationen durchläuft, die als Supersteps bezeichnet werden, ist die Hauptidee dieses Algorithmus.  Die Hauptidee kann auch wie folgt beschrieben werden: <i>„Denken Sie wie ein Scheitelpunkt“</i> , <i>dh</i> der Zustand des aktuellen Scheitelpunkts hängt nur vom Zustand seiner Nachbarn ab. <br><br>  Pregel wird extrem notwendig, wenn das Lösen eines Problems mit einem regulären MapReduce zu einem extrem schwierigen Prozess wird.  Interessanterweise leitet sich der Name Pregel vom Namen des Flusses ab, der die sieben Brücken von Königsberg überspannte. <br><br>  Das Hauptprimitiv für das Durchlaufen eines Graphen ist ein Triplett - es besteht aus den folgenden Komponenten: dem aktuellen Scheitelpunkt (einem Quellscheitelpunkt), dem Scheitelpunkt, an den wir übergeben (einem Zielscheitelpunkt) und der Kante zwischen ihnen (einer Kantenverbindung) - alles ist klar: wo Geh wohin wir gehen und welchen Weg wir gehen.  Außerdem müssen Sie für Pregel den Standardabstand zwischen den Scheitelpunkten angeben. In der Regel handelt es sich um eine PositiveInfinity, UDF-Funktion (benutzerdefinierte Funktion) für jeden Scheitelpunkt, um die eingehende Nachricht zu verarbeiten und den nächsten Scheitelpunkt zu berechnen, und UDF, um die beiden eingehenden Nachrichten zusammenzuführen. Diese Funktion sollte kommutativ sein assoziativ.  Da Scala eine funktionale Sprache ist, werden die letzten beiden Funktionen als zwei Lambda-Ausdrücke dargestellt. <br><br>  Wenn wir die Hauptkomponenten von Pregel auseinander genommen haben, lohnt es sich, zum Üben zu kommen.  Der erste Algorithmus, den wir implementieren werden, ist der Dijkstra-Algorithmus zum Finden des kürzesten Wegs von einem beliebigen Scheitelpunkt zu allen anderen. <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dijkstraShortestPath</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">VT</span></span>](graph: <span class="hljs-type"><span class="hljs-type">GenericGraph</span></span>[<span class="hljs-type"><span class="hljs-type">VT</span></span>], sourceId: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> initialGraph = graph.mapVertices((id, _) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == sourceId) <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sssp = initialGraph.pregel(<span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>)( (_, dist, newDist) =&gt; math.min(dist, newDist), triplet =&gt; { <span class="hljs-comment"><span class="hljs-comment">//Distance accumulator if (triplet.srcAttr + triplet.attr &lt; triplet.dstAttr) { Iterator((triplet.dstId, triplet.srcAttr + triplet.attr)) } else { Iterator.empty } }, (a, b) =&gt; math.min(a, b) ) sssp.vertices.sortByKey(ascending = true).collect.mkString("\n") }</span></span></code> </pre> <br>  Hier ist alles klar: Wir gehen von einem bestimmten Scheitelpunkt aus und bestimmen mit der Minimalfunktion den Mindestabstand bei jedem Schritt.  Die erste von Pregel verwendete Funktion behält den kürzesten Abstand zwischen der eingehenden Nachricht und dem aktuellen Scheitelpunkt bei.  Die zweite Funktion verteilt Nachrichten an Nachbarn, während der Abstand eingehalten wird.  Die letzte Funktion - dies ist ein Analogon der Stufe Reduzieren - wählt bei mehreren eingehenden Nachrichten den Mindestwert aus.  Als nächstes bilden wir einfach eine bequeme Grafikausgabe. <br><br><h3>  Trennungsgrad </h3><br>  Ich bin sicher, dass viele Leser dieses Artikels von der Theorie der sechs Handshakes ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sechs Trennungsgrade</a> ) gehört haben - dies ist eine unbewiesene Theorie, nach der zwei Personen durch nicht mehr als fünf Ebenen gemeinsamer Bekanntschaften getrennt sind, dh es sind maximal 6 Handshakes erforderlich, um zwei willkürliche zu verbinden Mann auf Erden.  In Bezug auf die Graphentheorie klingt dies so: Der Durchmesser des Datierungsgraphen überschreitet 6 für zwei Menschen auf der Erde nicht. <br><br>  Beginnen wir mit dem Schreiben des Codes wie folgt: Wir benötigen eine Breitensuche im Diagramm, um nach Kontakten des angegebenen Scheitelpunkts zu suchen. Dazu müssen wir den Dijkstra-Algorithmuscode ändern: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBFS</span></span></span></span>(root: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> initialGraph = graph.mapVertices((id, _) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == root) <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bfs = initialGraph.pregel(<span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>, maxIterations = <span class="hljs-number"><span class="hljs-number">10</span></span>)( (_, attr, msg) =&gt; math.min(attr, msg), triplet =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (triplet.srcAttr != <span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>) { <span class="hljs-type"><span class="hljs-type">Iterator</span></span>((triplet.dstId, triplet.srcAttr + <span class="hljs-number"><span class="hljs-number">1</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-type"><span class="hljs-type">Iterator</span></span>.empty } }, (a, b) =&gt; math.min(a, b)).cache() bfs }</code> </pre> <br>  Alles ist sehr ähnlich zu dem, was oben war, aber wir geben bereits die Anzahl der Iterationen an - für Ihr Diagramm kann dies eine andere Zahl sein - 10 für mein Diagramm, das ich empirisch erhalten habe.  Als nächstes verbinden Sie sich mit Benutzernamen und nehmen die ersten 100 Werte für einen beliebigen Benutzer: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">degreeOfSeparation</span></span></span></span>(root: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>): <span class="hljs-type"><span class="hljs-type">Array</span></span>[(<span class="hljs-type"><span class="hljs-type">VertexId</span></span>, <span class="hljs-type"><span class="hljs-type">DegreeOfSeparation</span></span>)] = { getBFS(root).vertices.join(verts).take(<span class="hljs-number"><span class="hljs-number">100</span></span>) }</code> </pre> <br>  Jetzt suchen wir nach dem Trennungsgrad vom angegebenen Scheitelpunkt zu allen anderen. Sie können auch nach dem Trennungsgrad für zwei beliebige Scheitelpunkte suchen: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">degreeOfSeparationTwoUser</span></span></span></span>(firstUser: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>, secondUser: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>) = { getBFS(firstUser) .vertices .filter { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (vertexId, _) =&gt; vertexId == secondUser } .collect.map { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (_, degree) =&gt; degree } }</code> </pre> <br>  Spark GraphX ​​aus der Box bietet Ihnen die Möglichkeit, viele Informationen über das Diagramm abzurufen, z. B. um die verbundene Komponente des Diagramms (verbundene Komponente) abzurufen: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMostConnectedUsers</span></span></span></span>(amount: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Array</span></span>[(<span class="hljs-type"><span class="hljs-type">VertexId</span></span>, <span class="hljs-type"><span class="hljs-type">ConnectedUser</span></span>)] = { graph.degrees.join(verts) .sortBy({ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (_, (userName, _)) =&gt; userName }, ascending = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) .take(amount) }</code> </pre> <br>  Oder erhalten Sie eine Metrik wie die Anzahl der Dreiecke im Diagramm (Anzahl der Dreiecke): <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">socialGraphTriangleCount</span></span></span><span class="hljs-function"> </span></span>= graph.triangleCount()</code> </pre> <br><h3>  Seitenrang </h3><br>  Der PageRank-Algorithmus wurde dank der Stanford-Studenten Larry Page und Sergey Brin entwickelt.  Für jeden Scheitelpunkt des Graphen weist der Algorithmus allen anderen eine Bedeutung zu.  Wenn ein Twitter-Benutzer beispielsweise eine große Anzahl von Abonnements von anderen Benutzern hat, hat er eine hohe Bewertung, sodass er leicht in der Suchmaschine gefunden werden kann. <br><br>  GraphX ​​verfügt über eine statische und dynamische Version der PageRank-Implementierung.  Die statische Version hat eine feste Anzahl von Iterationen, während die dynamische Version so lange funktioniert, bis die Bewertung auf den angegebenen Wert konvergiert. <br><br>  Für unser Diagramm ist dies wie folgt: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dynamicRanks</span></span></span></span>(socialGraph: <span class="hljs-type"><span class="hljs-type">SocialGraph</span></span>, tolerance: <span class="hljs-type"><span class="hljs-type">Double</span></span>) = socialGraph.graph.pageRank(tol = tolerance).vertices <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticRanks</span></span></span></span>(socialGraph: <span class="hljs-type"><span class="hljs-type">SocialGraph</span></span>, tolerance: <span class="hljs-type"><span class="hljs-type">Double</span></span>) = socialGraph.graph.staticPageRank(numIter = <span class="hljs-number"><span class="hljs-number">20</span></span>).vertices</code> </pre> <br><h3>  Fazit </h3><br>  Ein aufmerksamer Leser stellte fest, dass das Thema dieses Artikels die verteilte Verarbeitung von Diagrammen ist. Beim Schreiben von Code haben wir jedoch nichts unternommen, um die Verarbeitung wirklich zu verteilen.  Und hier sollten wir uns ganz am Anfang an das Zitat von Edsger Dijkstra erinnern.  Spark vereinfacht unser Leben dramatisch, indem es die Last und die Lasten des verteilten Rechnens übernimmt.  Das Schreiben von Code, der in einem verteilten Cluster ausgeführt wird, ist keine so schwierige Aufgabe, wie es am Anfang schien.  Und hier gibt es sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehrere Optionen</a> zum Verwalten von Clusterressourcen: Hadoop YARN, Apache Mesos (persönlich meine Lieblingsoption) und in jüngerer Zeit gibt es Unterstützung für Kubernetes.  Der gesamte Quellcode, der in diesem Artikel analysiert wurde, befindet sich auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415939/">https://habr.com/ru/post/de415939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415927/index.html">Industrielampe Breeze 50</a></li>
<li><a href="../de415929/index.html">Optimierung der Architektur der künstlichen Intelligenz: Das Rennen beginnt</a></li>
<li><a href="../de415933/index.html">So erstellen Sie eine IIoT-Architektur zum Selbermachen</a></li>
<li><a href="../de415935/index.html">Insertion Sorts</a></li>
<li><a href="../de415937/index.html">Die japanische Privatrakete MOMO-2 explodierte auf der Startrampe</a></li>
<li><a href="../de415941/index.html">Wie wir versucht haben, Barcodes herauszufinden und nichts verstanden haben</a></li>
<li><a href="../de415943/index.html">"Spieleentwicklung und Unterhaltungstheorie": Wichtige Punkte aus Raff Costers Buch</a></li>
<li><a href="../de415945/index.html">Neue chinesische SPS mit Aliexpress: Wecon LX3VP / LX3VE</a></li>
<li><a href="../de415947/index.html">Fehlerkompensationssystem für die Installation von optischen Fasern während der Verarbeitung durch Laserstrahlung während der Rotation</a></li>
<li><a href="../de415949/index.html">High Mining: Die neueste Option zum Schutz der PoW-Blockchain vor einem „51% -Angriff“.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>