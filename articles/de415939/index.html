<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüç≥ üî∫ üßïüèΩ Verteilte Grafikverarbeitung mit Spark GraphX ‚óÄÔ∏è ‚õàÔ∏è ‚öîÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Einfachheit ist Voraussetzung f√ºr Zuverl√§ssigkeit" von Edsger Dijkstra 

 Prolog 
 Grafiken sind eine so klare und leicht verst√§ndliche Datenstruktur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verteilte Grafikverarbeitung mit Spark GraphX</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415939/"><img src="https://spark.apache.org/docs/latest/img/graphx_logo.png" alt="Bild"><br><br>  <i>"Einfachheit ist Voraussetzung f√ºr Zuverl√§ssigkeit" von Edsger Dijkstra</i> <br><br><h3>  Prolog </h3><br>  Grafiken sind eine so klare und leicht verst√§ndliche Datenstruktur, dass sie seit der Zeit von Leonhard Euler gezwungen sind, den Verstand der Menschheit √ºber heterogene Aufgaben zu brechen, wie man alle sieben Br√ºcken von K√∂nigsberg durchqueren kann, ohne sie zweimal zu durchlaufen, oder als reisender Vermittler am meisten zu finden profitable Route. <br><a name="habracut"></a><br>  Seit Euler hat sich viel ge√§ndert: Transistoren, Programmiersprachen und verteiltes Rechnen sind erschienen.  Es ist der letzte Teil dieser Liste, der das Speichern und Verarbeiten von Diagrammen erheblich vereinfacht hat.  Genau das wird in diesem Artikel besprochen. <br><br>  Wenn Sie mit den grundlegenden Apache Spark-Konzepten wie RDD, Treiberprogramm, Worker-Knoten usw. nicht vertraut sind, empfehlen wir Ihnen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> von Databricks zu lesen, bevor Sie mit diesem Artikel fortfahren. <br><br>  F√ºr mich ist der beste Weg, mit einer Technologie umzugehen, zu versuchen, etwas darauf zu schreiben.  In diesem Artikel werden wir die √Ñhnlichkeit eines ‚Äûsozialen Netzwerks‚Äú anhand der Grundkonzepte der Graphentheorie analysieren. <br><br><h3>  Einen Code schreiben </h3><br>  Die von mir gew√§hlte Methode zum Speichern unseres ‚Äûsozialen Netzwerks‚Äú war √§u√üerst einfach und intuitiv: tsv-Dateien auf der Festplatte, nat√ºrlich k√∂nnen dies Dateien in jedem anderen Format wie Parquet, Avro sein.  Der Speicherort der Dateien spielt keine Rolle, ob es sich um HDFS oder S3 handelt, auch wenn wir etwas √§ndern m√ºssen. Spark SQL erledigt die Hauptarbeit f√ºr uns.  Die Netzwerkstruktur sieht wie folgt aus: Die erste Datei besteht aus zwei Benutzer-IDs und deren Namen, die zweite Benutzer-ID-Datei und einer Liste von Peers.  Apache Spark unterst√ºtzt die folgenden Programmiersprachen Java, Scala und Python als APIs.  Ich habe den zweiten gew√§hlt. <br><br>  Ich m√∂chte sofort die beliebte Frage beantworten, ob es sich lohnt, Spark GraphX ‚Äã‚Äãzum Speichern von Diagrammen zu verwenden, wenn Sie viele Einf√ºge- / Aktualisierungsvorg√§nge haben. Die Antwort lautet: Nein, alle RDD-√Ñnderungsvorg√§nge erzwingen das √Ñndern des gesamten RDD im Cluster. Dies ist nicht die optimale L√∂sung. Spezielle sind f√ºr diesen Fall geeignet NoSql-L√∂sung wie Neo4J, Titan oder sogar Cassandra, Hbase.  Nichts hindert Sie daran, Spark GraphX ‚Äã‚Äãspeziell f√ºr die Verarbeitung von Diagrammen zu verwenden und die Daten selbst aus der Datenbank zu laden, z. B. per Sheduler oder in einem ereignisgesteuerten Stil. <br><br>  Dann fangen wir an, Code zu schreiben.  Zuerst m√ºssen wir das Diagramm in den Speicher laden, die Quelldateien nehmen und die erforderlichen Eckpunkte und Kanten herausziehen (hier sind die Hauptpunkte, ein Link zur vollst√§ndigen Liste mit dem Quellcode befindet sich am Ende des Artikels): <br><br><pre><code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verts</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">RDD</span></span>[(<span class="hljs-type"><span class="hljs-type">VertexId</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>)] = sc.textFile(<span class="hljs-type"><span class="hljs-type">USER_NAMES</span></span>) .flatMap(<span class="hljs-type"><span class="hljs-type">InputDataFlow</span></span>.parseNames) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edges</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">RDD</span></span>[<span class="hljs-type"><span class="hljs-type">Edge</span></span>[<span class="hljs-type"><span class="hljs-type">PartitionID</span></span>]] = sc.textFile(<span class="hljs-type"><span class="hljs-type">USER_GRAPH</span></span>) .flatMap(<span class="hljs-type"><span class="hljs-type">InputDataFlow</span></span>.makeEdges)</code> </pre> <br><h3>  Pregel </h3><br>  Der Hauptmechanismus f√ºr die Graphiteration in GraphX ‚Äã‚Äãist der Pregel-Algorithmus.  Der Algorithmus wurde von Google entwickelt. Das Pregel-Modell verwendet die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbertragung von Nachrichten</a> zwischen den Scheitelpunkten im Diagramm.  Die Nachricht, die eine Reihe von Iterationen durchl√§uft, die als Supersteps bezeichnet werden, ist die Hauptidee dieses Algorithmus.  Die Hauptidee kann auch wie folgt beschrieben werden: <i>‚ÄûDenken Sie wie ein Scheitelpunkt‚Äú</i> , <i>dh</i> der Zustand des aktuellen Scheitelpunkts h√§ngt nur vom Zustand seiner Nachbarn ab. <br><br>  Pregel wird extrem notwendig, wenn das L√∂sen eines Problems mit einem regul√§ren MapReduce zu einem extrem schwierigen Prozess wird.  Interessanterweise leitet sich der Name Pregel vom Namen des Flusses ab, der die sieben Br√ºcken von K√∂nigsberg √ºberspannte. <br><br>  Das Hauptprimitiv f√ºr das Durchlaufen eines Graphen ist ein Triplett - es besteht aus den folgenden Komponenten: dem aktuellen Scheitelpunkt (einem Quellscheitelpunkt), dem Scheitelpunkt, an den wir √ºbergeben (einem Zielscheitelpunkt) und der Kante zwischen ihnen (einer Kantenverbindung) - alles ist klar: wo Geh wohin wir gehen und welchen Weg wir gehen.  Au√üerdem m√ºssen Sie f√ºr Pregel den Standardabstand zwischen den Scheitelpunkten angeben. In der Regel handelt es sich um eine PositiveInfinity, UDF-Funktion (benutzerdefinierte Funktion) f√ºr jeden Scheitelpunkt, um die eingehende Nachricht zu verarbeiten und den n√§chsten Scheitelpunkt zu berechnen, und UDF, um die beiden eingehenden Nachrichten zusammenzuf√ºhren. Diese Funktion sollte kommutativ sein assoziativ.  Da Scala eine funktionale Sprache ist, werden die letzten beiden Funktionen als zwei Lambda-Ausdr√ºcke dargestellt. <br><br>  Wenn wir die Hauptkomponenten von Pregel auseinander genommen haben, lohnt es sich, zum √úben zu kommen.  Der erste Algorithmus, den wir implementieren werden, ist der Dijkstra-Algorithmus zum Finden des k√ºrzesten Wegs von einem beliebigen Scheitelpunkt zu allen anderen. <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dijkstraShortestPath</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">VT</span></span>](graph: <span class="hljs-type"><span class="hljs-type">GenericGraph</span></span>[<span class="hljs-type"><span class="hljs-type">VT</span></span>], sourceId: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> initialGraph = graph.mapVertices((id, _) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == sourceId) <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sssp = initialGraph.pregel(<span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>)( (_, dist, newDist) =&gt; math.min(dist, newDist), triplet =&gt; { <span class="hljs-comment"><span class="hljs-comment">//Distance accumulator if (triplet.srcAttr + triplet.attr &lt; triplet.dstAttr) { Iterator((triplet.dstId, triplet.srcAttr + triplet.attr)) } else { Iterator.empty } }, (a, b) =&gt; math.min(a, b) ) sssp.vertices.sortByKey(ascending = true).collect.mkString("\n") }</span></span></code> </pre> <br>  Hier ist alles klar: Wir gehen von einem bestimmten Scheitelpunkt aus und bestimmen mit der Minimalfunktion den Mindestabstand bei jedem Schritt.  Die erste von Pregel verwendete Funktion beh√§lt den k√ºrzesten Abstand zwischen der eingehenden Nachricht und dem aktuellen Scheitelpunkt bei.  Die zweite Funktion verteilt Nachrichten an Nachbarn, w√§hrend der Abstand eingehalten wird.  Die letzte Funktion - dies ist ein Analogon der Stufe Reduzieren - w√§hlt bei mehreren eingehenden Nachrichten den Mindestwert aus.  Als n√§chstes bilden wir einfach eine bequeme Grafikausgabe. <br><br><h3>  Trennungsgrad </h3><br>  Ich bin sicher, dass viele Leser dieses Artikels von der Theorie der sechs Handshakes ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sechs Trennungsgrade</a> ) geh√∂rt haben - dies ist eine unbewiesene Theorie, nach der zwei Personen durch nicht mehr als f√ºnf Ebenen gemeinsamer Bekanntschaften getrennt sind, dh es sind maximal 6 Handshakes erforderlich, um zwei willk√ºrliche zu verbinden Mann auf Erden.  In Bezug auf die Graphentheorie klingt dies so: Der Durchmesser des Datierungsgraphen √ºberschreitet 6 f√ºr zwei Menschen auf der Erde nicht. <br><br>  Beginnen wir mit dem Schreiben des Codes wie folgt: Wir ben√∂tigen eine Breitensuche im Diagramm, um nach Kontakten des angegebenen Scheitelpunkts zu suchen. Dazu m√ºssen wir den Dijkstra-Algorithmuscode √§ndern: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBFS</span></span></span></span>(root: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> initialGraph = graph.mapVertices((id, _) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == root) <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bfs = initialGraph.pregel(<span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>, maxIterations = <span class="hljs-number"><span class="hljs-number">10</span></span>)( (_, attr, msg) =&gt; math.min(attr, msg), triplet =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (triplet.srcAttr != <span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>) { <span class="hljs-type"><span class="hljs-type">Iterator</span></span>((triplet.dstId, triplet.srcAttr + <span class="hljs-number"><span class="hljs-number">1</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-type"><span class="hljs-type">Iterator</span></span>.empty } }, (a, b) =&gt; math.min(a, b)).cache() bfs }</code> </pre> <br>  Alles ist sehr √§hnlich zu dem, was oben war, aber wir geben bereits die Anzahl der Iterationen an - f√ºr Ihr Diagramm kann dies eine andere Zahl sein - 10 f√ºr mein Diagramm, das ich empirisch erhalten habe.  Als n√§chstes verbinden Sie sich mit Benutzernamen und nehmen die ersten 100 Werte f√ºr einen beliebigen Benutzer: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">degreeOfSeparation</span></span></span></span>(root: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>): <span class="hljs-type"><span class="hljs-type">Array</span></span>[(<span class="hljs-type"><span class="hljs-type">VertexId</span></span>, <span class="hljs-type"><span class="hljs-type">DegreeOfSeparation</span></span>)] = { getBFS(root).vertices.join(verts).take(<span class="hljs-number"><span class="hljs-number">100</span></span>) }</code> </pre> <br>  Jetzt suchen wir nach dem Trennungsgrad vom angegebenen Scheitelpunkt zu allen anderen. Sie k√∂nnen auch nach dem Trennungsgrad f√ºr zwei beliebige Scheitelpunkte suchen: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">degreeOfSeparationTwoUser</span></span></span></span>(firstUser: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>, secondUser: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>) = { getBFS(firstUser) .vertices .filter { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (vertexId, _) =&gt; vertexId == secondUser } .collect.map { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (_, degree) =&gt; degree } }</code> </pre> <br>  Spark GraphX ‚Äã‚Äãaus der Box bietet Ihnen die M√∂glichkeit, viele Informationen √ºber das Diagramm abzurufen, z. B. um die verbundene Komponente des Diagramms (verbundene Komponente) abzurufen: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMostConnectedUsers</span></span></span></span>(amount: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Array</span></span>[(<span class="hljs-type"><span class="hljs-type">VertexId</span></span>, <span class="hljs-type"><span class="hljs-type">ConnectedUser</span></span>)] = { graph.degrees.join(verts) .sortBy({ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (_, (userName, _)) =&gt; userName }, ascending = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) .take(amount) }</code> </pre> <br>  Oder erhalten Sie eine Metrik wie die Anzahl der Dreiecke im Diagramm (Anzahl der Dreiecke): <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">socialGraphTriangleCount</span></span></span><span class="hljs-function"> </span></span>= graph.triangleCount()</code> </pre> <br><h3>  Seitenrang </h3><br>  Der PageRank-Algorithmus wurde dank der Stanford-Studenten Larry Page und Sergey Brin entwickelt.  F√ºr jeden Scheitelpunkt des Graphen weist der Algorithmus allen anderen eine Bedeutung zu.  Wenn ein Twitter-Benutzer beispielsweise eine gro√üe Anzahl von Abonnements von anderen Benutzern hat, hat er eine hohe Bewertung, sodass er leicht in der Suchmaschine gefunden werden kann. <br><br>  GraphX ‚Äã‚Äãverf√ºgt √ºber eine statische und dynamische Version der PageRank-Implementierung.  Die statische Version hat eine feste Anzahl von Iterationen, w√§hrend die dynamische Version so lange funktioniert, bis die Bewertung auf den angegebenen Wert konvergiert. <br><br>  F√ºr unser Diagramm ist dies wie folgt: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dynamicRanks</span></span></span></span>(socialGraph: <span class="hljs-type"><span class="hljs-type">SocialGraph</span></span>, tolerance: <span class="hljs-type"><span class="hljs-type">Double</span></span>) = socialGraph.graph.pageRank(tol = tolerance).vertices <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticRanks</span></span></span></span>(socialGraph: <span class="hljs-type"><span class="hljs-type">SocialGraph</span></span>, tolerance: <span class="hljs-type"><span class="hljs-type">Double</span></span>) = socialGraph.graph.staticPageRank(numIter = <span class="hljs-number"><span class="hljs-number">20</span></span>).vertices</code> </pre> <br><h3>  Fazit </h3><br>  Ein aufmerksamer Leser stellte fest, dass das Thema dieses Artikels die verteilte Verarbeitung von Diagrammen ist. Beim Schreiben von Code haben wir jedoch nichts unternommen, um die Verarbeitung wirklich zu verteilen.  Und hier sollten wir uns ganz am Anfang an das Zitat von Edsger Dijkstra erinnern.  Spark vereinfacht unser Leben dramatisch, indem es die Last und die Lasten des verteilten Rechnens √ºbernimmt.  Das Schreiben von Code, der in einem verteilten Cluster ausgef√ºhrt wird, ist keine so schwierige Aufgabe, wie es am Anfang schien.  Und hier gibt es sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehrere Optionen</a> zum Verwalten von Clusterressourcen: Hadoop YARN, Apache Mesos (pers√∂nlich meine Lieblingsoption) und in j√ºngerer Zeit gibt es Unterst√ºtzung f√ºr Kubernetes.  Der gesamte Quellcode, der in diesem Artikel analysiert wurde, befindet sich auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415939/">https://habr.com/ru/post/de415939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415927/index.html">Industrielampe Breeze 50</a></li>
<li><a href="../de415929/index.html">Optimierung der Architektur der k√ºnstlichen Intelligenz: Das Rennen beginnt</a></li>
<li><a href="../de415933/index.html">So erstellen Sie eine IIoT-Architektur zum Selbermachen</a></li>
<li><a href="../de415935/index.html">Insertion Sorts</a></li>
<li><a href="../de415937/index.html">Die japanische Privatrakete MOMO-2 explodierte auf der Startrampe</a></li>
<li><a href="../de415941/index.html">Wie wir versucht haben, Barcodes herauszufinden und nichts verstanden haben</a></li>
<li><a href="../de415943/index.html">"Spieleentwicklung und Unterhaltungstheorie": Wichtige Punkte aus Raff Costers Buch</a></li>
<li><a href="../de415945/index.html">Neue chinesische SPS mit Aliexpress: Wecon LX3VP / LX3VE</a></li>
<li><a href="../de415947/index.html">Fehlerkompensationssystem f√ºr die Installation von optischen Fasern w√§hrend der Verarbeitung durch Laserstrahlung w√§hrend der Rotation</a></li>
<li><a href="../de415949/index.html">High Mining: Die neueste Option zum Schutz der PoW-Blockchain vor einem ‚Äû51% -Angriff‚Äú.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>