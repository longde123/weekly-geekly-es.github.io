<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âœ´ï¸ ğŸ‘¨ğŸ¿â€ğŸ¤ ğŸš‘ Hasura. GraphQL Kinerja Tinggi untuk Arsitektur SQL Server ğŸš ğŸ§• ğŸ›€ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya hadir untuk Anda terjemahan artikel "Arsitektur GraphQL berkinerja tinggi ke mesin SQL" . 

 Ini adalah terjemahan dari artikel tenta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hasura. GraphQL Kinerja Tinggi untuk Arsitektur SQL Server</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428133/">  Halo, Habr!  Saya hadir untuk Anda terjemahan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Arsitektur GraphQL berkinerja tinggi ke mesin SQL"</a> . <br><br>  Ini adalah terjemahan dari artikel tentang bagaimana strukturnya terstruktur secara internal dan solusi optimalisasi dan arsitektur apa yang dibawa Hasura - server GraphQL ringan berkinerja tinggi, yang bertindak sebagai lapisan antara aplikasi web Anda dan database PostgreSQL. <br><br>  Ini memungkinkan Anda untuk menghasilkan skema GraphQL berdasarkan pada database yang ada atau membuat yang baru.  Ini mendukung Langganan GraphQL dari kotak berdasarkan pemicu Postgres, kontrol akses dinamis, pembuatan gabungan otomatis, menyelesaikan masalah permintaan N + 1 (batching) dan banyak lagi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tb/tq/nt/tbtqntldyuxalrgy5wvz9exu5kc.png" width="400"></div><a name="habracut"></a><br>  Anda dapat menggunakan batasan kunci asing di PostgreSQL untuk mengambil data hierarkis dalam satu permintaan.  Misalnya, Anda dapat menjalankan kueri ini untuk mendapatkan album dan trek yang sesuai (jika kunci asing dibuat di tabel "trek" yang menunjuk ke tabel "album") <br><br><pre><code class="hljs dos">{ album (where: {year: {_eq: <span class="hljs-number"><span class="hljs-number">2018</span></span>}}) { <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> tracks { id <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> } } }</code> </pre> <br>  Seperti yang sudah Anda tebak, Anda dapat meminta data dengan kedalaman apa pun.  API ini, dikombinasikan dengan kontrol akses, memungkinkan aplikasi web untuk meminta data dari PostgreSQL tanpa menulis backend mereka sendiri.  Ini dirancang untuk memenuhi permintaan secepat mungkin, memiliki bandwidth tinggi, sekaligus menghemat waktu prosesor dan konsumsi memori di server.  Kami akan berbicara tentang solusi arsitektur yang memungkinkan kami untuk mencapai ini. <br><br><h2>  Minta Siklus Hidup </h2><br>  Permintaan yang dikirim ke Hasura melewati tahapan berikut: <br><br><ol><li>  <b>Sesi penerimaan</b> : Permintaan masuk ke gateway, yang memeriksa kunci (jika ada) dan menambahkan berbagai tajuk, misalnya, peran pengidentifikasi dan pengguna. </li><li>  Penguraian <b>kueri</b> : Hasura menerima kueri, mengurai header untuk mendapatkan informasi pengguna, membuat GraphQL AST berdasarkan pada badan permintaan. </li><li>  <b>Validasi permintaan</b> : Ini memeriksa apakah permintaan secara semantik benar, maka hak akses yang sesuai dengan peran pengguna diterapkan. </li><li>  <b>Eksekusi Query</b> : Query dikonversi ke SQL dan dikirim ke Postgres. </li><li>  <b>Generasi respons</b> : Hasil kueri SQL diproses dan dikirim ke klien ( <i>gateway dapat menggunakan gzip jika perlu</i> ). </li></ol><br><h2>  Tujuan </h2><br>  Persyaratannya kira-kira sebagai berikut: <br><br><ol><li>  Stack HTTP harus menambahkan overhead minimum dan dapat menangani banyak permintaan bersamaan untuk throughput tinggi. </li><li>  Pembuatan SQL cepat dari permintaan GraphQL. </li><li>  Query SQL yang dihasilkan harus efisien untuk Postgres. </li><li>  Hasil dari query SQL harus secara efektif dikembalikan dari Postgres. </li></ol><br><h2>  Pemrosesan permintaan GraphQL </h2><br>  Ada beberapa pendekatan untuk mendapatkan data yang diperlukan untuk permintaan GraphQL: <br><br><h3>  Penyelesai konvensional </h3><br>  Menjalankan query GraphQL biasanya melibatkan pemanggilan resolver untuk setiap bidang. <br>  Dalam contoh permintaan, kami mendapatkan album yang dirilis pada tahun 2018, dan kemudian untuk masing-masing kami meminta trek yang sesuai dengannya - masalah klasik permintaan N +1.  Jumlah kueri tumbuh secara eksponensial dengan meningkatnya kedalaman kueri. <br><br>  Permintaan yang dibuat oleh Postgres adalah: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>,title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> album <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> = <span class="hljs-number"><span class="hljs-number">2018</span></span>;</code> </pre><br>  Permintaan ini akan mengembalikan semua album kepada kami.  Misalkan jumlah album yang dikembalikan oleh permintaan sama dengan N. Kemudian untuk setiap album kami akan menjalankan permintaan berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>,title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tracks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> album_id = &lt;album-<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&gt;</code> </pre><br>  Secara total, Anda mendapatkan N + 1 kueri untuk mendapatkan semua data yang diperlukan. <br><br><h3>  Permintaan batching </h3><br>  Alat-alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dataloader</a> dirancang untuk memecahkan masalah permintaan N + 1 menggunakan batching.  Jumlah kueri SQL untuk data yang disematkan tidak lagi tergantung pada ukuran sampel awal, karena  Sekarang itu mempengaruhi jumlah node dalam permintaan GraphQL.  Dalam hal ini, 2 permintaan kepada Postgres diperlukan untuk mendapatkan data yang diperlukan: <br><br>  Kami mendapat album: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>,title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> album <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> = <span class="hljs-number"><span class="hljs-number">2018</span></span></code> </pre><br>  Kami mendapatkan trek untuk album yang kami terima di permintaan sebelumnya: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tracks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> album_id <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> {the <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> album ids}</code> </pre><br>  Secara total, 2 kueri diterima.  Kami menghindari mengeksekusi query SQL pada trek untuk setiap album individual, sebagai gantinya, kami menggunakan operator WHERE untuk mendapatkan semua trek yang diperlukan dalam satu permintaan sekaligus. <br><br><h3>  Bergabung </h3><br>  Dataloader dirancang untuk bekerja dengan sumber data yang berbeda dan tidak memungkinkan pemanfaatan kemampuan yang khusus.  Dalam kasus kami, Postgres adalah satu-satunya sumber data dan, seperti semua basis data relasional, Postgres menyediakan kemampuan untuk mengumpulkan data dari beberapa tabel dengan satu permintaan menggunakan operator BERGABUNG.  Kami dapat menentukan semua tabel yang diperlukan untuk permintaan GraphQL dan menghasilkan satu permintaan SQL menggunakan GABUNG untuk mendapatkan semua data.  Ternyata data yang diperlukan untuk setiap permintaan GraphQL dapat diperoleh dengan menggunakan satu query SQL.  Data ini dikonversi sebelum dikirim ke klien. <br><br>  Permintaan seperti itu: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> album.id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> album_id, album.title <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> album_title, track.id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> track_id, track.title <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> track_title <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> album <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> track <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (album.id = track.album_id) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> album.year = <span class="hljs-number"><span class="hljs-number">2018</span></span></code> </pre><br>  Akan mengembalikan data tersebut kepada kami: <br><br><pre> <code class="sql hljs">album_id, album_title, track_id, track_title 1, Album1, 1, track1 1, Album1, 2, track2 2, Album2, NULL, NULL</code> </pre><br>  Kemudian akan dikonversi ke JSON dan dikirim ke klien: <br><br><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span> : <span class="hljs-string"><span class="hljs-string">"Album1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tracks"</span></span>: [ {<span class="hljs-attr"><span class="hljs-attr">"id"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"track1"</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">"id"</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"track2"</span></span>} ] }, { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span> : <span class="hljs-string"><span class="hljs-string">"Album2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tracks"</span></span> : [] } ]</code> </pre><br><h2>  Optimalisasi generasi respons </h2><br>  Kami menemukan bahwa sebagian besar waktu dalam pemrosesan query dihabiskan untuk fungsi mengkonversi hasil dari query SQL ke JSON. <br><br>  Setelah beberapa upaya untuk mengoptimalkan fungsi ini dengan berbagai cara, kami memutuskan untuk mentransfernya ke Postgres.  Postgres 9.4 ( <i>dirilis sekitar waktu rilis pertama Hasura</i> ) menambahkan fitur untuk agregasi JSON yang membantu kami melakukan pekerjaan kami.  Setelah optimasi ini, pertanyaan SQL mulai terlihat seperti ini: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> json_agg(r.*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> album.title <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> title, json_agg(track.*) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tracks <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> album <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> track <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (album.id = track.album_id) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> album.year = <span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> album.id ) r</code> </pre><br>  Hasil kueri ini akan memiliki satu kolom dan satu baris, dan nilai ini akan dikirim ke klien tanpa konversi lebih lanjut.  Menurut pengujian kami, pendekatan ini sekitar 3-6 kali lebih cepat daripada fungsi konversi Haskell. <br><br><h2>  Pernyataan yang disiapkan </h2><br>  Kueri SQL yang dihasilkan bisa sangat besar dan kompleks tergantung pada tingkat bersarang kueri dan kondisi penggunaan.  Biasanya, aplikasi web memiliki serangkaian kueri yang berulang kali dieksekusi dengan parameter berbeda.  Misalnya, kueri sebelumnya perlu dijalankan untuk 2017, bukan 2018. Pernyataan yang disiapkan paling cocok untuk kasus di mana ada kueri SQL kompleks berulang di mana hanya parameter yang diubah. <br><br>  Katakanlah kueri ini dijalankan untuk pertama kali: <br><br><pre> <code class="hljs dos">{ album (where: {year: {_eq: <span class="hljs-number"><span class="hljs-number">2018</span></span>}}) { <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> tracks { id <span class="hljs-built_in"><span class="hljs-built_in">title</span></span> } } }</code> </pre><br>  Kami membuat pernyataan yang disiapkan untuk kueri SQL alih-alih menjalankannya: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">PREPARE</span></span> prep_1 <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> json_agg(r.*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> album.title <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> title, json_agg(track.*) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tracks <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> album <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> track <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (album.id = track.album_id) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> album.year = $<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> album.</code> </pre><br>  Setelah itu kami segera menjalankannya: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> prep_1(<span class="hljs-string"><span class="hljs-string">'2018'</span></span>);</code> </pre><br>  Ketika Anda perlu menjalankan permintaan GraphQL untuk 2017, kami cukup memanggil pernyataan yang disiapkan sama dengan argumen yang berbeda: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> prep_1(<span class="hljs-string"><span class="hljs-string">'2017'</span></span>);</code> </pre><br>  Ini memberikan sekitar 10-20% peningkatan kecepatan tergantung pada kompleksitas permintaan GraphQL. <br><br><h2>  Haskell </h2><br>  Haskell berfungsi dengan baik karena beberapa alasan: <br><br><ul><li>  Bahasa yang dikompilasi dengan kinerja luar biasa ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">detail lebih lanjut di sini</a> ). </li><li>  Stack HTTP yang sangat efisien ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">warp</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsitektur warp</a> ). </li><li>  Pengalaman bahasa kami sebelumnya. </li></ul><br><h2>  Pada akhirnya </h2><br>  Semua optimasi yang disebutkan di atas menghasilkan keuntungan kinerja yang cukup serius: <br><br><img src="https://habrastorage.org/webt/oq/fl/gj/oqflgjy29zi_ar0amyy6xfggvbc.png"><br><br>  Faktanya, konsumsi memori yang rendah dan penundaan yang tidak signifikan dibandingkan dengan panggilan langsung ke PostgreSQL memungkinkan dalam kebanyakan kasus untuk mengganti ORM di backend Anda dengan panggilan API GraphQL. <br><br>  <b>Tolak ukur:</b> <br><br>  Test stand: <br><br><ol><li>  Laptop dengan RAM 8GB dan i7 </li><li>  Postgres berjalan di komputer yang sama </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wrk</a> , digunakan sebagai alat perbandingan dan untuk berbagai jenis permintaan kami mencoba "memaksimalkan" rps </li><li>  Salah satu contoh dari Hasura GraphQL Engine </li><li>  Ukuran Koneksi Pool: 50 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dataset</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">chinook</a> </li></ol><br><br>  <b>Permintaan 1: tracks_media_some</b> <br><br><pre> <code class="hljs pgsql">query tracks_media_some { tracks (<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: {composer: {_eq: "Kurt Cobain"}}){ id <span class="hljs-type"><span class="hljs-type">name</span></span> album { id title } media_type { <span class="hljs-type"><span class="hljs-type">name</span></span> } }}</code> </pre><br><ul><li>  Permintaan per detik: 1375 req / s </li><li>  Penundaan: 17,5 ms </li><li>  CPU: ~ 30% </li><li>  RAM: ~ 30MB (Hasura) + 90MB (Postgres) </li></ul><br>  <b>Permintaan 2: tracks_media_all</b> <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> tracks_media_all { <span class="hljs-section"><span class="hljs-section">tracks</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> name media_type { <span class="hljs-attribute"><span class="hljs-attribute">name</span></span> } }}</code> </pre><br><ul><li>  Permintaan per detik: 410 req / s </li><li>  Keterlambatan: 59ms </li><li>  CPU: ~ 100% </li><li>  RAM: ~ 30MB (Hasura) + 130MB (Postgres) </li></ul><br>  <b>Permintaan 3: album_tracks_genre_some</b> <br><br><pre> <code class="hljs pgsql">query albums_tracks_genre_some { albums (<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: {artist_id: {_eq: <span class="hljs-number"><span class="hljs-number">127</span></span>}}) { id title tracks { id <span class="hljs-type"><span class="hljs-type">name</span></span> genre { <span class="hljs-type"><span class="hljs-type">name</span></span> } } }}</code> </pre><br><ul><li>  Permintaan per detik: 1029 req / s </li><li>  Keterlambatan: 24 ms </li><li>  CPU: ~ 30% </li><li>  RAM: ~ 30MB (Hasura) + 90MB (Postgres) </li></ul><br>  <b>Permintaan 4: album_tracks_genre_all</b> <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> albums_tracks_genre_all { <span class="hljs-section"><span class="hljs-section">albums</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> title tracks { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> name genre { <span class="hljs-attribute"><span class="hljs-attribute">name</span></span> } } }</code> </pre><br><ul><li>  Permintaan per detik: 328 req / s </li><li>  Keterlambatan: 73ms </li><li>  CPU: 100% </li><li>  RAM: ~ 30MB (Hasura) + 130MB (Postgres) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428133/">https://habr.com/ru/post/id428133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428123/index.html">Minggu Keamanan 41: Kabar Baik</a></li>
<li><a href="../id428125/index.html">Siapa analitik produk dan mengapa mereka diperlukan dalam sebuah tim?</a></li>
<li><a href="../id428127/index.html">Cache nginx: semuanya baru - lama terlupakan</a></li>
<li><a href="../id428129/index.html">Logika fuzzy sederhana saling menempel â€œdari apa duluâ€ untuk mesin turbin gas</a></li>
<li><a href="../id428131/index.html">Seluruh kebenaran tentang RTOS. Artikel # 17. Grup Bendera Acara: Pengantar dan Layanan Dasar</a></li>
<li><a href="../id428135/index.html">Cara mengkonfigurasi atau menonaktifkan linting di editor kode bawaan</a></li>
<li><a href="../id428137/index.html">Olimpiade, kontes ide, ceramah tentang manajemen proyek TI dan pemutaran film: 10 acara mendatang di ITMO University</a></li>
<li><a href="../id428141/index.html">Backend untuk frontend, atau How Yandex.Market membuat API tanpa kruk</a></li>
<li><a href="../id428143/index.html">Pendekatan Implementasi ReactJS RBAC</a></li>
<li><a href="../id428147/index.html">Script untuk mengumpulkan kutipan dan mengenali teks dari video dengan Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>