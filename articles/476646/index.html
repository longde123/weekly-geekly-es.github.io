<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎃 👌 👌 Fusión de 3 vías en werf: despliegue en Kubernetes con Helm "con esteroides" 🍂 💛 👃🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algo sucedió que nosotros (y no solo nosotros) hemos estado esperando: werf , nuestra utilidad de código abierto para crear aplicaciones y entregarlas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fusión de 3 vías en werf: despliegue en Kubernetes con Helm "con esteroides"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/476646/"> Algo sucedió que nosotros (y no solo nosotros) hemos estado esperando: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">werf</a> , nuestra utilidad de código abierto para crear aplicaciones y entregarlas a Kubernetes, ¡ahora admite la aplicación de cambios utilizando parches de combinación de 3 vías!  Además de esto, se hizo posible adoptar los recursos K8 existentes en las versiones de Helm sin volver a crear estos recursos. <br><br><img src="https://habrastorage.org/webt/os/yc/op/osycopyy-kknbg7fnwuf8cjohxi.png"><br><br>  Si es muy corto, configure <code>WERF_THREE_WAY_MERGE=enabled</code> : obtenemos la implementación "como en <code>kubectl apply</code> ", compatible con las instalaciones existentes en Helm 2 e incluso un poco más. <br><br>  Pero comencemos con la teoría: ¿qué son los parches de fusión de 3 vías en general, cómo llegaron las personas al enfoque con su generación y por qué son importantes en los procesos de CI / CD con infraestructura basada en Kubernetes?  Y después de eso, veamos qué es la combinación de 3 vías en werf, qué modos se usan por defecto y cómo administrarlo. <a name="habracut"></a><br><br><h2>  ¿Qué es un parche de fusión de 3 vías? </h2><br>  Entonces, comencemos con la tarea de desplegar los recursos descritos en los manifiestos de YAML en Kubernetes. <br><br>  Para trabajar con recursos, la API de Kubernetes ofrece las siguientes operaciones básicas: crear, parchar, reemplazar y eliminar.  Se supone que con su ayuda es necesario construir un despliegue continuo conveniente de recursos para el clúster.  Como? <br><br><h3>  Equipos de kubectl imperativo </h3><br>  El primer enfoque para administrar objetos en Kubernetes es usar los imperativos comandos kubectl para crear, modificar y eliminar estos objetos.  En pocas palabras: <br><br><ul><li>  <code>kubectl run</code> comando <code>kubectl run</code> puede ejecutar Deployment o Job: <br><br><pre> <code class="bash hljs">kubectl run --generator=deployment/apps.v1 DEPLOYMENT_NAME --image=IMAGE</code> </pre> </li><li>  <code>kubectl scale</code> : cambie el número de réplicas: <br><br><pre> <code class="bash hljs">kubectl scale --replicas=3 deployment/mysql</code> </pre> </li><li>  etc. </li></ul><br>  Tal enfoque puede parecer conveniente a primera vista.  Sin embargo, hay problemas: <br><br><ol><li>  Es difícil de <b>automatizar</b> . </li><li>  ¿Cómo <b>reflejar la configuración</b> en Git?  ¿Cómo revisar los cambios que ocurren en un clúster? </li><li>  ¿Cómo asegurar la <b>reproducibilidad de la</b> configuración al reiniciar? </li><li>  ... </li></ol><br>  Está claro que este enfoque no encaja bien con el almacenamiento de la aplicación y la infraestructura como código (IaC; o incluso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitOps</a> como una opción más moderna, ganando popularidad en el ecosistema de Kubernetes) con el código.  Por lo tanto, estos equipos no recibieron más desarrollo en kubectl. <br><br><h3>  Crear, obtener, reemplazar y eliminar operaciones </h3><br>  Con la <b>creación</b> primaria <b>,</b> todo es simple: enviamos el manifiesto a la operación de <code>create</code> de kube api y se crea el recurso.  La representación YAML del manifiesto se puede almacenar en Git, y para crear, use el <code>kubectl create -f manifest.yaml</code> . <br><br>  <b>La eliminación</b> también <b>es</b> simple: sustituimos el mismo <code>manifest.yaml</code> de Git en el <code>kubectl delete -f manifest.yaml</code> . <br><br>  La operación de <b><code>replace</code></b> permite reemplazar completamente la configuración del recurso con una nueva, sin volver a crear el recurso.  Esto significa que antes de realizar un cambio en un recurso, es lógico solicitar la versión actual con la operación de <code>get</code> , cambiarla y actualizar con la operación de <code>replace</code> .  El bloqueo optimista está integrado en el kiser apiserver, y si el objeto ha cambiado después de la operación de <code>get</code> , la operación de <code>replace</code> fallará. <br><br>  Para almacenar la configuración en Git y actualizar usando replace, debe realizar una operación <code>get</code> , mantener la configuración de Git con lo que obtuvimos y realizar <code>replace</code> .  Normalmente, kubectl solo le permite usar el <code>kubectl replace -f manifest.yaml</code> , donde <code>manifest.yaml</code> es el <code>manifest.yaml</code> totalmente preparado (en nuestro caso, adjunto) que necesita ser instalado.  Resulta que el usuario necesita implementar manifiestos de fusión, pero este no es un asunto trivial ... <br><br>  También vale la pena señalar que, aunque <code>manifest.yaml</code> está almacenado en Git, no podemos saber de antemano si necesitamos crear un objeto o actualizarlo; esto debería hacerlo el software del usuario. <br><br>  En pocas palabras: <b>¿podemos construir un despliegue continuo</b> solo con crear, reemplazar y eliminar, asegurando que la configuración de la infraestructura se almacene en Git junto con el código y un conveniente CI / CD? <br><br>  Básicamente, podemos ... Para hacer esto, <b>necesitamos implementar la operación de fusión de los</b> manifiestos y algún tipo de enlace que: <br><br><ul><li>  comprueba la presencia de un objeto en el clúster, </li><li>  realiza la creación inicial del recurso, </li><li>  lo actualiza o lo elimina. </li></ul><br>  Al actualizar, debe tener en cuenta que el <i>recurso puede haber cambiado</i> desde la última vez y manejar automáticamente el caso de bloqueo optimista: realice intentos repetidos para actualizar. <br><br>  Sin embargo, ¿por qué reinventar la rueda cuando kube-apiserver ofrece otra forma de actualizar recursos: la operación de <code>patch</code> , que elimina algunos de los problemas descritos por el usuario? <br><br><h3>  Parche </h3><br>  Entonces llegamos a los parches. <br><br>  Los parches son la forma principal de aplicar cambios a los objetos existentes en Kubernetes.  La operación de <code>patch</code> funciona para que: <br><br><ul><li>  El usuario de kube-apiserver necesita enviar el parche en formato JSON y especificar el objeto, </li><li>  y el mismo servidor se ocupará del estado actual del objeto y lo llevará a la forma deseada. </li></ul><br>  El bloqueo optimista en este caso no es necesario.  Esta operación es más declarativa en comparación con reemplazar, aunque al principio puede parecer al revés. <br><br>  De esta manera: <br><br><ul><li>  usando la operación de <code>create</code> , creamos un objeto desde el manifiesto de Git, </li><li>  usando <code>delete</code> - delete si el objeto ya no es necesario, </li><li>  usando <code>patch</code> : modificamos el objeto, llevándolo al formulario descrito en Git. </li></ul><br>  Sin embargo, para hacer esto, debe crear el <i>parche correcto</i> . <br><br><h3>  Cómo funcionan los parches en Helm 2: combinación de 2 vías </h3><br>  La primera vez que se instala una versión, Helm realiza una operación de <code>create</code> en los recursos del gráfico. <br><br>  Al actualizar la versión de Helm para cada recurso: <br><br><ul><li>  cuenta el parche entre la versión del recurso del gráfico anterior y la versión actual del gráfico, </li><li>  aplica este parche </li></ul><br>  Llamaremos a ese parche parche <b>de fusión de 2 vías</b> , porque 2 manifiestos participan en su creación: <br><br><ul><li>  Manifiesto de recursos de la versión anterior, </li><li>  El manifiesto del recurso del recurso actual. </li></ul><br>  Al eliminar, se llama a la operación de <code>delete</code> en kube apiserver para los recursos que se declararon en la versión anterior pero que no se declararon en la versión actual. <br><br>  El enfoque con el parche de fusión de 2 vías tiene un problema: conduce a una <b>desincronización del estado real del recurso en el clúster y el manifiesto en Git</b> . <br><br><h3>  Un ejemplo de un problema. </h3><br><ul><li>  En Git, un manifiesto se almacena en el gráfico en el que el campo <code>image</code> implementación tiene el valor de <code>ubuntu:18.04</code> . </li><li>  El usuario a través de <code>kubectl edit</code> cambió el valor de este campo a <code>ubuntu:19.04</code> . </li><li>  Cuando vuelve a implementar el gráfico, Helm <i>no genera un parche</i> , porque el campo de <code>image</code> en la versión anterior de la versión y en el gráfico actual son los mismos. </li><li>  Después del despliegue repetido de la <code>image</code> , <code>ubuntu:19.04</code> permanece, aunque <code>ubuntu:18.04</code> está escrito en la tabla. </li></ul><br>  Obtuvimos desincronización y perdimos declaratividad. <br><br><h3>  ¿Qué es un recurso sincronizado? </h3><br>  En términos generales, es imposible obtener una coincidencia <i>completa</i> entre un manifiesto de recursos en un clúster en ejecución y un manifiesto de Git.  Debido a que en el manifiesto real puede haber anotaciones / etiquetas de servicio, contenedores adicionales y otros datos agregados y eliminados dinámicamente por algunos controladores del recurso.  No podemos y no queremos mantener estos datos en Git.  Sin embargo, queremos que cuando se despliegue, los campos que especificamos explícitamente en Git tomen los valores apropiados. <br><br>  Resulta esta <b>regla</b> general <b>de un recurso sincronizado</b> : cuando despliega un recurso, puede cambiar o eliminar solo aquellos campos que se especifican explícitamente en el manifiesto de Git (o se registraron en la versión anterior, pero ahora se eliminan). <br><br><h3>  Parche de fusión de 3 vías </h3><br>  La idea principal del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parche de combinación de 3 vías</a> : generamos un parche entre la última versión aplicada del manifiesto de Git y la versión de destino del manifiesto de Git, teniendo en cuenta la versión actual del manifiesto del clúster de trabajo.  El parche final debe cumplir con la regla de recursos sincronizados: <br><br><ul><li>  los nuevos campos agregados a la versión de destino se agregan usando el parche; </li><li>  los campos previamente existentes en la última versión aplicada y no existentes en el campo de destino se restablecen usando el parche; </li><li>  Los campos en la versión actual del objeto que difieren de la versión de destino del manifiesto se actualizan utilizando el parche. </li></ul><br>  Es por este principio que se generan parches de <code>kubectl apply</code> : <br><br><ul><li>  la última versión aplicada del manifiesto se almacena en la anotación del objeto mismo, </li><li>  target: tomado del archivo YAML especificado, </li><li>  actual: de un clúster de trabajo. </li></ul><br>  Ahora que hemos descubierto la teoría, es hora de contarte lo que hicimos en werf. <br><br><h2>  Aplicar cambios a werf </h2><br>  Anteriormente, werf, como Helm 2, usaba parches de fusión de 2 vías. <br><br><h3>  Parche de reparación </h3><br>  Para cambiar a un nuevo tipo de parches, fusión de 3 vías, el primer paso fue la introducción de los llamados <b>parches de reparación</b> . <br><br>  Cuando se implementa, se usa el parche estándar de combinación de 2 vías, pero werf adicionalmente genera un parche que sincroniza el estado real del recurso con lo que está escrito en Git (dicho parche se crea usando la misma regla de recursos sincronizados descrita anteriormente). <br><br>  En el caso de un rassynchron, al final de la implementación, el usuario recibe una ADVERTENCIA con el mensaje y el parche apropiados, que deben aplicarse para llevar el recurso a una forma sincronizada.  Además, este parche se graba en una anotación especial <code>werf.io/repair-patch</code> .  Se supone que el usuario <b>mismo</b> aplicará este parche con las manos: werf no lo aplicará en principio. <br><br>  La generación de parches de reparación es una medida temporal que le permite probar realmente la creación de parches según el principio de la fusión de 3 vías, pero no aplique estos parches automáticamente.  Por el momento, este modo de operación está habilitado por defecto. <br><br><h3>  Parche de combinación de 3 vías solo para nuevos lanzamientos </h3><br>  A partir del 1 de diciembre de 2019, las versiones beta y alfa de werf comienzan <b>por defecto a</b> usar parches completos de combinación de 3 vías para aplicar cambios solo para las nuevas versiones de Helm implementadas a través de werf.  Las versiones existentes continuarán utilizando el enfoque de parche de reparación de combinación de 2 vías. <br><br>  Puede habilitar este modo de operación explícitamente estableciendo <code>WERF_THREE_WAY_MERGE_MODE=onlyNewReleases</code> ahora. <br><br>  <i><b>Nota</b> : la función apareció en werf durante varios lanzamientos: en el canal alfa se preparó a partir de la versión <a href="">v1.0.5-alpha.19</a> , y en el canal beta con <a href="">v1.0.4-beta.20</a> .</i> <br><br><h3>  Parche de combinación de 3 vías para todos los lanzamientos </h3><br>  A partir del 15 de diciembre de 2019, las versiones beta y alfa de werf comienzan a usar parches completos de combinación de 3 vías de forma predeterminada para aplicar cambios en todas las versiones. <br><br>  Este modo de operación se puede <code>WERF_THREE_WAY_MERGE_MODE=enabled</code> explícitamente estableciendo <code>WERF_THREE_WAY_MERGE_MODE=enabled</code> ahora. <br><br><h3>  ¿Qué hacer con los recursos de escalado automático? </h3><br>  Kubernetes tiene 2 tipos de autoescalado: HPA (horizontal) y VPA (vertical). <br><br>  Horizontal selecciona automáticamente el número de réplicas, vertical: el número de recursos.  Tanto el número de réplicas como los requisitos de recursos se especifican en el manifiesto de recursos (consulte <code>spec.replicas</code> o <code>spec.containers[].resources.limits.cpu</code> , <code>spec.containers[].resources.limits.memory</code> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otros</a> ). <br><br>  Problema: si un usuario configura un recurso en el gráfico para que muestre valores específicos para recursos o réplicas y los autoescaladores estén habilitados para este recurso, entonces con cada despliegue werf restablecerá estos valores a lo que está escrito en el manifiesto del gráfico. <br><br>  Hay dos soluciones al problema.  Para empezar, es mejor descartar especificando explícitamente los valores de autoescala en el manifiesto del gráfico.  Si por alguna razón esta opción no encaja (por ejemplo, porque es conveniente establecer los límites de recursos iniciales y el número de réplicas en el gráfico), werf ofrece las siguientes anotaciones: <br><br><ul><li> <code>werf.io/set-replicas-only-on-creation=true</code> </li> <li> <code>werf.io/set-resources-only-on-creation=true</code> </li> </ul><br>  Si tal anotación está presente, werf no restablecerá los valores correspondientes en cada implementación, sino que solo los establecerá en la creación inicial del recurso. <br><br>  Para obtener más información, consulte la documentación del proyecto para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HPA</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VPA</a> . <br><br><h3>  Negar el uso del parche de fusión de 3 vías </h3><br>  El usuario aún puede prohibir el uso de nuevos parches en werf utilizando la variable de entorno <code>WERF_THREE_WAY_MERGE_MODE=disabled</code> .  Sin embargo, a partir <b>del 1 de marzo de 2020, esta prohibición dejará de funcionar</b> y solo será posible usar parches de fusión de 3 vías. <br><br><h2>  Adopción de recursos en werf </h2><br>  El dominio del método de aplicación de cambios en parches de fusión de 3 vías nos permitió implementar de inmediato una característica como la adopción de recursos existentes en el clúster en la versión Helm. <br><br>  Helm 2 tiene un problema: no puede agregar un recurso a un manifiesto de gráfico que ya existe en el clúster sin volver a crear este recurso desde cero (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="># 6031</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="># 3275</a> ).  Enseñamos a werf a aceptar los recursos existentes en un comunicado.  Para hacer esto, debe establecer una anotación en la versión actual del recurso desde un clúster en ejecución (por ejemplo, usando <code>kubectl edit</code> ): <br><br><pre> <code class="plaintext hljs">"werf.io/allow-adoption-by-release": RELEASE_NAME</code> </pre> <br>  Ahora, el recurso debe describirse en el gráfico y, en el próximo despliegue, mediante el lanzamiento de werf del lanzamiento con el nombre correspondiente, el recurso existente será aceptado en este lanzamiento y permanecerá bajo su control.  Además, en el proceso de aceptar el recurso para su liberación, werf traerá el estado actual del recurso desde el clúster de trabajo al estado descrito en el gráfico utilizando los mismos parches de combinación de 3 vías y la regla de recursos sincronizados. <br><br>  <i><b>Nota</b> : la configuración de <code>WERF_THREE_WAY_MERGE_MODE</code> no afecta la adopción de recursos; en el caso de la adopción, siempre se usa un parche de fusión de 3 vías.</i> <br><br>  Los detalles están en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> . <br><br><h2>  Conclusiones y planes futuros </h2><br>  Espero que después de este artículo se haya aclarado qué son los parches de combinación de 3 vías y por qué vinieron a ellos.  Desde un punto de vista práctico del desarrollo del proyecto werf, su implementación fue otro paso hacia la mejora de la implementación similar a Helm.  Ahora puede olvidarse de los problemas con la sincronización de la configuración, que a menudo ocurrían al usar Helm 2. Al mismo tiempo, se agregó una nueva característica útil de la adopción de los recursos de Kubernetes ya cargados en la versión de Helm. <br><br>  Todavía hay algunos problemas y dificultades en la implementación similar a Helm, como el uso de plantillas Go, y continuaremos resolviéndolos. <br><br>  También se puede encontrar información sobre métodos de actualización de recursos y adopción en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta página de documentación</a> . <br><br><h3>  Timón 3 </h3><br>  Una nota especial es digna de la nueva versión principal lanzada recientemente de Helm, v3, que también usa parches de combinación de 3 vías y elimina Tiller.  La nueva versión de Helm requiere la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">migración de</a> las instalaciones existentes para convertirlas en un nuevo formato de almacenamiento de lanzamiento. <br><br>  Werf, por su parte, ahora ha eliminado el uso de Tiller, cambió a la combinación de 3 vías y agregó <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mucho más</a> , sin dejar de ser compatible con las instalaciones existentes en Helm 2 (no se necesitan scripts de migración).  Por lo tanto, hasta que werf se cambie a Helm 3, los usuarios de werf no perderán las principales ventajas de Helm 3 sobre Helm 2 (también existen en werf). <br><br>  Sin embargo, cambiar werf a la base de código Helm 3 es inevitable y sucederá en un futuro próximo.  Presumiblemente será werf 1.1 o werf 1.2 (en este momento, la versión principal de werf es 1.0; para más detalles sobre el dispositivo de versiones de werf, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> ).  Durante este tiempo, Helm 3 tendrá tiempo para estabilizarse. <br><br><h2>  PS </h2><br>  Lea también en nuestro blog: <br><br><ul><li>  Una serie de notas sobre innovaciones en werf: <br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Uso de werf para desplegar gráficos complejos de Helm</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soporte para monorepo y multirepo en werf y qué tiene que ver el Registro de Docker con él</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ahora puede construir imágenes Docker en werf utilizando el Dockerfile habitual</a> ". </li></ul></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Werf es nuestra herramienta de CI / CD en Kubernetes (revisión e informe de video)</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Montaje y despliegue del mismo tipo de microservicios con werf y GitLab CI</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Presentación de Helm 3.</a> " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/476646/">https://habr.com/ru/post/476646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../476626/index.html">PVS-Studio en las nubes: GitLab CI / CD</a></li>
<li><a href="../476628/index.html">PVS-Studio va a las nubes: GitLab CI / CD</a></li>
<li><a href="../476636/index.html">Ajuste de Firebird y Linux para una base de datos de 691 GB de tamaño con más de 1000 usuarios</a></li>
<li><a href="../476640/index.html">Protección de Zimbra OSE de la fuerza bruta y los ataques DoS</a></li>
<li><a href="../476644/index.html">Capas de lenguaje</a></li>
<li><a href="../476648/index.html">Lenovo en FINOPOLIS 2019</a></li>
<li><a href="../476650/index.html">El lugar de la enumeración en el mundo cambiante de hoy</a></li>
<li><a href="../476656/index.html">26 de noviembre, Moscú - Alfa JS MeetUP # 3</a></li>
<li><a href="../476658/index.html">VPS con una tarjeta de video (parte 2): capacidades informáticas</a></li>
<li><a href="../476664/index.html">oktech: Frontend Meetup # 2: mini entrevistas de oradores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>