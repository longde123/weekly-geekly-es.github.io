<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Fusi贸n de 3 v铆as en werf: despliegue en Kubernetes con Helm "con esteroides"   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algo sucedi贸 que nosotros (y no solo nosotros) hemos estado esperando: werf , nuestra utilidad de c贸digo abierto para crear aplicaciones y entregarlas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fusi贸n de 3 v铆as en werf: despliegue en Kubernetes con Helm "con esteroides"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/476646/"> Algo sucedi贸 que nosotros (y no solo nosotros) hemos estado esperando: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">werf</a> , nuestra utilidad de c贸digo abierto para crear aplicaciones y entregarlas a Kubernetes, 隆ahora admite la aplicaci贸n de cambios utilizando parches de combinaci贸n de 3 v铆as!  Adem谩s de esto, se hizo posible adoptar los recursos K8 existentes en las versiones de Helm sin volver a crear estos recursos. <br><br><img src="https://habrastorage.org/webt/os/yc/op/osycopyy-kknbg7fnwuf8cjohxi.png"><br><br>  Si es muy corto, configure <code>WERF_THREE_WAY_MERGE=enabled</code> : obtenemos la implementaci贸n "como en <code>kubectl apply</code> ", compatible con las instalaciones existentes en Helm 2 e incluso un poco m谩s. <br><br>  Pero comencemos con la teor铆a: 驴qu茅 son los parches de fusi贸n de 3 v铆as en general, c贸mo llegaron las personas al enfoque con su generaci贸n y por qu茅 son importantes en los procesos de CI / CD con infraestructura basada en Kubernetes?  Y despu茅s de eso, veamos qu茅 es la combinaci贸n de 3 v铆as en werf, qu茅 modos se usan por defecto y c贸mo administrarlo. <a name="habracut"></a><br><br><h2>  驴Qu茅 es un parche de fusi贸n de 3 v铆as? </h2><br>  Entonces, comencemos con la tarea de desplegar los recursos descritos en los manifiestos de YAML en Kubernetes. <br><br>  Para trabajar con recursos, la API de Kubernetes ofrece las siguientes operaciones b谩sicas: crear, parchar, reemplazar y eliminar.  Se supone que con su ayuda es necesario construir un despliegue continuo conveniente de recursos para el cl煤ster.  Como? <br><br><h3>  Equipos de kubectl imperativo </h3><br>  El primer enfoque para administrar objetos en Kubernetes es usar los imperativos comandos kubectl para crear, modificar y eliminar estos objetos.  En pocas palabras: <br><br><ul><li>  <code>kubectl run</code> comando <code>kubectl run</code> puede ejecutar Deployment o Job: <br><br><pre> <code class="bash hljs">kubectl run --generator=deployment/apps.v1 DEPLOYMENT_NAME --image=IMAGE</code> </pre> </li><li>  <code>kubectl scale</code> : cambie el n煤mero de r茅plicas: <br><br><pre> <code class="bash hljs">kubectl scale --replicas=3 deployment/mysql</code> </pre> </li><li>  etc. </li></ul><br>  Tal enfoque puede parecer conveniente a primera vista.  Sin embargo, hay problemas: <br><br><ol><li>  Es dif铆cil de <b>automatizar</b> . </li><li>  驴C贸mo <b>reflejar la configuraci贸n</b> en Git?  驴C贸mo revisar los cambios que ocurren en un cl煤ster? </li><li>  驴C贸mo asegurar la <b>reproducibilidad de la</b> configuraci贸n al reiniciar? </li><li>  ... </li></ol><br>  Est谩 claro que este enfoque no encaja bien con el almacenamiento de la aplicaci贸n y la infraestructura como c贸digo (IaC; o incluso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitOps</a> como una opci贸n m谩s moderna, ganando popularidad en el ecosistema de Kubernetes) con el c贸digo.  Por lo tanto, estos equipos no recibieron m谩s desarrollo en kubectl. <br><br><h3>  Crear, obtener, reemplazar y eliminar operaciones </h3><br>  Con la <b>creaci贸n</b> primaria <b>,</b> todo es simple: enviamos el manifiesto a la operaci贸n de <code>create</code> de kube api y se crea el recurso.  La representaci贸n YAML del manifiesto se puede almacenar en Git, y para crear, use el <code>kubectl create -f manifest.yaml</code> . <br><br>  <b>La eliminaci贸n</b> tambi茅n <b>es</b> simple: sustituimos el mismo <code>manifest.yaml</code> de Git en el <code>kubectl delete -f manifest.yaml</code> . <br><br>  La operaci贸n de <b><code>replace</code></b> permite reemplazar completamente la configuraci贸n del recurso con una nueva, sin volver a crear el recurso.  Esto significa que antes de realizar un cambio en un recurso, es l贸gico solicitar la versi贸n actual con la operaci贸n de <code>get</code> , cambiarla y actualizar con la operaci贸n de <code>replace</code> .  El bloqueo optimista est谩 integrado en el kiser apiserver, y si el objeto ha cambiado despu茅s de la operaci贸n de <code>get</code> , la operaci贸n de <code>replace</code> fallar谩. <br><br>  Para almacenar la configuraci贸n en Git y actualizar usando replace, debe realizar una operaci贸n <code>get</code> , mantener la configuraci贸n de Git con lo que obtuvimos y realizar <code>replace</code> .  Normalmente, kubectl solo le permite usar el <code>kubectl replace -f manifest.yaml</code> , donde <code>manifest.yaml</code> es el <code>manifest.yaml</code> totalmente preparado (en nuestro caso, adjunto) que necesita ser instalado.  Resulta que el usuario necesita implementar manifiestos de fusi贸n, pero este no es un asunto trivial ... <br><br>  Tambi茅n vale la pena se帽alar que, aunque <code>manifest.yaml</code> est谩 almacenado en Git, no podemos saber de antemano si necesitamos crear un objeto o actualizarlo; esto deber铆a hacerlo el software del usuario. <br><br>  En pocas palabras: <b>驴podemos construir un despliegue continuo</b> solo con crear, reemplazar y eliminar, asegurando que la configuraci贸n de la infraestructura se almacene en Git junto con el c贸digo y un conveniente CI / CD? <br><br>  B谩sicamente, podemos ... Para hacer esto, <b>necesitamos implementar la operaci贸n de fusi贸n de los</b> manifiestos y alg煤n tipo de enlace que: <br><br><ul><li>  comprueba la presencia de un objeto en el cl煤ster, </li><li>  realiza la creaci贸n inicial del recurso, </li><li>  lo actualiza o lo elimina. </li></ul><br>  Al actualizar, debe tener en cuenta que el <i>recurso puede haber cambiado</i> desde la 煤ltima vez y manejar autom谩ticamente el caso de bloqueo optimista: realice intentos repetidos para actualizar. <br><br>  Sin embargo, 驴por qu茅 reinventar la rueda cuando kube-apiserver ofrece otra forma de actualizar recursos: la operaci贸n de <code>patch</code> , que elimina algunos de los problemas descritos por el usuario? <br><br><h3>  Parche </h3><br>  Entonces llegamos a los parches. <br><br>  Los parches son la forma principal de aplicar cambios a los objetos existentes en Kubernetes.  La operaci贸n de <code>patch</code> funciona para que: <br><br><ul><li>  El usuario de kube-apiserver necesita enviar el parche en formato JSON y especificar el objeto, </li><li>  y el mismo servidor se ocupar谩 del estado actual del objeto y lo llevar谩 a la forma deseada. </li></ul><br>  El bloqueo optimista en este caso no es necesario.  Esta operaci贸n es m谩s declarativa en comparaci贸n con reemplazar, aunque al principio puede parecer al rev茅s. <br><br>  De esta manera: <br><br><ul><li>  usando la operaci贸n de <code>create</code> , creamos un objeto desde el manifiesto de Git, </li><li>  usando <code>delete</code> - delete si el objeto ya no es necesario, </li><li>  usando <code>patch</code> : modificamos el objeto, llev谩ndolo al formulario descrito en Git. </li></ul><br>  Sin embargo, para hacer esto, debe crear el <i>parche correcto</i> . <br><br><h3>  C贸mo funcionan los parches en Helm 2: combinaci贸n de 2 v铆as </h3><br>  La primera vez que se instala una versi贸n, Helm realiza una operaci贸n de <code>create</code> en los recursos del gr谩fico. <br><br>  Al actualizar la versi贸n de Helm para cada recurso: <br><br><ul><li>  cuenta el parche entre la versi贸n del recurso del gr谩fico anterior y la versi贸n actual del gr谩fico, </li><li>  aplica este parche </li></ul><br>  Llamaremos a ese parche parche <b>de fusi贸n de 2 v铆as</b> , porque 2 manifiestos participan en su creaci贸n: <br><br><ul><li>  Manifiesto de recursos de la versi贸n anterior, </li><li>  El manifiesto del recurso del recurso actual. </li></ul><br>  Al eliminar, se llama a la operaci贸n de <code>delete</code> en kube apiserver para los recursos que se declararon en la versi贸n anterior pero que no se declararon en la versi贸n actual. <br><br>  El enfoque con el parche de fusi贸n de 2 v铆as tiene un problema: conduce a una <b>desincronizaci贸n del estado real del recurso en el cl煤ster y el manifiesto en Git</b> . <br><br><h3>  Un ejemplo de un problema. </h3><br><ul><li>  En Git, un manifiesto se almacena en el gr谩fico en el que el campo <code>image</code> implementaci贸n tiene el valor de <code>ubuntu:18.04</code> . </li><li>  El usuario a trav茅s de <code>kubectl edit</code> cambi贸 el valor de este campo a <code>ubuntu:19.04</code> . </li><li>  Cuando vuelve a implementar el gr谩fico, Helm <i>no genera un parche</i> , porque el campo de <code>image</code> en la versi贸n anterior de la versi贸n y en el gr谩fico actual son los mismos. </li><li>  Despu茅s del despliegue repetido de la <code>image</code> , <code>ubuntu:19.04</code> permanece, aunque <code>ubuntu:18.04</code> est谩 escrito en la tabla. </li></ul><br>  Obtuvimos desincronizaci贸n y perdimos declaratividad. <br><br><h3>  驴Qu茅 es un recurso sincronizado? </h3><br>  En t茅rminos generales, es imposible obtener una coincidencia <i>completa</i> entre un manifiesto de recursos en un cl煤ster en ejecuci贸n y un manifiesto de Git.  Debido a que en el manifiesto real puede haber anotaciones / etiquetas de servicio, contenedores adicionales y otros datos agregados y eliminados din谩micamente por algunos controladores del recurso.  No podemos y no queremos mantener estos datos en Git.  Sin embargo, queremos que cuando se despliegue, los campos que especificamos expl铆citamente en Git tomen los valores apropiados. <br><br>  Resulta esta <b>regla</b> general <b>de un recurso sincronizado</b> : cuando despliega un recurso, puede cambiar o eliminar solo aquellos campos que se especifican expl铆citamente en el manifiesto de Git (o se registraron en la versi贸n anterior, pero ahora se eliminan). <br><br><h3>  Parche de fusi贸n de 3 v铆as </h3><br>  La idea principal del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parche de combinaci贸n de 3 v铆as</a> : generamos un parche entre la 煤ltima versi贸n aplicada del manifiesto de Git y la versi贸n de destino del manifiesto de Git, teniendo en cuenta la versi贸n actual del manifiesto del cl煤ster de trabajo.  El parche final debe cumplir con la regla de recursos sincronizados: <br><br><ul><li>  los nuevos campos agregados a la versi贸n de destino se agregan usando el parche; </li><li>  los campos previamente existentes en la 煤ltima versi贸n aplicada y no existentes en el campo de destino se restablecen usando el parche; </li><li>  Los campos en la versi贸n actual del objeto que difieren de la versi贸n de destino del manifiesto se actualizan utilizando el parche. </li></ul><br>  Es por este principio que se generan parches de <code>kubectl apply</code> : <br><br><ul><li>  la 煤ltima versi贸n aplicada del manifiesto se almacena en la anotaci贸n del objeto mismo, </li><li>  target: tomado del archivo YAML especificado, </li><li>  actual: de un cl煤ster de trabajo. </li></ul><br>  Ahora que hemos descubierto la teor铆a, es hora de contarte lo que hicimos en werf. <br><br><h2>  Aplicar cambios a werf </h2><br>  Anteriormente, werf, como Helm 2, usaba parches de fusi贸n de 2 v铆as. <br><br><h3>  Parche de reparaci贸n </h3><br>  Para cambiar a un nuevo tipo de parches, fusi贸n de 3 v铆as, el primer paso fue la introducci贸n de los llamados <b>parches de reparaci贸n</b> . <br><br>  Cuando se implementa, se usa el parche est谩ndar de combinaci贸n de 2 v铆as, pero werf adicionalmente genera un parche que sincroniza el estado real del recurso con lo que est谩 escrito en Git (dicho parche se crea usando la misma regla de recursos sincronizados descrita anteriormente). <br><br>  En el caso de un rassynchron, al final de la implementaci贸n, el usuario recibe una ADVERTENCIA con el mensaje y el parche apropiados, que deben aplicarse para llevar el recurso a una forma sincronizada.  Adem谩s, este parche se graba en una anotaci贸n especial <code>werf.io/repair-patch</code> .  Se supone que el usuario <b>mismo</b> aplicar谩 este parche con las manos: werf no lo aplicar谩 en principio. <br><br>  La generaci贸n de parches de reparaci贸n es una medida temporal que le permite probar realmente la creaci贸n de parches seg煤n el principio de la fusi贸n de 3 v铆as, pero no aplique estos parches autom谩ticamente.  Por el momento, este modo de operaci贸n est谩 habilitado por defecto. <br><br><h3>  Parche de combinaci贸n de 3 v铆as solo para nuevos lanzamientos </h3><br>  A partir del 1 de diciembre de 2019, las versiones beta y alfa de werf comienzan <b>por defecto a</b> usar parches completos de combinaci贸n de 3 v铆as para aplicar cambios solo para las nuevas versiones de Helm implementadas a trav茅s de werf.  Las versiones existentes continuar谩n utilizando el enfoque de parche de reparaci贸n de combinaci贸n de 2 v铆as. <br><br>  Puede habilitar este modo de operaci贸n expl铆citamente estableciendo <code>WERF_THREE_WAY_MERGE_MODE=onlyNewReleases</code> ahora. <br><br>  <i><b>Nota</b> : la funci贸n apareci贸 en werf durante varios lanzamientos: en el canal alfa se prepar贸 a partir de la versi贸n <a href="">v1.0.5-alpha.19</a> , y en el canal beta con <a href="">v1.0.4-beta.20</a> .</i> <br><br><h3>  Parche de combinaci贸n de 3 v铆as para todos los lanzamientos </h3><br>  A partir del 15 de diciembre de 2019, las versiones beta y alfa de werf comienzan a usar parches completos de combinaci贸n de 3 v铆as de forma predeterminada para aplicar cambios en todas las versiones. <br><br>  Este modo de operaci贸n se puede <code>WERF_THREE_WAY_MERGE_MODE=enabled</code> expl铆citamente estableciendo <code>WERF_THREE_WAY_MERGE_MODE=enabled</code> ahora. <br><br><h3>  驴Qu茅 hacer con los recursos de escalado autom谩tico? </h3><br>  Kubernetes tiene 2 tipos de autoescalado: HPA (horizontal) y VPA (vertical). <br><br>  Horizontal selecciona autom谩ticamente el n煤mero de r茅plicas, vertical: el n煤mero de recursos.  Tanto el n煤mero de r茅plicas como los requisitos de recursos se especifican en el manifiesto de recursos (consulte <code>spec.replicas</code> o <code>spec.containers[].resources.limits.cpu</code> , <code>spec.containers[].resources.limits.memory</code> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">otros</a> ). <br><br>  Problema: si un usuario configura un recurso en el gr谩fico para que muestre valores espec铆ficos para recursos o r茅plicas y los autoescaladores est茅n habilitados para este recurso, entonces con cada despliegue werf restablecer谩 estos valores a lo que est谩 escrito en el manifiesto del gr谩fico. <br><br>  Hay dos soluciones al problema.  Para empezar, es mejor descartar especificando expl铆citamente los valores de autoescala en el manifiesto del gr谩fico.  Si por alguna raz贸n esta opci贸n no encaja (por ejemplo, porque es conveniente establecer los l铆mites de recursos iniciales y el n煤mero de r茅plicas en el gr谩fico), werf ofrece las siguientes anotaciones: <br><br><ul><li> <code>werf.io/set-replicas-only-on-creation=true</code> </li> <li> <code>werf.io/set-resources-only-on-creation=true</code> </li> </ul><br>  Si tal anotaci贸n est谩 presente, werf no restablecer谩 los valores correspondientes en cada implementaci贸n, sino que solo los establecer谩 en la creaci贸n inicial del recurso. <br><br>  Para obtener m谩s informaci贸n, consulte la documentaci贸n del proyecto para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HPA</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VPA</a> . <br><br><h3>  Negar el uso del parche de fusi贸n de 3 v铆as </h3><br>  El usuario a煤n puede prohibir el uso de nuevos parches en werf utilizando la variable de entorno <code>WERF_THREE_WAY_MERGE_MODE=disabled</code> .  Sin embargo, a partir <b>del 1 de marzo de 2020, esta prohibici贸n dejar谩 de funcionar</b> y solo ser谩 posible usar parches de fusi贸n de 3 v铆as. <br><br><h2>  Adopci贸n de recursos en werf </h2><br>  El dominio del m茅todo de aplicaci贸n de cambios en parches de fusi贸n de 3 v铆as nos permiti贸 implementar de inmediato una caracter铆stica como la adopci贸n de recursos existentes en el cl煤ster en la versi贸n Helm. <br><br>  Helm 2 tiene un problema: no puede agregar un recurso a un manifiesto de gr谩fico que ya existe en el cl煤ster sin volver a crear este recurso desde cero (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="># 6031</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="># 3275</a> ).  Ense帽amos a werf a aceptar los recursos existentes en un comunicado.  Para hacer esto, debe establecer una anotaci贸n en la versi贸n actual del recurso desde un cl煤ster en ejecuci贸n (por ejemplo, usando <code>kubectl edit</code> ): <br><br><pre> <code class="plaintext hljs">"werf.io/allow-adoption-by-release": RELEASE_NAME</code> </pre> <br>  Ahora, el recurso debe describirse en el gr谩fico y, en el pr贸ximo despliegue, mediante el lanzamiento de werf del lanzamiento con el nombre correspondiente, el recurso existente ser谩 aceptado en este lanzamiento y permanecer谩 bajo su control.  Adem谩s, en el proceso de aceptar el recurso para su liberaci贸n, werf traer谩 el estado actual del recurso desde el cl煤ster de trabajo al estado descrito en el gr谩fico utilizando los mismos parches de combinaci贸n de 3 v铆as y la regla de recursos sincronizados. <br><br>  <i><b>Nota</b> : la configuraci贸n de <code>WERF_THREE_WAY_MERGE_MODE</code> no afecta la adopci贸n de recursos; en el caso de la adopci贸n, siempre se usa un parche de fusi贸n de 3 v铆as.</i> <br><br>  Los detalles est谩n en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci贸n</a> . <br><br><h2>  Conclusiones y planes futuros </h2><br>  Espero que despu茅s de este art铆culo se haya aclarado qu茅 son los parches de combinaci贸n de 3 v铆as y por qu茅 vinieron a ellos.  Desde un punto de vista pr谩ctico del desarrollo del proyecto werf, su implementaci贸n fue otro paso hacia la mejora de la implementaci贸n similar a Helm.  Ahora puede olvidarse de los problemas con la sincronizaci贸n de la configuraci贸n, que a menudo ocurr铆an al usar Helm 2. Al mismo tiempo, se agreg贸 una nueva caracter铆stica 煤til de la adopci贸n de los recursos de Kubernetes ya cargados en la versi贸n de Helm. <br><br>  Todav铆a hay algunos problemas y dificultades en la implementaci贸n similar a Helm, como el uso de plantillas Go, y continuaremos resolvi茅ndolos. <br><br>  Tambi茅n se puede encontrar informaci贸n sobre m茅todos de actualizaci贸n de recursos y adopci贸n en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta p谩gina de documentaci贸n</a> . <br><br><h3>  Tim贸n 3 </h3><br>  Una nota especial es digna de la nueva versi贸n principal lanzada recientemente de Helm, v3, que tambi茅n usa parches de combinaci贸n de 3 v铆as y elimina Tiller.  La nueva versi贸n de Helm requiere la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">migraci贸n de</a> las instalaciones existentes para convertirlas en un nuevo formato de almacenamiento de lanzamiento. <br><br>  Werf, por su parte, ahora ha eliminado el uso de Tiller, cambi贸 a la combinaci贸n de 3 v铆as y agreg贸 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mucho m谩s</a> , sin dejar de ser compatible con las instalaciones existentes en Helm 2 (no se necesitan scripts de migraci贸n).  Por lo tanto, hasta que werf se cambie a Helm 3, los usuarios de werf no perder谩n las principales ventajas de Helm 3 sobre Helm 2 (tambi茅n existen en werf). <br><br>  Sin embargo, cambiar werf a la base de c贸digo Helm 3 es inevitable y suceder谩 en un futuro pr贸ximo.  Presumiblemente ser谩 werf 1.1 o werf 1.2 (en este momento, la versi贸n principal de werf es 1.0; para m谩s detalles sobre el dispositivo de versiones de werf, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu铆</a> ).  Durante este tiempo, Helm 3 tendr谩 tiempo para estabilizarse. <br><br><h2>  PS </h2><br>  Lea tambi茅n en nuestro blog: <br><br><ul><li>  Una serie de notas sobre innovaciones en werf: <br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Uso de werf para desplegar gr谩ficos complejos de Helm</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soporte para monorepo y multirepo en werf y qu茅 tiene que ver el Registro de Docker con 茅l</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ahora puede construir im谩genes Docker en werf utilizando el Dockerfile habitual</a> ". </li></ul></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Werf es nuestra herramienta de CI / CD en Kubernetes (revisi贸n e informe de video)</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Montaje y despliegue del mismo tipo de microservicios con werf y GitLab CI</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Presentaci贸n de Helm 3.</a> " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/476646/">https://habr.com/ru/post/476646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../476626/index.html">PVS-Studio en las nubes: GitLab CI / CD</a></li>
<li><a href="../476628/index.html">PVS-Studio va a las nubes: GitLab CI / CD</a></li>
<li><a href="../476636/index.html">Ajuste de Firebird y Linux para una base de datos de 691 GB de tama帽o con m谩s de 1000 usuarios</a></li>
<li><a href="../476640/index.html">Protecci贸n de Zimbra OSE de la fuerza bruta y los ataques DoS</a></li>
<li><a href="../476644/index.html">Capas de lenguaje</a></li>
<li><a href="../476648/index.html">Lenovo en FINOPOLIS 2019</a></li>
<li><a href="../476650/index.html">El lugar de la enumeraci贸n en el mundo cambiante de hoy</a></li>
<li><a href="../476656/index.html">26 de noviembre, Mosc煤 - Alfa JS MeetUP # 3</a></li>
<li><a href="../476658/index.html">VPS con una tarjeta de video (parte 2): capacidades inform谩ticas</a></li>
<li><a href="../476664/index.html">oktech: Frontend Meetup # 2: mini entrevistas de oradores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>