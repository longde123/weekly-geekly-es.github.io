<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍⚕️ 👩🏽‍🤝‍👨🏻 🤹🏽 MongoDB und IT-Arbeitsmarktforschung 👆🏽 🖐🏽 👨🏻‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haben Sie jemals offene Stellen analysiert? 

 Sie stellten die Frage, in welchen Technologien die Nachfrage auf dem Arbeitsmarkt am aktuellsten ist. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MongoDB und IT-Arbeitsmarktforschung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422627/">  Haben Sie jemals offene Stellen analysiert? <br><br>  Sie stellten die Frage, in welchen Technologien die Nachfrage auf dem Arbeitsmarkt am aktuellsten ist.  Vor einem Monat?  Vor einem Jahr? <br><br>  Wie oft werden neue Java-Stellenangebote in einem bestimmten Bereich Ihrer Stadt geöffnet und wie aktiv werden sie geschlossen? <br><br>  In diesem Artikel werde ich Ihnen erklären, wie Sie das gewünschte Ergebnis erzielen und ein Berichtssystem zu einem für uns interessanten Thema aufbauen können.  Lass uns gehen! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z0/f8/y8/z0f8y8sbxdtwpnhis-xvvclfodc.gif"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Bildquelle)</a> <br><a name="habracut"></a><br><h3>  Die Wahl fiel auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Headhunter.ru</a> </h3><br>  Wahrscheinlich sind viele von Ihnen vertraut und haben sogar eine Ressource wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Headhunter.ru verwendet</a> .  Täglich werden auf dieser Website Tausende neuer Stellen in verschiedenen Bereichen ausgeschrieben.  HeadHunter verfügt außerdem über eine API, mit der der Entwickler mit den Daten dieser Ressource interagieren kann. <br><br><h3>  Toolkit </h3><br>  Anhand eines einfachen Beispiels betrachten wir den Aufbau des Prozesses zum Abrufen von Daten für das Berichtssystem, der auf der Arbeit mit der API-Site Headhunter.ru basiert.  Als Zwischenspeicherung von Informationen verwenden wir das eingebettete SQLite-DBMS. Die verarbeiteten Daten werden in der NoSQL-Datenbank von MongoDB, Python 3.4, als Hauptsprache gespeichert. <br><br><div class="spoiler">  <b class="spoiler_title">HH API</b> <div class="spoiler_text">  Die Funktionen der HeadHunter-API sind sehr umfangreich und in der offiziellen Dokumentation zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHib</a> ausführlich beschrieben.  Dies ist zunächst die Möglichkeit, anonyme Anforderungen zu senden, für die keine Berechtigung zum Empfangen von Auftragsinformationen im JSON-Format erforderlich ist.  In letzter Zeit wurden eine Reihe von Methoden bezahlt (Arbeitgebermethoden), die jedoch bei dieser Aufgabe nicht berücksichtigt werden. <br></div></div><br><blockquote>  Jede freie Stelle bleibt 30 Tage lang auf der Website. Wenn sie nicht erneuert wird, wird sie archiviert.  Wurde die Stelle vor Ablauf von 30 Tagen archiviert, wurde <b>sie vom</b> Arbeitgeber <b>geschlossen</b> . <br><br>  Mit der HeadHunter-API (im Folgenden als HH-API bezeichnet) können Sie eine Reihe veröffentlichter Stellenangebote für jedes Datum in den letzten 30 Tagen erhalten, die wir verwenden werden. Wir erfassen <b>täglich</b> veröffentlichte Stellenangebote für jeden Tag. <br></blockquote><h2>  Implementierung </h2><br><ul><li>  Verbinden Sie SQLite DB <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sqlite3 conn_db = sqlite3.connect(<span class="hljs-string"><span class="hljs-string">'hr.db'</span></span>, timeout=<span class="hljs-number"><span class="hljs-number">10</span></span>) c = conn_db.cursor()</code> </pre> </li><li>  Tabelle zum Speichern von Änderungen im Auftragsstatus <br>  Der Einfachheit halber speichern wir den Verlauf der Änderung des Stellenstatus (Verfügbarkeit nach Datum) in einer speziellen Tabelle der SQLite-Datenbank.  Dank der Tabelle <b>vacancy_history wissen</b> wir zu jedem Zeitpunkt des Entladens, d. H.  Welche Daten war sie aktiv. <br><br><pre> <code class="python hljs">c.execute(<span class="hljs-string"><span class="hljs-string">''' create table if not exists vacancy_history ( id_vacancy integer, date_load text, date_from text, date_to text )'''</span></span>)</code> </pre> </li><li>  Stellenfilterung <br>  Es gibt eine Einschränkung, dass eine Anfrage nicht mehr als 2000 Sammlungen zurückgeben kann. Da an einem Tag viel mehr Stellen auf der Website veröffentlicht werden können, werden wir einen Filter in den Anfragetext einfügen, zum Beispiel: Stellen nur in St. Petersburg (Bereich = 2) nach IT-Spezialisierung (Spezialisierung = 1) <br><br><pre> <code class="python hljs">path = (<span class="hljs-string"><span class="hljs-string">"/vacancies?area=2&amp;specialization=1&amp;page={}&amp;per_page={}&amp;date_from={}&amp;date_to={}"</span></span>.format(page, per_page, date_from, date_to))</code> </pre> </li><li>  Zusätzliche Auswahlbedingungen <br>  Der Arbeitsmarkt wächst schnell und selbst unter Berücksichtigung des Filters kann die Anzahl der offenen Stellen 2000 überschreiten. Daher werden wir für jeden Tag ein zusätzliches Limit in Form eines separaten Starts festlegen: freie Stellen für die erste Tageshälfte und freie Stellen für die zweite Tageshälfte <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_vacancy_history</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... count_days = <span class="hljs-number"><span class="hljs-number">30</span></span> hours = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> count_days &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> hours &lt; <span class="hljs-number"><span class="hljs-number">24</span></span>: date_from = (cur_date.replace(hour=hours, minute=<span class="hljs-number"><span class="hljs-number">0</span></span>, second=<span class="hljs-number"><span class="hljs-number">0</span></span>) - td(days=count_days)).strftime(<span class="hljs-string"><span class="hljs-string">'%Y-%m-%dT%H:%M:%S'</span></span>) date_to = (cur_date.replace(hour=hours + <span class="hljs-number"><span class="hljs-number">11</span></span>, minute=<span class="hljs-number"><span class="hljs-number">59</span></span>, second=<span class="hljs-number"><span class="hljs-number">59</span></span>) - td(days=count_days)).strftime(<span class="hljs-string"><span class="hljs-string">'%Y-%m-%dT%H:%M:%S'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> count == per_page: path = (<span class="hljs-string"><span class="hljs-string">"/vacancies?area=2&amp;specialization=1&amp;page={} &amp;per_page={}&amp;date_from={}&amp;date_to={}"</span></span> .format(page, per_page, date_from, date_to)) conn.request(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, path, headers=headers) response = conn.getresponse() vacancies = response.read() conn.close() count = len(json.loads(vacancies)[<span class="hljs-string"><span class="hljs-string">'items'</span></span>]) ... <span class="hljs-comment"><span class="hljs-comment">#     try: c.executemany('INSERT INTO vacancy_history VALUES (?,?,?,?)', collection_for_ins) except sqlite3.DatabaseError as err: print("Error: ", err) else: conn_db.commit() if collection_for_ins: page = page + 1 total = total + count #   del(collection_for_ins[:]) hours = hours + 12 count_days = count_days - 1 hours = 0</span></span></code> </pre><br></li></ul><br><div class="spoiler">  <b class="spoiler_title">Erster Anwendungsfall</b> <div class="spoiler_text">  Nehmen wir an, wir stehen vor der Aufgabe, offene Stellen zu identifizieren, die für ein bestimmtes Zeitintervall geschlossen wurden, beispielsweise für Juli 2018.  Dies wird wie folgt gelöst: Das Ergebnis einer einfachen SQL-Abfrage an die Tabelle vacancy_history gibt die benötigten Daten zurück, die zur weiteren Analyse an den DataFrame übergeben werden können: <br><br><pre> <code class="python hljs"> c.execute(<span class="hljs-string"><span class="hljs-string">""" select a.id_vacancy, date(a.date_load) as date_last_load, date(a.date_from) as date_publish, ifnull(a.date_next, date(a.date_load, '+1 day')) as date_close from ( select vh1.id_vacancy, vh1.date_load, vh1.date_from, min(vh2.date_load) as date_next from vacancy_history vh1 left join vacancy_history vh2 on vh1.id_vacancy = vh2.id_vacancy and vh1.date_load &lt; vh2.date_load where date(vh1.date_load) between :date_in and :date_out group by vh1.id_vacancy, vh1.date_load, vh1.date_from ) as a where a.date_next is null """</span></span>, {<span class="hljs-string"><span class="hljs-string">"date_in"</span></span> : date_in, <span class="hljs-string"><span class="hljs-string">"date_out"</span></span> : date_out}) date_in = dt.datetime(<span class="hljs-number"><span class="hljs-number">2018</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) date_out = dt.datetime(<span class="hljs-number"><span class="hljs-number">2018</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>) closed_vacancies = get_closed_by_period(date_in, date_out) df = pd.DataFrame(closed_vacancies, columns = [<span class="hljs-string"><span class="hljs-string">'id_vacancy'</span></span>, <span class="hljs-string"><span class="hljs-string">'date_last_load'</span></span>, <span class="hljs-string"><span class="hljs-string">'date_publish'</span></span>, <span class="hljs-string"><span class="hljs-string">'date_close'</span></span>]) df.head()</code> </pre> <br>  Wir erhalten das Ergebnis dieses Typs: <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  id_vacancy </th><th>  date_last_load </th><th>  date_publish </th><th>  date_close </th></tr><tr><td>  0 </td><td>  18126697 </td><td>  2018-07-09 </td><td>  2018-07-09 </td><td>  2018-07-10 </td></tr><tr><td>  1 </td><td>  18155121 </td><td>  2018-07-09 </td><td>  2018-06-19 </td><td>  2018-07-10 </td></tr><tr><td>  2 </td><td>  18881605 </td><td>  2018-07-09 </td><td>  2018-07-02 </td><td>  2018-07-10 </td></tr><tr><td>  3 </td><td>  19620783 </td><td>  2018-07-09 </td><td>  2018-06-27 </td><td>  2018-07-10 </td></tr><tr><td>  4 </td><td>  19696188 </td><td>  2018-07-09 </td><td>  2018-06-15 </td><td>  2018-07-10 </td></tr></tbody></table></div>  Wenn wir mit Excel-Tools oder BI-Tools von Drittanbietern analysieren möchten, können wir die Tabelle vacancy_history zur weiteren Analyse in eine CSV-Datei hochladen: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       CSV data = c.execute('select * from vacancy_history') with open('vacancy_history.csv','w', newline='') as out_csv_file: csv_out = csv.writer(out_csv_file) csv_out.writerow(d[0] for d in data.description) csv_out.writerows(data.fetchall()) conn_db.close()</span></span></code> </pre> </div></div><br><h3>  Schwere Artillerie </h3><br>  Was aber, wenn wir komplexere Datenanalysen durchführen müssen?  Hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hilft die</a> dokumentenorientierte NoSQL-Datenbank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MongoDB</a> , mit der Sie Daten im JSON-Format speichern können. <br><br><ul><li>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mLab-</a> Clouddienst wird eine Demo meiner MongoDB-Datenbank bereitgestellt, mit der Sie kostenlos eine Datenbank mit bis zu 500 MB erstellen können. Dies reicht aus, um die aktuelle Aufgabe zu analysieren.  Die Datenbank hr_db verfügt über eine Vacancy-Sammlung, zu der eine Verbindung hergestellt wird: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    Mongo from pymongo import MongoClient from pymongo import ASCENDING from pymongo import errors client = MongoClient('mongodb://&lt;db_user&gt;:&lt;dbpassword&gt;@ds115219.mlab.com:15219/hr_db') db = client.hr_db VacancyMongo = db.Vacancy</span></span></code> </pre> </li><li>  Es ist anzumerken, dass das Gehaltsniveau nicht immer in Rubel angegeben ist. Für die Analyse ist es daher erforderlich, alle Werte auf das Rubeläquivalent zu bringen.  Dazu pumpen wir mithilfe der HH-API eine Sammlung von Wörterbüchern aus, die Informationen zum Wechselkurs für das aktuelle Datum enthält: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   def get_dictionaries(): conn = http.client.HTTPSConnection("api.hh.ru") conn.request("GET", "https://api.hh.ru/dictionaries", headers=headers) response = conn.getresponse() if response.status != 200: conn.close() conn = http.client.HTTPSConnection("api.hh.ru") conn.request("GET", "https://api.hh.ru/dictionaries", headers=headers) response = conn.getresponse() dictionaries = response.read() dictionaries_json = json.loads(dictionaries) return dictionaries_json</span></span></code> </pre> </li><li>  Füllen Sie das Wörterbuch mit Währungen mit aktuellen Wechselkursen aus: <br><br><pre> <code class="python hljs">hh_dictionary = get_dictionaries() currencies = hh_dictionary[<span class="hljs-string"><span class="hljs-string">'currency'</span></span>] currency_rates = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> currency <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> currencies: currency_rates[currency[<span class="hljs-string"><span class="hljs-string">'code'</span></span>]] = currency[<span class="hljs-string"><span class="hljs-string">'rate'</span></span>]</code> </pre><br></li></ul><blockquote>  Die oben genannten Maßnahmen zum Sammeln von Stellenangeboten werden täglich gestartet, sodass nicht jedes Mal alle Stellenangebote angezeigt und detaillierte Informationen zu den einzelnen Stellen erhalten werden müssen.  Wir nehmen nur diejenigen, die in den letzten <b>fünf</b> Tagen eingegangen sind. </blockquote><ul><li>  Abrufen einer Reihe von Stellenangeboten für die letzten 5 Tage aus einer SQLite-Datenbank: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_list_of_vacancies_sql</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> conn_db = sqlite3.connect(<span class="hljs-string"><span class="hljs-string">'hr.db'</span></span>, timeout=<span class="hljs-number"><span class="hljs-number">10</span></span>) conn_db.row_factory = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> cursor, row: row[<span class="hljs-number"><span class="hljs-number">0</span></span>] c = conn_db.cursor() items = c.execute(<span class="hljs-string"><span class="hljs-string">""" select distinct id_vacancy from vacancy_history where date(date_load) &gt;= date('now', '-5 day') """</span></span>).fetchall() conn_db.close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items</code> </pre> </li><li>  Eine Reihe von Jobs für die letzten fünf Tage von MongoDB erhalten: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_list_of_vacancies_nosql</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> date_load = (dt.datetime.now() - td(days=<span class="hljs-number"><span class="hljs-number">5</span></span>)).strftime(<span class="hljs-string"><span class="hljs-string">'%Y-%m-%d'</span></span>) vacancies_from_mongo = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> VacancyMongo.find({<span class="hljs-string"><span class="hljs-string">"date_load"</span></span> : {<span class="hljs-string"><span class="hljs-string">"$gte"</span></span> : date_load}}, {<span class="hljs-string"><span class="hljs-string">"id"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"_id"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>}): vacancies_from_mongo.append(int(item[<span class="hljs-string"><span class="hljs-string">'id'</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vacancies_from_mongo</code> </pre></li><li>  Es bleibt der Unterschied zwischen den beiden Arrays zu ermitteln. Für Stellenangebote, die nicht in MongoDB enthalten sind, müssen detaillierte Informationen abgerufen und in die Datenbank geschrieben werden: <br><br><pre> <code class="python hljs">sql_list = get_list_of_vacancies_sql() mongo_list = get_list_of_vacancies_nosql() vac_for_pro = [] s = set(mongo_list) vac_for_pro = [x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sql_list <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s] vac_id_chunks = [vac_for_pro[x: x + <span class="hljs-number"><span class="hljs-number">500</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(vac_for_pro), <span class="hljs-number"><span class="hljs-number">500</span></span>)]</code> </pre></li><li>  Wir haben also ein Array mit neuen Stellenangeboten, die in MongoDB noch nicht verfügbar sind. Wir erhalten detaillierte Informationen zu jedem dieser Stellen mithilfe einer Anfrage in der HH-API. Bevor wir sie direkt in MongoDB verarbeiten, verarbeiten wir jedes Dokument: <br><ol><li>  Wir bringen die Höhe der Löhne auf das Rubeläquivalent; </li><li>  Fügen Sie jeder offenen Stelle (Junior / Middle / Senior usw.) einen Abschluss eines Fachniveaus hinzu. </li></ol><br>  All dies ist in der Funktion vacancies_processing implementiert: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> nltk.stem.snowball <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SnowballStemmer stemmer = SnowballStemmer(<span class="hljs-string"><span class="hljs-string">"russian"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vacancies_processing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vacancies_list)</span></span></span><span class="hljs-function">:</span></span> cur_date = dt.datetime.now().strftime(<span class="hljs-string"><span class="hljs-string">'%Y-%m-%d'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> vacancy_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vacancies_list: conn = http.client.HTTPSConnection(<span class="hljs-string"><span class="hljs-string">"api.hh.ru"</span></span>) conn.request(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"/vacancies/{}"</span></span>.format(vacancy_id), headers=headers) response = conn.getresponse() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> response.status != <span class="hljs-number"><span class="hljs-number">404</span></span>: vacancy_txt = response.read() conn.close() vacancy = json.loads(vacancy_txt) <span class="hljs-comment"><span class="hljs-comment"># salary salary = None if 'salary' in vacancy: if vacancy['salary'] != None: ... max_salary = 500000 if salary is not None: salary = int(salary) if salary &gt;= max_salary: salary = max_salary # grade grade = None if 'name' in vacancy: p_grade = '' title = re.sub(u'[^a-z-]+', ' ', vacancy['name'].lower(), re.UNICODE) words = re.split(r'\s{1,}', title.strip()) for title_word in words: title_word = stemmer.stem(title_word) if len(title_word.strip()) &gt; 1: p_grade = p_grade + " " + title_word.strip() if re.search('()|(princip)', p_grade): grade = 'principal' elif re.search('()|(senior)|([f|F]ull)', p_grade): grade = 'senior' ... else: grade = 'not specify' vacancy['salary_processed'] = salary vacancy['date_load'] = cur_date vacancy['grade'] = grade vacancy.pop('branded_description', None) try: post_id = VacancyMongo.insert_one(vacancy) except errors.DuplicateKeyError: print ('Cant insert the duplicate vacancy_id:', vacancy['id'])</span></span></code> </pre></li><li>  Abrufen detaillierter Informationen durch Zugriff auf die HH-API, empfangene Vorverarbeitung <br>  MongoDB wird die Daten ausführen und in mehrere Streams mit jeweils 500 offenen Stellen einfügen: <br><br><pre> <code class="python hljs">t_num = <span class="hljs-number"><span class="hljs-number">1</span></span> threads = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> vac_id_chunk <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vac_id_chunks: print(<span class="hljs-string"><span class="hljs-string">'starting'</span></span>, t_num) t_num = t_num + <span class="hljs-number"><span class="hljs-number">1</span></span> t = threading.Thread(target=vacancies_processing, kwargs={<span class="hljs-string"><span class="hljs-string">'vacancies_list'</span></span>: vac_id_chunk}) threads.append(t) t.start() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> threads: t.join()</code> </pre> <br></li></ul><br>  Die bevölkerte Sammlung in MongoDB sieht ungefähr so ​​aus: <br><br> <a href=""><img src="https://habrastorage.org/webt/er/vq/sy/ervqsyhywfqykkbh2stmqgumc9q.jpeg"></a> <br><br><h2>  Einige weitere Beispiele </h2><br>  Mit der gesammelten Datenbank können wir verschiedene analytische Proben durchführen.  Also werde ich die Top 10 der bestbezahlten Stellenangebote von Python-Entwicklern in St. Petersburg herausbringen: <br><br><pre> <code class="python hljs">cursor_mongo = VacancyMongo.find({<span class="hljs-string"><span class="hljs-string">"name"</span></span> : {<span class="hljs-string"><span class="hljs-string">"$regex"</span></span> : <span class="hljs-string"><span class="hljs-string">".*[pP]ython*"</span></span>}}) df_mongo = pd.DataFrame(list(cursor_mongo)) <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> df_mongo[<span class="hljs-string"><span class="hljs-string">'_id'</span></span>] pd.concat([df_mongo.drop([<span class="hljs-string"><span class="hljs-string">'employer'</span></span>], axis=<span class="hljs-number"><span class="hljs-number">1</span></span>), df_mongo[<span class="hljs-string"><span class="hljs-string">'employer'</span></span>].apply(pd.Series)[<span class="hljs-string"><span class="hljs-string">'name'</span></span>]], axis=<span class="hljs-number"><span class="hljs-number">1</span></span>)[[<span class="hljs-string"><span class="hljs-string">'grade'</span></span>, <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'salary_processed'</span></span> ]].sort_values(<span class="hljs-string"><span class="hljs-string">'salary_processed'</span></span>, ascending=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>)[:<span class="hljs-number"><span class="hljs-number">10</span></span>]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Top 10 der bestbezahlten Jobs von Python</b> <div class="spoiler_text"><table border="1"><thead><tr><th>  Klasse </th><th>  Name </th><th>  Name </th><th>  Gehalt_verarbeitet </th></tr></thead><tbody><tr><td>  Senior </td><td>  Web Teamleiter / Architekt (Python / Django / React) </td><td>  Investex Ltd. </td><td>  293901.0 </td></tr><tr><td>  Senior </td><td>  Leitender Python-Entwickler in Montenegro </td><td>  Betmaster </td><td>  277141.0 </td></tr><tr><td>  Senior </td><td>  Leitender Python-Entwickler in Montenegro </td><td>  Betmaster </td><td>  275289.0 </td></tr><tr><td>  Mitte </td><td>  Back-End-Webentwickler (Python) </td><td>  Soshace </td><td>  250000.0 </td></tr><tr><td>  Mitte </td><td>  Back-End-Webentwickler (Python) </td><td>  Soshace </td><td>  250000.0 </td></tr><tr><td>  Senior </td><td>  Leitender Python-Ingenieur für ein Schweizer Startup </td><td>  Assaia International AG </td><td>  250000.0 </td></tr><tr><td>  Mitte </td><td>  Back-End-Webentwickler (Python) </td><td>  Soshace </td><td>  250000.0 </td></tr><tr><td>  Mitte </td><td>  Back-End-Webentwickler (Python) </td><td>  Soshace </td><td>  250000.0 </td></tr><tr><td>  Senior </td><td>  Python-Teamleiter </td><td>  Digitalhr </td><td>  230000.0 </td></tr><tr><td>  Senior </td><td>  Leitender Entwickler (Python, PHP, Javascript) </td><td>  IK GROUP </td><td>  220231.0 </td></tr></tbody></table></div><br></div><br><br>  Lassen Sie uns nun herausfinden, welche U-Bahn-Station die höchste Konzentration an freien Stellen für Java-Entwickler aufweist.  Mit einem regulären Ausdruck filtere ich nach dem Jobtitel "Java" und wähle auch nur die Jobs aus, bei denen die Adresse angegeben ist: <br><br><pre> <code class="python hljs">cursor_mongo = VacancyMongo.find({<span class="hljs-string"><span class="hljs-string">"name"</span></span> : {<span class="hljs-string"><span class="hljs-string">"$regex"</span></span> : <span class="hljs-string"><span class="hljs-string">".*[jJ]ava[^sS]"</span></span>}, <span class="hljs-string"><span class="hljs-string">"address"</span></span> : {<span class="hljs-string"><span class="hljs-string">"$ne"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>}}) df_mongo = pd.DataFrame(list(cursor_mongo)) df_mongo[<span class="hljs-string"><span class="hljs-string">'metro'</span></span>] = df_mongo.apply(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-string"><span class="hljs-string">'address'</span></span>][<span class="hljs-string"><span class="hljs-string">'metro'</span></span>][<span class="hljs-string"><span class="hljs-string">'station_name'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x[<span class="hljs-string"><span class="hljs-string">'address'</span></span>][<span class="hljs-string"><span class="hljs-string">'metro'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, axis = <span class="hljs-number"><span class="hljs-number">1</span></span>) df_mongo.groupby(<span class="hljs-string"><span class="hljs-string">'metro'</span></span>)[<span class="hljs-string"><span class="hljs-string">'_id'</span></span>] \ .count() \ .reset_index(name=<span class="hljs-string"><span class="hljs-string">'count'</span></span>) \ .sort_values([<span class="hljs-string"><span class="hljs-string">'count'</span></span>], ascending=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) \ [:<span class="hljs-number"><span class="hljs-number">10</span></span>]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jobs für Java-Entwickler in U-Bahn-Stationen</b> <div class="spoiler_text"><table border="1"><thead><tr><th>  U-Bahn </th><th>  zählen </th></tr></thead><tbody><tr><td>  Vasileostrovskaya </td><td>  87 </td></tr><tr><td>  Petrogradskaya </td><td>  68 </td></tr><tr><td>  Wyborg </td><td>  46 </td></tr><tr><td>  Lenin-Platz </td><td>  45 </td></tr><tr><td>  Gorkovskaya </td><td>  45 </td></tr><tr><td>  Chkalovskaya </td><td>  43 </td></tr><tr><td>  Narva </td><td>  32 </td></tr><tr><td>  Aufstandsplatz </td><td>  29 </td></tr><tr><td>  Altes Dorf </td><td>  29 </td></tr><tr><td>  Elizarovskaya </td><td>  27 </td></tr></tbody></table></div><br></div><br><h2>  Zusammenfassung </h2><br>  Die Analysefunktionen des entwickelten Systems sind also wirklich breit und können verwendet werden, um einen Start zu planen oder eine neue Richtung der Aktivität zu eröffnen. <br><br>  Ich stelle fest, dass bisher nur die Grundfunktionalität des Systems vorgestellt wird. In Zukunft ist geplant, sich in Richtung Analyse durch geografische Koordinaten zu entwickeln und das Auftreten von Leerständen in einem bestimmten Bereich der Stadt vorherzusagen. <br><br>  Den vollständigen Quellcode für diesen Artikel finden Sie unter dem Link zu meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> . <br><br>  <b>PS</b> Kommentare zu dem Artikel sind willkommen. Gerne beantworte ich alle Ihre Fragen und finde Ihre Meinung heraus.  Vielen Dank! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422627/">https://habr.com/ru/post/de422627/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422613/index.html">PowerPool Cybergroup hat die Zero-Day-Sicherheitsanfälligkeit in Advanced Local Procedure Call gemeistert</a></li>
<li><a href="../de422615/index.html">Die ganze Wahrheit über RTOS. Artikel 9. Scheduler: Implementierung</a></li>
<li><a href="../de422617/index.html">Die ganze Wahrheit über RTOS. Artikel 8. Nucleus SE: Internes Design und Bereitstellung</a></li>
<li><a href="../de422623/index.html">So sichern Sie C.</a></li>
<li><a href="../de422625/index.html">Wir haben mit Troy Miles gesprochen - dem Programmierer von "Neuromancer"</a></li>
<li><a href="../de422629/index.html">Hör auf, die Holzfäller zu füttern! Gib mehr Modifikatoren! Lazy Static Final Fields. Entwurf einer Feature-Skizze</a></li>
<li><a href="../de422631/index.html">QIWI-Terminals. So holen Sie das Beste aus einfachen Technologien heraus</a></li>
<li><a href="../de422633/index.html">Wie wir die Überwachung der Arbeit der Mitarbeiter des Tankstellennetzes des Bundes automatisiert haben</a></li>
<li><a href="../de422635/index.html">Sie haben das Wort "Hallo" noch nicht gesagt und wir wissen bereits, wer Sie sind</a></li>
<li><a href="../de422637/index.html">Geeks Geschenk: Auto-Alkash-Schutz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>