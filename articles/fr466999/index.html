<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕡 👃 💥 Comparaison des bibliothèques CLI populaires pour Python: clic, ciment, feu et autres 🤟 😱 🌪️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Python est un excellent langage pour les applications console, et il met en évidence un grand nombre de bibliothèques pour ces tâches. Mais quelles bi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comparaison des bibliothèques CLI populaires pour Python: clic, ciment, feu et autres</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466999/"><img src="https://habrastorage.org/webt/rp/ek/be/rpekben_u6jtlwru-flsslxk70e.png"><br><br>  Python est un excellent langage pour les applications console, et il met en évidence un grand nombre de bibliothèques pour ces tâches.  <i>Mais quelles bibliothèques existent?</i>  <i>Et quoi de mieux à prendre?</i>  Ce matériel compare les outils populaires et peu utilisés pour le monde des consoles et tente de répondre à la deuxième question. <br><br>  Pour faciliter la lecture, la revue est divisée en deux articles: le premier compare les six bibliothèques les plus populaires, le second - moins populaire et plus spécifique, mais mérite tout de même l'attention. <br><a name="habracut"></a><br>  Dans chacun des exemples, un utilitaire de console pour la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">todolib</a> sera écrit en Python 3.7, avec lequel vous pouvez créer, afficher, baliser et supprimer des tâches.  Le reste sera ajouté sous réserve de la simplicité de mise en œuvre sur un cadre particulier.  Les tâches elles-mêmes sont stockées dans un fichier json, qui sera enregistré dans un appel distinct - une condition supplémentaire pour les exemples. <br>  En plus de cela, un test trivial sera écrit pour chaque implémentation.  Pytest avec les appareils suivants a été utilisé comme cadre de test: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@pytest.fixture(autouse=True) def db(monkeypatch): """ monkeypatch     ,        """ value = {"tasks": []} monkeypatch.setattr(todolib.TodoApp, "get_db", lambda _: value) return value @pytest.yield_fixture(autouse=True) def check(db): """      """ yield assert db["tasks"] and db["tasks"][0]["title"] == "test" # ,      EXPECTED = "Task 'test' created with number 1.\n"</span></span></code> </pre> <br>  En principe, tout ce qui précède sera suffisant pour démontrer les bibliothèques.  Le code source complet est disponible dans <a href="">ce</a> référentiel. <br><br><h2>  argparse </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Argparse</a> a un avantage indéniable - il est dans la bibliothèque standard et son API n'est pas difficile à apprendre: il y a un analyseur, il y a des arguments, les arguments ont <i>type</i> , <i>action</i> , <i>dest</i> , <i>default</i> et <i>help</i> .  Et il y a un sous- <i>analyseur</i> - la possibilité de séparer une partie des arguments et de la logique en commandes distinctes. <br><br><h4>  Analyseur </h4><br>  À première vue - rien d'inhabituel, l'analyseur est comme un analyseur.  Mais - à mon avis - la lisibilité n'est pas la meilleure par rapport à d'autres bibliothèques, car  les arguments des différentes commandes sont décrits au même endroit. <br><br><div class="spoiler">  <b class="spoiler_title">code source</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_parser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> parser = argparse.ArgumentParser(<span class="hljs-string"><span class="hljs-string">"Todo notes - argparse version"</span></span>) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--verbose"</span></span>, <span class="hljs-string"><span class="hljs-string">"-v"</span></span>, action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Enable verbose mode"</span></span> ) parser.add_argument(<span class="hljs-string"><span class="hljs-string">"--version"</span></span>, <span class="hljs-string"><span class="hljs-string">"-V"</span></span>, action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Show version"</span></span>) subparsers = parser.add_subparsers(title=<span class="hljs-string"><span class="hljs-string">"Commands"</span></span>, dest=<span class="hljs-string"><span class="hljs-string">"cmd"</span></span>) add = subparsers.add_parser(<span class="hljs-string"><span class="hljs-string">"add"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Add new task"</span></span>) add.add_argument(<span class="hljs-string"><span class="hljs-string">"title"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Todo title"</span></span>) show = subparsers.add_parser(<span class="hljs-string"><span class="hljs-string">"show"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Show tasks"</span></span>) show.add_argument( <span class="hljs-string"><span class="hljs-string">"--show-done"</span></span>, action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Include done tasks in the output"</span></span> ) done = subparsers.add_parser(<span class="hljs-string"><span class="hljs-string">"done"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Mark task as done"</span></span>) done.add_argument(<span class="hljs-string"><span class="hljs-string">"number"</span></span>, type=int, help=<span class="hljs-string"><span class="hljs-string">"Task number"</span></span>) remove = subparsers.add_parser(<span class="hljs-string"><span class="hljs-string">"remove"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Remove task"</span></span>) remove.add_argument(<span class="hljs-string"><span class="hljs-string">"number"</span></span>, type=int, help=<span class="hljs-string"><span class="hljs-string">"Task number"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser</code> </pre><br></div></div><br><h4>  principal </h4><br>  Et ici, la même chose - l'analyseur, à l'exception des arguments d'analyse, ne peut rien faire de plus, de sorte que la logique devra être écrite indépendamment et en un seul endroit.  D'une part - il est possible de vivre, d'autre part - c'est possible mieux, mais on ne sait pas encore comment. <br><br>  <b>UPD:</b> <i>Comme l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">a</a> noté <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">foldr</a> , en fait, les sous-analyseurs peuvent définir des fonctions via set_defaults (func = foo), c'est-à-dire, argparse vous permet de raccourcir le principal en petites tailles.</i>  <i>Vivez et apprenez.</i> <br><br><div class="spoiler">  <b class="spoiler_title">code source</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(raw_args=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Argparse example entrypoint """</span></span> parser = get_parser() args = parser.parse_args(raw_args) logging.basicConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.verbose: logging.getLogger(<span class="hljs-string"><span class="hljs-string">"todolib"</span></span>).setLevel(logging.INFO) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.version: print(lib_version) exit(<span class="hljs-number"><span class="hljs-number">0</span></span>) cmd = args.cmd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> cmd: parser.print_help() exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> TodoApp.fromenv() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> app: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd == <span class="hljs-string"><span class="hljs-string">"add"</span></span>: task = app.add_task(args.title) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> cmd == <span class="hljs-string"><span class="hljs-string">"show"</span></span>: app.print_tasks(args.show_done) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> cmd == <span class="hljs-string"><span class="hljs-string">"done"</span></span>: task = app.task_done(args.number) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> cmd == <span class="hljs-string"><span class="hljs-string">"remove"</span></span>: task = app.remove_task(args.number) print(task, <span class="hljs-string"><span class="hljs-string">"removed from list."</span></span>)</code> </pre><br></div></div><br><h4>  Test </h4><br>  Pour vérifier la sortie de l'utilitaire, le luminaire <i>capsys</i> est <i>utilisé</i> , ce qui donne accès au texte de stdout et stderr. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_argparse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capsys)</span></span></span><span class="hljs-function">:</span></span> todo_argparse.main([<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) out, _ = capsys.readouterr() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> out == EXPECTED</code> </pre><br><h4>  Résumé </h4><br>  Des avantages - un bon ensemble de fonctionnalités pour l'analyse, la présence d'un module dans la bibliothèque standard. <br><br>  Contre - argparse ne traite que des arguments d'analyse, la plupart de la logique principale a dû être écrite par moi-même.  Et on ne sait pas comment tester le code de sortie dans les tests. <br><br><h2>  docopt </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docopt</a> est un petit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analyseur</a> (&lt;600 lignes, comparé à 2500 avec argparse), qui vous fera sourire, citant une description sur GitHub.  L'idée principale de docopt est de décrire l'interface littéralement avec du texte, par exemple, dans docstring. <br><br>  Sur le même github, docopt&gt; 6700 étoiles, il est utilisé dans au moins 22 mille autres projets.  Et ce n'est qu'avec l'implémentation de python!  La page du projet docopt propose de nombreuses options pour différents langages, du C et PHP au CoffeeScript et même au R. Une telle multiplateforme ne peut être expliquée que par la compacité et la simplicité du code. <br><br><h4>  Analyseur </h4><br>  Comparé à argparse, cet analyseur est un grand pas en avant. <br><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Todo notes on docopt. Usage: todo_docopt [-v | -vv ] add &lt;task&gt; todo_docopt [-v | -vv ] show --show-done todo_docopt [-v | -vv ] done &lt;number&gt; todo_docopt [-v | -vv ] remove &lt;number&gt; todo_docopt -h | --help todo_docopt --version Options: -h --help Show help. -v --verbose Enable verbose mode. """</span></span></code> </pre><br><h4>  principal </h4><br>  En général, tout est identique à argparse, mais maintenant <i>verbeux</i> peut avoir plusieurs valeurs (0-2), et l'accès aux arguments est différent: docopt ne renvoie pas un espace de noms avec des attributs, mais juste un dictionnaire, où le choix d'une commande est indiqué à travers son booléen, comme on le voit <i>si</i> : <br><br><div class="spoiler">  <b class="spoiler_title">code source</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(argv=None)</span></span></span><span class="hljs-function">:</span></span> args = docopt(__doc__, argv=argv, version=lib_version) log.setLevel(levels[args[<span class="hljs-string"><span class="hljs-string">"--verbose"</span></span>]]) logging.basicConfig() log.debug(<span class="hljs-string"><span class="hljs-string">"Arguments: %s"</span></span>, args) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> TodoApp.fromenv() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> app: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args[<span class="hljs-string"><span class="hljs-string">"add"</span></span>]: task = app.add_task(args[<span class="hljs-string"><span class="hljs-string">"&lt;task&gt;"</span></span>]) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> args[<span class="hljs-string"><span class="hljs-string">"show"</span></span>]: app.print_tasks(args[<span class="hljs-string"><span class="hljs-string">"--show-done"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> args[<span class="hljs-string"><span class="hljs-string">"done"</span></span>]: task = app.task_done(args[<span class="hljs-string"><span class="hljs-string">"&lt;number&gt;"</span></span>]) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> args[<span class="hljs-string"><span class="hljs-string">"remove"</span></span>]: task = app.remove_task(args[<span class="hljs-string"><span class="hljs-string">"&lt;number&gt;"</span></span>]) print(task, <span class="hljs-string"><span class="hljs-string">"removed from list."</span></span>)</code> </pre><br></div></div><br><h4>  Test </h4><br>  Similaire aux tests argparse: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_docopt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capsys)</span></span></span><span class="hljs-function">:</span></span> todo_docopt.main([<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) out, _ = capsys.readouterr() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> out == EXPECTED</code> </pre><br><h4>  Résumé </h4><br>  Des avantages - beaucoup moins de code pour l'analyseur, facilité de description et de lecture des commandes et des arguments, version intégrée. <br><br>  Inconvénients, tout d'abord, la même chose que argparse - beaucoup de logique en <i>principal</i> , vous ne pouvez pas tester le code de sortie.  De plus, la version actuelle (0.6.2) de docopt n'est pas encore stable et ne le sera probablement jamais - le projet se développait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">activement</a> de 2012 à fin 2013, le dernier commit était le 17 décembre.  Et la chose la plus désagréable pour le moment est que certains habitués de Docopt provoquent DeprecationWarning lors des tests. <br><br><h2>  Cliquez sur </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Click est</a> fondamentalement différent de argparse et docopt par le nombre de fonctionnalités et l'approche de description des commandes et des paramètres par le biais de décorateurs, et la logique elle-même est proposée pour être séparée en fonctions distinctes au lieu d'un grand <i>principal</i> .  Les auteurs affirment que Click a beaucoup de paramètres, mais les paramètres standard devraient être suffisants.  Parmi les fonctionnalités, les commandes imbriquées et leur chargement paresseux sont mis en évidence. <br><br>  Le projet est extrêmement populaire: en plus d'avoir&gt; 8100 étoiles et de l'utiliser dans au moins 174 mille (!) Projets, il est toujours en développement: la version 7.0 est sortie à l'automne 2018, et de nouvelles requêtes de validation et de fusion apparaissent à ce jour. jour. <br><br><h4>  Analyseur </h4><br>  Sur la page de documentation, j'ai trouvé le décorateur <i>confirmation_option</i> , qui demande la confirmation de l'utilisateur avant d'exécuter la commande.  Pour le démontrer, la commande wipe a été ajoutée, ce qui efface toute la liste des tâches. <br><br><div class="spoiler">  <b class="spoiler_title">code source</b> <div class="spoiler_text"><pre> <code class="python hljs">levels = [logging.WARN, logging.INFO, logging.DEBUG] pass_app = click.make_pass_decorator(TodoApp) @click.group() @click.version_option(lib_version, prog_name=<span class="hljs-string"><span class="hljs-string">"todo_click"</span></span>) @click.option(<span class="hljs-string"><span class="hljs-string">"-v"</span></span>, <span class="hljs-string"><span class="hljs-string">"--verbose"</span></span>, count=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-comment"><span class="hljs-comment"># click   ,     @click.option("--db", help="Path to the database file") @click.pass_context def cli(ctx, verbose, db): """Todo notes - click version.""" level = levels[min(verbose, 2)] logging.basicConfig(level=level) logging.getLogger("todolib").setLevel(level) ctx.obj = TodoApp.fromenv(db) atexit.register(ctx.obj.save) @cli.command() @click.argument("task") @pass_app def add(app, task): """ Add new task. """ task = app.add_task(task) click.echo(f"{task} created with number {task.number}.") @cli.command() @click.option("--show-done", is_flag=True, help="Include done tasks") @pass_app def show(app, show_done): """ Show current tasks. """ app.print_tasks(show_done) @cli.command() @click.argument("number", type=int) @pass_app def done(app, number): """ Mark task as done. """ task = app.task_done(number) click.echo(f"{task} marked as done.") @cli.command() @click.argument("number", type=int) @pass_app def remove(app, number): """ Remove task from the list. """ task = app.remove_task(number) click.echo(f"{task} removed from the list.") @cli.command() @click.confirmation_option(prompt="Are you sure you want to remove database") @pass_app def wipe(app): for task in app.list_tasks(): task.remove()</span></span></code> </pre><br></div></div><br><h4>  principal </h4><br>  Et ici, nous rencontrons le principal avantage de Click - du fait que la logique des commandes est espacée en fonction de leurs fonctions, presque rien ne reste en principal.  La capacité de la bibliothèque à recevoir des arguments et des paramètres de variables d'environnement est également illustrée ici. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: cli(auto_envvar_prefix=<span class="hljs-string"><span class="hljs-string">"TODO"</span></span>)</code> </pre><br><h4>  Test </h4><br>  Dans le cas de Click, il n'est pas nécessaire d'intercepter sys.stdout, car il existe un module <i>click.testing</i> avec un runner pour de telles choses.  Et non seulement <i>CliRunner</i> lui-même intercepte la sortie, il vous permet également de vérifier le code de sortie, ce qui est également cool.  Tout cela permet de tester les utilitaires de clic sans utiliser pytest et sans passer par le module standard <i>unittest</i> . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> click.testing <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> runner = click.testing.CliRunner() result = runner.invoke(todo_click.cli, [<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> result.exit_code == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> result.output == EXPECTED</code> </pre><br><h4>  Résumé </h4><br>  Ce n'est qu'une petite partie de ce que Click peut faire.  Du reste de l'API - validation des valeurs, intégration avec le terminal (couleurs, pager a la less, barre de progression, etc.), rappel des résultats, auto-complétion et bien plus encore.  Vous pouvez voir leurs exemples <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Avantages: beaucoup d'outils pour toute occasion, une approche originale, mais en même temps pratique pour décrire les équipes, la facilité des tests et la vie active du projet. <br><br>  Inconvénients: Quels sont les inconvénients d'un «clic» - c'est une question difficile.  Peut-être qu'il ne sait rien de ce dont les bibliothèques suivantes sont capables? <br><br><h2>  Le feu </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fire</a> n'est pas seulement une jeune bibliothèque (apparue en 2017) pour les interfaces de console de Google, c'est une bibliothèque pour générer des interfaces de console à partir, citant textuellement, <i>absolument n'importe quel objet</i> Python. <br>  Entre autres choses, il est indiqué que le feu aide au développement et au débogage du code, aide à adapter le code existant dans la CLI, facilite la transition de bash à Python et possède son propre REPL pour le travail interactif.  Verrons-nous? <br><br><h4>  Analyseur et principal </h4><br>  fire.Fire est vraiment capable d'accepter n'importe quel objet: un module, une instance de classe, un dictionnaire avec des noms de commande et des fonctions correspondantes, etc. <br><br>  Ce qui est important pour nous, c'est que le Feu permet le transfert d'un objet de classe.  Ainsi, le constructeur de classe accepte des arguments communs à toutes les commandes, et ses méthodes et attributs sont des commandes distinctes.  Nous utiliserons ceci: <br><br><div class="spoiler">  <b class="spoiler_title">code source</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Commands</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, db=None, verbose=False)</span></span></span><span class="hljs-function">:</span></span> level = logging.INFO <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> verbose <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> logging.WARNING logging.basicConfig(level=level) logging.getLogger(<span class="hljs-string"><span class="hljs-string">"todolib"</span></span>).setLevel(level) self._app = todolib.TodoApp.fromenv(db) atexit.register(self._app.save) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">version</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> todolib.__version__ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, task)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Add new task."""</span></span> task = self._app.add_task(task) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, show_done=False)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Show current tasks. """</span></span> self._app.print_tasks(show_done) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Mark task as done. """</span></span> task = self._app.task_done(number) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Removes task from the list. """</span></span> task = self._app.remove_task(number) print(task, <span class="hljs-string"><span class="hljs-string">"removed from the list."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args=None)</span></span></span><span class="hljs-function">:</span></span> fire.Fire(Commands, command=args)</code> </pre><br></div></div><br><h4>  Drapeaux en ligne </h4><br>  Fire a ses propres drapeaux avec une syntaxe spéciale (ils doivent être passés après le "-"), qui vous permettent de regarder sous le capot de l'analyseur et de l'application dans son ensemble: <br><br><div class="spoiler">  <b class="spoiler_title">exemples d'appel</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ./todo_fire.py show -- --trace Fire trace: 1. Initial component 2. Instantiated class <span class="hljs-string"><span class="hljs-string">"Commands"</span></span> (todo_fire.py:9) 3. Accessed property <span class="hljs-string"><span class="hljs-string">"show"</span></span> (todo_fire.py:25) $ ./todo_fire.py -- --verbose | head -n 12 <span class="hljs-comment"><span class="hljs-comment">#    , ,  Commands._app NAME todo_fire.py - SYNOPSIS todo_fire.py - GROUP | COMMAND GROUPS GROUP is one of the following: _app Todo Application definition. $ ./todo_fire.py show -- --interactive Fire is starting a Python REPL with the following objects: Modules: atexit, fire, logging, todolib Objects: Commands, args, component, main, result, self, todo_fire.py, trace Python 3.7.4 (default, Aug 15 2019, 13:09:37) [GCC 7.4.0] on linux Type "help", "copyright", "credits" or "license" for more information. (InteractiveConsole) &gt;&gt;&gt; self &lt;__main__.Commands object at 0x7fd0a6125bd0&gt; &gt;&gt;&gt; self._app.db {'tasks': [{'title': 'test', 'done': False}]}</span></span></code> </pre><br></div></div><br><h4>  Test </h4><br>  Tester la fonction principale est similaire à tester argparse et docopt, donc je ne vois pas le point ici. <br><br>  Dans le même temps, il convient de noter qu'en raison de la nature introspective de Fire, il est également possible de tester immédiatement la classe Commands. <br><br><h4>  Résumé </h4><br>  Le feu est un outil non moins intéressant que le clic.  Il ne nécessite pas de répertorier de nombreuses options dans l'analyseur, la configuration est minimale, il existe des options de débogage et la bibliothèque elle-même <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vit et se développe</a> encore plus activement que le clic (60 commits cet été). <br><br>  Inconvénients: peut considérablement moins que le clic et les autres analyseurs;  API instable (la version actuelle est 0.2.1). <br><br><h2>  Le ciment </h2><br>  En fait, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cement n'est</a> pas exactement une bibliothèque CLI, mais un cadre pour les applications de console, mais on prétend qu'il convient aux scripts et aux applications complexes avec diverses intégrations. <br><br><h4>  Analyseur </h4><br>  L'analyseur dans Cement semble inhabituel, mais si vous regardez attentivement les paramètres, il est facile de deviner que l'argparse familière est sous le capot.  Mais c'est peut-être pour le mieux - pas besoin d'apprendre de nouveaux paramètres. <br><br><div class="spoiler">  <b class="spoiler_title">code source</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cement <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Controller, ex <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Controller)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> label = <span class="hljs-string"><span class="hljs-string">"base"</span></span> arguments = [ ( [<span class="hljs-string"><span class="hljs-string">"-v"</span></span>, <span class="hljs-string"><span class="hljs-string">"--version"</span></span>], {<span class="hljs-string"><span class="hljs-string">"action"</span></span>: <span class="hljs-string"><span class="hljs-string">"version"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">f"todo_cement v</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{todolib.__version__}</span></span></span><span class="hljs-string">"</span></span>}, ) ] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_default</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Default action if no sub-command is passed."""</span></span> self.app.args.print_help() @ex(help=<span class="hljs-string"><span class="hljs-string">"Add new task"</span></span>, arguments=[([<span class="hljs-string"><span class="hljs-string">"task"</span></span>], {<span class="hljs-string"><span class="hljs-string">"help"</span></span>: <span class="hljs-string"><span class="hljs-string">"Task title"</span></span>})]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> title = self.app.pargs.task self.app.log.debug(<span class="hljs-string"><span class="hljs-string">f"Task title: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{title!r}</span></span></span><span class="hljs-string">"</span></span>) task = self.app.todoobj.add_task(title) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) @ex( help=<span class="hljs-string"><span class="hljs-string">"Show current tasks"</span></span>, arguments=[ ([<span class="hljs-string"><span class="hljs-string">"--show-done"</span></span>], dict(action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Include done tasks"</span></span>)) ], ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.app.todoobj.print_tasks(self.app.pargs.show_done) @ex(help=<span class="hljs-string"><span class="hljs-string">"Mark task as done"</span></span>, arguments=[([<span class="hljs-string"><span class="hljs-string">"number"</span></span>], {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: int})]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> task = self.app.todoobj.task_done(self.app.pargs.number) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) @ex(help=<span class="hljs-string"><span class="hljs-string">"Remove task from the list"</span></span>, arguments=[([<span class="hljs-string"><span class="hljs-string">"number"</span></span>], {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: int})]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> task = self.app.todoobj.remove_task(self.app.pargs.number) print(task, <span class="hljs-string"><span class="hljs-string">"removed from the list."</span></span>)</code> </pre><br></div></div><br><h4>  App et principal </h4><br>  Le ciment, entre autres, encapsule toujours les signaux dans les exceptions.  Ceci est démontré ici à la sortie de code zéro avec SIGINT / SIGTERM. <br><br><div class="spoiler">  <b class="spoiler_title">code source</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoApp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(App)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, argv=None)</span></span></span><span class="hljs-function">:</span></span> super().__init__(argv=argv) self.todoobj = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_db</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.todoobj = todolib.TodoApp.fromenv() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.todoobj.save() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># application label label = "todo_cement" # register handlers handlers = [Base] hooks = [("post_setup", lambda app: app.load_db()), ("pre_close", lambda app: app.save())] # call sys.exit() on close close_on_exit = True def main(): with TodoApp() as app: try: app.run() except CaughtSignal as e: if e.signum not in (signal.SIGINT, signal.SIGTERM): raise app.log.debug(f"\n{e}") app.exit_code = 0</span></span></code> </pre><br></div></div><br>  Si vous maîtrisez main, vous pouvez voir que le chargement et l'enregistrement de todolib.TodoApp peuvent également être effectués dans le __enter __ / __ exit__ substitué, mais ces phases ont finalement été séparées en méthodes distinctes afin de démontrer les crochets de ciment. <br><br><h4>  Test </h4><br>  Pour les tests, vous pouvez utiliser la même classe d'application: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_cement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capsys)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> todo_cement.TodoApp(argv=[<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> app: app.run() out, _ = capsys.readouterr() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> out == EXPECTED <span class="hljs-comment"><span class="hljs-comment">#     jinja,       assert app.last_rendered is None</span></span></code> </pre><br><h4>  Résumé </h4><br>  Avantages: L'ensemble des API est comme un ensemble de couteaux suisses, l'extensibilité via des crochets et des plugins, une interface stable et un développement actif. <br><br>  Inconvénients: à certains endroits, documentation vide;  les petits scripts à base de ciment peuvent sembler un peu compliqués. <br><br><h2>  Cleo </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cleo est</a> loin d'être un framework aussi populaire que les autres listés ici (environ 400 étoiles sur GitHub au total), et pourtant j'ai réussi à le connaître quand j'ai étudié comment la sortie formatée par Poetry. <br><br>  Ainsi, Cleo est l'un des projets de l'auteur de la poésie déjà mentionnée, un outil de gestion des dépendances, des virtualenvs et des builds d'applications.  À propos de la poésie sur un habr déjà écrit plus d'une fois, et à propos de sa partie console - non. <br><br><h4>  Analyseur </h4><br>  Cleo, comme Cement, est construit sur des principes d'objet, c'est-à-dire  les commandes sont définies via la classe Command et sa docstring, les paramètres sont accessibles via la méthode option (), etc.  De plus, la méthode line (), qui est utilisée pour produire du texte, prend en charge les styles (c'est-à-dire les couleurs) et le filtrage de sortie en fonction du nombre de drapeaux verbeux hors de la boîte.  Cleo a également une sortie de table.  Et aussi des barres de progression.  Et pourtant ... En général, voir: <br><br><div class="spoiler">  <b class="spoiler_title">code source</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cleo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Command <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> BaseCommand <span class="hljs-comment"><span class="hljs-comment"># cleo    clikit,          from clikit.api.io import flags as verbosity class Command(BaseCommand): def __init__(self): super().__init__() self.todoapp = None def handle(self): with todolib.TodoApp.fromenv() as app: self.todoapp = app self.do_handle() def do_handle(self): raise NotImplementedError class AddCommand(Command): """ Add new task. add {task : Task to add} """ def do_handle(self): title = self.argument("task") task = self.todoapp.add_task(title) # will be printed only on "-vvv" self.line(f"Title: {title}", style="comment", verbosity=verbosity.DEBUG) self.line(f"Task &lt;info&gt;{task.title}&lt;/&gt; created with number {task.number}.") class ShowCommand(Command): """ Show current tasks. show {--show-done : Include tasks that are done.} """ def do_handle(self): tasks = self.todoapp.list_tasks(self.option("show-done")) if not tasks: self.line("There is no TODOs.", style="info") self.render_table( ["Number", "Title", "Status"], [ [str(task.number), task.title, "" if task.done else "✘"] for task in tasks ], ) class DoneCommand(Command): """ Mark task as done. done {number : Task number} """ def do_handle(self): task = self.todoapp.task_done(int(self.argument("number"))) self.line(f"Task &lt;info&gt;{task.title}&lt;/&gt; marked as done.") class RemoveCommand(Command): """ Removes task from the list. remove {number : Task number} """ def do_handle(self): task = self.todoapp.remove_task(int(self.argument("number"))) self.line(f"Task &lt;info&gt;{task.title}&lt;/&gt; removed from the list.")</span></span></code> </pre><br></div></div><br><h4>  principal </h4><br>  Il <i>suffit</i> de créer un objet <i>cleo.Application</i> , puis de lui passer des commandes pour lui ajouter des commandes.  Afin de ne pas répéter pendant les tests, tout cela a été transféré du principal au constructeur: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cleo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Application <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> BaseApplication <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoApp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseApplication)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> super().__init__(name=<span class="hljs-string"><span class="hljs-string">"ToDo app - cleo version"</span></span>, version=todolib.__version__) self.add_commands(AddCommand(), ShowCommand(), DoneCommand(), RemoveCommand()) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args=None)</span></span></span><span class="hljs-function">:</span></span> TodoApp().run(args=args)</code> </pre><br><h4>  Test </h4><br>  Pour tester les commandes dans Cleo, il y a <i>CommandTester</i> , qui, comme tous les <s>oncles</s> adultes <s>du</s> framework, intercepte les E / S et le code de sortie: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_cleo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> app = todo_cleo.TodoApp() command = app.find(<span class="hljs-string"><span class="hljs-string">"add"</span></span>) tester = cleo.CommandTester(command) tester.execute(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> tester.status_code == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> tester.io.fetch_output() == <span class="hljs-string"><span class="hljs-string">"Task test created with number 0.\n"</span></span></code> </pre><br><h4>  Résumé </h4><br>  Avantages: structure d'objet avec des indications de type, ce qui simplifie le développement (puisque de nombreux IDE et éditeurs ont un bon support pour le code OOP et le module de typage);  Une bonne quantité de fonctionnalités pour travailler non seulement avec des arguments, mais aussi avec des E / S. <br><br>  Plus ou moins: son paramètre de verbosité, qui n'est compatible qu'avec les E / S Cleo / CliKit.  Bien que vous puissiez écrire un gestionnaire personnalisé pour le module de journalisation, il peut être difficile à maintenir avec le développement de cleo. <br><br>  Inconvénients: évidemment - une opinion personnelle - une jeune API: le framework manque d'un autre "grand" utilisateur, sauf pour la poésie, et Cleo se développe en parallèle avec le développement et pour les besoins de l'un;  parfois, la documentation est obsolète (par exemple, les niveaux de journalisation ne se trouvent désormais plus dans le module clikit, mais dans clikit.api.io.flags), et en général, ils sont médiocres et ne reflètent pas l'intégralité de l'API. <br><br>  Cleo, par rapport à Cement, est plus concentré sur la CLI, et il est le seul à avoir pensé à formater (masquer la trace de pile par défaut) des exceptions dans la sortie par défaut.  Mais il - encore une fois une opinion personnelle - perd face à Cement dans sa jeunesse et la stabilité de l'API. <br><br><h2>  En conclusion </h2><br>  À ce stade, tout le monde a déjà sa propre opinion, ce qui est mieux, mais la conclusion devrait être: j'ai le plus aimé Click, car il contient beaucoup de choses et il est assez facile de développer et de tester des applications avec.  Si vous essayez d'écrire du code au minimum - commencez par Fire.  Votre script doit avoir accès à Memcached, au formatage avec jinja et à l'extensibilité - prenez Cement et vous ne le regretterez pas.  Vous avez un projet pour animaux de compagnie ou vous voulez essayer autre chose - regardez cleo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466999/">https://habr.com/ru/post/fr466999/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466983/index.html">Pourquoi personne ne peut battre la course de Tesla</a></li>
<li><a href="../fr466985/index.html">À propos des nouvelles normes C ++</a></li>
<li><a href="../fr466987/index.html">Les «ls» atypiques ou comment les linuxoïdes sont divertis</a></li>
<li><a href="../fr466993/index.html">Configuration du plugin Warnings Next Generation pour l'intégration avec PVS-Studio</a></li>
<li><a href="../fr466995/index.html">Configuration du plug-in Warnings Next Generation pour l'intégration PVS-Studio</a></li>
<li><a href="../fr467003/index.html">Menu rapide, pratique et adaptatif pour 1075 catégories (36000 produits)</a></li>
<li><a href="../fr467005/index.html">Comment colorer correctement les polynômes</a></li>
<li><a href="../fr467007/index.html">FLProg - Intégration indépendante dans le programme des contrôleurs personnalisés</a></li>
<li><a href="../fr467009/index.html">Créer une bibliothèque personnelle avec Notion et Python</a></li>
<li><a href="../fr467011/index.html">Ce qu'il faut lire et voir pour commencer en science des données: livres, dictionnaires et cours</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>