<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï° üëÉ üí• Comparaison des biblioth√®ques CLI populaires pour Python: clic, ciment, feu et autres ü§ü üò± üå™Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Python est un excellent langage pour les applications console, et il met en √©vidence un grand nombre de biblioth√®ques pour ces t√¢ches. Mais quelles bi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comparaison des biblioth√®ques CLI populaires pour Python: clic, ciment, feu et autres</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466999/"><img src="https://habrastorage.org/webt/rp/ek/be/rpekben_u6jtlwru-flsslxk70e.png"><br><br>  Python est un excellent langage pour les applications console, et il met en √©vidence un grand nombre de biblioth√®ques pour ces t√¢ches.  <i>Mais quelles biblioth√®ques existent?</i>  <i>Et quoi de mieux √† prendre?</i>  Ce mat√©riel compare les outils populaires et peu utilis√©s pour le monde des consoles et tente de r√©pondre √† la deuxi√®me question. <br><br>  Pour faciliter la lecture, la revue est divis√©e en deux articles: le premier compare les six biblioth√®ques les plus populaires, le second - moins populaire et plus sp√©cifique, mais m√©rite tout de m√™me l'attention. <br><a name="habracut"></a><br>  Dans chacun des exemples, un utilitaire de console pour la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">todolib</a> sera √©crit en Python 3.7, avec lequel vous pouvez cr√©er, afficher, baliser et supprimer des t√¢ches.  Le reste sera ajout√© sous r√©serve de la simplicit√© de mise en ≈ìuvre sur un cadre particulier.  Les t√¢ches elles-m√™mes sont stock√©es dans un fichier json, qui sera enregistr√© dans un appel distinct - une condition suppl√©mentaire pour les exemples. <br>  En plus de cela, un test trivial sera √©crit pour chaque impl√©mentation.  Pytest avec les appareils suivants a √©t√© utilis√© comme cadre de test: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@pytest.fixture(autouse=True) def db(monkeypatch): """ monkeypatch     ,        """ value = {"tasks": []} monkeypatch.setattr(todolib.TodoApp, "get_db", lambda _: value) return value @pytest.yield_fixture(autouse=True) def check(db): """      """ yield assert db["tasks"] and db["tasks"][0]["title"] == "test" # ,      EXPECTED = "Task 'test' created with number 1.\n"</span></span></code> </pre> <br>  En principe, tout ce qui pr√©c√®de sera suffisant pour d√©montrer les biblioth√®ques.  Le code source complet est disponible dans <a href="">ce</a> r√©f√©rentiel. <br><br><h2>  argparse </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Argparse</a> a un avantage ind√©niable - il est dans la biblioth√®que standard et son API n'est pas difficile √† apprendre: il y a un analyseur, il y a des arguments, les arguments ont <i>type</i> , <i>action</i> , <i>dest</i> , <i>default</i> et <i>help</i> .  Et il y a un sous- <i>analyseur</i> - la possibilit√© de s√©parer une partie des arguments et de la logique en commandes distinctes. <br><br><h4>  Analyseur </h4><br>  √Ä premi√®re vue - rien d'inhabituel, l'analyseur est comme un analyseur.  Mais - √† mon avis - la lisibilit√© n'est pas la meilleure par rapport √† d'autres biblioth√®ques, car  les arguments des diff√©rentes commandes sont d√©crits au m√™me endroit. <br><br><div class="spoiler">  <b class="spoiler_title">code source</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_parser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> parser = argparse.ArgumentParser(<span class="hljs-string"><span class="hljs-string">"Todo notes - argparse version"</span></span>) parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--verbose"</span></span>, <span class="hljs-string"><span class="hljs-string">"-v"</span></span>, action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Enable verbose mode"</span></span> ) parser.add_argument(<span class="hljs-string"><span class="hljs-string">"--version"</span></span>, <span class="hljs-string"><span class="hljs-string">"-V"</span></span>, action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Show version"</span></span>) subparsers = parser.add_subparsers(title=<span class="hljs-string"><span class="hljs-string">"Commands"</span></span>, dest=<span class="hljs-string"><span class="hljs-string">"cmd"</span></span>) add = subparsers.add_parser(<span class="hljs-string"><span class="hljs-string">"add"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Add new task"</span></span>) add.add_argument(<span class="hljs-string"><span class="hljs-string">"title"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Todo title"</span></span>) show = subparsers.add_parser(<span class="hljs-string"><span class="hljs-string">"show"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Show tasks"</span></span>) show.add_argument( <span class="hljs-string"><span class="hljs-string">"--show-done"</span></span>, action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Include done tasks in the output"</span></span> ) done = subparsers.add_parser(<span class="hljs-string"><span class="hljs-string">"done"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Mark task as done"</span></span>) done.add_argument(<span class="hljs-string"><span class="hljs-string">"number"</span></span>, type=int, help=<span class="hljs-string"><span class="hljs-string">"Task number"</span></span>) remove = subparsers.add_parser(<span class="hljs-string"><span class="hljs-string">"remove"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Remove task"</span></span>) remove.add_argument(<span class="hljs-string"><span class="hljs-string">"number"</span></span>, type=int, help=<span class="hljs-string"><span class="hljs-string">"Task number"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser</code> </pre><br></div></div><br><h4>  principal </h4><br>  Et ici, la m√™me chose - l'analyseur, √† l'exception des arguments d'analyse, ne peut rien faire de plus, de sorte que la logique devra √™tre √©crite ind√©pendamment et en un seul endroit.  D'une part - il est possible de vivre, d'autre part - c'est possible mieux, mais on ne sait pas encore comment. <br><br>  <b>UPD:</b> <i>Comme l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">a</a> not√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">foldr</a> , en fait, les sous-analyseurs peuvent d√©finir des fonctions via set_defaults (func = foo), c'est-√†-dire, argparse vous permet de raccourcir le principal en petites tailles.</i>  <i>Vivez et apprenez.</i> <br><br><div class="spoiler">  <b class="spoiler_title">code source</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(raw_args=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Argparse example entrypoint """</span></span> parser = get_parser() args = parser.parse_args(raw_args) logging.basicConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.verbose: logging.getLogger(<span class="hljs-string"><span class="hljs-string">"todolib"</span></span>).setLevel(logging.INFO) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.version: print(lib_version) exit(<span class="hljs-number"><span class="hljs-number">0</span></span>) cmd = args.cmd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> cmd: parser.print_help() exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> TodoApp.fromenv() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> app: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd == <span class="hljs-string"><span class="hljs-string">"add"</span></span>: task = app.add_task(args.title) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> cmd == <span class="hljs-string"><span class="hljs-string">"show"</span></span>: app.print_tasks(args.show_done) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> cmd == <span class="hljs-string"><span class="hljs-string">"done"</span></span>: task = app.task_done(args.number) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> cmd == <span class="hljs-string"><span class="hljs-string">"remove"</span></span>: task = app.remove_task(args.number) print(task, <span class="hljs-string"><span class="hljs-string">"removed from list."</span></span>)</code> </pre><br></div></div><br><h4>  Test </h4><br>  Pour v√©rifier la sortie de l'utilitaire, le luminaire <i>capsys</i> est <i>utilis√©</i> , ce qui donne acc√®s au texte de stdout et stderr. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_argparse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capsys)</span></span></span><span class="hljs-function">:</span></span> todo_argparse.main([<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) out, _ = capsys.readouterr() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> out == EXPECTED</code> </pre><br><h4>  R√©sum√© </h4><br>  Des avantages - un bon ensemble de fonctionnalit√©s pour l'analyse, la pr√©sence d'un module dans la biblioth√®que standard. <br><br>  Contre - argparse ne traite que des arguments d'analyse, la plupart de la logique principale a d√ª √™tre √©crite par moi-m√™me.  Et on ne sait pas comment tester le code de sortie dans les tests. <br><br><h2>  docopt </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docopt</a> est un petit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analyseur</a> (&lt;600 lignes, compar√© √† 2500 avec argparse), qui vous fera sourire, citant une description sur GitHub.  L'id√©e principale de docopt est de d√©crire l'interface litt√©ralement avec du texte, par exemple, dans docstring. <br><br>  Sur le m√™me github, docopt&gt; 6700 √©toiles, il est utilis√© dans au moins 22 mille autres projets.  Et ce n'est qu'avec l'impl√©mentation de python!  La page du projet docopt propose de nombreuses options pour diff√©rents langages, du C et PHP au CoffeeScript et m√™me au R. Une telle multiplateforme ne peut √™tre expliqu√©e que par la compacit√© et la simplicit√© du code. <br><br><h4>  Analyseur </h4><br>  Compar√© √† argparse, cet analyseur est un grand pas en avant. <br><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Todo notes on docopt. Usage: todo_docopt [-v | -vv ] add &lt;task&gt; todo_docopt [-v | -vv ] show --show-done todo_docopt [-v | -vv ] done &lt;number&gt; todo_docopt [-v | -vv ] remove &lt;number&gt; todo_docopt -h | --help todo_docopt --version Options: -h --help Show help. -v --verbose Enable verbose mode. """</span></span></code> </pre><br><h4>  principal </h4><br>  En g√©n√©ral, tout est identique √† argparse, mais maintenant <i>verbeux</i> peut avoir plusieurs valeurs (0-2), et l'acc√®s aux arguments est diff√©rent: docopt ne renvoie pas un espace de noms avec des attributs, mais juste un dictionnaire, o√π le choix d'une commande est indiqu√© √† travers son bool√©en, comme on le voit <i>si</i> : <br><br><div class="spoiler">  <b class="spoiler_title">code source</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(argv=None)</span></span></span><span class="hljs-function">:</span></span> args = docopt(__doc__, argv=argv, version=lib_version) log.setLevel(levels[args[<span class="hljs-string"><span class="hljs-string">"--verbose"</span></span>]]) logging.basicConfig() log.debug(<span class="hljs-string"><span class="hljs-string">"Arguments: %s"</span></span>, args) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> TodoApp.fromenv() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> app: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args[<span class="hljs-string"><span class="hljs-string">"add"</span></span>]: task = app.add_task(args[<span class="hljs-string"><span class="hljs-string">"&lt;task&gt;"</span></span>]) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> args[<span class="hljs-string"><span class="hljs-string">"show"</span></span>]: app.print_tasks(args[<span class="hljs-string"><span class="hljs-string">"--show-done"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> args[<span class="hljs-string"><span class="hljs-string">"done"</span></span>]: task = app.task_done(args[<span class="hljs-string"><span class="hljs-string">"&lt;number&gt;"</span></span>]) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> args[<span class="hljs-string"><span class="hljs-string">"remove"</span></span>]: task = app.remove_task(args[<span class="hljs-string"><span class="hljs-string">"&lt;number&gt;"</span></span>]) print(task, <span class="hljs-string"><span class="hljs-string">"removed from list."</span></span>)</code> </pre><br></div></div><br><h4>  Test </h4><br>  Similaire aux tests argparse: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_docopt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capsys)</span></span></span><span class="hljs-function">:</span></span> todo_docopt.main([<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) out, _ = capsys.readouterr() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> out == EXPECTED</code> </pre><br><h4>  R√©sum√© </h4><br>  Des avantages - beaucoup moins de code pour l'analyseur, facilit√© de description et de lecture des commandes et des arguments, version int√©gr√©e. <br><br>  Inconv√©nients, tout d'abord, la m√™me chose que argparse - beaucoup de logique en <i>principal</i> , vous ne pouvez pas tester le code de sortie.  De plus, la version actuelle (0.6.2) de docopt n'est pas encore stable et ne le sera probablement jamais - le projet se d√©veloppait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">activement</a> de 2012 √† fin 2013, le dernier commit √©tait le 17 d√©cembre.  Et la chose la plus d√©sagr√©able pour le moment est que certains habitu√©s de Docopt provoquent DeprecationWarning lors des tests. <br><br><h2>  Cliquez sur </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Click est</a> fondamentalement diff√©rent de argparse et docopt par le nombre de fonctionnalit√©s et l'approche de description des commandes et des param√®tres par le biais de d√©corateurs, et la logique elle-m√™me est propos√©e pour √™tre s√©par√©e en fonctions distinctes au lieu d'un grand <i>principal</i> .  Les auteurs affirment que Click a beaucoup de param√®tres, mais les param√®tres standard devraient √™tre suffisants.  Parmi les fonctionnalit√©s, les commandes imbriqu√©es et leur chargement paresseux sont mis en √©vidence. <br><br>  Le projet est extr√™mement populaire: en plus d'avoir&gt; 8100 √©toiles et de l'utiliser dans au moins 174 mille (!) Projets, il est toujours en d√©veloppement: la version 7.0 est sortie √† l'automne 2018, et de nouvelles requ√™tes de validation et de fusion apparaissent √† ce jour. jour. <br><br><h4>  Analyseur </h4><br>  Sur la page de documentation, j'ai trouv√© le d√©corateur <i>confirmation_option</i> , qui demande la confirmation de l'utilisateur avant d'ex√©cuter la commande.  Pour le d√©montrer, la commande wipe a √©t√© ajout√©e, ce qui efface toute la liste des t√¢ches. <br><br><div class="spoiler">  <b class="spoiler_title">code source</b> <div class="spoiler_text"><pre> <code class="python hljs">levels = [logging.WARN, logging.INFO, logging.DEBUG] pass_app = click.make_pass_decorator(TodoApp) @click.group() @click.version_option(lib_version, prog_name=<span class="hljs-string"><span class="hljs-string">"todo_click"</span></span>) @click.option(<span class="hljs-string"><span class="hljs-string">"-v"</span></span>, <span class="hljs-string"><span class="hljs-string">"--verbose"</span></span>, count=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-comment"><span class="hljs-comment"># click   ,     @click.option("--db", help="Path to the database file") @click.pass_context def cli(ctx, verbose, db): """Todo notes - click version.""" level = levels[min(verbose, 2)] logging.basicConfig(level=level) logging.getLogger("todolib").setLevel(level) ctx.obj = TodoApp.fromenv(db) atexit.register(ctx.obj.save) @cli.command() @click.argument("task") @pass_app def add(app, task): """ Add new task. """ task = app.add_task(task) click.echo(f"{task} created with number {task.number}.") @cli.command() @click.option("--show-done", is_flag=True, help="Include done tasks") @pass_app def show(app, show_done): """ Show current tasks. """ app.print_tasks(show_done) @cli.command() @click.argument("number", type=int) @pass_app def done(app, number): """ Mark task as done. """ task = app.task_done(number) click.echo(f"{task} marked as done.") @cli.command() @click.argument("number", type=int) @pass_app def remove(app, number): """ Remove task from the list. """ task = app.remove_task(number) click.echo(f"{task} removed from the list.") @cli.command() @click.confirmation_option(prompt="Are you sure you want to remove database") @pass_app def wipe(app): for task in app.list_tasks(): task.remove()</span></span></code> </pre><br></div></div><br><h4>  principal </h4><br>  Et ici, nous rencontrons le principal avantage de Click - du fait que la logique des commandes est espac√©e en fonction de leurs fonctions, presque rien ne reste en principal.  La capacit√© de la biblioth√®que √† recevoir des arguments et des param√®tres de variables d'environnement est √©galement illustr√©e ici. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: cli(auto_envvar_prefix=<span class="hljs-string"><span class="hljs-string">"TODO"</span></span>)</code> </pre><br><h4>  Test </h4><br>  Dans le cas de Click, il n'est pas n√©cessaire d'intercepter sys.stdout, car il existe un module <i>click.testing</i> avec un runner pour de telles choses.  Et non seulement <i>CliRunner</i> lui-m√™me intercepte la sortie, il vous permet √©galement de v√©rifier le code de sortie, ce qui est √©galement cool.  Tout cela permet de tester les utilitaires de clic sans utiliser pytest et sans passer par le module standard <i>unittest</i> . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> click.testing <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> runner = click.testing.CliRunner() result = runner.invoke(todo_click.cli, [<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> result.exit_code == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> result.output == EXPECTED</code> </pre><br><h4>  R√©sum√© </h4><br>  Ce n'est qu'une petite partie de ce que Click peut faire.  Du reste de l'API - validation des valeurs, int√©gration avec le terminal (couleurs, pager a la less, barre de progression, etc.), rappel des r√©sultats, auto-compl√©tion et bien plus encore.  Vous pouvez voir leurs exemples <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Avantages: beaucoup d'outils pour toute occasion, une approche originale, mais en m√™me temps pratique pour d√©crire les √©quipes, la facilit√© des tests et la vie active du projet. <br><br>  Inconv√©nients: Quels sont les inconv√©nients d'un ¬´clic¬ª - c'est une question difficile.  Peut-√™tre qu'il ne sait rien de ce dont les biblioth√®ques suivantes sont capables? <br><br><h2>  Le feu </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fire</a> n'est pas seulement une jeune biblioth√®que (apparue en 2017) pour les interfaces de console de Google, c'est une biblioth√®que pour g√©n√©rer des interfaces de console √† partir, citant textuellement, <i>absolument n'importe quel objet</i> Python. <br>  Entre autres choses, il est indiqu√© que le feu aide au d√©veloppement et au d√©bogage du code, aide √† adapter le code existant dans la CLI, facilite la transition de bash √† Python et poss√®de son propre REPL pour le travail interactif.  Verrons-nous? <br><br><h4>  Analyseur et principal </h4><br>  fire.Fire est vraiment capable d'accepter n'importe quel objet: un module, une instance de classe, un dictionnaire avec des noms de commande et des fonctions correspondantes, etc. <br><br>  Ce qui est important pour nous, c'est que le Feu permet le transfert d'un objet de classe.  Ainsi, le constructeur de classe accepte des arguments communs √† toutes les commandes, et ses m√©thodes et attributs sont des commandes distinctes.  Nous utiliserons ceci: <br><br><div class="spoiler">  <b class="spoiler_title">code source</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Commands</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, db=None, verbose=False)</span></span></span><span class="hljs-function">:</span></span> level = logging.INFO <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> verbose <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> logging.WARNING logging.basicConfig(level=level) logging.getLogger(<span class="hljs-string"><span class="hljs-string">"todolib"</span></span>).setLevel(level) self._app = todolib.TodoApp.fromenv(db) atexit.register(self._app.save) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">version</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> todolib.__version__ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, task)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Add new task."""</span></span> task = self._app.add_task(task) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, show_done=False)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Show current tasks. """</span></span> self._app.print_tasks(show_done) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Mark task as done. """</span></span> task = self._app.task_done(number) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Removes task from the list. """</span></span> task = self._app.remove_task(number) print(task, <span class="hljs-string"><span class="hljs-string">"removed from the list."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args=None)</span></span></span><span class="hljs-function">:</span></span> fire.Fire(Commands, command=args)</code> </pre><br></div></div><br><h4>  Drapeaux en ligne </h4><br>  Fire a ses propres drapeaux avec une syntaxe sp√©ciale (ils doivent √™tre pass√©s apr√®s le "-"), qui vous permettent de regarder sous le capot de l'analyseur et de l'application dans son ensemble: <br><br><div class="spoiler">  <b class="spoiler_title">exemples d'appel</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ./todo_fire.py show -- --trace Fire trace: 1. Initial component 2. Instantiated class <span class="hljs-string"><span class="hljs-string">"Commands"</span></span> (todo_fire.py:9) 3. Accessed property <span class="hljs-string"><span class="hljs-string">"show"</span></span> (todo_fire.py:25) $ ./todo_fire.py -- --verbose | head -n 12 <span class="hljs-comment"><span class="hljs-comment">#    , ,  Commands._app NAME todo_fire.py - SYNOPSIS todo_fire.py - GROUP | COMMAND GROUPS GROUP is one of the following: _app Todo Application definition. $ ./todo_fire.py show -- --interactive Fire is starting a Python REPL with the following objects: Modules: atexit, fire, logging, todolib Objects: Commands, args, component, main, result, self, todo_fire.py, trace Python 3.7.4 (default, Aug 15 2019, 13:09:37) [GCC 7.4.0] on linux Type "help", "copyright", "credits" or "license" for more information. (InteractiveConsole) &gt;&gt;&gt; self &lt;__main__.Commands object at 0x7fd0a6125bd0&gt; &gt;&gt;&gt; self._app.db {'tasks': [{'title': 'test', 'done': False}]}</span></span></code> </pre><br></div></div><br><h4>  Test </h4><br>  Tester la fonction principale est similaire √† tester argparse et docopt, donc je ne vois pas le point ici. <br><br>  Dans le m√™me temps, il convient de noter qu'en raison de la nature introspective de Fire, il est √©galement possible de tester imm√©diatement la classe Commands. <br><br><h4>  R√©sum√© </h4><br>  Le feu est un outil non moins int√©ressant que le clic.  Il ne n√©cessite pas de r√©pertorier de nombreuses options dans l'analyseur, la configuration est minimale, il existe des options de d√©bogage et la biblioth√®que elle-m√™me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vit et se d√©veloppe</a> encore plus activement que le clic (60 commits cet √©t√©). <br><br>  Inconv√©nients: peut consid√©rablement moins que le clic et les autres analyseurs;  API instable (la version actuelle est 0.2.1). <br><br><h2>  Le ciment </h2><br>  En fait, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cement n'est</a> pas exactement une biblioth√®que CLI, mais un cadre pour les applications de console, mais on pr√©tend qu'il convient aux scripts et aux applications complexes avec diverses int√©grations. <br><br><h4>  Analyseur </h4><br>  L'analyseur dans Cement semble inhabituel, mais si vous regardez attentivement les param√®tres, il est facile de deviner que l'argparse famili√®re est sous le capot.  Mais c'est peut-√™tre pour le mieux - pas besoin d'apprendre de nouveaux param√®tres. <br><br><div class="spoiler">  <b class="spoiler_title">code source</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cement <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Controller, ex <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Controller)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> label = <span class="hljs-string"><span class="hljs-string">"base"</span></span> arguments = [ ( [<span class="hljs-string"><span class="hljs-string">"-v"</span></span>, <span class="hljs-string"><span class="hljs-string">"--version"</span></span>], {<span class="hljs-string"><span class="hljs-string">"action"</span></span>: <span class="hljs-string"><span class="hljs-string">"version"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">f"todo_cement v</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{todolib.__version__}</span></span></span><span class="hljs-string">"</span></span>}, ) ] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_default</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Default action if no sub-command is passed."""</span></span> self.app.args.print_help() @ex(help=<span class="hljs-string"><span class="hljs-string">"Add new task"</span></span>, arguments=[([<span class="hljs-string"><span class="hljs-string">"task"</span></span>], {<span class="hljs-string"><span class="hljs-string">"help"</span></span>: <span class="hljs-string"><span class="hljs-string">"Task title"</span></span>})]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> title = self.app.pargs.task self.app.log.debug(<span class="hljs-string"><span class="hljs-string">f"Task title: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{title!r}</span></span></span><span class="hljs-string">"</span></span>) task = self.app.todoobj.add_task(title) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) @ex( help=<span class="hljs-string"><span class="hljs-string">"Show current tasks"</span></span>, arguments=[ ([<span class="hljs-string"><span class="hljs-string">"--show-done"</span></span>], dict(action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Include done tasks"</span></span>)) ], ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.app.todoobj.print_tasks(self.app.pargs.show_done) @ex(help=<span class="hljs-string"><span class="hljs-string">"Mark task as done"</span></span>, arguments=[([<span class="hljs-string"><span class="hljs-string">"number"</span></span>], {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: int})]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> task = self.app.todoobj.task_done(self.app.pargs.number) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) @ex(help=<span class="hljs-string"><span class="hljs-string">"Remove task from the list"</span></span>, arguments=[([<span class="hljs-string"><span class="hljs-string">"number"</span></span>], {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: int})]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> task = self.app.todoobj.remove_task(self.app.pargs.number) print(task, <span class="hljs-string"><span class="hljs-string">"removed from the list."</span></span>)</code> </pre><br></div></div><br><h4>  App et principal </h4><br>  Le ciment, entre autres, encapsule toujours les signaux dans les exceptions.  Ceci est d√©montr√© ici √† la sortie de code z√©ro avec SIGINT / SIGTERM. <br><br><div class="spoiler">  <b class="spoiler_title">code source</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoApp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(App)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, argv=None)</span></span></span><span class="hljs-function">:</span></span> super().__init__(argv=argv) self.todoobj = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_db</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.todoobj = todolib.TodoApp.fromenv() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.todoobj.save() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Meta</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># application label label = "todo_cement" # register handlers handlers = [Base] hooks = [("post_setup", lambda app: app.load_db()), ("pre_close", lambda app: app.save())] # call sys.exit() on close close_on_exit = True def main(): with TodoApp() as app: try: app.run() except CaughtSignal as e: if e.signum not in (signal.SIGINT, signal.SIGTERM): raise app.log.debug(f"\n{e}") app.exit_code = 0</span></span></code> </pre><br></div></div><br>  Si vous ma√Ætrisez main, vous pouvez voir que le chargement et l'enregistrement de todolib.TodoApp peuvent √©galement √™tre effectu√©s dans le __enter __ / __ exit__ substitu√©, mais ces phases ont finalement √©t√© s√©par√©es en m√©thodes distinctes afin de d√©montrer les crochets de ciment. <br><br><h4>  Test </h4><br>  Pour les tests, vous pouvez utiliser la m√™me classe d'application: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_cement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capsys)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> todo_cement.TodoApp(argv=[<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> app: app.run() out, _ = capsys.readouterr() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> out == EXPECTED <span class="hljs-comment"><span class="hljs-comment">#     jinja,       assert app.last_rendered is None</span></span></code> </pre><br><h4>  R√©sum√© </h4><br>  Avantages: L'ensemble des API est comme un ensemble de couteaux suisses, l'extensibilit√© via des crochets et des plugins, une interface stable et un d√©veloppement actif. <br><br>  Inconv√©nients: √† certains endroits, documentation vide;  les petits scripts √† base de ciment peuvent sembler un peu compliqu√©s. <br><br><h2>  Cleo </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cleo est</a> loin d'√™tre un framework aussi populaire que les autres list√©s ici (environ 400 √©toiles sur GitHub au total), et pourtant j'ai r√©ussi √† le conna√Ætre quand j'ai √©tudi√© comment la sortie format√©e par Poetry. <br><br>  Ainsi, Cleo est l'un des projets de l'auteur de la po√©sie d√©j√† mentionn√©e, un outil de gestion des d√©pendances, des virtualenvs et des builds d'applications.  √Ä propos de la po√©sie sur un habr d√©j√† √©crit plus d'une fois, et √† propos de sa partie console - non. <br><br><h4>  Analyseur </h4><br>  Cleo, comme Cement, est construit sur des principes d'objet, c'est-√†-dire  les commandes sont d√©finies via la classe Command et sa docstring, les param√®tres sont accessibles via la m√©thode option (), etc.  De plus, la m√©thode line (), qui est utilis√©e pour produire du texte, prend en charge les styles (c'est-√†-dire les couleurs) et le filtrage de sortie en fonction du nombre de drapeaux verbeux hors de la bo√Æte.  Cleo a √©galement une sortie de table.  Et aussi des barres de progression.  Et pourtant ... En g√©n√©ral, voir: <br><br><div class="spoiler">  <b class="spoiler_title">code source</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cleo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Command <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> BaseCommand <span class="hljs-comment"><span class="hljs-comment"># cleo    clikit,          from clikit.api.io import flags as verbosity class Command(BaseCommand): def __init__(self): super().__init__() self.todoapp = None def handle(self): with todolib.TodoApp.fromenv() as app: self.todoapp = app self.do_handle() def do_handle(self): raise NotImplementedError class AddCommand(Command): """ Add new task. add {task : Task to add} """ def do_handle(self): title = self.argument("task") task = self.todoapp.add_task(title) # will be printed only on "-vvv" self.line(f"Title: {title}", style="comment", verbosity=verbosity.DEBUG) self.line(f"Task &lt;info&gt;{task.title}&lt;/&gt; created with number {task.number}.") class ShowCommand(Command): """ Show current tasks. show {--show-done : Include tasks that are done.} """ def do_handle(self): tasks = self.todoapp.list_tasks(self.option("show-done")) if not tasks: self.line("There is no TODOs.", style="info") self.render_table( ["Number", "Title", "Status"], [ [str(task.number), task.title, "" if task.done else "‚úò"] for task in tasks ], ) class DoneCommand(Command): """ Mark task as done. done {number : Task number} """ def do_handle(self): task = self.todoapp.task_done(int(self.argument("number"))) self.line(f"Task &lt;info&gt;{task.title}&lt;/&gt; marked as done.") class RemoveCommand(Command): """ Removes task from the list. remove {number : Task number} """ def do_handle(self): task = self.todoapp.remove_task(int(self.argument("number"))) self.line(f"Task &lt;info&gt;{task.title}&lt;/&gt; removed from the list.")</span></span></code> </pre><br></div></div><br><h4>  principal </h4><br>  Il <i>suffit</i> de cr√©er un objet <i>cleo.Application</i> , puis de lui passer des commandes pour lui ajouter des commandes.  Afin de ne pas r√©p√©ter pendant les tests, tout cela a √©t√© transf√©r√© du principal au constructeur: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cleo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Application <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> BaseApplication <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoApp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseApplication)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> super().__init__(name=<span class="hljs-string"><span class="hljs-string">"ToDo app - cleo version"</span></span>, version=todolib.__version__) self.add_commands(AddCommand(), ShowCommand(), DoneCommand(), RemoveCommand()) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args=None)</span></span></span><span class="hljs-function">:</span></span> TodoApp().run(args=args)</code> </pre><br><h4>  Test </h4><br>  Pour tester les commandes dans Cleo, il y a <i>CommandTester</i> , qui, comme tous les <s>oncles</s> adultes <s>du</s> framework, intercepte les E / S et le code de sortie: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_cleo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> app = todo_cleo.TodoApp() command = app.find(<span class="hljs-string"><span class="hljs-string">"add"</span></span>) tester = cleo.CommandTester(command) tester.execute(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> tester.status_code == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> tester.io.fetch_output() == <span class="hljs-string"><span class="hljs-string">"Task test created with number 0.\n"</span></span></code> </pre><br><h4>  R√©sum√© </h4><br>  Avantages: structure d'objet avec des indications de type, ce qui simplifie le d√©veloppement (puisque de nombreux IDE et √©diteurs ont un bon support pour le code OOP et le module de typage);  Une bonne quantit√© de fonctionnalit√©s pour travailler non seulement avec des arguments, mais aussi avec des E / S. <br><br>  Plus ou moins: son param√®tre de verbosit√©, qui n'est compatible qu'avec les E / S Cleo / CliKit.  Bien que vous puissiez √©crire un gestionnaire personnalis√© pour le module de journalisation, il peut √™tre difficile √† maintenir avec le d√©veloppement de cleo. <br><br>  Inconv√©nients: √©videmment - une opinion personnelle - une jeune API: le framework manque d'un autre "grand" utilisateur, sauf pour la po√©sie, et Cleo se d√©veloppe en parall√®le avec le d√©veloppement et pour les besoins de l'un;  parfois, la documentation est obsol√®te (par exemple, les niveaux de journalisation ne se trouvent d√©sormais plus dans le module clikit, mais dans clikit.api.io.flags), et en g√©n√©ral, ils sont m√©diocres et ne refl√®tent pas l'int√©gralit√© de l'API. <br><br>  Cleo, par rapport √† Cement, est plus concentr√© sur la CLI, et il est le seul √† avoir pens√© √† formater (masquer la trace de pile par d√©faut) des exceptions dans la sortie par d√©faut.  Mais il - encore une fois une opinion personnelle - perd face √† Cement dans sa jeunesse et la stabilit√© de l'API. <br><br><h2>  En conclusion </h2><br>  √Ä ce stade, tout le monde a d√©j√† sa propre opinion, ce qui est mieux, mais la conclusion devrait √™tre: j'ai le plus aim√© Click, car il contient beaucoup de choses et il est assez facile de d√©velopper et de tester des applications avec.  Si vous essayez d'√©crire du code au minimum - commencez par Fire.  Votre script doit avoir acc√®s √† Memcached, au formatage avec jinja et √† l'extensibilit√© - prenez Cement et vous ne le regretterez pas.  Vous avez un projet pour animaux de compagnie ou vous voulez essayer autre chose - regardez cleo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466999/">https://habr.com/ru/post/fr466999/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466983/index.html">Pourquoi personne ne peut battre la course de Tesla</a></li>
<li><a href="../fr466985/index.html">√Ä propos des nouvelles normes C ++</a></li>
<li><a href="../fr466987/index.html">Les ¬´ls¬ª atypiques ou comment les linuxo√Ødes sont divertis</a></li>
<li><a href="../fr466993/index.html">Configuration du plugin Warnings Next Generation pour l'int√©gration avec PVS-Studio</a></li>
<li><a href="../fr466995/index.html">Configuration du plug-in Warnings Next Generation pour l'int√©gration PVS-Studio</a></li>
<li><a href="../fr467003/index.html">Menu rapide, pratique et adaptatif pour 1075 cat√©gories (36000 produits)</a></li>
<li><a href="../fr467005/index.html">Comment colorer correctement les polyn√¥mes</a></li>
<li><a href="../fr467007/index.html">FLProg - Int√©gration ind√©pendante dans le programme des contr√¥leurs personnalis√©s</a></li>
<li><a href="../fr467009/index.html">Cr√©er une biblioth√®que personnelle avec Notion et Python</a></li>
<li><a href="../fr467011/index.html">Ce qu'il faut lire et voir pour commencer en science des donn√©es: livres, dictionnaires et cours</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>