<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß° ‚õÖÔ∏è üöÉ Types de compilation dans la JVM: exposer la session Black Magic ü•Ç üñïüèæ ü§ô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! 

 Aujourd'hui, votre attention est invit√©e √† une traduction de l'article, qui montre des exemples d'options de compilation dans la JV...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Types de compilation dans la JVM: exposer la session Black Magic</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/466529/">  Bonjour √† tous! <br><br>  Aujourd'hui, votre attention est invit√©e √† une traduction de l'article, qui montre des exemples d'options de compilation dans la JVM.  Une attention particuli√®re est accord√©e √† la compilation AOT prise en charge dans Java 9 et sup√©rieur. <br><br>  Bonne lecture! <br><a name="habracut"></a><br>  Je crois que quiconque a d√©j√† programm√© en Java a entendu parler de compilation instantan√©e (JIT), et peut-√™tre de compilation avant ex√©cution (AOT).  De plus, il n'est pas n√©cessaire d'expliquer ce que sont les langues ¬´interpr√©t√©es¬ª.  Cet article explique comment toutes ces fonctionnalit√©s sont impl√©ment√©es dans la machine virtuelle Java, JVM. <br><br>  Vous savez probablement que lors de la programmation en Java, vous devez ex√©cuter un compilateur (en utilisant le programme ¬´javac¬ª) qui recueille le code source Java (fichiers .java) dans le code binaire Java (fichiers .class).  Le bytecode Java est un langage interm√©diaire.  Elle est dite "interm√©diaire" car elle n'est pas comprise par un v√©ritable dispositif informatique (CPU) et ne peut pas √™tre ex√©cut√©e par un ordinateur et repr√©sente ainsi une forme transitoire entre le code source et le code machine "natif" ex√©cut√© dans le processeur. <br><br>  Pour que le bytecode Java effectue un travail sp√©cifique, il y a 3 fa√ßons de le faire: <br><br><ol><li>  Ex√©cutez directement le code interm√©diaire.  Il vaut mieux et plus juste de dire qu'il faut "l'interpr√©ter".  La JVM dispose d'un interpr√©teur Java.  Comme vous le savez, pour que la JVM fonctionne, vous devez ex√©cuter le programme ¬´java¬ª. </li><li>  Juste avant d'ex√©cuter le code interm√©diaire, compilez-le en code natif et forcez le CPU √† ex√©cuter ce code natif fra√Æchement pr√©par√©.  Ainsi, la compilation a lieu juste avant l'ex√©cution (Just in Time) et est appel√©e ¬´dynamique¬ª. </li><li>  3La toute premi√®re chose, avant m√™me le lancement du programme, le code interm√©diaire est traduit en natif et ex√©cut√© √† travers le CPU du d√©but √† la fin.  Cette compilation se fait avant l'ex√©cution et s'appelle AoT (Ahead of Time). </li></ol><br>  Ainsi, (1) est le travail de l'interpr√©teur, (2) est le r√©sultat de la compilation JIT et (3) est le r√©sultat de la compilation AOT. <br><br>  Par souci d'exhaustivit√©, je mentionnerai qu'il existe une quatri√®me approche - pour interpr√©ter directement le code source, mais en Java, cela n'est pas accept√©.  Cela se fait, par exemple, en Python. <br>  Voyons maintenant comment "java" fonctionne comme (1) l'interpr√©teur de (2) le compilateur JIT et / ou (3) le compilateur AOT - et quand. <br><br>  En bref - en r√®gle g√©n√©rale, "java" fait √† la fois (1) et (2).  √Ä partir de Java 9, une troisi√®me option est √©galement possible. <br><br>  Voici notre classe <code>Test</code> , qui sera utilis√©e dans de futurs exemples. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { System.out.println(<span class="hljs-string"><span class="hljs-string">"call "</span></span> + Integer.valueOf(i)); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a = System.nanoTime(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test().f(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b = System.nanoTime(); System.out.println(<span class="hljs-string"><span class="hljs-string">"elapsed= "</span></span> + (ba)); } } }</code> </pre> <br>  Comme vous pouvez le voir, il existe une m√©thode <code>main</code> qui instancie l'objet <code>Test</code> et appelle cycliquement la fonction <code>f</code> 10 fois de suite.  La fonction <code>f</code> ne fait presque rien. <br><br>  Donc, si vous compilez et ex√©cutez le code ci-dessus, la sortie sera tout √† fait attendue (bien s√ªr, les valeurs du temps √©coul√© seront diff√©rentes pour vous): <br><br><pre> <code class="plaintext hljs">call 1 elapsed= 5373 call 2 elapsed= 913 call 3 elapsed= 654 call 4 elapsed= 623 call 5 elapsed= 680 call 6 elapsed= 710 call 7 elapsed= 728 call 8 elapsed= 699 call 9 elapsed= 853 call 10 elapsed= 645</code> </pre> <br>  Et maintenant, la question est: cette conclusion est-elle le r√©sultat du travail de "java" en tant qu'interpr√®te, c'est-√†-dire l'option (1), "java" en tant que compilateur JIT, c'est-√†-dire l'option (2) ou est-elle en quelque sorte li√©e √† la compilation AOT , c'est-√†-dire l'option (3)?  Dans cet article, je vais trouver les bonnes r√©ponses √† toutes ces questions. <br><br>  La premi√®re r√©ponse que je veux donner est tr√®s probablement que seul (1) a lieu ici.  Je dis "tr√®s probablement", car je ne sais pas si une variable d'environnement est d√©finie ici qui modifierait les options JVM par d√©faut.  Si rien de superflu n'est install√©, et c'est ainsi que ¬´java¬ª fonctionne par d√©faut, alors nous observons √† 100% seulement l'option (1), c'est-√†-dire que le code est enti√®rement interpr√©t√©.  J'en suis s√ªr, car: <br><br><ul><li>  Selon la documentation java, l'option <code>-XX:CompileThreshold=invocations</code> s'ex√©cute avec les <code>invocations=1500</code> par d√©faut <code>invocations=1500</code> sur la machine <code>-XX:CompileThreshold=invocations</code> client (plus d'informations sur la machine <code>-XX:CompileThreshold=invocations</code> cliente sont d√©crites ci-dessous).  Comme je ne l'ex√©cute que 10 fois et 10 &lt;1500, nous ne parlons pas ici de compilation dynamique.  En r√®gle g√©n√©rale, cette option de ligne de commande sp√©cifie combien de fois (au maximum) la fonction doit √™tre interpr√©t√©e avant le d√©but de l'√©tape de compilation dynamique.  Je m'attarderai sur cela ci-dessous. </li><li>  En fait, j'ai ex√©cut√© ce code avec des indicateurs de diagnostic, donc je sais s'il a √©t√© compil√© dynamiquement.  J'expliquerai √©galement ce point ci-dessous. </li></ul><br>  Remarque: la JVM peut fonctionner en mode client ou serveur, et les options d√©finies par d√©faut dans les premier et deuxi√®me cas seront diff√©rentes.  En r√®gle g√©n√©rale, la d√©cision concernant le mode de d√©marrage est prise automatiquement, en fonction de l'environnement ou de l'ordinateur sur lequel la JVM a √©t√© lanc√©e.  Ci-apr√®s, je sp√©cifierai l'option <code>‚Äìclient</code> lors de tous les d√©marrages, afin de ne pas douter que le programme s'ex√©cute en mode client.  Cette option n'affectera pas les aspects que je veux d√©montrer dans ce post. <br><br>  Si vous ex√©cutez ¬´java¬ª avec l' <code>-XX:PrintCompilation</code> , le programme imprime une ligne lorsque la fonction est compil√©e dynamiquement.  N'oubliez pas que la compilation JIT est effectu√©e pour chaque fonction s√©par√©ment, certaines fonctions de la classe peuvent rester en bytecode (c'est-√†-dire non compil√©es), tandis que d'autres peuvent d√©j√† avoir pass√© la compilation JIT, c'est-√†-dire, pr√™tes √† √™tre ex√©cut√©es directement dans le processeur . <br><br>  Ci-dessous, j'ajoute √©galement l'option <code>-Xbatch</code> .  L'option <code>-Xbatch</code> n√©cessaire que pour rendre la sortie plus pr√©sentable;  sinon, la compilation JIT se d√©roule de mani√®re comp√©titive (avec l'interpr√©tation), et la sortie apr√®s la compilation peut parfois sembler √©trange au moment de l'ex√©cution (en raison de <code>-XX:PrintCompilation</code> ).  Cependant, l'option <code>‚ÄìXbatch</code> d√©sactive la compilation en arri√®re-plan, par cons√©quent, avant d'ex√©cuter la compilation JIT, l'ex√©cution de notre programme sera arr√™t√©e. <br><br>  (Par souci de lisibilit√©, j'√©crirai chaque option √† partir d'une nouvelle ligne) <br><br><pre> <code class="plaintext hljs">$ java -client -Xbatch -XX:+PrintCompilation Test</code> </pre> <br>  Je n'ins√©rerai pas la sortie de cette commande ici, car par d√©faut, la JVM compile beaucoup de fonctions internes (concernant, par exemple, les packages java, sun, jdk), donc la sortie sera tr√®s longue - donc, sur mon √©cran, il y a 274 lignes sur les fonctions internes , et quelques autres - jusqu'√† la fin du programme).  Pour faciliter cette recherche, je vais annuler la compilation JIT pour les classes internes ou l'activer s√©lectivement uniquement pour ma m√©thode ( <code>Test.f</code> ).  Pour ce faire, sp√©cifiez une autre option, <code>-XX:CompileCommand</code> .  Vous pouvez sp√©cifier de nombreuses commandes (compilation), il serait donc plus facile de les placer dans un fichier s√©par√©.  Heureusement, nous avons l'option <code>-XX:CompileCommandFile</code> .  Passez donc √† la cr√©ation du fichier.  Je l'appellerai <code>hotspot_compiler</code> pour une raison que je vais expliquer bri√®vement et √©crire ce qui suit: <br><br><pre> <code class="plaintext hljs">quiet exclude java/* * exclude jdk/* * exclude sun/* *</code> </pre> <br>  Dans ce cas, il devrait √™tre tout √† fait clair que nous excluons toutes les fonctions (la derni√®re *) de toutes les classes de tous les packages commen√ßant par java, jdk et sun (les noms des packages sont s√©par√©s par / et vous pouvez utiliser *).  La commande <code>quiet</code> indique √† la JVM de ne rien √©crire sur les classes exclues, donc seules celles qui sont maintenant compil√©es seront sorties sur la console.  Alors je lance: <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler Test</code> </pre> <br>  Avant de vous parler de la sortie de cette commande, je vous rappelle que j'ai nomm√© ce fichier <code>hotspot_compiler</code> , car il semble (je n'ai pas v√©rifi√©) que dans Oracle JDK le nom <code>.hotspot_compiler</code> est d√©fini par d√©faut pour le fichier avec les commandes du compilateur. <br><br>  La conclusion est donc: <br><br><pre> <code class="plaintext hljs">many lines like this 111 1 n 0 java.lang.invoke.MethodHandle::linkToStatic(LLLLLL)L (native) (static) call 1 some more lines like this 161 48 n 0 java.lang.invoke.MethodHandle::linkToStatic(ILIJL)I (native) (static) elapsed= 7558 call 2 elapsed= 1532 call 3 elapsed= 920 call 4 elapsed= 732 call 5 elapsed= 774 call 6 elapsed= 815 call 7 elapsed= 767 call 8 elapsed= 765 call 9 elapsed= 757 call 10 elapsed= 868</code> </pre> <br>  Tout d'abord, je ne sais pas pourquoi certaines m√©thodes <code>java.lang.invoke.MethodHandler.</code> sont toujours en cours de compilation <code>java.lang.invoke.MethodHandler.</code>  Probablement, certaines choses ne peuvent tout simplement pas √™tre d√©sactiv√©es.  Si je comprends bien le probl√®me, je mettrai √† jour ce message.  Cependant, comme vous pouvez le voir, toutes les autres √©tapes de compilation (il y avait auparavant 274 lignes) ont maintenant disparu.  Dans d'autres exemples, je supprimerai √©galement <code>java.lang.invoke.MethodHandler</code> de la sortie du journal de compilation. <br><br>  Voyons voir o√π nous en sommes.  Maintenant, nous avons un code simple o√π nous ex√©cutons notre fonction 10 fois.  J'ai mentionn√© plus t√¥t que cette fonction est interpr√©t√©e, non compil√©e, comme cela est indiqu√© dans la documentation, et maintenant nous la voyons dans les journaux (en m√™me temps, nous ne la voyons pas dans les journaux de compilation, ce qui signifie qu'elle n'est pas soumise √† la compilation JIT).  Eh bien, vous venez de voir l'outil ¬´java¬ª en action, interpr√©tant et n'interpr√©tant notre fonction que dans 100% des cas.  Donc, nous pouvons cocher la case qui a figur√© avec l'option (1).  On passe √† (2), compilation dynamique. <br><br>  Selon la documentation, vous pouvez ex√©cuter la fonction 1 500 fois et vous assurer que la compilation JIT se d√©roule r√©ellement.  Cependant, vous pouvez √©galement utiliser l' <code>-XX:CompileThreshold=invocations</code> appel <code>-XX:CompileThreshold=invocations</code> , d√©finissant la valeur souhait√©e au lieu de 1500.  Pointons ici 5. Cela signifie que nous nous attendons √† ce qui suit: apr√®s 5 ¬´interpr√©tations¬ª de notre fonction f, la JVM doit compiler la m√©thode, puis ex√©cuter la version compil√©e. <br>  java -client -Xbatch <br><br><pre> <code class="plaintext hljs">-XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 Test</code> </pre> <br>  Si vous avez ex√©cut√© cette commande, vous avez peut-√™tre remarqu√© que rien n'a chang√© par rapport √† l'exemple ci-dessus.  Autrement dit, la compilation ne se produit toujours pas.  Il s'av√®re que, selon la documentation, <code>-XX:CompileThreshold</code> ne fonctionne que lorsque <code>TieredCompilation</code> d√©sactiv√©, ce qui est la valeur par d√©faut.  Il <code>-XX:-TieredCompilation</code> comme ceci: <code>-XX:-TieredCompilation</code> .  La compilation √† plusieurs niveaux est une fonctionnalit√© introduite dans Java 7 pour am√©liorer √† la fois le lancement et la vitesse de croisi√®re de la JVM.  Dans le contexte de ce post, ce n'est pas important, alors n'h√©sitez pas √† le d√©sactiver.  Ex√©cutons √† nouveau cette commande: <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation Test</code> </pre> <br>  Voici la sortie (je me souviens, j'ai rat√© les lignes concernant <code>java.lang.invoke.MethodHandle</code> ): <br><br><pre> <code class="plaintext hljs">call 1 elapsed= 9411 call 2 elapsed= 1291 call 3 elapsed= 862 call 4 elapsed= 1023 call 5 227 56 b Test::&lt;init&gt; (5 bytes) 228 57 b Test::f (4 bytes) elapsed= 1051739 call 6 elapsed= 18516 call 7 elapsed= 940 call 8 elapsed= 769 call 9 elapsed= 855 call 10 elapsed= 838</code> </pre> <br>  Nous accueillons (bonjour!) La fonction compil√©e dynamiquement Test.f ou <code>Test::&lt;init&gt;</code> imm√©diatement apr√®s avoir appel√© le num√©ro 5, car j'ai d√©fini CompileThreshold sur 5. La JVM interpr√®te la fonction 5 fois, puis la compile et ex√©cute enfin la version compil√©e.  √âtant donn√© que la fonction est compil√©e, elle devrait s'ex√©cuter plus rapidement, mais nous ne pouvons pas le v√©rifier ici, car cette fonction ne fait rien.  Je pense que c'est un bon sujet pour un article s√©par√©. <br><br>  Comme vous l'avez probablement d√©j√† devin√©, une autre fonction est compil√©e ici, √† savoir <code>Test::&lt;init&gt;</code> , qui est un constructeur de la classe <code>Test</code> .  Puisque le code appelle le constructeur (nouveau <code>Test()</code> ), chaque fois que <code>f</code> appel√©, il compile simultan√©ment avec la fonction <code>f</code> , exactement apr√®s 5 appels. <br><br>  En principe, cela peut mettre fin √† la discussion de l'option (2), la compilation JIT.  Comme vous pouvez le voir, dans ce cas, la fonction est d'abord interpr√©t√©e par la JVM, puis compil√©e dynamiquement apr√®s une interpr√©tation quintuple.  Je voudrais ajouter le dernier d√©tail concernant la compilation JIT, √† savoir mentionner l'option <code>-XX:+PrintAssembly</code> .  Comme son nom l'indique, il fournit √† la console une version compil√©e de la fonction (version compil√©e = code machine natif = code assembleur).  Cependant, cela ne fonctionnera que s'il y a un d√©sassembleur dans le chemin de la biblioth√®que.  Je suppose que le d√©sassembleur peut diff√©rer dans diff√©rentes machines virtuelles Java, mais dans ce cas, nous avons affaire √† hsdis - un d√©sassembleur pour openjdk.  Le code source de la biblioth√®que hsdis ou son fichier binaire peut √™tre pris √† diff√©rents endroits.  Dans ce cas, j'ai compil√© ce fichier et mis <code>hsdis-amd64.so</code> dans <code>JAVA_HOME/lib/server</code> . <br><br>  Alors maintenant, nous pouvons ex√©cuter cette commande.  Mais je dois d'abord ajouter cela pour ex√©cuter <code>-XX:+PrintAssembly</code> devez √©galement ajouter l' <code>-XX:+UnlockDiagnosticVMOptions</code> , et elle doit suivre avant l'option <code>PrintAssembly</code> .  Si cela n'est pas fait, la JVM vous <code>PrintAssembly</code> une utilisation incorrecte de l'option <code>PrintAssembly</code> .  Ex√©cutons ce code: <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly Test</code> </pre> <br>  La sortie sera longue et il y aura des lignes comme: <br><br><pre> <code class="plaintext hljs">0x00007f4b7cab1120: mov 0x8(%rsi),%r10d 0x00007f4b7cab1124: shl $0x3,%r10 0x00007f4b7cab1128: cmp %r10,%rax</code> </pre> <br>  Comme vous pouvez le voir, les fonctions correspondantes sont compil√©es en code machine natif. <br><br>  Enfin, discutez de l'option 3, AOT.  La compilation avant ex√©cution, AOT, n'√©tait pas disponible en Java avant la version 9. <br><br>  Un nouvel outil est apparu dans JDK 9, jaotc - comme son nom l'indique, il s'agit d'un compilateur AOT pour Java.  L'id√©e est la suivante: ex√©cutez le compilateur Java "javac", puis le compilateur AOT pour Java "jaotc", puis ex√©cutez la JVM "java" comme d'habitude.  La JVM effectue normalement l'interpr√©tation et la compilation JIT.  Cependant, si la fonction a du code compil√© AOT, elle l'utilise directement et n'a pas recours √† l'interpr√©tation ou √† la compilation JIT.  Laissez-moi vous expliquer: vous n'avez pas besoin d'ex√©cuter le compilateur AOT, il est facultatif, et si vous l'utilisez, vous ne pouvez compiler que les classes que vous souhaitez avant de l'ex√©cuter. <br><br>  Construisons une biblioth√®que compos√©e d'une version compil√©e AOT de <code>Test::f</code> .  N'oubliez pas: pour le faire vous-m√™me, vous aurez besoin de JDK 9 dans la version 150+. <br><br><pre> <code class="plaintext hljs">jaotc --output=libTest.so Test.class</code> </pre> <br>  En cons√©quence, <code>libTest.so</code> g√©n√©r√©, une biblioth√®que contenant le code natif de fonctions compil√© par AOT inclus dans la classe <code>Test</code> .  Vous pouvez visualiser les caract√®res d√©finis dans cette biblioth√®que: <br><br><pre> <code class="plaintext hljs">nm libTest.so</code> </pre> <br>  Dans notre conclusion, entre autres, il y aura: <br><br><pre> <code class="plaintext hljs">0000000000002120 t Test.f()I 00000000000021a0 t Test.&lt;init&gt;()V 00000000000020a0 t Test.main([Ljava/lang/String;)V</code> </pre> <br>  Ainsi, toutes nos fonctions, constructeur, <code>f</code> , m√©thode statique <code>main</code> sont pr√©sentes dans la biblioth√®que <code>libTest.so</code> . <br><br>  Comme dans le cas de l'option ¬´java¬ª correspondante, dans ce cas, l'option peut √™tre accompagn√©e d'un fichier, pour cela il y a l'option ‚Äìcompile-commandes √† jaotc.  JEP 295 fournit des exemples pertinents que je ne montrerai pas ici. <br><br>  Lan√ßons maintenant ¬´java¬ª et voyons si des m√©thodes compil√©es AOT sont utilis√©es.  Si vous ex√©cutez ¬´java¬ª comme auparavant, la biblioth√®que AOT ne sera pas utilis√©e, ce qui n'est pas surprenant.  Pour utiliser cette nouvelle fonctionnalit√©, l'option <code>-XX:AOTLibrary</code> est fournie, que vous devez sp√©cifier: <br><br><pre> <code class="plaintext hljs">java -XX:AOTLibrary=./libTest.so Test</code> </pre> <br>  Vous pouvez sp√©cifier plusieurs biblioth√®ques AOT, s√©par√©es par des virgules. <br><br>  La sortie de cette commande est exactement la m√™me que lors du d√©marrage de ¬´java¬ª sans <code>AOTLibrary</code> , car le comportement du programme Test n'a pas chang√© du tout.  Pour v√©rifier si les fonctions compil√©es AOT sont utilis√©es, vous pouvez ajouter une autre nouvelle option, <code>-XX:+PrintAOT</code> . <br><br><pre> <code class="plaintext hljs">java -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  Avant la sortie du programme de <code>Test</code> , cette commande affiche les √©l√©ments suivants: <br><br><pre> <code class="plaintext hljs"> 9 1 loaded ./libTest.so aot library 99 1 aot[ 1] Test.main([Ljava/lang/String;)V 99 2 aot[ 1] Test.f()I 99 3 aot[ 1] Test.&lt;init&gt;()V</code> </pre> <br>  Comme pr√©vu, la biblioth√®que AOT est charg√©e et les fonctions compil√©es AOT sont utilis√©es. <br><br>  Si vous √™tes int√©ress√©, vous pouvez ex√©cuter la commande suivante et v√©rifier si la compilation JIT se produit. <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  Comme pr√©vu, la compilation JIT ne se produit pas, car les m√©thodes de la classe Test sont compil√©es avant l'ex√©cution et fournies sous forme de biblioth√®que. <br><br>  Une question possible est: si nous fournissons un code de fonction natif, alors comment la JVM d√©termine-t-elle si le code natif est obsol√®te / p√©rim√©?  Comme dernier exemple, modifions la fonction <code>f</code> et fixons a √† 6. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br>  Je l'ai fait juste pour modifier le fichier de classe.  Maintenant, nous faisons compiler javac et ex√©cutons la m√™me commande que ci-dessus. <br><br><pre> <code class="plaintext hljs">javac Test.java java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  Comme vous pouvez le voir, je n'ai pas ex√©cut√© ¬´jaotc¬ª apr√®s ¬´javac¬ª, donc le code de la biblioth√®que AOT est maintenant ancien et incorrect, et la fonction <code>f</code> a a = 5. <br><br>  La sortie de la commande ¬´java¬ª ci-dessus montre: <br><br><pre> <code class="plaintext hljs">228 56 b Test::&lt;init&gt; (5 bytes) 229 57 b Test::f (5 bytes)</code> </pre> <br>  Cela signifie que les fonctions dans ce cas ont √©t√© compil√©es dynamiquement, donc le code r√©sultant de la compilation AOT n'a pas √©t√© utilis√©.  Un changement a donc √©t√© d√©tect√© dans le fichier de classe.  Lorsque la compilation est effectu√©e √† l'aide de javac, son empreinte digitale est entr√©e dans la classe et l'empreinte digitale de la classe est √©galement stock√©e dans la biblioth√®que AOT.  √âtant donn√© que la nouvelle empreinte digitale de la classe diff√®re de celle stock√©e dans la biblioth√®que AOT, le code natif compil√© √† l'avance (AOT) n'a pas √©t√© utilis√©.  C'est tout ce que je voulais vous dire sur la derni√®re option de compilation, avant ex√©cution. <br><br>  Dans cet article, j'ai essay√© d'expliquer et d'illustrer avec des exemples simples et r√©alistes comment la JVM ex√©cute le code Java: l'interpr√©ter, compiler dynamiquement (JIT) ou √† l'avance (AOT) - de plus, la derni√®re opportunit√© n'est apparue que dans JDK 9. J'esp√®re que vous avez appris quelque chose nouveau. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466529/">https://habr.com/ru/post/fr466529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466517/index.html">Formation √† la localisation de l'Universit√© de Washington</a></li>
<li><a href="../fr466519/index.html">Analyse d√©taill√©e d'AWS Lambda</a></li>
<li><a href="../fr466521/index.html">C for Metal - m√©tal pr√©cieux pour l'informatique sur les cartes graphiques Intel</a></li>
<li><a href="../fr466525/index.html">Qu'est-ce qu'une disposition iPhone PSD et comment l'utiliser?</a></li>
<li><a href="../fr466527/index.html">Test de la fonctionnalit√© utilisateur du site Web avec les objets de page Capybara</a></li>
<li><a href="../fr466535/index.html">Repenser deepClone</a></li>
<li><a href="../fr466537/index.html">Utilisation de modules JavaScript en production: situation actuelle. Partie 1</a></li>
<li><a href="../fr466539/index.html">Utilisation de modules JavaScript en production: situation actuelle. 2e partie</a></li>
<li><a href="../fr466541/index.html">Utilisation de DbTool pour amorcer des bases de donn√©es dans des applications .NET (Core)</a></li>
<li><a href="../fr466543/index.html">Les pr√™ts Habr Weekly # 17 / Sberbank seront approuv√©s par AI - effrayant, publicit√© dans les produits open source - douteux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>