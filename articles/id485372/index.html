<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ» ğŸ§•ğŸ¾ â˜ï¸ Tentang yang tidak berubah: sejarah tempat ke-9 Piala AI Rusia 2019 ğŸ‘¨ğŸ½â€ğŸ”§ ğŸ‘¨ğŸ¿â€ğŸ³ ğŸ¤Ÿ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nama saya Andrey Rybalka, saya berpartisipasi dalam Piala AI Rusia di bawah nama panggilan lama dan saya akan memberi tahu Anda lagi bagaimana tidak m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tentang yang tidak berubah: sejarah tempat ke-9 Piala AI Rusia 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/485372/"><p>  Nama saya Andrey Rybalka, saya berpartisipasi dalam Piala AI Rusia di bawah nama panggilan <a href="https://russianaicup.ru/profile/lama">lama</a> dan saya <a href="https://habr.com/ru/post/345598/">akan</a> <a href="https://habr.com/ru/post/440574/">memberi tahu</a> Anda <a href="https://habr.com/ru/post/345598/">lagi</a> bagaimana tidak memenangkan macbook.  Untungnya, saya adalah orang yang berpengalaman dalam hal ini - dengan tangan ini saya belum memenangkan sebanyak 7 buah. </p><br><p>  Jadi, tugas tahun ini adalah platformer / penembak 2D, di mana Anda harus menulis bot.  Permainannya terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/81/rg/vp/81rgvptb0d2fztphudph9deltvc.jpeg"></p><br><p>  Bot tampak seperti ini: </p><br><p><img src="https://habrastorage.org/webt/au/a7/qp/aua7qpjn5khyazt7nqnefeyvra0.png"></p><br><p>  Jika Anda tertarik dengan bagaimana gambar # 2 diputar ke dalam gambar # 1, silakan, di bawah cat. </p><a name="habracut"></a><br><p>  Jika Anda tidak berpartisipasi dan tidak membaca artikel lain, saya sarankan Anda melihat dulu bagaimana semuanya terlihat dalam dinamika <a href="https://russianaicup.ru/profile/lama">di situs</a> atau di tabung: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/vfImU0kAFI0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="turnirnaya-sistema">  Sistem turnamen </h2><br><p>  Sebagai permulaan, lebih dari 2 minggu diberikan untuk pemrograman.  Kemudian babak pertama dimulai.  Itu berlangsung 2 hari dan 300 yang terbaik berlangsung.  Setelah ronde, aturan permainan berubah (sekarang kami mengontrol dua karakter sekaligus) dan satu minggu lagi diberikan, setelah ronde kedua berlalu.  Kemudian aturannya rumit lagi (sekarang kita bermain di peta yang jauh lebih kompleks), satu minggu lagi diberikan dan, akhirnya, kita bermain final. </p><br><p> Tapi ini bukan akhirnya.  Setelah final ada satu minggu lagi, di mana sandbox hanya berhenti, dan 6 yang terbaik di dalamnya, tidak termasuk pemenang final, juga diberikan.  Perbedaan mendasar antara final sandbox dan final kejuaraan adalah bahwa di sandbox, permainan dibuat dalam format acak, dan bukan hanya dalam format putaran saat ini. </p><br><h1 id="istoriya-uchastiya">  Sejarah partisipasi </h1><br><p>  Di mana tanpa itu?  Anda dapat melewati yang tidak tertarik.  Bagian teknis akan lebih rendah. </p><br><h2 id="nedelya-beta-testirovaniya-i-pervyy-raund">  Pekan Uji Beta dan Babak Pertama </h2><br><p>  Saya mulai pemrograman, tampaknya, sehari setelah dimulainya Tes Beta Terbuka.  Tetapi secara pribadi, itu agak mendemotivasi bagi saya bahwa penyelenggara kali ini, tidak seperti masa lalu, memutuskan untuk kembali dari praktik penerbitan kode pseudo-simulator.  Tentunya di antara peserta adalah mereka yang suka menulis simulator dengan teknik terbalik, tapi saya bukan salah satu dari mereka, dan saya bosan melakukannya.  Karena ini bukan kejuaraan pertamaku, aku tahu bahwa cepat atau lambat aku akan terlibat, tetapi karena alasan yang dijelaskan di atas, aku terlambat terlibat.  Akibatnya, apa yang dilakukan beberapa peserta dalam beberapa hari pertama, saya bisa memaksa diri untuk menyelesaikan hanya dalam satu setengah minggu.  Sebagai hasilnya, saya menulis baris pertama kode bot 5 hari sebelum putaran pertama.  Singkatnya, pada awal babak pertama, saya belum siap, dan putaran berlalu tanpa partisipasi saya.  Saya memutuskan bahwa saya akan langsung masuk ke putaran kedua, melalui sambungan cepat. </p><br><h2 id="vtoroy-raund">  Babak kedua </h2><br><p>  Pada titik ini, saya sudah memprogram secara maksimal, rata-rata 4-6 jam sehari.  Beberapa hari sebelum dimulainya putaran kedua, saya mengunggah bot versi pertama.  Dia segera dengan cepat naik dan dengan cepat masuk ke 10 kotak pasir teratas.  Kemudian putaran dimulai, di mana saya mengambil tempat kelima. </p><br><h2 id="final">  Terakhir </h2><br><p>  Saya menghabiskan malam pertama minggu terakhir (dari empat, karena awal dijadwalkan untuk Jumat) untuk menemukan jalan.  Masih ada banyak ide, tetapi apa yang harus dikonsentrasikan dan ide mana yang berpotensi memberikan hasil terbesar tidak jelas, jadi saya mencoba untuk memperbaiki apa yang menyebabkan kekalahan terbesar.  Pada hari Selasa dan Rabu, ini adalah peningkatan dalam membidik dan menembak, serta mengontrol peralatan P3K. </p><br><p>  Kemudian saya melihat sesuatu telah terjadi yang sudah lama saya harapkan, tetapi saya berharap ini tidak akan terjadi - beberapa lawan mulai aktif menggunakan ranjau. </p><br><p>  Faktanya adalah bahwa selama OBT, panitia mendengarkan proposal para peserta dan mengubah salah satu mekanik permainan.  Dalam kasus umum, ini, tentu saja, bagus ketika peserta didengarkan.  Namun secara khusus kali ini kehadiran umpan balik memainkan lelucon yang kejam.  Singkatnya, panitia memungkinkan ranjau diledakkan dengan tembakan. </p><br><p>  Ini sendiri logis.  Jika saya milik saya dan mereka menembaki saya, saya juga akan meledak.  Tetapi masalahnya adalah bahwa kami bermain pada poin, dan poin diberikan tidak hanya untuk pembunuhan, tetapi juga untuk kerusakan.  Jadi, ternyata jika Anda cukup dekat dengan musuh, meletakkan ranjau di bawah Anda dan menembak mereka, Anda membunuh musuh dan diri Anda sendiri dengan ledakan.  Tidak mungkin untuk menghindar.  Anda berdua mendapatkan 1000 poin untuk kedua karakter mati, tetapi Anda juga mendapatkan poin untuk kerusakan.  Jadi, jika musuh sehat, Anda akan menerima 1000 poin untuk membunuh dan 100 untuk kerusakan, dan musuh - hanya 1000. </p><br><p>  Meskipun semua orang tahu tentang itu, tetapi di atas hampir tidak ada yang menggunakan ranjau sampai yang terakhir.  Saya tidak tahu bagaimana orang lain, tetapi secara pribadi, saya tidak menggunakannya hanya karena saya tidak ingin menyalahgunakan kesalahan perhitungan yang tidak disengaja.  Tetapi, seperti yang mereka katakan dalam satu film, saya tahu bahwa cepat atau lambat kita akan beralih ke sampah ini. </p><br><p>  Singkatnya, di tengah malam dari Rabu hingga Kamis, saya membuat gangguan diri.  Murni situasional, tidak ada yang maju.  Hanya dengan prinsip bahwa jika pada saat ini karakter saya menguntungkan untuk bunuh diri, dan dia bisa melakukannya, dia melakukannya.  Seperti yang telah ditunjukkan oleh praktik, beberapa peserta lain berencana untuk menggunakan ranjau terlebih dahulu, sehingga mereka menerapkan bunuh diri yang lebih maju, tetapi secara strategis direncanakan untuk melepaskannya sebelum final.  Hasilnya, ternyata apa yang terjadi - tempat ke-9 di final, serta tahun lalu. </p><br><h2 id="final-pesochnicy">  Sandbox Finale </h2><br><p>  Setelah selesai, saya meninggalkan kota untuk liburan.  Dia kembali seminggu kemudian dan pada malam pertama, secara harfiah dalam 2-3 jam kerja, tambang sangat meningkat, yang akan saya tulis lebih banyak di bagian teknis.  Sisa dari perubahan terutama berkaitan dengan pengeditan bug dan penyelesaian fungsi evaluasi.  Singkatnya, sedikit pemrograman dan banyak tes. </p><br><h1 id="tehnicheskaya-chast">  Bagian teknis </h1><br><p>  Entah kecepatan Jawa, atau jari-jari kelengkungan tangan, melainkan, keduanya bersamaan, sekali lagi tidak memungkinkan saya untuk bergaul dengan simulasi murni.  Karena itu, pergerakan, pemotretan normal, dan pemasangan ranjau terpisah dari saya. </p><br><h2 id="simulyaciya">  Simulasi </h2><br><p>  Melalui mata bot, dunia tampak seperti ini: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jwnUo2b96eA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Di video, saya pikir, dan semuanya hampir jelas.  Di sudut kiri atas adalah debug fungsi evaluasi.  Anda dapat melihat apa Skor dari masing-masing lintasan.  Siluet kuning (misalnya, pada jam 2:30) - ini adalah lintasan yang sama di 9 arah, tentang mereka akan lebih rendah.  Garis dari panah di suatu tempat mulai 2:50 adalah pencarian jalan (merah - ke musuh, hijau - ke kotak P3K, kuning-hijau - ke senjata, biru - ke tambang).  Kotak hijau di akhir video adalah ubin PVS saya, yang terlihat dari ubin yang dipilih.  Titik-titik merah di pusatnya menunjukkan dari mana visibilitas balik berasal. </p><br><p>  Gerakan karakter disimulasikan tanpa mikrotik.  Peluru terbang juga, tetapi di dalamnya saya menggunakan beberapa peretasan sehingga situasi lebih kecil kemungkinannya terjadi ketika dengan centang penuh, peluru â€œmenembusâ€ karakter tanpa memukulnya, meskipun itu seharusnya menyentuhnya dengan mikrotik.  Misalnya, jika Anda memikirkannya, situasi yang dijelaskan hanya dapat terjadi di sudut: </p><br><p><img src="https://habrastorage.org/webt/ve/b3/wf/veb3wfaqijpe7p-qk2scwgfrueq.png"></p><br><p> Pada tick 1, peluru berada di posisi 1, di tick 2 - di posisi 2, masing-masing.  Tanpa Mikrotik - Boris-lobak - Anda dapatkan, dengan Mikrotik - tembakan telinga.  Jadi, agar ini terjadi, posisi peluru pada kutu 1 dan 2 harus berada di sisi yang berbeda dari setidaknya satu wajah karakter atau ubin (persegi panjang mint).  Dengan demikian, dimungkinkan untuk mensimulasikan peluru tanpa mikrotik sampai, seperti yang diterapkan pada gambar di atas, kondisi <code>old_bullet.x &gt; character_left_side.x != new_bullet.x &gt; character_left_side.x</code> , dan jika ini terjadi, maka Anda harus menganalisis centang ini dengan lebih hati-hati . </p><br><p>  Kemudian, setiap tick, saya menghitung ulang lintasan semua peluru terbang sebelum mereka bertabrakan dengan dinding dan menyimpan posisi mereka di setiap tick dalam array, sehingga dalam simulasi Anda dapat dengan cepat memeriksa tabrakan dengan mereka. </p><br><p>  Untuk bazoka, setelah menabrak dinding, saya secara matematis, tanpa mikrotik, menghitung titik dampak yang tepat untuk menghitung dengan tepat pusat gempa. </p><br><p>  Juga, setiap centang yang saya isi array <code>dodge_trajectories</code> - disimulasikan pergerakan setiap karakter, termasuk musuh, dalam 8 arah untuk 25 ticks (siluet kuning dalam video dari visualizer, setelah mengaktifkan kotak centang traj yang mungkin. Misalnya, jam 2:30).  Dan, seperti halnya peluru, dia menyimpan semua posisi yang memungkinkan di setiap tick.  Itu kemudian digunakan di banyak tempat, beberapa di antaranya akan saya sebutkan. </p><br><p>  Saya juga menghitung <a href="https://www.wikiwand.com/en/Potentially_visible_set">PVS</a> dengan ubin sebelumnya.  Untuk setiap sel, saya menyimpan daftar ubin, yang pusatnya terlihat berdiri di dalamnya.  Itu dihitung dengan ray tracing.  Ini bisa dilihat di video dari visualizer, di akhir.  Kotak hijau adalah ubin yang terlihat dari sel yang dipilih.  Titik-titik merah di pusatnya menunjukkan dari mana visibilitas balik berasal. </p><br><h2 id="poisk-puti">  Cari cara </h2><br><p>  Diimplementasikan oleh algoritma Dijkstra sesuai dengan Waypoints.  Ubin tempat Anda bisa berdiri dianggap Waypoint.  Adaptasi algoritma untuk platformer 2D adalah miliknya sendiri, buatan sendiri, dan oleh karena itu, demi optimasi, ia dibangun di atas kruk.  Tapi itu bekerja cukup cepat: Saya sebelumnya membangun Dijkstra (saya tidak tahu bagaimana mengatakannya dengan benar) dari setiap subjek di tingkat ke setiap ubin.  Saya hanya membangun jalan yang memiliki kemampuan lintas negara dua arah.  Ini diperlukan agar nantinya Anda bisa dengan cepat mendapatkan jalan dari ubin apa pun ke kotak P3K / senjata / tambang pertolongan pertama.  Dimungkinkan untuk menyingkirkan pembatasan ini, tetapi dalam praktiknya, saya menganggap lebih baik menghabiskan waktu untuk hal-hal lain, karena tidak ada banyak kerugian dari pembatasan ini. </p><br><p>  Selain itu, setiap kali saya beralih ke ubin lain dengan karakter apa pun (milik saya dan musuh), saya menghitung baginya jalan menuju musuh terdekat, kotak P3K, dan juga tambang dan senjata, jika dia masih membutuhkannya. </p><br><p>  Di komputer rumah saya dalam game dengan 1000 ticks, seluruh pencarian path memakan waktu sekitar 100 ms. </p><br><p>  Jika jalan melintasi musuh atau teman, saya cukup menambahkan beberapa lusin unit ke beratnya.  Jadi, jika ada jalan memutar yang relatif singkat, atau jika setelah itu lebih menguntungkan untuk lari ke objek lain, saya akan melakukannya.  Dalam video dari visualizer di atas, ini dapat dilihat pada 2:55, di mana jalan ke musuh terdekat dilewati, karena  jalan lurus melintasi karakter kedua. </p><br><p>  Visualisasi jalur pencarian: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Dyk03lk14Ho" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Kotak ungu tembus adalah titik arah, mereka juga merupakan simpul dari grafik.  Panah hijau limau - ujung <sup>1</sup> kolom <sup>2</sup> <br>  <em><sup>1</sup> tidak menjadi bingung dengan tulang rusuk; <sup>2</sup> setiap kebetulan yang bersifat monarkis adalah acak [sekitar]</em> </p><br><h2 id="peredvizhenie">  Gerakan </h2><br><p>  Dua karakter berjalan bergantian.  Jika Anda hanya berpikir - â€œdan sekarang masuk ke dalam 10 besar?!â€, Maka Anda berpikir dengan benar.  :) Tidak ada cukup sumber daya untuk berjalan dengan keduanya.  Pengecualian adalah kasus kemunculan peluru terbang baru. </p><br><p>  Dasar untuk memilih lintasan adalah genetika tanpa persimpangan.  Tetapi jika tahun lalu, dalam sepakbola, genetika menunjukkan dirinya dengan sempurna, maka tahun ini itu memberi keuntungan yang sangat kecil.  Eksperimen saya menunjukkan hasil yang sangat dekat dalam genetika dan pencarian acak.  Saya melihat beberapa alasan untuk ini, tetapi yang utama bagi saya adalah sebagai berikut: Dalam sepak bola, kami memiliki tujuan tetap - bola.  Sebagian besar waktu perilakunya dapat ditebak - jika kami menemukan lintasan yang baik untuk memukul bola ke gawang dan mengikutinya, maka setelah 20 kutu, lintasan ini mungkin masih akan baik, karena  bola tidak bisa secara spontan mengubah jalurnya.  Tapi tahun ini kami bermain bukan dengan bola, tetapi dengan karakter musuh.  Mereka mengubah perilaku mereka setiap kutu.  Jadi relevansi lintasan tetap sangat pendek. </p><br><p>  Saya masih menggunakan genetika karena dua alasan: </p><br><ol><li>  Saya baru saja menyalin kodenya dari tahun lalu.  Bahkan lucu betapa sedikit saya harus melakukan perubahan, dengan pengecualian fungsi evaluasi, sehingga bot mulai bergerak dengan lumayan.  Singkatnya, saya menulis simulator selama satu setengah minggu, dan kemudian selama sekitar satu jam saya menyalin logika gerakan dari tahun lalu, dalam satu jam saya melemparkan perkiraan sederhana dan bot, ketika memotret a la Start Cepat, mulai menang cukup stabil dengan itu. </li><li>  Saya tampaknya menyukai rasa sakit itu.  Kalau tidak, saya tidak tahu bagaimana menjelaskan mengapa saya menulis di Jawa lagi, dan tidak seperti semua atasan normal: </li></ol><br><p><img src="https://habrastorage.org/webt/kt/qp/2n/ktqp2np94dkdbxjbajr9pgp0fky.png"></p><br><p>  Jadi saya harus melakukan segalanya dengan segala cara sehingga strateginya tidak jatuh dengan batas waktu di setiap pertandingan pertama.  Dan pendekatan dengan genetika memungkinkan saya untuk menyimpan snapshot dari simulasi dunia dan poin-poin yang dihitung, dan kemudian, ketika menghitung generasi berikutnya, untuk menonaktifkan snapshot hanya dimulai dari gen <em>termutasi</em> pertama. </p><br><p>  Yaitu  secara kasar, jika pada generasi pertama saya pergi 10 kutu ke kanan, dan kemudian melompat, dan pada generasi kedua saya mengevaluasi mutan yang pergi 10 kutu ke kanan dan kemudian melompat ke bawah, maka titik referensi untuk mutan akan menjadi snapshot dunia yang sebelumnya dihitung dan poin setelah 10 gerakan ke kanan.  Jadi, saya mengurangi perhitungan secara signifikan. </p><br><p>  Igogo, algoritme gerakan perkiraan: </p><br><ol><li>  Kami menghasilkan N genotipe acak.  Masing-masing terdiri dari gen acak M.  Setiap gen adalah angka yang dikodekan dengan tindakan: satu angka bertanggung jawab untuk arah gerakan, yang kedua adalah untuk melompat / berjalan / melompat ke bawah, yang ketiga adalah untuk pemotretan dasar (murni untuk fungsi evaluasi, algoritma penembakan dasar akan dijelaskan di bawah), keempat untuk jumlah pengulangan dari ini tindakan.  Jumlah total tindakan dalam genotipe, bersama dengan pengulangan, tidak melebihi kedalaman simulasi - 40 ticks. </li><li>  Kami menambahkan sejumlah genotipe kode-keras kepada mereka: gerakan langsung dalam 9 arah (8 sisi + diam) dan beberapa preset sederhana, yang dalam praktik membantu untuk keluar dari beberapa situasi khas di labirin sedikit lebih cepat.  Sebagai contoh, ini adalah lintasan: â®¤ â®¥ </li><li>  Tambahkan genotipe terbaik dari langkah sebelumnya. </li><li>  Evaluasi semuanya, tinggalkan yang terbaik. </li><li>  Kami menciptakan generasi berikutnya di mana dalam setiap genotipe satu atau lebih gen bermutasi. </li><li>  Kami menambahkannya ke kumpulan umum, yang sudah berisi M terbaik dari generasi terakhir. </li><li>  Kami ulangi, mulai dari poin 4, beberapa kali lagi. </li></ol><br><h2 id="ocenochnaya-funkciya">  Fungsi evaluasi </h2><br><p>  Sebenarnya, tempat strategi itu tinggal. </p><br><p>  Sepanjang kejuaraan, sejumlah besar semua jenis metrik ditambahkan (tepatnya, 57).  Beberapa dari mereka tidak hidup untuk melihat final.  Bagian lain selamat, tetapi dengan latar belakang inflasi Skor selama kejuaraan, sebagai hasilnya, secara praktis tidak mempengaruhi hasilnya, tetapi sisanya, dari urutan 20-25, justru bertanggung jawab untuk gerakan dan penembakan dasar. </p><br><p>  Saya akan memberikan beberapa contoh metrik penting, secara acak: </p><br><ol><li>  Hukuman untuk ledakan peluru / bazooka pada saya. </li><li>  Bonus untuk derajat kebebasan.  Yaitu  untuk jumlah arah (atas / bawah / kiri / kanan) tempat saya dapat bergerak dari ubin saat ini.  Seperti yang Anda duga, semakin banyak derajat kebebasan - semakin banyak peluang untuk menghindari peluru.  Bonus ini memaksa bot untuk menempel pada platform dan tangga.  Bonusnya tiga kali lebih tinggi jika lawan memiliki bazoka. </li><li>  Penalti untuk jarak (melalui pencarian jalan) ke kotak P3K terdekat;  untuk jarak rata-rata (melalui pencarian jalur) ke semua kotak P3K;  karena jalan dari dia ke kotak P3K yang paling dekat dengannya kurang dari jalur dari saya ke kotak P3K (!). </li><li>  Hukuman atas kenyataan bahwa musuh melihat kepalaku. </li><li>  Hukuman untuk fakta bahwa musuh melihat kaki saya (poin 4 dan 5 memaksa bot untuk bersembunyi di balik tempat berlindung sebagian). </li><li>  Bonus serangan saat memuat ulang senjata musuh. </li><li>  Bonus untuk tembakan yang dilakukan. </li><li>  Hukuman untuk terlalu banyak atau terlalu sedikit jarak dari musuh.  Itu tergantung pada beberapa faktor: kesehatan keduanya, apakah senjata keduanya dimuat ulang, dll. </li><li>  Bonus untuk kondisi kerja berbahaya. </li><li>  Hukuman untuk keadaan jatuh dan untuk keadaan terbang pada jumppad (karena kedua negara ini tidak dapat diganggu, dan oleh karena itu, mereka lebih kecil kemungkinannya untuk menghindari peluru). </li><li>  Bonus untuk jumlah kit pertolongan pertama yang berada di sisi saya yang berlawanan, dibandingkan dengan musuh (mis., Misalnya, jika musuh ada di sebelah kanan saya, maka saya akan mendapatkan bonus untuk jumlah kit pertolongan pertama yang ada di sebelah kiri saya. Ini pada dasarnya masuk akal di Babak 1 dan 2, di mana satu-satunya jalan dari musuh ke kotak P3K adalah melalui saya). </li><li>  Bonus untuk mengikuti jalur ke musuh, ke kotak P3K (jika saya terluka), ke tambang (jika saya memiliki kurang dari dua), untuk senjata (jika tidak ada). </li><li>  Hukuman untuk kedekatan dinding jika musuh memiliki bazoka.  Lebih khusus, saya mempertimbangkan berapa banyak kutu roket musuh, jika melepaskannya, akan terbang ke dinding di dekat saya, dan berdasarkan ini, bahwa zona di dekat dinding dari mana mustahil untuk melarikan diri dari ledakan itu dianggap berbahaya dan saya menerima denda karena berada di dalamnya. </li><li>  Bonus Tahun Baru. </li></ol><br><h2 id="uklonenie-ot-pul">  Evasion Peluru </h2><br><p>  Ini terjadi secara otomatis, karena hal di atas </p><br><h2 id="pricelivanie">  Bertujuan </h2><br><p>  Ada banyak hal yang terjadi.  Mungkin yang paling penting adalah algoritma sederhana dan efektif yang memutuskan apakah saya harus mengarahkan senjata ke musuh (karena bertujuan meningkatkan penyebaran senjata): </p><br><ol><li>  Kami mempertimbangkan sudut antara (last_angle - min_spread) dan (last_angle + max_spread). </li><li>  Kami menembakkan sinar dari pusat karakter saya ke dua sudut musuh <a href="https://www.wikiwand.com/ru/AABB">AABB yang</a> paling dekat dengan garis tegak lurus.  Jika salah satu dari mereka berada di luar kisaran (last_angle - min_spread) ... (last_angle + max_spread), kami memotong rentang ini. </li><li>  Kami mempertimbangkan sudut antara sinar-sinar ini. </li><li>  Bagi sudut kedua pertama dengan yang pertama, kita mendapatkan Cakupan (cakupan).  Merupakan probabilitas <em>saat ini</em> dalam persen bahwa lintasan peluru yang ditembakkan akan berpotongan dengan kotak lawan. </li><li>  Kami mensimulasikan Aksi yang bertujuan membidik musuh, bersama dengan perubahan sebaran. </li><li>  Ulangi langkah 1..4 untuk set baru [last_angle, min_spread, max_spread].  Karenanya, kami mempertimbangkan cakupan apa yang akan kami jaga jika kami bertujuan. </li><li>  Akibatnya, kami memiliki jangkauan saat ini, serta cakupan yang diprediksi jika kami mengarahkan senjata ke musuh.  Jika perkiraan cakupan lebih besar dari saat ini, kami bertujuan. </li></ol><br><p>  Demo 2 poin: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/au1eInNY9XQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Jika garisnya berwarna hijau, maka musuh jatuh sepenuhnya ke area tujuan.  Oranye - sebagian, merah - tidak jatuh sama sekali. </p><br><p>  Tetapi saya biasanya tidak mengarah pada perut musuh, tetapi pada titik yang lebih optimal. </p><br><p>  Untuk pistol dan senapan serbu, jika musuh ada di udara, saya mempertimbangkan berapa banyak kutu peluru akan mencapai posisi saat ini, maka saya mengambil dari array <code>dodge_trajectories</code> dijelaskan di atas semua posisi yang mungkin melalui jumlah kutu, rata-rata semua 8 posisi dan, ketika membidik, saya mempertimbangkan bahwa musuh berada pada titik rata-rata ini. </p><br><p>  Jika dia berdiri di tanah, aku membidik "di kepala", atas dasar pertimbangan bahwa dia hanya bisa melompat ke atas, sehingga tembakan di kepala jauh lebih sulit untuk dihindari daripada tembakan di perut, dan bahkan lebih lagi, di kaki. </p><br><p>  Untuk bazoka, saya juga mengambil 8 posisi yang mungkin melalui kutu sebanyak roket mencapai musuh.  Bagi mereka, saya membangun kerucut (lebih tepatnya, sektor lingkaran) yang menggambarkan semua posisi ini dan di dalam kerucut ini saya memilah-milah lintasan dengan beberapa langkah.  Untuk setiap lintasan, saya mensimulasikan penerbangan roket, bersama dengan ledakan jika terjadi tabrakan di dinding.  Lintasan di mana musuh memiliki peluang paling sedikit untuk menghindar, saya gunakan untuk membidik. </p><br><p>  Bahkan dalam beberapa kasus, untuk jatuh dan terbang dari jumppad (yaitu, negara-negara yang tidak dapat disela musuh), saya cukup mempertimbangkan titik intersepsi oleh peluru musuh, dengan menyelesaikan sistem persamaan gerak.  Kode tersebut disalin dari bot hoki 2014 miliknya, tempat kode itu digunakan untuk mencegat keping.  :) </p><br><p>  Antara lain, dalam situasi tertentu saya membatalkan membidik jika ada posisi di jalur saya untuk 10 ticks berikutnya di mana sinar dari pusat posisi ini ke arah last_angle <em>saat ini</em> bersinggungan dengan musuh.  Ini memungkinkan saya untuk membidik dengan gerakan, tanpa mengubah sudut, dan karenanya, tanpa meningkatkan penyebaran. </p><br><h2 id="strelba">  Menembak </h2><br><p>  Penembakan dasar dijahit ke lintasan yang ditemukan dan murni situasional.  Tetapi juga, setiap centang bot saya mencoba menghitung apakah masuk akal untuk menembak sekarang, dan jika berhasil, ia akan menembak.  Sebagai contoh: </p><br><ul><li>  jika musuh tidak dijamin menghindar; </li><li>  jika cakupan di atas beberapa nilai tetap. </li></ul><br><p>  Juga, jika senjata saya adalah bazoka, saya mensimulasikan semua jenis lintasan dalam penyebaran jika terjadi tembakan langsung, dengan beberapa langkah.  Dan jika hasilnya menunjukkan bahwa manfaat potensial melebihi potensi bahaya, saya menembak.  Saya mengevaluasi manfaat dengan 4 metrik dalam urutan yang penting bagi saya dan musuh: jaminan kematian (milik saya atau musuh), kemungkinan kematian, kerusakan terjamin, kemungkinan kerusakan.  Jika ada setidaknya satu lintasan di mana, misalnya, saya <em>dijamin akan</em> bunuh diri dan hanya <em>mungkin</em> membunuh musuh, saya tidak menembak. </p><br><p>  Ada cek lain.  Misalnya, saya bisa membatalkan pemotretan jika pada tick berikutnya dari lintasan saya, cakupan potensial lebih tinggi daripada yang ada sekarang. </p><br><p>  Secara umum, logika mengatakan kepada saya bahwa pemotretan dasar harus dimatikan, tetapi tes menunjukkan sebaliknya.  Saya tidak bisa membayangkan mengapa. </p><br><h2 id="miny">  Tambang </h2><br><p>  Pada saat final, mereka masih bayi: Saya menandai setiap centang apa yang akan terjadi jika saya menempatkan 1 atau 2 ranjau sekarang, tergantung pada kesehatan lawan, dan menembak mereka.  Jika saya dijamin untuk membunuh musuh dan jika itu menguntungkan bagi saya (baik pada poin, atau karena hanya musuh akan mati), saya melakukannya. </p><br><p>  Setelah tahun baru, kembali dari perjalanan, saya menulis algoritma malam pertama, yang membawa saya ke 2-4 tempat di tabel.  Algoritma itu sederhana: Saya hanya mensimulasikan setiap centang apa yang akan terjadi jika saya segera beralih ke mode berserker dan berlari ke arah musuh untuk meledakkannya dengan ranjau di kesempatan paling awal.  Untuk musuh, saya mensimulasikan penghindaran sederhana menggunakan dodge_trajectories yang sama: Saya mengambil tiga lintasan yang meningkatkan jarak dari saya.  Misalnya, jika saya berada di sebelah kiri musuh, maka saya menganalisis tiga kasus: musuh melarikan diri ke kanan;  musuh berlari ke kanan dan melompat;  berlari ke kanan dan melompat ke bawah.  Jika dalam ketiga kasus saya dijamin punya waktu untuk membunuhnya dengan tambang dan dia dijamin tidak bisa menempatkan tambang di hadapanku, aku yang melakukannya. </p><br><p>  Algoritme juga dapat melompat atau melompat pada level strategi Mulai Cepat - hanya berdasarkan pada perbedaan koordinat Y. </p><br><p>  Hasilnya, pada peta terakhir, hampir setiap pertandingan berakhir dengan kurang dari 1000 kutu dengan peledakan otomatis dari kedua karakter saya. </p><br><h2 id="pacifizm">  Pasifisme </h2><br><p>  Melihat seberapa efektif ranjau saya, saya memutuskan untuk memeriksa asumsi saya yang dibuat sebelumnya pada <a href="https://t.me/aicups">saluran telegram</a> bahwa pada akhirnya dimungkinkan untuk mengambil tempat di atas tanpa menembak sama sekali.  Jadi saya hanya mengambil dan mematikan penembakan di bot saya, kecuali tembakan ranjau.  Satu-satunya adalah - agar tidak kehilangan peringkat, mode ini diaktifkan hanya jika saya memiliki cukup ranjau untuk membunuh musuh. </p><br><p>  Singkatnya, bot saya telah menjadi pasifis.  Untuk menunjukkan kedamaian dan kerendahan hatinya, dia bahkan tidak melihat musuh (lihat video).  Yah, dia terkadang menembak ranjau, menurutmu.  Saya tidak menembak lawan!  Dan jika mereka mati pada saat yang sama - yah, apa yang bisa Anda lakukan, kecelakaan tragis. </p><br><p>  Secara umum, saya mengunggah versi ini ke situs, membuat 4 game dengan masing-masing 3 teratas dan ... </p><br><p><img src="https://habrastorage.org/webt/sv/e8/69/sve869ijby1cp9lduijtx5wfusc.png"></p><br><p>  ... memenangkan 3 dari 4 pertandingan melawan masing-masing.  Secara umum, aneh bahwa tetangga tidak datang untuk mengeluh tentang tawa homeric saya di tengah malam.  :) </p><br><p>  Kagumi diri Anda sendiri: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZpvvN21vufg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Eh, jika saya menghabiskan 2-3 jam sebelum final, dan bukan setelahnya, mungkin artikel ini akan memberi tahu cara memenangkan MacBook, dan bukan bagaimana cara menghindarinya dengan segala cara, siapa tahu.  Sayangnya, sejarah tidak tahu mood subjungtif. </p><br><h1 id="testirovanie">  Pengujian </h1><br><p>  Secara umum, saya menguji setiap perubahan berkali-kali sehingga hasilnya signifikan secara statistik.  Lebih tepatnya, batas bawah interval kepercayaan harus melebihi 50%.  Untuk final kotak pasir, skrip memilih koefisien.  Pada tahun-tahun sebelumnya saya mencoba genetika, tetapi itu bekerja buruk - untuk hasil yang normal, Anda harus bermain terlalu banyak permainan.  Jadi kali ini saya hanya mengubah satu koefisien pada satu waktu dan memenangkan kembali 200 pertandingan.  Dalam kasus ketika hasilnya bagus, saya melakukan tes tambahan.  Singkatnya, dibiarkan semalam koefisien dua lusin dan memiliki hasil di pagi hari. </p><br><h1 id="v-zaklyuchenie">  Kesimpulannya </h1><br><p>  Entah bagaimana itu semua berhasil dengan setengah kesedihan. </p><br><p>  Dalam beberapa hari terakhir sebelum akhir kotak pasir, saya menghabiskan sebagian besar waktu di tempat kedua dalam tabel dengan selisih yang signifikan dari yang ketiga, tetapi beberapa jam sebelum akhir kotak pasir saya kurang beruntung dan saya memulai serangkaian permainan sesuai dengan aturan putaran 1 dan 2, sementara strategi saya paling dimainkan oleh aturan finale.  Sebagai contoh, di sini dari 13 pertandingan hanya ada 1 sesuai dengan aturan final.  Jadi saya juga, tingkat kemenangan saya dalam permainan ini keluar jauh lebih buruk dari biasanya.  Secara umum, Yang Mahakuasa acak: </p><br><p><img src="https://habrastorage.org/webt/4-/xl/wi/4-xlwimvw-jwctcn8qerejyjsma.jpeg"></p><br><p>  Akibatnya, saya kehilangan terlalu banyak pertandingan, kehilangan semua keunggulan saya dan jatuh dari 2 ke 4 tempat, dan tidak punya waktu untuk pulih, karena kejuaraan telah berakhir.  Ada baiknya bahwa kotak pasir tidak kehilangan tempat pertama dalam daftar pemenang. </p><br><p>  Sekali lagi, saya ingin berterima kasih kepada Mail.ru Group atas kejuaraan indah berikutnya.   , ,   ,          ( 1100 ).      â€” ,   .  ,         .  , , ,  ! </p><br><p>   ,    .  , ,       .       "   8 ". </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485372/">https://habr.com/ru/post/id485372/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485354/index.html">Sepeda motor dibuat menggunakan pencetakan 3D SLS</a></li>
<li><a href="../id485358/index.html">Apakah pengembangan seluler mudah dan membosankan? Laporan Yandex</a></li>
<li><a href="../id485362/index.html">Inovasi JavaScript ES2020 dengan contoh sederhana</a></li>
<li><a href="../id485364/index.html">Cara berhenti membuang waktu pengembang pada utang teknis</a></li>
<li><a href="../id485370/index.html">Bagaimana pengembang dapat membantu manajer membuat kesepakatan</a></li>
<li><a href="../id485374/index.html">Cache adalah raja kinerja: apakah prosesor memerlukan tingkat caching keempat</a></li>
<li><a href="../id485376/index.html">Bagaimana membuat frontend tiga kali lebih cepat dan kapan menerapkan perintah alih-alih repositori? Video</a></li>
<li><a href="../id485378/index.html">Studi Kasus: Cara Mendapatkan Fitur di Google Play dan Beradaptasi ASO ke Berbagai Negara</a></li>
<li><a href="../id485380/index.html">Craft dan Sukses TI</a></li>
<li><a href="../id485384/index.html">NeurIPS 2019: Tren ML yang akan bersama kita untuk dekade berikutnya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>