<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öõÔ∏è üèë üó≥Ô∏è Interfaces en C # 8: hypoth√®ses dangereuses dans l'impl√©mentation par d√©faut üë® ü§ú üëêüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 

 Dans le cadre de l'exploration du sujet de C # 8, nous vous sugg√©rons de discuter de l'article suivant sur les nouvelles r√®gles d'im...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interfaces en C # 8: hypoth√®ses dangereuses dans l'impl√©mentation par d√©faut</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/471872/"> Bonjour, Habr! <br><br>  Dans le cadre de l'exploration du sujet de C # 8, nous vous sugg√©rons de discuter de l'article suivant sur les nouvelles r√®gles d'impl√©mentation des interfaces. <br><br><img src="https://habrastorage.org/webt/vt/jp/uq/vtjpuqini0ddgc23gpr2kllk4aq.jpeg"><br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">En examinant attentivement la fa√ßon dont les</a> interfaces sont structur√©es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en C # 8</a> , vous devez consid√©rer que lors de la mise en ≈ìuvre des interfaces, vous pouvez casser le bois de chauffage par d√©faut. <br><br>  <b>Les hypoth√®ses li√©es √† l'impl√©mentation par d√©faut peuvent entra√Æner une corruption du code, des exceptions d'ex√©cution et de mauvaises performances.</b> <br><br>  L'une des fonctionnalit√©s activement annonc√©es des interfaces C # 8 est que vous pouvez ajouter des membres √† une interface sans casser les impl√©menteurs existants.  Mais l'inattention dans ce cas est lourde de gros probl√®mes.  Consid√©rez le code dans lequel les fausses hypoth√®ses sont faites - cela rendra plus clair √† quel point il est important d'√©viter de tels probl√®mes. <br><br>  <i>Tout le code de cet article est publi√© sur GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jeremybytes / interfaces-in-csharp-8</a> , en particulier dans le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DangerousAssumptions</a></i> . <br><br>  <i>Remarque: Cet article d√©crit les fonctionnalit√©s de C # 8, actuellement impl√©ment√©es uniquement dans .NET Core 3.0.</i>  <i>Dans les exemples que j'ai utilis√©s, Visual Studio 16.3.0 et .NET Core 3.0.100</i> . <br><br>  <b>Hypoth√®ses sur les d√©tails de mise en ≈ìuvre</b> <br><br>  La principale raison pour laquelle j'articule ce probl√®me est la suivante: j'ai trouv√© un article sur Internet o√π l'auteur propose un code avec de tr√®s mauvaises hypoth√®ses sur la mise en ≈ìuvre (je n'indiquerai pas l'article parce que je ne veux pas que l'auteur soit r√©capitul√© avec des commentaires; je le contacterai personnellement) . <br><br>  L'article parle de la qualit√© de l'impl√©mentation par d√©faut, car il nous permet de compl√©ter les interfaces m√™me apr√®s que le code a d√©j√† des impl√©menteurs.  Cependant, un certain nombre de mauvaises hypoth√®ses sont faites dans ce code (le code se trouve dans le dossier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BadInterface</a> de mon projet GitHub) <br><br>  Voici l'interface d'origine: <br><br><img src="https://habrastorage.org/webt/e0/w_/zs/e0w_zsxwq2pw7gvs28a6b2zsgb0.png"><br><br>  Le reste de l'article montre l'impl√©mentation de l'interface MyFile (pour moi, dans le fichier <a href="">MyFile.cs</a> ): <br><br>  L'article montre ensuite comment vous pouvez ajouter la m√©thode <code>Rename</code> avec l'impl√©mentation par d√©faut, et il ne cassera pas la classe <code>MyFile</code> existante. <br><br>  Voici l'interface mise √† jour (√† partir <a href="">du</a> fichier <a href="">IFileHandler.cs</a> ): <br><br><img src="https://habrastorage.org/webt/wt/1o/qo/wt1oqop87pe-7xcknbif6-vxcbu.png"><br><br>  MyFile fonctionne toujours, donc tout va bien.  Alors?  Pas vraiment. <br><br>  <b>Mauvaises hypoth√®ses</b> <br><br>  Le principal probl√®me avec la m√©thode Rename est ce qu'une hypoth√®se √âNORME lui est associ√©e: les impl√©mentations utilisent un fichier physique situ√© dans le syst√®me de fichiers. <br><br>  Consid√©rez l'impl√©mentation que j'ai cr√©√©e pour une utilisation dans un syst√®me de fichiers situ√© dans la RAM.  (Remarque: ceci est mon code. Ce n'est pas un article que je critique. Vous trouverez l'impl√©mentation compl√®te dans le fichier <a href="">MemoryStringFileHandler.cs</a> .) <br><br><img src="https://habrastorage.org/webt/8b/-g/mf/8b-gmffz-p1tclhw8imq0vanofa.png"><br><br>  Cette classe impl√©mente un syst√®me de fichiers formel qui utilise un dictionnaire situ√© dans la RAM, qui contient des fichiers texte.  Il n'y a rien ici qui pourrait affecter le syst√®me de fichiers physique; il n'y a g√©n√©ralement aucune r√©f√©rence √† <code>System.IO</code> . <br><br>  <b>Impl√©menteur d√©fectueux</b> <br><br>  Apr√®s la mise √† jour de l'interface, cette classe est endommag√©e. <br><br>  Si le code client appelle la m√©thode Rename, il g√©n√©rera une erreur d'ex√©cution (ou pire, renommera le fichier stock√© dans le syst√®me de fichiers). <br><br>  M√™me si notre impl√©mentation fonctionne avec des fichiers physiques, elle peut acc√©der aux fichiers situ√©s dans le stockage cloud et ces fichiers ne sont pas accessibles via System.IO.File. <br><br>  Il existe √©galement un probl√®me potentiel en ce qui concerne les tests unitaires.  Si l'objet simul√© ou faux n'est pas mis √† jour et que le code test√© est mis √† jour, il essaiera d'acc√©der au syst√®me de fichiers lors des tests unitaires. <br><blockquote>  √âtant donn√© que la mauvaise hypoth√®se concerne l'interface, les impl√©menteurs de cette interface sont corrompus. </blockquote>  <b>Des craintes d√©raisonnables?</b> <br><br>  Il est inutile de consid√©rer ces craintes comme non fond√©es.  Quand je parle d'abus dans le code, ils me r√©pondent: "Eh bien, c'est juste qu'une personne ne sait pas programmer."  Je ne peux pas √™tre en d√©saccord avec cela. <br><br>  Habituellement, je fais cela: j'attends et regarde comment cela fonctionnera.  Par exemple, j'avais peur que la possibilit√© d'une "utilisation statique" soit abus√©e.  Jusqu'√† pr√©sent, cela n'a pas d√ª √™tre convaincu. <br><br>  <i><b>Il ne faut pas oublier que de telles id√©es sont dans l'air, il est donc en notre pouvoir d'aider les autres √† emprunter une voie plus pratique, qui ne sera pas si p√©nible √† suivre.</b></i> <i><br></i> <br><br>  <b>Probl√®mes de performances</b> <br><br>  J'ai commenc√© √† r√©fl√©chir √† ce que d'autres probl√®mes pourraient nous attendre si nous faisions des hypoth√®ses incorrectes sur les impl√©menteurs d'interface. <br><br>  Dans l'exemple pr√©c√©dent, un code est appel√© en dehors de l'interface elle-m√™me (dans ce cas, en dehors de System.IO).  Vous conviendrez probablement que de telles actions sont une cloche dangereuse.  Mais, si nous utilisons les choses qui font d√©j√† partie de l'interface, tout devrait bien se passer, non? <br><br>  Pas toujours. <br><br>  √Ä titre d'exemple, j'ai cr√©√© l'interface IReader. <br><br>  <b>L'interface source et sa mise en ≈ìuvre</b> <br><br>  Voici l'interface IReader d'origine (√† partir du fichier <a href="">IReader.cs</a> - bien qu'il existe d√©j√† des mises √† jour dans ce fichier): <br><br><img src="https://habrastorage.org/webt/fi/lt/z-/filtz-c6je1oksyxv_anoif7df4.png"><br><br>  Il s'agit d'une interface de m√©thode g√©n√©rique qui vous permet d'obtenir une collection d'√©l√©ments en lecture seule. <br><br>  L'une des impl√©mentations de cette interface g√©n√®re une s√©quence de nombres de Fibonacci (oui, j'ai un int√©r√™t malsain √† g√©n√©rer des s√©quences de Fibonacci).  Voici l'interface <code>FibonacciReader</code> (du fichier <a href="">FibonacciReader.cs</a> - elle est √©galement mise √† jour sur mon github): <br><br><img src="https://habrastorage.org/webt/hl/3y/rp/hl3yrppzww6gsi1jk8r0th_tro8.png"><br><br>  La classe <code>FibonacciSequence</code> est une impl√©mentation de <code>IEnumerable &lt;int&gt;</code> (√† partir du fichier FibonacciSequence.cs).  Il utilise un entier 32 bits comme type de donn√©es, donc le d√©bordement se produit assez rapidement. <br><br><img src="https://habrastorage.org/webt/ne/jl/n2/nejln2hdhrbwjtejikx_a43ml_q.png"><br><br>  Si vous √™tes int√©ress√© par cette impl√©mentation, jetez un ≈ìil √† mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TDDing dans une s√©quence de Fibonacci en</a> article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C #</a> . <br><br>  Le projet DangerousAssumptions est une application console qui affiche les r√©sultats de FibonacciReader (√† partir du fichier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Program.cs</a> ): <br><br><img src="https://habrastorage.org/webt/no/th/06/noth06uvuy-aupnil7rirs_xm2u.png"><br><br>  Et voici la conclusion: <br><br><img src="https://habrastorage.org/webt/kb/5b/tp/kb5btppuomd69iw_mdxfpy_cu8k.png"><br><br>  <b>Interface mise √† jour</b> <br><br>  Alors maintenant, nous avons le code de travail.  Mais, t√¥t ou tard, nous devrons peut-√™tre obtenir un √©l√©ment distinct d'IReader, et non la collection enti√®re √† la fois.  Puisque nous utilisons un type g√©n√©rique avec l'interface, et pourtant nous n'avons pas la propri√©t√© ¬´natural ID¬ª dans l'objet, nous allons √©tendre l'√©l√©ment situ√© √† un index sp√©cifique. <br><br>  Voici notre interface √† laquelle la m√©thode <code>GetItemAt</code> est <code>GetItemAt</code> (√† partir de la version finale du fichier <a href="">IReader.cs</a> ): <br><br><img src="https://habrastorage.org/webt/ok/tz/ex/oktzexqhidrdeejlrbkidjnpat4.png"><br><br>  <code>GetItemAt</code> suppose ici une impl√©mentation par d√©faut.  √Ä premi√®re vue - pas si mal.  Il utilise un membre d'interface existant ( <code>GetItems</code> ), par cons√©quent, aucune hypoth√®se "externe" n'est faite ici.  Avec les r√©sultats, il utilise la m√©thode LINQ.  Je suis un grand fan de LINQ, et ce code, √† mon avis, est construit de mani√®re raisonnable. <br><br>  <b>Diff√©rences de performances</b> <br><br>  √âtant donn√© que l'impl√©mentation par d√©faut appelle <code>GetItems</code> , elle n√©cessite que la collection enti√®re soit renvoy√©e avant qu'un √©l√©ment sp√©cifique ne soit s√©lectionn√©. <br><br>  Dans le cas de <code>FibonacciReader</code> cela implique que toutes les valeurs seront g√©n√©r√©es.  Dans un formulaire mis √† jour, le fichier <a href="">Program.cs</a> contiendra le code suivant: <br><br><img src="https://habrastorage.org/webt/nq/de/6o/nqde6otfxvpelqgevulvoa1syks.png"><br><br>  Nous appelons donc <code>GetItemAt</code> .  Voici la conclusion: <br><br><img src="https://habrastorage.org/webt/si/bp/xv/sibpxvefyrxeyrokzecxmamsf_c.png"><br><br>  Si nous mettons un point de contr√¥le √† l'int√©rieur du fichier FibonacciSequence.cs, nous verrons que la s√©quence enti√®re est g√©n√©r√©e pour cela. <br><br>  Apr√®s avoir d√©marr√© le programme, nous tomberons sur ce point de contr√¥le deux fois: d'abord lors de l'appel √† <code>GetItems</code> , puis lors de l'appel √† <code>GetItemAt</code> . <br><br>  <b>Hypoth√®se nuisible aux performances</b> <br><br>  Le probl√®me le plus grave de cette m√©thode est qu'elle n√©cessite de r√©cup√©rer l'int√©gralit√© de la collection d'√©l√©ments.  Si cet <code>IReader</code> va le retirer de la base de donn√©es, alors beaucoup d'√©l√©ments devront en √™tre retir√©s, puis un seul d'entre eux sera s√©lectionn√©.  Il serait pr√©f√©rable que cette s√©lection finale soit trait√©e dans une base de donn√©es. <br><br>  En travaillant avec notre <code>FibonacciReader</code> , nous calculons chaque nouvel √©l√©ment.  Ainsi, la liste enti√®re doit √™tre enti√®rement calcul√©e pour obtenir un seul √©l√©ment dont nous avons besoin.  Le calcul de la s√©quence de Fibonacci est une op√©ration qui ne charge pas trop le processeur, mais que faire si nous traitons quelque chose de plus compliqu√©, par exemple, nous calculerons des nombres premiers? <br><br>  Vous pourriez dire: ¬´Eh bien, nous avons une m√©thode <code>GetItems</code> qui renvoie tout.  Si cela fonctionne trop longtemps, alors il ne devrait probablement pas √™tre l√†.  Et ceci est une d√©claration honn√™te. <br><br>  Cependant, le code appelant n'en sait rien.  Si j'appelle <code>GetItems</code> , je sais que (probablement) mes informations devront passer par le r√©seau, et ce processus prendra beaucoup de temps.  Si je demande un seul article, pourquoi devrais-je m'attendre √† de tels frais? <br><br>  <b>Optimisation des performances sp√©cifiques</b> <br><br>  Dans le cas de <code>FibonacciReader</code> nous pouvons ajouter notre propre impl√©mentation pour am√©liorer consid√©rablement les performances (dans la version finale du fichier <a href="">FibonacciReader.cs</a> ): <br><br><img src="https://habrastorage.org/webt/b5/lm/nu/b5lmnudcmxo-_dw3l5r66wxkkne.png"><br><br>  La m√©thode <code>GetItemAt</code> remplace l'impl√©mentation par d√©faut fournie dans l'interface. <br><br>  Ici, j'utilise la m√™me m√©thode LINQ <code>ElementAt</code> que dans l'impl√©mentation par d√©faut.  Cependant, je n'utilise pas cette m√©thode avec la collection en lecture seule que GetItems renvoie, mais avec FibonacciSequence, qui est <code>IEnumerable</code> . <br><br>  Puisque <code>FibonacciSequence</code> est <code>IEnumerable</code> , l'appel √† <code>ElementAt</code> terminera d√®s que le programme atteindra l'√©l√©ment que nous avons s√©lectionn√©.  Ainsi, nous ne g√©n√©rerons pas la collection enti√®re, mais uniquement les √©l√©ments situ√©s jusqu'√† la position sp√©cifi√©e dans l'index. <br><br>  Pour essayer cela, laissez le point de contr√¥le que nous avons fait ci-dessus dans l'application et ex√©cutez √† nouveau l'application.  Cette fois, nous tombons sur un point d'arr√™t une seule fois (lors de l'appel √† <code>GetItems</code> ).  Lorsque vous appelez <code>GetItemAt</code> cela ne se produira pas. <br><br>  <b>Un exemple un peu artificiel</b> <br><br>  Cet exemple est un peu tir√© par les cheveux, car, en r√®gle g√©n√©rale, vous n'avez pas √† s√©lectionner les √©l√©ments de l'ensemble de donn√©es par index.  Cependant, vous pouvez imaginer quelque chose de similaire qui pourrait se produire si nous travaillions avec la propri√©t√© d'identification naturelle. <br><br>  Si nous avons extrait des √©l√©ments par ID, et non par index, nous aurions pu rencontrer les m√™mes probl√®mes de performances avec l'impl√©mentation par d√©faut.  L'impl√©mentation par d√©faut n√©cessite le retour de tous les √©l√©ments, apr√®s quoi un seul est s√©lectionn√© parmi eux.  Si vous autorisez la base de donn√©es ou un autre ¬´lecteur¬ª √† extraire un √©l√©ment sp√©cifique par son ID, une telle op√©ration serait beaucoup plus efficace. <br><br>  <b>Pensez √† vos hypoth√®ses</b> <br><br>  Les hypoth√®ses sont indispensables.  Si nous essayions de prendre en compte dans le code tous les cas d'utilisation possibles de nos biblioth√®ques, alors aucune t√¢che ne serait jamais termin√©e.  Mais vous devez toujours examiner attentivement les hypoth√®ses du code. <br><br>  Cela ne signifie pas que l'impl√©mentation <code>GetElementAt</code> est n√©cessairement mauvaise.  Oui, il peut y avoir des probl√®mes de performances.  Cependant, si les ensembles de donn√©es sont petits ou que les √©l√©ments calcul√©s sont ¬´bon march√©¬ª, l'impl√©mentation par d√©faut peut √™tre un compromis raisonnable. <br><br>  N√©anmoins, je n'accueille pas les modifications de l'interface apr√®s qu'elle ait d√©j√† des impl√©menteurs.  Mais je comprends qu'il existe √©galement de tels sc√©narios dans lesquels des options alternatives sont pr√©f√©r√©es.  La programmation est la solution des probl√®mes, et lors de la r√©solution des probl√®mes, il est n√©cessaire de peser les avantages et les inconv√©nients inh√©rents √† chaque outil et approche que nous utilisons. <br><br>  L'impl√©mentation par d√©faut peut potentiellement endommager les impl√©menteurs d'interface (et √©ventuellement le code qui invoquera ces impl√©mentations).  Par cons√©quent, vous devez faire particuli√®rement attention aux hypoth√®ses li√©es aux impl√©mentations par d√©faut. <br><br>  Bonne chance dans votre travail! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471872/">https://habr.com/ru/post/fr471872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471860/index.html">Analyseurs de cheville</a></li>
<li><a href="../fr471862/index.html">Impl√©mentation de l'analyseur PEG</a></li>
<li><a href="../fr471864/index.html">G√©n√©ration de l'analyseur PEG</a></li>
<li><a href="../fr471866/index.html">Visualisation de l'analyseur PEG</a></li>
<li><a href="../fr471868/index.html">G√©n√©tique de l'amour: le conflit entre les sexes comme base de coop√©ration dans des couples d'oiseaux monogames</a></li>
<li><a href="../fr471874/index.html">Comment nous avons contourn√© les directives d'examen et lanc√© un serveur par t√©l√©phone</a></li>
<li><a href="../fr471876/index.html">PDU et All-All-All: distribution d'alimentation en rack</a></li>
<li><a href="../fr471880/index.html">Id√©e pour Geek Halloween, ou le temps de choisir GeekMask</a></li>
<li><a href="../fr471882/index.html">Une liste ouverte d'√©v√©nements PHP, de conf√©renciers et d'organisateurs sur GitHub</a></li>
<li><a href="../fr471884/index.html">10 utilitaires ApexSQL gratuits pour g√©rer les bases de donn√©es Microsoft SQL Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>