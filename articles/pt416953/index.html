<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏾 🦒 🎚️ Crie um sombreador de água de desenho animado para a web. Parte 1 🕑 👨🏿‍🌾 ⚽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No meu tutorial “Criando Shaders”, observei principalmente os shaders de fragmento, que são suficientes para implementar quaisquer efeitos e exemplos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crie um sombreador de água de desenho animado para a web. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416953/"> No meu tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“Criando Shaders”,</a> observei principalmente os shaders de fragmento, que são suficientes para implementar quaisquer efeitos e exemplos 2D no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">ShaderToy</a> .  Mas há toda uma categoria de técnicas que requerem o uso de shaders de vértice.  Neste tutorial, falarei sobre a criação de um shader de água estilizado para desenhos animados e apresentarei os shaders de vértice.  Também falarei sobre o buffer de profundidade e como usá-lo para obter mais informações sobre a cena e criar linhas de espuma do mar. <br><br>  Aqui está como será o efeito final.  Uma demonstração interativa pode ser vista <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">aqui</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/58d/814/c3858d814aa8ca99c2c0c58535503482.jpg"></div><br>  Este efeito consiste nos seguintes elementos: <br><br><ol><li>  Uma malha translúcida de água com polígonos subdivididos e vértices deslocados para criar ondas. </li><li>  Linhas de água estáticas na superfície. </li><li>  Flutuabilidade simulada do barco. </li><li>  Linhas dinâmicas de espuma em torno dos limites dos objetos na água. </li><li>  Pós-processamento para criar distorção de tudo debaixo d'água. </li></ol><br>  Nesse sentido, gosto do fato de que ele aborda muitos conceitos diferentes de computação gráfica, por isso nos permitirá usar as idéias dos tutoriais anteriores, bem como desenvolver técnicas que possam ser aplicadas em novos efeitos. <br><a name="habracut"></a><br>  Neste tutorial, usarei o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">PlayCanvas</a> , simplesmente porque é um IDE da web gratuito e conveniente, mas tudo pode ser aplicado a qualquer outro ambiente WebGL sem problemas.  No final do artigo, a versão do código fonte do Three.js será apresentada.  Assumiremos que você já conhece bem os shaders de fragmentos e a interface PlayCanvas.  Você pode atualizar seu conhecimento sobre shaders <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e se familiarizar com o PlayCanvas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h2>  Configuração do ambiente </h2><br>  O objetivo desta seção é configurar nosso projeto PlayCanvas e inserir nele vários objetos ambientais que a água influenciará. <br><br>  Se você não possui uma conta PlayCanvas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">registre-a</a> e crie um novo <strong>projeto em branco</strong> .  Por padrão, você deve ter alguns objetos na cena, uma câmera e uma fonte de luz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f57/00e/57f/f5700e57f7434006e48831c30378d0df.png"></div><br><h3>  Inserir modelos </h3><br>  Um ótimo recurso para encontrar modelos 3D para a web é o projeto Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">Poly</a> .  Peguei o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">modelo de barco</a> de lá.  Depois de baixar e descompactar o arquivo, você encontrará arquivos <code>.obj</code> e <code>.png</code> nele. <br><br><ol><li>  Arraste os dois arquivos para a janela Assets do projeto PlayCanvas. </li><li>  Selecione o material gerado automaticamente e selecione o arquivo <code>.png</code> como seu mapa difuso. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b60/499/7cc/b604997ccaad7c5d0d97a81f6da3be98.png"></div><br>  Agora você pode arrastar <strong>Tugboat.json</strong> para a cena e excluir os objetos Box e Plane.  Se o barco parecer muito pequeno, você poderá aumentar sua escala (defino o valor para 50). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4c/307/250/c4c30725001beeacf4a2149735f95a1b.png"></div><br>  Da mesma forma, você pode adicionar outros modelos à cena. <br><br><h3>  Câmera em órbita </h3><br>  Para configurar a câmera voando em órbita, copiaremos o script <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">deste exemplo do PlayCanvas</a> .  Siga o link e clique no <strong>Editor</strong> para abrir o projeto. <br><br><ol><li>  Copie o conteúdo de <code>mouse-input.js</code> e <code>orbit-camera.js</code> deste projeto tutorial em arquivos com os mesmos nomes do seu projeto. </li><li>  Adicione um componente <strong>Script</strong> à câmera. </li><li>  Anexe dois scripts à câmera. </li></ol><br><blockquote>  <em>Dica: para organizar o projeto, você pode criar pastas na janela Ativos.</em>  <em>Coloquei esses dois scripts de câmera na pasta Scripts / Camera /, meu modelo em Models / e o material na pasta Materials /.</em> </blockquote><br>  Agora, quando você inicia o jogo (o botão de lançamento na parte superior direita da janela da cena), você deve ver um barco que você pode inspecionar com uma câmera, movendo-o em órbita com o mouse. <br><br><h2>  Divisão de polígonos de superfície da água </h2><br>  O objetivo desta seção é criar uma malha subdividida que será usada como superfície da água. <br><br>  Para criar uma superfície da água, adaptamos parte do código do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">tutorial de geração de relevo</a> .  Crie um novo <code>Water.js</code> script <code>Water.js</code> .  Abra este script para edição e crie uma nova função <code>GeneratePlaneMesh</code> que será parecida com esta: <br><br><pre> <code class="javascript hljs">Water.prototype.GeneratePlaneMesh = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1 -    ,     if(options === undefined) options = {subdivisions:100, width:10, height:10}; // 2 -  , UV   var positions = []; var uvs = []; var indices = []; var row, col; var normals; for (row = 0; row &lt;= options.subdivisions; row++) { for (col = 0; col &lt;= options.subdivisions; col++) { var position = new pc.Vec3((col * options.width) / options.subdivisions - (options.width / 2.0), 0, ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0)); positions.push(position.x, position.y, position.z); uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions); } } for (row = 0; row &lt; options.subdivisions; row++) { for (col = 0; col &lt; options.subdivisions; col++) { indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + (row + 1) * (options.subdivisions + 1)); } } //   normals = pc.calculateNormals(positions, indices); //    var node = new pc.GraphNode(); var material = new pc.StandardMaterial(); //   var mesh = pc.createMesh(this.app.graphicsDevice, positions, { normals: normals, uvs: uvs, indices: indices }); var meshInstance = new pc.MeshInstance(node, mesh, material); //      var model = new pc.Model(); model.graph = node; model.meshInstances.push(meshInstance); this.entity.addComponent('model'); this.entity.model.model = model; this.entity.model.castShadows = false; //   ,       };</span></span></code> </pre> <br>  Agora podemos chamá-lo na função de <code>initialize</code> : <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GeneratePlaneMesh({<span class="hljs-attr"><span class="hljs-attr">subdivisions</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">width</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">height</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}); };</code> </pre> <br>  Agora, quando você iniciar o jogo, verá apenas uma superfície plana.  Mas isso não é apenas uma superfície plana, é uma malha composta por milhares de picos.  Como exercício, tente verificar isso sozinho (esse é um bom motivo para estudar o código que acabou de copiar). <br><br><blockquote>  <em>Problema 1: altere a coordenada Y de cada vértice por um valor aleatório para que o plano se pareça com a figura abaixo.</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/397/111/391/397111391bbb4e1cafd0e658005ed1cc.jpg"></div><br><h2>  As ondas </h2><br>  O objetivo desta seção é designar a superfície da água do seu próprio material e criar ondas animadas. <br><br>  Para obter os efeitos de que precisamos, você precisa configurar seu próprio material.  A maioria dos mecanismos 3D possui um conjunto de shaders predefinidos para renderizar objetos e uma maneira de redefini-los.  Aqui está um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">bom link</a> sobre como fazer isso no PlayCanvas. <br><br><h3>  Acessório Shader </h3><br>  Vamos criar uma nova função <code>CreateWaterMaterial</code> que <code>CreateWaterMaterial</code> novo material com um shader alterado e o retorna: <br><br><pre> <code class="javascript hljs">Water.prototype.CreateWaterMaterial = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     var material = new pc.Material(); //    ,       material.name = "DynamicWater_Material"; //    //        . var gd = this.app.graphicsDevice; var fragmentShader = "precision " + gd.precision + " float;\n"; fragmentShader = fragmentShader + this.fs.resource; var vertexShader = this.vs.resource; //       . var shaderDefinition = { attributes: { aPosition: pc.gfx.SEMANTIC_POSITION, aUv0: pc.SEMANTIC_TEXCOORD0, }, vshader: vertexShader, fshader: fragmentShader }; //     this.shader = new pc.Shader(gd, shaderDefinition); //      material.setShader(this.shader); return material; };</span></span></code> </pre> <br>  Essa função pega o código de sombreamento de vértice e fragmento dos atributos de script  Então, vamos defini-los na parte superior do arquivo (após a linha <code>pc.createScript</code> ): <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'vs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Vertex Shader'</span></span> }); Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Fragment Shader'</span></span> });</code> </pre> <br>  Agora podemos criar esses arquivos de sombreador e anexá-lo ao nosso script.  Retorne ao editor e crie dois arquivos de sombreador: <strong>Water.frag</strong> e <strong>Water.vert</strong> .  Anexe esses sombreadores ao script, como mostra a figura abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/fa4/d8a/0a2fa4d8a998e8abe1fc63da301f0ad9.png"></div><br>  Se os novos atributos não forem exibidos no editor, clique no botão <strong>Analisar</strong> para atualizar o script. <br><br>  Agora cole esse shader básico no <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); gl_FragColor = color; }</code> </pre> <br>  E este está em <strong>Water.vert</strong> : <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Por fim, retorne ao <strong>Water.js</strong> para usar nosso novo material em vez do material padrão.  Ou seja, em vez de: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pc.StandardMaterial();</code> </pre> <br>  inserir: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CreateWaterMaterial();</code> </pre> <br>  Agora, depois de iniciar o jogo, o avião deve estar azul. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e79/797/8ff/e797978ff286ff2f15b3b8465debf767.png"></div><br><h3>  Reinicialização a quente </h3><br>  Por enquanto, apenas configuramos espaços em branco para o nosso novo material.  Antes de começar a escrever efeitos reais, desejo configurar o recarregamento automático de código. <br><br>  Depois de descomentar a função de <code>swap</code> em qualquer arquivo de script (por exemplo, em Water.js), ativaremos o recarregamento a quente.  Mais tarde, veremos como usar isso para manter o estado, mesmo ao atualizar o código em tempo real.  Mas, por enquanto, queremos apenas reaplicar os shaders depois de fazer as alterações.  Antes de executar no WebGL, os shaders são compilados; portanto, para isso, precisamos recriar nosso material. <br><br>  Verificaremos se o conteúdo do nosso código de sombreador mudou e, se houver, criaremos o material novamente.  Primeiro, salve os shaders atuais na <strong>inicialização</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  initialize,       Water.prototype.initialize = function() { this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br>  E, na <strong>atualização</strong> , verificamos se alguma alteração ocorreu: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  update,     Water.prototype.update = function(dt) { if(this.savedFS != this.fs.resource || this.savedVS != this.vs.resource){ //   ,      var newMaterial = this.CreateWaterMaterial(); //     var model = this.entity.model.model; model.meshInstances[0].material = newMaterial; //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; } };</span></span></code> </pre> <br>  Agora, para garantir que isso funcione, inicie o jogo e altere a cor do avião no <strong>Water.frag</strong> para um azul mais agradável.  Após salvar o arquivo, ele deve ser atualizado mesmo sem uma reinicialização e reinicie!  Aqui está a cor que eu escolhi: <br><br><pre> <code class="javascript hljs">vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>);</code> </pre> <br><h4>  Vertex Shaders </h4><br>  Para criar ondas, devemos mover cada vértice da nossa malha em cada quadro.  Parece que será muito ineficiente, mas cada vértice de cada modelo já está transformado em cada quadro renderizado.  É isso que o shader de vértice faz. <br><br>  Se percebermos um shader de fragmento como uma função executada para cada pixel, obtém sua posição e retorna a cor, um <em>shader de vértice é uma função</em> que roda para cada pixel, obtém sua posição e retorna <em>sua posição</em> . <br><br>  Um sombreador de vértice, por padrão, obtém uma <em>posição no mundo do</em> modelo e retorna sua <em>posição na tela</em> .  Nossa cena 3D é definida nas coordenadas x, ye z, mas como o monitor é um plano bidimensional plano, projetamos um mundo 3D em uma tela 2D.  Matrizes do tipo, projeção e modelo estão envolvidas nessa projeção; portanto, não vamos considerá-lo neste tutorial.  Mas se você quiser entender o que exatamente acontece em cada estágio, aqui está um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">guia muito bom</a> . <br><br>  Ou seja, esta linha: <br><br><pre> <code class="javascript hljs">gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  recebe <code>aPosition</code> como uma posição no mundo 3D de um vértice específico e o converte em <code>gl_Position</code> , ou seja, na posição final na tela 2D.  O prefixo "a" em aPosition indica que esse valor é um <em>atributo</em> .  Não esqueça que a variável <em>uniforme</em> é um valor que podemos definir na CPU e passá-lo ao shader.  Mantém o mesmo valor para todos os pixels / vértices.  Por outro lado, o valor do atributo é obtido da <em>matriz da</em> CPU especificada.  Um sombreador de vértice é chamado para cada valor dessa matriz de atributos. <br><br>  Você pode ver que esses atributos estão configurados na definição de sombreador que definimos no Water.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shaderDefinition = { <span class="hljs-attr"><span class="hljs-attr">attributes</span></span>: { <span class="hljs-attr"><span class="hljs-attr">aPosition</span></span>: pc.gfx.SEMANTIC_POSITION, <span class="hljs-attr"><span class="hljs-attr">aUv0</span></span>: pc.SEMANTIC_TEXCOORD0, }, <span class="hljs-attr"><span class="hljs-attr">vshader</span></span>: vertexShader, <span class="hljs-attr"><span class="hljs-attr">fshader</span></span>: fragmentShader };</code> </pre> <br>  O PlayCanvas se encarrega de configurar e transmitir uma matriz de posições de vértices para <code>aPosition</code> ao passar essa enumeração, mas, no caso geral, podemos passar qualquer matriz de dados para o sombreador de vértices. <br><br><h3>  Movimento de vértice </h3><br>  Suponha que queremos compactar o plano inteiro multiplicando todos os valores de <code>x</code> por 0,5.  Precisamos alterar <code>aPosition</code> ou <code>gl_Position</code> ? <br><br>  Vamos tentar uma <code>aPosition</code> primeiro.  Não podemos alterar o atributo diretamente, mas podemos criar uma cópia: <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; pos.x *= <span class="hljs-number"><span class="hljs-number">0.5</span></span>; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Agora o avião deve se parecer mais com um retângulo.  E não há nada de estranho nisso.  Mas o que acontece se tentarmos mudar a <code>gl_Position</code> ? <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; <span class="hljs-comment"><span class="hljs-comment">//pos.x *= 0.5; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, 1.0); gl_Position.x *= 0.5; }</span></span></code> </pre> <br>  Até você começar a mover a câmera, ela pode ter a mesma aparência.  Alteramos as coordenadas do espaço da tela, ou seja, a imagem depende de <em>como a vemos</em> . <br><br>  Assim, podemos mover os vértices e, ao mesmo tempo, é importante distinguir entre trabalho nos espaços do mundo e da tela. <br><br><blockquote>  <em>Tarefa 2: você pode mover toda a superfície do plano várias unidades para cima (ao longo do eixo Y) no sombreador de vértices sem distorcer sua forma?</em> </blockquote><br><blockquote>  <em>Tarefa 3: Eu disse que gl_Position é bidimensional, mas gl_Position.z também existe.</em>  <em>Você pode verificar se esse valor afeta algo e, em caso afirmativo, para que é usado?</em> </blockquote><br><h3>  Adicionando tempo </h3><br>  A última coisa que precisamos antes de começar a criar ondas em movimento é uma variável uniforme que pode ser usada com o tempo.  Declare uniforme no shader de vértice: <br><br><pre> <code class="javascript hljs">uniform float uTime;</code> </pre> <br>  Agora, para passá-lo ao shader, <strong>vamos</strong> voltar ao <strong>Water.js</strong> e definir a variável time na inicialização: <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/////     this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br>  Agora, para transferir a variável para o shader, usamos <code>material.setParameter</code> .  Primeiro, configuramos o valor inicial no final da função <code>CreateWaterMaterial</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     this.shader = new pc.Shader(gd, shaderDefinition); //////////////   material.setParameter('uTime',this.time); this.material = material; //      //////////////// //      material.setShader(this.shader); return material;</span></span></code> </pre> <br>  Agora, na função de <code>update</code> , podemos executar um incremento de tempo e acessar o material usando o link criado para isso: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.material.setParameter(<span class="hljs-string"><span class="hljs-string">'uTime'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time);</code> </pre> <br>  Finalmente, na função de troca, copiamos o valor do horário antigo para que, mesmo após alterar o código, ele continue aumentando sem redefinir para 0. <br><br><pre> <code class="javascript hljs">Water.prototype.swap = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">old</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = old.time; };</code> </pre> <br>  Agora está tudo pronto.  Execute o jogo para garantir que não haja erros.  Agora vamos mover nosso avião usando a função de tempo em <code>Water.vert</code> : <br><br><pre> <code class="javascript hljs">pos.y += cos(uTime)</code> </pre> <br>  E o nosso avião deve começar a subir e descer!  Como agora temos uma função de troca, também podemos atualizar o Water.js sem precisar reiniciar.  Para garantir que isso funcione, tente alterar o incremento de tempo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/9fe/64a/ae99fe64ab5d40e47e3760ac1dae1dd7.gif"></div><br><blockquote>  <em>Tarefa 4: você pode mover os vértices para que se pareçam com as ondas na figura abaixo?</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1be/c55/056/1bec55056dc955769178773c2d58fe7c.gif"></div><br>  Deixe-me dizer-lhe que examinei em detalhes o tópico de várias maneiras de criar ondas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">aqui</a> .  O artigo está relacionado ao 2D, mas os cálculos matemáticos são aplicáveis ​​ao nosso caso.  Se você só quer ver a solução, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">aqui está a essência</a> . <br><br><h2>  Translucência </h2><br>  O objetivo desta seção é criar uma superfície translúcida da água. <br><br>  Você pode perceber que a cor retornada ao Water.frag tem um valor de canal alfa de 0,5, mas a superfície ainda permanece opaca.  Em muitos casos, a transparência ainda se torna um problema não resolvido na computação gráfica.  Uma maneira de baixo custo para resolvê-lo é usar a mistura. <br><br>  Geralmente, antes de desenhar um pixel, ele verifica o valor no <em>buffer de profundidade</em> e o compara com seu próprio valor de profundidade (sua posição no eixo Z) para determinar se deve ou não redesenhar o pixel atual da tela.  É isso que permite renderizar a cena corretamente sem precisar classificar os objetos de volta para a frente. <br><br>  Ao misturar, em vez de simplesmente rejeitar o pixel ou substituir, podemos combinar a cor do pixel já renderizado (destino) com o pixel que vamos desenhar (a fonte).  Uma lista de todas as funções de mixagem disponíveis no WebGL pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">aqui</a> . <br><br>  Para que o canal alfa funcione de acordo com nossas expectativas, queremos que a cor combinada do resultado seja uma fonte multiplicada por um canal alfa mais um pixel de destino multiplicado por um menos alfa.  Em outras palavras, se alfa = 0,4, a cor final deve ter um valor: <br><br><pre> <code class="javascript hljs">finalColor = source * <span class="hljs-number"><span class="hljs-number">0.4</span></span> + destination * <span class="hljs-number"><span class="hljs-number">0.6</span></span>;</code> </pre> <br>  No PlayCanvas, esta é a operação que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">pc.BLEND_NORMAL executa</a> . <br><br>  Para habilitá-lo, basta definir a propriedade do material dentro de <code>CreateWaterMaterial</code> : <br><br><pre> <code class="javascript hljs">material.blendType = pc.BLEND_NORMAL;</code> </pre> <br>  Se você iniciar o jogo agora, a água ficará translúcida!  No entanto, ainda é imperfeito.  O problema surge quando a superfície translúcida é sobreposta a si mesma, como mostrado abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/6b0/653/6df6b0653c6a86a4cd5d8b0500e22f04.png"></div><br>  Podemos eliminá-lo usando <em>alfa para cobertura</em> , uma técnica de multisampling para transparência, em vez de mesclar: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//material.blendType = pc.BLEND_NORMAL; material.alphaToCoverage = true;</span></span></code> </pre> <br>  Mas está disponível apenas no WebGL 2. No restante do tutorial, por uma questão de simplicidade, usarei a mistura. <br><br><h2>  Resumir </h2><br>  Montamos o ambiente e criamos uma superfície translúcida da água com ondas animadas do vertex shader.  Na segunda parte do tutorial, consideraremos a flutuabilidade dos objetos, adicionaremos linhas à superfície da água e criaremos linhas de espuma ao longo dos limites dos objetos que se cruzam com a superfície. <br><br>  Na terceira (última) parte, consideraremos a aplicação do efeito pós-processamento de distorções subaquáticas e consideraremos idéias para melhorias adicionais. <br><br><h2>  Código fonte </h2><br>  O projeto concluído do PlayCanvas pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">aqui</a> .  Nosso repositório também possui uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">porta de projeto em Three.js</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416953/">https://habr.com/ru/post/pt416953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416943/index.html">Materiais úteis para projetar interfaces de voz</a></li>
<li><a href="../pt416945/index.html">Como fizemos o BelAZ. Parte 1 - Ferro</a></li>
<li><a href="../pt416947/index.html">Jogue o jogo antes das Olimpíadas: eSports se torna oficial</a></li>
<li><a href="../pt416949/index.html">A atualização em larga escala do Sr. Steven para instalar uma rede de caça quatro vezes maior foi concluída</a></li>
<li><a href="../pt416951/index.html">Clusters Kubernetes no serviço VPC</a></li>
<li><a href="../pt416955/index.html">Pequenos truques com Elasticsearch</a></li>
<li><a href="../pt416957/index.html">Qual máquina a laser comprar? Revisão confiável da máquina a laser Raylogic 11G</a></li>
<li><a href="../pt416959/index.html">Apple apresenta novo recurso anti-roubo para iOS</a></li>
<li><a href="../pt416961/index.html">Resolução automática de conflitos usando transformações operacionais</a></li>
<li><a href="../pt416963/index.html">Como fizemos o BelAZ. Parte 2 - Testes de laboratório</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>