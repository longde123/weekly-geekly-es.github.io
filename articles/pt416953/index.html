<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëµüèæ ü¶í üéöÔ∏è Crie um sombreador de √°gua de desenho animado para a web. Parte 1 üïë üë®üèø‚Äçüåæ ‚öΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No meu tutorial ‚ÄúCriando Shaders‚Äù, observei principalmente os shaders de fragmento, que s√£o suficientes para implementar quaisquer efeitos e exemplos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crie um sombreador de √°gua de desenho animado para a web. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416953/"> No meu tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúCriando Shaders‚Äù,</a> observei principalmente os shaders de fragmento, que s√£o suficientes para implementar quaisquer efeitos e exemplos 2D no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">ShaderToy</a> .  Mas h√° toda uma categoria de t√©cnicas que requerem o uso de shaders de v√©rtice.  Neste tutorial, falarei sobre a cria√ß√£o de um shader de √°gua estilizado para desenhos animados e apresentarei os shaders de v√©rtice.  Tamb√©m falarei sobre o buffer de profundidade e como us√°-lo para obter mais informa√ß√µes sobre a cena e criar linhas de espuma do mar. <br><br>  Aqui est√° como ser√° o efeito final.  Uma demonstra√ß√£o interativa pode ser vista <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">aqui</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/58d/814/c3858d814aa8ca99c2c0c58535503482.jpg"></div><br>  Este efeito consiste nos seguintes elementos: <br><br><ol><li>  Uma malha transl√∫cida de √°gua com pol√≠gonos subdivididos e v√©rtices deslocados para criar ondas. </li><li>  Linhas de √°gua est√°ticas na superf√≠cie. </li><li>  Flutuabilidade simulada do barco. </li><li>  Linhas din√¢micas de espuma em torno dos limites dos objetos na √°gua. </li><li>  P√≥s-processamento para criar distor√ß√£o de tudo debaixo d'√°gua. </li></ol><br>  Nesse sentido, gosto do fato de que ele aborda muitos conceitos diferentes de computa√ß√£o gr√°fica, por isso nos permitir√° usar as id√©ias dos tutoriais anteriores, bem como desenvolver t√©cnicas que possam ser aplicadas em novos efeitos. <br><a name="habracut"></a><br>  Neste tutorial, usarei o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">PlayCanvas</a> , simplesmente porque √© um IDE da web gratuito e conveniente, mas tudo pode ser aplicado a qualquer outro ambiente WebGL sem problemas.  No final do artigo, a vers√£o do c√≥digo fonte do Three.js ser√° apresentada.  Assumiremos que voc√™ j√° conhece bem os shaders de fragmentos e a interface PlayCanvas.  Voc√™ pode atualizar seu conhecimento sobre shaders <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e se familiarizar com o PlayCanvas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h2>  Configura√ß√£o do ambiente </h2><br>  O objetivo desta se√ß√£o √© configurar nosso projeto PlayCanvas e inserir nele v√°rios objetos ambientais que a √°gua influenciar√°. <br><br>  Se voc√™ n√£o possui uma conta PlayCanvas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">registre-a</a> e crie um novo <strong>projeto em branco</strong> .  Por padr√£o, voc√™ deve ter alguns objetos na cena, uma c√¢mera e uma fonte de luz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f57/00e/57f/f5700e57f7434006e48831c30378d0df.png"></div><br><h3>  Inserir modelos </h3><br>  Um √≥timo recurso para encontrar modelos 3D para a web √© o projeto Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">Poly</a> .  Peguei o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">modelo de barco</a> de l√°.  Depois de baixar e descompactar o arquivo, voc√™ encontrar√° arquivos <code>.obj</code> e <code>.png</code> nele. <br><br><ol><li>  Arraste os dois arquivos para a janela Assets do projeto PlayCanvas. </li><li>  Selecione o material gerado automaticamente e selecione o arquivo <code>.png</code> como seu mapa difuso. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b60/499/7cc/b604997ccaad7c5d0d97a81f6da3be98.png"></div><br>  Agora voc√™ pode arrastar <strong>Tugboat.json</strong> para a cena e excluir os objetos Box e Plane.  Se o barco parecer muito pequeno, voc√™ poder√° aumentar sua escala (defino o valor para 50). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4c/307/250/c4c30725001beeacf4a2149735f95a1b.png"></div><br>  Da mesma forma, voc√™ pode adicionar outros modelos √† cena. <br><br><h3>  C√¢mera em √≥rbita </h3><br>  Para configurar a c√¢mera voando em √≥rbita, copiaremos o script <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">deste exemplo do PlayCanvas</a> .  Siga o link e clique no <strong>Editor</strong> para abrir o projeto. <br><br><ol><li>  Copie o conte√∫do de <code>mouse-input.js</code> e <code>orbit-camera.js</code> deste projeto tutorial em arquivos com os mesmos nomes do seu projeto. </li><li>  Adicione um componente <strong>Script</strong> √† c√¢mera. </li><li>  Anexe dois scripts √† c√¢mera. </li></ol><br><blockquote>  <em>Dica: para organizar o projeto, voc√™ pode criar pastas na janela Ativos.</em>  <em>Coloquei esses dois scripts de c√¢mera na pasta Scripts / Camera /, meu modelo em Models / e o material na pasta Materials /.</em> </blockquote><br>  Agora, quando voc√™ inicia o jogo (o bot√£o de lan√ßamento na parte superior direita da janela da cena), voc√™ deve ver um barco que voc√™ pode inspecionar com uma c√¢mera, movendo-o em √≥rbita com o mouse. <br><br><h2>  Divis√£o de pol√≠gonos de superf√≠cie da √°gua </h2><br>  O objetivo desta se√ß√£o √© criar uma malha subdividida que ser√° usada como superf√≠cie da √°gua. <br><br>  Para criar uma superf√≠cie da √°gua, adaptamos parte do c√≥digo do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">tutorial de gera√ß√£o de relevo</a> .  Crie um novo <code>Water.js</code> script <code>Water.js</code> .  Abra este script para edi√ß√£o e crie uma nova fun√ß√£o <code>GeneratePlaneMesh</code> que ser√° parecida com esta: <br><br><pre> <code class="javascript hljs">Water.prototype.GeneratePlaneMesh = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1 -    ,     if(options === undefined) options = {subdivisions:100, width:10, height:10}; // 2 -  , UV   var positions = []; var uvs = []; var indices = []; var row, col; var normals; for (row = 0; row &lt;= options.subdivisions; row++) { for (col = 0; col &lt;= options.subdivisions; col++) { var position = new pc.Vec3((col * options.width) / options.subdivisions - (options.width / 2.0), 0, ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0)); positions.push(position.x, position.y, position.z); uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions); } } for (row = 0; row &lt; options.subdivisions; row++) { for (col = 0; col &lt; options.subdivisions; col++) { indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + (row + 1) * (options.subdivisions + 1)); } } //   normals = pc.calculateNormals(positions, indices); //    var node = new pc.GraphNode(); var material = new pc.StandardMaterial(); //   var mesh = pc.createMesh(this.app.graphicsDevice, positions, { normals: normals, uvs: uvs, indices: indices }); var meshInstance = new pc.MeshInstance(node, mesh, material); //      var model = new pc.Model(); model.graph = node; model.meshInstances.push(meshInstance); this.entity.addComponent('model'); this.entity.model.model = model; this.entity.model.castShadows = false; //   ,       };</span></span></code> </pre> <br>  Agora podemos cham√°-lo na fun√ß√£o de <code>initialize</code> : <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GeneratePlaneMesh({<span class="hljs-attr"><span class="hljs-attr">subdivisions</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">width</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">height</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}); };</code> </pre> <br>  Agora, quando voc√™ iniciar o jogo, ver√° apenas uma superf√≠cie plana.  Mas isso n√£o √© apenas uma superf√≠cie plana, √© uma malha composta por milhares de picos.  Como exerc√≠cio, tente verificar isso sozinho (esse √© um bom motivo para estudar o c√≥digo que acabou de copiar). <br><br><blockquote>  <em>Problema 1: altere a coordenada Y de cada v√©rtice por um valor aleat√≥rio para que o plano se pare√ßa com a figura abaixo.</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/397/111/391/397111391bbb4e1cafd0e658005ed1cc.jpg"></div><br><h2>  As ondas </h2><br>  O objetivo desta se√ß√£o √© designar a superf√≠cie da √°gua do seu pr√≥prio material e criar ondas animadas. <br><br>  Para obter os efeitos de que precisamos, voc√™ precisa configurar seu pr√≥prio material.  A maioria dos mecanismos 3D possui um conjunto de shaders predefinidos para renderizar objetos e uma maneira de redefini-los.  Aqui est√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">bom link</a> sobre como fazer isso no PlayCanvas. <br><br><h3>  Acess√≥rio Shader </h3><br>  Vamos criar uma nova fun√ß√£o <code>CreateWaterMaterial</code> que <code>CreateWaterMaterial</code> novo material com um shader alterado e o retorna: <br><br><pre> <code class="javascript hljs">Water.prototype.CreateWaterMaterial = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     var material = new pc.Material(); //    ,       material.name = "DynamicWater_Material"; //    //        . var gd = this.app.graphicsDevice; var fragmentShader = "precision " + gd.precision + " float;\n"; fragmentShader = fragmentShader + this.fs.resource; var vertexShader = this.vs.resource; //       . var shaderDefinition = { attributes: { aPosition: pc.gfx.SEMANTIC_POSITION, aUv0: pc.SEMANTIC_TEXCOORD0, }, vshader: vertexShader, fshader: fragmentShader }; //     this.shader = new pc.Shader(gd, shaderDefinition); //      material.setShader(this.shader); return material; };</span></span></code> </pre> <br>  Essa fun√ß√£o pega o c√≥digo de sombreamento de v√©rtice e fragmento dos atributos de script  Ent√£o, vamos defini-los na parte superior do arquivo (ap√≥s a linha <code>pc.createScript</code> ): <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'vs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Vertex Shader'</span></span> }); Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Fragment Shader'</span></span> });</code> </pre> <br>  Agora podemos criar esses arquivos de sombreador e anex√°-lo ao nosso script.  Retorne ao editor e crie dois arquivos de sombreador: <strong>Water.frag</strong> e <strong>Water.vert</strong> .  Anexe esses sombreadores ao script, como mostra a figura abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/fa4/d8a/0a2fa4d8a998e8abe1fc63da301f0ad9.png"></div><br>  Se os novos atributos n√£o forem exibidos no editor, clique no bot√£o <strong>Analisar</strong> para atualizar o script. <br><br>  Agora cole esse shader b√°sico no <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); gl_FragColor = color; }</code> </pre> <br>  E este est√° em <strong>Water.vert</strong> : <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Por fim, retorne ao <strong>Water.js</strong> para usar nosso novo material em vez do material padr√£o.  Ou seja, em vez de: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pc.StandardMaterial();</code> </pre> <br>  inserir: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CreateWaterMaterial();</code> </pre> <br>  Agora, depois de iniciar o jogo, o avi√£o deve estar azul. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e79/797/8ff/e797978ff286ff2f15b3b8465debf767.png"></div><br><h3>  Reinicializa√ß√£o a quente </h3><br>  Por enquanto, apenas configuramos espa√ßos em branco para o nosso novo material.  Antes de come√ßar a escrever efeitos reais, desejo configurar o recarregamento autom√°tico de c√≥digo. <br><br>  Depois de descomentar a fun√ß√£o de <code>swap</code> em qualquer arquivo de script (por exemplo, em Water.js), ativaremos o recarregamento a quente.  Mais tarde, veremos como usar isso para manter o estado, mesmo ao atualizar o c√≥digo em tempo real.  Mas, por enquanto, queremos apenas reaplicar os shaders depois de fazer as altera√ß√µes.  Antes de executar no WebGL, os shaders s√£o compilados; portanto, para isso, precisamos recriar nosso material. <br><br>  Verificaremos se o conte√∫do do nosso c√≥digo de sombreador mudou e, se houver, criaremos o material novamente.  Primeiro, salve os shaders atuais na <strong>inicializa√ß√£o</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  initialize,       Water.prototype.initialize = function() { this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br>  E, na <strong>atualiza√ß√£o</strong> , verificamos se alguma altera√ß√£o ocorreu: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  update,     Water.prototype.update = function(dt) { if(this.savedFS != this.fs.resource || this.savedVS != this.vs.resource){ //   ,      var newMaterial = this.CreateWaterMaterial(); //     var model = this.entity.model.model; model.meshInstances[0].material = newMaterial; //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; } };</span></span></code> </pre> <br>  Agora, para garantir que isso funcione, inicie o jogo e altere a cor do avi√£o no <strong>Water.frag</strong> para um azul mais agrad√°vel.  Ap√≥s salvar o arquivo, ele deve ser atualizado mesmo sem uma reinicializa√ß√£o e reinicie!  Aqui est√° a cor que eu escolhi: <br><br><pre> <code class="javascript hljs">vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>);</code> </pre> <br><h4>  Vertex Shaders </h4><br>  Para criar ondas, devemos mover cada v√©rtice da nossa malha em cada quadro.  Parece que ser√° muito ineficiente, mas cada v√©rtice de cada modelo j√° est√° transformado em cada quadro renderizado.  √â isso que o shader de v√©rtice faz. <br><br>  Se percebermos um shader de fragmento como uma fun√ß√£o executada para cada pixel, obt√©m sua posi√ß√£o e retorna a cor, um <em>shader de v√©rtice √© uma fun√ß√£o</em> que roda para cada pixel, obt√©m sua posi√ß√£o e retorna <em>sua posi√ß√£o</em> . <br><br>  Um sombreador de v√©rtice, por padr√£o, obt√©m uma <em>posi√ß√£o no mundo do</em> modelo e retorna sua <em>posi√ß√£o na tela</em> .  Nossa cena 3D √© definida nas coordenadas x, ye z, mas como o monitor √© um plano bidimensional plano, projetamos um mundo 3D em uma tela 2D.  Matrizes do tipo, proje√ß√£o e modelo est√£o envolvidas nessa proje√ß√£o; portanto, n√£o vamos consider√°-lo neste tutorial.  Mas se voc√™ quiser entender o que exatamente acontece em cada est√°gio, aqui est√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">guia muito bom</a> . <br><br>  Ou seja, esta linha: <br><br><pre> <code class="javascript hljs">gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  recebe <code>aPosition</code> como uma posi√ß√£o no mundo 3D de um v√©rtice espec√≠fico e o converte em <code>gl_Position</code> , ou seja, na posi√ß√£o final na tela 2D.  O prefixo "a" em aPosition indica que esse valor √© um <em>atributo</em> .  N√£o esque√ßa que a vari√°vel <em>uniforme</em> √© um valor que podemos definir na CPU e pass√°-lo ao shader.  Mant√©m o mesmo valor para todos os pixels / v√©rtices.  Por outro lado, o valor do atributo √© obtido da <em>matriz da</em> CPU especificada.  Um sombreador de v√©rtice √© chamado para cada valor dessa matriz de atributos. <br><br>  Voc√™ pode ver que esses atributos est√£o configurados na defini√ß√£o de sombreador que definimos no Water.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shaderDefinition = { <span class="hljs-attr"><span class="hljs-attr">attributes</span></span>: { <span class="hljs-attr"><span class="hljs-attr">aPosition</span></span>: pc.gfx.SEMANTIC_POSITION, <span class="hljs-attr"><span class="hljs-attr">aUv0</span></span>: pc.SEMANTIC_TEXCOORD0, }, <span class="hljs-attr"><span class="hljs-attr">vshader</span></span>: vertexShader, <span class="hljs-attr"><span class="hljs-attr">fshader</span></span>: fragmentShader };</code> </pre> <br>  O PlayCanvas se encarrega de configurar e transmitir uma matriz de posi√ß√µes de v√©rtices para <code>aPosition</code> ao passar essa enumera√ß√£o, mas, no caso geral, podemos passar qualquer matriz de dados para o sombreador de v√©rtices. <br><br><h3>  Movimento de v√©rtice </h3><br>  Suponha que queremos compactar o plano inteiro multiplicando todos os valores de <code>x</code> por 0,5.  Precisamos alterar <code>aPosition</code> ou <code>gl_Position</code> ? <br><br>  Vamos tentar uma <code>aPosition</code> primeiro.  N√£o podemos alterar o atributo diretamente, mas podemos criar uma c√≥pia: <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; pos.x *= <span class="hljs-number"><span class="hljs-number">0.5</span></span>; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Agora o avi√£o deve se parecer mais com um ret√¢ngulo.  E n√£o h√° nada de estranho nisso.  Mas o que acontece se tentarmos mudar a <code>gl_Position</code> ? <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; <span class="hljs-comment"><span class="hljs-comment">//pos.x *= 0.5; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, 1.0); gl_Position.x *= 0.5; }</span></span></code> </pre> <br>  At√© voc√™ come√ßar a mover a c√¢mera, ela pode ter a mesma apar√™ncia.  Alteramos as coordenadas do espa√ßo da tela, ou seja, a imagem depende de <em>como a vemos</em> . <br><br>  Assim, podemos mover os v√©rtices e, ao mesmo tempo, √© importante distinguir entre trabalho nos espa√ßos do mundo e da tela. <br><br><blockquote>  <em>Tarefa 2: voc√™ pode mover toda a superf√≠cie do plano v√°rias unidades para cima (ao longo do eixo Y) no sombreador de v√©rtices sem distorcer sua forma?</em> </blockquote><br><blockquote>  <em>Tarefa 3: Eu disse que gl_Position √© bidimensional, mas gl_Position.z tamb√©m existe.</em>  <em>Voc√™ pode verificar se esse valor afeta algo e, em caso afirmativo, para que √© usado?</em> </blockquote><br><h3>  Adicionando tempo </h3><br>  A √∫ltima coisa que precisamos antes de come√ßar a criar ondas em movimento √© uma vari√°vel uniforme que pode ser usada com o tempo.  Declare uniforme no shader de v√©rtice: <br><br><pre> <code class="javascript hljs">uniform float uTime;</code> </pre> <br>  Agora, para pass√°-lo ao shader, <strong>vamos</strong> voltar ao <strong>Water.js</strong> e definir a vari√°vel time na inicializa√ß√£o: <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/////     this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br>  Agora, para transferir a vari√°vel para o shader, usamos <code>material.setParameter</code> .  Primeiro, configuramos o valor inicial no final da fun√ß√£o <code>CreateWaterMaterial</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     this.shader = new pc.Shader(gd, shaderDefinition); //////////////   material.setParameter('uTime',this.time); this.material = material; //      //////////////// //      material.setShader(this.shader); return material;</span></span></code> </pre> <br>  Agora, na fun√ß√£o de <code>update</code> , podemos executar um incremento de tempo e acessar o material usando o link criado para isso: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.material.setParameter(<span class="hljs-string"><span class="hljs-string">'uTime'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time);</code> </pre> <br>  Finalmente, na fun√ß√£o de troca, copiamos o valor do hor√°rio antigo para que, mesmo ap√≥s alterar o c√≥digo, ele continue aumentando sem redefinir para 0. <br><br><pre> <code class="javascript hljs">Water.prototype.swap = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">old</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = old.time; };</code> </pre> <br>  Agora est√° tudo pronto.  Execute o jogo para garantir que n√£o haja erros.  Agora vamos mover nosso avi√£o usando a fun√ß√£o de tempo em <code>Water.vert</code> : <br><br><pre> <code class="javascript hljs">pos.y += cos(uTime)</code> </pre> <br>  E o nosso avi√£o deve come√ßar a subir e descer!  Como agora temos uma fun√ß√£o de troca, tamb√©m podemos atualizar o Water.js sem precisar reiniciar.  Para garantir que isso funcione, tente alterar o incremento de tempo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/9fe/64a/ae99fe64ab5d40e47e3760ac1dae1dd7.gif"></div><br><blockquote>  <em>Tarefa 4: voc√™ pode mover os v√©rtices para que se pare√ßam com as ondas na figura abaixo?</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1be/c55/056/1bec55056dc955769178773c2d58fe7c.gif"></div><br>  Deixe-me dizer-lhe que examinei em detalhes o t√≥pico de v√°rias maneiras de criar ondas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">aqui</a> .  O artigo est√° relacionado ao 2D, mas os c√°lculos matem√°ticos s√£o aplic√°veis ‚Äã‚Äãao nosso caso.  Se voc√™ s√≥ quer ver a solu√ß√£o, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">aqui est√° a ess√™ncia</a> . <br><br><h2>  Transluc√™ncia </h2><br>  O objetivo desta se√ß√£o √© criar uma superf√≠cie transl√∫cida da √°gua. <br><br>  Voc√™ pode perceber que a cor retornada ao Water.frag tem um valor de canal alfa de 0,5, mas a superf√≠cie ainda permanece opaca.  Em muitos casos, a transpar√™ncia ainda se torna um problema n√£o resolvido na computa√ß√£o gr√°fica.  Uma maneira de baixo custo para resolv√™-lo √© usar a mistura. <br><br>  Geralmente, antes de desenhar um pixel, ele verifica o valor no <em>buffer de profundidade</em> e o compara com seu pr√≥prio valor de profundidade (sua posi√ß√£o no eixo Z) para determinar se deve ou n√£o redesenhar o pixel atual da tela.  √â isso que permite renderizar a cena corretamente sem precisar classificar os objetos de volta para a frente. <br><br>  Ao misturar, em vez de simplesmente rejeitar o pixel ou substituir, podemos combinar a cor do pixel j√° renderizado (destino) com o pixel que vamos desenhar (a fonte).  Uma lista de todas as fun√ß√µes de mixagem dispon√≠veis no WebGL pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">aqui</a> . <br><br>  Para que o canal alfa funcione de acordo com nossas expectativas, queremos que a cor combinada do resultado seja uma fonte multiplicada por um canal alfa mais um pixel de destino multiplicado por um menos alfa.  Em outras palavras, se alfa = 0,4, a cor final deve ter um valor: <br><br><pre> <code class="javascript hljs">finalColor = source * <span class="hljs-number"><span class="hljs-number">0.4</span></span> + destination * <span class="hljs-number"><span class="hljs-number">0.6</span></span>;</code> </pre> <br>  No PlayCanvas, esta √© a opera√ß√£o que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">pc.BLEND_NORMAL executa</a> . <br><br>  Para habilit√°-lo, basta definir a propriedade do material dentro de <code>CreateWaterMaterial</code> : <br><br><pre> <code class="javascript hljs">material.blendType = pc.BLEND_NORMAL;</code> </pre> <br>  Se voc√™ iniciar o jogo agora, a √°gua ficar√° transl√∫cida!  No entanto, ainda √© imperfeito.  O problema surge quando a superf√≠cie transl√∫cida √© sobreposta a si mesma, como mostrado abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/6b0/653/6df6b0653c6a86a4cd5d8b0500e22f04.png"></div><br>  Podemos elimin√°-lo usando <em>alfa para cobertura</em> , uma t√©cnica de multisampling para transpar√™ncia, em vez de mesclar: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//material.blendType = pc.BLEND_NORMAL; material.alphaToCoverage = true;</span></span></code> </pre> <br>  Mas est√° dispon√≠vel apenas no WebGL 2. No restante do tutorial, por uma quest√£o de simplicidade, usarei a mistura. <br><br><h2>  Resumir </h2><br>  Montamos o ambiente e criamos uma superf√≠cie transl√∫cida da √°gua com ondas animadas do vertex shader.  Na segunda parte do tutorial, consideraremos a flutuabilidade dos objetos, adicionaremos linhas √† superf√≠cie da √°gua e criaremos linhas de espuma ao longo dos limites dos objetos que se cruzam com a superf√≠cie. <br><br>  Na terceira (√∫ltima) parte, consideraremos a aplica√ß√£o do efeito p√≥s-processamento de distor√ß√µes subaqu√°ticas e consideraremos id√©ias para melhorias adicionais. <br><br><h2>  C√≥digo fonte </h2><br>  O projeto conclu√≠do do PlayCanvas pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">aqui</a> .  Nosso reposit√≥rio tamb√©m possui uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">porta de projeto em Three.js</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416953/">https://habr.com/ru/post/pt416953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416943/index.html">Materiais √∫teis para projetar interfaces de voz</a></li>
<li><a href="../pt416945/index.html">Como fizemos o BelAZ. Parte 1 - Ferro</a></li>
<li><a href="../pt416947/index.html">Jogue o jogo antes das Olimp√≠adas: eSports se torna oficial</a></li>
<li><a href="../pt416949/index.html">A atualiza√ß√£o em larga escala do Sr. Steven para instalar uma rede de ca√ßa quatro vezes maior foi conclu√≠da</a></li>
<li><a href="../pt416951/index.html">Clusters Kubernetes no servi√ßo VPC</a></li>
<li><a href="../pt416955/index.html">Pequenos truques com Elasticsearch</a></li>
<li><a href="../pt416957/index.html">Qual m√°quina a laser comprar? Revis√£o confi√°vel da m√°quina a laser Raylogic 11G</a></li>
<li><a href="../pt416959/index.html">Apple apresenta novo recurso anti-roubo para iOS</a></li>
<li><a href="../pt416961/index.html">Resolu√ß√£o autom√°tica de conflitos usando transforma√ß√µes operacionais</a></li>
<li><a href="../pt416963/index.html">Como fizemos o BelAZ. Parte 2 - Testes de laborat√≥rio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>