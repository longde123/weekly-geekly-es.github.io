<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ•¦ ğŸ•¹ï¸ D'oÃ¹ viennent les mojibakes? Essentiels des encodages ğŸ³ï¸ ğŸ”¶ ğŸš½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article explore les concepts de base du codage de caractÃ¨res, puis approfondit les dÃ©tails techniques des systÃ¨mes de codage. 


 Si vous avez jus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D'oÃ¹ viennent les mojibakes? Essentiels des encodages</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alconost/blog/480688/"><p> <a href="https://habrahabr.ru/company/alconost/blog/480688/"><img src="https://habrastorage.org/webt/6b/fx/u8/6bfxu80gx8ygam-qemhdptmtsvc.jpeg"></a> </p><br><p>  Cet article explore les concepts de base du codage de caractÃ¨res, puis approfondit les dÃ©tails techniques des systÃ¨mes de codage. </p><br><p>  Si vous avez juste une connaissance de base de l'encodage de caractÃ¨res et que vous souhaitez mieux comprendre l'essentiel, les diffÃ©rences entre les systÃ¨mes d'encodage, pourquoi nous nous retrouvons parfois avec du texte absurde et les principes derriÃ¨re diffÃ©rentes architectures de systÃ¨me d'encodage, alors lisez la suite. </p><br><p>  Apprendre Ã  comprendre l'encodage des caractÃ¨res en dÃ©tail nÃ©cessite une lecture approfondie et beaucoup de temps.  J'ai essayÃ© de vous Ã©pargner une partie de cet effort en rassemblant tout cela en un seul endroit tout en fournissant ce que je pense Ãªtre un fond assez approfondi du sujet. </p><br><p>  Je vais passer en revue le fonctionnement des codages Ã  un octet (ASCII, Windows-1251, etc.), l'historique de la faÃ§on dont Unicode a vu le jour, les codages basÃ©s sur Unicode UTF-8, UTF-16 et leurs diffÃ©rences, le caractÃ©ristiques spÃ©cifiques, compatibilitÃ© et absence de fonctionnalitÃ©s parmi les diffÃ©rents encodages, principes d'encodage des caractÃ¨res et guide pratique sur la faÃ§on dont les caractÃ¨res sont encodÃ©s et dÃ©codÃ©s. </p><a name="habracut"></a><br><p>  Bien que l'encodage des caractÃ¨res ne soit pas un sujet de pointe, il est utile de comprendre comment cela fonctionne maintenant et comment cela a fonctionnÃ© dans le passÃ© sans passer beaucoup de temps. </p><br><h3 id="history-of-unicode">  Histoire de l'unicode </h3><br><p>  Je pense qu'il est prÃ©fÃ©rable de commencer notre histoire Ã  partir du moment oÃ¹ les ordinateurs n'Ã©taient pas aussi avancÃ©s ni aussi banals qu'une partie de notre vie comme ils le sont maintenant.  Les dÃ©veloppeurs et les ingÃ©nieurs qui essayaient de trouver des normes Ã  l'Ã©poque n'avaient aucune idÃ©e que les ordinateurs et Internet seraient aussi populaires et omniprÃ©sents qu'eux.  Lorsque cela s'est produit, le monde avait besoin d'encodages de caractÃ¨res. </p><br><p>  Mais comment pouvez-vous avoir un ordinateur pour stocker des caractÃ¨res ou des lettres alors qu'il ne comprend que les uns et les zÃ©ros?  De ce besoin est nÃ© le premier codage ASCII Ã  1 octet qui, bien que n'Ã©tant pas nÃ©cessairement le premier codage, a Ã©tÃ© le plus largement utilisÃ© et a Ã©tabli la rÃ©fÃ©rence.  C'est donc un bon standard Ã  utiliser. </p><br><p>  Mais qu'est-ce que l'ASCII?  Le code ASCII est composÃ© de 8 bits.  Une arithmÃ©tique simple montre que ce jeu de caractÃ¨res contient 256 symboles (huit bits, zÃ©ros et uns 2â¸ = 256). </p><br><p>  Les 7 premiers bits - 128 symboles (2â· = 128) de l'ensemble ont Ã©tÃ© utilisÃ©s pour les lettres latines, les caractÃ¨res de contrÃ´le (tels que les sauts de ligne, les tabulations, etc.) et les symboles grammaticaux.  Les autres Ã©lÃ©ments concernaient les langues nationales.  De cette faÃ§on, les 128 premiers caractÃ¨res sont toujours les mÃªmes, et si vous souhaitez encoder votre langue maternelle, servez-vous des symboles restants. </p><br><p>  Cela a donnÃ© lieu Ã  une panoplie d'encodages nationaux.  Vous vous retrouvez avec une situation comme celle-ci: disons que vous Ãªtes en Russie en train de crÃ©er un fichier texte qui, par dÃ©faut, utilisera Windows-1251 (l'encodage russe utilisÃ© dans Windows).  Et vous envoyez votre document Ã  quelqu'un en dehors de la Russie, par exemple aux Ã‰tats-Unis.  MÃªme si le destinataire connaÃ®t le russe, il n'aura pas de chance lorsqu'il ouvrira le document sur son ordinateur (avec un logiciel de traitement de texte utilisant ASCII comme code par dÃ©faut) car il verra des caractÃ¨res bizarres bizarres (mojibake) au lieu de lettres russes .  Plus prÃ©cisÃ©ment, toutes les lettres anglaises apparaÃ®tront trÃ¨s bien, car les 128 premiers symboles dans Windows-1251 et ASCII sont identiques, mais partout oÃ¹ il y a du texte russe, le logiciel de traitement de texte de notre destinataire utilisera le mauvais encodage Ã  moins que l'utilisateur n'ait dÃ©fini manuellement le bon caractÃ¨re encodage. </p><br><p>  Le problÃ¨me avec les normes de code de caractÃ¨re national est Ã©vident.  Et finalement, ces codes nationaux ont commencÃ© Ã  se multiplier, Internet a commencÃ© Ã  exploser, et tout le monde voulait Ã©crire dans sa langue nationale sans produire ces mojibakes indÃ©chiffrables. </p><br><p>  Il y avait deux options Ã  ce stade - utiliser un encodage pour chaque pays ou crÃ©er une carte de caractÃ¨res universelle pour reprÃ©senter tous les personnages de la planÃ¨te. </p><br><h3 id="a-short-primer-on-ascii">  Une courte introduction sur ASCII </h3><br><p>  Cela peut sembler trop Ã©lÃ©mentaire, mais si nous voulons Ãªtre approfondis, nous devons couvrir toutes les bases. </p><br><p> <a href="https://habrahabr.ru/company/alconost/blog/480688/"><img src="https://habrastorage.org/webt/az/bt/mw/azbtmwjfkdtsfbvqd_ju-fibbwe.png"></a> </p><br><p>  Il y a 3 groupes de colonnes dans la table ASCII: </p><br><ul><li>  la valeur dÃ©cimale du caractÃ¨re </li><li>  la valeur hexadÃ©cimale du caractÃ¨re </li><li>  le glyphe du personnage lui-mÃªme </li></ul><br><p> Disons que nous voulons encoder le mot Â«okÂ» en ASCII.  La lettre Â«oÂ» a une valeur dÃ©cimale de 111 et 6F en hexadÃ©cimal.  En binaire, ce serait - 01101111. La lettre Â«kÂ» est la position 107 en dÃ©cimal et 6B en hexadÃ©cimal, ou - 01101011 en binaire.  Ainsi, le mot Â«OKÂ» en ASCII ressemblerait Ã  01101111 01101011. Le processus de dÃ©codage serait le contraire.  Nous commenÃ§ons par 8 bits, les traduisons en codage dÃ©cimal et nous nous retrouvons avec le numÃ©ro de caractÃ¨re, et recherchons dans le tableau le symbole correspondant. </p><br><h3 id="unicode">  Unicode </h3><br><p>  De ce qui prÃ©cÃ¨de, il devrait Ãªtre assez Ã©vident pourquoi une seule carte de personnage commune Ã©tait nÃ©cessaire.  Mais Ã  quoi cela ressemblerait-il?  La rÃ©ponse est Unicode qui n'est en fait pas un encodage, mais un jeu de caractÃ¨res.  Il se compose de 1114112 positions ou points de code, dont la plupart sont encore vides, il est donc peu probable que l'ensemble doive Ãªtre Ã©tendu. </p><br><p>  La norme Unicode se compose de 17 avions avec 65 536 points de code chacun.  Chaque avion contient un groupe de symboles.  Le plan zÃ©ro est le plan multilingue de base oÃ¹ l'on trouve les caractÃ¨res les plus couramment utilisÃ©s dans tous les alphabets modernes.  Le deuxiÃ¨me avion contient des caractÃ¨res de langues mortes.  Il y a mÃªme deux avions rÃ©servÃ©s Ã  un usage privÃ©.  La plupart des avions sont encore vides. </p><br><p>  Unicode a des points de code de 0 Ã  10FFFF (en hexadÃ©cimal). </p><br><p>  Les caractÃ¨res sont encodÃ©s au format hexadÃ©cimal prÃ©cÃ©dÃ© d'un "U +".  Ainsi, par exemple, le premier plan de base comprend les caractÃ¨res U + 0000 Ã  U + FFFF (0 Ã  65 535), et le bloc 17 contient U + 100000 Ã  U + 10FFFF (1 048 576 Ã  1 114 111). </p><br><p>  Alors maintenant, au lieu d'une mÃ©nagerie de nombreux encodages, nous avons un tableau complet qui encode tous les symboles et caractÃ¨res dont nous pourrions avoir besoin.  Mais ce n'est pas sans ses dÃ©fauts.  Alors que chaque caractÃ¨re Ã©tait prÃ©cÃ©demment codÃ© d'un octet, il peut dÃ©sormais Ãªtre codÃ© en utilisant diffÃ©rents nombres d'octets.  Par exemple, vous n'aviez besoin que d'un octet pour coder toutes les lettres de l'alphabet anglais.  Par exemple, la lettre latine Â«oÂ» en Unicode est U + 006F.  En d'autres termes, le mÃªme nombre qu'en ASCII - 6F en hexadÃ©cimal et 111 en binaire.  Mais pour coder le symbole Â«U + 103D5Â» (le nombre persan Â«100Â»), nous avons besoin de 103D5 en hexadÃ©cimal et de 66 517 en dÃ©cimal, et maintenant nous avons besoin de trois octets. </p><br><p>  Cette complexitÃ© doit Ãªtre traitÃ©e par de tels codages Unicode comme UTF-8 et UTF-16.  Et plus loin, nous les examinerons. </p><br><h3 id="utf-8">  Utf-8 </h3><br><p>  UTF-8 est un codage Unicode du systÃ¨me de codage Ã  largeur variable qui peut Ãªtre utilisÃ© pour afficher n'importe quel symbole Unicode. </p><br><p>  Que voulons-nous dire lorsque nous parlons de largeur variable?  Tout d'abord, nous devons comprendre que l'unitÃ© structurelle (atomique) dans le codage est un octet.  Le codage Ã  largeur variable signifie qu'un caractÃ¨re peut Ãªtre codÃ© en utilisant diffÃ©rents nombres d'unitÃ©s ou d'octets.  Par exemple, les lettres latines sont codÃ©es avec un octet et les lettres cyrilliques avec deux. </p><br><p>  Avant de poursuivre, un petit cÃ´tÃ© concernant la compatibilitÃ© entre ASCII et UTF. </p><br><p>  Le fait que les lettres latines et les caractÃ¨res de contrÃ´le clÃ©s tels que les sauts de ligne, les tabulations, etc.  contient un octet rend le codage UTF compatible avec ASCII.  En d'autres termes, les caractÃ¨res de script et de contrÃ´le latins se trouvent dans les mÃªmes points de code exacts en ASCII et UTF et sont codÃ©s en utilisant un octet dans les deux, et sont donc rÃ©trocompatibles. </p><br><p>  Utilisons la lettre Â«oÂ» de notre exemple ASCII plus tÃ´t.  Rappelons que sa position dans le tableau ASCII est 111, ou 01101111 en binaire.  Dans la table Unicode, c'est U + 006F, ou 01101111. Et maintenant, comme UTF est un systÃ¨me de codage Ã  largeur variable, Â«oÂ» serait un octet.  En d'autres termes, Â«oÂ» serait reprÃ©sentÃ© de la mÃªme maniÃ¨re dans les deux.  Et la mÃªme chose pour les caractÃ¨res 0 - 128. Donc, si votre document contient des lettres anglaises, vous ne remarquerez pas de diffÃ©rence si vous l'ouvrez en utilisant UTF-8, UTF-16 ou ASCII, et ne remarquerez une diffÃ©rence que si vous commencez Ã  travailler avec des codages nationaux. </p><br><p>  Voyons comment l'expression mixte anglais / russe Â«Hello worldÂ» apparaÃ®trait dans trois systÃ¨mes de codage diffÃ©rents: Windows-1251 (codage russe), ISO-8859-1 (systÃ¨me de codage pour les langues d'Europe occidentale), UTF-8 (Unicode) .  Cet exemple est rÃ©vÃ©lateur car nous avons une phrase dans deux langues diffÃ©rentes. </p><br><p> <a href="https://habrahabr.ru/company/alconost/blog/480688/"><img src="https://habrastorage.org/webt/3c/xa/rk/3cxarky4ifw35kpwa2fhcoslen8.jpeg"></a> </p><br><p>  Voyons maintenant comment ces systÃ¨mes de codage fonctionnent et comment nous pouvons traduire une ligne de texte d'un codage Ã  un autre, et ce qui se passe si les caractÃ¨res ne s'affichent pas correctement, ou si nous ne pouvons tout simplement pas le faire en raison des diffÃ©rences dans les systÃ¨mes. </p><br><p>  Supposons que notre phrase d'origine ait Ã©tÃ© Ã©crite avec l'encodage Windows-1251.  Lorsque nous regardons le tableau ci-dessus, nous pouvons voir en traduisant de dÃ©cimal ou hexadÃ©cimal en dÃ©cimal que nous obtenons le codage ci-dessous en binaire en utilisant Windows-1251. </p><br><p>  01001000 01100101 01101100 01101100 01101111 00100000 11101100 11101000 11110000 </p><br><p>  Nous avons donc maintenant l'expression Â«Bonjour tout le mondeÂ» dans l'encodage Windows-1251. </p><br><p>  Imaginez maintenant que nous avons un fichier texte mais nous ne savons pas dans quel systÃ¨me de codage le texte a Ã©tÃ© enregistrÃ©.  Nous supposons qu'il est codÃ© en ISO-8859-1 et l'ouvrons dans notre traitement de texte en utilisant ce systÃ¨me de codage.  Comme nous l'avons vu plus tÃ´t, certains caractÃ¨res apparaissent trÃ¨s bien, car ils existent dans ce systÃ¨me de codage, et sont mÃªme dans les mÃªmes points de code, mais les caractÃ¨res du mot russe "monde" ne fonctionnent pas aussi bien.  Ces caractÃ¨res n'existent pas dans le systÃ¨me de codage, et Ã  leur place, ou points de code, dans ISO-8859-1, nous trouvons des caractÃ¨res complÃ¨tement diffÃ©rents.  Donc, Â«mÂ» est le point de code 236, Â«etÂ» est 232, et Â«pÂ» est 240. Mais dans ISO-8859-1, ces points de code correspondent Ã  Â«Ã¬Â» (236), Â«Ã¨Â» (232) et Â« Ã° â€(240). </p><br><p>  Ainsi, notre phrase en langage mixte "Hello World" encodÃ©e dans Windows-1251 et lue dans ISO-8859-1 ressemblera Ã  "Hello Ã¬Ã¨Ã°".  Nous avons une compatibilitÃ© partielle et nous ne pouvons pas afficher correctement une phrase encodÃ©e dans un systÃ¨me dans l'autre, car les symboles dont nous avons besoin n'existent tout simplement pas dans le deuxiÃ¨me encodage. </p><br><p>  Nous avons besoin d'un encodage Unicode - dans notre cas, nous utiliserons UTF-8 comme exemple.  Nous avons dÃ©jÃ  expliquÃ© que les caractÃ¨res peuvent prendre entre 1 et 4 octets en UTF-8, mais un autre avantage est que UTF, contrairement aux deux systÃ¨mes de codage antÃ©rieurs, n'est pas limitÃ© Ã  256 symboles, mais contient tous les symboles du jeu de caractÃ¨res Unicode . </p><br><p>  Cela fonctionne comme ceci: le premier bit de chaque caractÃ¨re codÃ© correspond non pas au glyphe ou au symbole lui-mÃªme, mais Ã  un octet spÃ©cifique.  Donc, si le premier bit est nul, nous savons que le symbole codÃ© utilise un seul octet - ce qui rend l'ensemble rÃ©trocompatible avec ASCII.  Si nous regardons de prÃ¨s la table des symboles ASCII, nous voyons que les 128 premiers symboles (l'alphabet anglais, les caractÃ¨res de contrÃ´le et les signes de ponctuation) sont exprimÃ©s en binaire, ils commencent tous par une valeur binaire de 0 (notez que si vous traduisez des caractÃ¨res en binaire en utilisant un convertisseur en ligne ou quelque chose de similaire, le premier bit de poids fort zÃ©ro peut Ãªtre ignorÃ©, ce qui peut Ãªtre un peu dÃ©routant). </p><br><p>  01001000 - la valeur du premier bit est 0, donc 1 octet code 1 caractÃ¨re -&gt; "H". </p><br><p>  01100101 - la valeur du premier bit est 0, donc 1 octet code 1 caractÃ¨re-&gt; "e". </p><br><p>  Si la valeur du premier bit n'est pas nulle, le symbole sera codÃ© sur plusieurs octets. </p><br><p>  Un codage Ã  deux octets aura 110 pour les trois premiÃ¨res valeurs binaires. </p><br><p>  11010000 10111100 - les bits de marqueur sont 110 et 10, nous utilisons donc 2 octets pour coder 1 caractÃ¨re.  Dans ce cas, le deuxiÃ¨me octet commence toujours par Â«10.Â» Nous omettons donc les bits de contrÃ´le (les bits de tÃªte qui sont surlignÃ©s en rouge et vert) et regardons le reste du code (10000111100), et convertissons en hexadÃ©cimal (043) -&gt; U + 043C qui nous donne le "m" russe en Unicode. </p><br><p>  Les bits initiaux d'un caractÃ¨re Ã  trois octets sont 1110. </p><br><p>  11101000 10000111 101010101 - nous additionnons tous les bits sauf les bits de contrÃ´le et nous constatons que dans l'hex, nous avons 103B5, U + 103D5 - l'ancien nombre persan cent (10000001111010101). </p><br><p>  Les codages de caractÃ¨res Ã  quatre octets commencent par les bits de tÃªte 11110. </p><br><p>  11110100 10001111 10111111 10111111 - U + 10FFFF qui est le dernier caractÃ¨re disponible dans l'ensemble Unicode (1000011111111111111111111). </p><br><p>  Maintenant, nous pouvons facilement Ã©crire notre phrase multilingue en encodage UTF-8. </p><br><h3 id="utf-16">  Utf-16 </h3><br><p>  UTF-16 est un autre codage Ã  largeur variable.  La principale diffÃ©rence entre UTF-16 et UTF-8 est que UTF-16 utilise 2 octets (16 bits) par unitÃ© de code au lieu de 1 octet (8 bits).  En d'autres termes, tout caractÃ¨re Unicode codÃ© en UTF-16 peut Ãªtre de deux ou quatre octets.  Pour garder les choses simples, je ferai rÃ©fÃ©rence Ã  ces deux octets comme une unitÃ© de code.  Ainsi, en UTF-16, n'importe quel caractÃ¨re peut Ãªtre reprÃ©sentÃ© en utilisant une ou deux unitÃ©s de code. </p><br><p>  CommenÃ§ons par les symboles codÃ©s Ã  l'aide d'une unitÃ© de code.  Nous pouvons facilement calculer qu'il y a 65 535 (216) caractÃ¨res avec une unitÃ© de code, ce qui correspond complÃ¨tement au plan multilingue de base d'Unicode.  Tous les caractÃ¨res de ce plan seront reprÃ©sentÃ©s par une unitÃ© de code (deux octets) en UTF-16. </p><br><p>  Lettre latine Â«oÂ» - 00000000 01101111. </p><br><p>  Lettre cyrillique Â«MÂ» - 00000100 00011100. </p><br><p>  Examinons maintenant les caractÃ¨res en dehors du plan multilingue de base.  Ceux-ci nÃ©cessitent deux unitÃ©s de code (4 octets) et sont codÃ©s de maniÃ¨re lÃ©gÃ¨rement plus compliquÃ©e. </p><br><p>  Tout d'abord, nous devons dÃ©finir le concept d'une paire de substitution.  Une paire de substitution est deux unitÃ©s de code utilisÃ©es pour coder un seul caractÃ¨re (totalisant 4 octets).  Le jeu de caractÃ¨res Unicode rÃ©serve une plage spÃ©ciale D800 Ã  DFFF pour les paires de substitution.  Cela signifie que lors de la conversion d'une paire de substitution en octets en hexadÃ©cimal, nous nous retrouvons avec un point de code dans cette plage qui est une paire de substitution plutÃ´t qu'un caractÃ¨re sÃ©parÃ©. </p><br><p>  Pour coder un symbole dans la plage 10000 - 10FFFF (c'est-Ã -dire les caractÃ¨res qui nÃ©cessitent plus d'une unitÃ© de code), nous procÃ©dons comme suit: </p><br><ol><li><p>  Soustrayez 10000 (hex) du point de code (il s'agit du point de code le plus bas dans la plage 10000 - 10FFFF). </p><br></li><li><p>  On se retrouve avec un nombre jusqu'Ã  20 bits pas supÃ©rieur Ã  FFFF. </p><br></li><li><p>  Les 10 bits de poids fort avec lesquels nous nous retrouvons sont ajoutÃ©s au D800 (le point de code le plus bas de la plage de paires de substitution en Unicode). </p><br></li><li><p>  Les 10 bits suivants sont ajoutÃ©s au DC00 (Ã©galement de la plage de paires de substitution). </p><br></li><li><p>  Ensuite, nous nous retrouvons avec 2 unitÃ©s de code de substitution 16 bits, dont les 6 premiers bits dÃ©finissent l'unitÃ© comme faisant partie d'une paire de substitution. </p><br></li><li><p>  Le dixiÃ¨me bit de chaque substitut dÃ©finit l'ordre de la paire.  Si nous avons un Â«1Â», c'est le substitut principal ou Ã©levÃ©, et si nous avons un Â«0Â», c'est le substitut final ou faible. </p><br></li></ol><br><p>  Cela aura un peu plus de sens lorsqu'il est illustrÃ© avec l'exemple ci-dessous. </p><br><p>  Encodons puis dÃ©codons le nombre persan cent (U + 103D5): </p><br><ol><li><p>  103D5 - 10000 = 3D5. </p><br></li><li><p>  3D5 = 0000000000 1111010101 (les 10 bits les plus Ã©levÃ©s sont nuls, et lorsqu'ils sont convertis en hexadÃ©cimal, nous nous retrouvons avec Â«0Â» (les dix premiers) et 3D5 (les dix derniers)). </p><br></li><li><p>  0 + D800 = D800 (1101100000000000) les 6 premiers bits nous indiquent que ce point de code se situe dans la plage de la paire de substitution, le dixiÃ¨me bit (Ã  partir de la droite) a une valeur "0", il s'agit donc du substitut Ã©levÃ©. </p><br></li><li><p>  3D5 + DC00 = DFD5 (1101111111010101) les 6 premiers bits nous indiquent que ce point de code se situe dans la plage de la paire de substitution, le dixiÃ¨me bit (Ã  partir de la droite) est un "1", nous savons donc qu'il s'agit de la substitution la plus faible. </p><br></li><li><p>  Le caractÃ¨re rÃ©sultant codÃ© en UTF-16 ressemble Ã  - 1101100000000000 1101111111010101. </p><br></li></ol><br><p>  DÃ©codons maintenant le personnage.  Disons que nous avons le point de code suivant - 1101100000100010 1101111010001000: </p><br><ol><li><p>  Nous convertissons en hexadÃ©cimal = D822 DE88 (les deux points de code tombent dans la plage de la paire de substitution, nous savons donc que nous avons affaire Ã  une paire de substitution). </p><br></li><li><p>  1101100000100010 - le dixiÃ¨me bit (Ã  partir de la droite) est un "0", c'est donc le substitut Ã©levÃ©. </p><br></li><li><p>  1101111010001000 - le dixiÃ¨me bit (Ã  partir de la droite) est un "1", c'est donc le substitut bas. </p><br></li><li><p>  Nous ignorons les 6 bits identifiant cela comme un substitut et nous nous retrouvons avec 0000100010 1010001000 (8A88). </p><br></li><li><p>  Nous ajoutons 10000 (le point de code le plus bas dans la plage de substitution) 8A88 + 10000 = 18A88. </p><br></li><li><p>  Nous regardons la table Unicode pour U + 18A88 = Tangut Component-649. </p><br></li></ol><br><p>  Bravo Ã  tous ceux qui ont lu jusqu'ici! </p><br><p>  J'espÃ¨re que cela a Ã©tÃ© instructif sans vous laisser trop ennuyÃ©. </p><br><p>  <strong>Vous pourriez Ã©galement trouver utile:</strong> <strong><br></strong> <br>  <a href="https://unicode-table.com/en/">Le jeu de caractÃ¨res Unicode</a> </p><br><p>  <a href="https://habr.com/ru/company/alconost/blog/473960/">StratÃ©gies de localisation de contenu: basÃ©es sur IP ou sur navigateur</a> <a href="https://habr.com/ru/company/alconost/blog/473960/"><br></a> </p><br><h3 id="about-the-translator">  Ã€ propos du traducteur </h3><br><p>  <a href="https://alconost.com/en%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">Alconost</a> est un fournisseur mondial de services de <a href="https://alconost.com/en/services/software-localization%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">localisation pour les applications</a> , les <a href="https://alconost.com/en/services/game-localization%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">jeux</a> , les vidÃ©os et les <a href="https://alconost.com/en/services/website-translation%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">sites Web</a> dans plus de 70 langues.  Nous proposons des traductions par des linguistes natifs, des tests linguistiques, un workflow basÃ© sur le cloud, une localisation continue, une gestion de projet 24h / 24 et 7j / 7 et travaillons avec n'importe quel format de ressources de chaÃ®ne.  Nous rÃ©alisons Ã©galement des <a href="https://alconost.com/en/services/video-production%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">vidÃ©os</a> et des images publicitaires et Ã©ducatives, des teasers, des explications et des bandes-annonces pour Google Play et l'App Store. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480688/">https://habr.com/ru/post/fr480688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480672/index.html">Le paradoxe d'Einstein - Podolsky - Rosen sur les doigts et ... qu'est-ce que l'Ã©ther a Ã  voir avec Ã§a</a></li>
<li><a href="../fr480674/index.html">Test de serveurs virtuels de DigitalOcean, Vultr, Linode et Hetzner. Victimes humaines: 0,0</a></li>
<li><a href="../fr480680/index.html">StratÃ©gie de dÃ©fense NGINX et demande Ã  Igor Sysoev</a></li>
<li><a href="../fr480682/index.html">Intel RealSense LiDAR L515 - Un autre nouveau RealSense</a></li>
<li><a href="../fr480686/index.html">Pourquoi j'ai refusÃ© les solutions multiplateformes dans le dÃ©veloppement mobile</a></li>
<li><a href="../fr480692/index.html">MobX ou Redux: quel est le meilleur pour React State Management?</a></li>
<li><a href="../fr480700/index.html">Nous utilisons pleinement console.log () dans Chrome</a></li>
<li><a href="../fr480702/index.html">RH et talents, experts et crÃ©atifs: comment s'est passÃ© le huitiÃ¨me Habraseminar</a></li>
<li><a href="../fr480704/index.html">Rendre le chargement de contenu rÃ©actif sur le site</a></li>
<li><a href="../fr480708/index.html">Les dÃ©cennies touchent Ã  leur fin. Quelles applications sur Google Play ont Ã©tÃ© les plus tÃ©lÃ©chargÃ©es au cours des 10 derniÃ¨res annÃ©es?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>