<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèΩ ü§∑üèª üëåüèø Prise en charge de Visual Studio 2019 dans PVS-Studio üëê üßëüèæ‚Äçü§ù‚Äçüßëüèª üí°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La prise en charge de Visual Studio 2019 dans PVS-Studio a affect√© un certain nombre de composants: le plug-in lui-m√™me, l'analyseur de ligne de comma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prise en charge de Visual Studio 2019 dans PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/454736/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de3/aea/16e/de3aea16e3b6472a4d5034fd035d8827.png"></div><br>  La prise en charge de Visual Studio 2019 dans PVS-Studio a affect√© un certain nombre de composants: le plug-in lui-m√™me, l'analyseur de ligne de commande, les c≈ìurs des analyseurs C ++ et C # et quelques utilitaires.  Dans cet article, je vais expliquer bri√®vement quels probl√®mes nous avons rencontr√©s lors de la mise en ≈ìuvre du support de l'IDE et comment nous les avons r√©solus. <br><a name="habracut"></a><br>  Avant de commencer, je voudrais revenir sur l'histoire de la prise en charge des versions pr√©c√©dentes de Visual Studio dans PVS-Studio afin que vous compreniez mieux notre vision de la t√¢che et des solutions que nous avons trouv√©es dans chaque situation. <br><br>  Depuis la premi√®re version de PVS-Studio livr√©e avec un plugin pour Visual Studio (c'√©tait Visual Studio 2005 √† l'√©poque), la prise en charge de nouvelles versions de cet IDE a √©t√© une t√¢che assez banale pour nous, qui se r√©sumait essentiellement √† la mise √† jour du projet du plugin fichier et d√©pendances des diff√©rentes extensions d'API de Visual Studio.  De temps en temps, nous devions ajouter la prise en charge de nouvelles fonctionnalit√©s de C ++, que le compilateur Visual C ++ apprenait progressivement √† utiliser, mais ce n'√©tait g√©n√©ralement pas une t√¢che difficile non plus et pouvait √™tre facilement effectu√©e juste avant une nouvelle version de Visual Studio .  De plus, PVS-Studio n'avait √† l'√©poque qu'un seul analyseur - pour C / C ++. <br><br>  Les choses ont chang√© lorsque Visual Studio 2017 est sorti.  En plus d'√©normes modifications apport√©es √† de nombreuses extensions d'API de l'IDE, nous avons √©galement rencontr√© un probl√®me avec le maintien de la compatibilit√© descendante du nouvel analyseur C # ajout√© peu de temps auparavant (ainsi que de la nouvelle couche d'analyseur pour C ++ pour fonctionner avec les projets MSBuild) avec le nouvelles versions de MSBuild \ Visual Studio. <br><br>  Compte tenu de tout cela, je vous recommande fortement de consulter un article connexe sur la prise en charge de Visual Studio 2017, ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise en charge de Visual Studio 2017 et Roslyn 2.0 dans PVS-Studio: parfois, ce n'est pas si facile √† utiliser des solutions pr√™tes √† l'emploi, comme cela peut sembler</a> ", avant de poursuivre la lecture.  Cet article traite des probl√®mes que nous avons rencontr√©s la derni√®re fois et du mod√®le d'interaction entre diff√©rents composants (tels que PVS-Studio, MSBuild et Roslyn).  La connaissance de ces d√©tails peut vous aider √† mieux comprendre l'article actuel. <br><br>  La r√©solution de ces probl√®mes a finalement conduit √† des modifications importantes de l'analyseur, et nous esp√©rions que les nouvelles approches appliqu√©es alors nous aideraient √† prendre en charge les futures versions de Visual Studio \ MSBuild beaucoup plus facilement et plus rapidement.  Cet espoir a d√©j√† commenc√© √† se r√©v√©ler r√©aliste avec la sortie des nombreuses mises √† jour de Visual Studio 2017.  La nouvelle approche nous a-t-elle aid√© √† prendre en charge Visual Studio 2019?  Lisez la suite pour le d√©couvrir. <br><br><h2>  Plugin PVS-Studio pour Visual Studio 2019 </h2><br>  Le d√©but semblait prometteur.  Il ne nous a pas fallu beaucoup d'efforts pour porter le plugin sur Visual Studio 2019 et le faire d√©marrer et fonctionner correctement.  Mais nous avons d√©j√† rencontr√© deux probl√®mes √† la fois qui pourraient causer plus de probl√®mes plus tard. <br><br>  La premi√®re concernait l'interface <i>IVsSolutionWorkspaceService</i> utilis√©e pour prendre en charge le mode Lightweight Solution Load (qui, soit dit en passant, avait √©t√© d√©sactiv√© dans l'une des mises √† jour pr√©c√©dentes, de retour dans Visual Studio 2017).  Il √©tait d√©cor√© de l'attribut <i>obsol√®te</i> , qui ne d√©clenchait actuellement qu'un avertissement au moment de la construction mais allait devenir un gros probl√®me √† l'avenir.  Ce mode n'a pas dur√© longtemps en effet ... C'√©tait facile √† corriger - nous avons simplement arr√™t√© d'utiliser cette interface. <br><br>  Le deuxi√®me probl√®me √©tait le message suivant que nous recevions toujours lors du chargement de Visual Studio avec le plugin activ√©: <i>Visual Studio a d√©tect√© une ou plusieurs extensions √† risque ou ne fonctionnant pas dans une mise √† jour VS de fonctionnalit√©.</i> <br><br>  Les journaux des lancements de Visual Studio (le fichier ActivityLog) ont aid√© √† le clarifier: <br><br>  <i>Avertissement: l'extension ¬´PVS-Studio¬ª utilise la fonction ¬´chargement automatique synchrone¬ª de Visual Studio.</i>  <i>Cette fonctionnalit√© ne sera plus prise en charge dans une future mise √† jour de Visual Studio 2019, auquel cas cette extension ne fonctionnera pas.</i>  <i>Veuillez contacter le fournisseur d'extensions pour obtenir une mise √† jour.</i> <br><br>  Cela signifiait pour nous que nous devions passer du mode de chargement synchrone au mode de chargement asynchrone.  J'esp√®re que cela ne vous d√©rangera pas si je vous √©pargne les d√©tails de la fa√ßon dont nous interagissons avec les interfaces COM de Visual Studio, et ne d√©cris que bri√®vement les changements. <br><br>  Il y a un article de Microsoft sur le chargement des plugins de mani√®re asynchrone: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment: utiliser AsyncPackage pour charger des VSPackages en arri√®re-plan</a> ".  Il √©tait cependant d√©j√† clair qu'il y avait d'autres changements √† venir. <br><br>  L'un des changements les plus importants concernait le mode de chargement, ou plut√¥t le mode d'initialisation.  Dans les versions ant√©rieures, toute l'initialisation n√©cessaire √©tait effectu√©e √† l'aide de deux m√©thodes: <i>initialisation</i> de notre classe h√©ritant de <i>Package</i> et <i>OnShellPropertyChange</i> .  Ce dernier a d√ª √™tre ajout√© car lors du chargement synchrone, Visual Studio lui-m√™me pouvait encore √™tre en cours de chargement et d'initialisation, et, par cons√©quent, certaines des actions n√©cessaires √©taient impossibles √† effectuer pendant l'initialisation du plugin.  Une fa√ßon de r√©soudre ce probl√®me √©tait de retarder l'ex√©cution de ces actions jusqu'√† ce que Visual Studio quitte l'√©tat ¬´zombie¬ª.  C'est cette partie de la logique que nous avons distingu√©e dans la m√©thode <i>OnShellPropertyChange</i> avec une v√©rification du statut de ¬´zombie¬ª. <br><br>  La m√©thode <i>Initialize</i> de la classe abstraite <i>AsyncPackage</i> , dont les plugins de chargement asynchrones h√©ritent, est <i>scell√©e</i> , donc l'initialisation doit √™tre effectu√©e dans la m√©thode surcharg√©e <i>InitializeAsync</i> , qui est exactement ce que nous avons fait.  La logique de v√©rification des ¬´zombies¬ª a √©galement d√ª √™tre modifi√©e car les informations d'√©tat n'√©taient plus disponibles pour notre plugin.  En outre, nous devions toujours effectuer les actions qui devaient √™tre effectu√©es apr√®s l'initialisation du plugin.  Nous avons r√©solu cela en utilisant la m√©thode <i>OnPackageLoaded</i> de l'interface <i>IVsPackageLoadEvents</i> , qui est l'endroit o√π ces actions diff√©r√©es ont √©t√© effectu√©es. <br><br>  Un autre probl√®me r√©sultant de la charge asynchrone √©tait que les commandes du plugin ne pouvaient pas √™tre utilis√©es avant le chargement de Visual Studio.  L'ouverture du journal de l'analyseur en double-cliquant dans le gestionnaire de fichiers (si vous aviez besoin de l'ouvrir √† partir de Visual Studio) a entra√Æn√© le lancement de la version correspondante de devenv.exe avec une commande d'ouverture du journal.  La commande de lancement ressemblait √† ceci: <br><br><pre><code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\Common7\IDE\devenv.exe"</span></span> /command <span class="hljs-string"><span class="hljs-string">"PVSStudio.OpenAnalysisReport C:\Users\vasiliev\source\repos\ConsoleApp\ConsoleApp.plog"</span></span></code> </pre> <br>  L'indicateur "/ command" est utilis√© ici pour ex√©cuter la commande enregistr√©e dans Visual Studio.  Cette approche ne fonctionnait plus puisque les commandes n'√©taient plus disponibles avant le chargement du plugin.  La solution de contournement que nous avons trouv√©e consistait √† analyser la commande de lancement devenv.exe apr√®s le chargement du plug-in et √† ex√©cuter la commande log open si elle se trouve dans la commande de lancement.  Ainsi, rejeter l'id√©e d'utiliser l'interface "appropri√©e" pour travailler avec des commandes nous a permis de conserver les fonctionnalit√©s n√©cessaires, avec une ouverture retard√©e du journal apr√®s le chargement complet du plugin. <br><br>  Ouf, on dirait que nous l'avons enfin fait;  le plugin se charge et s'ouvre comme pr√©vu, sans aucun avertissement. <br><br>  Et voici quand les choses tournent mal.  Paul (Salut Paul!) Installe le plugin sur son ordinateur et demande pourquoi nous ne sommes toujours pas pass√©s en charge asynchrone. <br><br>  Dire que nous avons √©t√© choqu√©s serait un euph√©misme.  √áa ne pouvait pas √™tre √ßa!  Mais c'est r√©el: voici la nouvelle version du plugin, et voici un message disant que le package se charge de mani√®re synchrone.  Alexander (Salut Alexander!) Et j'essaie la m√™me version sur nos ordinateurs respectifs - cela fonctionne tr√®s bien.  Comment est-ce possible?  Ensuite, il nous vient √† l'esprit de v√©rifier les versions des biblioth√®ques PVS-Studio charg√©es dans Visual Studio - et nous constatons que ce sont les biblioth√®ques pour Visual Studio 2017, tandis que le package VSIX contient les nouvelles versions, c'est-√†-dire pour Visual Studio 2019. <br><br>  Apr√®s avoir bricol√© avec VSIXInstaller pendant un certain temps, nous avons r√©ussi √† d√©couvrir que le probl√®me √©tait li√© au cache des packages.  Cette th√©orie a √©galement √©t√© appuy√©e par le fait que la restriction d'acc√®s au package mis en cache (C: \ ProgramData \ Microsoft \ VisualStudio \ Packages) provoqu√©e par VSIXInstaller pour afficher un message d'erreur dans le journal.  Curieusement, lorsque l'erreur ne s'est pas produite, les informations sur l'installation des packages mis en cache n'apparaissent pas. <br><br>  <b>Note de c√¥t√©</b> .  En √©tudiant le comportement de VSIX Installer et des biblioth√®ques qui l'accompagnent, j'ai pens√© √† quel point il est cool que Roslyn et MSBuild soient open-source, ce qui vous permet de lire et de d√©boguer facilement leur code et de suivre sa logique de travail. <br><br>  Donc, c'est ce qui s'est pass√©: lors de l'installation du plugin, le programme d'installation de VSIX a vu que le package correspondant √©tait d√©j√† mis en cache (il s'agissait en fait du package .vsix pour Visual Studio 2017) et a install√© ce package au lieu du nouveau.  Pourquoi il a ignor√© les restrictions / exigences d√©finies dans le fichier .vsixmanifest (qui, entre autres, restreint l'installation d'extensions √† une version sp√©cifique de Visual Studio) est une question √† laquelle il reste √† r√©pondre.  En cons√©quence, le plug-in con√ßu pour Visual Studio 2017 a √©t√© install√© sur Visual Studio 2019 - malgr√© les restrictions sp√©cifi√©es dans le fichier .vsixmanifest. <br><br>  Pire encore, cette installation a bris√© le graphique des d√©pendances de Visual Studio, et bien que l'EDI semble bien fonctionner, les choses √©taient en fait terribles.  Vous ne pouvez pas installer ou supprimer des extensions, des mises √† jour, etc.  Le processus de "restauration" a √©galement √©t√© p√©nible car nous avons d√ª supprimer l'extension (c'est-√†-dire les fichiers qui la contiennent) manuellement et - √©galement manuellement - √©diter les fichiers de configuration stockant les informations sur le package install√©.  En d'autres termes, ce n'√©tait pas amusant du tout. <br><br>  Pour r√©soudre ce probl√®me et nous assurer que nous ne rencontrerons pas de telles situations √† l'avenir, nous avons d√©cid√© de cr√©er notre propre GUID pour le nouveau package afin que les packages pour Visual Studio 2017 et Visual Studio 2019 soient isol√©s les uns des autres en toute s√©curit√© ( les anciens paquets √©taient bien, ils avaient toujours utilis√© un GUID partag√©). <br><br>  Depuis que nous avons commenc√© √† parler de mauvaises surprises, en voici une autre: apr√®s la mise √† jour vers l'aper√ßu 2, le menu PVS-Studio "s'est d√©plac√©" vers l'onglet "Extensions".  Pas tr√®s grave, mais cela rendait l'acc√®s aux fonctionnalit√©s du plugin moins pratique.  Ce comportement a persist√© dans les prochaines versions de Visual Studio 2019, y compris la version.  Je n'ai trouv√© de mention de cette "fonctionnalit√©" ni dans la documentation ni dans le blog. <br><br>  D'accord, maintenant les choses allaient bien et nous semblions avoir enfin fini avec le support de Visual Studio 2019.  Cela s'est av√©r√© faux le lendemain apr√®s la sortie de PVS-Studio 7.02.  C'√©tait √† nouveau le mode de chargement asynchrone.  Lors de l'ouverture de la fen√™tre des r√©sultats d'analyse (ou du d√©marrage de l'analyse), la fen√™tre de l'analyseur appara√Ætrait "vide" pour l'utilisateur - pas de boutons, pas de grille, rien du tout. <br><br>  Ce probl√®me s'est en fait produit de temps en temps au cours de l'analyse.  Mais cela n'a affect√© qu'un seul ordinateur et n'est pas apparu avant la mise √† jour de Visual Studio vers l'une des premi√®res it√©rations de ¬´Aper√ßu¬ª.  Nous soup√ßonnions que quelque chose s'√©tait cass√© pendant l'installation ou la mise √† jour.  Le probl√®me, cependant, a disparu quelque temps plus tard et ne se produirait m√™me pas sur cet ordinateur particulier, nous avons donc pens√© qu'il "s'est r√©gl√© tout seul".  Mais non - nous avons juste eu de la chance.  Ou malchanceux d'ailleurs. <br><br>  Comme nous l'avons d√©couvert, c'√©tait l'ordre dans lequel la fen√™tre IDE elle-m√™me (la classe d√©riv√©e de <i>ToolWindowPane</i> ) et son contenu (notre contr√¥le avec la grille et les boutons) √©taient initialis√©s.  Dans certaines conditions, le contr√¥le serait initialis√© avant le volet et m√™me si les choses fonctionnaient bien et que la m√©thode <i>FindToolWindowAsync</i> (cr√©ant la fen√™tre lors de son premier acc√®s) faisait bien son travail, le contr√¥le restait invisible.  Nous avons corrig√© cela en ajoutant une initialisation paresseuse pour notre contr√¥le au code de remplissage de volet. <br><br><h2>  Prise en charge de C # 8.0 </h2><br>  Il y a un grand avantage √† utiliser Roslyn comme base pour l'analyseur: vous n'avez pas √† ajouter manuellement la prise en charge des nouvelles constructions de langage - cela se fait automatiquement via les biblioth√®ques Microsoft. Code Analysis, et nous utilisons simplement les solutions pr√™tes √† l'emploi.  Cela signifie que la nouvelle syntaxe est prise en charge en mettant simplement √† jour les biblioth√®ques. <br><br>  Quant √† l'analyse elle-m√™me, nous avons d√ª modifier les choses par nous-m√™mes, bien s√ªr - en particulier, g√©rer de nouvelles constructions de langage.  Bien s√ªr, le nouvel arbre de syntaxe a √©t√© g√©n√©r√© automatiquement en mettant simplement √† jour Roslyn, mais nous avons encore d√ª enseigner √† l'analyseur comment interpr√©ter et traiter exactement les n≈ìuds d'arbre de syntaxe nouveaux ou modifi√©s. <br><br>  Les types de r√©f√©rence nullables sont peut-√™tre la nouvelle fonctionnalit√© la plus largement discut√©e de C # 8. Je ne vais pas en parler maintenant, car un sujet aussi important m√©rite un article s√©par√© (qui est actuellement en cours d'√©criture).  Pour l'instant, nous avons d√©cid√© d'ignorer les annotations annulables dans notre m√©canisme de flux de donn√©es (c'est-√†-dire que nous les comprenons, les analysons et les ignorons).  L'id√©e est qu'une variable, m√™me d'un type de r√©f√©rence non nullable, peut toujours √™tre assez facilement (ou accidentellement) affect√©e √† la valeur <i>null</i> , se terminant par un NRE lors d'une tentative de d√©r√©f√©rencement.  Notre analyseur peut d√©tecter de telles erreurs et signaler une √©ventuelle d√©r√©f√©rence nulle (s'il trouve une telle affectation dans le code, bien s√ªr) m√™me si la variable est de type r√©f√©rence non nullable. <br><br>  L'utilisation de types de r√©f√©rence nullables et de la syntaxe associ√©e vous permet d'√©crire du code assez int√©ressant.  Nous l'avons surnomm√© ¬´syntaxe √©motionnelle¬ª.  Cet extrait est parfaitement compilable: <br><br><pre> <code class="cpp hljs">obj.Calculate(); obj?.Calculate(); obj.Calculate(); obj!?.Calculate(); obj!!!.Calculate();</code> </pre> <br>  Au fait, mes exp√©riences m'ont amen√© √† d√©couvrir quelques astuces que vous pouvez utiliser pour "planter" Visual Studio en utilisant la nouvelle syntaxe.  Ils sont bas√©s sur le fait que vous √™tes autoris√© √† √©crire autant de '!'  personnages comme vous le souhaitez.  Cela signifie que vous pouvez √©crire non seulement du code comme celui-ci: <br><br><pre> <code class="cpp hljs">object temp = null!</code> </pre> <br>  mais aussi comme √ßa: <br><br><pre> <code class="cpp hljs">object temp = null!!!;</code> </pre> <br>  Et, en poussant encore plus loin, vous pourriez √©crire des choses folles comme ceci: <br><br><pre> <code class="cpp hljs">object temp = null!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!;</code> </pre> <br>  Ce code est compilable, mais si vous essayez d'afficher l'arborescence de syntaxe dans Syntax Visualizer √† partir du SDK de la plate-forme du compilateur .NET, Visual Studio se bloque. <br><br>  Le rapport d'√©chec peut √™tre extrait de l'Observateur d'√©v√©nements: <br><br><pre> <code class="cpp hljs">Faulting application name: devenv.exe, version: <span class="hljs-number"><span class="hljs-number">16.0</span></span><span class="hljs-number"><span class="hljs-number">.28803</span></span><span class="hljs-number"><span class="hljs-number">.352</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5cc37012</span></span> Faulting <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> name: WindowsBase.ni.dll, version: <span class="hljs-number"><span class="hljs-number">4.8</span></span><span class="hljs-number"><span class="hljs-number">.3745</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5c5bab63</span></span> Exception code: <span class="hljs-number"><span class="hljs-number">0xc00000fd</span></span> Fault offset: <span class="hljs-number"><span class="hljs-number">0x000c9af4</span></span> Faulting process id: <span class="hljs-number"><span class="hljs-number">0x3274</span></span> Faulting application start time: <span class="hljs-number"><span class="hljs-number">0x01d5095e7259362e</span></span> Faulting application path: C:\<span class="hljs-function"><span class="hljs-function">Program </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Files</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x86)</span></span></span><span class="hljs-function">\ Microsoft Visual Studio\2019\Community\Common7\IDE\devenv.exe Faulting </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">module</span></span></span><span class="hljs-function"> path: C:\WINDOWS\assembly\NativeImages_v4.0.30319_32\ WindowsBase\4480dfedf0d7b4329838f4bbf953027d\WindowsBase.ni.dll Report Id: 66d41eb2-c658-486d-b417-02961d9c3e4f Faulting package full name: Faulting package-relative application ID:</span></span></code> </pre> <br>  Si vous devenez encore plus fou et ajoutez plusieurs fois plus de points d'exclamation, Visual Studio commencera √† se bloquer tout seul, sans l'aide de Syntax Visualizer.  Les biblioth√®ques Microsoft.CodeAnalysis et le compilateur csc.exe ne peuvent pas non plus g√©rer ce code. <br><br>  Ces exemples sont artificiels, bien s√ªr, mais j'ai trouv√© cette astuce dr√¥le. <br><br><h2>  Jeu d'outils </h2><br>  Il √©tait √©vident que la mise √† jour de l'ensemble d'outils serait la partie la plus difficile.  C'est du moins ce √† quoi cela ressemblait au d√©but, mais maintenant j'ai tendance √† penser que le support du plugin √©tait la partie la plus difficile.  D'une part, nous avions d√©j√† un ensemble d'outils et un m√©canisme pour √©valuer les projets MSBuild, ce qui √©tait bien car il √©tait encore √† √©tendre.  Le fait que nous n'ayons pas d√ª √©crire les algorithmes √† partir de z√©ro a rendu la t√¢che beaucoup plus facile.  La strat√©gie consistant √† s'appuyer sur ¬´notre¬ª jeu d'outils, √† laquelle nous avons pr√©f√©r√© nous tenir lors de la prise en charge de Visual Studio 2017, s'est une fois de plus av√©r√©e correcte. <br><br>  Traditionnellement, le processus commence par la mise √† jour des packages NuGet.  L'onglet de gestion des packages NuGet pour la solution actuelle contient le bouton "Mettre √† jour" ... mais cela n'aide pas.  La mise √† jour de tous les packages √† la fois a provoqu√© plusieurs conflits de versions et essayer de les r√©soudre tous ne semblait pas une bonne id√©e.  Un moyen plus douloureux mais sans doute plus s√ªr √©tait de mettre √† jour de mani√®re s√©lective les packages cibles de Microsoft.Build / Microsoft.CodeAnalysis. <br><br>  Une diff√©rence a √©t√© imm√©diatement d√©tect√©e lors du test des diagnostics: la structure de l'arbre de syntaxe a chang√© sur un n≈ìud existant.  Pas un gros probl√®me;  nous avons corrig√© cela rapidement. <br><br>  Je vous rappelle que nous testons nos analyseurs (pour C #, C ++, Java) sur des projets open-source.  Cela nous permet de tester minutieusement les diagnostics - par exemple, de les v√©rifier pour les faux positifs ou de voir si nous avons rat√© des cas (pour r√©duire le nombre de faux n√©gatifs).  Ces tests nous aident √©galement √† tracer une √©ventuelle r√©gression √† l'√©tape initiale de la mise √† jour des biblioth√®ques / outils.  Cette fois, ils ont √©galement d√©tect√© un certain nombre de probl√®mes. <br><br>  L'une √©tait que le comportement √† l'int√©rieur des biblioth√®ques CodeAnalysis s'√©tait aggrav√©.  Plus pr√©cis√©ment, lors de la v√©rification de certains projets, nous avons commenc√© √† obtenir des exceptions du code des biblioth√®ques sur diverses op√©rations telles que l'obtention d'informations s√©mantiques, l'ouverture de projets, etc. <br><br>  Ceux d'entre vous qui ont lu attentivement l'article sur la prise en charge de Visual Studio 2017 se souviennent que notre distribution est livr√©e avec un mannequin - le fichier MSBuild.exe de 0 octet. <br><br>  Nous devions maintenant pousser cette pratique encore plus loin et inclure des variables muettes vides pour les compilateurs csc.exe, vbc.exe et VBCSCompiler.exe.  Pourquoi?  Nous avons trouv√© cette solution apr√®s avoir analys√© l'un des projets de notre base de test et obtenu des rapports de diff: la nouvelle version de l'analyseur ne produirait pas certains des avertissements attendus. <br><br>  Nous avons constat√© qu'il s'agissait de symboles de compilation conditionnelle, dont certains n'√©taient pas extraits correctement lors de l'utilisation de la nouvelle version de l'analyseur.  Afin d'aller √† la racine du probl√®me, nous avons d√ª approfondir le code des biblioth√®ques de Roslyn. <br><br>  Les symboles de compilation conditionnelle sont analys√©s √† l'aide de la m√©thode <i>GetDefineConstantsSwitch</i> de la classe <i>Csc</i> de la biblioth√®que <i>Microsoft.Build.Tasks.CodeAnalysis</i> .  L'analyse est effectu√©e √† l'aide de la m√©thode <i>String.Split</i> sur un certain nombre de s√©parateurs: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] allIdentifiers = originalDefineConstants.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">','</span></span>, <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span> });</code> </pre> <br>  Ce m√©canisme d'analyse fonctionne parfaitement;  tous les symboles de compilation conditionnelle sont extraits correctement.  D'accord, continuons √† creuser. <br><br>  Le point cl√© suivant a √©t√© l'appel de la m√©thode <i>ComputePathToTool</i> de la classe <i>ToolTask</i> .  Cette m√©thode calcule le chemin d'acc√®s au fichier ex√©cutable ( <i>csc.exe</i> ) et v√©rifie s'il s'y trouve.  Si tel est le cas, la m√©thode renvoie le chemin d'acc√®s ou <i>null</i> sinon. <br><br>  Le code appelant: <br><br><pre> <code class="cpp hljs">.... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> pathToTool = ComputePathToTool(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTool == null) { <span class="hljs-comment"><span class="hljs-comment">// An appropriate error should have been logged already. return false; } ....</span></span></code> </pre> <br>  Puisqu'il n'y a pas de fichier <i>csc.exe</i> (pourquoi en avons-nous besoin?), <i>PathToTool</i> re√ßoit la valeur <i>null</i> √† ce stade et la m√©thode actuelle ( <i>ToolTask.Execute</i> ) renvoie <i>false</i> .  Les r√©sultats de l'ex√©cution de la t√¢che, y compris les symboles de compilation conditionnelle extraits, sont ignor√©s. <br><br>  Bon, voyons ce qui se passe si nous pla√ßons le fichier <i>csc.exe</i> o√π il devrait se trouver. <br><br>  <i>PathToTool</i> stocke maintenant le chemin r√©el vers le fichier maintenant pr√©sent et <i>ToolTask.Execute</i> continue de s'ex√©cuter.  Le point cl√© suivant est l'appel de la m√©thode <i>ManagedCompiler.ExecuteTool</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteTool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathToTool, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> responseFileCommands, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> commandLineCommands)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ProvideCommandLineArgs) { CommandLineArgs = GetArguments(commandLineCommands, responseFileCommands) .Select(arg =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskItem(arg)).ToArray(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SkipCompilerExecution) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } .... }</code> </pre> <br>  La propri√©t√© <i>SkipCompilerExecution</i> est <i>vraie</i> (assez logiquement puisque nous ne compilons pas pour de vrai).  La m√©thode appelante ( <i>ToolTask.Execute</i> d√©j√† mentionn√©e) v√©rifie si la valeur de retour pour <i>ExecuteTool</i> est 0 et, si tel est le cas, renvoie <i>true</i> .  Que votre <i>csc.exe</i> soit un v√©ritable compilateur ou "War and Peace" de Leo Tolstoy n'a pas d'importance du tout. <br><br>  Ainsi, le probl√®me est li√© √† l'ordre dans lequel les √©tapes ont √©t√© d√©finies: <br><br><ul><li>  v√©rifier le compilateur; </li><li>  v√©rifier si le compilateur doit √™tre lanc√©; </li></ul><br>  Et nous nous attendrions √† un ordre inverse.  C'est pour corriger cela que les mannequins des compilateurs ont √©t√© ajout√©s. <br><br>  D'accord, mais comment avons-nous r√©ussi √† obtenir des symboles de compilation, avec le fichier csc.exe absent (et les r√©sultats de la t√¢che ignor√©s)? <br><br>  Eh bien, il existe √©galement une m√©thode pour ce cas: <i>CSharpCommandLineParser.ParseConditionalCompilationSymbols</i> de la biblioth√®que <i>Microsoft.CodeAnalysis.CSharp</i> .  Il effectue √©galement l'analyse en appelant la m√©thode <i>String.Split</i> sur un certain nombre de s√©parateurs: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] values = value.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">','</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*, StringSplitOptions.RemoveEmptyEntries*/</span></span>);</code> </pre> <br>  Vous voyez comment cet ensemble de s√©parateurs est diff√©rent de celui g√©r√© par la m√©thode <i>Csc.GetDefineConstantsSwitch</i> ?  Ici, un espace n'est pas un s√©parateur.  Cela signifie que les symboles de compilation conditionnelle s√©par√©s par des espaces ne seront pas analys√©s correctement par cette m√©thode. <br><br>  C'est ce qui s'est produit lorsque nous avons v√©rifi√© les projets probl√©matiques: ils ont utilis√© des symboles de compilation conditionnelle s√©par√©s par des espaces et ont donc √©t√© analys√©s avec succ√®s par la m√©thode <i>GetDefineConstantsSwitch</i> mais pas la m√©thode <i>ParseConditionalCompilationSymbols</i> . <br><br>  Un autre probl√®me qui est apparu apr√®s la mise √† jour des biblioth√®ques √©tait un comportement cass√© dans certains cas - en particulier sur les projets qui ne se sont pas construits.  Il a affect√© les biblioth√®ques Microsoft. <i>Code Analysis</i> et s'est manifest√© sous la forme d'exceptions de toutes sortes: <i>ArgumentNullException</i> (√©chec de l'initialisation d'un enregistreur interne), <i>NullReferenceException</i> , etc. <br><br>  Je voudrais vous parler d'une erreur particuli√®re que j'ai trouv√©e assez int√©ressante. <br><br>  Nous l'avons rencontr√© lors de la v√©rification de la nouvelle version du projet Roslyn: l'une des biblioth√®ques lan√ßait une <i>NullReferenceException</i> .  Gr√¢ce √† des informations d√©taill√©es sur sa source, nous avons rapidement trouv√© le code source du probl√®me et - juste pour la curiosit√© - nous avons d√©cid√© de v√©rifier si l'erreur persisterait lors du travail dans Visual Studio. <br><br>  Nous avons r√©ussi √† le reproduire dans Visual Studio (version 16.0.3).  Pour ce faire, vous avez besoin d'une d√©finition de classe comme celle-ci: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class">&lt;T1, T2&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T1 val = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val is null) { } } }</code> </pre> <br>  Vous aurez √©galement besoin du visualiseur de syntaxe (il est fourni avec le SDK de la plate-forme du compilateur .NET).  Recherchez le <i>TypeSymbol</i> (en cliquant sur l'√©l√©ment de menu "Afficher TypeSymbol (le cas √©ch√©ant)") du n≈ìud d'arborescence de syntaxe de type <i>ConstantPatternSyntax</i> ( <i>null</i> ).  Visual Studio va red√©marrer et les informations d'exception - en particulier, la trace de la pile - seront disponibles dans l'Observateur d'√©v√©nements: <br><br><pre> <code class="cpp hljs">Application: devenv.exe Framework Version: v4<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span> Description: The process was terminated due to an unhandled exception. Exception Info: System.NullReferenceException at Microsoft.CodeAnalysis.CSharp.ConversionsBase. ClassifyImplicitBuiltInConversionSlow( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet<span class="hljs-string"><span class="hljs-string">'1 &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyBuiltInConversion( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet'</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoForNode( Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode) at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo( Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) ....</code> </pre> <br>  Comme vous pouvez le voir, le probl√®me est d√ª √† une d√©r√©f√©rence de r√©f√©rence nulle. <br><br>  Comme je l'ai d√©j√† mentionn√©, nous avons rencontr√© un probl√®me similaire lors du test de l'analyseur.  Si vous le construisez √† l'aide de biblioth√®ques de d√©bogage de Microsoft. <i>Analyse de code</i> , vous pouvez acc√©der directement √† l'emplacement du probl√®me en recherchant le <i>TypeSymbol</i> du n≈ìud d'arborescence de syntaxe correspondant. <br><br>  Cela nous m√®nera finalement √† la m√©thode <i>ClassifyImplicitBuiltInConversionSlow</i> mentionn√©e dans la trace de pile ci-dessus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Conversion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeSymbol source, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert((object)source != null); Debug.Assert((object)destination != null); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.SpecialType == SpecialType.System_Void || destination.SpecialType == SpecialType.System_Void) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; } Conversion conversion = ClassifyStandardImplicitConversion(source, destination, ref useSiteDiagnostics); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conversion.Exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversion; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; }</code> </pre> <br>  Ici, le param√®tre de <i>destination</i> est <i>nul</i> , donc l'appel √† <i>destination.SpecialType</i> entra√Æne la <i>lev√©e d'</i> une <i>NullReferenceException</i> .  Oui, l'op√©ration de d√©r√©f√©rencement est pr√©c√©d√©e de <i>Debug.Assert</i> , mais elle n'aide pas car en fait elle ne prot√®ge de rien - elle vous permet simplement de rep√©rer le probl√®me dans les versions de d√©bogage des biblioth√®ques.  Ou ce n'est pas le cas. <br><br><h3>  Modifications du m√©canisme d'√©valuation des projets C ++ </h3><br>  Il n'y avait pas grand-chose d'int√©ressant dans cette partie: les algorithmes existants ne n√©cessitaient pas de grandes modifications √† noter, mais vous voudrez peut-√™tre conna√Ætre deux probl√®mes mineurs. <br><br>  La premi√®re √©tait que nous devions modifier les algorithmes qui s'appuyaient sur la valeur num√©rique de ToolsVersion.  Sans entrer dans les d√©tails, il existe certains cas o√π vous devez comparer des ensembles d'outils et choisir, par exemple, la version la plus r√©cente.  La nouvelle version a naturellement une valeur plus √©lev√©e.  Nous nous attendions √† ce que ToolsVersion pour le nouveau MSBuild / Visual Studio ait la valeur 16.0.  Ouais, bien s√ªr!  Le tableau ci-dessous montre comment les valeurs des diff√©rentes propri√©t√©s ont chang√© tout au long de l'historique de d√©veloppement de Visual Studio: <br><div class="scrollable-table"><table><tbody><tr><td>  Nom du produit Visual Studio <br></td><td>  Num√©ro de version de Visual Studio <br></td><td>  Version des outils <br></td><td>  Version PlatformToolset <br></td></tr><tr><td>  Visual studio 2010 <br></td><td>  10,0 <br></td><td>  4,0 <br></td><td>  100 <br></td></tr><tr><td>  Visual studio 2012 <br></td><td>  11,0 <br></td><td>  4,0 <br></td><td>  110 <br></td></tr><tr><td>  Visual studio 2013 <br></td><td>  12,0 <br></td><td>  12,0 <br></td><td>  120 <br></td></tr><tr><td>  Visual studio 2015 <br></td><td>  14,0 <br></td><td>  14,0 <br></td><td>  140 <br></td></tr><tr><td>  Visual studio 2017 <br></td><td>  15,0 <br></td><td>  15,0 <br></td><td>  141 <br></td></tr><tr><td>  Visual studio 2019 <br></td><td>  16,0 <br></td><td>  Courant <br></td><td>  142 <br></td></tr></tbody></table></div><br>  Je sais que la blague sur les num√©ros de version foir√©s de Windows et Xbox est ancienne, mais elle prouve que vous ne pouvez pas faire de pr√©dictions fiables sur les valeurs (que ce soit dans le nom ou la version) des futurs produits Microsoft.  :) <br><br>  Nous avons r√©solu cela facilement en ajoutant la hi√©rarchisation des ensembles d'outils (c.-√†-d. En distinguant la priorit√© en tant qu'entit√© distincte). <br><br>  Le deuxi√®me probl√®me concernait des probl√®mes de travail dans Visual Studio 2017 ou dans un environnement associ√© (par exemple, lorsque la variable d'environnement <i>VisualStudioVersion</i> est d√©finie).  Cela se produit car le calcul des param√®tres n√©cessaires √† l'√©valuation d'un projet C ++ est une t√¢che beaucoup plus difficile que l'√©valuation d'un projet .NET.  Pour .NET, nous utilisons notre propre ensemble d'outils et la valeur correspondante de ToolsVersion.  Pour C ++, nous pouvons utiliser √† la fois notre propre ensemble d'outils et ceux fournis par le syst√®me.  √Ä partir de Build Tools pour Visual Studio 2017, les jeux d'outils sont d√©finis dans le fichier <i>MSBuild.exe.config</i> au lieu du registre.  C'est pourquoi nous ne pouvions plus les obtenir √† partir de la liste globale des jeux d'outils (√† l'aide de <i>Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.Toolsets</i> , par exemple) contrairement √† ceux d√©finis dans le registre (c'est-√†-dire pour Visual Studio 2015 et versions ant√©rieures). <br><br>  Tout cela nous emp√™che d'√©valuer un projet √† l'aide de <i>ToolsVersion 15.0</i> car le syst√®me ne verra pas le jeu d'outils requis.  Le jeu d'outils le plus r√©cent, <i>Current</i> , sera toujours disponible car il s'agit de notre propre jeu d'outils, et, par cons√©quent, il n'y a pas un tel probl√®me dans Visual Studio 2019. La solution √©tait assez simple et nous a permis de r√©soudre cela sans changer les algorithmes d'√©valuation existants: nous venons de a d√ª inclure un autre jeu d'outils, <i>15.0</i> , dans la liste de nos propres jeux d'outils en plus de <i>Current</i> . <br><br><h3>  Modifications du m√©canisme d'√©valuation des projets C # .NET Core </h3><br>  Cette t√¢che impliquait deux probl√®mes interd√©pendants: <br><br><ul><li>  l'ajout de l'ensemble d'outils ¬´actuel¬ª a interrompu l'analyse des projets .NET Core dans Visual Studio 2017; </li><li>  l'analyse ne fonctionnerait pas pour les projets .NET Core sur les syst√®mes sans au moins une copie de Visual Studio install√©e. </li></ul><br>  Les deux probl√®mes provenaient de la m√™me source: certains des fichiers de base .targets / .props √©taient recherch√©s sur des chemins incorrects.  Cela nous a emp√™ch√©s d'√©valuer un projet √† l'aide de notre ensemble d'outils. <br><br>  Si vous n'aviez aucune instance de Visual Studio install√©e, vous obtiendrez l'erreur suivante (avec la version pr√©c√©dente de l'ensemble d'outils, <i>15.0</i> ): <br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Windows\Microsoft.NET\Framework64\ 15.0\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found.</code> </pre> <br>  Lors de l'√©valuation d'un projet C # .NET Core dans Visual Studio 2017, vous obtenez l'erreur suivante (avec la version actuelle du jeu d'outils, <i>Current</i> ): <br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\MSBuild\Current\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found. ....</code> </pre> <br>  Comme ces probl√®mes sont similaires (ce qu'ils semblent √™tre), nous pourrions essayer de tuer deux oiseaux avec une pierre. <br><br>  Dans les paragraphes suivants, j'expliquerai comment nous y sommes parvenus, sans entrer dans les d√©tails.  Ces d√©tails (sur la fa√ßon dont les projets C # .NET Core sont √©valu√©s ainsi que les modifications apport√©es au m√©canisme d'√©valuation dans notre ensemble d'outils) seront le sujet de l'un de nos futurs articles.  Soit dit en passant, si vous lisiez attentivement cet article, vous avez probablement remarqu√© qu'il s'agit de la deuxi√®me r√©f√©rence √† nos futurs articles.  :) <br><br>  Maintenant, comment avons-nous r√©solu ce probl√®me?  Nous avons √©tendu notre propre ensemble d'outils avec les fichiers de base .targets / .props du SDK .NET Core ( <i>Sdk.props</i> , <i>Sdk.targets</i> ).  Cela nous a donn√© plus de contr√¥le sur la situation et plus de flexibilit√© dans la gestion des importations ainsi que l'√©valuation des projets .NET Core en g√©n√©ral.  Oui, notre ensemble d'outils est redevenu un peu plus grand, et nous avons √©galement d√ª ajouter une logique pour configurer l'environnement requis pour l'√©valuation des projets .NET Core, mais cela en vaut la peine. <br><br>  Jusque-l√†, nous avions √©valu√© des projets .NET Core en demandant simplement l'√©valuation et en comptant sur MSBuild pour faire le travail. <br><br>  Maintenant que nous avions plus de contr√¥le sur la situation, le m√©canisme a un peu chang√©: <br><br><ul><li>  configurer l'environnement requis pour √©valuer les projets .NET Core; </li><li>  √©valuation: <ul><li>  commencer l'√©valuation en utilisant les fichiers .targets / .props de notre ensemble d'outils; </li><li>  poursuivre l'√©valuation √† l'aide de fichiers externes. </li></ul></li></ul><br>  Cette s√©quence sugg√®re que la configuration de l'environnement poursuit deux objectifs principaux: <br><br><ul><li>  lancer l'√©valuation √† l'aide des fichiers .targets / .props de notre ensemble d'outils; </li><li>  redirige toutes les op√©rations suivantes vers des fichiers externes .targets / .props. </li></ul><br>  Une biblioth√®que sp√©ciale Microsoft.DotNet.MSBuildSdkResolver est utilis√©e pour rechercher les fichiers .targets / .props n√©cessaires.  Afin de lancer la configuration de l'environnement √† l'aide des fichiers de notre ensemble d'outils, nous avons utilis√© une variable d'environnement sp√©ciale utilis√©e par cette biblioth√®que afin que nous puissions pointer vers la source d'o√π importer les fichiers n√©cessaires (c'est-√†-dire notre ensemble d'outils).  Puisque la biblioth√®que est incluse dans notre distribution, il n'y a aucun risque de panne logique soudaine. <br><br>  Nous avons maintenant les fichiers Sdk de notre ensemble d'outils import√©s en premier, et puisque nous pouvons facilement les modifier maintenant, nous contr√¥lons enti√®rement le reste de la logique d'√©valuation.  Cela signifie que nous pouvons maintenant d√©cider quels fichiers et de quel emplacement importer.  Il en va de m√™me pour Microsoft.Common.props mentionn√© ci-dessus.  Nous importons ce fichier et d'autres fichiers de base de notre ensemble d'outils afin de ne pas avoir √† nous soucier de leur existence ou de leur contenu. <br><br>  Une fois toutes les importations n√©cessaires effectu√©es et les propri√©t√©s d√©finies, nous transf√©rons le contr√¥le du processus d'√©valuation au SDK .NET Core r√©el, o√π toutes les autres op√©rations requises sont effectu√©es. <br><br><h2>  Conclusion </h2><br>  La prise en charge de Visual Studio 2019 √©tait g√©n√©ralement plus facile que la prise en charge de Visual Studio 2017 pour un certain nombre de raisons.  Tout d'abord, Microsoft n'a pas chang√© autant de choses que lors de la mise √† jour de Visual Studio 2015 vers Visual Studio 2017. Oui, ils ont chang√© le jeu d'outils de base et forc√© les plug-ins Visual Studio √† passer en mode de chargement asynchrone, mais ce changement n'a pas √©t√© que drastique.  Deuxi√®mement, nous avions d√©j√† une solution pr√™te √† l'emploi impliquant notre propre ensemble d'outils et un m√©canisme d'√©valuation de projet et nous n'avions tout simplement pas √† tout recommencer √† z√©ro - uniquement √† partir de ce que nous avions d√©j√†.  Le processus relativement indolore de prise en charge de l'analyse des projets .NET Core dans de nouvelles conditions (et sur des ordinateurs sans copie de Visual Studio install√©e) en √©tendant notre syst√®me d'√©valuation de projet nous donne √©galement l'espoir que nous avons fait le bon choix en prenant une partie du contr√¥le dans nos mains. <br><br>  Mais je voudrais r√©p√©ter l'id√©e communiqu√©e dans l'article pr√©c√©dent: parfois, l'utilisation de solutions toutes faites n'est pas aussi simple que cela puisse para√Ætre. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454736/">https://habr.com/ru/post/fr454736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454720/index.html">Comment faire revivre la documentation?</a></li>
<li><a href="../fr454728/index.html">Acc√®s Internet ouvert: la technologie LUWRAIN aide les utilisateurs aveugles</a></li>
<li><a href="../fr454730/index.html">Meetup Allure Server: enregistrements vid√©o de rapports</a></li>
<li><a href="../fr454732/index.html">5 techniques de priorisation robustes pour les √©quipes informatiques</a></li>
<li><a href="../fr454734/index.html">Sauvegarde, Partie 4: Pr√©sentation et test de zbackup, restic, borgbackup</a></li>
<li><a href="../fr454738/index.html">Prise en charge de Visual Studio 2019 dans PVS-Studio</a></li>
<li><a href="../fr454740/index.html">Mai 2019 Joomla Digest</a></li>
<li><a href="../fr454742/index.html">Au moins une astuce Vim que vous ne connaissiez pas</a></li>
<li><a href="../fr454744/index.html">Pr√©sentation des rapports de suivi Java de la conf√©rence RigaDevDays</a></li>
<li><a href="../fr454748/index.html">Guide de survie MongoDB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>