<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🔬 🍍 🙇🏻 Besondere Ausnahmen in .NET und wie man sie vorbereitet 🧕🏾 👩🏿‍🤝‍👩🏾 🤵🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die verschiedenen Ausnahmen in .NET haben ihre eigenen Eigenschaften, und es kann sehr nützlich sein, sie zu kennen. Wie betrüge ich die CLR? Wie kann...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Besondere Ausnahmen in .NET und wie man sie vorbereitet</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/426045/">  Die verschiedenen Ausnahmen in .NET haben ihre eigenen Eigenschaften, und es kann sehr nützlich sein, sie zu kennen.  Wie betrüge ich die CLR?  Wie kann man zur Laufzeit am Leben bleiben, indem man eine StackOverflowException abfängt?  Welche Ausnahmen scheint es unmöglich zu fangen, aber wenn Sie wirklich wollen, können Sie? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f1/314/78d/4f131478de33b4a6acd0ed25a0e53987.png"><br><br>  Unter dem Schnitt das Transkript des Berichts von Eugene ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">epeshk</a> ) Peshkov von unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DotNext 2018 Piter-</a> Konferenz, wo er über diese und andere Merkmale von Ausnahmen sprach. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WLSrYgMWif4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Hallo!  Ich heiße Eugene.  Ich arbeite für SKB Kontur und entwickle ein Hosting-System und stelle Anwendungen für Windows bereit.  Das Fazit ist, dass wir viele Produktteams haben, die ihre eigenen Services schreiben und sie bei uns hosten.  Wir bieten ihnen eine einfache Lösung für eine Vielzahl von Infrastrukturaufgaben.  Zum Beispiel, um den Verbrauch von Systemressourcen zu überwachen oder Replikate für den Dienst zu beenden. <br><br>  Manchmal stellt sich heraus, dass die auf unserem System gehosteten Anwendungen auseinanderfallen.  Wir haben so viele Möglichkeiten gesehen, wie eine Anwendung zur Laufzeit abstürzen kann.  Eine dieser Methoden besteht darin, eine unerwartete und bezaubernde Ausnahme auszuschließen. <br><br>  Heute werde ich über die Funktionen von Ausnahmen in .NET sprechen.  Wir haben einige dieser Merkmale in der Produktion und einige im Verlauf von Experimenten festgestellt. <br><br><h2>  Planen </h2><br><ol><li>  .NET-Ausnahmeverhalten <br></li><li>  Windows-Ausnahmebehandlung und Hacks <br></li></ol><br>  Alle folgenden Aussagen gelten für Windows.  Alle Beispiele wurden mit der neuesten Version des vollständigen .NET 4.7.1-Frameworks getestet.  Es wird auch einige Verweise auf .NET Core geben. <br><br><h2>  Zugriffsverletzung </h2><br>  Diese Ausnahme tritt bei falschen Speicheroperationen auf.  Wenn eine Anwendung beispielsweise versucht, auf einen Speicherbereich zuzugreifen, auf den sie keinen Zugriff hat.  Die Ausnahme ist ein niedriges Level, und normalerweise ist in diesem Fall ein sehr langes Debugging erforderlich. <br><br>  Versuchen wir, diese Ausnahme mit C # zu erhalten.  Dazu schreiben wir Byte 42 an die Adresse 1000 (wir gehen davon aus, dass 1000 eine ziemlich zufällige Adresse ist und unsere Anwendung höchstwahrscheinlich keinen Zugriff darauf hat). <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre> <br>  WriteByte macht genau das, was wir brauchen: Es schreibt ein Byte an die angegebene Adresse.  Wir erwarten, dass dieser Aufruf eine AccessViolationException auslöst.  Dieser Code löst tatsächlich diese Ausnahme aus, kann sie verarbeiten und die Anwendung funktioniert weiterhin.  Jetzt ändern wir den Code ein wenig: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] {<span class="hljs-number"><span class="hljs-number">42</span></span>}; Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre><br>  Wenn Sie anstelle von WriteByte die Copy-Methode verwenden und Byte 42 an die Adresse 1000 kopieren, kann AccessViolation mit try-catch nicht abgefangen werden.  Gleichzeitig wird auf der Konsole eine Meldung angezeigt, dass die Anwendung aufgrund einer nicht behandelten AccessViolationException beendet wurde. <br><br><pre> <code class="cs hljs">Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre><br>  Es stellt sich heraus, dass wir zwei Codezeilen haben, während die erste die gesamte Anwendung mit AccessViolation zum Absturz bringt und die zweite eine verarbeitete Ausnahme desselben Typs auslöst.  Um zu verstehen, warum dies geschieht, werden wir uns ansehen, wie diese Methoden von innen angeordnet sind. <br><br>  Beginnen wir mit der Copy-Methode. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Copy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">)</span></span> { Marshal.CopyToNative((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>) source, startIndex, destination, length); } [MethodImpl(MethodImplOptions.InternalCall)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyToNative</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, IntPtr destination, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Die Copy-Methode ruft lediglich die in .NET implementierte CopyToNative-Methode auf.  Wenn unsere Anwendung immer noch abstürzt und irgendwo eine Ausnahme auftritt, kann dies nur in CopyToNative geschehen.  Von hier aus können wir die erste Beobachtung machen: Wenn der .NET-Code als nativer Code bezeichnet wird und AccessViolation darin vorkommt, kann der .NET-Code diese Ausnahme aus irgendeinem Grund nicht behandeln. <br><br>  Jetzt werden wir verstehen, warum es möglich war, AccessViolation mit der WriteByte-Methode zu verarbeiten.  Schauen wir uns den Code für diese Methode an: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteByte</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { *(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) ptr = val; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NullReferenceException) {     <span class="hljs-comment"><span class="hljs-comment">// this method is documented to throw AccessViolationException on any AV throw new AccessViolationException(); } }</span></span></code> </pre><br>  Diese Methode ist vollständig in verwaltetem Code implementiert.  Es verwendet den C # -Pointer, um Daten an die gewünschte Adresse zu schreiben, und fängt auch eine NullReferenceException ab.  Wenn die NRE abgefangen wird, wird eine AccessViolationException ausgelöst.  Es ist also wegen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation</a> notwendig.  In diesem Fall werden alle vom throw-Konstrukt ausgelösten Ausnahmen behandelt.  Wenn während der Codeausführung in WriteByte eine NullReferenceException auftritt, können wir AccessViolation abfangen.  Könnte in unserem Fall ein NRE auftreten, wenn auf die Adresse 1000 anstatt auf die Adresse Null zugegriffen wird? <br><br>  Wir schreiben den Code mithilfe von C # -Zeigern direkt neu und stellen fest, dass beim Zugriff auf eine Adresse ungleich Null tatsächlich eine NullReferenceException ausgelöst wird: <br><br><pre> <code class="cs hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) <span class="hljs-number"><span class="hljs-number">1000</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre><br>  Um zu verstehen, warum dies geschieht, müssen wir uns daran erinnern, wie der Speicher des Prozesses funktioniert.  Im Prozessspeicher sind alle Adressen virtuell.  Dies bedeutet, dass die Anwendung einen großen Adressraum hat und nur einige Seiten davon im realen physischen Speicher angezeigt werden.  Es gibt jedoch eine Besonderheit: Die ersten 64 KB Adressen werden niemals dem physischen Speicher zugeordnet und nicht an die Anwendung übergeben.  Rantime .NET weiß das und verwendet es.  Wenn AccessViolation im verwalteten Code aufgetreten ist, überprüft die Laufzeit, auf welche Adresse im Speicher zugegriffen wurde, und generiert eine entsprechende Ausnahme.  Für Adressen von 0 bis 2 ^ 16 - NullReference, für alle anderen - AccessViolation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/775/3d4/38f/7753d438fc8a977ac0bb54e431d81c6f.png"><br><br>  Mal sehen, warum die NullReference nicht nur beim Zugriff auf die Nulladresse ausgelöst wird.  Stellen Sie sich vor, Sie greifen auf ein Feld eines Objekts eines Referenztyps zu und der Verweis auf dieses Objekt ist null: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/127/a27/867/127a27867ef7a568a242797758855b44.png"><br><br>  In dieser Situation erwarten wir eine NullReferenceException.  Der Zugriff auf das Feld des Objekts erfolgt in einem Versatz relativ zur Adresse dieses Objekts.  Es stellt sich heraus, dass wir uns an eine Adresse wenden, die nahe genug bei Null liegt (denken Sie daran, dass der Link zu unserem ursprünglichen Objekt Null ist).  Mit diesem Laufzeitverhalten erhalten wir die erwartete Ausnahme ohne zusätzliche Überprüfung der Adresse des Objekts selbst. <br><br>  Aber was passiert, wenn wir uns dem Feld eines Objekts zuwenden und dieses Objekt selbst mehr als 64 KB belegt? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/356/897/143/356897143b1275403569dc9f9a71471a.png"><br><br>  Können wir in diesem Fall AccessViolation erhalten?  Lass uns ein Experiment machen.  Lassen Sie uns ein sehr großes Objekt erstellen und auf seine Felder verweisen.  Ein Feld am Anfang des Objekts, das zweite am Ende: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08d/619/95a/08d61995a01630f94f31f759890af4a8.png"><br><br>  Beide Methoden lösen eine NullReferenceException aus.  Es tritt keine AccessViolationException auf. <br>  Schauen wir uns die Anweisungen an, die für diese Methoden generiert werden.  Im zweiten Fall fügte der JIT-Compiler eine zusätzliche cmp-Anweisung hinzu, die auf die Adresse des Objekts selbst zugreift, wodurch AccessViolation mit einer Nulladresse aufgerufen wird, die von der Laufzeit in eine NullReferenceException konvertiert wird. <br><br>  Es ist erwähnenswert, dass es für dieses Experiment nicht ausreicht, ein Array als großes Objekt zu verwenden.  Warum?  Überlassen Sie diese Frage dem Leser, schreiben Sie Ideen in die Kommentare :) <br><br>  Fassen wir die Experimente mit AccessViolation zusammen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffa/86b/0a8/ffa86b0a85f29a16936c92845f5d3e1e.png"><br><br>  AccessViolationException verhält sich je nachdem, wo die Ausnahme aufgetreten ist (im verwalteten Code oder im nativen Code), unterschiedlich.  Wenn im verwalteten Code eine Ausnahme aufgetreten ist, wird außerdem die Adresse des Objekts überprüft. <br><br>  Die Frage ist: Können wir eine AccessViolationException behandeln, die im nativen Code oder im verwalteten Code aufgetreten ist, aber nicht in NullReference konvertiert und nicht mit throw ausgelöst wurde?  Dies ist manchmal eine nützliche Funktion, insbesondere wenn Sie mit unsicherem Code arbeiten.  Die Antwort auf diese Frage hängt von der Version von .NET ab. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/67a/785/318/67a785318bc8b5f084a3b23fa36e766b.png"><br><br>  In .NET 1.0 gab es überhaupt keine AccessViolationException.  Alle Links wurden entweder als gültig oder als null angesehen.  Zum Zeitpunkt von .NET 2.0 wurde klar, dass ohne direkte Arbeit mit dem Speicher - auf keinen Fall - AccessViolation angezeigt wurde, während es verarbeitbar war.  In 4.0 und höher blieb es noch funktionsfähig, aber die Verarbeitung ist nicht so einfach.  Um diese Ausnahme abzufangen, müssen Sie jetzt die Methode, in der sich der catch-Block befindet, mit dem HandleProcessCorruptedStateException-Attribut markieren.  Anscheinend haben die Entwickler dies getan, weil sie der Meinung waren, dass AccessViolationException nicht die Ausnahme ist, die in einer regulären Anwendung abgefangen werden sollte. <br>  Aus Gründen der Abwärtskompatibilität können außerdem die Laufzeiteinstellungen verwendet werden: <br><br><ul><li>  LegacyNullReferenceExceptionPolicy gibt das .NET 1.0-Verhalten zurück - alle AVs werden zu NRE <br></li><li>  LegacyCorruptedStateExceptionsPolicy gibt das .NET 2.0-Verhalten zurück - alle AVs werden abgefangen <br></li></ul><br>  In .NET wird Core AccessViolation überhaupt nicht behandelt. <br><br>  In unserer Produktion gab es eine solche Situation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad7/0f1/6d3/ad70f16d3438d1e8ab80e43ba29d5412.png"><br><br>  Eine unter .NET 4.7.1 erstellte Anwendung verwendete eine unter .NET 3.5 erstellte gemeinsam genutzte Codebibliothek.  In dieser Bibliothek gab es einen Helfer, der eine regelmäßige Aktion ausführte: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isRunning) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { log.Error(e); } WaitForNextExecution(... ); }</code> </pre><br>  Wir haben die Aktion aus unserer Bewerbung an diesen Helfer weitergeleitet.  So kam es, dass er mit AccessViolation abstürzte.  Infolgedessen protokollierte unsere Anwendung ständig AccessViolation, anstatt weil zu stürzen  Der Code in der Bibliothek unter 3.5 könnte ihn abfangen.  Es ist zu beachten, dass das Abfangen nicht von der Version der Laufzeit abhängt, auf der die Anwendung ausgeführt wird, sondern von TargetFramework, unter dem die Anwendung erstellt wurde, und ihren Abhängigkeiten. <br><br>  Zusammenfassend.  Die AccessVilolation-Verarbeitung hängt davon ab, woher sie stammt - in nativem oder verwaltetem Code - sowie von den TargetFramework- und Laufzeiteinstellungen. <br><br><h2>  Thread abbrechen </h2><br>  Manchmal müssen Sie im Code die Ausführung eines der Threads stoppen.  Dazu können Sie den thread.Abort () verwenden. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... Thread.ResetAbort(); } }); ... thread.Abort();</code> </pre><br>  Wenn die Abort-Methode in einem gestoppten Thread aufgerufen wird, wird eine ThreadAbortException ausgelöst.  Lassen Sie uns seine Funktionen analysieren.  Zum Beispiel ein Code wie dieser: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { … } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { … } }); ... thread.Abort();</code> </pre><br>  Absolut gleichbedeutend damit: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }); ... thread.Abort();</code> </pre><br>  Wenn Sie ThreadAbort noch verarbeiten und einige andere Aktionen im gestoppten Thread ausführen müssen, können Sie die Thread.ResetAbort () -Methode verwenden.  Es stoppt den Prozess des Stoppens des Flusses und die Ausnahme hört auf, den Stapel höher zu werfen.  Es ist wichtig zu verstehen, dass die thread.Abort () -Methode selbst nichts garantiert - der Code im gestoppten Thread verhindert möglicherweise das Stoppen. <br><br>  Ein weiteres Merkmal von thread.Abort () ist, dass es den Code nicht unterbrechen kann, wenn er sich im catch befindet und schließlich blockiert. <br><br>  Im Framework-Code finden Sie häufig Methoden, bei denen der try-Block leer ist und die gesamte Logik endgültig enthalten ist.  Dies geschieht nur, um zu verhindern, dass dieser Code von einer ThreadAbortException ausgelöst wird. <br><br>  Außerdem wartet ein Aufruf der thread.Abort () -Methode darauf, dass eine ThreadAbortException ausgelöst wird.  Kombinieren Sie diese beiden Fakten und stellen Sie sicher, dass die thread.Abort () -Methode den aufrufenden Thread blockieren kann. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { }       <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { } <span class="hljs-comment"><span class="hljs-comment">// &lt;-- No ThreadAbortException in catch       finally { // &lt;-- No ThreadAbortException in finally           Thread.Sleep(- 1); } }); thread.Start(); ... thread.Abort(); // Never returns</span></span></code> </pre><br>  In der Realität kann dies bei der Verwendung der Verwendung auftreten.  Es wird in try / finally bereitgestellt. Innerhalb von finally wird die Dispose-Methode aufgerufen.  Es kann beliebig komplex sein, Ereignishandler enthalten und Sperren verwenden.  Und wenn thread.Abort zur Laufzeit aufgerufen wurde, wartet Dispose - thread.Abort () darauf.  So bekommen wir ein Schloss fast von Grund auf neu. <br><br>  In .NET Core löst die thread.Abort () -Methode eine PlatformNotSupportedException aus.  Und ich denke, das ist sehr gut, weil es mich motiviert, nicht thread.Abort (), sondern nicht-invasive Methoden zu verwenden, um die Codeausführung zu stoppen, beispielsweise mit dem CancellationToken. <br><br><h2>  AUS DEM SPEICHER </h2><br>  Diese Ausnahme kann erhalten werden, wenn der Speicher auf dem Computer geringer als erforderlich ist.  Oder als wir auf die Einschränkungen eines 32-Bit-Prozesses stießen.  Sie können es jedoch auch dann herunterladen, wenn der Computer über viel freien Speicher verfügt und der Prozess 64-Bit ist. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr4gb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue/<span class="hljs-number"><span class="hljs-number">2</span></span>];</code> </pre><br>  Der obige Code löst OutOfMemory aus.  Die Sache ist, dass Objekte mit mehr als 2 GB standardmäßig nicht zulässig sind.  Dies kann behoben werden, indem gcAllowVeryLargeObjects in App.config festgelegt wird.  In diesem Fall wird ein 4-GB-Array erstellt. <br><br>  Versuchen wir nun, ein Array noch weiter zu erstellen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> largeArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue];</code> </pre><br>  Jetzt hilft auch gcAllowVeryLargeObjects nicht mehr.  Dies liegt daran, dass .NET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den maximalen Index in einem Array begrenzt</a> .  Diese Einschränkung ist kleiner als int.MaxValue. <br><br>  Maximaler Array-Index: <br><br><ul><li>  Byte-Arrays - 0x7FFFFFC7 <br></li><li>  andere Arrays - 0X7F <b>E</b> FFFFF <br></li></ul><br>  In diesem Fall tritt eine OutOfMemoryException auf, obwohl wir tatsächlich auf eine Datentypeinschränkung gestoßen sind, nicht auf einen Speichermangel. <br><br>  Manchmal wird OutOfMemory durch verwalteten Code im .NET Framework explizit weggeworfen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/efd/c84/d98/efdc84d98a7786e39c9c5931ac523d13.png"><br>  Dies ist eine Implementierung der string.Concat-Methode.  Wenn die Länge der Ergebniszeichenfolge größer als int.MaxValue ist, wird sofort eine OutOfMemoryException ausgelöst. <br><br>  Kommen wir zu der Situation, in der OutOfMemory auftritt, wenn der Speicher tatsächlich leer ist. <br><br><pre> <code class="cs hljs">LimitMemory(<span class="hljs-number"><span class="hljs-number">64.</span></span>Mb()); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>)   list.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (OutOfMemoryException e) { Console.WriteLine(e); }</code> </pre><br>  Zunächst beschränken wir den Speicher unseres Prozesses auf 64 MB.  Wählen Sie als Nächstes in der Schleife neue Byte-Arrays aus, speichern Sie sie auf einem Blatt, damit der GC sie nicht sammelt, und versuchen Sie, OutOfMemory abzufangen. <br><br>  In diesem Fall kann alles passieren: <br><br><ul><li>  Ausnahme behandelt <br></li><li>  Prozess wird fallen <br></li><li>  Lassen Sie uns in den Fang gehen, aber die Ausnahme wird wieder abstürzen <br></li><li>  Lassen Sie uns in den Fang gehen, aber StackOverflow wird abstürzen <br></li></ul><br>  In diesem Fall ist das Programm vollständig nicht deterministisch.  Lassen Sie uns alle Optionen analysieren: <br><br><ol><li>  Eine Ausnahme kann behandelt werden.  In .NET hindert Sie nichts daran, eine OutOfMemoryException zu behandeln. <br></li><li>  Der Prozess kann fallen.  Vergessen Sie nicht, dass wir eine verwaltete Anwendung haben.  Dies bedeutet, dass darin nicht nur unser Code ausgeführt wird, sondern auch der Laufzeitcode.  Zum Beispiel GC.  Daher kann es vorkommen, dass die Laufzeit Speicher für sich selbst reservieren möchte, dies jedoch nicht kann. Dann können wir die Ausnahme nicht abfangen. <br></li><li>  Gehen wir in den Haken, aber die Ausnahme wird wieder abstürzen.  Innerhalb von catch erledigen wir den Job auch dort, wo wir Speicher benötigen (wir drucken eine Ausnahme auf die Konsole), und dies kann eine neue Ausnahme verursachen. <br></li><li>  Lassen Sie uns in den Fang gehen, aber StackOverflow wird abstürzen.  StackOverflow selbst tritt auf, wenn die WriteLine-Methode aufgerufen wird, aber es gibt hier keinen Stapelüberlauf, aber eine andere Situation tritt auf.  Lassen Sie es uns genauer analysieren. <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/6e3/d32/752/6e3d32752ba10fd39d1f4a5e2e6648a7.png"><br><br>  Im virtuellen Speicher können Seiten nicht nur dem physischen Speicher zugeordnet, sondern auch reserviert werden.  Wenn die Seite reserviert ist, hat die Anwendung festgestellt, dass sie verwendet werden soll.  Wenn die Seite bereits einem realen Speicher oder Swap zugeordnet ist, wird sie als "festgeschrieben" (festgeschrieben) bezeichnet.  Der Stapel verwendet diese Fähigkeit, um Speicher in reservierte und festgeschriebene zu teilen.  Es sieht ungefähr so ​​aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b17/9e4/41f/b179e441f0c00f18e2a5fdf12b3093a9.png"><br><br>  Es stellt sich heraus, dass wir die WriteLine-Methode aufrufen, die einen Platz auf dem Stapel einnimmt.  Es stellt sich heraus, dass der gesamte gesperrte Speicher bereits beendet ist. Dies bedeutet, dass das Betriebssystem zu diesem Zeitpunkt eine weitere reservierte Seite auf dem Stapel nehmen und sie dem realen physischen Speicher zuordnen sollte, der bereits mit Byte-Arrays gefüllt ist.  Dies führt zur Ausnahme von StackOverflow. <br><br>  Mit dem folgenden Code können Sie den gesamten Speicher zu Beginn des Streams auf einmal auf den Stapel übertragen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; F(), <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>).Start();</code> </pre><br>  Alternativ können Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laufzeiteinstellung</a> disableCommitThreadStack verwenden.  Es muss deaktiviert werden, damit der Thread-Stack im Voraus festgeschrieben wird.  Es ist anzumerken, dass das in der Dokumentation beschriebene und in der Realität beobachtete Standardverhalten unterschiedlich ist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46e/0e6/dbd/46e0e6dbd47906fb1d0ddf74ac927383.png"><br><br><h2>  Stapelüberlauf </h2><br>  Schauen wir uns StackOverflowException genauer an.  Schauen wir uns zwei Codebeispiele an.  In einem von ihnen führen wir eine unendliche Rekursion aus, die zu einem Stapelüberlauf führt, in dem zweiten werfen wir diese Ausnahme einfach mit throw. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { InfiniteRecursion(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StackOverflowException(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br>  Da alle mit throw ausgelösten Ausnahmen behandelt werden, werden wir im zweiten Fall die Ausnahme abfangen.  Und beim ersten Fall ist alles interessanter.  Wenden Sie sich an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MSDN</a> : <br><br><blockquote>  "Sie können keine Stapelüberlauf-Ausnahmen abfangen, da für den Ausnahmebehandlungscode möglicherweise der Stapel erforderlich ist." <br>  MSDN </blockquote><br>  Hier heißt es, dass wir keine StackOverflowException abfangen können, da das Abfangen selbst möglicherweise zusätzlichen Stapelspeicherplatz benötigt, der bereits beendet wurde. <br><br>  Um uns irgendwie vor dieser Ausnahme zu schützen, können wir Folgendes tun.  Zunächst können Sie die Tiefe der Rekursion begrenzen.  Zweitens können Sie die Methoden der RuntimeHelpers-Klasse verwenden: <br><br><blockquote>  RuntimeHelpers.EnsureSufficientExecutionStack (); <br><br><ul><li>  "Stellt sicher, dass der verbleibende Stapelspeicher groß genug ist, um die durchschnittliche .NET Framework-Funktion auszuführen."  - MSDN <br></li><li>  UnzureichendeExecutionStackException <br></li><li>  512 KB - x86, AnyCPU, 2 MB - x64 (Hälfte der Stapelgröße) <br></li><li>  64/128 KB - .NET Core <br></li><li>  Überprüfen Sie nur den Stapeladressraum <br></li></ul><br></blockquote><br>  In der Dokumentation zu dieser Methode wird überprüft, ob auf dem Stapel genügend Speicherplatz vorhanden ist, um die <i>durchschnittliche</i> .NET-Funktion auszuführen.  Aber was ist die <i>durchschnittliche</i> Funktion?  Tatsächlich überprüft diese Methode in .NET Framework, ob mindestens die Hälfte ihrer Größe auf dem Stapel frei ist.  In .NET Core wird nach 64 KB kostenlos gesucht. <br><br>  In .NET Core wurde auch ein Analogon angezeigt: RuntimeHelpers.TryEnsureSufficientExecutionStack (), das einen Bool zurückgibt, anstatt eine Ausnahme auszulösen. <br><br>  Mit C # 7.2 wurde die Möglichkeit eingeführt, Span und Stackallock zusammen zu verwenden, ohne unsicheren Code zu verwenden.  Möglicherweise wird Stackalloc aus diesem Grund häufiger im Code verwendet, und es ist hilfreich, sich bei der Verwendung vor StackOverflow zu schützen und auszuwählen, wo Speicher zugewiesen werden soll.  Als solches Verfahren wird ein Verfahren vorgeschlagen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, das die Möglichkeit der Zuordnung auf dem Stapel</a> und dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trystackalloc-</a> Konstrukt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">überprüft</a> . <br><br><pre> <code class="cs hljs">Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; span; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanAllocateOnStack(size)) span = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> span = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size];</code> </pre><br>  Zurück zur StackOverflow-Dokumentation zu MSDN <br><br><blockquote>  Wenn stattdessen in einer <b>normalen Anwendung</b> ein Stapelüberlauf auftritt, beendet die Common Language Runtime (CLR) den Prozess. “ <br>  MSDN <br></blockquote><br>  Wenn es eine „normale“ Anwendung gibt, die während StackOverflow herunterfällt, gibt es nicht normale Anwendungen, die nicht fallen?  Um diese Frage zu beantworten, müssen Sie eine Ebene von der Ebene der verwalteten Anwendung auf die Ebene der CLR senken. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/186/516/64d/18651664dd1c1d1346e5377f0e0b3995.png"><br><br><blockquote>  "Eine Anwendung, <b>die die CLR hostet,</b> kann das Standardverhalten ändern und angeben, dass die CLR <b>die Anwendungsdomäne entlädt,</b> in der die Ausnahme auftritt, den Prozess jedoch fortsetzen kann."  - MSDN <br>  StackOverflowException -&gt; AppDomainUnloadedException <br></blockquote><br>  Eine Anwendung, die die CLR hostet, kann das Verhalten des Stapelüberlaufs neu definieren, sodass anstelle des Abschlusses des gesamten Prozesses die Anwendungsdomäne entladen wird, in deren Stream dieser Überlauf aufgetreten ist.  So können wir eine StackOverflowException in eine AppDomainUnloadedException verwandeln. <br><br>  Wenn eine verwaltete Anwendung gestartet wird, wird die .NET-Laufzeit automatisch gestartet.  Aber du kannst den anderen Weg gehen.  Schreiben Sie beispielsweise eine nicht verwaltete Anwendung (in C ++ oder einer anderen Sprache), die eine spezielle API verwendet, um die CLR zu erhöhen und unsere Anwendung zu starten.  Eine Anwendung, die die CLR intern ausführt, wird als CLR-Host bezeichnet.  Durch das Schreiben können wir viele Dinge zur Laufzeit konfigurieren.  Ersetzen Sie beispielsweise den Speichermanager und den Thread-Manager.  Wir in der Produktion verwenden CLR-Host, um das Austauschen von Speicherseiten zu vermeiden. <br><br>  Der folgende Code konfiguriert den CLR-Host so, dass AppDomain (C ++) während StackOverflow entladen wird: <br><br><pre> <code class="cpp hljs">ICLRPolicyManager *policyMgr; pCLRControl-&gt;GetCLRManager(IID_ICLRPolicyManager, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) (&amp;policyMgr)); policyMgr-&gt;SetActionOnFailure(FAIL_StackOverflow, eRudeUnloadAppDomain);</code> </pre><br>  Ist dies ein guter Weg, um StackOverflow zu entkommen?  Wahrscheinlich nicht sehr.  Erstens mussten wir C ++ - Code schreiben, was wir nicht wollten.  Zweitens müssen wir unseren C # -Code so ändern, dass die Funktion, die eine StackOverflowException auslösen kann, in einer separaten AppDomain und in einem separaten Thread ausgeführt wird.  Unser Code wird sofort zu solchen Nudeln: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; InfiniteRecursion()); thread.Start(); thread.Join(); }); AppDomain.Unload(appDomain); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AppDomainUnloadedException) { }</code> </pre><br>  Um die InfiniteRecursion-Methode aufzurufen, haben wir eine Reihe von Zeilen geschrieben.  Drittens haben wir begonnen, AppDomain zu verwenden.  Und das garantiert fast eine Reihe neuer Probleme.  Einschließlich mit Ausnahmen.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain( <span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException()); System.Runtime.Serialization.SerializationException: Type <span class="hljs-string"><span class="hljs-string">'CustomException'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> not marked <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> serializable. at System.AppDomain.DoCallBack(CrossAppDomainDelegate callBackDelegate)</code> </pre><br>  Da unsere Ausnahme nicht als serialisierbar markiert ist, wird unser Code mit einer SerializationException gelöscht.  Um dieses Problem zu beheben, reicht es nicht aus, unsere Ausnahme mit dem Attribut Serializable zu markieren. Wir müssen dennoch einen zusätzlichen Konstruktor für die Serialisierung implementieren. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext ctx</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">info, context</span></span></span><span class="hljs-function">)</span></span>{} } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException());</code> </pre><br>  Es stellt sich heraus, dass alles nicht sehr schön ist, also gehen wir weiter - auf die Ebene des Betriebssystems und der Hacks, die nicht in der Produktion verwendet werden sollten. <br><br><h2>  Seh / veh </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/2c5/7a2/aff/2c57a2aff0542b2a02ad8ab34d097412.png"><br><br>  Beachten Sie, dass während verwaltete Ausnahmen zwischen verwaltet und der CLR flogen, SEH-Ausnahmen zwischen der CLR und Windows flogen. <br><br>  SEH - Strukturierte Ausnahmebehandlung <br><br><ul><li>  Windows-Ausnahmebehandlungsmodul <br></li><li>  Einheitliche Behandlung von Software- und Hardware-Ausnahmen <br></li><li>  C # -Ausnahmen zusätzlich zu SEH implementiert <br></li></ul><br>  SEH ist ein Ausnahmebehandlungsmechanismus in Windows, mit dem Sie Ausnahmen, die beispielsweise von der Prozessorebene stammen oder mit der Logik der Anwendung selbst zusammenhängen, gleichermaßen einheitlich behandeln können. <br><br>  Rantime .NET kennt SEH-Ausnahmen und kann sie in verwaltete Ausnahmen konvertieren: <br><br><ul><li>  EXCEPTION_STACK_OVERFLOW -&gt; Absturz <br></li><li>  EXCEPTION_ACCESS_VIOLATION -&gt; AccessViolationException <br></li><li>  EXCEPTION_ACCESS_VIOLATION -&gt; NullReferenceException <br></li><li>  EXCEPTION_INT_DIVIDE_BY_ZERO -&gt; DivideByZeroException <br></li><li>  Unbekannte SEH-Ausnahmen -&gt; SEHException <br></li></ul><br>  Wir können über WinApi mit SEH interagieren. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionFlags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nNumberOfArguments,IntPtr lpArguments</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// DivideByZeroException RaiseException(0xc0000094, 0, 0, IntPtr.Zero); // Stack overflow RaiseException(0xc00000fd, 0, 0, IntPtr.Zero);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tatsächlich funktioniert das Wurfkonstrukt auch über SEH. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> -&gt; RaiseException(<span class="hljs-number"><span class="hljs-number">0xe0434f4d</span></span>, ...)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hierbei ist zu beachten, dass der CLR-Ausnahmecode immer derselbe ist. Unabhängig davon, welche Art von Ausnahme wir auslösen, wird er immer verarbeitet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VEH ist eine Vektorausnahmebehandlung, eine Erweiterung von SEH, die jedoch auf Prozessebene und nicht auf der Ebene eines einzelnen Threads arbeitet. </font><font style="vertical-align: inherit;">Wenn SEH dem Try-Catch semantisch ähnlich ist, ist VEH einem Interrupt-Handler semantisch ähnlich. </font><font style="vertical-align: inherit;">Wir stellen einfach unseren Handler ein und können Informationen über alle Ausnahmen erhalten, die in unserem Prozess auftreten. </font><font style="vertical-align: inherit;">Eine interessante Funktion von VEH ist, dass Sie die SEH-Ausnahme ändern können, bevor sie zum Handler gelangt.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b8/79d/848/7b879d848390b9e3d1b9156b00b8e2bf.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können unseren eigenen Vektor-Handler zwischen das Betriebssystem und die Laufzeit stellen, der SEH-Ausnahmen behandelt. Wenn EXCEPTION_STACK_OVERFLOW auftritt, können Sie ihn so ändern, dass die .NET-Laufzeit den Prozess nicht zum Absturz bringt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können über WinApi mit VEH interagieren:</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">, SetLastError = true)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddVectoredExceptionHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr FirstHandler,  VECTORED_EXCEPTION_HANDLER VectoredHandler</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> VEH : <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> { EXCEPTION_CONTINUE_SEARCH = <span class="hljs-number"><span class="hljs-number">0</span></span>, EXCEPTION_EXECUTE_HANDLER = <span class="hljs-number"><span class="hljs-number">1</span></span>, EXCEPTION_CONTINUE_EXECUTION = <span class="hljs-number"><span class="hljs-number">-1</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_POINTERS { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EXCEPTION_RECORD* ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IntPtr Context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_RECORD { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> ExceptionCode; ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Kontext enthält Informationen zum Status aller Prozessorregister zum Zeitpunkt der Ausnahme. </font><font style="vertical-align: inherit;">Wir werden an EXCEPTION_RECORD und dem darin enthaltenen ExceptionCode-Feld interessiert sein. </font><font style="vertical-align: inherit;">Wir können es durch unseren eigenen Ausnahmecode ersetzen, von dem die CLR nichts weiß. </font><font style="vertical-align: inherit;">Der Vektor-Handler sieht folgendermaßen aus:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.ExceptionRecord == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> record = e. ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record-&gt;ExceptionCode != ExceptionStackOverflow) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; record-&gt;ExceptionCode = <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_EXECUTE_HANDLER; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt erstellen wir einen Wrapper, der einen Vektorhandler in Form der HandleSO-Methode installiert, der einen Delegaten aufnimmt, der möglicherweise aus einer StackOverflowException stammt (aus Gründen der Übersichtlichkeit behandelt der Code keine WinApi-Funktionsfehler und entfernt den Vektorhandler). </font></font><br><br><pre> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()) ; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T HandleSO&lt;T&gt;(Func&lt;T&gt; action) { Kernel32. AddVectoredExceptionHandler(IntPtr.Zero, Handler); Kernel32.SetThreadStackGuarantee(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> size); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) when ((<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) Marshal. GetExceptionCode() == <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T); } HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Darin wird auch die SetThreadStackGuarantee-Methode verwendet. </font><font style="vertical-align: inherit;">Diese Methode reserviert Stapelspeicher für die StackOverflow-Verarbeitung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf diese Weise können wir den Aufruf einer Methode mit unendlicher Rekursion überleben. </font><font style="vertical-align: inherit;">Unser Stream funktioniert weiterhin so, als wäre nichts passiert, als wäre kein Überlauf aufgetreten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber was passiert, wenn Sie HandleSO zweimal im selben Thread aufrufen?</font></font><br><br><pre> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()); HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und es wird eine AccessViolationException geben. Zurück zum Stapelgerät. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/639/e93/c8d/639e93c8d187dc31fc37a2ac7247f193.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Betriebssystem kann Stapelüberläufe erkennen. Ganz oben im Stapel befindet sich eine spezielle Seite, die mit dem Guard-Seitenflag gekennzeichnet ist. Beim ersten Zugriff auf diese Seite tritt eine weitere Ausnahme auf - STATUS_GUARD_PAGE_VIOLATION - und das Flag für die Seitenwache wird von der Seite entfernt. Wenn Sie diesen Überlauf einfach abfangen, befindet sich diese Seite nicht mehr auf dem Stapel. Beim nächsten Überlauf kann das Betriebssystem dies nicht verstehen und der Stapelzeiger geht über den für den Stapel zugewiesenen Speicher hinaus. Infolgedessen tritt eine AccessViolationException auf. Sie müssen also Seitenflags nach der Verarbeitung von StackOverflow wiederherstellen. Der einfachste Weg, dies zu tun, ist die Verwendung der Methode _resetstkoflw aus der C-Laufzeitbibliothek (msvcrt.dll).</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _resetstkoflw();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf ähnliche Weise können Sie eine AccessViolationException in .NET Core unter Windows abfangen, wodurch der Prozess abstürzt. </font><font style="vertical-align: inherit;">In diesem Fall müssen Sie die Reihenfolge berücksichtigen, in der Vektorhandler aufgerufen werden, und Ihren Handler auf den Anfang der Kette setzen, da .NET Core bei der Verarbeitung von AccessViolation auch VEH verwendet. </font><font style="vertical-align: inherit;">Der erste Parameter der Funktion AddVectoredExceptionHandler ist für die Reihenfolge verantwortlich, in der die Handler aufgerufen werden:</font></font><br><br><pre> <code class="cs hljs">Kernel32.AddVectoredExceptionHandler(FirstHandler: (IntPtr) <span class="hljs-number"><span class="hljs-number">1</span></span>, handler);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem wir praktische Fragen untersucht haben, fassen wir die allgemeinen Ergebnisse zusammen: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ausnahmen sind nicht so einfach, wie sie scheinen; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nicht alle Ausnahmen werden gleich behandelt. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Ausnahmebehandlung erfolgt auf verschiedenen Abstraktionsebenen. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie können in den Ausnahmebehandlungsprozess eingreifen und die .NET-Laufzeit anders als ursprünglich vorgesehen ausführen. </font></font><br></li></ul><br><h2>  Referenzen </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository mit Beispielen aus dem Bericht</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> → </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dotnext 2016 Moskau - Adam Sitnik - Außergewöhnliche Ausnahmen in .NET</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> → </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNetBook: Ausnahmen</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> → </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Inside Out Teil 8 - Behandlung von Stapelüberlauf-Ausnahmen in C # mit VEH</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine weitere Möglichkeit, StackOverflow abzufangen.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am 22. und 23. November wird Eugene auf der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext 2018 in Moskau</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit einem Bericht </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"System Metrics: </font></font></a><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Collecting </font></b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Pitfalls"</font></a><font style="vertical-align: inherit;"> sprechen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jeffrey Richter, Greg Young, Pavel Yosifovich und andere ebenso interessante Redner werden nach Moskau kommen. </font><font style="vertical-align: inherit;">Die Themen der Berichte können hier eingesehen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Tickets können </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier gekauft werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font> Jetzt mitmachen! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426045/">https://habr.com/ru/post/de426045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426029/index.html">Gibst du auf und willst die Aufgabe beenden? So sieht eine effektive Entwicklerschulung aus</a></li>
<li><a href="../de426031/index.html">Die Sorge, die Welt mit künstlicher Intelligenz zu erobern, kann auf unwissenschaftlichen Annahmen beruhen</a></li>
<li><a href="../de426033/index.html">Mathe-Titanen streiten sich um den epischen Beweis der ABC-Hypothese</a></li>
<li><a href="../de426039/index.html">Notstart "Sojus MS-10" (Besatzung gerettet, ausgestrahlt)</a></li>
<li><a href="../de426041/index.html">Symbolische Lösung linearer Differentialgleichungen und -systeme durch die Laplace-Transformationsmethode mit SymPy</a></li>
<li><a href="../de426047/index.html">10 großartige Bücher für Anfänger in Englisch</a></li>
<li><a href="../de426051/index.html">Verbesserung der Fähigkeiten zum Debuggen von Software - einige Tipps</a></li>
<li><a href="../de426053/index.html">Caching von Ereignishandlern und Verbesserung der Anwendungsleistung</a></li>
<li><a href="../de426055/index.html">TensorFlow.js und clmtrackr.js: Verfolgen der Blickrichtung des Benutzers im Browser</a></li>
<li><a href="../de426059/index.html">Tutu PHP Meetup # 2: Sprachvideo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>