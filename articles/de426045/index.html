<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüî¨ üçç üôáüèª Besondere Ausnahmen in .NET und wie man sie vorbereitet üßïüèæ üë©üèø‚Äçü§ù‚Äçüë©üèæ ü§µüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die verschiedenen Ausnahmen in .NET haben ihre eigenen Eigenschaften, und es kann sehr n√ºtzlich sein, sie zu kennen. Wie betr√ºge ich die CLR? Wie kann...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Besondere Ausnahmen in .NET und wie man sie vorbereitet</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/426045/">  Die verschiedenen Ausnahmen in .NET haben ihre eigenen Eigenschaften, und es kann sehr n√ºtzlich sein, sie zu kennen.  Wie betr√ºge ich die CLR?  Wie kann man zur Laufzeit am Leben bleiben, indem man eine StackOverflowException abf√§ngt?  Welche Ausnahmen scheint es unm√∂glich zu fangen, aber wenn Sie wirklich wollen, k√∂nnen Sie? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f1/314/78d/4f131478de33b4a6acd0ed25a0e53987.png"><br><br>  Unter dem Schnitt das Transkript des Berichts von Eugene ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">epeshk</a> ) Peshkov von unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DotNext 2018 Piter-</a> Konferenz, wo er √ºber diese und andere Merkmale von Ausnahmen sprach. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WLSrYgMWif4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Hallo!  Ich hei√üe Eugene.  Ich arbeite f√ºr SKB Kontur und entwickle ein Hosting-System und stelle Anwendungen f√ºr Windows bereit.  Das Fazit ist, dass wir viele Produktteams haben, die ihre eigenen Services schreiben und sie bei uns hosten.  Wir bieten ihnen eine einfache L√∂sung f√ºr eine Vielzahl von Infrastrukturaufgaben.  Zum Beispiel, um den Verbrauch von Systemressourcen zu √ºberwachen oder Replikate f√ºr den Dienst zu beenden. <br><br>  Manchmal stellt sich heraus, dass die auf unserem System gehosteten Anwendungen auseinanderfallen.  Wir haben so viele M√∂glichkeiten gesehen, wie eine Anwendung zur Laufzeit abst√ºrzen kann.  Eine dieser Methoden besteht darin, eine unerwartete und bezaubernde Ausnahme auszuschlie√üen. <br><br>  Heute werde ich √ºber die Funktionen von Ausnahmen in .NET sprechen.  Wir haben einige dieser Merkmale in der Produktion und einige im Verlauf von Experimenten festgestellt. <br><br><h2>  Planen </h2><br><ol><li>  .NET-Ausnahmeverhalten <br></li><li>  Windows-Ausnahmebehandlung und Hacks <br></li></ol><br>  Alle folgenden Aussagen gelten f√ºr Windows.  Alle Beispiele wurden mit der neuesten Version des vollst√§ndigen .NET 4.7.1-Frameworks getestet.  Es wird auch einige Verweise auf .NET Core geben. <br><br><h2>  Zugriffsverletzung </h2><br>  Diese Ausnahme tritt bei falschen Speicheroperationen auf.  Wenn eine Anwendung beispielsweise versucht, auf einen Speicherbereich zuzugreifen, auf den sie keinen Zugriff hat.  Die Ausnahme ist ein niedriges Level, und normalerweise ist in diesem Fall ein sehr langes Debugging erforderlich. <br><br>  Versuchen wir, diese Ausnahme mit C # zu erhalten.  Dazu schreiben wir Byte 42 an die Adresse 1000 (wir gehen davon aus, dass 1000 eine ziemlich zuf√§llige Adresse ist und unsere Anwendung h√∂chstwahrscheinlich keinen Zugriff darauf hat). <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre> <br>  WriteByte macht genau das, was wir brauchen: Es schreibt ein Byte an die angegebene Adresse.  Wir erwarten, dass dieser Aufruf eine AccessViolationException ausl√∂st.  Dieser Code l√∂st tats√§chlich diese Ausnahme aus, kann sie verarbeiten und die Anwendung funktioniert weiterhin.  Jetzt √§ndern wir den Code ein wenig: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] {<span class="hljs-number"><span class="hljs-number">42</span></span>}; Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre><br>  Wenn Sie anstelle von WriteByte die Copy-Methode verwenden und Byte 42 an die Adresse 1000 kopieren, kann AccessViolation mit try-catch nicht abgefangen werden.  Gleichzeitig wird auf der Konsole eine Meldung angezeigt, dass die Anwendung aufgrund einer nicht behandelten AccessViolationException beendet wurde. <br><br><pre> <code class="cs hljs">Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre><br>  Es stellt sich heraus, dass wir zwei Codezeilen haben, w√§hrend die erste die gesamte Anwendung mit AccessViolation zum Absturz bringt und die zweite eine verarbeitete Ausnahme desselben Typs ausl√∂st.  Um zu verstehen, warum dies geschieht, werden wir uns ansehen, wie diese Methoden von innen angeordnet sind. <br><br>  Beginnen wir mit der Copy-Methode. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Copy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">)</span></span> { Marshal.CopyToNative((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>) source, startIndex, destination, length); } [MethodImpl(MethodImplOptions.InternalCall)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyToNative</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, IntPtr destination, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Die Copy-Methode ruft lediglich die in .NET implementierte CopyToNative-Methode auf.  Wenn unsere Anwendung immer noch abst√ºrzt und irgendwo eine Ausnahme auftritt, kann dies nur in CopyToNative geschehen.  Von hier aus k√∂nnen wir die erste Beobachtung machen: Wenn der .NET-Code als nativer Code bezeichnet wird und AccessViolation darin vorkommt, kann der .NET-Code diese Ausnahme aus irgendeinem Grund nicht behandeln. <br><br>  Jetzt werden wir verstehen, warum es m√∂glich war, AccessViolation mit der WriteByte-Methode zu verarbeiten.  Schauen wir uns den Code f√ºr diese Methode an: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteByte</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { *(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) ptr = val; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NullReferenceException) {     <span class="hljs-comment"><span class="hljs-comment">// this method is documented to throw AccessViolationException on any AV throw new AccessViolationException(); } }</span></span></code> </pre><br>  Diese Methode ist vollst√§ndig in verwaltetem Code implementiert.  Es verwendet den C # -Pointer, um Daten an die gew√ºnschte Adresse zu schreiben, und f√§ngt auch eine NullReferenceException ab.  Wenn die NRE abgefangen wird, wird eine AccessViolationException ausgel√∂st.  Es ist also wegen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation</a> notwendig.  In diesem Fall werden alle vom throw-Konstrukt ausgel√∂sten Ausnahmen behandelt.  Wenn w√§hrend der Codeausf√ºhrung in WriteByte eine NullReferenceException auftritt, k√∂nnen wir AccessViolation abfangen.  K√∂nnte in unserem Fall ein NRE auftreten, wenn auf die Adresse 1000 anstatt auf die Adresse Null zugegriffen wird? <br><br>  Wir schreiben den Code mithilfe von C # -Zeigern direkt neu und stellen fest, dass beim Zugriff auf eine Adresse ungleich Null tats√§chlich eine NullReferenceException ausgel√∂st wird: <br><br><pre> <code class="cs hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) <span class="hljs-number"><span class="hljs-number">1000</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre><br>  Um zu verstehen, warum dies geschieht, m√ºssen wir uns daran erinnern, wie der Speicher des Prozesses funktioniert.  Im Prozessspeicher sind alle Adressen virtuell.  Dies bedeutet, dass die Anwendung einen gro√üen Adressraum hat und nur einige Seiten davon im realen physischen Speicher angezeigt werden.  Es gibt jedoch eine Besonderheit: Die ersten 64 KB Adressen werden niemals dem physischen Speicher zugeordnet und nicht an die Anwendung √ºbergeben.  Rantime .NET wei√ü das und verwendet es.  Wenn AccessViolation im verwalteten Code aufgetreten ist, √ºberpr√ºft die Laufzeit, auf welche Adresse im Speicher zugegriffen wurde, und generiert eine entsprechende Ausnahme.  F√ºr Adressen von 0 bis 2 ^ 16 - NullReference, f√ºr alle anderen - AccessViolation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/775/3d4/38f/7753d438fc8a977ac0bb54e431d81c6f.png"><br><br>  Mal sehen, warum die NullReference nicht nur beim Zugriff auf die Nulladresse ausgel√∂st wird.  Stellen Sie sich vor, Sie greifen auf ein Feld eines Objekts eines Referenztyps zu und der Verweis auf dieses Objekt ist null: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/127/a27/867/127a27867ef7a568a242797758855b44.png"><br><br>  In dieser Situation erwarten wir eine NullReferenceException.  Der Zugriff auf das Feld des Objekts erfolgt in einem Versatz relativ zur Adresse dieses Objekts.  Es stellt sich heraus, dass wir uns an eine Adresse wenden, die nahe genug bei Null liegt (denken Sie daran, dass der Link zu unserem urspr√ºnglichen Objekt Null ist).  Mit diesem Laufzeitverhalten erhalten wir die erwartete Ausnahme ohne zus√§tzliche √úberpr√ºfung der Adresse des Objekts selbst. <br><br>  Aber was passiert, wenn wir uns dem Feld eines Objekts zuwenden und dieses Objekt selbst mehr als 64 KB belegt? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/356/897/143/356897143b1275403569dc9f9a71471a.png"><br><br>  K√∂nnen wir in diesem Fall AccessViolation erhalten?  Lass uns ein Experiment machen.  Lassen Sie uns ein sehr gro√ües Objekt erstellen und auf seine Felder verweisen.  Ein Feld am Anfang des Objekts, das zweite am Ende: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08d/619/95a/08d61995a01630f94f31f759890af4a8.png"><br><br>  Beide Methoden l√∂sen eine NullReferenceException aus.  Es tritt keine AccessViolationException auf. <br>  Schauen wir uns die Anweisungen an, die f√ºr diese Methoden generiert werden.  Im zweiten Fall f√ºgte der JIT-Compiler eine zus√§tzliche cmp-Anweisung hinzu, die auf die Adresse des Objekts selbst zugreift, wodurch AccessViolation mit einer Nulladresse aufgerufen wird, die von der Laufzeit in eine NullReferenceException konvertiert wird. <br><br>  Es ist erw√§hnenswert, dass es f√ºr dieses Experiment nicht ausreicht, ein Array als gro√ües Objekt zu verwenden.  Warum?  √úberlassen Sie diese Frage dem Leser, schreiben Sie Ideen in die Kommentare :) <br><br>  Fassen wir die Experimente mit AccessViolation zusammen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffa/86b/0a8/ffa86b0a85f29a16936c92845f5d3e1e.png"><br><br>  AccessViolationException verh√§lt sich je nachdem, wo die Ausnahme aufgetreten ist (im verwalteten Code oder im nativen Code), unterschiedlich.  Wenn im verwalteten Code eine Ausnahme aufgetreten ist, wird au√üerdem die Adresse des Objekts √ºberpr√ºft. <br><br>  Die Frage ist: K√∂nnen wir eine AccessViolationException behandeln, die im nativen Code oder im verwalteten Code aufgetreten ist, aber nicht in NullReference konvertiert und nicht mit throw ausgel√∂st wurde?  Dies ist manchmal eine n√ºtzliche Funktion, insbesondere wenn Sie mit unsicherem Code arbeiten.  Die Antwort auf diese Frage h√§ngt von der Version von .NET ab. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/67a/785/318/67a785318bc8b5f084a3b23fa36e766b.png"><br><br>  In .NET 1.0 gab es √ºberhaupt keine AccessViolationException.  Alle Links wurden entweder als g√ºltig oder als null angesehen.  Zum Zeitpunkt von .NET 2.0 wurde klar, dass ohne direkte Arbeit mit dem Speicher - auf keinen Fall - AccessViolation angezeigt wurde, w√§hrend es verarbeitbar war.  In 4.0 und h√∂her blieb es noch funktionsf√§hig, aber die Verarbeitung ist nicht so einfach.  Um diese Ausnahme abzufangen, m√ºssen Sie jetzt die Methode, in der sich der catch-Block befindet, mit dem HandleProcessCorruptedStateException-Attribut markieren.  Anscheinend haben die Entwickler dies getan, weil sie der Meinung waren, dass AccessViolationException nicht die Ausnahme ist, die in einer regul√§ren Anwendung abgefangen werden sollte. <br>  Aus Gr√ºnden der Abw√§rtskompatibilit√§t k√∂nnen au√üerdem die Laufzeiteinstellungen verwendet werden: <br><br><ul><li>  LegacyNullReferenceExceptionPolicy gibt das .NET 1.0-Verhalten zur√ºck - alle AVs werden zu NRE <br></li><li>  LegacyCorruptedStateExceptionsPolicy gibt das .NET 2.0-Verhalten zur√ºck - alle AVs werden abgefangen <br></li></ul><br>  In .NET wird Core AccessViolation √ºberhaupt nicht behandelt. <br><br>  In unserer Produktion gab es eine solche Situation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad7/0f1/6d3/ad70f16d3438d1e8ab80e43ba29d5412.png"><br><br>  Eine unter .NET 4.7.1 erstellte Anwendung verwendete eine unter .NET 3.5 erstellte gemeinsam genutzte Codebibliothek.  In dieser Bibliothek gab es einen Helfer, der eine regelm√§√üige Aktion ausf√ºhrte: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isRunning) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { log.Error(e); } WaitForNextExecution(... ); }</code> </pre><br>  Wir haben die Aktion aus unserer Bewerbung an diesen Helfer weitergeleitet.  So kam es, dass er mit AccessViolation abst√ºrzte.  Infolgedessen protokollierte unsere Anwendung st√§ndig AccessViolation, anstatt weil zu st√ºrzen  Der Code in der Bibliothek unter 3.5 k√∂nnte ihn abfangen.  Es ist zu beachten, dass das Abfangen nicht von der Version der Laufzeit abh√§ngt, auf der die Anwendung ausgef√ºhrt wird, sondern von TargetFramework, unter dem die Anwendung erstellt wurde, und ihren Abh√§ngigkeiten. <br><br>  Zusammenfassend.  Die AccessVilolation-Verarbeitung h√§ngt davon ab, woher sie stammt - in nativem oder verwaltetem Code - sowie von den TargetFramework- und Laufzeiteinstellungen. <br><br><h2>  Thread abbrechen </h2><br>  Manchmal m√ºssen Sie im Code die Ausf√ºhrung eines der Threads stoppen.  Dazu k√∂nnen Sie den thread.Abort () verwenden. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... Thread.ResetAbort(); } }); ... thread.Abort();</code> </pre><br>  Wenn die Abort-Methode in einem gestoppten Thread aufgerufen wird, wird eine ThreadAbortException ausgel√∂st.  Lassen Sie uns seine Funktionen analysieren.  Zum Beispiel ein Code wie dieser: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ‚Ä¶ } }); ... thread.Abort();</code> </pre><br>  Absolut gleichbedeutend damit: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }); ... thread.Abort();</code> </pre><br>  Wenn Sie ThreadAbort noch verarbeiten und einige andere Aktionen im gestoppten Thread ausf√ºhren m√ºssen, k√∂nnen Sie die Thread.ResetAbort () -Methode verwenden.  Es stoppt den Prozess des Stoppens des Flusses und die Ausnahme h√∂rt auf, den Stapel h√∂her zu werfen.  Es ist wichtig zu verstehen, dass die thread.Abort () -Methode selbst nichts garantiert - der Code im gestoppten Thread verhindert m√∂glicherweise das Stoppen. <br><br>  Ein weiteres Merkmal von thread.Abort () ist, dass es den Code nicht unterbrechen kann, wenn er sich im catch befindet und schlie√ülich blockiert. <br><br>  Im Framework-Code finden Sie h√§ufig Methoden, bei denen der try-Block leer ist und die gesamte Logik endg√ºltig enthalten ist.  Dies geschieht nur, um zu verhindern, dass dieser Code von einer ThreadAbortException ausgel√∂st wird. <br><br>  Au√üerdem wartet ein Aufruf der thread.Abort () -Methode darauf, dass eine ThreadAbortException ausgel√∂st wird.  Kombinieren Sie diese beiden Fakten und stellen Sie sicher, dass die thread.Abort () -Methode den aufrufenden Thread blockieren kann. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { }       <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { } <span class="hljs-comment"><span class="hljs-comment">// &lt;-- No ThreadAbortException in catch       finally { // &lt;-- No ThreadAbortException in finally           Thread.Sleep(- 1); } }); thread.Start(); ... thread.Abort(); // Never returns</span></span></code> </pre><br>  In der Realit√§t kann dies bei der Verwendung der Verwendung auftreten.  Es wird in try / finally bereitgestellt. Innerhalb von finally wird die Dispose-Methode aufgerufen.  Es kann beliebig komplex sein, Ereignishandler enthalten und Sperren verwenden.  Und wenn thread.Abort zur Laufzeit aufgerufen wurde, wartet Dispose - thread.Abort () darauf.  So bekommen wir ein Schloss fast von Grund auf neu. <br><br>  In .NET Core l√∂st die thread.Abort () -Methode eine PlatformNotSupportedException aus.  Und ich denke, das ist sehr gut, weil es mich motiviert, nicht thread.Abort (), sondern nicht-invasive Methoden zu verwenden, um die Codeausf√ºhrung zu stoppen, beispielsweise mit dem CancellationToken. <br><br><h2>  AUS DEM SPEICHER </h2><br>  Diese Ausnahme kann erhalten werden, wenn der Speicher auf dem Computer geringer als erforderlich ist.  Oder als wir auf die Einschr√§nkungen eines 32-Bit-Prozesses stie√üen.  Sie k√∂nnen es jedoch auch dann herunterladen, wenn der Computer √ºber viel freien Speicher verf√ºgt und der Prozess 64-Bit ist. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr4gb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue/<span class="hljs-number"><span class="hljs-number">2</span></span>];</code> </pre><br>  Der obige Code l√∂st OutOfMemory aus.  Die Sache ist, dass Objekte mit mehr als 2 GB standardm√§√üig nicht zul√§ssig sind.  Dies kann behoben werden, indem gcAllowVeryLargeObjects in App.config festgelegt wird.  In diesem Fall wird ein 4-GB-Array erstellt. <br><br>  Versuchen wir nun, ein Array noch weiter zu erstellen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> largeArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue];</code> </pre><br>  Jetzt hilft auch gcAllowVeryLargeObjects nicht mehr.  Dies liegt daran, dass .NET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den maximalen Index in einem Array begrenzt</a> .  Diese Einschr√§nkung ist kleiner als int.MaxValue. <br><br>  Maximaler Array-Index: <br><br><ul><li>  Byte-Arrays - 0x7FFFFFC7 <br></li><li>  andere Arrays - 0X7F <b>E</b> FFFFF <br></li></ul><br>  In diesem Fall tritt eine OutOfMemoryException auf, obwohl wir tats√§chlich auf eine Datentypeinschr√§nkung gesto√üen sind, nicht auf einen Speichermangel. <br><br>  Manchmal wird OutOfMemory durch verwalteten Code im .NET Framework explizit weggeworfen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/efd/c84/d98/efdc84d98a7786e39c9c5931ac523d13.png"><br>  Dies ist eine Implementierung der string.Concat-Methode.  Wenn die L√§nge der Ergebniszeichenfolge gr√∂√üer als int.MaxValue ist, wird sofort eine OutOfMemoryException ausgel√∂st. <br><br>  Kommen wir zu der Situation, in der OutOfMemory auftritt, wenn der Speicher tats√§chlich leer ist. <br><br><pre> <code class="cs hljs">LimitMemory(<span class="hljs-number"><span class="hljs-number">64.</span></span>Mb()); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>)   list.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (OutOfMemoryException e) { Console.WriteLine(e); }</code> </pre><br>  Zun√§chst beschr√§nken wir den Speicher unseres Prozesses auf 64 MB.  W√§hlen Sie als N√§chstes in der Schleife neue Byte-Arrays aus, speichern Sie sie auf einem Blatt, damit der GC sie nicht sammelt, und versuchen Sie, OutOfMemory abzufangen. <br><br>  In diesem Fall kann alles passieren: <br><br><ul><li>  Ausnahme behandelt <br></li><li>  Prozess wird fallen <br></li><li>  Lassen Sie uns in den Fang gehen, aber die Ausnahme wird wieder abst√ºrzen <br></li><li>  Lassen Sie uns in den Fang gehen, aber StackOverflow wird abst√ºrzen <br></li></ul><br>  In diesem Fall ist das Programm vollst√§ndig nicht deterministisch.  Lassen Sie uns alle Optionen analysieren: <br><br><ol><li>  Eine Ausnahme kann behandelt werden.  In .NET hindert Sie nichts daran, eine OutOfMemoryException zu behandeln. <br></li><li>  Der Prozess kann fallen.  Vergessen Sie nicht, dass wir eine verwaltete Anwendung haben.  Dies bedeutet, dass darin nicht nur unser Code ausgef√ºhrt wird, sondern auch der Laufzeitcode.  Zum Beispiel GC.  Daher kann es vorkommen, dass die Laufzeit Speicher f√ºr sich selbst reservieren m√∂chte, dies jedoch nicht kann. Dann k√∂nnen wir die Ausnahme nicht abfangen. <br></li><li>  Gehen wir in den Haken, aber die Ausnahme wird wieder abst√ºrzen.  Innerhalb von catch erledigen wir den Job auch dort, wo wir Speicher ben√∂tigen (wir drucken eine Ausnahme auf die Konsole), und dies kann eine neue Ausnahme verursachen. <br></li><li>  Lassen Sie uns in den Fang gehen, aber StackOverflow wird abst√ºrzen.  StackOverflow selbst tritt auf, wenn die WriteLine-Methode aufgerufen wird, aber es gibt hier keinen Stapel√ºberlauf, aber eine andere Situation tritt auf.  Lassen Sie es uns genauer analysieren. <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/6e3/d32/752/6e3d32752ba10fd39d1f4a5e2e6648a7.png"><br><br>  Im virtuellen Speicher k√∂nnen Seiten nicht nur dem physischen Speicher zugeordnet, sondern auch reserviert werden.  Wenn die Seite reserviert ist, hat die Anwendung festgestellt, dass sie verwendet werden soll.  Wenn die Seite bereits einem realen Speicher oder Swap zugeordnet ist, wird sie als "festgeschrieben" (festgeschrieben) bezeichnet.  Der Stapel verwendet diese F√§higkeit, um Speicher in reservierte und festgeschriebene zu teilen.  Es sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b17/9e4/41f/b179e441f0c00f18e2a5fdf12b3093a9.png"><br><br>  Es stellt sich heraus, dass wir die WriteLine-Methode aufrufen, die einen Platz auf dem Stapel einnimmt.  Es stellt sich heraus, dass der gesamte gesperrte Speicher bereits beendet ist. Dies bedeutet, dass das Betriebssystem zu diesem Zeitpunkt eine weitere reservierte Seite auf dem Stapel nehmen und sie dem realen physischen Speicher zuordnen sollte, der bereits mit Byte-Arrays gef√ºllt ist.  Dies f√ºhrt zur Ausnahme von StackOverflow. <br><br>  Mit dem folgenden Code k√∂nnen Sie den gesamten Speicher zu Beginn des Streams auf einmal auf den Stapel √ºbertragen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; F(), <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>).Start();</code> </pre><br>  Alternativ k√∂nnen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laufzeiteinstellung</a> disableCommitThreadStack verwenden.  Es muss deaktiviert werden, damit der Thread-Stack im Voraus festgeschrieben wird.  Es ist anzumerken, dass das in der Dokumentation beschriebene und in der Realit√§t beobachtete Standardverhalten unterschiedlich ist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46e/0e6/dbd/46e0e6dbd47906fb1d0ddf74ac927383.png"><br><br><h2>  Stapel√ºberlauf </h2><br>  Schauen wir uns StackOverflowException genauer an.  Schauen wir uns zwei Codebeispiele an.  In einem von ihnen f√ºhren wir eine unendliche Rekursion aus, die zu einem Stapel√ºberlauf f√ºhrt, in dem zweiten werfen wir diese Ausnahme einfach mit throw. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { InfiniteRecursion(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StackOverflowException(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br>  Da alle mit throw ausgel√∂sten Ausnahmen behandelt werden, werden wir im zweiten Fall die Ausnahme abfangen.  Und beim ersten Fall ist alles interessanter.  Wenden Sie sich an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MSDN</a> : <br><br><blockquote>  "Sie k√∂nnen keine Stapel√ºberlauf-Ausnahmen abfangen, da f√ºr den Ausnahmebehandlungscode m√∂glicherweise der Stapel erforderlich ist." <br>  MSDN </blockquote><br>  Hier hei√üt es, dass wir keine StackOverflowException abfangen k√∂nnen, da das Abfangen selbst m√∂glicherweise zus√§tzlichen Stapelspeicherplatz ben√∂tigt, der bereits beendet wurde. <br><br>  Um uns irgendwie vor dieser Ausnahme zu sch√ºtzen, k√∂nnen wir Folgendes tun.  Zun√§chst k√∂nnen Sie die Tiefe der Rekursion begrenzen.  Zweitens k√∂nnen Sie die Methoden der RuntimeHelpers-Klasse verwenden: <br><br><blockquote>  RuntimeHelpers.EnsureSufficientExecutionStack (); <br><br><ul><li>  "Stellt sicher, dass der verbleibende Stapelspeicher gro√ü genug ist, um die durchschnittliche .NET Framework-Funktion auszuf√ºhren."  - MSDN <br></li><li>  UnzureichendeExecutionStackException <br></li><li>  512 KB - x86, AnyCPU, 2 MB - x64 (H√§lfte der Stapelgr√∂√üe) <br></li><li>  64/128 KB - .NET Core <br></li><li>  √úberpr√ºfen Sie nur den Stapeladressraum <br></li></ul><br></blockquote><br>  In der Dokumentation zu dieser Methode wird √ºberpr√ºft, ob auf dem Stapel gen√ºgend Speicherplatz vorhanden ist, um die <i>durchschnittliche</i> .NET-Funktion auszuf√ºhren.  Aber was ist die <i>durchschnittliche</i> Funktion?  Tats√§chlich √ºberpr√ºft diese Methode in .NET Framework, ob mindestens die H√§lfte ihrer Gr√∂√üe auf dem Stapel frei ist.  In .NET Core wird nach 64 KB kostenlos gesucht. <br><br>  In .NET Core wurde auch ein Analogon angezeigt: RuntimeHelpers.TryEnsureSufficientExecutionStack (), das einen Bool zur√ºckgibt, anstatt eine Ausnahme auszul√∂sen. <br><br>  Mit C # 7.2 wurde die M√∂glichkeit eingef√ºhrt, Span und Stackallock zusammen zu verwenden, ohne unsicheren Code zu verwenden.  M√∂glicherweise wird Stackalloc aus diesem Grund h√§ufiger im Code verwendet, und es ist hilfreich, sich bei der Verwendung vor StackOverflow zu sch√ºtzen und auszuw√§hlen, wo Speicher zugewiesen werden soll.  Als solches Verfahren wird ein Verfahren vorgeschlagen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, das die M√∂glichkeit der Zuordnung auf dem Stapel</a> und dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trystackalloc-</a> Konstrukt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºberpr√ºft</a> . <br><br><pre> <code class="cs hljs">Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; span; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanAllocateOnStack(size)) span = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> span = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size];</code> </pre><br>  Zur√ºck zur StackOverflow-Dokumentation zu MSDN <br><br><blockquote>  Wenn stattdessen in einer <b>normalen Anwendung</b> ein Stapel√ºberlauf auftritt, beendet die Common Language Runtime (CLR) den Prozess. ‚Äú <br>  MSDN <br></blockquote><br>  Wenn es eine ‚Äûnormale‚Äú Anwendung gibt, die w√§hrend StackOverflow herunterf√§llt, gibt es nicht normale Anwendungen, die nicht fallen?  Um diese Frage zu beantworten, m√ºssen Sie eine Ebene von der Ebene der verwalteten Anwendung auf die Ebene der CLR senken. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/186/516/64d/18651664dd1c1d1346e5377f0e0b3995.png"><br><br><blockquote>  "Eine Anwendung, <b>die die CLR hostet,</b> kann das Standardverhalten √§ndern und angeben, dass die CLR <b>die Anwendungsdom√§ne entl√§dt,</b> in der die Ausnahme auftritt, den Prozess jedoch fortsetzen kann."  - MSDN <br>  StackOverflowException -&gt; AppDomainUnloadedException <br></blockquote><br>  Eine Anwendung, die die CLR hostet, kann das Verhalten des Stapel√ºberlaufs neu definieren, sodass anstelle des Abschlusses des gesamten Prozesses die Anwendungsdom√§ne entladen wird, in deren Stream dieser √úberlauf aufgetreten ist.  So k√∂nnen wir eine StackOverflowException in eine AppDomainUnloadedException verwandeln. <br><br>  Wenn eine verwaltete Anwendung gestartet wird, wird die .NET-Laufzeit automatisch gestartet.  Aber du kannst den anderen Weg gehen.  Schreiben Sie beispielsweise eine nicht verwaltete Anwendung (in C ++ oder einer anderen Sprache), die eine spezielle API verwendet, um die CLR zu erh√∂hen und unsere Anwendung zu starten.  Eine Anwendung, die die CLR intern ausf√ºhrt, wird als CLR-Host bezeichnet.  Durch das Schreiben k√∂nnen wir viele Dinge zur Laufzeit konfigurieren.  Ersetzen Sie beispielsweise den Speichermanager und den Thread-Manager.  Wir in der Produktion verwenden CLR-Host, um das Austauschen von Speicherseiten zu vermeiden. <br><br>  Der folgende Code konfiguriert den CLR-Host so, dass AppDomain (C ++) w√§hrend StackOverflow entladen wird: <br><br><pre> <code class="cpp hljs">ICLRPolicyManager *policyMgr; pCLRControl-&gt;GetCLRManager(IID_ICLRPolicyManager, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) (&amp;policyMgr)); policyMgr-&gt;SetActionOnFailure(FAIL_StackOverflow, eRudeUnloadAppDomain);</code> </pre><br>  Ist dies ein guter Weg, um StackOverflow zu entkommen?  Wahrscheinlich nicht sehr.  Erstens mussten wir C ++ - Code schreiben, was wir nicht wollten.  Zweitens m√ºssen wir unseren C # -Code so √§ndern, dass die Funktion, die eine StackOverflowException ausl√∂sen kann, in einer separaten AppDomain und in einem separaten Thread ausgef√ºhrt wird.  Unser Code wird sofort zu solchen Nudeln: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; InfiniteRecursion()); thread.Start(); thread.Join(); }); AppDomain.Unload(appDomain); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AppDomainUnloadedException) { }</code> </pre><br>  Um die InfiniteRecursion-Methode aufzurufen, haben wir eine Reihe von Zeilen geschrieben.  Drittens haben wir begonnen, AppDomain zu verwenden.  Und das garantiert fast eine Reihe neuer Probleme.  Einschlie√ülich mit Ausnahmen.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain( <span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException()); System.Runtime.Serialization.SerializationException: Type <span class="hljs-string"><span class="hljs-string">'CustomException'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> not marked <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> serializable. at System.AppDomain.DoCallBack(CrossAppDomainDelegate callBackDelegate)</code> </pre><br>  Da unsere Ausnahme nicht als serialisierbar markiert ist, wird unser Code mit einer SerializationException gel√∂scht.  Um dieses Problem zu beheben, reicht es nicht aus, unsere Ausnahme mit dem Attribut Serializable zu markieren. Wir m√ºssen dennoch einen zus√§tzlichen Konstruktor f√ºr die Serialisierung implementieren. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext ctx</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">info, context</span></span></span><span class="hljs-function">)</span></span>{} } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException());</code> </pre><br>  Es stellt sich heraus, dass alles nicht sehr sch√∂n ist, also gehen wir weiter - auf die Ebene des Betriebssystems und der Hacks, die nicht in der Produktion verwendet werden sollten. <br><br><h2>  Seh / veh </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/2c5/7a2/aff/2c57a2aff0542b2a02ad8ab34d097412.png"><br><br>  Beachten Sie, dass w√§hrend verwaltete Ausnahmen zwischen verwaltet und der CLR flogen, SEH-Ausnahmen zwischen der CLR und Windows flogen. <br><br>  SEH - Strukturierte Ausnahmebehandlung <br><br><ul><li>  Windows-Ausnahmebehandlungsmodul <br></li><li>  Einheitliche Behandlung von Software- und Hardware-Ausnahmen <br></li><li>  C # -Ausnahmen zus√§tzlich zu SEH implementiert <br></li></ul><br>  SEH ist ein Ausnahmebehandlungsmechanismus in Windows, mit dem Sie Ausnahmen, die beispielsweise von der Prozessorebene stammen oder mit der Logik der Anwendung selbst zusammenh√§ngen, gleicherma√üen einheitlich behandeln k√∂nnen. <br><br>  Rantime .NET kennt SEH-Ausnahmen und kann sie in verwaltete Ausnahmen konvertieren: <br><br><ul><li>  EXCEPTION_STACK_OVERFLOW -&gt; Absturz <br></li><li>  EXCEPTION_ACCESS_VIOLATION -&gt; AccessViolationException <br></li><li>  EXCEPTION_ACCESS_VIOLATION -&gt; NullReferenceException <br></li><li>  EXCEPTION_INT_DIVIDE_BY_ZERO -&gt; DivideByZeroException <br></li><li>  Unbekannte SEH-Ausnahmen -&gt; SEHException <br></li></ul><br>  Wir k√∂nnen √ºber WinApi mit SEH interagieren. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionFlags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nNumberOfArguments,IntPtr lpArguments</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// DivideByZeroException RaiseException(0xc0000094, 0, 0, IntPtr.Zero); // Stack overflow RaiseException(0xc00000fd, 0, 0, IntPtr.Zero);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tats√§chlich funktioniert das Wurfkonstrukt auch √ºber SEH. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> -&gt; RaiseException(<span class="hljs-number"><span class="hljs-number">0xe0434f4d</span></span>, ...)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hierbei ist zu beachten, dass der CLR-Ausnahmecode immer derselbe ist. Unabh√§ngig davon, welche Art von Ausnahme wir ausl√∂sen, wird er immer verarbeitet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VEH ist eine Vektorausnahmebehandlung, eine Erweiterung von SEH, die jedoch auf Prozessebene und nicht auf der Ebene eines einzelnen Threads arbeitet. </font><font style="vertical-align: inherit;">Wenn SEH dem Try-Catch semantisch √§hnlich ist, ist VEH einem Interrupt-Handler semantisch √§hnlich. </font><font style="vertical-align: inherit;">Wir stellen einfach unseren Handler ein und k√∂nnen Informationen √ºber alle Ausnahmen erhalten, die in unserem Prozess auftreten. </font><font style="vertical-align: inherit;">Eine interessante Funktion von VEH ist, dass Sie die SEH-Ausnahme √§ndern k√∂nnen, bevor sie zum Handler gelangt.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b8/79d/848/7b879d848390b9e3d1b9156b00b8e2bf.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen unseren eigenen Vektor-Handler zwischen das Betriebssystem und die Laufzeit stellen, der SEH-Ausnahmen behandelt. Wenn EXCEPTION_STACK_OVERFLOW auftritt, k√∂nnen Sie ihn so √§ndern, dass die .NET-Laufzeit den Prozess nicht zum Absturz bringt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen √ºber WinApi mit VEH interagieren:</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">, SetLastError = true)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddVectoredExceptionHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr FirstHandler,  VECTORED_EXCEPTION_HANDLER VectoredHandler</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> VEH : <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> { EXCEPTION_CONTINUE_SEARCH = <span class="hljs-number"><span class="hljs-number">0</span></span>, EXCEPTION_EXECUTE_HANDLER = <span class="hljs-number"><span class="hljs-number">1</span></span>, EXCEPTION_CONTINUE_EXECUTION = <span class="hljs-number"><span class="hljs-number">-1</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_POINTERS { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EXCEPTION_RECORD* ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IntPtr Context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_RECORD { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> ExceptionCode; ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Kontext enth√§lt Informationen zum Status aller Prozessorregister zum Zeitpunkt der Ausnahme. </font><font style="vertical-align: inherit;">Wir werden an EXCEPTION_RECORD und dem darin enthaltenen ExceptionCode-Feld interessiert sein. </font><font style="vertical-align: inherit;">Wir k√∂nnen es durch unseren eigenen Ausnahmecode ersetzen, von dem die CLR nichts wei√ü. </font><font style="vertical-align: inherit;">Der Vektor-Handler sieht folgenderma√üen aus:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.ExceptionRecord == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> record = e. ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record-&gt;ExceptionCode != ExceptionStackOverflow) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; record-&gt;ExceptionCode = <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_EXECUTE_HANDLER; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt erstellen wir einen Wrapper, der einen Vektorhandler in Form der HandleSO-Methode installiert, der einen Delegaten aufnimmt, der m√∂glicherweise aus einer StackOverflowException stammt (aus Gr√ºnden der √úbersichtlichkeit behandelt der Code keine WinApi-Funktionsfehler und entfernt den Vektorhandler). </font></font><br><br><pre> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()) ; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T HandleSO&lt;T&gt;(Func&lt;T&gt; action) { Kernel32. AddVectoredExceptionHandler(IntPtr.Zero, Handler); Kernel32.SetThreadStackGuarantee(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> size); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) when ((<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) Marshal. GetExceptionCode() == <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T); } HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Darin wird auch die SetThreadStackGuarantee-Methode verwendet. </font><font style="vertical-align: inherit;">Diese Methode reserviert Stapelspeicher f√ºr die StackOverflow-Verarbeitung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen wir den Aufruf einer Methode mit unendlicher Rekursion √ºberleben. </font><font style="vertical-align: inherit;">Unser Stream funktioniert weiterhin so, als w√§re nichts passiert, als w√§re kein √úberlauf aufgetreten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber was passiert, wenn Sie HandleSO zweimal im selben Thread aufrufen?</font></font><br><br><pre> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()); HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und es wird eine AccessViolationException geben. Zur√ºck zum Stapelger√§t. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/639/e93/c8d/639e93c8d187dc31fc37a2ac7247f193.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Betriebssystem kann Stapel√ºberl√§ufe erkennen. Ganz oben im Stapel befindet sich eine spezielle Seite, die mit dem Guard-Seitenflag gekennzeichnet ist. Beim ersten Zugriff auf diese Seite tritt eine weitere Ausnahme auf - STATUS_GUARD_PAGE_VIOLATION - und das Flag f√ºr die Seitenwache wird von der Seite entfernt. Wenn Sie diesen √úberlauf einfach abfangen, befindet sich diese Seite nicht mehr auf dem Stapel. Beim n√§chsten √úberlauf kann das Betriebssystem dies nicht verstehen und der Stapelzeiger geht √ºber den f√ºr den Stapel zugewiesenen Speicher hinaus. Infolgedessen tritt eine AccessViolationException auf. Sie m√ºssen also Seitenflags nach der Verarbeitung von StackOverflow wiederherstellen. Der einfachste Weg, dies zu tun, ist die Verwendung der Methode _resetstkoflw aus der C-Laufzeitbibliothek (msvcrt.dll).</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _resetstkoflw();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf √§hnliche Weise k√∂nnen Sie eine AccessViolationException in .NET Core unter Windows abfangen, wodurch der Prozess abst√ºrzt. </font><font style="vertical-align: inherit;">In diesem Fall m√ºssen Sie die Reihenfolge ber√ºcksichtigen, in der Vektorhandler aufgerufen werden, und Ihren Handler auf den Anfang der Kette setzen, da .NET Core bei der Verarbeitung von AccessViolation auch VEH verwendet. </font><font style="vertical-align: inherit;">Der erste Parameter der Funktion AddVectoredExceptionHandler ist f√ºr die Reihenfolge verantwortlich, in der die Handler aufgerufen werden:</font></font><br><br><pre> <code class="cs hljs">Kernel32.AddVectoredExceptionHandler(FirstHandler: (IntPtr) <span class="hljs-number"><span class="hljs-number">1</span></span>, handler);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem wir praktische Fragen untersucht haben, fassen wir die allgemeinen Ergebnisse zusammen: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ausnahmen sind nicht so einfach, wie sie scheinen; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nicht alle Ausnahmen werden gleich behandelt. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Ausnahmebehandlung erfolgt auf verschiedenen Abstraktionsebenen. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie k√∂nnen in den Ausnahmebehandlungsprozess eingreifen und die .NET-Laufzeit anders als urspr√ºnglich vorgesehen ausf√ºhren. </font></font><br></li></ul><br><h2>  Referenzen </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository mit Beispielen aus dem Bericht</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dotnext 2016 Moskau - Adam Sitnik - Au√üergew√∂hnliche Ausnahmen in .NET</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNetBook: Ausnahmen</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Inside Out Teil 8 - Behandlung von Stapel√ºberlauf-Ausnahmen in C # mit VEH</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine weitere M√∂glichkeit, StackOverflow abzufangen.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am 22. und 23. November wird Eugene auf der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext 2018 in Moskau</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit einem Bericht </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"System Metrics: </font></font></a><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Collecting </font></b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Pitfalls"</font></a><font style="vertical-align: inherit;"> sprechen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jeffrey Richter, Greg Young, Pavel Yosifovich und andere ebenso interessante Redner werden nach Moskau kommen. </font><font style="vertical-align: inherit;">Die Themen der Berichte k√∂nnen hier eingesehen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Tickets k√∂nnen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier gekauft werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font> Jetzt mitmachen! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426045/">https://habr.com/ru/post/de426045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426029/index.html">Gibst du auf und willst die Aufgabe beenden? So sieht eine effektive Entwicklerschulung aus</a></li>
<li><a href="../de426031/index.html">Die Sorge, die Welt mit k√ºnstlicher Intelligenz zu erobern, kann auf unwissenschaftlichen Annahmen beruhen</a></li>
<li><a href="../de426033/index.html">Mathe-Titanen streiten sich um den epischen Beweis der ABC-Hypothese</a></li>
<li><a href="../de426039/index.html">Notstart "Sojus MS-10" (Besatzung gerettet, ausgestrahlt)</a></li>
<li><a href="../de426041/index.html">Symbolische L√∂sung linearer Differentialgleichungen und -systeme durch die Laplace-Transformationsmethode mit SymPy</a></li>
<li><a href="../de426047/index.html">10 gro√üartige B√ºcher f√ºr Anf√§nger in Englisch</a></li>
<li><a href="../de426051/index.html">Verbesserung der F√§higkeiten zum Debuggen von Software - einige Tipps</a></li>
<li><a href="../de426053/index.html">Caching von Ereignishandlern und Verbesserung der Anwendungsleistung</a></li>
<li><a href="../de426055/index.html">TensorFlow.js und clmtrackr.js: Verfolgen der Blickrichtung des Benutzers im Browser</a></li>
<li><a href="../de426059/index.html">Tutu PHP Meetup # 2: Sprachvideo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>