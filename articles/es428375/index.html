<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèº‚Äçü§ù‚Äçüßëüèº ü•ö üéé El libro "Trabaja con BigData en las nubes. Procesando y almacenando datos con ejemplos de Microsoft Azure ¬ª üö• ü§òüèæ üòü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aqu√≠ est√° el primer libro originalmente en ruso en el que los secretos de la vida real del procesamiento de Big Data en las nubes se examinan con ejem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El libro "Trabaja con BigData en las nubes. Procesando y almacenando datos con ejemplos de Microsoft Azure ¬ª</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/428375/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/un/xm/vy/unxmvydwj2ybjfabsmi3vbdcnsg.jpeg" align="left" alt="imagen"></a>  Aqu√≠ est√° el primer libro originalmente en ruso en el que los secretos de la vida real del procesamiento de Big Data en las nubes se examinan con ejemplos reales. <br><br>  La atenci√≥n se centra en las soluciones de Microsoft Azure y AWS.  Se consideran todas las etapas del trabajo: obtener datos preparados para el procesamiento en la nube, usar almacenamiento en la nube, herramientas de an√°lisis de datos en la nube.  Se presta especial atenci√≥n a los servicios SAAS, se demuestran las ventajas de las tecnolog√≠as en la nube en comparaci√≥n con las soluciones implementadas en servidores dedicados o m√°quinas virtuales. <br><br>  El libro est√° dise√±ado para una amplia audiencia y servir√° como un excelente recurso para el desarrollo de Azure, Docker y otras tecnolog√≠as indispensables, sin las cuales la empresa moderna es impensable. <br><br>  Te invitamos a leer el pasaje "Descarga directa de datos de transmisi√≥n" <br><a name="habracut"></a><br><h3>  10.1  Arquitectura general </h3><br>  En el cap√≠tulo anterior, examinamos la situaci√≥n en la que muchas aplicaciones cliente deben enviar una gran cantidad de mensajes que deben procesarse din√°micamente, colocarse en el repositorio y luego procesarse nuevamente en √©l.  Al mismo tiempo, es necesario poder cambiar la l√≥gica del procesamiento de datos y el flujo de almacenamiento sin tener que recurrir a cambiar el c√≥digo del cliente.  Y, por √∫ltimo, desde el punto de vista de las razones de seguridad, los clientes deber√≠an tener el derecho de hacer una sola cosa: enviar mensajes o recibirlos, pero de ninguna manera leer datos o eliminar bases de datos, y no deber√≠an tener derechos directos para escribir estos datos. <br><br>  Dichas tareas son muy comunes en sistemas que trabajan con dispositivos IoT conectados a trav√©s de una conexi√≥n a Internet, as√≠ como en sistemas de an√°lisis de registros en l√≠nea.  Adem√°s de los requisitos enumerados anteriormente para nuestro servicio dedicado, hay dos requisitos m√°s relacionados con los detalles de la "Internet de las cosas" y para garantizar el procesamiento confiable de mensajes.  En primer lugar, el protocolo de interacci√≥n entre el cliente y el receptor del servicio debe ser muy simple para que pueda implementarse en un dispositivo con capacidades inform√°ticas limitadas y memoria muy limitada (por ejemplo, Arduino, Intel Edison, STM32 Discovery y otras plataformas "inapropiadas", como como antes RaspberryPi).  El siguiente requisito es la entrega confiable de mensajes independientemente de las posibles fallas en los servicios de procesamiento.  Este es un requisito m√°s fuerte que el requisito de alta confiabilidad.  De hecho, para garantizar la confiabilidad general de todo el sistema, es necesario que la confiabilidad de todos sus componentes sea lo suficientemente alta y la adici√≥n de un nuevo componente no conduzca a un aumento notable en el n√∫mero de fallas.  Adem√°s de la falla en la infraestructura de la nube, puede ocurrir un error en el servicio creado por el usuario.  E incluso entonces, el mensaje debe procesarse tan pronto como se restablezca el servicio del usuario.  Para hacer esto, el servicio de recepci√≥n de flujo de mensajes debe almacenar de manera confiable el mensaje hasta que se procese o hasta que expire su vida √∫til (esto es necesario para evitar el desbordamiento de memoria durante un flujo continuo de mensajes).  Un servicio con estas propiedades se llama Event Hub.  Para los dispositivos IoT hay centros especializados (IoT Hub), que tienen una serie de otras propiedades que son muy importantes para usar en conjunto con los dispositivos de Internet de las cosas (por ejemplo, comunicaci√≥n bidireccional desde un punto, enrutamiento de mensajes incorporado, "dobles digitales" del dispositivo y una serie de otros)  Sin embargo, estos servicios a√∫n est√°n especializados y no los consideraremos en detalle. <br><br>  Antes de pasar al concepto de concentraci√≥n de mensajes, pasemos a las ideas subyacentes. <br><br>  Supongamos que tenemos una fuente de mensajes (por ejemplo, solicitudes de un cliente) y un servicio que deber√≠a manejarlos.  El procesamiento de una sola solicitud lleva tiempo y requiere recursos computacionales (CPU, memoria, IOPS).  Adem√°s, durante el procesamiento de una solicitud, las solicitudes restantes no se pueden procesar.  Para que las aplicaciones cliente no se congelen mientras esperan que se lance un servicio, es necesario separarlas con la ayuda de un servicio adicional que se encargar√° de almacenar los mensajes mientras esperan el procesamiento mientras est√°n en la cola.  Esta separaci√≥n tambi√©n es necesaria para aumentar la confiabilidad general del sistema.  De hecho, el cliente env√≠a un mensaje al sistema, pero el servicio de procesamiento puede "caerse", pero el mensaje no debe perderse, debe almacenarse en un servicio que sea m√°s confiable que el servicio de procesamiento.  La versi√≥n m√°s simple de dicho servicio se llama cola (Fig. 10.1). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ql/8v/vn/ql8vvnkz7cm8mkc0mrgtrdczzae.png" alt="imagen"></div><br>  El servicio de cola funciona de la siguiente manera: el cliente conoce la URL de la cola y tiene claves de acceso.  Usando el SDK o API de la cola, el cliente coloca un mensaje que contiene la marca de tiempo, el identificador y el cuerpo del mensaje con una carga √∫til en formato JSON, XML o binario. <br><br>  El c√≥digo del programa del servicio incluye un ciclo que "escucha" la cola, recuperando el siguiente mensaje en cada paso, y si hay un mensaje en la cola, se extrae y procesa.  Si el servicio procesa con √©xito el mensaje, se elimina de la cola.  Si se produce un error durante el procesamiento, no se elimina y puede procesarse nuevamente cuando se inicia una nueva versi√≥n del servicio, con el c√≥digo corregido.  La cola est√° dise√±ada para sincronizar un cliente (o un grupo de clientes similares) y exactamente un servicio de procesamiento (aunque este √∫ltimo puede ubicarse en un cl√∫ster de servidores o en una granja de servidores).  Los servicios de Cloud Queuing incluyen Azure Storage Queue, Azure Service Bus Queue y AWS SQS.  Los servicios alojados en m√°quinas virtuales incluyen RabbitMQ, ZeroMQ, MSMQ, IBM MQ, etc. <br><br>  Los diferentes servicios de cola garantizan diferentes tipos de entrega de mensajes: <br><ul><li>  Entrega de mensajes al menos una vez </li><li>  estrictamente entrega de una sola vez; </li><li>  entrega de mensajes mientras se mantiene el orden; </li><li>  entrega de mensajes sin mantener el orden. </li></ul><br>  La cola proporciona una entrega confiable de mensajes de una fuente a un servicio de procesamiento, es decir, interacci√≥n uno a uno.  Pero, ¬øqu√© sucede si es necesario enviar mensajes a varios servicios?  En este caso, debe usar un servicio llamado "tema" (tema) (Fig. 10.2). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wo/mi/6i/womi6if7bwniohwxjvik1r68v_4.png" alt="imagen"></div><br>  Un elemento importante de esta arquitectura son las "suscripciones".  Esta es la ruta registrada en la secci√≥n a lo largo de la cual se env√≠a el mensaje.  Los mensajes son publicados en el tema por el cliente y transferidos a una de las suscripciones, de donde los extrae uno de los servicios y los procesa.  Los temas proporcionan una arquitectura de interacci√≥n de servicio al cliente de uno a muchos.  Ejemplos de tales servicios incluyen el tema del Bus de servicio de Azure y AWS SNS. <br><br>  Ahora suponga que hay una gran cantidad de clientes heterog√©neos que necesitan enviar muchos mensajes a varios servicios, es decir, necesitamos construir un sistema de interacci√≥n de muchos a muchos.  Por supuesto, dicha arquitectura se puede construir utilizando varias secciones, pero dicha construcci√≥n no es escalable y requiere un esfuerzo de administraci√≥n y monitoreo.  Sin embargo, hay servicios separados: concentradores de mensajes (Fig. 10.3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5t/na/sg/5tnasgyiet_8zcd0zmtvxj4koeg.png" alt="imagen"></div><br>  El centro acepta mensajes de muchos clientes.  Todos los clientes pueden enviar mensajes a un punto final de servicio com√∫n o conectarse por separado a diferentes puntos finales a trav√©s de teclas especiales.  Estas teclas le permiten administrar clientes de manera flexible: desconecte algunos, conecte otros nuevos, etc. Dentro del concentrador tambi√©n hay particiones.  Pero en este caso, se pueden distribuir entre todos los clientes para aumentar la productividad (round robin - "con adici√≥n c√≠clica") o el cliente puede publicar mensajes en una de las secciones.  Por otro lado, los servicios de procesamiento se combinan en grupos de consumidores.  Uno o varios servicios se pueden conectar a un grupo.  Por lo tanto, un concentrador de mensajes es el servicio m√°s flexible que se puede configurar como una cola, secci√≥n o grupo de colas, o un conjunto de secciones.  En general, un concentrador de mensajes proporciona una relaci√≥n de muchos a muchos entre clientes y servicios.  Estos centros incluyen Apache Kafka, Azure Event Hub y AWS Kinesis Stream. <br><br>  Antes de mirar los servicios de PaaS basados ‚Äã‚Äãen la nube, prestaremos atenci√≥n a un servicio muy poderoso y conocido: Apache Kafka.  En entornos de nube, se puede acceder como una distribuci√≥n implementada directamente en un cl√∫ster de m√°quinas virtuales o utilizando el servicio HDInsight.  Entonces, Apache Kafka es un servicio que proporciona las siguientes caracter√≠sticas: <br><ul><li>  Publicar y suscribirse a un flujo de mensajes </li><li>  almacenamiento confiable de mensajes; </li><li>  Aplicaci√≥n de servicios de procesamiento de mensajes de transmisi√≥n de terceros. </li></ul><br>  F√≠sicamente, Kafka se ejecuta en un cl√∫ster de uno o m√°s servidores.  Kafka proporciona una API para interactuar con clientes externos (Fig. 10.4). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/50/ug/gz50ugazn-xwectzo--c8pulh4c.png" alt="imagen"></div><br>  Considere estas API en orden. <br><ul><li>  Las API de proveedores permiten que las aplicaciones cliente publiquen flujos de mensajes en uno o m√°s temas de Kafka. </li><li>  Las API del consumidor brindan a las aplicaciones del cliente la capacidad de suscribirse a uno o m√°s temas y procesar los flujos de mensajes entregados por los temas a los clientes. </li><li>  Las API del procesador de transmisi√≥n permiten que las aplicaciones interact√∫en con el cl√∫ster Kafka como procesador de transmisi√≥n.  Las fuentes para un procesador pueden ser uno o m√°s temas.  En este caso, los mensajes procesados ‚Äã‚Äãtambi√©n se colocan en uno o m√°s temas. </li><li>  Las API de conector ayudan a conectar fuentes de datos externas (por ejemplo, RDB) como fuentes de mensajes (por ejemplo, es posible interceptar eventos de cambio de datos en la base de datos) y como receptores. </li></ul><br>  En Kafka, la interacci√≥n entre los clientes y el cl√∫ster se realiza a trav√©s de TCP, que se ve facilitada por los SDK existentes para varios lenguajes de programaci√≥n, incluido .Net.  Pero los lenguajes b√°sicos del SDK son Java y Scala. <br><br>  En un cl√∫ster, el almacenamiento de flujos de mensajes (en la terminolog√≠a de Kafka tambi√©n denominada entradas) se produce l√≥gicamente en objetos llamados temas (Fig. 10.5).  Cada registro consta de una clave, un valor y una marca de tiempo.  En esencia, un tema es una secuencia de registros (mensajes) que han sido publicados por los clientes.  Los temas de Kafka admiten de 0 a varios suscriptores.  Cada tema se representa f√≠sicamente como un registro particionado.  Cada secci√≥n es una secuencia ordenada de registros, a los que se agregan constantemente nuevos que llegan a la entrada de Kafka. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qn/yi/wu/qnyiwuqtcxijhasj3iz7q8eh4jm.png" alt="imagen"></div><br>  Cada entrada en la secci√≥n corresponde a un n√∫mero en la secuencia, tambi√©n llamado desplazamiento, que identifica de manera √∫nica este mensaje en la secuencia.  A diferencia de la cola, Kafka elimina el mensaje no despu√©s de procesar el servicio, sino despu√©s de la vida √∫til de los mensajes.  Esta es una propiedad muy importante, ya que brinda la capacidad de leer un tema a diferentes consumidores.  Adem√°s, se asocia un sesgo con cada consumidor (Fig. 10.6).  Y cada acto de lectura solo conduce a un aumento en el valor para cada cliente individualmente y es determinado precisamente por el cliente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mj/1b/mk/mj1bmkl7ooowixrdekhfg3-bix8.png" alt="imagen"></div><br>  En el caso normal, este desplazamiento aumenta en uno despu√©s de leer con √©xito un mensaje del tema.  Pero si es necesario, el cliente puede cambiar este desplazamiento y repetir la operaci√≥n de lectura. <br><br>  Usar el concepto de secciones tiene los siguientes objetivos. <br><br>  En primer lugar, las secciones proporcionan la capacidad de escalar temas cuando un tema no cabe dentro del mismo nodo.  Al mismo tiempo, cada secci√≥n tiene un nodo principal (no lo confunda con el nodo principal de todo el cl√∫ster) y cero o varios nodos seguidores.  El nodo principal es responsable del procesamiento de las operaciones de lectura / escritura, mientras que los seguidores son sus copias pasivas.  Si el nodo maestro falla, uno de los nodos sucesores se convertir√° autom√°ticamente en el nodo principal.  Cada nodo del cl√∫ster es el l√≠der de algunas secciones y un seguidor de otras.  En segundo lugar, dicha replicaci√≥n aumenta el rendimiento de lectura debido a la posibilidad de operaciones de lectura paralelas. <br><br>  El productor puede colocar el mensaje en cualquier tema de su elecci√≥n expl√≠citamente o en modo round robin impl√≠citamente (es decir, con relleno uniforme).  Los consumidores est√°n unidos en los llamados grupos de consumidores, y cada mensaje publicado en el tema se entrega a un cliente en cada grupo de consumidores.  Los clientes en este caso pueden alojarse f√≠sicamente en uno o m√°s servidores / m√°quinas virtuales.  Con m√°s detalle, la entrega del mensaje es la siguiente.  Para todos los clientes que pertenecen al mismo grupo de consumidores, los mensajes se pueden distribuir entre los clientes para optimizar la carga.  Si los clientes pertenecen a diferentes grupos de consumidores, cada mensaje se enviar√° a cada grupo.  La separaci√≥n de mensajes de secciones por diferentes grupos de consumidores se muestra en la Fig.  10.7 <br><br>  Ahora describir√© brevemente los principales par√°metros de entrega y almacenamiento de mensajes garantizados por Kafka. <br><ul><li>  Los mensajes enviados por el fabricante a un tema espec√≠fico se agregar√°n estrictamente en el orden en que fueron enviados. </li><li>  El cliente ve el orden de los mensajes en el tema que se recibi√≥ cuando se guardaron los mensajes.  Como resultado, los mensajes se entregan del productor al consumidor estrictamente en el orden en que se reciben. </li><li>  La replicaci√≥n N-fold del tema garantiza la estabilidad del tema ante el fallo de los nodos N-1 sin p√©rdida de rendimiento. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rf/qp/ms/rfqpmsno04krpiqxhs1qv8agwhu.png" alt="imagen"></div><br>  Por lo tanto, el servicio Apache Kafka se puede usar en los siguientes modos. <br><br><ul><li>  Servicio: agente de mensajes (cola) o servicio de publicaci√≥n: suscripci√≥n de mensajes (tema).  De hecho, Kafka se basa en un grupo de temas que se pueden convertir en una cola con un suscriptor.  (Debe recordarse: en contraste con los servicios habituales de intermediario de mensajes, basados ‚Äã‚Äãen el principio de las colas, en Kafka los mensajes se eliminan solo despu√©s de que su vida haya expirado, mientras que los intermediarios implementan el principio Peek-Delete, es decir, recuperaci√≥n y eliminaci√≥n despu√©s de un procesamiento exitoso. ) El principio de grupos de consumidores resume estos dos conceptos, y la capacidad de publicar mensajes en todos los temas con la distribuci√≥n de round robin hace de Kafka un agente de mensajes universal multimodo. </li><li>  Servicio de an√°lisis de mensajes en streaming.  Esto es posible gracias a la API para procesadores de transmisi√≥n incluidos en Kafka, que le permite construir sistemas complejos, creados sobre la base de Event Driven, con servicios que filtran mensajes o responden a ellos, as√≠ como servicios que agregan mensajes. </li></ul><br>  Todas estas propiedades permiten utilizar Kafka como un componente clave de una plataforma que funciona con la transmisi√≥n de datos y tiene grandes capacidades para construir sistemas complejos de procesamiento de mensajes.  Pero al mismo tiempo, Kafka es bastante complicado en t√©rminos de implementaci√≥n y configuraci√≥n de un cl√∫ster de varios nodos, lo que requiere un esfuerzo administrativo significativo.  Pero, por otro lado, dado que las ideas subyacentes a Kafka son muy adecuadas para construir sistemas, transmitir mensajes y recibir mensajes, los proveedores de la nube brindan servicios de PaaS que implementan estas ideas y ocultan todas las dificultades de construir y administrar un cl√∫ster de Kafka.  Pero dado que estos servicios tienen una serie de restricciones en t√©rminos de personalizaci√≥n y expansi√≥n m√°s all√° de los l√≠mites asignados para los servicios, los proveedores de la nube proporcionan servicios especiales IaaS / PaaS para el despliegue f√≠sico de Kafka en un cl√∫ster de m√°quinas virtuales.  En este caso, el usuario tiene una libertad casi completa de configuraci√≥n y expansi√≥n.  Estos servicios incluyen Azure HDInsight.  Ya se ha mencionado anteriormente.  Fue creado para, por un lado, proporcionar al usuario servicios del ecosistema Hadoop por su cuenta, sin envoltorios externos y, por otro lado, para aliviar las dificultades derivadas de la instalaci√≥n, administraci√≥n y configuraci√≥n directa de IaaS.  El alojamiento Docker est√° un poco apartado.  Dado que este es un tema extremadamente importante, lo consideraremos, pero primero nos familiarizaremos con los servicios de PaaS implementados utilizando los conceptos b√°sicos de Kafka. <br><br><h3>  10.2  Centro de eventos de Azure </h3><br>  Considere el servicio de concentrador de mensajes de Azure Event Hub.  Es un servicio basado en el modelo PaaS.  Varios grupos de clientes pueden actuar como or√≠genes de mensajes para Azure Event Hub (Figura 10.8).  En primer lugar, este es un grupo muy grande de servicios en la nube cuyas salidas o disparadores se pueden configurar para enviar mensajes directamente al Event Hub.  Estos pueden ser Stream Analytics Job, Event Grid y un grupo significativo de servicios que redirigen eventos: registros en Event Hub (creados principalmente con AppService: aplicaci√≥n Api, aplicaci√≥n web, aplicaci√≥n m√≥vil y aplicaci√≥n de funci√≥n). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/th/wr/-y/thwr-yanwimel2wqzorsolaojxo.png" alt="imagen"></div><br>  Los mensajes entregados al concentrador pueden capturarse directamente y almacenarse en Blob Storage o Data Lake Store. <br><br>  El siguiente grupo de fuentes son los clientes o dispositivos de software externos para los cuales no hay SDK de Azure Event Hub y que no pueden integrarse directamente con los servicios de Azure.  Estos clientes incluyen principalmente dispositivos IoT.  Pueden enviar mensajes al Event Hub a trav√©s de HTTPS o AMQP.  La consideraci√≥n de c√≥mo conectar estos dispositivos est√° m√°s all√° del alcance de nuestro libro. <br><br>  Finalmente, los clientes de software que generan mensajes y los env√≠an a Event Hub mediante el SDK de Azure Event Hub.  Este grupo incluye Azure PowerShell y la CLI de Azure. <br>  Como receptores de mensajes (consumidores - "consumidores") del Event Hub, Stream Analytics Job o el servicio de integraci√≥n Event Grid se pueden utilizar.  Adem√°s, es posible recibir mensajes de clientes de software mediante el SDK de Azure Event Hub.  Los consumidores se conectan al Event Hub utilizando el protocolo AMQP 1.0. <br><br>  Considere los conceptos b√°sicos de Azure Event Hub necesarios para comprender c√≥mo usarlo y configurarlo.  Cualquier fuente (tambi√©n llamada editor en la documentaci√≥n) que env√≠e un mensaje al concentrador debe usar el protocolo HTTPS o AMQP 1.0.  La elecci√≥n de un protocolo est√° determinada por el tipo de cliente, la red de comunicaci√≥n y los requisitos de velocidad de mensajes.  AMQP requiere una conexi√≥n permanente entre dos sockets TCP bidireccionales.  Est√° protegido mediante el uso del protocolo de cifrado de la capa de transporte TLS o SSL / TLS.   ,  ,       AMQP   ,  HTTPS,          .      HTTPS. <br><br>     ,         SAS (Shared Access Signature) tokens.          SAS-          SAS   .      SAS-,      (  ). <br><br>         256 .  ,                  . <br><br>  ,      Event Hub.      ,        ,      ,     -.   EventHub     (partitions).   EventHub ‚Äî    ,     ¬´  ‚Äî  ¬ª (FIFO) (. 10.9). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iq/2g/_p/iq2g_p_ldvolfuahy8admgxqhzo.png" alt="imagen"></div><br>   ‚Äî       Event Hub.  Event Hub    2  32 ,          Event Hub.   ,          . <br><br>    (    )    ,      (    ,     ‚Äî . ),       (retention period),   .   .           .       ,  Azure Event Hub    (offset).     ‚Äî    ,      ,  ,  ,      .          . Azure Event Hub SDK    ,     ,     .       -,         . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fe/ab/bc/feabbcymdq52xiddkbp2vcajz-k.png" alt="imagen"></div><br>  ,          ,     ,       ,    .   Azure Event Hub SDK     ,        .  ,     Storage Account.  Azure,     Event Hub,       . <br><br>     Event Hub     (partition key),          .    ‚Äî   . ,         (    )          .        ,       (round robin). <br><br>       .      ,       (consumer group) (. 10.11).             .             (view) (     ) ,  ,     .        ,       .     ‚Äî 20,            ,            . <br><br>          .  ,              .    ,     (throughput unit).         : <br><ul><li>    ‚Äî 1 M    1000    (   ,       ); </li><li>    ‚Äî 2 M  . </li></ul><br>         .      ,     .           .         .  Ten cuidado  ,     ,    ,       Event Hub. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i_/l0/jc/i_l0jcqwomkuargf-sygdrfufdc.png" alt="imagen"></div><br>        (namespace) (. 10.12). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jf/de/h-/jfdeh-khouxn6olnkxcgw6-w1a4.png" alt="imagen"></div><br><br>  ¬ªSe puede encontrar m√°s informaci√≥n sobre el libro en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sitio web del editor</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contenidos</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Extracto</a> <br><br>  <b>Cup√≥n de</b> 20% de descuento para <b>vendedores ambulantes</b> - <b>BigData</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428375/">https://habr.com/ru/post/es428375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428365/index.html">La historia de c√≥mo cambi√≥ la facturaci√≥n de Google o c√≥mo evitar costos innecesarios</a></li>
<li><a href="../es428367/index.html">Creamos el m√≥dem sonar m√°s peque√±o del mundo</a></li>
<li><a href="../es428369/index.html">Salir de la rueda de Sansara, el extremismo y un poco de cosas verdes: un an√°lisis de las tareas del folleto GridGain en la conferencia Joker 2018</a></li>
<li><a href="../es428371/index.html">Viejo juego de IBM</a></li>
<li><a href="../es428373/index.html">iPhone es inc√≥modo de usar</a></li>
<li><a href="../es428377/index.html">Biomarcadores epigen√©ticos del envejecimiento</a></li>
<li><a href="../es428379/index.html">El verdadero proceso de dise√±o. Una historia paso a paso sobre c√≥mo crear un sitio web orientado a los negocios</a></li>
<li><a href="../es428381/index.html">Inversi√≥n de $ 10 millones y elogios de Wozniak: un largo camino para crear un dise√±ador de computadoras para ni√±os</a></li>
<li><a href="../es428383/index.html">Sony ha publicado una lista completa de juegos para PlayStation Classic</a></li>
<li><a href="../es428385/index.html">M√°s caf√©, menos cafe√≠na: Intel 9th ‚Äã‚ÄãGen (parte 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>