<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>帮   Pruebas de regresi贸n visual. Reiniciar   う</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En mi art铆culo anterior habl茅 sobre la experiencia de usar el motor Gemini para desarrollar pruebas visuales, o m谩s bien, pruebas de regresi贸n visual....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas de regresi贸n visual. Reiniciar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/479040/">  En mi <a href="https://habr.com/ru/post/454464/">art铆culo</a> anterior habl茅 sobre la experiencia de usar el motor <a href="https://github.com/gemini-testing/gemini">Gemini</a> para desarrollar pruebas visuales, o m谩s bien, pruebas de regresi贸n visual.  Dichas pruebas verifican si algo se ha "movido" en la interfaz de usuario despu茅s de los siguientes cambios comparando las capturas de pantalla actuales con las de referencia fijadas anteriormente.  Desde entonces, mucho ha cambiado en nuestros enfoques para escribir pruebas visuales, incluido el motor utilizado.  Ahora usamos a <a href="https://github.com/gemini-testing/hermione">Hermione</a> , pero en este art铆culo voy a contar no solo y no tanto sobre Hermione, sino tambi茅n sobre los problemas que se han acumulado desde entonces y c贸mo resolverlos, lo que, entre otras cosas, condujo a la transici贸n a un nuevo motor. <br><a name="habracut"></a><br>  En primer lugar, aunque las pruebas funcionaron, y con bastante 茅xito, no ten铆amos una comprensi贸n clara de lo que estaba cubierto por las pruebas y lo que no.  Hab铆a, por supuesto, alguna idea del grado de cobertura, pero no lo medimos cuantitativamente.  En segundo lugar, la composici贸n de las pruebas aument贸 con el tiempo y diferentes pruebas a menudo probaron lo mismo, porque  en diferentes capturas de pantalla, alguna parte coincidi贸 con la misma parte, pero en una captura de pantalla diferente.  Como resultado, incluso cambios menores en CSS podr铆an abrumar muchas pruebas a la vez y requerir la actualizaci贸n de una gran cantidad de est谩ndares.  En tercer lugar, apareci贸 un tema oscuro en nuestro producto, y para cubrirlo de alguna manera con pruebas, algunas pruebas se cambiaron selectivamente para usar un tema oscuro, que tampoco agreg贸 claridad al problema con la determinaci贸n del grado de cobertura. <br><br><h2>  Optimizaci贸n del rendimiento </h2><br>  Comenzamos, curiosamente, con un rendimiento optimizado.  Explicar茅 por qu茅.  Nuestras pruebas visuales se basan en el <a href="https://github.com/storybooks/storybook">libro de cuentos</a> .  Cada historia en el libro de cuentos no es un componente 煤nico, sino un "bloque" completo (por ejemplo, una cuadr铆cula con una lista de entidades, una tarjeta de entidad, di谩logo o incluso la aplicaci贸n en su conjunto).  Para mostrar este bloque, debe "bombear" la historia con datos, no solo los datos que se muestran al usuario, sino tambi茅n el estado de los componentes utilizados dentro del bloque.  Esta informaci贸n se almacena junto con el c贸digo fuente en forma de archivos json que contienen una representaci贸n serializada del estado de la aplicaci贸n (tienda redux).  S铆, esta informaci贸n es, por decirlo suavemente, redundante, pero simplifica enormemente la creaci贸n de pruebas.  Para crear una nueva prueba, simplemente abrimos la tarjeta, lista o cuadro de di谩logo deseados en la aplicaci贸n, tomamos una instant谩nea del estado actual de la aplicaci贸n y la serializamos en un archivo.  Luego agregamos una nueva historia y pruebas que toman capturas de pantalla de esta historia (todo en unas pocas l铆neas de c贸digo). <br><br>  Este enfoque inevitablemente aumenta el tama帽o del paquete.  El grado de duplicaci贸n de datos en 茅l simplemente "se transfiere".  Al ejecutar pruebas, el motor gemini ejecuta cada conjunto de pruebas en una sesi贸n de navegador separada.  Cada sesi贸n carga el paquete de nuevo y el tama帽o del paquete en dicho esquema est谩 lejos del 煤ltimo valor. <br><br>  Para reducir el tiempo de ejecuci贸n de la prueba, redujimos el n煤mero de conjuntos de pruebas aumentando el n煤mero de pruebas en ellos.  Por lo tanto, un conjunto de pruebas podr铆a afectar varias historias a la vez.  En este esquema, pr谩cticamente perdimos la capacidad de "filtrar" solo un 谩rea determinada de la pantalla debido al hecho de que Gemini le permite configurar el 谩rea de captura de pantalla solo para el conjunto de pruebas en su conjunto (aunque la API le permite hacer esto antes de cada captura de pantalla, pero en la pr谩ctica no funciona). <br><br>  La incapacidad de limitar el 谩rea de la captura de pantalla en las pruebas condujo a la duplicaci贸n de informaci贸n visual en las im谩genes de referencia.  Si bien no hubo muchas pruebas, este problema no parec铆a significativo.  S铆, y la IU no cambi贸 muy a menudo.  Pero esto no podr铆a continuar para siempre: un redise帽o se avecinaba en el horizonte. <br><br>  Mirando hacia el futuro, dir茅 que en Hermione se puede establecer un 谩rea de captura de pantalla para cada disparo y, a primera vista, cambiar a un nuevo motor resolver铆a todos los problemas.  Pero a煤n tendr铆amos que "aplastar" grandes conjuntos de pruebas.  El hecho es que las pruebas visuales no son inherentemente estables (esto puede deberse a varias razones, por ejemplo, con retrasos en la red, el uso de animaciones o con "clima en Marte") y es muy dif铆cil hacerlo sin reintentos autom谩ticos.  Tanto Gemini como Hermione realizan reintentos para el conjunto de pruebas en su conjunto, y cuanto m谩s "grueso" sea el conjunto de pruebas, es menos probable que se complete con 茅xito durante los reintentos, ya que  en la pr贸xima ejecuci贸n, las pruebas que se completaron con 茅xito anteriormente pueden caer.  Para las suites de prueba gruesas, tuvimos que implementar un esquema de reintento alternativo integrado en el motor Gemini y realmente no quer铆amos hacer esto nuevamente al cambiar a un nuevo motor. <br><br>  Por lo tanto, para acelerar la carga del conjunto de pruebas, dividimos el paquete monol铆tico en partes, asignando cada instant谩nea del estado de la aplicaci贸n en una "pieza" separada, cargada "a pedido" para cada historia por separado.  El c贸digo de creaci贸n de la historia ahora se ve as铆: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// visual-regression.stories.js import React from 'react'; import StoryProvider from './story-provider'; const stories = storiesOf('visual-regression', module); [ { name: 'Contract', loadData: import('./snapshots/contract.testdata') }, { name: 'ExecutionTask', loadData: import('./snapshots/execution-task.testdata') }, { name: 'ExecutionAssignment', loadData: import('./snapshots/execution-assignment.testdata') }, { name: 'DocumentTemplate', loadData: import('./snapshots/document-template.testdata') }, { name: 'Explorer', loadData: import('./snapshots/explorer.testdata') }, { name: 'Inbox', loadData: import('./snapshots/inbox.testdata') }, ] .map(story =&gt; { stories .add(story.name, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} /&gt;) .add(`${story.name}Dark`, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} theme='night' /&gt;); });</span></span></code> </pre> <br>  Para crear una historia, se utiliza el componente StoryProvider (su c贸digo se proporcionar谩 a continuaci贸n).  Las instant谩neas se cargan mediante la funci贸n de <a href="https://webpack.js.org/guides/code-splitting/">importaci贸n din谩mica</a> .  Diferentes historias difieren entre s铆 solo en im谩genes de estados.  Para un tema oscuro, se genera su propia historia, utilizando la misma instant谩nea que la historia para un tema claro.  En el contexto de un libro de cuentos, se ve as铆: <br><br><div class="spoiler">  <b class="spoiler_title">Historia del tema predeterminado</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d6/vc/uk/d6vcukhmensy0jogshjj4hifoui.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Historia oscura del tema</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/jy/z0/uu/jyz0uuyel6t1pofayyjxftuunwg.png"><br></div></div><br>  El componente StoryProvider acepta una devoluci贸n de llamada para cargar una instant谩nea en la que se llama a la funci贸n import ().  La funci贸n import () funciona de forma as铆ncrona, por lo que no puede tomar una captura de pantalla inmediatamente despu茅s de cargar la historia; nos arriesgamos a eliminar el vac铆o.  Para captar el momento del final de la descarga, el proveedor presenta el elemento DOM marcador que indica al motor de prueba durante todo el tiempo de la descarga, que debe retrasarse con la captura de pantalla: <br><br><div class="spoiler">  <b class="spoiler_title">story-provider.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// story-provider.js const propsStub = { // -,      . . . }; type Props = { loadSnapshot: () =&gt; Object, theme: ?string }; const StoryProvider = (props: Props) =&gt; { const [ snapshotState, setsnapshotState ] = React.useState(null); React.useEffect(() =&gt; { //    (async() =&gt; setsnapshotState((await props.loadSnapshot).default))(); }); if (!snapshotState) //     ,     return &lt;div className={'loading-stub'}&gt;Loading...&lt;/div&gt;; //    snapshotState.metadata = require('./snapshots/metadata'); //  redux-   const store = createMockStore(snapshotState); //   applyTheme(props.theme); return ( &lt;Provider store={store}&gt; &lt;MemoryRouter&gt; &lt;App {...propsStub} /&gt; &lt;/MemoryRouter&gt; &lt;/Provider&gt; ); }; export default StoryProvider;</span></span></code> </pre><br></div></div><br>  Adem谩s, para reducir el tama帽o del paquete, deshabilite la adici贸n de mapas de origen al paquete.  Pero para no perder la capacidad de depurar la historia (nunca se sabe qu茅), hacemos esto bajo la condici贸n: <br><br><div class="spoiler">  <b class="spoiler_title">.storybook / webpack.config.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// .storybook/webpack.config.js ... module.exports = { ... devtool: process.env.NODE_ENV === 'vr-test' ? '(none)' : 'eval-source-map' };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">package.json</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// package.json { ... "scripts": { ... "storybook": "start-storybook", "build-storybook": "cross-env NODE_ENV=vr-test build-storybook -o ./storybook-static", ... },</span></span></code> </pre><br></div></div><br>  El <b>script npm run build-storybook</b> compila un libro de cuentos est谩tico sin mapa de origen en la carpeta est谩tica del libro de cuentos.  Se utiliza al realizar pruebas.  Y el <b>script npm run storybook se</b> usa para desarrollar y depurar historias de prueba. <br><br><h2>  Eliminaci贸n de la duplicaci贸n de informaci贸n visual. </h2><br>  Como dije anteriormente, Gemini le permite establecer selectores de 谩rea de captura de pantalla para el conjunto de pruebas en su conjunto, lo que significa que para resolver completamente el problema de duplicar la informaci贸n visual en las capturas de pantalla, tendr铆amos que hacer nuestro propio conjunto de pruebas para cada captura de pantalla.  Incluso teniendo en cuenta la optimizaci贸n de cargar la historia, no parec铆a demasiado optimista en t茅rminos de velocidad y pensamos en cambiar el motor de prueba. <br><br>  En realidad, 驴por qu茅 Hermione?  Actualmente, el repositorio Gemini est谩 marcado como obsoleto y, tarde o temprano, tuvimos que "movernos" a alg煤n lado.  La estructura del archivo de configuraci贸n de Hermione es id茅ntica a la estructura del archivo de configuraci贸n de Gemini y pudimos reutilizar esta configuraci贸n.  Los complementos de G茅minis y Hermione tambi茅n son comunes.  Adem谩s, pudimos reutilizar la infraestructura de prueba: m谩quinas virtuales y red de selenio implementada. <br><br>  A diferencia de Gemini, Hermione no se posiciona como una herramienta solo para pruebas de regresi贸n del dise帽o.  Sus capacidades de manipulaci贸n del navegador son mucho m谩s amplias y limitadas solo por las capacidades de <a href="http://v4.webdriver.io/">Webdriver IO</a> .  En combinaci贸n con <a href="https://github.com/mochajs/mocha">mocha,</a> este motor es conveniente para usar m谩s para pruebas funcionales (simulaci贸n de acciones del usuario) que para pruebas de dise帽o.  Para las pruebas de regresi贸n del dise帽o, Hermione proporciona solo el m茅todo ClaimView (), que compara una captura de pantalla de una p谩gina del navegador con una referencia.  La captura de pantalla se puede limitar al 谩rea especificada mediante los selectores CSS. <br><br>  Para nuestro caso, la prueba para cada historia individual se ver铆a as铆: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    describe('Visual regression', function() { it('Contract card should equal to etalon', function() { return this.browser //  story   .url('http://localhost:8080/iframe.html?selectedKind=visual-regression&amp;selectedStory=ContractDark') // ,      story .waitForVisible('.loading-stub', true) //          .assertView('layout', '.form'); }) });</span></span></code> </pre><br>  El m茅todo waitForVisible (), a pesar de su nombre, le permite esperar no solo la apariencia, sino tambi茅n la ocultaci贸n del elemento, si establece el segundo par谩metro en verdadero.  Aqu铆 lo usamos para esperar a que se oculte un elemento marcador, lo que indica que la instant谩nea de datos a煤n no est谩 cargada y la historia a煤n no est谩 lista para una captura de pantalla. <br><br>  Si intenta encontrar el m茅todo waitForVisible () en la documentaci贸n de Hermione, no encontrar谩 nada.  El hecho es que el <a href="http://v4.webdriver.io/api/utility/waitForVisible.html">m茅todo</a> waitForVisible () <a href="http://v4.webdriver.io/api/utility/waitForVisible.html">es el m茅todo Webdriver IO API</a> .  El m茅todo url (), respectivamente, tambi茅n.  En el m茅todo url (), pasamos la direcci贸n del marco de una historia en particular, no el libro de cuentos completo.  En primer lugar, esto es necesario para que la lista de historias no se muestre en la ventana del navegador; no necesitamos probarla.  En segundo lugar, si es necesario, podemos tener acceso a elementos DOM dentro del marco (los m茅todos webdriverIO le permiten ejecutar c贸digo JavaScript en un contexto de navegador). <br><br>  Para simplificar la escritura de pruebas, creamos nuestro contenedor sobre las pruebas de mocha.  El hecho es que no tiene un sentido particular en la elaboraci贸n detallada de casos de prueba para pruebas de regresi贸n.  Todos los casos de prueba son iguales: "deber铆a ser igual a etalon".  Bueno, tampoco quiero duplicar el c贸digo para esperar la carga de datos en cada prueba.  Por lo tanto, el mismo trabajo para todas las pruebas "mono" se delega a la funci贸n de envoltura, y las pruebas mismas se escriben de manera declarativa (bueno, casi).  Aqu铆 est谩 el texto de esta funci贸n: <br><br><div class="spoiler">  <b class="spoiler_title">create-test-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> themes = [ <span class="hljs-string"><span class="hljs-string">'default'</span></span>, <span class="hljs-string"><span class="hljs-string">'dark'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootClassName = <span class="hljs-string"><span class="hljs-string">'.explorer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadingStubClassName = <span class="hljs-string"><span class="hljs-string">'.loading-stub'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timeout = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTestSuite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">testSuite</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, storyName, browsers, testCases, selector } = testSuite; <span class="hljs-comment"><span class="hljs-comment">//  ,       browsers &amp;&amp; hermione.only.in(browsers); //      themes.forEach(theme =&gt; { describe(`${name}_${theme}`, () =&gt; it('should equal to etalon', function() { let browser = this.browser //   story .url(`${storybookUrl}/iframe.html?selectedKind=visual-regression&amp;selectedStory=${storyName}-${theme}`) //     .waitForVisible(loadingStubClassName, timeout, true) .waitForVisible(rootClassName); //    (  ) if (testCases &amp;&amp; testCases.length &gt; 0) { testCases.forEach(testCase =&gt; { if (testCase.before) browser = testCase.before(browser); browser = browser.assertView(`${name}__${testCase.name}_${theme}`, testCase.selector || selector || rootClassName, testCase.options); }); return browser; } //    ,    return browser.assertView(`${name}_${theme}`, selector || rootClassName); })); }); }</span></span></code> </pre><br></div></div><br>  Un objeto que describe el conjunto de pruebas se pasa a la entrada de la funci贸n.  Cada conjunto de pruebas se construye de acuerdo con el siguiente escenario: tome una captura de pantalla del dise帽o principal (por ejemplo, un 谩rea de una tarjeta de entidad o un 谩rea de una lista de entidades), luego presione program谩ticamente los botones que pueden dar lugar a la aparici贸n de otros elementos (por ejemplo, paneles emergentes o men煤s contextuales) y tome una captura de pantalla 禄Cada uno de esos elementos por separado.  Por lo tanto, simulamos acciones del usuario en el navegador, pero no con el objetivo de probar un escenario empresarial, sino simplemente para "capturar" el m谩ximo n煤mero posible de componentes visuales.  Adem谩s, la duplicaci贸n de informaci贸n visual en las capturas de pantalla es m铆nima, porque  las capturas de pantalla se toman "puntiagudas" utilizando selectores.  Ejemplo de suite de prueba: <br><br><div class="spoiler">  <b class="spoiler_title">explorer-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// explorer-suite.js //         module.exports = { //  story,    storyName: 'explorer', //    name: 'explorer', //  ,       browsers: [ 'chrome-1920x1080', 'ie-1920x1080' ], //   testCases: [ { //    name: 'layout' }, { //    name: 'notification-area', selector: '.notification-area__popup', before: b =&gt; b .click('.notification-area__popup-button') .waitForVisible('.notification-area__popup') .execute(function() { //       document.querySelectorAll('.expandable-item__content')[2].click(); }) }, //... ] };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">tests.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tests.js [ require('./suites/explorer-suite'), //... ] .forEach(suite =&gt; createTestSuite(suite));</span></span></code> </pre><br></div></div><br><h2>  Determinaci贸n de cobertura </h2><br>  Entonces, descubrimos la velocidad y la redundancia, queda por determinar la efectividad de nuestras pruebas, es decir, determinar el grado de cobertura del c贸digo con las pruebas (aqu铆 por c贸digo me refiero a las hojas de estilo CSS). <br><br>  Para las historias de prueba, seleccionamos emp铆ricamente las tarjetas, listas y otros elementos m谩s complicados para llenar para cubrir tantos estilos como sea posible con una captura de pantalla.  Por ejemplo, para probar una tarjeta de entidad, se seleccionaron tarjetas con una gran cantidad de diferentes tipos de controles (texto, n煤mero, transferencias, fechas, cuadr铆culas, etc.).  Las tarjetas para diferentes tipos de entidades tienen sus propios detalles, por ejemplo, desde una tarjeta de documentos puede mostrar un panel con una lista de versiones de documentos, y la tarjeta de tareas muestra la correspondencia para esta tarea.  En consecuencia, para cada tipo de entidad, se cre贸 su propia historia y un conjunto de pruebas espec铆ficas para este tipo, etc.  Al final, pensamos que todo parec铆a estar cubierto con pruebas, pero quer铆amos un poco m谩s de confianza que "me gusta". <br><br>  Para evaluar la cobertura en Chrome DevTools, hay una herramienta con el nombre Cobertura muy adecuada para este caso: <br><br><img src="https://habrastorage.org/webt/ma/yt/dh/maytdhehcjiumoxdsdj-woa40lo.png"><br><br>  La cobertura le permite determinar qu茅 estilos o qu茅 c贸digo js se utiliz贸 al trabajar con la p谩gina del navegador.  El informe sobre el uso de rayas verdes indica el c贸digo utilizado, rojo - no utilizado.  Y todo estar铆a bien si tuvi茅ramos una aplicaci贸n del nivel "hola, mundo", pero 驴qu茅 hacer cuando tenemos miles de l铆neas de c贸digo?  Los desarrolladores de cobertura lo entendieron bien y proporcionaron la capacidad de exportar el informe a un archivo que ya se puede resolver mediante programaci贸n. <br><br>  Debo decir de inmediato que hasta ahora no hemos encontrado una manera de cobrar el grado de cobertura autom谩ticamente.  Te贸ricamente, esto se puede hacer usando el navegador sin cabeza de Pupeteer, pero Pupeteer no funciona bajo el control de selenio, lo que significa que no podremos reutilizar el c贸digo de nuestras pruebas.  Entonces, por ahora, omita este tema extremadamente interesante y trabajemos con bol铆grafos. <br><br>  Despu茅s de ejecutar las pruebas en modo manual, obtenemos un informe de cobertura, que es un archivo json.  En el informe para cada css, js, ts, etc.  el archivo indica su texto (en una l铆nea) y los intervalos del c贸digo utilizado en este texto (en forma de 铆ndices de caracteres de esta l铆nea).  A continuaci贸n se muestra una parte del informe: <br><br><div class="spoiler">  <b class="spoiler_title">cobertura.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/theme-default.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">8127</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... --theme_primary-accent: #5b9bd5;\r\n --theme_primary-light: #ffffff;\r\n --theme_primary: #f4f4f4;\r\n ..."</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/main.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">610</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">728</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">754</span></span> } ] <span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... \r\n line-height:1;\r\n}\r\n\r\nol, ul{\r\n list-style:none;\r\n}\r\n\r\nblockquote, q..."</span></span> ]</code> </pre><br></div></div><br>  A primera vista, no hay nada dif铆cil en encontrar selectores CSS no utilizados.  Pero entonces, 驴qu茅 hacer con esta informaci贸n?  De hecho, en el an谩lisis final, necesitamos encontrar no selectores espec铆ficos, sino componentes que olvidamos cubrir con las pruebas.  Los estilos de un componente pueden ser configurados por m谩s de una docena de selectores.  Como resultado, de acuerdo con los resultados del an谩lisis del informe, obtenemos cientos de selectores no utilizados, y si trata con cada uno de ellos, puede matar mucho tiempo. <br><br>  Aqu铆, las expresiones regulares nos ayudan.  Por supuesto, solo funcionar谩n si se cumplen las convenciones de nomenclatura para las clases css (en nuestro c贸digo, las clases css se nombran de acuerdo con la metodolog铆a BEM - block_name_name_name_modifier).  Usando expresiones regulares, calculamos los valores 煤nicos de los nombres de bloque, que ya no son dif铆ciles de asociar con los componentes.  Por supuesto, tambi茅n estamos interesados en elementos y modificadores, pero no en primer lugar, primero debemos tratar con un "pez" m谩s grande.  A continuaci贸n se muestra una secuencia de comandos para procesar un informe de cobertura <br><br><div class="spoiler">  <b class="spoiler_title">cobertura.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> modules = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./coverage.json'</span></span>).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> e.url.endsWith(<span class="hljs-string"><span class="hljs-string">'.css'</span></span>)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module, rangeStart, rangeEnd, isUsed</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rules = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.text.slice(rangeStart, rangeEnd); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> regex = <span class="hljs-regexp"><span class="hljs-regexp">/^\.([^\d{:,)_ ]+-?)+/gm</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classNames = rules.match(regex); classNames &amp;&amp; classNames.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> selectors[name] = selectors[name] || isUsed); } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previousEnd, selectors = {}; modules.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function"> =&gt;</span></span> { previousEnd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.ranges) { processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, range.start, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, range.start, range.end, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); previousEnd = range.end; } processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.length, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'className;isUsed'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(selectors).sort().forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${s}</span></span></span><span class="hljs-string">;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${selectors[s]}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre><br></div></div><br>  Ejecutamos el script colocando primero el archivo coverage.json exportado desde Chrome DevTools y escribiendo el escape en un archivo .csv: <br><br>  <b>Nodo cobertura.js&gt; cobertura.csv</b> <br><br>  Puede abrir este archivo con Excel y analizar los datos, incluida la determinaci贸n del porcentaje de cobertura de c贸digo por pruebas. <br><br><img src="https://habrastorage.org/webt/gh/ss/b8/ghssb8zrlh41pakcvwhyl6fcjge.png"><br><br><h2>  En lugar de un curriculum vitae </h2><br>  Usar el libro de cuentos como base para las pruebas visuales se ha justificado por completo: tenemos un grado suficiente de cobertura del c贸digo CSS con pruebas con un n煤mero relativamente peque帽o de historias y costos m铆nimos para crear nuevas. <br><br>  La transici贸n a un nuevo motor nos permiti贸 eliminar la duplicaci贸n de informaci贸n visual en las capturas de pantalla, lo que simplific贸 enormemente el soporte de las pruebas existentes. <br><br>  El grado de cobertura del c贸digo CSS se puede medir y, de vez en cuando, se supervisa.  Por supuesto, hay una gran pregunta: c贸mo no olvidar la necesidad de este control y c贸mo no perder algo en el proceso de recopilaci贸n de informaci贸n sobre la cobertura.  Idealmente, me gustar铆a medir el grado de cobertura autom谩ticamente en cada ejecuci贸n de prueba, de modo que cuando se alcanza el umbral especificado, las pruebas caer铆an con un error.  Trabajaremos en esto, si hay noticias, definitivamente te lo dir茅. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/479040/">https://habr.com/ru/post/479040/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479022/index.html">Los televisores inteligentes Samsung, LG, Vizio y TCL toman cada segundo "huellas digitales" de la pantalla y las env铆an al servidor</a></li>
<li><a href="../479026/index.html">Verdadera suma de canales de Internet - OpenMPTCPRouter</a></li>
<li><a href="../479034/index.html">C贸mo conectarse a una VPN corporativa en Linux usando openconnect y vpn-slice</a></li>
<li><a href="../479036/index.html">Intel no puede hacer frente a la demanda de procesadores. HP y Dell sufren como resultado</a></li>
<li><a href="../479038/index.html">Transformaci贸n digital Leroy Merlin: dise帽o de una interfaz para trabajar con llamadas de clientes</a></li>
<li><a href="../479042/index.html">El m茅todo Y es una forma realmente f谩cil de construir un cubo de Rubik</a></li>
<li><a href="../479044/index.html">Mi implementaci贸n de buffer de anillo en flash NOR</a></li>
<li><a href="../479048/index.html">Node.js Streams para dummies o c贸mo trabajar con streams</a></li>
<li><a href="../479050/index.html">Investigaci贸n de patentes en TI. El curso del joven luchador. Parte II Fuentes de informaci贸n para la investigaci贸n de patentes.</a></li>
<li><a href="../479052/index.html">[Supercomputaci贸n 2019]. Almacenamiento en m煤ltiples nubes como una aplicaci贸n para los nuevos discos Kingston DC1000M</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>