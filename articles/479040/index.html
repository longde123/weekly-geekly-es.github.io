<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚰️ 👩🏿 🖐🏼 Pruebas de regresión visual. Reiniciar 🏡 🎒 🤦🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En mi artículo anterior hablé sobre la experiencia de usar el motor Gemini para desarrollar pruebas visuales, o más bien, pruebas de regresión visual....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pruebas de regresión visual. Reiniciar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/479040/">  En mi <a href="https://habr.com/ru/post/454464/">artículo</a> anterior hablé sobre la experiencia de usar el motor <a href="https://github.com/gemini-testing/gemini">Gemini</a> para desarrollar pruebas visuales, o más bien, pruebas de regresión visual.  Dichas pruebas verifican si algo se ha "movido" en la interfaz de usuario después de los siguientes cambios comparando las capturas de pantalla actuales con las de referencia fijadas anteriormente.  Desde entonces, mucho ha cambiado en nuestros enfoques para escribir pruebas visuales, incluido el motor utilizado.  Ahora usamos a <a href="https://github.com/gemini-testing/hermione">Hermione</a> , pero en este artículo voy a contar no solo y no tanto sobre Hermione, sino también sobre los problemas que se han acumulado desde entonces y cómo resolverlos, lo que, entre otras cosas, condujo a la transición a un nuevo motor. <br><a name="habracut"></a><br>  En primer lugar, aunque las pruebas funcionaron, y con bastante éxito, no teníamos una comprensión clara de lo que estaba cubierto por las pruebas y lo que no.  Había, por supuesto, alguna idea del grado de cobertura, pero no lo medimos cuantitativamente.  En segundo lugar, la composición de las pruebas aumentó con el tiempo y diferentes pruebas a menudo probaron lo mismo, porque  en diferentes capturas de pantalla, alguna parte coincidió con la misma parte, pero en una captura de pantalla diferente.  Como resultado, incluso cambios menores en CSS podrían abrumar muchas pruebas a la vez y requerir la actualización de una gran cantidad de estándares.  En tercer lugar, apareció un tema oscuro en nuestro producto, y para cubrirlo de alguna manera con pruebas, algunas pruebas se cambiaron selectivamente para usar un tema oscuro, que tampoco agregó claridad al problema con la determinación del grado de cobertura. <br><br><h2>  Optimización del rendimiento </h2><br>  Comenzamos, curiosamente, con un rendimiento optimizado.  Explicaré por qué.  Nuestras pruebas visuales se basan en el <a href="https://github.com/storybooks/storybook">libro de cuentos</a> .  Cada historia en el libro de cuentos no es un componente único, sino un "bloque" completo (por ejemplo, una cuadrícula con una lista de entidades, una tarjeta de entidad, diálogo o incluso la aplicación en su conjunto).  Para mostrar este bloque, debe "bombear" la historia con datos, no solo los datos que se muestran al usuario, sino también el estado de los componentes utilizados dentro del bloque.  Esta información se almacena junto con el código fuente en forma de archivos json que contienen una representación serializada del estado de la aplicación (tienda redux).  Sí, esta información es, por decirlo suavemente, redundante, pero simplifica enormemente la creación de pruebas.  Para crear una nueva prueba, simplemente abrimos la tarjeta, lista o cuadro de diálogo deseados en la aplicación, tomamos una instantánea del estado actual de la aplicación y la serializamos en un archivo.  Luego agregamos una nueva historia y pruebas que toman capturas de pantalla de esta historia (todo en unas pocas líneas de código). <br><br>  Este enfoque inevitablemente aumenta el tamaño del paquete.  El grado de duplicación de datos en él simplemente "se transfiere".  Al ejecutar pruebas, el motor gemini ejecuta cada conjunto de pruebas en una sesión de navegador separada.  Cada sesión carga el paquete de nuevo y el tamaño del paquete en dicho esquema está lejos del último valor. <br><br>  Para reducir el tiempo de ejecución de la prueba, redujimos el número de conjuntos de pruebas aumentando el número de pruebas en ellos.  Por lo tanto, un conjunto de pruebas podría afectar varias historias a la vez.  En este esquema, prácticamente perdimos la capacidad de "filtrar" solo un área determinada de la pantalla debido al hecho de que Gemini le permite configurar el área de captura de pantalla solo para el conjunto de pruebas en su conjunto (aunque la API le permite hacer esto antes de cada captura de pantalla, pero en la práctica no funciona). <br><br>  La incapacidad de limitar el área de la captura de pantalla en las pruebas condujo a la duplicación de información visual en las imágenes de referencia.  Si bien no hubo muchas pruebas, este problema no parecía significativo.  Sí, y la IU no cambió muy a menudo.  Pero esto no podría continuar para siempre: un rediseño se avecinaba en el horizonte. <br><br>  Mirando hacia el futuro, diré que en Hermione se puede establecer un área de captura de pantalla para cada disparo y, a primera vista, cambiar a un nuevo motor resolvería todos los problemas.  Pero aún tendríamos que "aplastar" grandes conjuntos de pruebas.  El hecho es que las pruebas visuales no son inherentemente estables (esto puede deberse a varias razones, por ejemplo, con retrasos en la red, el uso de animaciones o con "clima en Marte") y es muy difícil hacerlo sin reintentos automáticos.  Tanto Gemini como Hermione realizan reintentos para el conjunto de pruebas en su conjunto, y cuanto más "grueso" sea el conjunto de pruebas, es menos probable que se complete con éxito durante los reintentos, ya que  en la próxima ejecución, las pruebas que se completaron con éxito anteriormente pueden caer.  Para las suites de prueba gruesas, tuvimos que implementar un esquema de reintento alternativo integrado en el motor Gemini y realmente no queríamos hacer esto nuevamente al cambiar a un nuevo motor. <br><br>  Por lo tanto, para acelerar la carga del conjunto de pruebas, dividimos el paquete monolítico en partes, asignando cada instantánea del estado de la aplicación en una "pieza" separada, cargada "a pedido" para cada historia por separado.  El código de creación de la historia ahora se ve así: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// visual-regression.stories.js import React from 'react'; import StoryProvider from './story-provider'; const stories = storiesOf('visual-regression', module); [ { name: 'Contract', loadData: import('./snapshots/contract.testdata') }, { name: 'ExecutionTask', loadData: import('./snapshots/execution-task.testdata') }, { name: 'ExecutionAssignment', loadData: import('./snapshots/execution-assignment.testdata') }, { name: 'DocumentTemplate', loadData: import('./snapshots/document-template.testdata') }, { name: 'Explorer', loadData: import('./snapshots/explorer.testdata') }, { name: 'Inbox', loadData: import('./snapshots/inbox.testdata') }, ] .map(story =&gt; { stories .add(story.name, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} /&gt;) .add(`${story.name}Dark`, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} theme='night' /&gt;); });</span></span></code> </pre> <br>  Para crear una historia, se utiliza el componente StoryProvider (su código se proporcionará a continuación).  Las instantáneas se cargan mediante la función de <a href="https://webpack.js.org/guides/code-splitting/">importación dinámica</a> .  Diferentes historias difieren entre sí solo en imágenes de estados.  Para un tema oscuro, se genera su propia historia, utilizando la misma instantánea que la historia para un tema claro.  En el contexto de un libro de cuentos, se ve así: <br><br><div class="spoiler">  <b class="spoiler_title">Historia del tema predeterminado</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d6/vc/uk/d6vcukhmensy0jogshjj4hifoui.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Historia oscura del tema</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/jy/z0/uu/jyz0uuyel6t1pofayyjxftuunwg.png"><br></div></div><br>  El componente StoryProvider acepta una devolución de llamada para cargar una instantánea en la que se llama a la función import ().  La función import () funciona de forma asíncrona, por lo que no puede tomar una captura de pantalla inmediatamente después de cargar la historia; nos arriesgamos a eliminar el vacío.  Para captar el momento del final de la descarga, el proveedor presenta el elemento DOM marcador que indica al motor de prueba durante todo el tiempo de la descarga, que debe retrasarse con la captura de pantalla: <br><br><div class="spoiler">  <b class="spoiler_title">story-provider.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// story-provider.js const propsStub = { // -,      . . . }; type Props = { loadSnapshot: () =&gt; Object, theme: ?string }; const StoryProvider = (props: Props) =&gt; { const [ snapshotState, setsnapshotState ] = React.useState(null); React.useEffect(() =&gt; { //    (async() =&gt; setsnapshotState((await props.loadSnapshot).default))(); }); if (!snapshotState) //     ,     return &lt;div className={'loading-stub'}&gt;Loading...&lt;/div&gt;; //    snapshotState.metadata = require('./snapshots/metadata'); //  redux-   const store = createMockStore(snapshotState); //   applyTheme(props.theme); return ( &lt;Provider store={store}&gt; &lt;MemoryRouter&gt; &lt;App {...propsStub} /&gt; &lt;/MemoryRouter&gt; &lt;/Provider&gt; ); }; export default StoryProvider;</span></span></code> </pre><br></div></div><br>  Además, para reducir el tamaño del paquete, deshabilite la adición de mapas de origen al paquete.  Pero para no perder la capacidad de depurar la historia (nunca se sabe qué), hacemos esto bajo la condición: <br><br><div class="spoiler">  <b class="spoiler_title">.storybook / webpack.config.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// .storybook/webpack.config.js ... module.exports = { ... devtool: process.env.NODE_ENV === 'vr-test' ? '(none)' : 'eval-source-map' };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">package.json</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// package.json { ... "scripts": { ... "storybook": "start-storybook", "build-storybook": "cross-env NODE_ENV=vr-test build-storybook -o ./storybook-static", ... },</span></span></code> </pre><br></div></div><br>  El <b>script npm run build-storybook</b> compila un libro de cuentos estático sin mapa de origen en la carpeta estática del libro de cuentos.  Se utiliza al realizar pruebas.  Y el <b>script npm run storybook se</b> usa para desarrollar y depurar historias de prueba. <br><br><h2>  Eliminación de la duplicación de información visual. </h2><br>  Como dije anteriormente, Gemini le permite establecer selectores de área de captura de pantalla para el conjunto de pruebas en su conjunto, lo que significa que para resolver completamente el problema de duplicar la información visual en las capturas de pantalla, tendríamos que hacer nuestro propio conjunto de pruebas para cada captura de pantalla.  Incluso teniendo en cuenta la optimización de cargar la historia, no parecía demasiado optimista en términos de velocidad y pensamos en cambiar el motor de prueba. <br><br>  En realidad, ¿por qué Hermione?  Actualmente, el repositorio Gemini está marcado como obsoleto y, tarde o temprano, tuvimos que "movernos" a algún lado.  La estructura del archivo de configuración de Hermione es idéntica a la estructura del archivo de configuración de Gemini y pudimos reutilizar esta configuración.  Los complementos de Géminis y Hermione también son comunes.  Además, pudimos reutilizar la infraestructura de prueba: máquinas virtuales y red de selenio implementada. <br><br>  A diferencia de Gemini, Hermione no se posiciona como una herramienta solo para pruebas de regresión del diseño.  Sus capacidades de manipulación del navegador son mucho más amplias y limitadas solo por las capacidades de <a href="http://v4.webdriver.io/">Webdriver IO</a> .  En combinación con <a href="https://github.com/mochajs/mocha">mocha,</a> este motor es conveniente para usar más para pruebas funcionales (simulación de acciones del usuario) que para pruebas de diseño.  Para las pruebas de regresión del diseño, Hermione proporciona solo el método ClaimView (), que compara una captura de pantalla de una página del navegador con una referencia.  La captura de pantalla se puede limitar al área especificada mediante los selectores CSS. <br><br>  Para nuestro caso, la prueba para cada historia individual se vería así: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    describe('Visual regression', function() { it('Contract card should equal to etalon', function() { return this.browser //  story   .url('http://localhost:8080/iframe.html?selectedKind=visual-regression&amp;selectedStory=ContractDark') // ,      story .waitForVisible('.loading-stub', true) //          .assertView('layout', '.form'); }) });</span></span></code> </pre><br>  El método waitForVisible (), a pesar de su nombre, le permite esperar no solo la apariencia, sino también la ocultación del elemento, si establece el segundo parámetro en verdadero.  Aquí lo usamos para esperar a que se oculte un elemento marcador, lo que indica que la instantánea de datos aún no está cargada y la historia aún no está lista para una captura de pantalla. <br><br>  Si intenta encontrar el método waitForVisible () en la documentación de Hermione, no encontrará nada.  El hecho es que el <a href="http://v4.webdriver.io/api/utility/waitForVisible.html">método</a> waitForVisible () <a href="http://v4.webdriver.io/api/utility/waitForVisible.html">es el método Webdriver IO API</a> .  El método url (), respectivamente, también.  En el método url (), pasamos la dirección del marco de una historia en particular, no el libro de cuentos completo.  En primer lugar, esto es necesario para que la lista de historias no se muestre en la ventana del navegador; no necesitamos probarla.  En segundo lugar, si es necesario, podemos tener acceso a elementos DOM dentro del marco (los métodos webdriverIO le permiten ejecutar código JavaScript en un contexto de navegador). <br><br>  Para simplificar la escritura de pruebas, creamos nuestro contenedor sobre las pruebas de mocha.  El hecho es que no tiene un sentido particular en la elaboración detallada de casos de prueba para pruebas de regresión.  Todos los casos de prueba son iguales: "debería ser igual a etalon".  Bueno, tampoco quiero duplicar el código para esperar la carga de datos en cada prueba.  Por lo tanto, el mismo trabajo para todas las pruebas "mono" se delega a la función de envoltura, y las pruebas mismas se escriben de manera declarativa (bueno, casi).  Aquí está el texto de esta función: <br><br><div class="spoiler">  <b class="spoiler_title">create-test-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> themes = [ <span class="hljs-string"><span class="hljs-string">'default'</span></span>, <span class="hljs-string"><span class="hljs-string">'dark'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootClassName = <span class="hljs-string"><span class="hljs-string">'.explorer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadingStubClassName = <span class="hljs-string"><span class="hljs-string">'.loading-stub'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timeout = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTestSuite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">testSuite</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, storyName, browsers, testCases, selector } = testSuite; <span class="hljs-comment"><span class="hljs-comment">//  ,       browsers &amp;&amp; hermione.only.in(browsers); //      themes.forEach(theme =&gt; { describe(`${name}_${theme}`, () =&gt; it('should equal to etalon', function() { let browser = this.browser //   story .url(`${storybookUrl}/iframe.html?selectedKind=visual-regression&amp;selectedStory=${storyName}-${theme}`) //     .waitForVisible(loadingStubClassName, timeout, true) .waitForVisible(rootClassName); //    (  ) if (testCases &amp;&amp; testCases.length &gt; 0) { testCases.forEach(testCase =&gt; { if (testCase.before) browser = testCase.before(browser); browser = browser.assertView(`${name}__${testCase.name}_${theme}`, testCase.selector || selector || rootClassName, testCase.options); }); return browser; } //    ,    return browser.assertView(`${name}_${theme}`, selector || rootClassName); })); }); }</span></span></code> </pre><br></div></div><br>  Un objeto que describe el conjunto de pruebas se pasa a la entrada de la función.  Cada conjunto de pruebas se construye de acuerdo con el siguiente escenario: tome una captura de pantalla del diseño principal (por ejemplo, un área de una tarjeta de entidad o un área de una lista de entidades), luego presione programáticamente los botones que pueden dar lugar a la aparición de otros elementos (por ejemplo, paneles emergentes o menús contextuales) y “tome una captura de pantalla »Cada uno de esos elementos por separado.  Por lo tanto, simulamos acciones del usuario en el navegador, pero no con el objetivo de probar un escenario empresarial, sino simplemente para "capturar" el máximo número posible de componentes visuales.  Además, la duplicación de información visual en las capturas de pantalla es mínima, porque  las capturas de pantalla se toman "puntiagudas" utilizando selectores.  Ejemplo de suite de prueba: <br><br><div class="spoiler">  <b class="spoiler_title">explorer-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// explorer-suite.js //         module.exports = { //  story,    storyName: 'explorer', //    name: 'explorer', //  ,       browsers: [ 'chrome-1920x1080', 'ie-1920x1080' ], //   testCases: [ { //    name: 'layout' }, { //    name: 'notification-area', selector: '.notification-area__popup', before: b =&gt; b .click('.notification-area__popup-button') .waitForVisible('.notification-area__popup') .execute(function() { //       document.querySelectorAll('.expandable-item__content')[2].click(); }) }, //... ] };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">tests.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tests.js [ require('./suites/explorer-suite'), //... ] .forEach(suite =&gt; createTestSuite(suite));</span></span></code> </pre><br></div></div><br><h2>  Determinación de cobertura </h2><br>  Entonces, descubrimos la velocidad y la redundancia, queda por determinar la efectividad de nuestras pruebas, es decir, determinar el grado de cobertura del código con las pruebas (aquí por código me refiero a las hojas de estilo CSS). <br><br>  Para las historias de prueba, seleccionamos empíricamente las tarjetas, listas y otros elementos más complicados para llenar para cubrir tantos estilos como sea posible con una captura de pantalla.  Por ejemplo, para probar una tarjeta de entidad, se seleccionaron tarjetas con una gran cantidad de diferentes tipos de controles (texto, número, transferencias, fechas, cuadrículas, etc.).  Las tarjetas para diferentes tipos de entidades tienen sus propios detalles, por ejemplo, desde una tarjeta de documentos puede mostrar un panel con una lista de versiones de documentos, y la tarjeta de tareas muestra la correspondencia para esta tarea.  En consecuencia, para cada tipo de entidad, se creó su propia historia y un conjunto de pruebas específicas para este tipo, etc.  Al final, pensamos que todo parecía estar cubierto con pruebas, pero queríamos un poco más de confianza que "me gusta". <br><br>  Para evaluar la cobertura en Chrome DevTools, hay una herramienta con el nombre Cobertura muy adecuada para este caso: <br><br><img src="https://habrastorage.org/webt/ma/yt/dh/maytdhehcjiumoxdsdj-woa40lo.png"><br><br>  La cobertura le permite determinar qué estilos o qué código js se utilizó al trabajar con la página del navegador.  El informe sobre el uso de rayas verdes indica el código utilizado, rojo - no utilizado.  Y todo estaría bien si tuviéramos una aplicación del nivel "hola, mundo", pero ¿qué hacer cuando tenemos miles de líneas de código?  Los desarrolladores de cobertura lo entendieron bien y proporcionaron la capacidad de exportar el informe a un archivo que ya se puede resolver mediante programación. <br><br>  Debo decir de inmediato que hasta ahora no hemos encontrado una manera de cobrar el grado de cobertura automáticamente.  Teóricamente, esto se puede hacer usando el navegador sin cabeza de Pupeteer, pero Pupeteer no funciona bajo el control de selenio, lo que significa que no podremos reutilizar el código de nuestras pruebas.  Entonces, por ahora, omita este tema extremadamente interesante y trabajemos con bolígrafos. <br><br>  Después de ejecutar las pruebas en modo manual, obtenemos un informe de cobertura, que es un archivo json.  En el informe para cada css, js, ts, etc.  el archivo indica su texto (en una línea) y los intervalos del código utilizado en este texto (en forma de índices de caracteres de esta línea).  A continuación se muestra una parte del informe: <br><br><div class="spoiler">  <b class="spoiler_title">cobertura.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/theme-default.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">8127</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... --theme_primary-accent: #5b9bd5;\r\n --theme_primary-light: #ffffff;\r\n --theme_primary: #f4f4f4;\r\n ..."</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/main.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">610</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">728</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">754</span></span> } ] <span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... \r\n line-height:1;\r\n}\r\n\r\nol, ul{\r\n list-style:none;\r\n}\r\n\r\nblockquote, q..."</span></span> ]</code> </pre><br></div></div><br>  A primera vista, no hay nada difícil en encontrar selectores CSS no utilizados.  Pero entonces, ¿qué hacer con esta información?  De hecho, en el análisis final, necesitamos encontrar no selectores específicos, sino componentes que olvidamos cubrir con las pruebas.  Los estilos de un componente pueden ser configurados por más de una docena de selectores.  Como resultado, de acuerdo con los resultados del análisis del informe, obtenemos cientos de selectores no utilizados, y si trata con cada uno de ellos, puede matar mucho tiempo. <br><br>  Aquí, las expresiones regulares nos ayudan.  Por supuesto, solo funcionarán si se cumplen las convenciones de nomenclatura para las clases css (en nuestro código, las clases css se nombran de acuerdo con la metodología BEM - block_name_name_name_modifier).  Usando expresiones regulares, calculamos los valores únicos de los nombres de bloque, que ya no son difíciles de asociar con los componentes.  Por supuesto, también estamos interesados ​​en elementos y modificadores, pero no en primer lugar, primero debemos tratar con un "pez" más grande.  A continuación se muestra una secuencia de comandos para procesar un informe de cobertura <br><br><div class="spoiler">  <b class="spoiler_title">cobertura.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> modules = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./coverage.json'</span></span>).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> e.url.endsWith(<span class="hljs-string"><span class="hljs-string">'.css'</span></span>)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module, rangeStart, rangeEnd, isUsed</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rules = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.text.slice(rangeStart, rangeEnd); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> regex = <span class="hljs-regexp"><span class="hljs-regexp">/^\.([^\d{:,)_ ]+-?)+/gm</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classNames = rules.match(regex); classNames &amp;&amp; classNames.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> selectors[name] = selectors[name] || isUsed); } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previousEnd, selectors = {}; modules.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function"> =&gt;</span></span> { previousEnd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.ranges) { processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, range.start, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, range.start, range.end, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); previousEnd = range.end; } processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.length, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'className;isUsed'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(selectors).sort().forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${s}</span></span></span><span class="hljs-string">;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${selectors[s]}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre><br></div></div><br>  Ejecutamos el script colocando primero el archivo coverage.json exportado desde Chrome DevTools y escribiendo el escape en un archivo .csv: <br><br>  <b>Nodo cobertura.js&gt; cobertura.csv</b> <br><br>  Puede abrir este archivo con Excel y analizar los datos, incluida la determinación del porcentaje de cobertura de código por pruebas. <br><br><img src="https://habrastorage.org/webt/gh/ss/b8/ghssb8zrlh41pakcvwhyl6fcjge.png"><br><br><h2>  En lugar de un curriculum vitae </h2><br>  Usar el libro de cuentos como base para las pruebas visuales se ha justificado por completo: tenemos un grado suficiente de cobertura del código CSS con pruebas con un número relativamente pequeño de historias y costos mínimos para crear nuevas. <br><br>  La transición a un nuevo motor nos permitió eliminar la duplicación de información visual en las capturas de pantalla, lo que simplificó enormemente el soporte de las pruebas existentes. <br><br>  El grado de cobertura del código CSS se puede medir y, de vez en cuando, se supervisa.  Por supuesto, hay una gran pregunta: cómo no olvidar la necesidad de este control y cómo no perder algo en el proceso de recopilación de información sobre la cobertura.  Idealmente, me gustaría medir el grado de cobertura automáticamente en cada ejecución de prueba, de modo que cuando se alcanza el umbral especificado, las pruebas caerían con un error.  Trabajaremos en esto, si hay noticias, definitivamente te lo diré. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/479040/">https://habr.com/ru/post/479040/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479022/index.html">Los televisores inteligentes Samsung, LG, Vizio y TCL toman cada segundo "huellas digitales" de la pantalla y las envían al servidor</a></li>
<li><a href="../479026/index.html">Verdadera suma de canales de Internet - OpenMPTCPRouter</a></li>
<li><a href="../479034/index.html">Cómo conectarse a una VPN corporativa en Linux usando openconnect y vpn-slice</a></li>
<li><a href="../479036/index.html">Intel no puede hacer frente a la demanda de procesadores. HP y Dell sufren como resultado</a></li>
<li><a href="../479038/index.html">Transformación digital Leroy Merlin: diseño de una interfaz para trabajar con llamadas de clientes</a></li>
<li><a href="../479042/index.html">El método Y es una forma realmente fácil de construir un cubo de Rubik</a></li>
<li><a href="../479044/index.html">Mi implementación de buffer de anillo en flash NOR</a></li>
<li><a href="../479048/index.html">Node.js Streams para dummies o cómo trabajar con streams</a></li>
<li><a href="../479050/index.html">Investigación de patentes en TI. El curso del joven luchador. Parte II Fuentes de información para la investigación de patentes.</a></li>
<li><a href="../479052/index.html">[Supercomputación 2019]. Almacenamiento en múltiples nubes como una aplicación para los nuevos discos Kingston DC1000M</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>