<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👷🏻 🤽🏿 ♟️ Sistem Operasi: Tiga Potongan Mudah. Bagian 4: Pengantar Penjadwal (terjemahan) 😥 ⤵️ 🙅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengantar Sistem Operasi 
 Halo, Habr! Saya ingin menarik perhatian Anda serangkaian artikel-terjemahan dari satu literatur yang menarik menurut saya ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistem Operasi: Tiga Potongan Mudah. Bagian 4: Pengantar Penjadwal (terjemahan)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449026/"><h1>  Pengantar Sistem Operasi </h1><br>  Halo, Habr!  Saya ingin menarik perhatian Anda serangkaian artikel-terjemahan dari satu literatur yang menarik menurut saya - OSTEP.  Artikel ini membahas lebih dalam karya sistem operasi mirip-unix, yaitu, bekerja dengan proses, berbagai penjadwal, memori, dan komponen serupa lainnya yang membentuk OS modern.  Asli semua bahan bisa Anda lihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Harap dicatat bahwa terjemahannya dilakukan secara tidak profesional (cukup bebas), tetapi saya harap saya tetap memiliki makna umum. <br><br>  Pekerjaan laboratorium tentang hal ini dapat ditemukan di sini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aslinya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aslinya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adaptasi pribadi saya</a> </li></ul><br>  Bagian lain: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1: Pendahuluan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2: Abstraksi: proses</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3: Pengantar API Proses</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4: Pengantar Penjadwal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 5: Penjadwal MLFQ</a> </li></ul><br>  Dan Anda dapat melihat saluran saya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">telegram</a> =) <br><a name="habracut"></a><br><h2>  Pengantar Penjadwal </h2><br>  <u>Inti dari masalah: Bagaimana mengembangkan kebijakan perencana</u> <u><br></u>  <u>Bagaimana seharusnya kerangka kebijakan penjadwal dasar dikembangkan?</u>  <u>Apa yang seharusnya menjadi asumsi utama?</u>  <u>Metrik apa yang penting?</u>  <u>Apa teknik dasar yang digunakan dalam komputasi awal?</u> <br><br><h3>  Asumsi Beban Kerja </h3><br>  Sebelum membahas kemungkinan kebijakan, sebagai permulaan kami akan membuat beberapa penyederhanaan penyimpangan tentang proses yang berjalan dalam sistem, yang secara kolektif disebut <b>beban kerja</b> .  Dengan mendefinisikan beban kerja sebagai bagian penting dari kebijakan pembangunan dan semakin Anda tahu tentang beban kerja, semakin baik kebijakan yang bisa Anda tulis. <br><br>  Kami membuat asumsi berikut tentang proses yang berjalan di sistem, kadang-kadang juga disebut <b>pekerjaan</b> (tugas).  Hampir semua asumsi ini tidak realistis, tetapi perlu untuk pengembangan pemikiran. <br><br><ol><li>  Setiap tugas menjalankan jumlah waktu yang sama, </li><li>  Semua tugas diatur pada saat yang sama, </li><li>  Tugas yang ada sampai selesai, </li><li>  Semua tugas hanya menggunakan CPU, </li><li>  Waktu berjalan setiap tugas diketahui. </li></ol><br><h3>  Metrik Penjadwal </h3><br>  Selain beberapa asumsi tentang beban, masih ada kebutuhan untuk beberapa alat untuk membandingkan berbagai kebijakan perencanaan: metrik penjadwal.  Metrik hanyalah ukuran dari sesuatu.  Ada sejumlah metrik yang dapat digunakan untuk membandingkan perencana. <br><br>  Misalnya, kami akan menggunakan metrik yang disebut waktu penyelesaian.  Waktu penyelesaian tugas didefinisikan sebagai perbedaan antara waktu yang dibutuhkan untuk menyelesaikan tugas dan waktu tugas memasuki sistem. <br><br>  <u>Tturnaround = Tcompletion - Tarrival</u> <br><br>  Karena kami mengasumsikan bahwa semua tugas tiba pada waktu yang sama, maka Ta = 0 dan dengan demikian Tt = Tc.  Nilai ini secara alami akan berubah ketika kita mengubah asumsi di atas. <br><br>  Metrik lain adalah <b>keadilan</b> (fairness, honesty).  Produktivitas dan kejujuran seringkali berlawanan karakteristik dalam perencanaan.  Misalnya, penjadwal dapat mengoptimalkan kinerja, tetapi dengan biaya menunggu tugas lain berjalan, sehingga mengurangi integritas. <br><br><h3>  PERTOLONGAN PERTAMA (FIFO) </h3><br>  Algoritma paling dasar yang dapat kita implementasikan disebut FIFO atau <b>first come (in), first served (out)</b> .  Algoritma ini memiliki beberapa keunggulan: sangat mudah diterapkan dan cocok dengan semua asumsi kami, melakukan pekerjaan dengan cukup baik. <br><br>  Pertimbangkan contoh sederhana.  Misalkan 3 tugas ditetapkan pada waktu bersamaan.  Tapi anggaplah tugas A datang sedikit lebih awal dari yang lain, jadi itu akan ada di daftar eksekusi sebelum yang lain, seperti B relatif terhadap C. Misalkan masing-masing dari mereka membutuhkan waktu 10 detik untuk menyelesaikan.  Apa yang akan menjadi waktu rata-rata untuk menyelesaikan tugas-tugas ini? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b4/a43/acd/1b4a43acd8a0f18c24bbdd831529bbda.jpg" alt="gambar"><br><br>  Menghitung nilai - 10 + 20 + 30 dan membaginya dengan 3, kami mendapatkan waktu eksekusi rata-rata program sama dengan 20 detik. <br><br>  Sekarang mari kita coba mengubah asumsi kita.  Khususnya, asumsi 1, dan dengan demikian kita tidak akan lagi menganggap bahwa setiap tugas membutuhkan jumlah waktu yang sama.  Bagaimana FIFO akan tampil sendiri kali ini? <br><br>  Ternyata, waktu pelaksanaan tugas yang berbeda memiliki dampak yang sangat negatif pada produktivitas algoritma FIFO.  Asumsikan bahwa tugas A akan dieksekusi selama 100 detik, sedangkan B dan C masing-masing akan tetap 10. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7a/bee/3fe/a7abee3fefd7a0cf481d0322f40e732f.jpg" alt="gambar"><br><br>  Seperti dapat dilihat dari gambar, waktu rata-rata untuk sistem adalah (100 + 110 + 120) / 3 = 110.  Efek ini disebut <b>efek konvoi</b> , ketika beberapa konsumen jangka pendek dari suatu sumber daya akan sejalan setelah konsumen yang berat.  Itu terlihat seperti garis toko kelontong ketika pelanggan dengan troli penuh ada di depan Anda.  Solusi terbaik untuk masalah ini adalah mencoba mengganti kasir atau bersantai dan bernapas dalam-dalam. <br><br><h3>  Pekerjaan terpendek pertama </h3><br>  Apakah mungkin untuk menyelesaikan situasi yang serupa dengan proses yang berat?  Tentu saja  Tipe lain dari penjadwalan disebut <b>Shortest Job First</b> (SJF).  Algoritma ini juga cukup primitif - seperti namanya, tugas terpendek akan diluncurkan satu demi satu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/778/feb/207/778feb20723fa2d019620b97d27f2830.jpg" alt="gambar"><br><br>  Dalam contoh ini, hasil dari memulai proses yang sama akan menjadi peningkatan dalam waktu penyelesaian rata-rata dari program dan itu akan menjadi <b>50 bukannya 110</b> , yang hampir 2 kali lebih baik. <br><br>  Dengan demikian, untuk asumsi yang diberikan bahwa semua tugas tiba pada saat yang sama, algoritma SJF tampaknya merupakan algoritma yang paling optimal.  Namun, asumsi kami masih tampak tidak realistis.  Kali ini, kami mengubah asumsi 2 dan kali ini membayangkan bahwa tugas dapat tetap setiap saat, dan tidak semua pada waktu yang bersamaan.  Masalah apa yang bisa menyebabkan ini? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/484/6df/332/4846df332de36b42bf891e167ef3f751.jpg" alt="gambar"><br><br>  Bayangkan bahwa tugas A (100-an) datang pertama dan mulai dieksekusi.  Pada waktu t = 10, tugas B, C tiba, yang masing-masing akan memakan waktu 10 detik.  Dengan demikian, waktu eksekusi rata-rata adalah (100+ (110-10) + (120-10)) \ 3 = 103. Apa yang dapat dilakukan perencana untuk memperbaiki situasi? <br><br><h3>  STCF (Waktu-ke-Penyelesaian) Terpendek Pertama </h3><br>  Untuk memperbaiki situasi, kami menghilangkan asumsi 3 bahwa program sudah berjalan dan berjalan sampai selesai.  Selain itu, kami akan memerlukan dukungan perangkat keras, dan seperti yang Anda duga, kami akan menggunakan <b>timer</b> untuk mengganggu tugas kerja dan <b>mengubah konteks</b> .  Dengan demikian, penjadwal dapat melakukan sesuatu pada saat tugas B dan C tiba - hentikan pelaksanaan tugas A dan letakkan tugas B dan C dalam pemrosesan dan, setelah selesai, lanjutkan proses A. Penjadwal ini disebut <b>STCF</b> atau <b>Preemptive Job First</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0eb/900/a1f/0eb900a1f8b96a0952061727037faf4f.jpg" alt="gambar"><br><br>  Hasil dari penjadwal ini adalah hasil ini: ((120-0) + (20-10) + (30-10)) / 3 = 50.  Dengan demikian, penjadwal seperti itu menjadi lebih optimal untuk tugas kita. <br><br><h3>  Waktu Respons Metrik </h3><br>  Jadi, jika kita tahu waktu menjalankan tugas dan bahwa tugas-tugas ini hanya menggunakan CPU, STCF akan menjadi solusi terbaik.  Dan sekali di hari-hari awal, algoritma ini bekerja dengan cukup baik.  Namun, sekarang pengguna menghabiskan sebagian besar waktu di terminal dan mengharapkan interaksi interaktif yang produktif darinya.  Maka lahirlah sebuah metrik baru - <b>waktu</b> respons (response). <br><br>  Waktu respons dihitung sebagai berikut: <br><br>  <u>Tresponse = Tfirstrun - Tarrival</u> <br><br>  Jadi, untuk contoh sebelumnya, waktu respons adalah sebagai berikut: A = 0, B = 0, B = 10 (abg = 3,33). <br><br>  Dan ternyata algoritma STCF tidak begitu baik dalam situasi ketika 3 tugas tiba pada saat yang sama - itu harus menunggu sampai tugas-tugas kecil selesai sepenuhnya.  Dengan demikian, algoritma ini baik untuk metrik waktu penyelesaian, tetapi buruk untuk metrik interaktivitas.  Bayangkan duduk di terminal dalam upaya mengetikkan karakter di editor, Anda harus menunggu lebih dari 10 detik, karena beberapa tugas lain ditempati oleh prosesor.  Ini tidak terlalu menyenangkan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bed/aed/2e2/bedaed2e2491a426eb3fe137ed5b467e.jpg" alt="gambar"><br><br>  Jadi kita dihadapkan dengan masalah lain - bagaimana kita bisa membuat scheduler yang sensitif terhadap waktu respons? <br><br><h3>  Round robin </h3><br>  Untuk mengatasi masalah ini, algoritma <b>Round Robin</b> (RR) dikembangkan.  Gagasan dasarnya cukup sederhana: alih-alih memulai tugas hingga selesai, kami akan memulai tugas untuk periode waktu tertentu (disebut kuantum waktu) dan kemudian beralih ke tugas lain dari antrian.  Algoritme mengulangi kerjanya sampai semua tugas selesai.  Dalam hal ini, waktu menjalankan program harus kelipatan dari waktu setelah timer menghentikan proses.  Misalnya, jika timer menghentikan proses setiap x = 10ms, maka ukuran jendela eksekusi proses harus kelipatan 10 dan menjadi 10,20 atau x * 10. <br><br>  Mari kita lihat sebuah contoh: Tugas ABV tiba secara bersamaan dalam sistem dan masing-masing ingin bekerja selama 5 detik.  Algoritma SJF akan menyelesaikan setiap tugas sampai akhir sebelum memulai yang lain.  Sebaliknya, algoritma RR dengan jendela peluncuran = 1s akan melalui tugas-tugas sebagai berikut (Gbr. 4.3): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bed/aed/2e2/bedaed2e2491a426eb3fe137ed5b467e.jpg" alt="gambar"><br>  <i>(SJF Lagi (Buruk untuk Waktu Respons)</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e40/351/12e/e4035112ea5d27958b0e099ed19a6c41.jpg" alt="gambar"><br>  <i>(Round Robin (Baik Untuk Waktu Respons)</i> <br><br>  Rata-rata waktu respons untuk algoritma adalah RR (0 + 1 + 2) / 3 = 1, sedangkan untuk SJF (0 + 5 + 10) / 3 = 5. <br><br>  Adalah logis untuk mengasumsikan bahwa jendela waktu adalah parameter yang sangat penting untuk RR, semakin kecil, semakin tinggi waktu respons.  Namun, Anda tidak dapat membuatnya terlalu kecil, karena waktu untuk beralih konteks juga akan memainkan peran dalam kinerja keseluruhan.  Dengan demikian, waktu dari jendela eksekusi diatur oleh arsitek OS dan tergantung pada tugas-tugas yang direncanakan untuk dieksekusi di dalamnya.  Berpindah konteks bukan satu-satunya operasi layanan yang menghabiskan waktu - program yang berjalan beroperasi dengan lebih banyak, misalnya, berbagai cache, dan setiap kali diperlukan untuk menyimpan dan memulihkan lingkungan ini, yang juga dapat memakan banyak waktu. <br><br>  RR adalah perencana hebat jika hanya metrik waktu respons.  Tetapi bagaimana metrik waktu penyelesaian tugas akan berperilaku dengan algoritma ini?  Perhatikan contoh di atas, ketika waktu operasi A, B, C = 5d dan tiba pada waktu yang sama.  Tugas A akan berakhir pada 13, B pada 14, C pada 15-an dan waktu penyelesaian rata-rata adalah 14-an.  Dengan demikian, RR adalah algoritma terburuk untuk metrik omset. <br><br>  Lebih umum, algoritma apa pun seperti RR jujur, itu membagi waktu yang dihabiskan untuk CPU secara merata di antara semua proses.  Dan dengan demikian, metrik ini terus-menerus bertentangan satu sama lain. <br><br>  Dengan demikian, kami memiliki beberapa algoritma yang berlawanan dan pada saat yang sama beberapa asumsi tetap - bahwa waktu tugas diketahui dan bahwa tugas hanya menggunakan CPU. <br><br><h3>  Bercampur dengan I / O </h3><br>  Pertama-tama, kami menghapus asumsi 4 bahwa proses hanya menggunakan CPU, tentu saja tidak demikian, dan proses dapat beralih ke peralatan lain. <br><br>  Saat proses meminta operasi I / O, proses masuk ke status diblokir, menunggu I / O selesai.  Jika I / O dikirim ke hard disk, maka operasi seperti itu dapat memakan waktu hingga beberapa ms atau lebih lama, dan prosesor akan idle pada saat itu.  Pada saat ini, penjadwal dapat mengambil alih prosesor dengan proses lainnya.  Keputusan berikutnya yang harus dibuat oleh penjadwal adalah ketika proses menyelesaikan I / O-nya.  Ketika ini terjadi, interupsi akan terjadi dan OS akan menempatkan proses I / O-calling dalam status siap. <br><br>  Pertimbangkan contoh beberapa tugas.  Masing-masing dari mereka membutuhkan 50ms waktu prosesor.  Namun, yang pertama akan mengakses I / O setiap 10 ms (yang juga akan dieksekusi untuk 10 ms).  Dan proses B hanya menggunakan prosesor 50ms tanpa I / O. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/50a/488/cae/50a488cae4476f65002df9ea966f9ef7.jpg" alt="gambar"><br><br>  Dalam contoh ini, kita akan menggunakan penjadwal STCF.  Bagaimana penjadwal berperilaku jika Anda menjalankan proses seperti A di atasnya?  Dia akan melanjutkan sebagai berikut - proses sepenuhnya pertama A, dan kemudian proses B. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/151/f5e/326/151f5e326437859d65d29541dbe0e94f.jpg" alt="gambar"><br><br>  Pendekatan tradisional untuk memecahkan masalah ini adalah untuk menafsirkan setiap 10-ms sub-tugas dari proses A sebagai tugas yang terpisah.  Jadi, ketika memulai dengan algoritma STJF, pilihan antara tugas 50 ms dan 10 ms jelas.  Kemudian, ketika subtugas A selesai, proses B dan I / O akan dimulai.  Setelah I / O selesai, akan menjadi kebiasaan untuk memulai proses 10-ms lagi alih-alih proses B. Dengan demikian, dimungkinkan untuk mewujudkan tumpang tindih ketika CPU digunakan oleh proses lain sementara yang pertama sedang menunggu I / O.  Dan sebagai hasilnya, sistem lebih baik digunakan - pada saat proses interaktif menunggu I / O, proses lain dapat dijalankan pada prosesor. <br><br><h3>  Oracle tidak ada lagi </h3><br>  Sekarang mari kita coba untuk menyingkirkan anggapan bahwa waktu tugas diketahui.  Ini umumnya asumsi terburuk dan paling tidak realistis dari seluruh daftar.  Bahkan, dalam OS standar rata-rata, OS itu sendiri biasanya tahu sedikit tentang waktu yang dibutuhkan untuk menyelesaikan tugas, jadi bagaimana Anda bisa membuat penjadwal tanpa mengetahui berapa lama tugas itu akan berlangsung?  Mungkin kita bisa menggunakan beberapa prinsip RR untuk menyelesaikan masalah ini? <br><br><h3>  Ringkasan </h3><br>  Kami memeriksa ide-ide dasar perencanaan tugas dan meninjau 2 keluarga perencana.  Yang pertama memulai tugas terpendek di awal dan dengan demikian meningkatkan waktu penyelesaian, yang kedua terpecah antara semua tugas secara sama, meningkatkan waktu respons.  Kedua algoritma buruk di mana algoritma keluarga lainnya baik.  Kami juga melihat bagaimana penggunaan paralel CPU dan I / O dapat meningkatkan kinerja, tetapi tidak memecahkan masalah dengan clairvoyance dari OS.  Dan dalam pelajaran berikutnya, kita akan mempertimbangkan seorang perencana yang melihat ke masa lalu dekat dan mencoba untuk memprediksi masa depan.  Dan itu disebut antrian umpan balik multi-level. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449026/">https://habr.com/ru/post/id449026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449012/index.html">Dunia! Buruh! iOS! Hidupkan penawaran selama 1 hari</a></li>
<li><a href="../id449014/index.html">Advance Ethereum DAPP</a></li>
<li><a href="../id449016/index.html">Steganografi dalam sistem file cakram optik</a></li>
<li><a href="../id449022/index.html">Analisis kode Platform CUBA menggunakan PVS-Studio</a></li>
<li><a href="../id449024/index.html">"Rahasia Planet Ketiga" dengan grafik jaringan saraf yang ditingkatkan</a></li>
<li><a href="../id449028/index.html">Kemarahan, tawar-menawar, dan depresi saat bekerja dengan InfluxDB</a></li>
<li><a href="../id449032/index.html">Kami merancang sistem pemadam api sprinkler</a></li>
<li><a href="../id449034/index.html">Citymobil - manual untuk meningkatkan ketersediaan di tengah pertumbuhan bisnis untuk startup. Bagian 1</a></li>
<li><a href="../id449038/index.html">Mengelola Kontainer Docker di Go</a></li>
<li><a href="../id449040/index.html">Minggu Keamanan 17: Serangan Rantai Pasokan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>