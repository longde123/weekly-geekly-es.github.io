<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ–‹ï¸ ğŸ© ğŸš‚ Cari kontur wajah dalam satu milidetik menggunakan ansambel pohon regresi ğŸ˜… ğŸŒ® ğŸ¤˜ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terjemahan artikel disiapkan untuk siswa kursus "Matematika untuk Ilmu Data" 

 Anotasi 


 Artikel ini membahas tugas menemukan kontur wajah untuk sa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cari kontur wajah dalam satu milidetik menggunakan ansambel pohon regresi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/460541/"><p><img src="https://habrastorage.org/webt/eb/rn/3a/ebrn3a_ugfcxc9tuhkdmwgnrut8.png"></p><br><p>  <em>Terjemahan artikel disiapkan untuk siswa kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Matematika untuk Ilmu Data"</a></em> </p><br><hr><br><h1 id="annotaciya">  Anotasi </h1><br><p>  <em>Artikel ini membahas tugas menemukan kontur wajah untuk satu gambar.</em>  <em>Kami menunjukkan bagaimana ansambel pohon regresi dapat digunakan untuk memprediksi posisi kontur wajah langsung dari subset intensitas piksel yang tersebar, mencapai kinerja super secara real time dengan prediksi berkualitas tinggi.</em>  <em>Kami menyajikan struktur umum berdasarkan peningkatan gradien untuk mempelajari ansambel pohon regresi yang mengoptimalkan jumlah kerugian kuadrat dan, tentu saja, memproses data yang hilang atau sebagian ditandai.</em>  <em>Kami akan menunjukkan bagaimana penggunaan distribusi yang tepat yang memperhitungkan struktur data gambar membantu dalam pemilihan kontur yang efisien.</em>  <em>Berbagai strategi regularisasi dan kepentingannya dalam perjuangan melawan pelatihan ulang juga sedang diselidiki.</em>  <em>Selain itu, kami menganalisis efek dari jumlah data pelatihan pada keakuratan prakiraan dan menguji pengaruh peningkatan data menggunakan data yang disintesis.</em> <a name="habracut"></a></p><br><h1 id="1-vvedenie">  1. Pendahuluan </h1><br><p>  Dalam artikel ini, kami menyajikan algoritma baru yang mencari kontur wajah dalam milidetik dan mencapai akurasi yang lebih unggul atau sebanding dengan metode modern pada set data standar.  Peningkatan kecepatan dibandingkan dengan metode sebelumnya adalah konsekuensi dari identifikasi komponen utama dari algoritma sebelumnya untuk pencarian kontur wajah dan inklusi berikutnya dalam bentuk yang dioptimalkan dalam kaskade model regresi dengan bandwidth tinggi, disetel menggunakan gradient boosting. </p><br><p>  Kami menunjukkan, seperti yang telah kami lakukan sebelumnya [8, 2], bahwa pencarian untuk kontur wajah dapat dilakukan menggunakan kaskade model regresi.  Dalam kasus kami, setiap model regresi dalam kaskade secara efektif memprediksi bentuk wajah berdasarkan perkiraan awal dan intensitas kumpulan piksel yang diindeks relatif terhadap perkiraan awal ini.  Pekerjaan kami didasarkan pada sejumlah besar studi yang dilakukan selama dekade terakhir, yang telah menyebabkan kemajuan yang signifikan dalam tugas menemukan kontur wajah [9, 4, 13, 7, 15, 1, 16, 18, 3, 6, 19].  Secara khusus, kami telah memasukkan dalam model regresi yang disetel kami dua elemen kunci yang hadir dalam beberapa algoritma yang sukses di bawah ini, dan sekarang kami merinci elemen-elemen ini. </p><br><p><img src="https://habrastorage.org/webt/xe/fn/ux/xefnuxzvuozcmpu5xjzvwwm3kq4.png"></p><br><p>  <em>Gambar 1. Hasil yang dipilih pada dataset HELEN.</em>  <em>Untuk mendeteksi 194 titik kunci (landmark) pada wajah dalam satu gambar dalam milidetik, ensemble pohon regresi acak digunakan.</em> </p><br><p>  Yang pertama berkisar pada pengindeksan intensitas piksel relatif terhadap perkiraan bentuk wajah saat ini.  Fitur-fitur khusus dalam representasi vektor dari gambar wajah dapat sangat bervariasi karena deformasi bentuk, dan karena faktor-faktor yang mengganggu seperti perubahan kondisi pencahayaan.  Ini membuatnya sulit untuk secara akurat memprediksi bentuk menggunakan fungsi-fungsi ini.  Dilema adalah kita membutuhkan tanda yang dapat diandalkan untuk memprediksi bentuk secara akurat, dan di sisi lain, kita membutuhkan perkiraan bentuk yang akurat untuk mengekstraksi tanda yang dapat diandalkan.  Dalam karya sebelumnya [4, 9, 5, 8], serta dalam karya ini, pendekatan iteratif (kaskade) digunakan untuk menyelesaikan masalah ini.  Alih-alih mundur parameter bentuk berdasarkan fitur yang diekstraksi dalam sistem koordinat gambar global, gambar dikonversi ke sistem koordinat dinormalisasi berdasarkan perkiraan bentuk saat ini, dan kemudian tanda diekstraksi untuk memprediksi vektor pembaruan untuk parameter bentuk.  Proses ini biasanya diulang beberapa kali hingga konvergensi. </p><br><p>  Yang kedua meneliti bagaimana menangani kompleksitas masalah penjelasan / prediksi.  Selama pengujian, algoritma pencarian kontur harus memprediksi bentuk wajah - vektor dimensi tinggi yang sesuai dengan data gambar dan model bentuk kami.  Masalahnya adalah nonconvex dengan banyak optima lokal.  Algoritma yang berhasil [4, 9] menyelesaikan masalah ini, dengan asumsi bahwa bentuk yang diprediksi harus terletak pada subruang linier yang dapat dideteksi, misalnya, dengan menemukan komponen utama dari formulir pelatihan.  Asumsi ini secara signifikan mengurangi jumlah bentuk potensial yang dipertimbangkan selama penjelasan, dan dapat membantu menghindari optima lokal. </p><br><p>  Sebuah karya baru-baru ini [8, 11, 2] mengeksploitasi fakta bahwa kelas tertentu dari regressor dijamin untuk membuat prediksi yang terletak pada subruang linier yang ditentukan oleh bentuk pembelajaran, dan tidak perlu adanya pembatasan tambahan.  Adalah penting bahwa model regresi kami memiliki dua elemen ini. <br>  Kedua faktor ini terkait dengan pelatihan efektif kami dalam model regresi.  Kami mengoptimalkan fungsi kerugian terkait dan melakukan pemilihan fitur berdasarkan data.  Secara khusus, kami melatih setiap regressor menggunakan gradient boosting [10] menggunakan fungsi kerugian kuadratik, fungsi kerugian yang sama yang ingin kami meminimalkan selama pengujian.  Himpunan piksel jarang yang digunakan sebagai input ke regresi dipilih menggunakan kombinasi algoritma peningkatan gradien dan probabilitas a priori dari jarak antara pasangan piksel input.  Distribusi apriori memungkinkan algoritma peningkatan untuk menyelidiki secara efisien sejumlah besar fitur yang relevan.  Hasilnya adalah kaskade regressor yang dapat melokalkan landmark wajah ketika diinisialisasi dari depan. </p><br><p>  Kontribusi utama dari artikel ini adalah: </p><br><ol><li>  Metode baru untuk menemukan kontur wajah, berdasarkan ansambel pohon regresi (pohon keputusan), yang melakukan pemilihan fitur invarian dari formulir, sambil meminimalkan fungsi kehilangan yang sama selama pelatihan yang ingin kami meminimalkan selama pengujian. </li><li>  Kami menyajikan ekstensi alami dari metode kami yang memproses label yang hilang atau tidak ditentukan. </li><li>  Hasil kuantitatif dan kualitatif disajikan, yang mengkonfirmasi bahwa metode kami memberikan perkiraan berkualitas tinggi, jauh lebih efektif daripada metode terbaik sebelumnya (Gambar 1). </li><li>  Pengaruh jumlah data pelatihan, penggunaan data yang diberi label sebagian dan data yang digeneralisasi pada kualitas perkiraan dianalisis. </li></ol><br><h1 id="2-metod">  2. Metode </h1><br><p>  Artikel ini menyajikan algoritma untuk secara akurat menilai posisi landmark wajah (poin utama) dalam hal efisiensi komputasi.  Seperti dalam karya sebelumnya [8, 2], kaskade regressor digunakan dalam metode kami.  Pada bagian selanjutnya dari bagian ini, kami menjelaskan detail bentuk komponen individu dari kaskade dan bagaimana kami melakukan pelatihan. </p><br><h4 id="21-kaskad-regressorov">  2.1.  Kaskade regresi </h4><br><p>  Pertama kami memperkenalkan beberapa notasi.  Biarkan <img src="https://habrastorage.org/getpro/habr/post_images/96b/8a8/cd3/96b8a8cd39c5f39cf67191c499d17a36.svg">  , koordinat y dari landmark ke-i dari wajah pada gambar I. Kemudian vektor <img src="https://habrastorage.org/getpro/habr/post_images/bd9/f10/315/bd9f10315460922e284cfe03581f1e91.svg">  menunjukkan koordinat semua wajah p dalam I. Seringkali dalam artikel ini kita menyebut vektor S bentuk.  Kami menggunakan <img src="https://habrastorage.org/getpro/habr/post_images/765/839/4d5/7658394d527b5ec58206aa0bde88e139.svg">  untuk menunjukkan peringkat kami saat ini S. Setiap regresi <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg">  (Â·, Â·) Dalam kaskade memprediksi pembaruan vektor dari gambar dan <img src="https://habrastorage.org/getpro/habr/post_images/765/839/4d5/7658394d527b5ec58206aa0bde88e139.svg">  yang ditambahkan ke evaluasi formulir saat ini <img src="https://habrastorage.org/getpro/habr/post_images/765/839/4d5/7658394d527b5ec58206aa0bde88e139.svg">  Untuk meningkatkan peringkat: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/813/e90/80c/813e9080c1daa94987bfd323fcf05d75.svg">  ) <em>(1)</em> </p><br><p>  Titik kunci dari kaskade adalah bahwa sang regresor <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg">  membuat perkiraan berdasarkan atribut seperti intensitas piksel yang dihitung oleh I dan diindeks relatif terhadap perkiraan bentuk saat ini <img src="https://habrastorage.org/getpro/habr/post_images/765/839/4d5/7658394d527b5ec58206aa0bde88e139.svg">  .  Ini memperkenalkan semacam invarian geometris ke dalam proses, dan saat Anda maju melalui kaskade, Anda bisa lebih yakin bahwa lokasi semantik yang tepat pada wajah diindeks.  Kami nanti akan menjelaskan bagaimana pengindeksan ini dilakukan. </p><br><p>  Harap dicatat bahwa rentang output yang diperpanjang oleh ansambel dijamin terletak pada subruang linier dari data pelatihan jika perkiraan awal <img src="https://habrastorage.org/getpro/habr/post_images/f0d/6ae/457/f0d6ae4573955eb6abc901db0a68bc4a.svg">  milik ruang ini.  Oleh karena itu, kami tidak perlu memperkenalkan batasan tambahan pada prediksi, yang sangat menyederhanakan metode kami.  Bentuk awal hanya dapat dipilih sebagai bentuk tengah dari data pelatihan, dipusatkan dan diskalakan sesuai dengan output dari kotak pembatas dari detektor wajah umum. </p><br><p>  Untuk mendidik semua orang <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg">  kami menggunakan algoritma peningkatan gradien untuk pohon dengan jumlah kerugian kuadratik, seperti yang dijelaskan dalam [10].  Sekarang kami akan memberikan detail detail dari proses ini. </p><br><h4 id="22-obuchenie-kazhdogo-regressora-v-kaskade">  2.2.  Latih setiap regressor dalam sebuah riam </h4><br><p>  Misalkan kita memiliki data pelatihan <img src="https://habrastorage.org/getpro/habr/post_images/a81/786/c9b/a81786c9b9d6dc27492f55b19afb5055.svg">  dimana semua orang <img src="https://habrastorage.org/getpro/habr/post_images/e19/7a8/ea5/e197a8ea5f9ce816e060678de54e7ba9.svg">  adalah gambar wajah, dan <img src="https://habrastorage.org/getpro/habr/post_images/7a3/62f/59e/7a362f59eba33ebc236fefd712440e76.svg">  vektor bentuknya.  Untuk mengetahui fungsi regresi pertama <img src="https://habrastorage.org/getpro/habr/post_images/0ac/302/657/0ac302657b1d8e45efa7f7b9b2557268.svg">  dalam kaskade, kami membuat dari triplet data pelatihan kami dari gambar wajah, prakiraan bentuk awal dan langkah pembaruan target, mis. <img src="https://habrastorage.org/getpro/habr/post_images/6a1/450/b9e/6a1450b9ea40a582ec2794d9df7afd31.svg">  ) dimana </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f29/a62/581/f29a625813ba6c6cd00aea30a8cfe019.svg">  <em>(2)</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6c3/a0d/468/6c3a0d468f609ada0672c0f473c589ec.svg">  <em>(3)</em> dan </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/691/50d/5cf/69150d5cfe48125a51002916c28453e8.svg">  <em>(4)</em> </p><br><p>  untuk i = 1, ..., N. </p><br><p>  Kami menetapkan jumlah total kembar tiga ini ke N = nR, di mana R adalah jumlah inisialisasi yang digunakan pada gambar Ii.  Setiap perkiraan bentuk awal untuk gambar dipilih secara merata <img src="https://habrastorage.org/getpro/habr/post_images/d1c/fb5/092/d1cfb5092f0e598893288582f2114b37.svg">  tanpa penggantian. </p><br><p>  Pada data ini kami melatih fungsi regresi <img src="https://habrastorage.org/getpro/habr/post_images/bcb/830/694/bcb83069438bb8a2d3e1e51f76a276f4.svg">  (Lihat Algoritma 1) menggunakan gradien meningkatkan pohon dengan jumlah kerugian kuadratik.  Set triplet pelatihan kemudian diperbarui untuk memberikan data pelatihan. <img src="https://habrastorage.org/getpro/habr/post_images/f56/e5c/4a8/f56e5c4a803f2c95ebe20dae215895cf.svg">  % 20) untuk penerus berikutnya <img src="https://habrastorage.org/getpro/habr/post_images/dc5/512/a85/dc5512a85c881619a2c05faa3c2a2806.svg">  dalam kaskade dengan mengatur (dengan t = 0). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/146/29d/692/14629d6922ca89d70fed70bbeb3287bd.svg">  % 20) <em>(5)</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/17d/8a5/44a/17d8a544a843aa72dc68d79ab9c2236d.svg">  <em>(6)</em> </p><br><p>  Proses ini diulangi sampai riam T regressor dilatih. <img src="https://habrastorage.org/getpro/habr/post_images/ee6/6a5/503/ee66a5503085c7bbaa7a616585c4ae2e.svg">  yang dalam kombinasi memberikan tingkat akurasi yang cukup. </p><br><p>  Seperti yang ditunjukkan, masing-masing regresi <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg">  belajar menggunakan algoritma peningkatan pohon gradien.  Harus diingat bahwa fungsi kerugian kuadratik digunakan, dan residu yang dihitung dalam loop dalam berhubungan dengan gradien dari fungsi kehilangan ini yang diperkirakan dalam setiap sampel pelatihan.  Perumusan algoritma mencakup parameter laju pembelajaran 0 &lt;Î½ â‰¤ 1, juga dikenal sebagai koefisien regularisasi.  Pengaturan Î½ &lt;1 membantu untuk memerangi konfigurasi ulang dan biasanya mengarah ke regressor yang menggeneralisasi jauh lebih baik daripada yang dilatih dengan Î½ = 1 [10]. </p><br><hr><br><p>  <strong>Algoritma Belajar 1</strong> <strong><img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg"></strong>  <strong>dalam kaskade</strong> </p><br><p>  Kami memiliki data pelatihan <img src="https://habrastorage.org/getpro/habr/post_images/2d4/805/43a/2d480543a349544ead268291984b1e6a.svg">  dan tingkat pembelajaran (koefisien regularisasi) 0 &lt;Î½ &lt;1 </p><br><ol><li>  Inisialisasi <br><img src="https://habrastorage.org/getpro/habr/post_images/e54/d75/bae/e54d75bae7a82091f8d5c1f04a92cc22.svg"></li><li>  untuk k = 1, ..., K: <br>  a) kita atur untuk i = 1, ..., <br><img src="https://habrastorage.org/getpro/habr/post_images/759/573/b03/759573b032b3bb95986dfe5d42d8e5d8.svg"><br>  b) Kami menyesuaikan pohon regresi ke target <img src="https://habrastorage.org/getpro/habr/post_images/683/2f3/54e/6832f354e8f4ecad8283cc1be6a6899a.svg">  dengan fungsi regresi yang lemah <img src="https://habrastorage.org/getpro/habr/post_images/425/db2/33f/425db233f09794bfe60e62a49da89a98.svg">  . <br>  c) Memperbarui <img src="https://habrastorage.org/getpro/habr/post_images/376/5d0/ac3/3765d0ac3de75d838ad520821c141c21.svg"></li><li>  Kesimpulan <br><img src="https://habrastorage.org/getpro/habr/post_images/7c0/9c4/2b9/7c09c42b9cc35b3225f89435a9d4ce22.svg"></li></ol><br><hr><br><h4 id="23-drevovidnyy-regressor">  2.3.  Pohon regressor </h4><br><p>  Pada intinya setiap fungsi regresi rt adalah regressor mirip pohon yang cocok untuk target residual selama algoritma peningkatan gradien.  Sekarang kita akan melihat detail implementasi yang paling penting untuk melatih setiap pohon regresi. </p><br><h4 id="231-invariantnye-split-testy-formy">  2.3.1 Tes formulir split invarian </h4><br><p>  Pada setiap simpul pemisahan di pohon regresi, kami membuat keputusan berdasarkan nilai ambang perbedaan antara intensitas dua piksel.  Pixel yang digunakan dalam pengujian berada di posisi u dan v ketika ditetapkan dalam sistem koordinat bentuk tengah.  Untuk gambar wajah dengan bentuk sewenang-wenang, kami ingin mengindeks poin yang memiliki posisi yang sama relatif terhadap bentuknya seperti u dan v, untuk bentuk rata-rata.  Untuk melakukan ini, sebelum mengekstraksi elemen, gambar dapat dideformasi menjadi bentuk tengah berdasarkan pada perkiraan bentuk saat ini.  Karena kami hanya menggunakan representasi gambar yang sangat jarang, jauh lebih efisien untuk mengubah bentuk pengaturan titik daripada keseluruhan gambar.  Selain itu, perkiraan kasar deformasi dapat dibuat hanya menggunakan transformasi kesamaan global di samping perpindahan lokal, seperti yang diusulkan dalam [2]. </p><br><p>  Rincian persisnya adalah sebagai berikut.  Biarkan <img src="https://habrastorage.org/getpro/habr/post_images/482/2f7/60f/4822f760fdf061f414f323d30d0c14cd.svg">  Apakah indeks tengara pada wajah dalam bentuk tengah paling dekat dengan Anda, dan tentukan perpindahannya dari Anda sebagai <img src="https://habrastorage.org/getpro/habr/post_images/0fa/bbb/f81/0fabbbf8125f80b9f31e3b5ce093bc3c.svg">  . </p><br><p>  Kemudian untuk bentuk Si didefinisikan dalam gambar <img src="https://habrastorage.org/getpro/habr/post_images/e19/7a8/ea5/e197a8ea5f9ce816e060678de54e7ba9.svg">  posisi dalam <img src="https://habrastorage.org/getpro/habr/post_images/e19/7a8/ea5/e197a8ea5f9ce816e060678de54e7ba9.svg">  , yang secara kualitatif mirip dengan u pada gambar bentuk sedang, didefinisikan sebagai <br><img src="https://habrastorage.org/getpro/habr/post_images/e2d/e8d/0d4/e2de8d0d461e2ef6e76642d39a803b27.svg">  <em>(7)</em> </p><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/7a3/62f/59e/7a362f59eba33ebc236fefd712440e76.svg">  dan <img src="https://habrastorage.org/getpro/habr/post_images/8f6/b4a/913/8f6b4a913e518f22483a28148144b54e.svg">  - skala dan matriks rotasi dari transformasi kesamaan yang mentransformasikannya <img src="https://habrastorage.org/getpro/habr/post_images/7a3/62f/59e/7a362f59eba33ebc236fefd712440e76.svg">  masuk <img src="https://habrastorage.org/getpro/habr/post_images/919/800/718/919800718f235e7487c36b01db6739e1.svg">  , bentuk tengah. </p><br><p>  Skala dan rotasi diminimalkan </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cf0/581/e89/cf0581e890e027fcaf3327e3be6f194c.svg">  <em>(8)</em> </p><br><p>  jumlah kuadrat antara titik-titik tengara bentuk tengah, <img src="https://habrastorage.org/getpro/habr/post_images/c73/942/e7f/c73942e7f47a9adb6091e024085fc1bb.svg">  dan point warp. <img src="https://habrastorage.org/getpro/habr/post_images/b2d/a25/52e/b2da2552e44457f6bcbf5d1aab251267.svg">  didefinisikan dengan cara yang sama. </p><br><p>  Secara formal, setiap divisi adalah solusi yang mencakup 3 parameter Î¸ = (Ï„, u, v), dan diterapkan pada setiap pelatihan dan contoh pengujian sebagai </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bfe/6ee/9c7/bfe6ee9c7e9da21fb2b81caca3d8abad.svg">  <em>(9)</em> </p><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/ff8/c77/429/ff8c77429402ff15260663452a693e8d.svg">  dan <img src="https://habrastorage.org/getpro/habr/post_images/b2d/a25/52e/b2da2552e44457f6bcbf5d1aab251267.svg">  ditentukan dengan menggunakan skala dan matriks rotasi yang paling merusak <img src="https://habrastorage.org/getpro/habr/post_images/5ac/ad7/803/5acad7803f7a79cc10fa8c714205eeab.svg">  masuk <img src="https://habrastorage.org/getpro/habr/post_images/919/800/718/919800718f235e7487c36b01db6739e1.svg">  sesuai dengan persamaan (7).  Dalam praktiknya, tugas dan perpindahan lokal ditentukan pada tahap pelatihan.  Perhitungan transformasi kesamaan, selama pengujian bagian paling mahal dari proses ini, dilakukan hanya sekali di setiap tingkat kaskade. </p><br><h4 id="232-vybor-uzlovyh-razbieniy">  2.3.2 Pemilihan partisi nodal </h4><br><p>  Untuk setiap pohon regresi, kami memperkirakan fungsi dasar dengan fungsi linear piecewise, di mana vektor konstan cocok untuk setiap node hingga.  Untuk melatih pohon regresi, kami secara acak menghasilkan sekumpulan partisi yang cocok, yaitu, Î¸, di setiap node.  Kemudian kami dengan penuh semangat memilih Î¸ * dari kandidat ini, yang meminimalkan jumlah kesalahan kuadratik.  Jika Q adalah sekumpulan indeks contoh pelatihan dalam sebuah simpul, maka ini berhubungan dengan minimalisasi </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8b2/8f1/e02/8b28f1e02ab50c802525c5ded6aaeeaf.svg">  <em>(10)</em> </p><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/fd5/fa1/737/fd5fa1737973ecd7a303b2862a32f8ec.svg">  - indeks contoh yang dikirim ke simpul kiri karena keputusan Î¸, <img src="https://habrastorage.org/getpro/habr/post_images/ab1/ee0/4fb/ab1ee04fb1210c9352cc942823f6dcd1.svg">  Apakah vektor semua residu dihitung untuk gambar <em>i</em> dalam algoritma peningkatan gradien, dan </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c7f/e61/cc7/c7fe61cc7d441d07443317d12fc860c4.svg">  untuk <img src="https://habrastorage.org/getpro/habr/post_images/e17/6e7/ece/e176e7ece99e70aeee6c4ffe2949bb2f.svg">  <em>(11)</em> </p><br><p>  Partisi optimal dapat ditemukan dengan sangat efisien, karena jika kita mengubah persamaan (10) dan menghilangkan faktor-faktor yang tidak bergantung pada Î¸, kita dapat melihat bahwa </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/517/57c/a5c/51757ca5c227156f25de32c995a6c1eb.svg"></p><br><p>  Di sini kita hanya perlu menghitung <img src="https://habrastorage.org/getpro/habr/post_images/88d/4eb/4bb/88d4eb4bb69acbcbbbf4ad0e10098a80.svg">  ketika mengevaluasi berbagai Î¸, sejak <img src="https://habrastorage.org/getpro/habr/post_images/ba2/1c8/eeb/ba21c8eeb00ef767cf6f5bd5297f986e.svg">  dapat dihitung dari sasaran rata-rata di simpul induk Î¼ dan <img src="https://habrastorage.org/getpro/habr/post_images/88d/4eb/4bb/88d4eb4bb69acbcbbbf4ad0e10098a80.svg">  sebagai berikut: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b0a/e76/10a/b0ae7610afe1aa13d10de797871193c6.svg"></p><br><h4 id="233-vybor-priznakov">  2.3.3 Pemilihan karakteristik </h4><br><p>  Solusi di setiap node didasarkan pada nilai ambang dari perbedaan dalam nilai intensitas dalam sepasang piksel.  Ini adalah tes yang cukup sederhana, tetapi jauh lebih efektif daripada nilai ambang batas dengan intensitas tunggal, karena relatif tidak sensitif terhadap perubahan pencahayaan global.  Sayangnya, kelemahan menggunakan perbedaan piksel adalah bahwa jumlah kandidat pemisahan potensial (fitur) kuadrat sehubungan dengan jumlah piksel dalam gambar rata-rata.  Hal ini membuat sulit untuk menemukan barang yang bagus tanpa mencari dalam jumlah yang besar.  Namun, faktor pembatas ini bisa agak melemah, dengan mempertimbangkan struktur data gambar. </p><br><p>  Kami memperkenalkan distribusi eksponensial </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f30/6b8/6c4/f306b86c47bfa440c1d1c716e3c9d6b8.svg">  <em>(12)</em> </p><br><p>  oleh jarak antara piksel yang digunakan dalam pemisahan untuk mendorong pemilihan pasangan piksel yang lebih dekat. </p><br><p>  Kami telah menemukan bahwa menggunakan distribusi sederhana ini mengurangi kesalahan prediksi untuk sejumlah set data wajah.  Gambar 4 membandingkan fitur yang dipilih dengan dan tanpa itu, di mana ukuran kumpulan objek dalam kedua kasus diatur ke 20. </p><br><h1 id="24-obrabotka-propuschennyh-metok">  2.4.  Menangani Tag yang Hilang </h1><br><p>  Masalah persamaan (10) dapat dengan mudah diperluas untuk menangani kasus ketika beberapa landmark tidak ditandai pada beberapa gambar pelatihan (atau kami memiliki ukuran ketidakpastian untuk setiap landmark).  Masukkan variabel <img src="https://habrastorage.org/getpro/habr/post_images/7e0/805/7ed/7e08057ed464a0c8c2af586f05a009aa.svg">  [0, 1] untuk setiap gambar pelatihan <em>i</em> dan setiap tengara <em>j</em> .  Instalasi <img src="https://habrastorage.org/getpro/habr/post_images/260/ce8/a6b/260ce8a6b696864e07aaa5de561923e6.svg">  nilai 0 menunjukkan bahwa landmark <em>j</em> tidak ditandai dalam gambar ke- <em>i</em> , dan pengaturan 1 menunjukkan bahwa itu ditandai.  Maka persamaan (10) dapat direpresentasikan sebagai berikut </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7e5/183/d89/7e5183d8955912640ff62a62fd8913de.svg"></p><br><p>  dimana <img src="https://habrastorage.org/getpro/habr/post_images/07f/821/26e/07f82126e42fc56123ae1a571fcaac7b.svg">  - matriks diagonal dengan vektor <img src="https://habrastorage.org/getpro/habr/post_images/a77/988/515/a779885154cabacbcccfb17d823fd818.svg">  di diagonal dan </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7a7/975/451/7a79754517a719b74cff33c43743171f.svg">  untuk <img src="https://habrastorage.org/getpro/habr/post_images/e17/6e7/ece/e176e7ece99e70aeee6c4ffe2949bb2f.svg">  <em>(13)</em> </p><br><p>  Algoritma peningkatan gradien juga harus dimodifikasi untuk memperhitungkan bobot ini.  Ini dapat dilakukan dengan hanya menginisialisasi model ensemble dengan nilai rata-rata tertimbang dari target dan menyesuaikan pohon regresi ke residu tertimbang dalam algoritma 1 sebagai berikut </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/396/468/7a9/3964687a9c8c905316ef8d6b69d73888.svg">  <em>(14)</em> </p><br><h1 id="3-eksperimenty">  3. Eksperimen </h1><br><p>  <strong>Basis:</strong> Untuk mengevaluasi secara akurat kinerja metode yang kami usulkan, ansambel pohon regresi (ERT), kami membuat dua basis lagi.  Yang pertama didasarkan pada pakis acak (random pakis) dengan sifat seleksi acak (EF), dan yang lainnya adalah versi yang lebih maju dari pendekatan ini dengan pemilihan sifat berdasarkan korelasi (EF + CB), yang merupakan implementasi baru kami [2].  Semua parameter diperbaiki untuk ketiga pendekatan. </p><br><p>  EF menggunakan implementasi langsung pakis acak sebagai pelemah lemah dalam ansambel dan merupakan yang tercepat untuk pelatihan.  Kami menggunakan metode regularisasi yang sama seperti yang disarankan dalam [2] untuk regularisasi pakis. </p><br><p>  EF + CB menggunakan metode pemilihan objek berbasis korelasi yang memproyeksikan nilai output, <img src="https://habrastorage.org/getpro/habr/post_images/ab1/ee0/4fb/ab1ee04fb1210c9352cc942823f6dcd1.svg">  , ke arah acak w dan memilih pasangan tanda (u, v) untuk mana <img src="https://habrastorage.org/getpro/habr/post_images/dcf/e8f/3cc/dcfe8f3ccb1ca1095fc35db5b623abc0.svg">  memiliki korelasi sampel tertinggi untuk data pelatihan dengan sasaran yang diprediksi <img src="https://habrastorage.org/getpro/habr/post_images/b63/418/2d8/b634182d884088b10405bc691e479fd8.svg">  . </p><br><p>  <strong>Parameter</strong> <br>  Kecuali ditentukan lain, semua percobaan dilakukan dengan pengaturan parameter tetap berikut.  Jumlah regresi kuat dalam kaskade adalah T = 10, dan masing-masing <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg">  terdiri dari K = 500 regressor yang lemah <img src="https://habrastorage.org/getpro/habr/post_images/cfb/227/fd2/cfb227fd27d043451a49e2337d85a6bf.svg">  .  Kedalaman pohon (atau pakis) digunakan untuk mewakili <img src="https://habrastorage.org/getpro/habr/post_images/cfb/227/fd2/cfb227fd27d043451a49e2337d85a6bf.svg">  , set sama dengan F = 5. Pada setiap level kaskade, P = 400 piksel dipilih dari gambar.  Untuk melatih regressor yang lemah, kami secara acak memilih sepasang piksel P ini sesuai dengan distribusi kami dan memilih ambang acak untuk membuat pemisahan potensial, seperti yang dijelaskan dalam persamaan (9).  Pemisahan terbaik dicapai dengan mengulangi proses ini S = 20 kali dan memilih salah satu yang mengoptimalkan tujuan kami.        ,   R = 20      . </p><br><p><img src="https://habrastorage.org/webt/7j/we/fs/7jwefsr7puidwxuehw6owexel8k.png"></p><br><p> <em> 2.       ,             Viola &amp; Jones [17].        .</em> </p><br><p> <strong></strong> <br>          O (TKF).          O (NDTKF S),  N â€”   ,  D â€”  .                HELEN [12],           . </p><br><p> <strong> </strong> <br>   ,   ,      HELEN [12], ,   ,      .    2330 ,     194 .      2000    ,    . </p><br><p>           LFPW [1],    1432 .  ,     778    216   ,         ,      . </p><br><p>  <strong>Perbandingan</strong> <br>  1         .                  (Active Shape Models) â€” STASM [14]  CompASM [12]. </p><br><p><img src="https://habrastorage.org/webt/89/fk/kc/89fkkczbo119vyy4oo7hhu7cmno.png"></p><br><p> <em> 1.        HELEN.  â€”          .       .      ,        .    ,       .              .</em> </p><br><p>   ,    ,        .   3       ,  ,  ERT     ,   .  ,        EF + CB     .  ,      EF + CB       ,     . </p><br><p>          LFPW [1] ( 2).    EF + CB     ,   [2]. (     ,        .)              ,      ,     . </p><br><p><img src="https://habrastorage.org/webt/ef/uu/nz/efuunznz_ljfv_sr1v1vi5fujoy.png"></p><br><p> <em> 2.        LFPW.       1.</em> </p><br><p> <strong> </strong> <br>  4     (12)       ,   ,      .  Î»               0,1   .            <img src="https://habrastorage.org/getpro/habr/post_images/8a3/da7/d5c/8a3da7d5c0b3aeb3983a52357424a4ba.svg">         .  4          . </p><br><p><img src="https://habrastorage.org/webt/do/pm/v4/dopmv4u-mj6pa5tcaioawlcvegs.png"></p><br><p> <em> 3.           .         ,  , .  (12).</em> </p><br><p> <strong></strong> <br>        ,   .     ,     .    â€” .        Î½      1 (   Î½ = 0.1).           .  , <img src="https://habrastorage.org/getpro/habr/post_images/cfb/227/fd2/cfb227fd27d043451a49e2337d85a6bf.svg">   ,    ,    Î½ = 1.                   (10   )   . (      .) </p><br><p><img src="https://habrastorage.org/webt/lp/hv/hv/lphvhvclakdn02mzwrfe5rtt28w.png"></p><br><p> <em> 3.       HELEN (a)  LFPW (b). EF â€”    ,  EF + CB â€”      ,   .          (5  10),    [2].  ,      (ERT),     ,     ,             .</em> </p><br><p><img src="https://habrastorage.org/webt/xm/3y/pp/xm3yppxdejbgcglidfb-ecofaza.png"></p><br><p> <em> 4.   ,    .       ,      .</em> </p><br><p>             ,   .         ,    . </p><br><p><img src="https://habrastorage.org/webt/0r/hv/l0/0rhvl0mowqozwdscxpkc-lp-w7e.png"></p><br><p> <em> 4.      HELEN     .                .</em> </p><br><p>    ,          .   ,        ,    ,        ,       . </p><br><p> <strong></strong> <br>                 .              .  5          .    ,    ,      [8, 2] (           10 Ã— 400 .) </p><br><p><img src="https://habrastorage.org/webt/rt/sa/n3/rtsan3fkhl6houggpnk8zyiwqie.png"></p><br><p> <em> 5.             .</em> </p><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data pelatihan</font></font></strong> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk menguji keefektifan metode kami dalam hal jumlah gambar pelatihan, kami melatih berbagai model dari subset data pelatihan yang berbeda. </font><font style="vertical-align: inherit;">Tabel 6 merangkum hasil akhir, dan Gambar 5 menunjukkan grafik kesalahan di setiap tingkat kaskade. </font><font style="vertical-align: inherit;">Menggunakan banyak level regressor sangat berguna ketika kita memiliki banyak contoh pelatihan.</font></font></p><br><p> Kami mengulangi percobaan yang sama dengan jumlah total tetap contoh yang diperluas, tetapi mengubah kombinasi bentuk awal yang digunakan untuk membuat contoh pelatihan dari satu contoh wajah yang ditandai dan sejumlah gambar beranotasi yang digunakan untuk mempelajari kaskade (Tabel 7). </p><br><p><img src="https://habrastorage.org/webt/8p/-8/bb/8p-8bbob2qvordp1hhebxruts38.png"></p><br><p>  <em>Tabel 6. Tingkat kesalahan akhir untuk jumlah contoh pelatihan.</em>  <em>Saat membuat data pelatihan untuk mempelajari regresi cascading, setiap gambar wajah yang ditandai menghasilkan 20 contoh pelatihan, menggunakan 20 wajah yang ditandai sebagai asumsi awal tentang bentuk wajah.</em> </p><br><p><img src="https://habrastorage.org/webt/0o/ft/7s/0oft7ss-mbxhjnln3wje3hqzxau.png"></p><br><p>  <em>Gambar 5. Kesalahan rata-rata di setiap tingkat kaskade disajikan tergantung pada jumlah contoh pelatihan yang digunakan.</em>  <em>Penggunaan banyak level regressor sangat berguna ketika jumlah contoh pelatihan besar.</em> </p><br><p><img src="https://habrastorage.org/webt/am/mj/aq/ammjaqyvpgnzjynmk0ychb7lnw8.png"></p><br><p>  <em>Tabel 7. Di sini jumlah contoh pelatihan efektif diperbaiki, tetapi kami menggunakan berbagai kombinasi jumlah gambar pelatihan dan jumlah formulir awal yang digunakan untuk setiap gambar wajah yang ditandai.</em> </p><br><p>  Meningkatkan data pelatihan menggunakan berbagai formulir awal akan memperluas kumpulan data dalam bentuk formulir.  Hasil kami menunjukkan bahwa jenis suplemen ini tidak sepenuhnya mengimbangi ketiadaan gambar pelatihan beranotasi.  Meskipun tingkat peningkatan diperoleh dengan meningkatkan jumlah gambar pelatihan dengan cepat menurun setelah beberapa ratus gambar pertama. </p><br><p>  <strong>Anotasi sebagian</strong> <br>  Tabel 8 menunjukkan hasil penggunaan data beranotasi sebagian.  200 studi kasus dijelaskan sepenuhnya, dan sisanya hanya sebagian. </p><br><p><img src="https://habrastorage.org/webt/iu/j9/7q/iuj97qa3-awn35lf8z3yibbuzhw.png"></p><br><p>  <em>Tabel 8. Hasil menggunakan data berlabel sebagian.</em>  <em>200 contoh selalu sepenuhnya beranotasi.</em>  <em>Nilai dalam tanda kurung menunjukkan persentase landmark yang diamati.</em> </p><br><p>  Hasilnya menunjukkan bahwa kami dapat mencapai peningkatan yang signifikan menggunakan data yang diberi label sebagian.  Namun, peningkatan yang ditampilkan mungkin tidak jenuh, karena kita tahu bahwa ukuran dasar dari parameter bentuk jauh lebih rendah daripada ukuran landmark (194 Ã— 2).  Akibatnya, ada potensi untuk peningkatan yang lebih signifikan dengan tanda parsial, jika Anda secara eksplisit menggunakan korelasi antara posisi tengara.  Harap dicatat bahwa prosedur peningkatan gradien yang dijelaskan dalam artikel ini tidak menggunakan korelasi antara landmark.  Masalah ini dapat diselesaikan di pekerjaan mendatang. </p><br><h1 id="4-vyvod">  4. Kesimpulan </h1><br><p>  Kami menggambarkan bagaimana ansambel pohon regresi dapat digunakan untuk regresi lokasi landmark wajah dari himpunan bagian dari nilai intensitas yang diekstraksi dari gambar input.  Struktur yang disajikan mengurangi kesalahan lebih cepat dari pekerjaan sebelumnya, dan juga dapat memproses tanda parsial atau tidak terdefinisi.  Sementara komponen utama dari algoritma kami mempertimbangkan berbagai pengukuran target sebagai variabel independen, kelanjutan alami dari pekerjaan ini adalah penggunaan korelasi parameter bentuk untuk pelatihan yang lebih efektif dan penggunaan label parsial yang lebih baik. </p><br><p><img src="https://habrastorage.org/webt/am/cu/xs/amcuxsbdkp6du3rohxpnoey0r2q.png"></p><br><p>  <em>Gambar 6. Hasil akhir dalam database HELEN.</em> </p><br><p>  <strong>Ucapan Terima Kasih</strong> <br>  Pekerjaan ini didanai oleh Swedish Strategic Research Foundation sebagai bagian dari proyek VINST. </p><br><h1 id="ispolzovannaya-literatura">  Literatur bekas </h1><br><p>  [1] PN Belhumeur, DW Jacobs, DJ Kriegman, dan N. Kumar.  Melokalkan bagian-bagian wajah menggunakan konsensus eksemplar.  Dalam CVPR, halaman 545â€“552, 2011. 1, 5 <br>  [2] X. Cao, Y. Wei, F. Wen, dan J. Sun.  Perataan wajah dengan regresi bentuk eksplisit.  Dalam CVPR, halaman 2887â€“2894, 2012. 1, 2, 3, 4, 5, 6 <br>  [3] TF Cootes, M. Ionita, C. Lindner, dan P. Sauer.  Model bentuk yang kuat dan akurat cocok menggunakan voting regresi hutan acak.  Dalam ECCV, 2012.1 <br>  [4] TF Cootes, CJ Taylor, DH Cooper, dan J. Graham.  Model bentuk aktif - pelatihan dan aplikasi mereka.  Visi Komputer dan Pemahaman Gambar, 61 (1): 38â€“59, 1995.1, 2 <br>  [5] D. Cristinacce dan TF Cootes.  Meningkatkan model bentuk aktif regresi.  Dalam BMVC, halaman 79.1â€“79.10, 2007.1 <br>  [6] M. Dantone, J. Gall, G. Fanelli, dan LV Gool.  Deteksi fitur wajah real-time menggunakan hutan regresi bersyarat.  Dalam CVPR, 2012.1 <br>  [7] L. Ding dan AM MartÂ´Ä±nez.  Deteksi rinci wajah dan fitur wajah.  Dalam CVPR, 2008.1 <br>  [8] P. Dollar, P. Welinder, dan P. Perona.  Regresi bertingkat bertingkat.  Dalam CVPR, halaman 1078-1085, 2010. 1, 2, 6 <br>  [9] GJ Edwards, TF Cootes, dan CJ Taylor.  Kemajuan dalam model penampilan aktif.  Dalam ICCV, halaman 137â€“142, 1999. 1, 2 <br>  [10] T. Hastie, R. Tibshirani, dan JH Friedman.  Unsur-unsur pembelajaran statistik: penambangan data, inferensi, dan prediksi.  New York: Springer-Verlag, 2001.2,3 <br>  [11] V. Kazemi dan J. Sullivan.  Penjajaran wajah dengan pemodelan berbasis bagian.  Dalam BMVC, halaman 27.1â€“27.10, 2011.2 <br>  [12] V. Le, J. Brandt, Z. Lin, LD Bourdev, dan TS Huang.  Pelokalan fitur wajah interaktif.  Dalam [13] L. Liang, R. Xiao, F. Wen, dan J. Sun.  Penjajaran wajah melalui pencarian diskriminatif berbasis komponen.  Dalam ECCV, halaman 72-85, 2008. 1ECCV, halaman 679- 692, 2012.5 <br>  [14] S. Milborrow dan F. Nicolls.  Menemukan fitur wajah dengan model bentuk aktif yang diperluas.  Dalam ECCV, halaman 504â€“513, 2008.5 <br>  [15] J. Saragih, S. Lucey, dan J. Cohn.  Model yang dapat dideformasi pas oleh pergeseran tengara yang teregulasi.  Jurnal Internasional Visi Komputer, 91: 200â€“215, 2010.1 <br>  [16] BM Smith dan L. Zhang.  Penjajaran wajah bersama dengan model bentuk nonparametrik.  Dalam ECCV, halaman 43â€“56, 2012.1 <br>  [17] PA Viola dan MJ Jones.  Deteksi wajah real-time yang tangguh.  Dalam ICCV, halaman 747, 2001.5 <br>  [18] X. Zhao, X. Chai, dan S. Shan.  Penjajaran wajah bersama: Menyelamatkan penyelarasan buruk dengan yang baik dengan memasang kembali secara teratur.  Dalam ECCV, 2012.1 <br>  [19] X. Zhu dan D. Ramanan.  Deteksi wajah, estimasi pose, dan pelokalan landmark di alam liar.  Dalam CVPR, halaman 2879â€“2886, 2012.1 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460541/">https://habr.com/ru/post/id460541/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460527/index.html">Pemecahan masalah dengan pwnable.kr 06 - acak dan 09 - kesalahan</a></li>
<li><a href="../id460531/index.html">Penasaran Penasaran dari Dunia IT - 5</a></li>
<li><a href="../id460533/index.html">Anda datang dengan ide produk IT, apa selanjutnya</a></li>
<li><a href="../id460537/index.html">ZuriHac: mempraktikkan pemrograman fungsional</a></li>
<li><a href="../id460539/index.html">Kesalahan penanganan di Vue</a></li>
<li><a href="../id460543/index.html">Sertifikasi baru untuk pengembang dari Cisco. Tinjauan Sertifikasi Industri</a></li>
<li><a href="../id460547/index.html">Barang Antik: Psion 5MX dan Retired Life</a></li>
<li><a href="../id460551/index.html">Portugal Pantai terbaik dan seribu startup per tahun</a></li>
<li><a href="../id460553/index.html">Teknologi, outsourcing, dan mentalitas: bagaimana kami menerapkan Microsoft Dynamics 365 di kantor Jerman Lamoda</a></li>
<li><a href="../id460555/index.html">Laporan dari pertemuan PyDaCon di Mail.ru Group, 22 Juni</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>