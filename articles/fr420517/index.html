<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçï üë®üèæ‚Äçüè≠ üëêüèª Impl√©mentation FPGA de la FFT enti√®re üë®üèº‚Äç‚öïÔ∏è üóûÔ∏è ‚úçüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! 

 Une fois, les clients m'ont demand√© si j'avais de la FFT enti√®re dans mes projets, √† laquelle j'ai toujours r√©pondu que cela avait ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Impl√©mentation FPGA de la FFT enti√®re</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420517/"> Bonjour √† tous! <br><br>  Une fois, les clients m'ont demand√© si j'avais de la FFT enti√®re dans mes projets, √† laquelle j'ai toujours r√©pondu que cela <u>avait d√©j√† √©t√© fait par d'autres</u> sous la forme de c≈ìurs IP pr√™ts √† l'emploi, bien que courbes, mais gratuits (Altera / Xilinx) - prenez-le et utilisez-le.  Cependant, ces c≈ìurs <b>ne</b> sont <b>pas optimaux</b> , ont un ensemble de ¬´fonctionnalit√©s¬ª et n√©cessitent un raffinement suppl√©mentaire.  √Ä cet √©gard, apr√®s avoir pris d'autres vacances pr√©vues, que je ne voulais pas passer m√©diocres, j'ai commenc√© √† impl√©menter le noyau configurable de la FFT enti√®re. <br><br><img src="https://habrastorage.org/webt/rn/s4/d1/rns4d1s48360ir8tjj1pwu7qcee.png"><br>  <sub><i>KDPV (processus de d√©bogage des erreurs de d√©bordement de donn√©es)</i></sub> <br><br>  Dans l'article, je veux vous dire par quelles m√©thodes et moyens les op√©rations math√©matiques sont r√©alis√©es lors du calcul de la transform√©e de Fourier rapide dans un format entier sur des cristaux FPGA modernes.  La base de toute FFT est un n≈ìud appel√© ¬´papillon¬ª.  Le papillon met en ≈ìuvre des op√©rations math√©matiques - addition, multiplication et soustraction.  C'est sur l'impl√©mentation du "papillon" et de ses n≈ìuds finis que l'histoire se d√©roulera en premier.  Bas√© sur les familles FPGA Xilinx modernes - ce sont les s√©ries Ultrascale et Ultrascale +, ainsi que les anciennes s√©ries 6- (Virtex) et 7- (Artix, Kintex, Virtex) sont affect√©es.  Les anciennes s√©ries de projets modernes ne sont pas int√©ressantes en 2018.  Le but de l'article est de r√©v√©ler les caract√©ristiques de la mise en ≈ìuvre de noyaux personnalis√©s de traitement de signal num√©rique en utilisant l'exemple FFT. <br><a name="habracut"></a><br><h3>  Pr√©sentation </h3><br>  Ce n'est un secret pour personne que les algorithmes pour prendre la FFT sont fermement ancr√©s dans la vie des ing√©nieurs en traitement du signal num√©rique, et donc cet outil est constamment n√©cessaire.  Les principaux fabricants de FPGA tels que Altera / Xilinx ont d√©j√† des c≈ìurs FFT / IFFT configurables flexibles, mais ils ont un certain nombre de limitations et de fonctionnalit√©s, et j'ai donc d√ª utiliser ma propre exp√©rience plus d'une fois.  Donc, cette fois, j'ai d√ª impl√©menter une FFT dans un format entier selon le sch√©ma Radix-2 sur le FPGA.  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon dernier article, j'ai d√©j√† fait de la FFT</a> au format virgule flottante, et de l√†, vous savez que l'algorithme √† double parall√©lisme est utilis√© pour impl√©menter la FFT, c'est-√†-dire que le <b>noyau peut traiter deux √©chantillons complexes √† la m√™me fr√©quence</b> .  Il s'agit d'une fonctionnalit√© FFT cl√© qui n'est pas disponible dans les noyaux pr√™ts √† l'emploi FFT Xilinx. <br><br>  <i>Exemple:</i> il est n√©cessaire de d√©velopper un n≈ìud FFT effectuant un fonctionnement continu du flux d'entr√©e de nombres complexes √† une fr√©quence de 800 MHz.  Le c≈ìur de Xilinx ne tirera pas cela (les fr√©quences d'horloge de traitement r√©alisables dans les FPGA modernes sont de l'ordre de 300 √† 400 MHz), ou il faudra d√©cimer le flux d'entr√©e d'une mani√®re ou d'une autre.  Le noyau personnalis√© vous permet de synchroniser deux √©chantillons d'entr√©e √† une fr√©quence de 400 MHz sans intervention pr√©alable, au lieu d'un seul √©chantillon √† 800 MHz.  Un autre <u>inconv√©nient du noyau Xilinx FFT est l'incapacit√© √† accepter le flux d'entr√©e dans l'ordre inverse des bits</u> .  √Ä cet √©gard, une √©norme ressource de m√©moire de puce FPGA est d√©pens√©e pour r√©organiser les donn√©es dans un ordre normal.  Pour les t√¢ches de convolution rapide de signaux, lorsque deux n≈ìuds FFT se tiennent l'un derri√®re l'autre, cela peut devenir un moment critique, c'est-√†-dire que la t√¢che ne r√©side tout simplement pas dans la puce FPGA s√©lectionn√©e.  Le noyau FFT personnalis√© vous permet de recevoir des donn√©es dans l'ordre normal √† l'entr√©e et de les produire en mode bit-reverse, tandis que le noyau de la FFT inverse - au contraire, re√ßoit les donn√©es dans l'ordre bit-reverse et les sort en mode normal.  Deux tampons pour la permutation des donn√©es sont enregistr√©s √† la fois !!! <br><br>  √âtant donn√© que la plupart des √©l√©ments de cet article peuvent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chevaucher le pr√©c√©dent</a> , j'ai d√©cid√© de me concentrer sur le th√®me des op√©rations math√©matiques au format entier sur FPGA pour la mise en ≈ìuvre de la FFT. <br><br><h3>  Param√®tres du noyau FFT </h3><br><ul><li>  <i>NFFT</i> - nombre de papillons (longueur FFT), </li><li>  <i>DATA_WIDTH</i> - profondeur de bits des donn√©es d'entr√©e (4-32), </li><li>  <i>TWDL_WIDTH</i> - profondeur de bits des facteurs de rotation (8-27). </li><li>  <i>SERIES</i> - d√©finit la famille FPGA sur laquelle la FFT est impl√©ment√©e (¬´NEW¬ª - Ultrascale, ¬´OLD¬ª - 6/7 Xilinx FPGA series). </li></ul><br><img src="https://habrastorage.org/webt/jr/ko/rp/jrkorpz6jkzl7tiltyajcgy_2ns.png"><br><br>  Comme toutes les autres liaisons du circuit, la FFT poss√®de des ports de contr√¥le d'entr√©e - un signal d'horloge et une r√©initialisation, ainsi que des ports de donn√©es d'entr√©e et de sortie.  De plus, le signal USE_FLY est utilis√© dans le noyau, ce qui vous permet de d√©sactiver dynamiquement les papillons FFT pour les processus de d√©bogage ou de voir le flux d'entr√©e d'origine. <br><br>  Le tableau ci-dessous montre la quantit√© de ressources FPGA utilis√©es, en fonction de la longueur de la FFT NFFT pour DATA_WIDTH = 16 et deux bits TWDL_WIDTH = 16 et 24 bits. <br><br><img src="https://habrastorage.org/webt/12/cg/5d/12cg5dao_i8ihsv3-_0bqjufmgy.png"><br><br>  Le noyau √† NFFT = 64K est stable √† la fr√©quence de traitement <b>FREQ = 375 MHz</b> sur un cristal Kintex-7 (410T). <br><br><h3>  Structure du projet </h3><br><br>  Le graphique sch√©matique du n≈ìud FFT est illustr√© dans la figure suivante: <br><img src="https://habrastorage.org/webt/af/4t/zx/af4tzxcjc6sltju9ldyi8clctz8.png"><br><br>  Pour faciliter la compr√©hension des fonctionnalit√©s de certains composants, je vais donner une liste des fichiers de projet et leur br√®ve description dans un ordre hi√©rarchique: <br><ul><li>  <b>Noyaux FFT:</b> <br><ul><li>  <i>int_fftNk</i> - N≈ìud FFT, circuit Radix-2, d√©cimation de fr√©quence (DIF), le flux d'entr√©e est normal, le flux de sortie est invers√©. </li><li>  <i>int_ifftNk</i> - Noeud <i>OBPF</i> , circuit Radix-2, d√©cimation temporelle (DIT), le flux d'entr√©e est invers√©, le flux de sortie est normal. </li></ul></li><li>  <b>Papillons:</b> <br><br><ul><li>  <i>int_dif2_fly</i> - papillon Radix-2, d√©cimation en fr√©quence, </li><li>  <i>int_dit2_fly</i> - papillon Radix-2, d√©cimation dans le temps, </li></ul></li><li>  <b>Multiplicateurs complexes:</b> <br><br><ul><li>  <i>int_cmult_dsp48</i> - multiplicateur configurable g√©n√©ral, comprend: </li><li>  <i>int_cmult18x25_dsp48</i> - multiplicateur pour de faibles <i>profondeurs de</i> bits <i>des</i> donn√©es et des facteurs de rotation, </li><li>  <i>int_cmult_dbl18_dsp48</i> - multiplicateur doubl√©, largeur de bits des facteurs de rotation jusqu'√† 18 bits, </li><li>  <i>int_cmult_dbl35_dsp48</i> - multiplicateur doubl√©, largeur de bits des facteurs de rotation jusqu'√† 25 * bits, </li><li>  <i>int_cmult_trpl18_dsp48</i> - triple multiplicateur, la capacit√© des facteurs de rotation jusqu'√† 18 bits, </li><li>  <i>int_cmult_trpl52_dsp48</i> - triple multiplicateur, la capacit√© des facteurs de rotation jusqu'√† 25 * bits, </li></ul></li><li>  <b>Multiplicateurs:</b> <br><br><ul><li>  <i>mlt42x18_dsp48e1</i> - un multiplicateur avec des bits d'op√©randes jusqu'√† 42 et 18 bits bas√©s sur DSP48E1, </li><li>  <i>mlt59x18_dsp48e1</i> - multiplicateur avec des bits d'op√©rande jusqu'√† 59 et 18 bits bas√©s sur DSP48E1, </li><li>  <i>mlt35x25_dsp48e1</i> - un multiplicateur avec des bits d'op√©randes jusqu'√† 35 et 25 bits bas√©s sur DSP48E1, </li><li>  <i>mlt52x25_dsp48e1</i> - un multiplicateur avec des bits d'op√©randes jusqu'√† 52 et 25 bits bas√©s sur DSP48E1, </li><li>  <i>mlt44x18_dsp48e2</i> - multiplicateur avec des bits d'op√©randes jusqu'√† 44 et 18 bits bas√©s sur DSP48E2, </li><li>  <i>mlt61x18_dsp48e2</i> - multiplicateur avec bits d'op√©rande jusqu'√† 61 et 18 bits bas√© sur DSP48E2, </li><li>  <i>mlt35x27_dsp48e2</i> - multiplicateur avec des bits d'op√©rande jusqu'√† 35 et 27 bits bas√©s sur DSP48E2, </li><li>  <i>mlt52x27_dsp48e2</i> est un multiplicateur avec des bits d'op√©rande jusqu'√† 52 et 27 bits bas√©s sur DSP48E2. </li></ul></li><li>  <b>Totalisateur:</b> <br><br><ul><li>  <i>int_addsub_dsp48</i> - additionneur universel, bits d'op√©rande jusqu'√† 96 bits. </li></ul></li><li>  <b>Lignes de retard:</b> <br><br><ul><li>  <i>int_delay_line</i> - la ligne de base du retard, fournit une permutation des donn√©es entre les papillons, </li><li>  <i>int_align_fft</i> - alignement des donn√©es d'entr√©e et des facteurs de retournement √† l'entr√©e du papillon FFT, </li><li>  <i>int_align_fft</i> - alignement des donn√©es d'entr√©e et des facteurs de retournement √† l'entr√©e du papillon <i>OBPF</i> , </li></ul></li><li>  <b>Facteurs tournants:</b> <br><br><ul><li>  <i>rom_twiddle_int</i> - un g√©n√©rateur de facteurs rotatifs, √† partir d'une certaine longueur la FFT consid√®re des coefficients bas√©s sur des cellules FPGA DSP, </li><li>  <i>row_twiddle_tay</i> - g√©n√©rateur de facteurs rotatifs utilisant une s√©rie de Taylor (NFFT&gt; 2K) **. </li></ul></li><li>  <b>Tampon de donn√©es:</b> <br><br><ul><li>  <i>inbuf_half_path</i> - tampon d'entr√©e, re√ßoit le flux en mode normal et produit deux s√©quences d'√©chantillons d√©cal√©es de la moiti√© de la longueur de la FFT ***, </li><li>  <i>outbuf_half_path</i> - le tampon de sortie, collecte deux s√©quences et produit une continue √©gale √† la longueur de la FFT, </li><li>  <i>iobuf_flow_int2</i> - le tampon fonctionne en deux modes: il re√ßoit un flux en mode Interleave-2 et produit deux s√©quences de FFT d√©cal√©es de moiti√©.  Ou vice versa, selon l'option BITREV. </li><li>  <i>int_bitrev_ord</i> est un simple convertisseur de donn√©es de l'ordre naturel au bit-reverse. </li></ul></li></ul><br>  <i>* - pour DSP48E1: 25 bits, pour DSP48E2 - 27 bits.</i> <br>  <i>** - √† partir d'un certain stade de la FFT, une quantit√© fixe de m√©moire de bloc peut √™tre utilis√©e pour stocker des coefficients de rotation, et des coefficients interm√©diaires peuvent √™tre calcul√©s en utilisant des n≈ìuds DSP48 en utilisant la formule de Taylor √† la premi√®re d√©riv√©e.</i>  <i>En raison du fait que la ressource m√©moire est plus importante pour la FFT, vous pouvez sacrifier en toute s√©curit√© les unit√©s de calcul pour la m√©moire.</i> <i><br></i>  <i>*** - tampon d'entr√©e et lignes √† retard - contribuent de mani√®re significative √† la quantit√© de ressources m√©moire FPGA occup√©es</i> <br><br>  <b>Papillon</b> <br><br>  Quiconque a rencontr√© au moins une fois l'algorithme de transform√©e de Fourier rapide sait que cet algorithme est bas√© sur une op√©ration √©l√©mentaire - un ¬´papillon¬ª.  Il convertit le flux d'entr√©e en multipliant l'entr√©e par le facteur de torsion.  Il existe deux sch√©mas de conversion classiques pour les FFT: la d√©cimation en fr√©quence (DIF, d√©cimation en fr√©quence) et la d√©cimation en temps (DIT, d√©cimation en temps).  L'algorithme DIT est caract√©ris√© en divisant la s√©quence d'entr√©e en deux s√©quences de demi-dur√©e et l'algorithme DIF en deux s√©quences d'√©chantillons pairs et impairs de dur√©e NFFT.  De plus, ces algorithmes diff√®rent dans les op√©rations math√©matiques pour l'op√©ration papillon. <br><br><img src="https://habrastorage.org/webt/ka/d9/hr/kad9hr8dktrs2l7jhb9iq3lm6em.png"><br><br>  <i>A, B</i> - paires d'entr√©e d'√©chantillons complexes, <br>  <i>X, Y</i> - paires de sortie d'√©chantillons complexes, <br>  <i>W</i> - facteurs de retournement complexes. <br><br>  Les donn√©es d'entr√©e √©tant des quantit√©s complexes, le papillon n√©cessite un multiplicateur complexe (4 op√©rations de multiplication et 2 op√©rations d'addition) et deux additionneurs complexes (4 op√©rations d'addition).  C'est toute la base math√©matique qui doit √™tre impl√©ment√©e sur le FPGA. <br><br><h3>  Multiplicateur </h3><br>  Il convient de noter que toutes les op√©rations math√©matiques sur les FPGA sont souvent effectu√©es dans du code suppl√©mentaire (compl√©ment √† 2).  Le multiplicateur FPGA peut √™tre impl√©ment√© de deux mani√®res - sur la logique √† l'aide de d√©clencheurs et de tables LUT, ou sur des unit√©s de calcul DSP48 sp√©ciales, qui ont longtemps et fermement √©t√© incluses dans tous les FPGA modernes.  Sur les blocs logiques, la multiplication est mise en ≈ìuvre √† l'aide de l'algorithme de Booth ou de ses modifications, occupe une quantit√© d√©cente de ressources logiques et ne satisfait pas toujours les contraintes de temps √† des fr√©quences de traitement de donn√©es √©lev√©es.  √Ä cet √©gard, les multiplicateurs FPGA dans les projets modernes sont presque toujours con√ßus sur la base de n≈ìuds DSP48 et seulement occasionnellement sur la logique.  Un n≈ìud DSP48 est une cellule finie complexe qui impl√©mente des fonctions math√©matiques et logiques.  Op√©rations de base: multiplication, addition, soustraction, accumulation, compteur, op√©rations logiques (XOR, NAND, AND, OR, NOR), quadrature, comparaison de nombres, d√©calage, etc.  La figure suivante montre la cellule DSP48E2 pour la famille Xilinx Ultrascale + FPGA. <br><br><img src="https://habrastorage.org/webt/rz/_w/bu/rz_wbuxd3sx1d1llz0psh-8tt1e.png"><br><br>  Au moyen d'une configuration simple des ports d'entr√©e, des op√©rations de calcul dans les n≈ìuds et de la d√©finition des retards √† l'int√©rieur du n≈ìud, vous pouvez cr√©er une batteuse de donn√©es math√©matiques √† grande vitesse. <br>  Notez que tous les principaux fournisseurs de FPGA dans l'environnement de d√©veloppement ont des c≈ìurs IP standard et gratuits pour calculer les fonctions math√©matiques bas√©es sur le n≈ìud DSP48.  Ils vous permettent de calculer des fonctions math√©matiques primitives et de d√©finir divers retards √† l'entr√©e et √† la sortie du n≈ìud.  Pour Xilinx, il s'agit du ¬´multiplicateur¬ª IP-Core (version 12.0, 2018), qui vous permet de configurer le multiplicateur √† n'importe quelle profondeur de bits des donn√©es d'entr√©e de 2 √† 64 bits.  De plus, vous pouvez sp√©cifier comment le multiplicateur est impl√©ment√© - sur les ressources logiques ou sur les primitives DSP48 int√©gr√©es. <br><br>  <b>Estimez la quantit√© de logique que le multiplicateur ¬´mange¬ª</b> avec la profondeur de bits des donn√©es d'entr√©e sur les ports A et B = 64 bits.  Si vous utilisez les n≈ìuds DSP48, ils n'en auront besoin que de 16. <br><br><img src="https://habrastorage.org/webt/r5/_e/pb/r5_epbvkf-45ayqoi8jebye_rcu.png"><br><br>  La principale limitation des cellules DSP48 est la profondeur de bits des donn√©es d'entr√©e.  Le n≈ìud DSP48E1, qui est la cellule de base des s√©ries FPGA Xilinx 6 et 7, la largeur des ports d'entr√©e pour la multiplication: "A" - 25 bits, "B" - 18 bits, Par cons√©quent, le r√©sultat de la multiplication est un nombre de 43 bits.  Pour les familles Xilinx Ultrascale et Ultrascale + FPGA, le n≈ìud a subi plusieurs modifications, notamment la capacit√© du premier port augment√©e de deux bits: ¬´A¬ª - 27 bits, ¬´B¬ª - 18 - bits.  De plus, le n≈ìud lui-m√™me est appel√© DSP48E2. <br><br>  Afin de ne pas √™tre li√© √† une famille sp√©cifique et √† une puce FPGA, pour garantir la ¬´puret√© du code source¬ª et pour prendre en compte toutes les profondeurs de bits possibles des donn√©es d'entr√©e, il a √©t√© d√©cid√© de concevoir notre propre ensemble de multiplicateurs.  Cela permettra la mise en ≈ìuvre la plus efficace de multiplicateurs complexes pour les papillons FFT, √† savoir des multiplicateurs et un additionneur-soustracteur bas√© sur des blocs DSP48.  La premi√®re entr√©e du multiplicateur est les donn√©es d'entr√©e, la deuxi√®me entr√©e du multiplicateur est les facteurs de rotation (signal harmonique de la m√©moire).  Un ensemble de multiplicateurs est impl√©ment√© √† l'aide de la biblioth√®que UNISIM int√©gr√©e, √† partir de laquelle il est n√©cessaire de connecter les primitives DSP48E1 et DSP48E2 pour leur utilisation ult√©rieure dans le projet.  Un ensemble de multiplicateurs est pr√©sent√© dans le tableau.  Il convient de noter que: <br><br><ul><li>  L'op√©ration de multiplication des nombres entra√Æne une augmentation de la capacit√© du produit comme la somme de la capacit√© des op√©randes. </li><li>  En fait, chacun des multiplicateurs 25x18 et 27x18 est dupliqu√© - c'est un composant pour diff√©rentes familles. </li><li>  Plus la phase de parall√©lisme de l'op√©ration est grande, plus le d√©lai de calcul est important et plus les ressources occup√©es sont importantes. </li><li>  Avec une profondeur de bits plus faible √† l'entr√©e ¬´B¬ª, des multiplicateurs avec une profondeur de bits plus √©lev√©e √† une autre entr√©e peuvent √™tre impl√©ment√©s. </li><li>  La principale limitation de l'augmentation de la profondeur de bits est introduite par le port ¬´B¬ª (le port r√©el de la primitive DSP48) et le registre √† d√©calage interne de 17 bits. </li></ul><br><img src="https://habrastorage.org/webt/aw/ma/p9/awmap93marfh0kvrj8loqdrekoo.png"><br><br>  Une nouvelle augmentation de la profondeur de bits n'est pas int√©ressante dans le cadre de la t√¢che pour les raisons d√©crites ci-dessous: <br><br><h3>  Profondeur de bits des facteurs de rotation </h3><br>  On sait que plus la r√©solution du signal harmonique est √©lev√©e, plus le nombre appara√Æt avec pr√©cision (plus il y a de signes dans la partie fractionnaire).  Mais la taille des bits du port est B &lt;25 bits en raison du fait que pour les facteurs de rotation dans les n≈ìuds FFT, cette profondeur de bits est suffisante pour assurer une multiplication de haute qualit√© du flux d'entr√©e avec des √©l√©ments de signal harmoniques dans les ¬´papillons¬ª (pour toutes les longueurs FFT r√©alisables sur les FPGA modernes).  La valeur typique de la profondeur de bits des coefficients de rotation dans les t√¢ches que j'impl√©mente est de 16 bits, 24 - moins souvent, 32 - jamais. <br><br><h3>  Profondeur de bits des √©chantillons d'entr√©e </h3><br>  La capacit√© de ces n≈ìuds de r√©ception et d'enregistrement typiques (ADC, DAC) n'est pas grande - de 8 √† 16 bits, et rarement - de 24 ou 32 bits.  De plus, dans ce dernier cas, il est plus efficace d'utiliser le format de donn√©es √† virgule flottante selon la norme IEEE-754.  D'un autre c√¥t√©, chaque √©tape du ¬´papillon¬ª dans la FFT ajoute un bit de donn√©es aux √©chantillons de sortie en raison d'op√©rations math√©matiques.  Par exemple, pour une longueur de NFFT = 1024, log2 (NFFT) = 10 papillons est utilis√©. <br><br>  Par cons√©quent, la profondeur de bits de sortie sera sup√©rieure de dix bits √† l'entr√©e, WOUT = WIN + 10. En g√©n√©ral, la formule ressemble √† ceci: <br><br>  WOUT = WIN + log2 (NFFT); <br><br>  Un exemple: <br><br>  Profondeur de bits du flux d'entr√©e WIN = 32 bits, <br>  Profondeur de bits des facteurs de rotation TWD = 27, <br>  La capacit√© du port ¬´A¬ª de la liste des multiplicateurs mis en ≈ìuvre dans cet article ne d√©passe pas 52 bits.  Cela signifie que le nombre maximum de papillons est FFT = 52-32 = 20. Autrement dit, il est possible de r√©aliser FFT avec une longueur allant jusqu'√† 2 ^ 20 = 1M d'√©chantillons.  (Cependant, dans la pratique, cela n'est pas possible par des moyens directs en raison de ressources limit√©es, m√™me pour les cristaux FPGA les plus puissants, mais cela se rapporte √† un autre sujet et ne sera pas examin√© dans l'article). <br><br>  Comme vous pouvez le voir, c'est l'une des principales raisons pour lesquelles je n'ai pas impl√©ment√© de multiplicateurs avec une profondeur de bits plus √©lev√©e des ports d'entr√©e.  <b>Les multiplicateurs utilis√©s couvrent la gamme compl√®te des</b> tailles de <b>bits d'</b> entr√©e et des facteurs de rotation <b>requis</b> pour le calcul de la FFT enti√®re.  Dans tous les autres cas, vous pouvez utiliser le calcul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>FFT au format virgule flottante</b></a> ! <br><br><h3>  La mise en place du multiplicateur "large" </h3><br>  Sur la base d'un exemple simple de multiplication de deux nombres qui ne correspondent pas √† la profondeur de bits d'un n≈ìud DSP48 standard, je vais montrer comment vous pouvez impl√©menter un multiplicateur de donn√©es large.  La figure suivante montre son sch√©ma de principe.  Le multiplicateur impl√©mente la multiplication de deux nombres sign√©s dans le code suppl√©mentaire, la largeur du premier op√©rande X est de 42 bits, le second Y est de 18 bits.  Il contient deux n≈ìuds DSP48E2.  Deux registres sont utilis√©s pour √©galiser les retards dans le n≈ìud sup√©rieur.  Cela est d√ª au fait que dans l'additionneur sup√©rieur, vous devez ajouter correctement les num√©ros des n≈ìuds sup√©rieur et inf√©rieur du DSP48.  L'additionneur inf√©rieur n'est pas r√©ellement utilis√©.  √Ä la sortie du n≈ìud inf√©rieur, il y a un retard suppl√©mentaire du produit pour aligner le num√©ro de sortie avec le temps.  Le retard total est de 4 cycles. <br><br><img src="https://habrastorage.org/webt/rp/_t/he/rp_the-qaroc7pgzedutsbcb-ee.png"><br><br>  Le travail comprend deux volets: <br><br><ul><li>  La partie la plus jeune: <b>P1 = '0' &amp; X [16: 0] * Y [17: 0];</b> </li><li>  La partie la plus ancienne: <b>P2 = X [42:17] * Y [17: 0] + (P1 &gt;&gt; 17);</b> </li></ul><br><h3>  Totalisateur </h3><br>  Comme un multiplicateur, un additionneur peut √™tre construit sur des ressources logiques √† l'aide d'une cha√Æne de transfert ou sur des blocs DSP48.  Pour atteindre un d√©bit maximal, une deuxi√®me m√©thode est pr√©f√©rable.  Une primitive DSP48 permet d'impl√©menter l'op√©ration d'addition jusqu'√† 48 bits, deux n≈ìuds jusqu'√† 96 bits.  Pour la t√¢che actuelle, de telles profondeurs de bits sont tout √† fait suffisantes.  De plus, la primitive DSP48 dispose d'un mode sp√©cial ¬´MODE SIMD¬ª, qui met en parall√®le l'ALU 48 bits int√©gr√© en plusieurs op√©rations avec diff√©rentes donn√©es de petite capacit√©.  C'est-√†-dire que dans le mode "UN" une grille de bits compl√®te de 48 bits et deux op√©randes sont utilis√©s, et dans le mode "DEUX" la grille de bits est divis√©e en plusieurs flux parall√®les de 24 bits chacun (4 op√©randes).  Ce mode, utilisant un seul additionneur, permet de r√©duire la quantit√© de ressources de puces FPGA occup√©es √† de faibles profondeurs de bits d'√©chantillons d'entr√©e (lors des premi√®res √©tapes de calcul). <br><br><h3>  Augmentation de la profondeur de bits </h3><br>  L'op√©ration de <b>multiplication de</b> deux nombres par les bits N et M dans un code binaire suppl√©mentaire conduit √† une augmentation de la capacit√© des bits de sortie √† <b>P = N + M.</b> <br><br>  Exemple: pour multiplier des nombres √† trois bits N = M = 3, le nombre positif maximum est +3 = <i>(011) <sub>2</sub></i> et le nombre n√©gatif maximum est 4 = <i>(100) <sub>2</sub></i> .  Le bit le plus significatif est responsable du signe du nombre.  Par cons√©quent, le nombre maximum possible lors de la multiplication est +16 = <i>(010000) <sub>2</sub></i> , qui r√©sulte de la multiplication de deux nombres n√©gatifs maximum -4.  La profondeur de bits de la sortie est √©gale √† la somme des bits d'entr√©e P = N + M = 6 bits. <br><br>  L'op√©ration consistant √† <b>ajouter</b> deux nombres avec les bits N et M dans le code binaire suppl√©mentaire entra√Æne une augmentation du bit de sortie d'un bit. <br><br>  Exemple: ajoutez deux nombres positifs, N = M = 3, le nombre positif maximum est 3 = <i>(011) <sub>2</sub></i> et le nombre n√©gatif maximum est 4 = <i>(100) <sub>2</sub></i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le bit le plus significatif est responsable du signe du nombre. </font><font style="vertical-align: inherit;">Par cons√©quent, le nombre positif maximum est 6 = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(0110) </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et le nombre n√©gatif maximum est -8 = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1000) </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La r√©solution de la sortie augmente d'un bit.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prise en compte des fonctionnalit√©s de l'algorithme </font></font></h3><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Troncature de la profondeur de bits par le haut:</font></font></b></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour minimiser les ressources FPGA dans l'algorithme FFT, il a √©t√© d√©cid√© que lors de la multiplication des donn√©es dans un papillon, n'utilisez jamais le nombre n√©gatif maximum possible pour les coefficients de rotation. Cet amendement n'a pas d'incidence n√©gative sur le r√©sultat. Par exemple, lorsque vous utilisez la repr√©sentation 16 bits des facteurs de rotation, le nombre minimum est -32768 = 0x8000 et le suivant -32767 = 0x8001. L'erreur lors du remplacement du nombre n√©gatif maximum par la valeur voisine la plus proche sera de</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ~ 0,003%</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et est tout √† fait acceptable pour la t√¢che.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En supprimant le nombre minimum dans le produit de deux nombres, √† chaque it√©ration, vous pouvez r√©duire un bit d'ordre √©lev√© inutilis√©. Exemple: donn√©es - 4 = (100)</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , coefficient +3 = (011)</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. R√©sultat de multiplication = -12 = (110100) </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Le cinqui√®me bit peut √™tre ignor√© car il duplique le voisin, le quatri√®me est un bit de signe. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Troncature de bits par le bas:</font></font></b></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âvidemment, en multipliant le signal d'entr√©e dans le ¬´papillon¬ª par l'effet harmonique, il n'est pas n√©cessaire de tirer la profondeur de bits de sortie dans les papillons suivants, mais un arrondi ou une troncature est requis. Les facteurs de rotation sont pr√©sent√©s dans un format M bits pratique, mais en r√©alit√© il s'agit d'un sinus et cosinus normal normalis√© √† l'unit√©. Autrement dit, le nombre 0x8000 = -1 et le nombre 0x7FFF = +1. Par cons√©quent, le r√©sultat de la multiplication est n√©cessairement tronqu√© √† la profondeur de bits d'origine des donn√©es (c'est-√†-dire que M bits des facteurs de rotation sont tronqu√©s √† partir du bas). Dans toutes les impl√©mentations FFT que j'ai vues, les facteurs de retournement sont normalis√©s √† 1 d'une mani√®re ou d'une autre. Par cons√©quent, √† partir du r√©sultat de la multiplication, il est n√©cessaire de prendre les bits dans la grille suivante [N + M-1-1: M-1]. Le bit le plus significatif n'est pas utilis√© (soustrayez le 1 suppl√©mentaire), les moins significatifs sont tronqu√©s.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'addition / soustraction de donn√©es dans les op√©rations du ¬´papillon¬ª n'est en aucun cas minimis√©e, et seule cette op√©ration contribue √† l' </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">augmentation de la profondeur de bits des donn√©es de sortie d'un bit √† chaque √©tape du calcul</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez qu'au premier stade de l'algorithme FFT DIT ou au dernier stade de l'algorithme FFT DIF, les donn√©es doivent √™tre multipli√©es par un facteur de rotation avec un indice z√©ro W0 = {Re, Im} = {1, 0}. Du fait que la multiplication par l'unit√© et z√©ro sont des op√©rations primitives, elles peuvent √™tre omises. Dans ce cas, l'op√©ration de multiplication complexe n'est pas du tout n√©cessaire: les composants r√©els et imaginaires subissent un ¬´tour¬ª sans changements. Au deuxi√®me stade, deux coefficients sont utilis√©s: W0 = {Re, Im} = {1, 0} et W1 = {Re, Im} = {0, -1}. De m√™me, les op√©rations peuvent √™tre r√©duites √† des transformations √©l√©mentaires et utiliser un multiplexeur pour s√©lectionner l'√©chantillon de sortie. Cela vous permet de sauvegarder de mani√®re significative les blocs DSP48 sur les deux premiers papillons.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le multiplicateur complexe est construit de la m√™me mani√®re - sur la base des multiplicateurs et de l'additionneur-soustracteur, cependant, pour certaines options pour la profondeur de bits des donn√©es d'entr√©e, aucune ressource suppl√©mentaire n'est requise, ce qui sera d√©crit ci-dessous. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le tampon d'entr√©e et les lignes √† retard et les commutateurs crois√©s sont similaires √† ceux d√©crits dans l'article pr√©c√©dent. </font><font style="vertical-align: inherit;">Les facteurs de rotation deviennent des entiers avec une profondeur de bits configurable. </font><font style="vertical-align: inherit;">Sinon, il n'y a aucun changement global dans la conception du c≈ìur FFT.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fonctions de base de la FFT INT_FFTK </font></font></h3><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sch√©ma de traitement des donn√©es enti√®rement canalis√©. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Longueur de conversion NFFT = 8-512K points. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©glage flexible de la longueur de conversion NFFT. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Format d'entr√©e entier, la largeur de bit est configurable. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Format entier des facteurs rotatifs, la largeur de bit est configurable. </font></font></li><li>            . </li><li>          ! </li><li>        . </li><li> :    ‚Äì   ,    -. </li><li> :     - ,   ‚Äì  . </li><li>      . Radix-2. </li><li>       NFFT *. </li><li>        . </li><li>      (Virtex-6, 7-Series, Ultrascale). </li><li>    <b>~375MHz</b>  Kintex-7 </li><li>   ‚Äì VHDL. </li><li>     bitreverse   +. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projet open source sans inclusion de c≈ìurs IP tiers. </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code source </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code source du noyau FFT INTFFTK sur VHDL (y compris les op√©rations de base et un ensemble de multiplicateurs) et les scripts m pour Matlab / Octave </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont disponibles dans mon profil sur le github</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au cours du d√©veloppement, un nouveau c≈ìur FFT a √©t√© con√ßu, qui offre de meilleures performances par rapport aux pairs. </font><font style="vertical-align: inherit;">La combinaison des c≈ìurs FFT et OBPF ne n√©cessite pas de traduction en ordre naturel, et la longueur de conversion maximale n'est limit√©e que par les ressources FPGA. </font><font style="vertical-align: inherit;">La double concurrence vous permet de traiter des flux d'entr√©e double fr√©quence, ce que IP-CORE Xilinx ne peut pas faire. </font><font style="vertical-align: inherit;">La profondeur de bits √† la sortie de la FFT enti√®re augmente lin√©airement en fonction du nombre d'√©tages de conversion.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans un article pr√©c√©dent, j'ai √©crit sur les plans futurs: FFT core Radix-4, Radix-8, Ultra-Long FFT pour plusieurs millions de points, FFT-FP32 (au format IEEE-754). </font><font style="vertical-align: inherit;">Bref, presque tous sont autoris√©s, mais pour une raison ou une autre, ils ne peuvent pas √™tre rendus publics pour le moment. </font><font style="vertical-align: inherit;">L'exception est l'algorithme FFT Radix-8, avec lequel je n'ai m√™me pas pris la peine (difficile et paresseux). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encore une fois, j'exprime ma gratitude √† </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dsmv2014</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui a toujours accueilli mes id√©es aventureuses.</font></font> Merci de votre attention! <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MISE √Ä JOUR 2018/08/22 </font></font></h3><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajout de l'option SCALED FFT / IFFT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aux codes source </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sur chaque papillon, la profondeur de bits est tronqu√©e de 1 bit (tronquer LSB). </font><font style="vertical-align: inherit;">Profondeur de bits de sortie = profondeur de bits d'entr√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, je donnerai deux graphiques du passage d'un signal r√©el √† travers le FPGA pour montrer la propri√©t√© int√©grale de la transformation, c'est-√†-dire: comment la troncature affecte le r√©sultat de l'accumulation d'erreurs √† la sortie FFT. </font><font style="vertical-align: inherit;">Il est connu de la th√©orie qu'en raison de la transform√©e de Fourier, le rapport signal / bruit se d√©t√©riore lorsque le signal d'entr√©e est tronqu√© par rapport √† la version non tronqu√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple: L'amplitude de l'amplitude d'entr√©e est de 6 bits. </font><font style="vertical-align: inherit;">Le signal est une onde sinuso√Ødale √† 128 √©chantillons PF. </font><font style="vertical-align: inherit;">NFFT = 1024 √©chantillons, DATA_WIDTH = 16, TWDL_WIDTH = 16.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deux graphiques de passage du signal √† travers la FFT</font></font></b> <div class="spoiler_text">  <b>Fig.</b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 Le rapport signal / bruit est faible:</font></font></b> <br><img src="https://habrastorage.org/webt/ww/4b/rg/ww4brg3lv-rb1i_52hqggjfv4fw.png"><br><br>  <b>Fig.</b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 Le rapport signal / bruit est fort:</font></font></b> <br><img src="https://habrastorage.org/webt/kx/uh/go/kxuhgoybynu2kiduizld8r6fvmo.png"><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rose - FSC NON SCAL√â, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bleu - FFT √âCHELLE. </font></font></li></ul><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comme vous pouvez le voir, l'option SCALED n'a pas ¬´tir√©¬ª l'onde sinuso√Ødale du bruit, tandis que l'option UNSCALED a montr√© un bon r√©sultat. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420517/">https://habr.com/ru/post/fr420517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420507/index.html">Contexte: l'Internet mondial pour tous et ses cr√©ateurs</a></li>
<li><a href="../fr420509/index.html">Un probl√®me √©vident avec l'utilisation de l'assertion</a></li>
<li><a href="../fr420511/index.html">Travailler en tant que sp√©cialiste informatique dans la r√©gion Extr√™me-Orient - Amour</a></li>
<li><a href="../fr420513/index.html">Une copie pirat√©e d'un service payant en 39 lignes de code Python</a></li>
<li><a href="../fr420515/index.html">Diarisation bas√©e sur le mod√®le GMM-UBM et l'algorithme d'adaptation MAP</a></li>
<li><a href="../fr420519/index.html">Vulgarisation de la science</a></li>
<li><a href="../fr420521/index.html">Maintenant officiellement: TLS 1.3 reconnu comme standard</a></li>
<li><a href="../fr420523/index.html">Analyse des graphiques d'options binaires ou comment je me suis encore une fois prouv√© que les cadeaux n'existent pas</a></li>
<li><a href="../fr420525/index.html">Des r√©seaux pour les plus aguerris. Quinzi√®me partie. QoS</a></li>
<li><a href="../fr420527/index.html">Un sourire peut retentir et c'est contagieux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>