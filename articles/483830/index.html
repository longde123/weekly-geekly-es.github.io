<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèª üôÉ üêÖ Enrutamiento para iOS: navegaci√≥n universal sin reescribir la aplicaci√≥n üë®üèæ‚Äç‚öñÔ∏è üö¢ ü§µüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En cualquier aplicaci√≥n que consista en m√°s de una pantalla, es necesario implementar la navegaci√≥n entre sus componentes. Parece que esto no deber√≠a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Enrutamiento para iOS: navegaci√≥n universal sin reescribir la aplicaci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/483830/">  En cualquier aplicaci√≥n que consista en m√°s de una pantalla, es necesario implementar la navegaci√≥n entre sus componentes.  Parece que esto no deber√≠a ser un problema, porque en UIKit hay componentes de contenedor bastante convenientes como UINavigationController y UITabBarController, as√≠ como m√©todos de visualizaci√≥n modal flexibles: solo use la navegaci√≥n correcta en el momento correcto. <br><img src="https://habrastorage.org/webt/h0/r3/vf/h0r3vfqvn3tlkotbyelqpy5jqjo.png"><br>  Sin embargo, tan pronto como la aplicaci√≥n cambia a una pantalla usando una notificaci√≥n push o un enlace, todo se vuelve un poco m√°s complicado.  Inmediatamente hay muchas preguntas: <br><br><ul><li>  ¬øQu√© hacer con el controlador de vista, que ahora est√° en la pantalla? </li><li>  ¬øC√≥mo cambiar el contexto (por ejemplo, pesta√±a activa en UITabBarController)? </li><li>  ¬øLa pila de navegaci√≥n actual tiene la pantalla correcta? </li><li>  ¬øCu√°ndo se debe ignorar la navegaci√≥n? </li></ul><br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/rb/dr/zb/rbdrzb1qpjkgxw6zfclqjqtdstq.gif" width="300"><br><br>  En el desarrollo de iOS, en Badoo nos encontramos con todos estos problemas.  Como resultado, formalizamos nuestros m√©todos de soluci√≥n en una biblioteca de componentes para la navegaci√≥n, que usamos en todos los productos nuevos.  En este art√≠culo hablar√© sobre nuestro enfoque con m√°s detalle.  Un ejemplo de la aplicaci√≥n de las pr√°cticas descritas se puede ver en un peque√±o <a href="https://github.com/azatZul/NavigationDemo">proyecto de demostraci√≥n</a> . <br><br><h2>  Nuestro problema </h2><br>  A menudo, los problemas de navegaci√≥n se resuelven agregando un componente global que conoce la estructura de las pantallas en la aplicaci√≥n y decide qu√© hacer en un caso particular.  La estructura de las pantallas significa informaci√≥n sobre la presencia de un contenedor en la jerarqu√≠a actual de controladores y secciones de la aplicaci√≥n. <br><br>  Badoo ten√≠a un componente similar.  Funcion√≥ de manera similar con la biblioteca bastante antigua de Facebook, que ahora ya no se puede encontrar en su repositorio p√∫blico.  La navegaci√≥n se bas√≥ en las URL asociadas con las pantallas de la aplicaci√≥n.  B√°sicamente, toda la l√≥gica estaba contenida en una clase, que estaba vinculada a la presencia de una barra de pesta√±as y a algunas otras funciones espec√≠ficas de Badoo.  La complejidad y conectividad de este componente era tan alta que resolver tareas que requer√≠an un cambio en la l√≥gica de navegaci√≥n podr√≠a llevar varias veces m√°s de lo planeado.  La capacidad de prueba de esta clase tambi√©n plante√≥ grandes preguntas. <br><br>  Este componente se cre√≥ cuando solo ten√≠amos una aplicaci√≥n.  No podr√≠amos imaginar que en el futuro desarrollemos varios productos que sean bastante diferentes entre s√≠ ( <a href="https://bumble.com/">Bumble</a> , <a href="https://lumenapp.com/">Lumen</a> y otros).  Por esta raz√≥n, el navegador de nuestra aplicaci√≥n m√°s madura, Badoo, era imposible de usar en otros productos y cada equipo ten√≠a que encontrar algo nuevo. <br><br>  Desafortunadamente, los nuevos enfoques tambi√©n se han agudizado para aplicaciones espec√≠ficas.  Con el creciente n√∫mero de proyectos, el problema se hizo evidente y surgi√≥ la idea de crear una biblioteca que proporcionara un cierto conjunto de componentes, incluida la l√≥gica de navegaci√≥n universal.  Esto ayudar√≠a a minimizar el tiempo de implementaci√≥n de funcionalidades similares en nuevos productos. <br><br><h2>  Implementamos un enrutador universal </h2><br>  Las tareas principales resueltas por el navegador global no son tantas: <br><br><ol><li>  Encuentra la pantalla activa actual. </li><li>  Compare de alguna manera el tipo de pantalla activa y su contenido con lo que debe mostrarse. </li><li>  Realice la transici√≥n seg√∫n sea necesario (secuencia de transiciones). </li></ol><br>  Quiz√°s la formulaci√≥n de las tareas parezca un poco abstracta, pero es esta abstracci√≥n la que hace posible universalizar la l√≥gica. <br><br><h3>  1. B√∫squeda activa de pantalla </h3><br>  La primera tarea parece bastante simple: solo tienes que recorrer toda la jerarqu√≠a de pantallas y encontrar el <i>UIViewController</i> superior. <br><br><img src="https://habrastorage.org/webt/vw/dj/er/vwdjerugihaukbnwqjri1cd4wu0.png"><br><br>  La interfaz de nuestro objeto puede verse as√≠: <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopViewControllerProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> topViewController: <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre> <br>  Sin embargo, no est√° claro c√≥mo determinar el elemento ra√≠z de la jerarqu√≠a y qu√© hacer con las pantallas de contenedor como UIPageViewController y los contenedores espec√≠ficos de la aplicaci√≥n. <br><br>  La opci√≥n m√°s f√°cil para determinar el elemento ra√≠z es tomar el controlador ra√≠z de la pantalla activa: <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.windows.first { $<span class="hljs-number"><span class="hljs-number">0</span></span>.isKeyWindow }?.rootViewController</code> </pre> <br>  Es posible que este enfoque no siempre funcione con aplicaciones donde hay varias ventanas.  Pero este es un caso bastante raro, y el problema puede resolverse pasando expl√≠citamente la ventana deseada como par√°metro. <br><br>  El problema con las pantallas de contenedor se puede resolver creando un protocolo especial para ellas, que contendr√° un m√©todo para obtener una pantalla activa, o puede usar el protocolo anunciado anteriormente.  Todos los controladores de contenedores utilizados en la aplicaci√≥n deben implementar este protocolo.  Por ejemplo, para un <i>UITabBarController, una</i> implementaci√≥n podr√≠a verse as√≠: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITabBarController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopViewControllerProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> topViewController: <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.selectedViewController } }</code> </pre> <br>  Solo queda recorrer toda la jerarqu√≠a y obtener la pantalla superior.  Si el pr√≥ximo controlador implementa TopViewControllerProvider, obtendremos la pantalla que se muestra a trav√©s del m√©todo declarado.  De lo contrario, el controlador que se muestra en √©l se verificar√° modalmente (si corresponde). <br><br><h3>  2. Contexto actual </h3><br>  La tarea de determinar el contexto actual parece mucho m√°s complicada.  Queremos determinar el tipo de pantalla y, posiblemente, la informaci√≥n que se muestra en ella.  Parece l√≥gico crear una estructura que contenga esta informaci√≥n. <br><br>  Pero, ¬øqu√© tipos deber√≠an tener propiedades de objeto?  Nuestro objetivo final es comparar el contexto con lo que se debe mostrar, por lo que deben implementar el protocolo <i>Equatable</i> .  Esto se puede implementar a trav√©s de tipos gen√©ricos: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContext</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScreenType</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InfoType</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenType: <span class="hljs-type"><span class="hljs-type">ScreenType</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> info: <span class="hljs-type"><span class="hljs-type">InfoType?</span></span> }</code> </pre> <br>  Sin embargo, debido a los detalles de Swift, esto impone ciertas restricciones sobre el uso de este tipo.  Para evitar problemas, esta estructura en nuestras aplicaciones tiene un aspecto ligeramente diferente: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextInfo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to info: ViewControllerContextInfo?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContext</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenType: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> info: <span class="hljs-type"><span class="hljs-type">ViewControllerContextInfo?</span></span> }</code> </pre> <br>  Otra opci√≥n es aprovechar la nueva funci√≥n Swift, <a href="https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html">Tipos opacos</a> , pero solo est√° disponible a partir de iOS 13, que todav√≠a es inaceptable para muchos productos. <br><br>  La implementaci√≥n de la comparaci√≥n de contexto es bastante obvia.  Para no escribir la funci√≥n isEqual para los tipos que ya implementan Equatable, puede hacer un truco simple, esta vez utilizando las ventajas de Swift: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextInfo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to info: ViewControllerContextInfo?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> info = info <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> == info } }</code> </pre> <br>  Genial, tenemos un objeto para comparar.  Pero, ¬øc√≥mo puedes asociarlo con un <i>UIViewController</i> ?  Una forma es usar <a href="https://developer.apple.com/documentation/objectivec/1418509-objc_setassociatedobject%3Flanguage%3Dobjc">objetos asociados</a> , una caracter√≠stica √∫til del lenguaje del Objetivo C en algunos casos, pero en primer lugar, no es muy expl√≠cito y, en segundo lugar, generalmente queremos comparar el contexto de solo algunas pantallas de aplicaciones.  Por lo tanto, crear un protocolo parece buenas ideas: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentContext: <span class="hljs-type"><span class="hljs-type">ViewControllerContext?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre> <br><br>  y su implementaci√≥n solo en las pantallas necesarias.  Si la pantalla activa no implementa este protocolo, entonces su contenido puede considerarse insignificante y no tenerse en cuenta al mostrar uno nuevo. <br><br><h3>  3. Ejecuci√≥n de transici√≥n </h3><br>  Veamos lo que ya tenemos.  La capacidad en cualquier momento de obtener informaci√≥n sobre la pantalla activa en forma de una estructura de datos espec√≠fica.  Informaci√≥n recibida externamente a trav√©s de una URL abierta, notificaci√≥n push u otra forma de iniciar la navegaci√≥n, que se puede convertir en una estructura del mismo tipo y servir como una intenci√≥n de navegaci√≥n.  Si la pantalla superior ya muestra la informaci√≥n necesaria, simplemente puede ignorar la navegaci√≥n o actualizar el contenido de la pantalla. <br><br><img src="https://habrastorage.org/webt/wl/wq/lx/wlwqlxy8knlnfjgy6sg-gmnycm4.png"><br><br>  Pero, ¬øqu√© pasa con la transici√≥n en s√≠? <br><br>  Es l√≥gico hacer un componente (llam√©moslo <b>enrutador</b> ), que tomar√° lo que se necesita mostrar, lo comparar√° con lo que ya se ha mostrado y realizar√° una transici√≥n o secuencia de transiciones.  Adem√°s, el enrutador puede contener l√≥gica general para procesar y validar informaci√≥n y el estado de la aplicaci√≥n.  Lo principal es que no debe incluir la l√≥gica espec√≠fica de un dominio o funci√≥n de aplicaci√≥n en este componente.  Si cumple con esta regla, seguir√° siendo reutilizable para diferentes aplicaciones y f√°cil de mantener. <br><br>  La declaraci√≥n de interfaz b√°sica de dicho protocolo se ve as√≠: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextRouterProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigateToContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context: ViewControllerContext, animated: Bool)</span></span></span></span> }</code> </pre> <br>  Puede generalizar la funci√≥n anterior al pasar una secuencia de contextos.  Esto no tendr√° un impacto significativo en la implementaci√≥n. <br><br>  Es bastante obvio que el enrutador necesitar√° un controlador de f√°brica, porque solo se reciben datos de navegaci√≥n en su entrada.  Es necesario crear pantallas separadas dentro de la f√°brica, y tal vez incluso m√≥dulos completos basados ‚Äã‚Äãen el contexto transferido.  Desde el campo <i>screenType</i> , puede determinar qu√© pantalla desea crear, desde el campo de <i>informaci√≥n</i> , con qu√© datos necesita completar previamente: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllersByContextFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context: ViewControllerContext)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> }</code> </pre> <br>  Si la aplicaci√≥n no es un clon de Snapchat, lo m√°s probable es que el n√∫mero de m√©todos utilizados para mostrar el nuevo controlador sea peque√±o.  Por lo tanto, para la mayor√≠a de las aplicaciones, es suficiente actualizar la pila <i>UINavigationController</i> y mostrar una pantalla modal.  En este caso, puede definir una enumeraci√≥n con posibles tipos, por ejemplo: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NavigationType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> modal <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> navigationStack <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> rootScreen }</code> </pre> <br>  El tipo de pantalla depende de c√≥mo se muestre.  Si se trata de una notificaci√≥n de bloqueo, debe mostrarse modalmente.  Es posible que sea necesario agregar otra pantalla a una pila de navegaci√≥n existente a trav√©s del <i>UINavigationController</i> . <br><br>  Decidir c√≥mo mostrar una pantalla en particular es mejor no en el enrutador.  Si agregamos la dependencia del enrutador bajo el protocolo <i>ViewControllerNavigationTypeProvider</i> e implementamos el conjunto deseado de m√©todos espec√≠ficos para cada aplicaci√≥n, lograremos este objetivo: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerNavigationTypeProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigationType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context: ViewControllerContext)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">NavigationType</span></span> }</code> </pre> <br>  Pero, ¬øqu√© pasa si queremos introducir un nuevo tipo de navegaci√≥n en una de las aplicaciones?  ¬øNecesita agregar una nueva opci√≥n para enumerar, y todas las dem√°s aplicaciones lo sabr√°n?  Probablemente, en algunos casos, esto es exactamente lo que estamos buscando, pero si se adhiere al <a href="https://en.wikipedia.org/wiki/Open%25E2%2580%2593closed_principle">principio abierto-cerrado</a> , entonces, para una mayor flexibilidad, puede ingresar el protocolo de un objeto que puede realizar transiciones: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextTransition</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from source: UIViewController?, to destination: UIViewController, animated: Bool)</span></span></span></span> }</code> </pre> <br>  Entonces <i>ViewControllerNavigationTypeProvider</i> se convertir√° en esto: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextTransitionProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context: ViewControllerContext)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ViewControllerContextTransition</span></span> }</code> </pre> <br>  Ahora no estamos limitados a un conjunto fijo de tipos de pantallas y podemos ampliar las capacidades de navegaci√≥n sin cambios en el enrutador. <br><br>  A veces no es necesario crear un nuevo <i>UIViewController</i> para cambiar a alguna pantalla, simplemente cambie a una existente.  El ejemplo m√°s obvio es el cambio de pesta√±as en un <i>UITabBarController</i> .  Otro ejemplo es la transici√≥n a un elemento existente en la pila de controladores que se muestra en lugar de crear una nueva pantalla con el mismo contenido.  Para hacer esto, en el enrutador, antes de crear un nuevo <i>UIViewController,</i> primero puede verificar si el contexto simplemente se puede cambiar. <br><br>  ¬øC√≥mo resolver este problema?  M√°s abstracciones! <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewControllerContextSwitcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canSwitch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to context: ViewControllerContext)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">switchContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to context: ViewControllerContext, animated: Bool)</span></span></span></span> }</code> </pre> <br>  En el caso de las pesta√±as, este protocolo puede ser implementado por un componente que sepa qu√© contiene el <i>UITabBarViewController</i> y puede asignar <i>ViewControllerContext</i> a una pesta√±a espec√≠fica y cambiar pesta√±as. <br><br><img src="https://habrastorage.org/webt/r_/do/yv/r_doyvigb9gfjp-i8afhu-btglk.gif" width="300"><br><br>  Un conjunto de tales objetos se puede pasar al enrutador como una dependencia. <br><br>  Para resumir, el algoritmo de procesamiento de contexto se ver√° as√≠: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigateToContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context: ViewControllerContext, animated: Bool)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> topViewController = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.topViewControllerProvider.topViewController <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contextHolder = topViewController <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">ViewControllerContextHolder</span></span>, contextHolder.currentContext == context { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> switcher = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.contextSwitchers.first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { $<span class="hljs-number"><span class="hljs-number">0</span></span>.canSwitch(to: context) }) { switcher.switchContext(to: context, animated: animated) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewController = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.viewControllersFactory.viewController(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: context) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> navigation = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.transitionProvider.navigation(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: context) navigation.navigate(from: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.topViewControllerProvider.topViewController, to: viewController, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre> <br><br>  Es conveniente presentar el diagrama de dependencia del enrutador en forma de diagrama UML: <br><br><img src="https://habrastorage.org/webt/jt/ic/gk/jticgkvmsmm5own334ql_uvq6mg.png"><br><br>  El enrutador resultante se puede usar para transiciones iniciadas autom√°ticamente o mediante acciones del usuario.  En nuestros productos, si la navegaci√≥n no se produce autom√°ticamente, se utilizan las funciones est√°ndar del sistema y la mayor√≠a de los m√≥dulos desconocen la existencia de un enrutador global.  Solo es importante recordar acerca de la implementaci√≥n del protocolo <i>ViewControllerContextHolder</i> cuando sea necesario para que el enrutador siempre pueda encontrar la informaci√≥n que el usuario ve en el momento actual. <br><br><h2>  Ventajas y desventajas. </h2><br>  Recientemente, comenzamos a introducir el m√©todo de gesti√≥n de navegaci√≥n descrito en los productos Badoo.  A pesar de que la implementaci√≥n result√≥ ser algo m√°s complicada que la opci√≥n presentada en el <a href="https://github.com/azatZul/NavigationDemo">proyecto de demostraci√≥n</a> , estamos satisfechos con los resultados.  Vamos a evaluar las ventajas y desventajas del enfoque descrito. <br><br>  De los beneficios incluyen: <br><br><ul><li>  universalidad </li><li>  relativa facilidad de implementaci√≥n, en comparaci√≥n con las opciones presentadas en la secci√≥n de alternativas, </li><li>  falta de restricciones en la arquitectura de la aplicaci√≥n y la implementaci√≥n de navegaci√≥n convencional entre pantallas. </li></ul><br>  Las desventajas son en parte consecuencia de las ventajas. <br><br><ul><li>  Los controladores necesitan saber qu√© informaci√≥n muestran.  Si consideramos la arquitectura de la aplicaci√≥n, el UIViewController debe asignarse a la capa de visualizaci√≥n y la l√≥gica empresarial no debe almacenarse en esta capa.  La estructura de datos que contiene el contexto de navegaci√≥n debe implementarse all√≠ desde la capa de l√≥gica de negocios, sin embargo, los controladores almacenar√°n esta informaci√≥n, que no es muy correcta. </li><li>  La fuente de la verdad sobre el estado de la aplicaci√≥n es la jerarqu√≠a de las pantallas que se muestran, lo que en algunos casos puede ser una limitaci√≥n. </li></ul><br><br><h2>  Alternativas </h2><br>  Una alternativa a este enfoque podr√≠a ser construir una jerarqu√≠a de m√≥dulos activos manualmente.  Un ejemplo de tal soluci√≥n es la <a href="https://github.com/AndreyPanov/ApplicationCoordinator">implementaci√≥n del</a> patr√≥n Coordinador, donde los coordinadores forman una estructura de √°rbol que sirve como una fuente de verdad para determinar la pantalla activa, y la l√≥gica de la decisi√≥n de mostrar esta o aquella pantalla est√° contenida en los coordinadores mismos. <br><br>  Se pueden encontrar ideas similares en la arquitectura <a href="https://github.com/uber/RIBs">RIB</a> , que es <a href="https://badootech.badoo.com/the-immense-benefits-of-not-thinking-in-screens-6c311e3344a0">utilizada por</a> nuestro equipo de Android. <br><br>  Dichas alternativas proporcionan una abstracci√≥n m√°s flexible, pero requieren uniformidad en la arquitectura y pueden ser demasiado engorrosas para muchas aplicaciones. <br><br>  Si tom√≥ un enfoque diferente para resolver tales problemas, no dude en hablar de ello en los comentarios. </div></div><p>Source: <a href="https://habr.com/ru/post/483830/">https://habr.com/ru/post/483830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../483804/index.html">Richard Hamming "Cap√≠tulo inexistente": como sabemos lo que sabemos (11-20 minutos de 40)</a></li>
<li><a href="../483818/index.html">Motor, lenguaje de script y novela visual: en 45 horas</a></li>
<li><a href="../483820/index.html">Lo que afecta la emisi√≥n de cr√©dito. Descripci√≥n general de la competencia de riesgo de incumplimiento de cr√©dito de vivienda</a></li>
<li><a href="../483822/index.html">5 caracter√≠sticas de JavaScript sin las cuales no podr√≠a escribir c√≥digo</a></li>
<li><a href="../483826/index.html">Conexi√≥n de un sensor de CO2 Modelo MH-Z19B utilizando la salida anal√≥gica Vo</a></li>
<li><a href="../483832/index.html">RxJava a Coroutines: migraci√≥n de caracter√≠sticas de extremo a extremo</a></li>
<li><a href="../483834/index.html">Debian: simplemente convirtiendo i386 en amd64</a></li>
<li><a href="../483842/index.html">La historia de la creaci√≥n de una nube dom√©stica. Parte 5. Actualizaci√≥n 2019 - PHP 7.2, MariaDB 10.4 y Nextcloud 17</a></li>
<li><a href="../483844/index.html">An√°lisis de documentos reglamentarios sobre protecci√≥n de la informaci√≥n en el sector financiero y crediticio ruso</a></li>
<li><a href="../483846/index.html">Gesti√≥n alternativa de ventanas en Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>