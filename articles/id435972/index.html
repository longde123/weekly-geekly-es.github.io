<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸 🖌️ 🧖🏼 Memperkenalkan pemrograman reaktif di Spring 👨‍👦‍👦 👈🏾 🏴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Minggu ini kami mengharapkan buku Spring 5 baru dari percetakan: 


 Di antara fitur menarik dari Spring 5, pemrograman reaktif layak d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memperkenalkan pemrograman reaktif di Spring</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/435972/">  Halo, Habr! <br><br>  Minggu ini kami mengharapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku</a> Spring 5 baru dari percetakan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ap/o3/tt/apo3ttu5x8fqhvkjyzyrj8g3m2s.jpeg"></div><br>  Di antara fitur menarik dari Spring 5, pemrograman reaktif layak disebutkan secara khusus, implementasi yang dalam kerangka ini dijelaskan secara singkat oleh artikel yang diusulkan oleh Matt Raible.  Dalam buku tersebut, pola reaktif dibahas dalam bab 11. <br><br>  Matt ditulis bersama oleh Josh Long, penulis buku hebat lain tentang Java and Spring, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java in the Cloud,</a> " dirilis musim panas lalu. <br><a name="habracut"></a><br>  Pemrograman reaktif adalah cara Anda untuk membangun sistem yang tahan terhadap beban tinggi.  Memproses lalu lintas besar tidak lagi menjadi masalah, karena server non-pemblokiran dan proses klien tidak harus menunggu tanggapan.  Klien tidak dapat secara langsung mengamati bagaimana program berjalan di server dan menyinkronkannya.  Ketika API mengalami kesulitan untuk memproses permintaan, itu harus tetap memberikan tanggapan yang masuk akal.  Seharusnya tidak menolak dan membuang pesan dengan cara yang tidak terkontrol.  Itu harus menginformasikan komponen yang lebih tinggi bahwa ia bekerja di bawah beban sehingga mereka dapat membebaskan sebagian dari beban ini.  Teknik ini disebut backpressure, aspek penting dari pemrograman reaktif. <br><br>  Kami turut menulis artikel ini dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Josh Long</a> .  Josh adalah seorang juara Java, Spring Developer Advocate, dan umumnya seorang pria global yang bekerja di Pivotal.  Saya telah bekerja dengan Spring untuk waktu yang lama, tetapi Josh yang menunjukkan kepada saya Boot Musim Semi, pada konferensi Devoxx di Belgia.  Sejak itu, kami telah menjadi teman yang kuat, kami menyukai Java dan menulis aplikasi keren. <br><br>  <b>Pemrograman reaktif atau I / O, I / O, kami mulai bekerja ...</b> <br><br>  Pemrograman reaktif adalah pendekatan untuk membuat perangkat lunak yang secara aktif menggunakan I / O yang tidak sinkron.  Asynchronous I / O adalah ide kecil, penuh dengan perubahan besar dalam pemrograman.  Idenya sendiri sederhana: untuk memperbaiki situasi dengan alokasi sumber daya yang tidak efisien, membebaskan sumber daya yang akan menganggur tanpa campur tangan kita, menunggu penyelesaian I / O.  Input / output asinkron membalikkan pendekatan biasa untuk pemrosesan I / O: klien dibebaskan dan dapat melakukan tugas-tugas lain, menunggu pemberitahuan baru. <br><br>  Pertimbangkan apa yang umum antara input / output sinkron dan asinkron, dan apa perbedaan di antara keduanya. <br><br>  Kami akan menulis program sederhana yang membaca data dari sumber (khususnya, kita berbicara tentang tautan <code>java.io.File</code> ).  Mari kita mulai dengan implementasi yang menggunakan <code>java.io.InputStream</code> : <br><br>  <i>Contoh 1. Secara sinkron membaca data dari suatu file</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.io; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.extern.log4j.Log4j2; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.util.FileCopyUtils; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileInputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.function.Consumer; <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>4j2 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Synchronous</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Consumer&lt;BytesPayload&gt; consumer)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (FileInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file)) { <span class="hljs-comment"><span class="hljs-comment">//1 byte[] data = new byte[FileCopyUtils.BUFFER_SIZE]; int res; while ((res = in.read(data, 0, data.length)) != -1) { //2 consumer.accept(BytesPayload.from(data, res)); //3 } } } }</span></span></code> </pre> <br><ol><li>  Kami menyediakan file untuk dibaca dengan <code>java.io.File</code> biasa </li><li>  Tarik hasil dari sumber satu baris sekaligus ... </li><li>  Saya menulis kode ini untuk mengambil <code>Consumer&lt;BytesPayloadgt;</code>  dipanggil saat data baru tiba </li></ol><br>  Cukup sederhana, apa yang kamu katakan?  Jalankan kode ini dan Anda akan melihat di log output (di sebelah kiri setiap baris), menunjukkan bahwa semua tindakan terjadi dalam satu utas. <br>  Di sini kita mengekstrak byte dari data kita yang diambil dalam sumber (dalam hal ini, kita berbicara tentang subkelas <code>java.io.FileInputStream</code> diwarisi dari <code>java.io.InputStream</code> ).  Apa yang salah dengan contoh ini?  Dalam hal ini, kami menggunakan InputStream yang menunjuk ke data yang terletak di sistem file kami.  Jika file ada di sana dan hard drive berfungsi, maka kode ini akan berfungsi seperti yang diharapkan. <br><br>  Tapi, apa yang terjadi jika kita membaca data bukan dari <code>File</code> , tetapi dari soket jaringan, dan menggunakan implementasi <code>InputStream</code> ?  Tidak ada yang perlu dikhawatirkan!  Tentu saja, tidak akan ada yang perlu dikhawatirkan jika kecepatan jaringan sangat tinggi.  Dan jika saluran jaringan antara ini dan simpul lainnya tidak pernah gagal.  Jika kondisi ini terpenuhi, maka kodenya akan bekerja dengan sempurna. <br><br>  Tetapi apa yang terjadi jika jaringan melambat atau mundur?  Dalam hal ini, maksud saya bahwa kita akan meningkatkan periode sampai operasi <code>in.read(…)</code> .  Bahkan, dia mungkin tidak kembali sama sekali!  Ini adalah masalah jika kita mencoba melakukan hal lain dengan aliran dari mana kita membaca data.  Tentu saja, Anda selalu dapat membuat aliran lain dan membaca data melalui itu.  Ini dapat dilakukan hingga titik tertentu, tetapi, pada akhirnya, kita akan mencapai batas di mana hanya menambahkan utas untuk penskalaan lebih lanjut tidak akan lagi cukup.  Kami tidak akan memiliki persaingan sejati di luar jumlah core yang ada di mesin kami.  Jalan buntu!  Dalam hal ini, kita dapat meningkatkan pemrosesan input / output (membaca dimaksudkan di sini) hanya karena arus tambahan, tetapi di sini kita cepat atau lambat akan mencapai batas. <br><br>  Dalam contoh ini, karya utama adalah membaca - hampir tidak ada yang terjadi di bidang lain.  Kami bergantung pada I / O.  Pertimbangkan bagaimana solusi asinkron membantu kita mengatasi monopoli sebagian dari aliran kita. <br><br>  <i>Contoh 2. Membaca data dari file secara tidak sinkron</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.io; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.extern.log4j.Log4j2; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.util.FileCopyUtils; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.ByteBuffer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.channels.AsynchronousFileChannel; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.channels.CompletionHandler; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.Path; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.StandardOpenOption; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Collections; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.ExecutorService; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.Executors; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.function.Consumer; <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>4j2 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Asynchronous</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletionHandler</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByteBuffer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytesRead; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> position; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> AsynchronousFileChannel fileChannel; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Consumer&lt;BytesPayload&gt; consumer; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Consumer&lt;BytesPayload&gt; c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.consumer = c; Path path = file.toPath(); <span class="hljs-comment"><span class="hljs-comment">// 1 this.fileChannel = AsynchronousFileChannel.open(path, Collections.singleton(StandardOpenOption.READ), this.executorService); //2 ByteBuffer buffer = ByteBuffer.allocate(FileCopyUtils.BUFFER_SIZE); this.fileChannel.read(buffer, position, buffer, this); //3 while (this.bytesRead &gt; 0) { this.position = this.position + this.bytesRead; this.fileChannel.read(buffer, this.position, buffer, this); } } @Override public void completed(Integer result, ByteBuffer buffer) { //4 this.bytesRead = result; if (this.bytesRead &lt; 0) return; buffer.flip(); byte[] data = new byte[buffer.limit()]; buffer.get(data); //5 consumer.accept(BytesPayload.from(data, data.length)); buffer.clear(); this.position = this.position + this.bytesRead; this.fileChannel.read(buffer, this.position, buffer, this); } @Override public void failed(Throwable exc, ByteBuffer attachment) { log.error(exc); } }</span></span></code> </pre> <br><ol><li>  Kali ini kita mengadaptasi <code>java.io.File</code> , membuat <code>Java NIO java.nio.file.Path</code> darinya </li><li>  Saat membuat <code>Channel</code> , kami, khususnya, menentukan layanan <code>java.util.concurrent.ExecutorService</code> , yang akan digunakan untuk memanggil handler <code>CompletionHandler</code> ketika data yang diperlukan muncul </li><li>  Kami mulai membaca dengan mengirimkan tautan ke <code>CompletionHandler&lt;Integer, ByteBuffer&gt; (this)</code> </li><li>  Dalam panggilan balik, baca byte dari <code>ByteBuffer</code> ke dalam kapasitas <code>byte[]</code> </li><li>  Sama seperti pada contoh <code>Synchronous</code> , data <code>byte[]</code> diteruskan ke konsumen. </li></ol><br>  Kami akan segera melakukan reservasi: kode ini ternyata jauh lebih sulit!  Ada begitu banyak hal yang terjadi di sini sehingga kepala Anda langsung berputar, namun, izinkan saya tunjukkan ... kode ini membaca data dari <code>Java NIO Channel</code> , dan kemudian memproses data ini dalam utas terpisah yang bertanggung jawab untuk panggilan balik.  Dengan demikian, aliran di mana bacaan dimulai tidak dimonopoli.  Kami kembali hampir seketika setelah memanggil <code>.read(..)</code> , dan ketika, akhirnya, kami memiliki data yang kami miliki, panggilan balik dilakukan - sudah ada di utas lainnya.  Jika ada penundaan di antara panggilan ke <code>.read()</code> Anda dapat beralih ke masalah lain dengan mengeksekusinya di utas kami.  Durasi operasi baca asinkron, dari byte pertama hingga terakhir, paling tidak tidak lebih dari operasi baca sinkron.  Biasanya, operasi asinkron tidak konsisten lebih lama.  Namun, dengan kesulitan tambahan seperti itu, kita dapat lebih efektif menangani arus kita.  Lakukan lebih banyak pekerjaan, multiplex I / O di kolam dengan jumlah utas yang terbatas. <br><br>  Saya bekerja untuk perusahaan cloud computing.  Kami ingin Anda mendapatkan contoh aplikasi baru untuk menyelesaikan masalah dengan penskalaan horizontal!  Tentu saja, di sini saya sedikit tidak jujur.  Asynchronous I / O sedikit mempersulit hal, tapi saya harap contoh ini menggambarkan betapa kode reaktif sangat berguna: memungkinkan Anda untuk memproses lebih banyak permintaan dan melakukan lebih banyak pekerjaan pada perangkat keras yang ada jika kinerjanya sangat tergantung pada I / O.  Jika kinerjanya tergantung pada penggunaan prosesor (katakanlah, kita berbicara tentang operasi pada angka Fibonacci, penambangan bitcoin atau kriptografi), maka pemrograman reaktif tidak akan memberi kita apa pun. <br><br>  Saat ini, kebanyakan dari kita tidak menggunakan implementasi <code>Channel</code> atau <code>InputStream</code> dalam pekerjaan kita sehari-hari!  Kita harus memikirkan masalah pada level abstraksi level yang lebih tinggi.  Ini tentang hal-hal seperti array, atau lebih tepatnya, hirarki <code>java.util.Collection</code> .  Koleksi <code>java.util.Collection</code> ditampilkan dengan sangat baik pada InputStream: kedua entitas menganggap bahwa Anda dapat beroperasi pada semua data sekaligus, dan hampir secara instan.  Diharapkan bahwa Anda akan dapat selesai membaca dari sebagian besar <code>InputStreams</code> lebih awal, daripada nanti.  Jenis koleksi menjadi sedikit tidak nyaman ketika pindah ke jumlah data yang lebih besar.  Bagaimana jika Anda berurusan dengan sesuatu yang berpotensi tak terbatas (tak terbatas) - misalnya, soket web atau peristiwa server?  Apa yang harus dilakukan jika ada penundaan di antara rekaman? <br><br>  Kami membutuhkan cara yang lebih baik untuk menggambarkan data semacam ini.  Kita berbicara tentang peristiwa yang tidak sinkron, seperti yang akan terjadi pada akhirnya.  Tampaknya <code>Future&lt;T&gt;</code> atau <code>CompletableFuture&lt;T&gt;</code> sangat cocok untuk tujuan ini, tetapi mereka menggambarkan hanya satu hal yang terjadi pada akhirnya.  Bahkan, Java tidak menyediakan metafora yang cocok untuk menggambarkan data semacam ini.  Baik tipe <code>Iterator</code> dan <code>Stream</code> dari Java 8 mungkin tidak terkait, namun, keduanya berorientasi untuk menarik;  Anda sendiri yang meminta entri berikutnya, bukan tipe yang harus mengirim panggilan balik ke kode Anda.  Diasumsikan bahwa jika pemrosesan berbasis-push didukung dalam kasus ini, yang akan memungkinkan mencapai lebih banyak pada level thread, maka API juga akan menyediakan kontrol threading dan penjadwalan.  Implementasi <code>Iterator</code> tidak mengatakan apa pun tentang threading, dan semua thread Java 8 berbagi fork-join pool yang sama. <br><br>  Jika <code>Iterator</code> dan <code>Stream</code> benar-benar mendukung pemrosesan dorong, maka kita akan menghadapi masalah lain yang benar-benar meningkat secara tepat dalam konteks I / O: kita akan memerlukan semacam mekanisme penetrasi belakang!  Karena konsumen data diproses secara tidak sinkron, kami tidak tahu kapan data akan berada dalam pipa dan dalam jumlah berapa.  Kami tidak tahu berapa banyak data yang perlu diproses dalam panggilan balik berikutnya: satu byte atau satu terabyte! <br><br>  Menarik data dari <code>InputStream</code> , Anda membaca informasi sebanyak yang siap Anda proses, dan tidak lebih.  Pada contoh sebelumnya, kita membaca data ke buffer <code>byte[]</code> dengan panjang tetap dan dikenal.  Dalam konteks asinkron, kita perlu beberapa cara untuk memberi tahu penyedia data berapa banyak data yang ingin kita proses. <br>  Ya, tuan.  Pasti ada sesuatu yang hilang di sini. <br><br>  <b>Cari metafora yang hilang</b> <br><br>  Dalam hal ini, kami mencari metafora yang dengan indah mencerminkan esensi I / O asinkron, mendukung mekanisme untuk transfer data terbalik dan memungkinkan kami untuk mengontrol aliran eksekusi dalam sistem terdistribusi.  Dalam pemrograman reaktif, kemampuan klien untuk memberi sinyal muatan apa yang dapat ditangani disebut "aliran balik." <br><br>  Sekarang ada sejumlah proyek bagus - Vert.x, Akka Streams dan RxJava - mendukung pemrograman reaktif.  Tim Spring juga menjalankan proyek yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Reactor</a> .  Di antara berbagai standar ini terdapat bidang umum yang cukup luas, secara de facto dialokasikan untuk standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inisiatif Reactive Streams</a> .  Inisiatif Aliran Reaktif mendefinisikan empat jenis: <br><br>  Antarmuka <code>Publisher&lt;T&amp;gt</code> ;  menghasilkan nilai-nilai yang pada akhirnya mungkin tiba.  Antarmuka <code>Publisher&lt;T&amp;gt</code> ;  menghasilkan nilai tipe <code>T</code> untuk <code>Subscriber&lt;T&gt;</code> . <br><br>  <i>Contoh 3. Aliran reaktif: Antarmuka <code>Publisher&lt;T&gt;</code></i> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Tgt; s)</span></span></span></span>; }</code> </pre> <br>  Tipe Pelanggan berlangganan <code>Publisher&lt;T&gt;</code> , menerima pemberitahuan nilai baru tipe <code>T</code> melalui <code>onNext(T)</code> .  Jika ada kesalahan, <code>onError(Throwable)</code> .  Ketika pemrosesan selesai secara normal, metode <code>onComplete</code> dari pelanggan dipanggil. <br><br>  <i>Contoh 4. Jet stream: Antarmuka <code>Subscriber&lt;T&gt;</code> .</i> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Saat <code>Subscriber</code> pertama kali terhubung ke <code>Publisher</code> , ia akan <code>Subscription</code> dalam metode <code>Subscriber#onSubscribe</code> .  Berlangganan <code>Subscription</code> mungkin merupakan bagian terpenting dari keseluruhan spesifikasi;  dialah yang menyediakan aliran balik.  Pelanggan Pelanggan menggunakan metode <code>Subscription#request</code> untuk meminta data tambahan atau metode <code>Subscription#cancel</code> untuk menghentikan pemrosesan. <br><br>  <i>Contoh 5. Streaming reaktif: <code>Subscription&lt;T&gt;</code> antarmuka <code>Subscription&lt;T&gt;</code></i> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br>  Spesifikasi aliran reaktif menyediakan jenis lain yang bermanfaat, meskipun jelas <code>Processor&lt;A,B&gt;</code> hanyalah sebuah antarmuka yang mewarisi <code>Subscriber&lt;A&gt;</code> dan <code>Publisher&lt;B&gt;</code> . <br><br>  <i>Contoh 6. Jet stream: Antarmuka <code>Processor&lt;T&gt;</code></i> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.reactivestreams; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ltT</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  Spesifikasi tidak diposisikan sebagai resep untuk implementasi, pada kenyataannya, tujuannya adalah untuk menentukan jenis untuk mendukung interoperabilitas.  Manfaat yang jelas dari tipe yang terkait dengan aliran reaktif adalah bahwa mereka tetap menemukan tempat di rilis Java 9, lebih dari itu, secara semantik mereka adalah “satu ke satu” sesuai dengan antarmuka dari kelas <code>java.util.concurrent.Flow</code> , misalnya: <code>java.util.concurrent.Flow.Publisher</code> . <br><br>  <b>Temui Reactor</b> <br><br>  Jenis aliran reaktif saja tidak cukup;  implementasi tingkat tinggi diperlukan untuk mendukung operasi seperti penyaringan dan transformasi.  Dengan demikian, proyek Reactor nyaman;  itu dibangun di atas spesifikasi Streaming Reaktif dan menyediakan dua spesialisasi <code>Publisher&lt;T&gt;</code> . <br><br>  Pertama, <code>Flux&lt;T&gt;</code> adalah <code>Publisher</code> yang menghasilkan nilai nol atau lebih.  Yang kedua, <code>Mono&lt;T&gt;</code> , adalah <code>Publisher&lt;T&gt;</code> , menghasilkan nol atau satu nilai.  Keduanya mempublikasikan nilai dan dapat menanganinya, namun, kemampuan mereka jauh lebih luas daripada spesifikasi Reactive Streams.  Keduanya menyediakan operator yang memungkinkan Anda memproses aliran nilai.  Jenis reaktor menyusun dengan baik - output dari salah satu dari mereka dapat berfungsi sebagai input untuk yang lain, dan jika suatu jenis perlu bekerja dengan aliran data lain, mereka bergantung pada instance <code>Publisher&lt;T&gt;</code> . <br><br>  Baik <code>Mono&lt;T&gt;</code> dan <code>Flux&lt;T&gt;</code> menerapkan <code>Publisher&lt;T&gt;</code> ;  kami menyarankan agar metode Anda menerima instance <code>Publisher&lt;T&gt;</code> tetapi mengembalikan <code>Flux&lt;T&gt;</code> atau <code>Mono&lt;T&gt;</code> ;  ini akan membantu klien membedakan jenis data apa yang ia terima. <br><br>  Misalkan Anda diberi <code>Publisher&lt;T&gt;</code> dan diminta untuk menampilkan antarmuka pengguna untuk <code>Publisher&lt;T&gt;</code> ini <code>Publisher&lt;T&gt;</code> .  Haruskah saya menampilkan halaman dengan detail untuk satu catatan, karena Anda bisa mendapatkan <code>CompletableFuture&lt;T&gt;</code> ?  Atau tampilkan halaman ikhtisar dengan daftar atau kisi di mana semua entri ditampilkan halaman demi halaman?  Sulit dikatakan. <br><br>  Pada gilirannya, <code>Flux&lt;T&gt;</code> dan <code>Mono&lt;T&gt;</code> sangat spesifik.  Anda tahu bahwa Anda perlu menampilkan halaman ulasan jika <code>Flux&lt;T&gt;</code> diterima, dan halaman dengan detail untuk satu (atau bukan satu) catatan ketika Anda menerima <code>Mono&lt;T&gt;</code> . <br><br>  Reactor adalah proyek sumber terbuka yang diluncurkan oleh Pivotal;  Sekarang dia menjadi sangat populer.  Facebook menggunakannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin</a> jetnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk memanggil prosedur jarak jauh</a> , dan juga menggunakannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rsocket</a> , dipimpin oleh pencipta RxJava Ben Christensen.  Salesforce menggunakannya dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi gRPC reaktifnya</a> .  Reactor mengimplementasikan tipe Reactive Streams, sehingga dapat berinteraksi dengan teknologi lain yang mendukung tipe ini, misalnya, dengan <a href="">RxJava 2</a> dari Netflix, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Akka Streams</a> dari Lightbend dan dengan proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vert.x</a> dari Eclipse Foundation.  David Cairnock, direktur RxJava 2, juga secara aktif berkolaborasi dengan Pivotal untuk mengembangkan Reactor, membuat proyek ini menjadi lebih baik.  Plus, tentu saja, hadir dalam satu atau lain bentuk dalam Kerangka Kerja Musim Semi, dimulai dengan Kerangka Kerja 4.0. <br><br>  <b>Pemrograman reaktif dengan Spring WebFlux</b> <br><br>  Untuk semua manfaatnya, Reactor hanyalah dasar.  Aplikasi kita harus berkomunikasi dengan sumber data.  Harus mendukung otentikasi dan otorisasi.  Spring menyediakan semua ini.  Jika Reactor memberi kita metafora yang hilang, maka Spring membantu kita semua berbicara dengan bahasa yang sama. <br><br>  Spring Framework 5.0 dirilis pada September 2017. Ini didasarkan pada spesifikasi Reactor dan Reactive Streams.  Ini memiliki runtime reaktif baru dan model komponen yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spring WebFlux</a> . <br><br>  Spring WebFlux independen dari Servlet API dan tidak mengharuskan mereka untuk bekerja.  Muncul dengan adaptor yang memungkinkan Anda menggunakannya di atas mesin Servlet jika perlu, tetapi ini tidak perlu.  Ini juga menyediakan runtime berbasis Netty yang sama sekali baru yang disebut Spring WebFlux.  Spring Framework 5, bekerja dengan Java 8 dan Java EE 7 dan yang lebih baru, sekarang berfungsi sebagai fondasi bagi sebagian besar ekosistem Spring, termasuk Spring Data Kay, Spring Security 5, Spring Boot 2, dan Spring Cloud Finchley. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435972/">https://habr.com/ru/post/id435972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435960/index.html">Eksperimen Pikiran: Berkibar saat Pergi</a></li>
<li><a href="../id435962/index.html">Peringatan 25 tahun Aeron: sensasi dan kesan versi Aeron Remastered yang diperbarui</a></li>
<li><a href="../id435964/index.html">Ethereum berencana menjadi 99% lebih ekonomis</a></li>
<li><a href="../id435968/index.html">Tinjauan Algoritma Pembelajaran Mesin Mendalam untuk Robot</a></li>
<li><a href="../id435970/index.html">Panduan Pemula untuk Pengembangan Server Web dengan Node.js</a></li>
<li><a href="../id435974/index.html">Three.js - lakukan kontrol untuk ruang atau planetarium</a></li>
<li><a href="../id435976/index.html">WebMerupakan produksi dan "ladang ranjau" Smart TV: wawancara dengan Andrei Nagih</a></li>
<li><a href="../id435978/index.html">Solusi Perlindungan Biometrik</a></li>
<li><a href="../id435984/index.html">Jaringan saraf dan filosofi bahasa</a></li>
<li><a href="../id435986/index.html">Windows akan memesan 7 GB untuk pembaruan sistem untuk menghindari kehabisan ruang hard disk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>