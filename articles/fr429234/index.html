<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏽 👩‍👧 🍅 Création du jeu "Like coins" sur Godot Engine. Partie 1 💵 🏉 😍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Godot Engine se développe très rapidement et gagne le cœur des développeurs de jeux du monde entier. C'est peut-être l'outil le plus convivial et le p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Création du jeu "Like coins" sur Godot Engine. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429234/"><p>  Godot Engine se développe très rapidement et gagne le cœur des développeurs de jeux du monde entier.  C'est peut-être l'outil le plus convivial et le plus facile à apprendre pour créer des jeux, et pour vous en assurer, essayez de faire un petit jeu 2D.  Pour une bonne compréhension du processus de développement de jeux, vous devriez commencer par les jeux 2D - cela abaissera le seuil d'entrée dans un système de jeu plus sérieux.  Bien que la transition vers la 3D en elle-même ne soit pas aussi difficile qu'il y paraît, après tout, la plupart des fonctions du moteur Godot peuvent être utilisées avec succès en 2D et en 3D. </p><a name="habracut"></a><br><h3 id="vvedenie">  Présentation </h3><br><p> La chose la plus simple à laquelle vous pouvez penser est un jeu dans lequel notre personnage principal collectera des pièces.  Pour compliquer un peu, ajoutez un obstacle et du temps, comme facteur limitant.  Le jeu aura 3 scènes: <code>Player</code> , <code>Coin</code> et <code>HUD</code> (cet article n'est pas considéré), qui seront combinées en une seule scène <code>Main</code> . </p><br><p><img src="https://habrastorage.org/webt/vu/vv/ct/vuvvctv4zp9csexcarj4_zitxje.png"></p><br><h3 id="nastroyki-proekta">  Paramètres du projet </h3><br><p>  Avant de vous lancer dans l'écriture de scripts (scripts), ce qui représente environ 80 à 90% du temps total consacré à la création du jeu, la première chose à faire est de configurer notre futur projet.  Dans les grands projets, il est utile de créer des dossiers séparés pour stocker des scripts, des scènes, des images et des sons, et nous devons certainement en tenir compte, car qui sait quel sera le résultat final. </p><br><blockquote>  Je veux tout de suite faire une réserve que cet article suppose que vous êtes un peu familier avec le moteur Godot et que vous avez des connaissances et des compétences pour utiliser cet outil, bien que je me concentre sur le fait que vous rencontrez le moteur Godot pour la première fois, je suis toujours Je vous conseille d'abord de vous familiariser avec le composant de base du moteur, d'étudier la syntaxe de GDScript et de comprendre la terminologie utilisée (nœuds, scènes, signaux, etc.), puis de revenir ici et de continuer votre connaissance. </blockquote><p>  Dans le menu du programme, accédez à <code>Project -&gt; Project Settings</code> . </p><br><blockquote>  Encore une petite digression.  Je donnerai toujours des exemples basés sur le fait que l'utilisateur final utilise l'interface en langue anglaise du moteur, malgré le fait que le "moteur Godot" prend en charge la langue russe.  Ceci est fait afin de se débarrasser des éventuels malentendus ou embarras associés à une traduction incorrecte / inexacte de certains éléments de l'interface du programme. </blockquote><p>  Recherchez la section <code>Display/Window</code> et définissez la largeur sur <code>800</code> et la hauteur sur <code>600</code> .  Toujours dans cette section, définissez <code>Stretch/Mode</code> sur <code>2D</code> et <code>Aspect</code> à <code>Keep</code> .  Cela empêchera l'étirement et la déformation du contenu de la fenêtre lors du changement de sa taille, mais pour empêcher la fenêtre d'être redimensionnée, décochez simplement la case <code>Resizable</code> .  Je vous conseille de jouer avec ces options. </p><br><p>  Accédez maintenant à la section <code>Rendering/Quality</code> et activez l' <code>Use Pixel Snap</code> dans le volet droit.  À quoi ça sert?  Les coordonnées des vecteurs dans le moteur Godot sont des nombres à virgule flottante.  Étant donné que les objets ne peuvent être dessinés que d'un demi-pixel, cette différence peut entraîner des défauts visuels pour les jeux qui utilisent <code>pixelart</code> .  Et il convient de noter qu'en 3D, cette option est inutile.  Gardez cela à l'esprit. </p><br><h3 id="scena-igrok">  Scène de joueur </h3><br><p>  Commençons par créer la première scène - <code>Player</code> . </p><br><blockquote>  L'avantage de n'importe quelle scène est qu'initialement, elles sont indépendantes des autres parties du jeu, ce qui permet de les tester librement et d'obtenir le résultat qui y était initialement prévu.  En général, la division d'objets de jeu en scènes est un outil utile pour créer des jeux complexes - il est plus facile de détecter les erreurs, d'apporter des modifications à la scène elle-même, tandis que d'autres parties du jeu ne seront pas affectées, elles peuvent également servir de modèles pour d'autres jeux et elles fonctionneront certainement aussi bien. comme ils travaillaient avant le transfert. </blockquote><p>  La création d'une scène est une action trivialement simple - sur l'onglet <code>Scene</code> , cliquez sur <code>+</code> (Ajouter / Créer) et sélectionnez le nœud <code>Area2D</code> et changez immédiatement son nom afin de ne pas vous tromper.  Il s'agit de notre nœud parent et pour étendre les fonctionnalités dont vous avez besoin pour ajouter des nœuds enfants.  Dans notre cas, ce sont <code>AnimatedSprite</code> et <code>CollisionShape2D</code> , mais ne nous précipitons pas, mais commençons dans l'ordre.  Ensuite, «verrouillez» immédiatement le nœud racine: </p><br><p><img src="https://habrastorage.org/webt/5m/wf/ac/5mwfacrfvyjm6wtkmkqlgd_pasu.png"></p><br><p>  Si la forme de collision corporelle (CollisionShape2D) ou l'image-objet (AnimatedSprite) sont décalées, étirées par rapport au nœud parent, cela entraînera certainement des erreurs imprévues et plus tard il sera difficile de les corriger.  Lorsque cette option est activée, le «parent» et tous ses «enfants» se déplaceront toujours ensemble.  Cela semble drôle, mais l'utilisation de cette fonctionnalité est extrêmement utile. </p><br><h4 id="animatedsprite">  AnimatedSprite </h4><br><p>  <code>Area2D</code> nœud très utile si vous avez besoin de connaître un événement de chevauchement avec d'autres objets ou de leur collision, mais en soi, il est invisible à l'œil nu et pour rendre visible l'objet <code>Player</code> ajoutez <code>AnimatedSprite</code> .  Le nom du nœud nous dit que nous allons traiter des animations et des sprites.  Dans la fenêtre <code>Inspector</code> , accédez au paramètre <code>Frames</code> et créez un nouveau <code>SpriteFrames</code> .  Travailler avec le panneau <code>SpriteFrames</code> consiste à créer les animations nécessaires et à leur charger les sprites correspondants.  Nous n'analyserons pas en détail toutes les étapes de la création d'animations, laissant cela pour une étude indépendante, je dirai seulement que nous devrions avoir trois animations: <code>walk</code> (animation de marche), <code>idle</code> (état de repos) et <code>die</code> (animation de mort ou d'échec).  N'oubliez pas que la valeur de <code>SPEED (FPS)</code> doit être <code>8</code> (bien que vous puissiez choisir une valeur différente - appropriée). </p><br><p><img src="https://habrastorage.org/webt/0u/9w/tr/0u9wtrugdci7wueb5tihyoza2hq.png"></p><br><h4 id="collisionshape2d">  Collisionshape2d </h4><br><p>  Pour que <code>Area2D</code> détecte les collisions, vous devez lui fournir la forme d'un objet.  Les formes sont déterminées par le paramètre <code>Shape2D</code> et incluent des rectangles, des cercles, des polygones et d'autres types de formes plus complexes, et les tailles sont déjà modifiées dans l'éditeur lui-même, mais vous pouvez toujours utiliser l' <code>Inspector</code> pour un réglage plus précis. </p><br><h4 id="scenarii">  Scénarios </h4><br><p>  Maintenant, afin de «faire revivre» notre objet de jeu, vous devez définir un script pour celui-ci, selon lequel les actions définies par nous, qui sont prescrites dans ce scénario, seront exécutées.  Dans l'onglet <code>Scene</code> , créez un script, laissez les paramètres par défaut, supprimez tous les commentaires (lignes commençant par le signe «#») et procédez à la déclaration des variables: </p><br><pre> <code class="python hljs">export (int) var speed var velocity = Vector2() var window_size = Vector2(<span class="hljs-number"><span class="hljs-number">800</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>)</code> </pre> <br><p>  L'utilisation du mot-clé d' <code>export</code> vous permet de définir la valeur de la variable de <code>speed</code> dans la fenêtre du panneau <code>Inspector</code> .  Il s'agit d'une méthode très utile si nous voulons obtenir des valeurs personnalisées qui sont faciles à modifier dans la fenêtre <code>Inspector</code> .  Réglez la <code>Speed</code> sur <code>350</code> .  La valeur de <code>velocity</code> déterminera la direction du mouvement, et <code>window_size</code> est la zone limitant le mouvement du joueur. </p><br><p>  L'ordre supplémentaire de nos actions est le suivant: nous utilisons la fonction <code>get_input()</code> pour vérifier si la saisie au clavier est en cours.  Ensuite, nous déplacerons l'objet, en fonction des touches enfoncées, puis jouerons l'animation.  Le joueur se déplacera dans quatre directions.  Par défaut, le moteur Godot a des événements attribués aux touches fléchées ( <code>Project -&gt; Project Settings -&gt; Input Map</code> ), nous pouvons donc les appliquer à notre projet.  Pour savoir si une touche particulière est enfoncée, vous devez utiliser <code>Input.is_action_pressed()</code> en lui glissant le nom de l'événement que vous souhaitez suivre. </p><br><pre> <code class="python hljs">func get_input(): velocity = Vector2() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Input.is_action_pressed(<span class="hljs-string"><span class="hljs-string">"ui_left"</span></span>): velocity.x -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Input.is_action_pressed(<span class="hljs-string"><span class="hljs-string">"ui_right"</span></span>): velocity.x += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Input.is_action_pressed(<span class="hljs-string"><span class="hljs-string">"ui_up"</span></span>): velocity.y -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Input.is_action_pressed(<span class="hljs-string"><span class="hljs-string">"ui_down"</span></span>): velocity.y += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> velocity.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: velocity = velocity.normalized() * speed</code> </pre> <br><p>  À première vue, tout semble bien, mais il y a une petite nuance.  La combinaison de plusieurs touches enfoncées (par exemple, vers le bas et vers la gauche) provoquera l'ajout de vecteurs et dans ce cas, le joueur se déplacera plus rapidement que s'il se déplaçait simplement vers le bas.  Pour éviter cela, nous utiliserons la méthode <code>normalized()</code> - elle retournera la longueur du vecteur à <code>1</code> . </p><br><p>  Ainsi, les événements de frappe ont été suivis, vous devez maintenant déplacer l'objet <code>Player</code> .  La fonction <code>_process()</code> nous aidera à cela, qui est appelée chaque fois qu'un changement de trame se produit, il est donc conseillé de l'utiliser pour les objets qui changent souvent. </p><br><pre> <code class="python hljs">func _process(delta): get_input() position += velocity * delta position.x = clamp(position.x, <span class="hljs-number"><span class="hljs-number">0</span></span>, window_size.x) position.y = clamp(position.y, <span class="hljs-number"><span class="hljs-number">0</span></span>, window_size.y)</code> </pre> <br><p>  J'espère que vous remarquerez le paramètre <code>delta</code> , qui à son tour est multiplié par la vitesse.  Il faut expliquer ce que c'est.  Le moteur de jeu est initialement configuré pour fonctionner à une vitesse de 60 images par seconde.  Néanmoins, il peut y avoir des situations où l'ordinateur ou le moteur Godot lui-même ralentit.  Si la fréquence d'images n'est pas cohérente (le temps nécessaire pour que les images changent), cela affectera la "fluidité" du mouvement des objets du jeu (par conséquent, le mouvement est "saccadé").  "Godot Engine" résout ce problème (comme la plupart des moteurs similaires) en introduisant la variable <code>delta</code> - elle donne la valeur pour laquelle les images ont été modifiées.  Grâce à ces valeurs, vous pouvez "aligner" le mouvement.  Faites attention à une autre fonction remarquable - <code>clamp</code> (renvoie la valeur dans les deux paramètres spécifiés), grâce à elle, nous sommes en mesure de limiter la zone que le <code>Player</code> peut déplacer en définissant simplement la valeur minimale et maximale de la zone. </p><br><p>  N'oubliez pas d'animer notre objet.  Veuillez noter que lorsque l'objet se déplace vers la droite, vous devez retourner <code>AnimatedSprite</code> (en utilisant <code>flip_h</code> ) et notre héros regardera dans la direction où il se déplace directement lors du déplacement.  Assurez-vous que dans <code>AnimatedSprite</code> le paramètre <code>Playing</code> est activé afin que l'animation commence à jouer. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> velocity.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: $AnimatedSprite.animation = <span class="hljs-string"><span class="hljs-string">"walk"</span></span> $AnimatedSprite.flip_h = velocity.x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: $AnimatedSprite.animation = <span class="hljs-string"><span class="hljs-string">"idle"</span></span></code> </pre> <br><h4 id="rozhdenie-i-smert">  Naissance et décès </h4><br><p>  Lors du lancement du jeu, la scène principale doit être informée des scènes clés sur son état de préparation pour démarrer un nouveau jeu, dans notre cas, nous devons informer l'objet <code>Player</code> du début du jeu et définir les paramètres initiaux pour celui-ci: position d'apparence, animation par défaut, exécuter <code>set_process</code> . </p><br><pre> <code class="python hljs">func start(pos): set_process(true) <span class="hljs-comment"><span class="hljs-comment">#     Vector2(x, y) position = pos $AnimatedSprite.animation = "idle"</span></span></code> </pre> <br><p>  Nous fournissons également un événement de mort d'un joueur lorsque le temps est écoulé ou que le joueur rencontre un obstacle, et la définition de <code>set_process (false)</code> empêchera la fonction <code>_process ()</code> d'être exécutée pour cette scène. </p><br><pre> <code class="python hljs">func die(): $AnimatedSprite.animation = <span class="hljs-string"><span class="hljs-string">"die"</span></span> set_process(false)</code> </pre> <br><h4 id="dobavlenie-kolliziy">  Ajout de collisions </h4><br><p>  C'était au tour de faire détecter au joueur des collisions avec des pièces et des obstacles.  Ceci est plus facilement mis en œuvre en utilisant des signaux.  Les signaux sont un excellent moyen d'envoyer un message afin que d'autres nœuds puissent les détecter et répondre.  La plupart des nœuds ont déjà des signaux intégrés, mais il est possible de définir des signaux "utilisateur" à leurs propres fins.  Des signaux sont ajoutés si vous les déclarez au début du script: </p><br><pre> <code class="python hljs">signal pickup signal die</code> </pre> <br><p>  Parcourez la liste des signaux dans la fenêtre <code>Inspector</code> (onglet <code>Node</code> ) et faites attention à nos signaux et aux signaux qui existent déjà.  Maintenant, nous sommes intéressés par <code>area_entered ()</code> , il suppose que les objets avec lesquels la collision se produira sont également de type <code>Area2D</code> .  Nous connectons le signal <code>area_entered ()</code> à l'aide du bouton <code>Connect</code> , et dans la fenêtre <code>Connect Signal</code> sélectionnez le nœud en surbrillance (Player), laissez le reste par défaut. </p><br><pre> <code class="python hljs">func _on_Player_area_entered( area ): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> area.is_in_group(<span class="hljs-string"><span class="hljs-string">"coins"</span></span>): <span class="hljs-comment"><span class="hljs-comment">#  emit_signal("pickup") area.pickup()</span></span></code> </pre> <br><p>  Pour que les objets puissent être facilement détectés et interagis avec eux, ils doivent être identifiés dans les groupes appropriés.  La création des groupes eux-mêmes est désormais omise, mais nous y reviendrons certainement plus tard.  La fonction <code>pickup()</code> détermine le comportement de la pièce (par exemple, elle peut jouer une animation ou un son, supprimer un objet, etc.). </p><br><h4 id="scena-monetka">  Scène de pièces </h4><br><p>  Lors de la création d'une scène avec une pièce, vous devez faire tout ce que nous avons fait avec la scène "Player", sauf qu'il n'y aura qu'une seule animation (surbrillance) dans <code>AnimatedSprite</code> .  <code>Speed (FPS)</code> peut être augmentée à <code>14</code> .  Nous allons également modifier l'échelle de <code>AnimatedSprite</code> - <code>0,5, 0,5</code> .  Et les dimensions de <code>CollisionShape2D</code> devraient correspondre à l'image de la pièce, l'essentiel n'est pas de la mettre à l'échelle, à savoir changer la taille en utilisant les marqueurs appropriés sur le formulaire dans l'éditeur 2D, qui <br>  ajuste le rayon du cercle. </p><br><p><img src="https://habrastorage.org/webt/63/uc/jq/63ucjq07ny8i7pjjyakue47ojdg.png"></p><br><p>  Les groupes sont une sorte d'étiquetage des nœuds qui vous permet d'identifier des nœuds similaires.  Pour que l'objet <code>Player</code> réagisse au toucher avec des pièces, les pièces doivent appartenir au groupe, appelons-les <code>coins</code> .  Sélectionnez le nœud <code>Area2D</code> (avec le nom "Coin") et affectez-lui une balise dans l'onglet <code>Node -&gt; Groups</code> , créant le groupe correspondant. </p><br><p><img src="https://habrastorage.org/webt/a5/3q/sk/a53qskzr8be5yfagoubkbe2vbrs.png"></p><br><p>  Pour le nœud <code>Coin</code> , créez un script.  La fonction <code>pickup()</code> sera appelée par le script de l'objet <code>Player</code> et indiquera à la pièce quoi faire lorsqu'elle fonctionne.  La méthode <code>queue_free()</code> supprimera en toute sécurité un nœud de l'arborescence avec tous ses nœuds enfants et effacera la mémoire, mais la suppression ne fonctionnera pas immédiatement, elle sera d'abord déplacée vers la file d'attente à supprimer à la fin de la trame actuelle.  C'est beaucoup plus sûr que de supprimer un nœud immédiatement, car d'autres "participants" (nœuds ou scènes) du jeu peuvent encore avoir besoin de ce nœud pour exister. </p><br><pre> <code class="python hljs">func pickup (): queue_free ()</code> </pre> <br><h4 id="zaklyuchenie">  Conclusion </h4><br><p>  Maintenant, nous pouvons créer la scène <code>Main</code> , faites glisser les deux scènes: <code>Player</code> et <code>Coin</code> souris dans l'éditeur 2D, et vérifiez comment le mouvement du joueur et son contact avec la pièce fonctionnent en démarrant la scène (F5).  Eh bien, je suis pressé de dire que la première partie de la création du jeu "Like Coins" est terminée, laissez-moi prendre un congé et remercier tout le monde pour leur attention.  Si vous avez quelque chose à dire, complétez le matériel ou si vous avez vu des erreurs dans l'article, assurez-vous de le signaler en écrivant un commentaire ci-dessous.  N'ayez pas peur d'être dur et critique.  Vos «commentaires» vous diront si je vais dans la bonne direction et ce qui peut être corrigé pour rendre le matériel encore plus intéressant et utile. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429234/">https://habr.com/ru/post/fr429234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr429224/index.html">Modèles de formulaire Web sombre ou quel serait le formulaire de conversion le plus</a></li>
<li><a href="../fr429226/index.html">Tarification dynamique ou comment Yandex.Taxi prédit une forte demande</a></li>
<li><a href="../fr429228/index.html">PMP Réussir l'examen. Ce qu'il faut considérer et pourquoi vous en avez besoin</a></li>
<li><a href="../fr429230/index.html">Rapport: des projecteurs Epson à Integrated Systems Russia 2018</a></li>
<li><a href="../fr429232/index.html">Stéroïdes de carrière. Les chiens</a></li>
<li><a href="../fr429236/index.html">De combien de Data Scientists avez-vous besoin pour allumer une ampoule (ou quelle équipe fera fonctionner les données pour l'entreprise)</a></li>
<li><a href="../fr429238/index.html">Encore une fois sur les niveaux</a></li>
<li><a href="../fr429240/index.html">Comment j'ai essayé de corriger une recherche de carte pour les pilotes</a></li>
<li><a href="../fr429242/index.html">«Ne soyez pas timide. Essayez-le! " Interviews sur la vie, les compilateurs et la vie dans les compilateurs avec Unity Alexandre Mutel</a></li>
<li><a href="../fr429244/index.html">Greedy Gnome: alors que j'écrivais des analyses de marché dans Lineage 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>