<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏽 🦋 👩🏼‍🌾 Asterisk dialplan extension generador de máscara 🎰 👨🏻‍🏭 🚩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El administrador del sistema Asterisk a menudo necesita crear máscaras de extensión para el plan de marcado basado en intervalos de código DEF. Hacer ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asterisk dialplan extension generador de máscara</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430934/">  El administrador del sistema Asterisk a menudo necesita crear máscaras de extensión para el plan de marcado basado en intervalos de código DEF.  Hacer esto manualmente lleva mucho tiempo, y casi el único <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">script de</a> trabajo que se puede encontrar en Internet en realidad no funciona tan bien. <br><br>  Espero que alguien tenga a mano un pequeño generador de cli en marcha, que tuve que escribir recientemente para actualizar un plan de marcado existente. <br><a name="habracut"></a><br>  Capacidades: <br><br><ul><li>  filtrar por región </li><li>  filtro de operador </li><li>  formato de salida simple </li><li>  comentarios de estilo asterisco con información de intervalo </li><li>  agrupación de transportistas </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuentes y binarios para Mac OS y Linux en GitHub</a> <br><br><div class="spoiler">  <b class="spoiler_title">Código</b> <div class="spoiler_text"><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/csv"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"sort"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> <span class="hljs-string"><span class="hljs-string">"strings"</span></span> <span class="hljs-string"><span class="hljs-string">"golang.org/x/text/encoding/charmap"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> params <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { URL <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Region <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Operator <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Comment <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Prefix <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Suffix <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Group <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { p := readArgs() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> values [][]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p.Region != <span class="hljs-string"><span class="hljs-string">""</span></span> { values = filterRegion(parse(getCodes(p.URL)), p.Region) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { values = parse(getCodes(p.URL)) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p.Operator != <span class="hljs-string"><span class="hljs-string">""</span></span> { values = filterOperator(values, p.Operator) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p.Group { sort.Slice(values, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values[i][<span class="hljs-number"><span class="hljs-number">4</span></span>] &lt; values[j][<span class="hljs-number"><span class="hljs-number">4</span></span>] }) } op := <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> values { _, min, max, dif := convert(v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !validate(min, max, dif) { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"wrong interval: from %d to %d != %d\n"</span></span>, min, max, dif) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p.Comment { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"; %v, %v, %v, %v, %v, %v\n"</span></span>, v[<span class="hljs-number"><span class="hljs-number">0</span></span>], v[<span class="hljs-number"><span class="hljs-number">1</span></span>], v[<span class="hljs-number"><span class="hljs-number">2</span></span>], v[<span class="hljs-number"><span class="hljs-number">3</span></span>], v[<span class="hljs-number"><span class="hljs-number">4</span></span>], v[<span class="hljs-number"><span class="hljs-number">5</span></span>]) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p.Group { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v[<span class="hljs-number"><span class="hljs-number">4</span></span>] != op { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"; %s\n"</span></span>, v[<span class="hljs-number"><span class="hljs-number">4</span></span>]) op = v[<span class="hljs-number"><span class="hljs-number">4</span></span>] } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">rune</span></span>(v[<span class="hljs-number"><span class="hljs-number">0</span></span>])) != <span class="hljs-number"><span class="hljs-number">3</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">rune</span></span>(v[<span class="hljs-number"><span class="hljs-number">1</span></span>])) != <span class="hljs-number"><span class="hljs-number">7</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">rune</span></span>(v[<span class="hljs-number"><span class="hljs-number">2</span></span>])) != <span class="hljs-number"><span class="hljs-number">7</span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"wrong interval: from %d to %d != %d\n"</span></span>, min, max, dif) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } compute(p.Prefix+v[<span class="hljs-number"><span class="hljs-number">0</span></span>], v[<span class="hljs-number"><span class="hljs-number">1</span></span>], v[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-string"><span class="hljs-string">""</span></span>+p.Suffix) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client http.Client res, err := client.Get(url) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Panic(err) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> res.Body.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> res.StatusCode == http.StatusOK { b, err := ioutil.ReadAll(res.Body) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Panic(err) } dec := charmap.Windows1251.NewDecoder() body := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b)*<span class="hljs-number"><span class="hljs-number">2</span></span>) n, _, err := dec.Transform(body, []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(b), <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(body[:n]) } log.Panic(<span class="hljs-string"><span class="hljs-string">"bad response"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-comment"><span class="hljs-comment">// returns slice without row names // element 0: code // 1: min value of interval // 2: max value of interval // 3: interval length // 4: cellular operator // 5: region func parse(data string) [][]string { codes := csv.NewReader(strings.NewReader(fixCodes(data, 6))) codes.LazyQuotes = true codes.Comma = ';' ext, err := codes.ReadAll() if err != nil { log.Println(err) } return ext[1:] } // I found three records with excess separators // in https://rossvyaz.gov.ru/docs/articles/DEF-9x.csv // (start at 955;5550000;5559999;10000 ...) func fixCodes(data string, f int) string { c := 0 var x []rune for _, v := range []rune(data) { if v == '\n' { c = 0 } // replace excess separators with spaces if v == ';' { c++ if c &gt; f-1 { v = ' ' } } x = append(x, v) } return string(x) } func filterRegion(values [][]string, region string) [][]string { var res [][]string for _, v := range values { if strings.Contains(strings.ToLower(v[5]), strings.ToLower(region)) { res = append(res, v) } } return res } func filterOperator(values [][]string, operator string) [][]string { var res [][]string for _, v := range values { if strings.Contains(strings.ToLower(v[4]), strings.ToLower(operator)) { res = append(res, v) } } return res } func validate(min, max, dif int) bool { if max-min == dif-1 { return true } return false } func convert(v []string) (pre, min, max, dif int) { pre, err := strconv.Atoi(v[0]) if err != nil { log.Panic(err) } min, err = strconv.Atoi(v[1]) if err != nil { log.Panic(err) } max, err = strconv.Atoi(v[2]) if err != nil { log.Panic(err) } dif, err = strconv.Atoi(v[3]) if err != nil { log.Panic(err) } return } type runes []rune func increment(r runes) runes { if len(r) &lt;= 1 { return r } var res runes i, err := strconv.Atoi(string(r)) if err != nil { log.Panic(err) } i++ res = runes(strconv.Itoa(i)) if len(res) == len(r) { return res } res = res.reverse() l := len(res) for i := 0; i &lt; len(r)-l; i++ { res = append(res, '0') } return res.reverse() } func (r runes) reverse() (rev []rune) { for i := len(r) - 1; i &gt;= 0; i-- { rev = append(rev, r[i]) } return } func hi(r runes) runes { var res runes for i := len(r) - 1; i &gt;= 1; i-- { res = append(res, '9') if r[i] == '0' { continue } break } l := len(res) r = r.reverse() for i := l; i &lt; len(r); i++ { res = append(res, r[i]) } return res.reverse() } func decrement(r runes) runes { if len(r) &lt;= 1 { return r } var res runes i, err := strconv.Atoi(string(r)) if err != nil { log.Panic(err) } i-- res = runes(strconv.Itoa(i)) if len(res) == len(r) { return res } res = res.reverse() l := len(res) for i := 0; i &lt; len(r)-l; i++ { res = append(res, '0') } return res.reverse() } func low(r runes) runes { var res runes res = append(res, r[0]) for i := 2; i &lt;= len(r); i++ { res = append(res, '0') } return res } func compute(pre, min, max, suf string) { // mask found if min and max are equal if min == max { fmt.Printf("%v%v%v\n", pre, min, suf) return } var prefix []rune mi := runes(min) ma := runes(max) if len(mi) != len(ma) { log.Panic("the length of min and max values is not equal") } for k, v := range ma { if v == mi[k] { prefix = append(prefix, v) continue } break } if l := len(prefix); l != 0 { compute(pre+string(prefix), string(mi[l:]), string(ma[l:]), suf) return } var suffix runes for k, v := range mi.reverse() { if ma.reverse()[k]-v == 9 { suffix = append(suffix, 'X') continue } break } if l := len(suffix); l != 0 { compute(pre, string(mi)[:len(mi)-l], string(ma)[:len(ma)-l], string(suffix)+suf) return } if len(mi) == 1 { compute(pre+"["+string(mi)+"-"+string(ma)+"]", "", "", suf) return } zc, err := strconv.Atoi(min) if err != nil { log.Panic(err) } if zc == 0 { compute(pre, string(mi), string(decrement(low(ma))), suf) compute(pre, string(low(ma)), max, suf) return } compute(pre, string(mi), string(hi(mi)), suf) if increment(hi(mi))[0] == mi[0] { compute(pre, string(increment(hi(mi))), max, suf) } else { if increment(hi(mi))[0] == ma[0] { compute(pre, string(increment(hi(mi))), max, suf) } else { compute(pre, string(increment(hi(mi))), string(decrement(low(ma))), suf) compute(pre, string(low(ma)), max, suf) } } } func readArgs() params { p := params{ URL: "https://rossvyaz.gov.ru/docs/articles/DEF-9x.csv", Region: "", Operator: "", Comment: false, Prefix: "", Suffix: "", Group: false, } wait := false key := "" for _, v := range os.Args[1:] { if wait { switch key { case "-u": p.URL = v case "-r": p.Region = v case "-o": p.Operator = v case "-p": p.Prefix = v case "-s": p.Suffix = v } wait = false } else { if v == "-c" { p.Comment = true continue } if v == "-g" { p.Group = true continue } switch v { case "-u", "-r", "-o", "-p", "-s": key = v wait = true case "-h": help() os.Exit(0) default: fmt.Println("unknown option:", v) fmt.Println("show help: genmask -h") os.Exit(1) } } } if wait == true { fmt.Printf("missing value of %s argument\n", key) os.Exit(1) } return p } func help() { fmt.Println("usage: genmask [-u &lt;url&gt;] [-r &lt;region filter&gt;] [-c] [-p &lt;prefix&gt;] [-s &lt;suffix&gt;]") fmt.Println("\tu &lt;value&gt;: url to csv file. Default is https://rossvyaz.gov.ru/docs/articles/DEF-9x.csv") fmt.Println("\tr &lt;value&gt;: find entries in the csv file that contain the value in region field.") fmt.Println("\t It's better to use short masks, because errors and typos are possible in the csv file.") fmt.Println("\to &lt;value&gt;: find entries in the csv file that contain the value in operator field.") fmt.Println("\t It's better to use short masks, because errors and typos are possible in the csv file.") fmt.Println("\tc Print a comment: &lt;; code, min, max, length, cellular operator, region&gt; before each interval") fmt.Println("\tp &lt;value&gt;: Print a prefix for each mask") fmt.Println("\ts &lt;value&gt;: Print a suffix for each mask") fmt.Println("\tg &lt;value&gt;: Group output by cellular operator") fmt.Println("show this help: genmask -h") }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de salida</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">genmask -r  -g ;  " " 958034XXXX ;  "" 95840430XX ;  " " 9584586XXX ;  " " 958385[0-1]XXX ;  "" 99916[5-6]XXXX 99646[0-2]XXXX 99638[3-7]XXXX 999681[0-4]XXX 991116[8-9]XXX 9911170XXX ;  "2 " 90101368XX 994200XXXX ;  "-" 968246XXXX 9696392XXX 965677XXXX 96567[0-2]XXXX 96384[2-9]XXXX 96381[8-9]XXXX 96381[0-7]XXXX 90989[3-5]XXXX 96380XXXXX 96228[3-5]XXXX 96195XXXXX 90988[3-5]XXXX 90981XXXXX 96813[2-4]XXXX 96229[3-5]XXXX ;  "" 999251[5-9]XXX 92949[3-4]XXXX 92949[0-1]XXXX 92947[5-9]XXXX 924748XXXX 92484XXXXX 92474[4-6]XXXX 92467XXXXX 92468[0-4]XXXX 92458[0-4]XXXX 92444XXXXX 92434XXXXX 934476XXXX 92404[0-1]XXXX 924025[4-7]XXX 999254[7-8]XXX 92414XXXXX ;  " " 91453[0-2]XXXX 91406[0-4]XXXX 91404XXXXX 914538XXXX 914539[0-2]XXX 9145[5-9]XXXXX 9146[0-1]XXXXX 9143[8-9]XXXXX</code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430934/">https://habr.com/ru/post/es430934/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430924/index.html">Programación Ada</a></li>
<li><a href="../es430926/index.html">El tiempo está fragmentado; un poco sobre la similitud de los sistemas distribuidos y un modelo de memoria débil</a></li>
<li><a href="../es430928/index.html">Sobre la "casa inteligente": cómo hacer una luz de fondo "inteligente"</a></li>
<li><a href="../es430930/index.html">Acerca de los gráficos 3D en palabras simples</a></li>
<li><a href="../es430932/index.html">Los hackers robaron más de 21 millones de rublos de un banco ruso</a></li>
<li><a href="../es430936/index.html">DEFCON 21. La conferencia DNS puede ser peligrosa para su salud. Parte 2</a></li>
<li><a href="../es430938/index.html">Cómo obtener los primeros pedidos en diseño cuando no hay cartera ni experiencia</a></li>
<li><a href="../es430940/index.html">¡SDK para ti, SDK para mí, SDK para todos! Cómo hacer un SDK y por qué es necesario</a></li>
<li><a href="../es430942/index.html">Julia Scripts y análisis de argumentos de línea de comando</a></li>
<li><a href="../es430944/index.html">La NASA ha decidido a los participantes para su competencia de mini-rover de luna</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>