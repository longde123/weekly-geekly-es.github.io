<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⌚️ 🚶🏿 ✍🏻 "Efek aljabar" dalam bahasa manusia ⛈️ 💎 👨🏾‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Komentar Penerjemah: Ini adalah terjemahan dari artikel hebat oleh Dan Abramov, kontributor React. Contoh-contohnya ditulis untuk JS, tetapi akan jela...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Efek aljabar" dalam bahasa manusia</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470718/">  Komentar Penerjemah: Ini adalah terjemahan dari artikel hebat oleh Dan Abramov, kontributor React.  Contoh-contohnya ditulis untuk JS, tetapi akan jelas bagi pengembang dalam bahasa apa pun.  Idenya umum untuk semua. <br><br><h3>  Pernahkah Anda mendengar tentang efek aljabar? </h3><br><p>  Upaya pertama saya untuk mengetahui siapa mereka dan mengapa mereka harus membuat saya bersemangat tidak berhasil.  Saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PDF</a> , tetapi lebih membingungkan saya.  (Untuk beberapa alasan, saya tertidur ketika membaca artikel akademik.) </p><br><p>  Tetapi kolega saya, Sebastian, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyebut</a> mereka model mental dari beberapa hal yang kami lakukan dalam Bereaksi.  (Sebastian bekerja di tim React dan mengajukan banyak ide, termasuk Hooks dan Suspense.) Pada titik tertentu, itu menjadi meme lokal di tim React, dan banyak dari percakapan kami berakhir dengan yang berikut: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xb/xm/oi/xbxmoi1bn7whmzill63sq1yz1tw.jpeg"></div><br><p>  Ternyata efek aljabar adalah konsep yang keren, dan tidak seseram yang saya rasakan pada awalnya setelah membaca PDF ini.  Jika Anda hanya menggunakan Bereaksi, Anda tidak perlu tahu apa pun tentang mereka, tetapi jika Anda, seperti saya, tertarik, baca terus. </p><a name="habracut"></a><br><p>  (Penafian: Saya bukan seorang peneliti di bidang bahasa pemrograman dan mungkin telah mengacaukan sesuatu dalam penjelasan saya. Jadi beri tahu saya jika saya salah!) </p><br><h3>  Ini masih awal produksi </h3><br><p> Efek aljabar saat ini merupakan konsep eksperimental dari bidang studi bahasa pemrograman.  Ini berarti bahwa tidak seperti <code>if</code> , <code>for</code> atau bahkan <code>async/await</code> ekspresi, Anda kemungkinan besar tidak akan dapat menggunakannya sekarang dalam produksi.  Mereka didukung oleh hanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahasa</a> yang diciptakan khusus untuk mempelajari ide ini.  Ada kemajuan dalam implementasi mereka di OCaml, yang ... masih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berlangsung</a> .  Dengan kata lain, perhatikan, tetapi jangan menyentuh dengan tangan Anda. </p><br><h3>  Kenapa itu harus mengganggu saya? </h3><br><p>  Bayangkan Anda menulis kode menggunakan <code>goto</code> , dan seseorang memberi tahu Anda tentang keberadaan <code>if</code> dan <code>for</code> constructs.  Atau mungkin Anda terperosok dalam neraka panggilan balik dan seseorang menunjukkan kepada Anda <code>async/await</code> .  Cukup keren, bukan? </p><br><p>  Jika Anda adalah tipe orang yang suka mempelajari inovasi pemrograman beberapa tahun sebelum menjadi modis, mungkin ini saatnya untuk tertarik pada efek aljabar.  Meski tidak perlu.  Ini adalah cara berbicara tentang <code>async/await</code> pada tahun 1999. </p><br><h3>  Nah, apa efeknya? </h3><br><p>  Nama itu mungkin sedikit membingungkan, tetapi idenya sederhana.  Jika Anda terbiasa dengan blok <code>try/catch</code> , Anda akan dengan cepat memahami efek aljabar. </p><br><p>  Mari kita ingat <code>try/catch</code> .  Katakanlah Anda memiliki fungsi yang melempar pengecualian.  Mungkin ada beberapa panggilan bersarang di antara itu dan <code>catch</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'  '</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">",   : "</span></span>, err); }</code> </pre> <br><p>  Kami melempar pengecualian di dalam <code>getName</code> , tetapi "muncul" melalui <code>makeFriends</code> ke <code>catch</code> terdekat.  Ini adalah properti utama <code>try/catch</code> .  <strong>Kode perantara tidak diperlukan untuk peduli dengan penanganan kesalahan.</strong> </p><br><p>  Tidak seperti kode kesalahan dalam bahasa seperti C, saat menggunakan <code>try/catch</code> Anda tidak harus melewati kesalahan secara manual melalui setiap tingkat perantara untuk menangani kesalahan di tingkat atas.  Pengecualian muncul secara otomatis. </p><br><p>  Apa hubungannya ini dengan efek aljabar? </p><br><p>  Dalam contoh di atas, segera setelah kami melihat kesalahan, kami tidak akan dapat melanjutkan menjalankan program.  Ketika kita menemukan diri kita dalam <code>catch</code> , eksekusi program normal akan berhenti. </p><br><p>  Semua sudah berakhir.  Sudah terlambat.  Yang terbaik yang bisa kita lakukan adalah pulih dari kegagalan dan mungkin entah bagaimana mengulangi apa yang kita lakukan, tetapi secara ajaib kita tidak bisa "kembali" ke tempat kita berada dan melakukan sesuatu yang lain.  Dan dengan efek aljabar, kita bisa. </p><br><p>  Ini adalah contoh yang ditulis dalam dialek JavaScript hipotetis (sebut saja ES2025 untuk bersenang-senang), yang memungkinkan kami untuk <em>terus</em> bekerja setelah <code>user.name</code> hilang: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre><br><p>  (Saya meminta maaf kepada semua pembaca dari 2025 yang mencari "ES2025" di Internet dan masuk ke dalam artikel ini. Jika pada saat itu efek aljabar akan menjadi bagian dari JavaScript, saya akan dengan senang hati memperbarui artikel!) </p><br><p>  Alih-alih <code>throw</code> kami menggunakan <code>perform</code> kata kunci hipotetis.  Demikian pula, alih-alih <code>try/catch</code> kami menggunakan <code>try/handle</code> hipotetis.  <strong>Sintaks yang</strong> tepat <strong>tidak masalah di sini</strong> - saya baru saja menemukan sesuatu untuk mengilustrasikan ide tersebut. </p><br><p>  Jadi apa yang terjadi di sini?  Mari kita lihat lebih dekat. </p><br><p>  Alih-alih melempar kesalahan, kami <em>melakukan efeknya</em> .  Sama seperti kita dapat <em>membuang</em> objek apa pun, di sini kita dapat memberikan beberapa nilai untuk <em>diproses</em> .  Dalam contoh ini, saya meneruskan string, tetapi bisa berupa objek atau tipe data lainnya: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; }</code> </pre> <br><p>  Saat kami melempar pengecualian, mesin mencari pawang <code>try/catch</code> terdekat di tumpukan panggilan.  Demikian pula, ketika kita menjalankan <em>efek</em> , mesin akan mencari <code>try/handle</code> efek <code>try/handle</code> terdekat di atas tumpukan: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br><p>  Efek ini memungkinkan kita untuk memutuskan bagaimana menangani situasi ketika nama tidak ditentukan.  Baru di sini (dibandingkan dengan pengecualian) adalah <code>resume with</code> hipotetis <code>resume with</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre><br><p>  Ini adalah sesuatu yang tidak dapat Anda lakukan dengan <code>try/catch</code> .  Ini memungkinkan kita <strong>untuk kembali ke tempat kita melakukan efek dan melewatkan sesuatu dari pawang</strong> .  : -O </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// 1.     name = perform 'ask_name'; // 4. ...     (name   ' ') } return name; } // ... try { makeFriends(arya, gendry); } handle(effect) { // 2.    ( try/catch)  (effect === 'ask_name') { // 3. ,      (    try/catch!) resume with ' '; } }</span></span></code> </pre><br><p>  Butuh sedikit waktu untuk merasa nyaman, tetapi secara konseptual ini tidak jauh berbeda dari <code>try/catch</code> dengan pengembalian. </p><br><p>  Perhatikan, bagaimanapun, bahwa efek aljabar adalah alat yang jauh lebih kuat daripada sekadar <code>try/catch</code> .  Pemulihan kesalahan hanyalah salah satu dari banyak kasus penggunaan yang mungkin.  Saya mulai dengan contoh ini hanya karena paling mudah bagi saya untuk mengerti. </p><br><br><h3>  Fungsi tidak memiliki warna </h3><br><p>  Efek aljabar memiliki implikasi yang menarik untuk kode asinkron. </p><br><p>  Dalam bahasa dengan <code>async/await</code> fungsi biasanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memiliki "warna"</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rusia</a> ).  Misalnya, dalam JavaScript, kita tidak bisa hanya membuat <code>getName</code> asynchronous tanpa menginfeksi <code>makeFriends</code> dan fungsi pemanggilannya dengan async.  Ini bisa sangat menyakitkan jika bagian dari kode terkadang perlu sinkron dan terkadang tidak sinkron. </p><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       ... async getName(user) { // ... } //       ... async function makeFriends(user1, user2) { user1.friendNames.add(await getName(user2)); user2.friendNames.add(await getName(user1)); } //   ... async getName(user) { // ... }</span></span></code> </pre><br><p>  Generator JavaScript bekerja dengan cara yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sama</a> : jika Anda bekerja dengan generator, maka semua kode perantara juga harus tahu tentang generator. </p><br><p>  Nah, apa hubungannya dengan itu? </p><br><p>  Untuk sesaat, mari kita lupakan tentang async / tunggu dan kembali ke contoh kita: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre><br><p>  Bagaimana jika penangan efek kami tidak dapat mengembalikan "nama cadangan" secara serempak?  Bagaimana jika kita ingin mendapatkannya dari database? </p><br><p>  Ternyata kami dapat memanggil <code>resume with</code> sinkron dari penangan efek kami tanpa membuat perubahan apa pun untuk <code>getName</code> atau <code>makeFriends</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); } }</code> </pre><br><p>  Dalam contoh ini, kami memanggil <code>resume with</code> hanya satu detik kemudian.  Anda dapat mempertimbangkan <code>resume with</code> panggilan balik, yang hanya dapat Anda panggil sekali.  (Anda juga dapat memamerkan kepada teman-teman dengan menyebut hal ini " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelanjutan terbatas</a> satu kali" (istilah <i>kelanjutan terbatas</i> belum menerima terjemahan yang stabil ke dalam bahasa Rusia - sekitar Terjemahan.).) </p><br><p>  Sekarang mekanisme efek aljabar harus sedikit lebih jelas.  Ketika kami melempar kesalahan, mesin JavaScript memutar tumpukan dengan menghancurkan variabel lokal dalam proses.  Namun, ketika kita <em>mengeksekusi</em> efeknya, mesin hipotetis kita membuat panggilan balik (sebenarnya "bingkai lanjutan", kira-kira. Terjemahan.) Dengan sisa fungsi kita, dan <code>resume with</code> akan memanggilnya. </p><br><p>  Sekali lagi, pengingat: sintaks spesifik dan kata kunci spesifik seluruhnya diciptakan hanya untuk artikel ini.  Intinya bukan di dalamnya, tetapi di mekanik. </p><br><br><h3>  Catatan Kebersihan </h3><br><p>  Perlu dicatat bahwa efek aljabar muncul sebagai hasil dari studi pemrograman fungsional.  Beberapa masalah yang mereka selesaikan hanya unik untuk pemrograman fungsional.  Misalnya, dalam bahasa yang tidak mengizinkan efek samping sewenang-wenang (seperti Haskell), Anda harus menggunakan konsep seperti monad untuk menyeret efek melalui program Anda.  Jika Anda pernah membaca tutorial monad, maka Anda tahu bahwa itu bisa sulit dimengerti.  Efek aljabar membantu untuk melakukan sesuatu yang serupa dengan sedikit usaha. </p><br><p>  Itulah mengapa sebagian besar diskusi tentang efek aljabar sama sekali tidak bisa dipahami oleh saya.  (Saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak tahu Haskell</a> dan "teman-teman" -nya.) Namun, saya berpikir bahwa bahkan dalam bahasa yang tidak bersih seperti JavaScript, efek aljabar dapat menjadi alat yang sangat kuat untuk memisahkan "apa" dari "bagaimana" dalam "bagaimana" dalam kode Anda. </p><br><p>  Mereka memungkinkan Anda untuk menulis kode yang menggambarkan <em>apa yang</em> Anda lakukan: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumerateFiles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dir</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> contents = perform OpenDirectory(dir); perform Log(<span class="hljs-string"><span class="hljs-string">'Enumerating files in '</span></span>, dir); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> contents.files) { perform HandleFile(file); } perform Log(<span class="hljs-string"><span class="hljs-string">'Enumerating subdirectories in '</span></span>, dir); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> directory <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> contents.dir) { <span class="hljs-comment"><span class="hljs-comment">//           enumerateFiles(directory); } perform Log('Done'); }</span></span></code> </pre> <br><p>  Dan kemudian bungkus dengan sesuatu yang menggambarkan "bagaimana" Anda melakukannya: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> files = []; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { enumerateFiles(<span class="hljs-string"><span class="hljs-string">'C:\\'</span></span>); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Log) { myLoggingLibrary.log(effect.message); resume; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> OpenDirectory) { myFileSystemImpl.openDir(effect.dirName, (contents) =&gt; { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> contents; }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HandleFile) { files.push(effect.fileName); resume; } } <span class="hljs-comment"><span class="hljs-comment">//  `files`    </span></span></code> </pre><br><p>  Yang berarti bahwa bagian-bagian ini dapat menjadi perpustakaan: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withMyLoggingLibrary } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'my-log'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withMyFileSystem } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'my-fs'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ourProgram</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ enumerateFiles(<span class="hljs-string"><span class="hljs-string">'C:\\'</span></span>); } withMyLoggingLibrary(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { withMyFileSystem(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { ourProgram(); }); });</code> </pre><br><p>  Tidak seperti async / menunggu atau generator, efek aljabar tidak memerlukan komplikasi fungsi "perantara".  Panggilan kami ke <code>enumerateFiles</code> mungkin jauh di dalam program kami, tetapi selama suatu tempat di atas ada penangan efek untuk setiap efek yang dapat dieksekusi, kode kami akan terus bekerja. </p><br><p>  Penangan efek memungkinkan kita untuk memisahkan logika program dari implementasi spesifik efeknya tanpa tarian dan kode boilerplate yang tidak perlu.  Sebagai contoh, kita dapat mendefinisikan kembali perilaku dalam pengujian untuk menggunakan sistem file palsu dan melakukan snapshot log alih-alih menampilkannya di konsol: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withFakeFileSystem } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'fake-fs'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withLogSnapshot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logs = []; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fn(); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Log) { logs.push(effect.message); resume; } } <span class="hljs-comment"><span class="hljs-comment">// Snapshot  . expect(logs).toMatchSnapshot(); } test('my program', () =&gt; { const fakeFiles = [ /* ... */ ]; withFakeFileSystem(fakeFiles, () =&gt; { withLogSnapshot(() =&gt; { ourProgram(); }); }); });</span></span></code> </pre><br><p>  Karena fungsi tidak memiliki "warna" (kode perantara tidak harus tahu tentang efek), dan penangan efek dapat dikomposisikan (mereka dapat disarangkan), Anda dapat membuat abstraksi yang sangat ekspresif dengannya. </p><br><br><h3>  Jenis Catatan </h3><br><p>  Karena efek aljabar berasal dari bahasa yang diketik secara statis, sebagian besar perdebatan tentang mereka berfokus pada cara mengekspresikannya dalam jenis.  Ini tidak diragukan lagi penting, tetapi juga dapat memperumit pemahaman konsep.  Itu sebabnya artikel ini tidak berbicara tentang tipe sama sekali.  Namun, saya harus mencatat bahwa biasanya fakta bahwa suatu fungsi dapat melakukan efek akan dikodekan dalam tanda tangan jenisnya.  Dengan demikian, Anda akan dilindungi dari situasi ketika efek yang tidak terduga dilakukan, atau Anda tidak dapat melacak dari mana mereka berasal. </p><br><p>  Di sini Anda dapat mengatakan bahwa efek aljabar teknis "memberi warna" untuk fungsi dalam bahasa yang diketik secara statis, karena efek adalah bagian dari tanda tangan jenis.  Memang benar.  Namun, memperbaiki anotasi jenis untuk fungsi antara untuk memasukkan efek baru tidak dengan sendirinya merupakan perubahan semantik - tidak seperti menambahkan async atau mengubah fungsi menjadi generator.  Ketik inferensi juga dapat membantu menghindari kebutuhan untuk perubahan cascading.  Perbedaan penting adalah bahwa Anda dapat "menekan" efek dengan memasukkan rintisan kosong atau implementasi sementara (misalnya, panggilan sinkronisasi untuk efek asinkron), yang, jika perlu, memungkinkan Anda untuk mencegah efeknya pada kode eksternal - atau mengubahnya menjadi efek lain. </p><br><br><h3>  Apakah saya perlu efek aljabar dalam JavaScript? </h3><br><p>  Jujur saja, saya tidak tahu.  Mereka sangat kuat, dan dapat dikatakan bahwa mereka terlalu kuat untuk bahasa seperti JavaScript. </p><br><p>  Saya pikir mereka bisa sangat berguna untuk bahasa di mana mutabilitas jarang terjadi dan di mana pustaka standar sepenuhnya mendukung efek.  Jika Anda pertama kali melakukan <code>perform Timeout(1000), perform Fetch('http://google.com')</code> , dan <code>perform ReadFile('file.txt')</code> , dan bahasa Anda memiliki "pencocokan pola" dan pengetikan statis untuk efek, kemudian ini bisa menjadi lingkungan pemrograman yang sangat bagus. </p><br><p>  Mungkin bahasa ini bahkan akan dikompilasi dalam JavaScript! </p><br><br><h3>  Apa hubungannya ini dengan Bereaksi? </h3><br><p>  Tidak terlalu besar.  Anda bahkan dapat mengatakan bahwa saya menarik burung hantu di bola dunia. </p><br><p>  Jika Anda menonton ceramah saya tentang Time Slicing dan Suspense, maka bagian kedua termasuk komponen yang membaca data dari cache: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MovieDetails</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ id }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         ? const movie = movieCache.read(id); }</span></span></code> </pre><br><p>  (Laporan menggunakan API yang sedikit berbeda, tetapi bukan itu intinya.) </p><br><p>  Kode ini didasarkan pada fungsi Bereaksi untuk sampel data yang disebut " <code>Suspense</code> ", yang saat ini sedang dalam pengembangan aktif.  Hal yang menarik di sini, tentu saja, adalah bahwa data mungkin belum ada di movieCache - dalam hal ini, kita perlu melakukan sesuatu terlebih dahulu, karena kita tidak dapat melanjutkan eksekusi.  Secara teknis, dalam hal ini panggilan untuk membaca () melempar Janji (ya, lempar Janji - Anda harus menelan fakta ini).  Ini menjeda eksekusi.  Bereaksi memotong Janji ini dan ingat bahwa perlu mengulang rendering pohon komponen setelah Janji yang dilempar memenuhi. </p><br><p>  Ini bukan efek aljabar dalam dirinya sendiri, meskipun penciptaan trik ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terinspirasi oleh</a> mereka.  Trik ini mencapai tujuan yang sama: beberapa kode di bawah ini di tumpukan panggilan sementara lebih rendah daripada sesuatu yang lebih tinggi dalam tumpukan panggilan (dalam hal ini, Bereaksi), sementara semua fungsi antara tidak harus tahu tentang hal itu atau "diracuni" oleh async atau generator.  Tentu saja, kita tidak bisa "benar-benar" melanjutkan eksekusi dalam JavaScript, tetapi dari sudut pandang React, menampilkan ulang pohon komponen setelah izin Promise hampir sama.  Anda dapat menipu ketika model pemrograman Anda mengasumsikan idempotensi! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hooks</a> adalah contoh lain yang dapat mengingatkan Anda tentang efek aljabar.  Salah satu pertanyaan pertama yang diajukan orang adalah: di mana panggilan useState "tahu" komponen mana yang dimaksud? </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LikeButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  useState ,    ? const [isLiked, setIsLiked] = useState(false); }</span></span></code> </pre><br><p>  Saya sudah menjelaskan ini di akhir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> : di objek Bereaksi ada keadaan "pengirim saat ini", yang menunjukkan implementasi yang sedang Anda gunakan (misalnya, seperti dalam <code>react-dom</code> ).  Demikian pula, ada properti komponen saat ini yang menunjuk ke struktur data internal LikeButton.  Inilah cara useState mengetahui apa yang harus dilakukan. </p><br><p>  Sebelum terbiasa, orang sering berpikir bahwa itu terlihat seperti retasan kotor karena alasan yang jelas.  Adalah salah untuk mengandalkan keadaan umum yang bisa berubah.  (Catatan: menurut Anda bagaimana coba / tangkap diterapkan di mesin JavaScript?) </p><br><p>  Namun, secara konseptual Anda dapat mempertimbangkan useState () sebagai efek dari eksekusi State (), yang diproses oleh React ketika komponen Anda dieksekusi.  Ini "menjelaskan" mengapa Bereaksi (apa panggilan komponen Anda) dapat menyediakannya dengan keadaan (lebih tinggi di tumpukan panggilan, sehingga dapat memberikan penangan efek).  Memang, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerapan keadaan</a> eksplisit adalah salah satu contoh paling umum dalam buku teks tentang efek aljabar yang saya temui. </p><br><p>  Sekali lagi, tentu saja, ini bukan cara Bereaksi sebenarnya bekerja, karena kita tidak memiliki efek aljabar dalam JavaScript.  Sebagai gantinya, ada bidang tersembunyi di mana kami menyimpan komponen saat ini, serta bidang yang menunjuk ke "dispatcher" saat ini dengan implementasi useState.  Sebagai pengoptimalan kinerja, bahkan ada implementasi useState yang terpisah untuk <a href="">pemasangan dan pembaruan</a> .  Tetapi jika Anda sekarang sangat terpelintir oleh kode ini, maka Anda dapat menganggap mereka sebagai penangan efek biasa. </p><br><p>  Ringkasnya, kita dapat mengatakan bahwa dalam JavaScript <code>throw</code> dapat berfungsi sebagai perkiraan pertama untuk efek input-output (asalkan kode dapat dieksekusi kembali dengan aman nanti, dan sampai diikat ke CPU), dan bidang variabelnya adalah “ dispatcher "dikembalikan dalam percobaan / akhirnya dapat berfungsi sebagai perkiraan kasar untuk penangan efek sinkron. </p><br><p>  Anda bisa mendapatkan implementasi efek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan</a> kualitas yang jauh lebih tinggi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan generator</a> , tetapi ini berarti Anda harus meninggalkan sifat fungsi JavaScript yang "transparan" dan Anda harus melakukan semuanya dengan generator.  Dan ini "baik, itu ..." </p><br><h3>  Di mana mencari tahu lebih lanjut </h3><br><p>  Secara pribadi, saya terkejut betapa banyak efek aljabar yang diperoleh untuk saya.  Saya selalu mencoba yang terbaik untuk memahami konsep abstrak, seperti monad, tetapi efek aljabar hanya mengambil dan "dihidupkan" di kepala.  Saya harap artikel ini akan membantu mereka untuk "bergabung" dengan Anda. </p><br><p>  Saya tidak tahu apakah mereka akan mulai digunakan secara massal.  Saya pikir saya akan kecewa jika mereka tidak mengakar di salah satu bahasa utama pada tahun 2025.  Ingatkan saya untuk check-in lima tahun! </p><br><p>  Saya yakin Anda bisa melakukan jauh lebih menarik dengan mereka, tetapi sangat sulit untuk merasakan kekuatan mereka sampai Anda mulai menulis kode dan menggunakannya.  Jika posting ini membangkitkan rasa ingin tahu Anda, berikut adalah beberapa sumber lainnya tempat Anda dapat membaca lebih detail: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/ocamllabs/ocaml-effects-tutorial</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.janestreet.com/tech-talks/effective-programming</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.youtube.com/watch?v=hrBq8R_kxI0</a> </li></ul><br><p>  Banyak orang juga menunjukkan bahwa jika Anda menghilangkan aspek pengetikan (seperti yang saya lakukan dalam artikel ini), Anda dapat menemukan penggunaan sebelumnya dari teknik seperti itu dalam sistem kondisi di Common Lisp.      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>  ,   ,   call/cc          . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470718/">https://habr.com/ru/post/id470718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470696/index.html">Mengapa Kaldi bagus untuk pengenalan ucapan? (diperbarui 12.25.2019)</a></li>
<li><a href="../id470700/index.html">Meja. Logam Diam Milikmu</a></li>
<li><a href="../id470706/index.html">Python + Keras + LSTM: lakukan penerjemah teks dalam waktu setengah jam</a></li>
<li><a href="../id470710/index.html">Pembelajaran Mesin untuk berburu flat Anda. Bagian 2</a></li>
<li><a href="../id470714/index.html">Bagaimana saya pergi ke Final Terobosan Digital</a></li>
<li><a href="../id470720/index.html">Bagaimana cara menulis kontrak pintar dengan Python pada Ontologi? Bagian 2: API Penyimpanan</a></li>
<li><a href="../id470722/index.html">Bagaimana cara menulis kontrak pintar dengan Python pada Ontologi? Bagian 3: Runtime API</a></li>
<li><a href="../id470726/index.html">Bagaimana tidak tenggelam dalam rutinitas, atau Pengalaman kami membandingkan AWR dumps selama stress testing</a></li>
<li><a href="../id470728/index.html">Azure PowerShell: Kebanyakan Tidak Berbahaya</a></li>
<li><a href="../id470730/index.html">Azure PowerShell: "kebanyakan tidak berbahaya"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>