<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏿 👶🏼 👨🏽‍🚀 Função Math.Sin (dupla) para GPU 🧗🏽 👨🏼‍🎨 👨‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prefácio 
 Eu precisava calcular o arco com maior precisão no processador da placa de vídeo em tempo real. 

 O autor não estabeleceu uma meta para su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Função Math.Sin (dupla) para GPU</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426355/"><h3>  Prefácio </h3><br>  Eu precisava calcular o arco com maior precisão no processador da placa de vídeo em tempo real. <br><br>  O autor não estabeleceu uma meta para superar a função padrão System.Math.Sin () (C #) e não a alcançou. <br><a name="habracut"></a><br>  <i>O resultado do trabalho e minha escolha (para quem não quer ler):</i> <br><br><div class="spoiler">  <b class="spoiler_title">Sin_3 (rad)</b> <div class="spoiler_text"><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Math_d { const <span class="hljs-type"><span class="hljs-type">double</span></span> PI025 = Math.PI / <span class="hljs-number"><span class="hljs-number">4</span></span>; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>^<span class="hljs-number"><span class="hljs-number">17</span></span> = <span class="hljs-number"><span class="hljs-number">131072</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span> ),   <span class="hljs-number"><span class="hljs-number">10000</span></span> ( ),  <span class="hljs-number"><span class="hljs-number">2</span></span>^<span class="hljs-number"><span class="hljs-number">21</span></span> = <span class="hljs-number"><span class="hljs-number">22097152</span></span> (<span class="hljs-number"><span class="hljs-number">16</span></span> )   +<span class="hljs-number"><span class="hljs-number">-1</span></span> ( ) (  ) &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; const <span class="hljs-type"><span class="hljs-type">int</span></span> length_mem = <span class="hljs-number"><span class="hljs-number">22097152</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> length_mem_M1 = length_mem - <span class="hljs-number"><span class="hljs-number">1</span></span>; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;    sin,    . &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; static <span class="hljs-type"><span class="hljs-type">double</span></span>[] mem_sin; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;    cos,    . &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; static <span class="hljs-type"><span class="hljs-type">double</span></span>[] mem_cos; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;  ,   sin,    . &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> Initialise() { Ini_Mem_Sin(); Ini_Mem_Cos(); } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;       Cos,   . &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="rad"&gt;&lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">double</span></span> Sin_3(<span class="hljs-type"><span class="hljs-type">double</span></span> rad) { <span class="hljs-type"><span class="hljs-type">double</span></span> rad_025; <span class="hljs-type"><span class="hljs-type">int</span></span> i; //    //<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rad &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { rad = -rad + Math.PI; } i = (<span class="hljs-type"><span class="hljs-type">int</span></span>)(rad / PI025); //   rad_025 = rad - PI025 * i; //     ( ) i = i &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>; //      <span class="hljs-number"><span class="hljs-number">8</span></span> //    switch (i) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Sin_Lerp(rad_025); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Cos_Lerp(PI025 - rad_025); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Cos_Lerp(rad_025); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Sin_Lerp(PI025 - rad_025); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -Sin_Lerp(rad_025); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -Cos_Lerp(PI025 - rad_025); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -Cos_Lerp(rad_025); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -Sin_Lerp(PI025 - rad_025); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;   sin    &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; static <span class="hljs-type"><span class="hljs-type">void</span></span> Ini_Mem_Sin() { <span class="hljs-type"><span class="hljs-type">double</span></span> rad; mem_sin = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span>[length_mem]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length_mem; i++) { rad = (i * PI025) / length_mem_M1; mem_sin[i] = Math.Sin(rad); } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;   cos    &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; static <span class="hljs-type"><span class="hljs-type">void</span></span> Ini_Mem_Cos() { <span class="hljs-type"><span class="hljs-type">double</span></span> rad; mem_cos = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span>[length_mem]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length_mem; i++) { rad = (i * PI025) / length_mem_M1; mem_cos[i] = Math.Cos(rad); } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;      sin  <span class="hljs-number"><span class="hljs-number">0</span></span>  pi/<span class="hljs-number"><span class="hljs-number">4.</span></span> &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="rad"&gt;     <span class="hljs-number"><span class="hljs-number">0</span></span>  pi/<span class="hljs-number"><span class="hljs-number">4.</span></span> &lt;/param&gt; static <span class="hljs-type"><span class="hljs-type">double</span></span> Sin_Lerp(<span class="hljs-type"><span class="hljs-type">double</span></span> rad) { <span class="hljs-type"><span class="hljs-type">int</span></span> i_0; <span class="hljs-type"><span class="hljs-type">int</span></span> i_1; <span class="hljs-type"><span class="hljs-type">double</span></span> i_0d; <span class="hljs-type"><span class="hljs-type">double</span></span> percent; <span class="hljs-type"><span class="hljs-type">double</span></span> a; <span class="hljs-type"><span class="hljs-type">double</span></span> b; <span class="hljs-type"><span class="hljs-type">double</span></span> s; percent = rad / PI025; i_0d = percent * length_mem_M1; i_0 = (<span class="hljs-type"><span class="hljs-type">int</span></span>)i_0d; i_1 = i_0 + <span class="hljs-number"><span class="hljs-number">1</span></span>; a = mem_sin[i_0]; b = mem_sin[i_1]; s = i_0d - i_0; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lerp(a, b, s); } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;      cos  <span class="hljs-number"><span class="hljs-number">0</span></span>  pi/<span class="hljs-number"><span class="hljs-number">4.</span></span> &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="rad"&gt;     <span class="hljs-number"><span class="hljs-number">0</span></span>  pi/<span class="hljs-number"><span class="hljs-number">4.</span></span> &lt;/param&gt; static <span class="hljs-type"><span class="hljs-type">double</span></span> Cos_Lerp(<span class="hljs-type"><span class="hljs-type">double</span></span> rad) { <span class="hljs-type"><span class="hljs-type">int</span></span> i_0; <span class="hljs-type"><span class="hljs-type">int</span></span> i_1; <span class="hljs-type"><span class="hljs-type">double</span></span> i_0d; <span class="hljs-type"><span class="hljs-type">double</span></span> percent; <span class="hljs-type"><span class="hljs-type">double</span></span> a; <span class="hljs-type"><span class="hljs-type">double</span></span> b; <span class="hljs-type"><span class="hljs-type">double</span></span> s; percent = rad / PI025; i_0d = percent * length_mem_M1; i_0 = (<span class="hljs-type"><span class="hljs-type">int</span></span>)i_0d; i_1 = i_0 + <span class="hljs-number"><span class="hljs-number">1</span></span>; a = mem_cos[i_0]; b = mem_cos[i_1]; s = i_0d - i_0; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lerp(a, b, s); } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;      . (<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + s * (b - a)) &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="a"&gt;  . &lt;/param&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="b"&gt;  . &lt;/param&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="s"&gt;  . <span class="hljs-number"><span class="hljs-number">0</span></span> = a, <span class="hljs-number"><span class="hljs-number">1</span></span> = b, <span class="hljs-number"><span class="hljs-number">0.5</span></span> =   a  b. &lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">double</span></span> Lerp(<span class="hljs-type"><span class="hljs-type">double</span></span> a, <span class="hljs-type"><span class="hljs-type">double</span></span> b, <span class="hljs-type"><span class="hljs-type">double</span></span> s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + s * (b - a); } }</code> </pre> <br></div></div><br><h3>  Razões para publicação </h3><br><ul><li>  Não há função Sin padrão para duplicar na linguagem HLSL (mas isso não é exato) </li><li>  Há pouca informação disponível na Internet sobre esse tópico. </li></ul><br><h3>  Abordagens Consideradas </h3><br><ul><li>  Série Taylor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">(Wikipedia)</a> </li><li>  Polinômios ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">autor da função: "asvp"</a> ) </li><li>  Interpolação linear de resultados pré-calculados de Math.Sin e Math.Cos (autor: ) </li></ul><br><h3>  Os parâmetros analisados </h3><br><ul><li>  Precisão com Math.Sin </li><li>  Velocidade em relação ao Math.Sin </li></ul><br>  <u>Além da análise, melhoraremos seu desempenho.</u> <br><br><h4>  Taylor classifica </h4><br>  Prós: <br><br><ul><li><div class="spoiler">  <b class="spoiler_title">Maior precisão</b> <div class="spoiler_text">  Esta função, usada para calcular o valor do pecado, pode ser usada para calcular o <u>valor do</u> pecado <u>infinitamente preciso</u> .  Quanto mais iterações forem realizadas, mais precisamente o valor será obtido na saída (em uma hipótese).  Na prática de programação, vale a pena considerar erros de arredondamento dos cálculos, dependendo dos tipos de parâmetros usados ​​(duplo, flutuante, decimal e outros). </div></div></li><li><div class="spoiler">  <b class="spoiler_title">Calcula qualquer ângulo</b> <div class="spoiler_text">  Você pode inserir qualquer valor como argumento para a função, portanto, não há necessidade de monitorar os parâmetros de entrada. <br></div></div></li><li><div class="spoiler">  <b class="spoiler_title">Independência</b> <div class="spoiler_text">  Ele não requer cálculos preliminares (como as funções discutidas abaixo) e é frequentemente a base na qual as funções mais rápidas são montadas. <br></div></div></li></ul><br>  Contras: <br><br><ul><li><div class="spoiler">  <b class="spoiler_title">Velocidade muito baixa (4-10%)</b> <div class="spoiler_text">  São necessárias muitas iterações para obter a precisão mais próxima da precisão do Math.Sin e, como resultado, funciona 25 vezes mais lento que a função padrão. <br></div></div></li><li><div class="spoiler">  <b class="spoiler_title">Quanto maior o ângulo, menor a precisão</b> <div class="spoiler_text">  Quanto maior o ângulo inserido na função, mais iterações são necessárias para obter a mesma precisão do Math.Sin. <br></div></div></li></ul><br>  <i><b>Aparência original (velocidade: 4%):</b></i> <br><br>  A função padrão envolve o cálculo de fatoriais, além de aumentar a potência a cada iteração. <br><br><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c847dfe24de5ad14ebd936999a7183ba96d81717" alt="imagem"><br><br>  <i><b>Modificado (velocidade: 10%):</b></i> <br><br>  O cálculo de alguns graus pode ser reduzido em um ciclo (a * = aa;), e outros fatoriais podem ser pré-calculados e colocados em uma matriz, enquanto a alteração dos sinais (+, -, +, ...) não pode ser aumentada para uma potência e seu cálculo também pode ser reduzido usando os valores anteriores. <br><br>  O resultado é o seguinte código: <br><br><div class="spoiler">  <b class="spoiler_title">Sin (rad, passos)</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> // &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;  ,    Fact &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; static <span class="hljs-type"><span class="hljs-type">double</span></span>[] fact; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;            . ///   rad,   . ///  ( Math): <span class="hljs-number"><span class="hljs-number">4</span></span>% (fps)  steps = <span class="hljs-number"><span class="hljs-number">17</span></span> &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="rad"&gt;   .      pi/<span class="hljs-number"><span class="hljs-number">4.</span></span> &lt;/param&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="steps"&gt;  :  ,   .  pi/<span class="hljs-number"><span class="hljs-number">4</span></span>   E<span class="hljs-number"><span class="hljs-number">-15</span></span>  <span class="hljs-number"><span class="hljs-number">8.</span></span> &lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">double</span></span> Sin(<span class="hljs-type"><span class="hljs-type">double</span></span> rad, <span class="hljs-type"><span class="hljs-type">int</span></span> steps) { <span class="hljs-type"><span class="hljs-type">double</span></span> ret; <span class="hljs-type"><span class="hljs-type">double</span></span> a; //,     <span class="hljs-type"><span class="hljs-type">double</span></span> aa; // *  <span class="hljs-type"><span class="hljs-type">int</span></span> i_f; //  <span class="hljs-type"><span class="hljs-type">int</span></span> sign; // (  -  +,     = +) ret = <span class="hljs-number"><span class="hljs-number">0</span></span>; sign = <span class="hljs-number"><span class="hljs-number">-1</span></span>; aa = rad * rad; a = rad; i_f = <span class="hljs-number"><span class="hljs-number">1</span></span>; //      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; steps; n++) { sign *= <span class="hljs-number"><span class="hljs-number">-1</span></span>; ret += sign * a / Fact(i_f); a *= aa; i_f += <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;   (n!).  n &gt; fact.Length,  <span class="hljs-number"><span class="hljs-number">-1.</span></span> &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="n"&gt; ,     . &lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">double</span></span> Fact(<span class="hljs-type"><span class="hljs-type">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; n &lt; fact.Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fact[n]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Debug</span></span>.Log("    . n = " + n + ",   = " + fact.Length); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;  . &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; static <span class="hljs-type"><span class="hljs-type">void</span></span> Init_Fact() { <span class="hljs-type"><span class="hljs-type">int</span></span> steps; steps = <span class="hljs-number"><span class="hljs-number">46</span></span>; fact = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span>[steps]; fact[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> n = <span class="hljs-number"><span class="hljs-number">1</span></span>; n &lt; steps; n++) { fact[n] = fact[n - <span class="hljs-number"><span class="hljs-number">1</span></span>] * n; } }</code> </pre><br></div></div><br>  <i><b>Vista superior (velocidade: 19%):</b></i> <br><br>  Sabemos que quanto menor o ângulo, menos iterações são necessárias.  O menor ângulo que precisamos é = 0,25 * PI, ou seja,  45 graus.  Considerando Sin e Cos na região de 45 graus, podemos obter todos os valores de -1 a 1 para Sin (na região de 2 * PI).  Para fazer isso, dividimos o círculo (2 * PI) em 8 partes e, para cada parte, indicamos nosso próprio método de cálculo do seno.  Além disso, para acelerar o cálculo, recusaremos usar a função de obter o restante (%) (para obter a posição do ângulo dentro da zona de 45 graus): <br><br><div class="spoiler">  <b class="spoiler_title">Sin_2 (rad)</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"> // &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;  ,    Fact &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; static <span class="hljs-type"><span class="hljs-type">double</span></span>[] fact; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;   Sin &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="rad"&gt;&lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">double</span></span> Sin_2(<span class="hljs-type"><span class="hljs-type">double</span></span> rad) { <span class="hljs-type"><span class="hljs-type">double</span></span> rad_025; <span class="hljs-type"><span class="hljs-type">int</span></span> i; //rad = rad % PI2; //% -   .  , fps   <span class="hljs-number"><span class="hljs-number">90</span></span>  <span class="hljs-number"><span class="hljs-number">150</span></span> (  <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span>   ) //rad_025 = rad % PI025; i = (<span class="hljs-type"><span class="hljs-type">int</span></span>)(rad / PI025); rad_025 = rad - PI025 * i; i = i &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>; //     <span class="hljs-number"><span class="hljs-number">8</span></span>  //    switch (i) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Sin(rad_025, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Cos(PI025 - rad_025, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Cos(rad_025, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Sin(PI025 - rad_025, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -Sin(rad_025, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -Cos(PI025 - rad_025, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -Cos(rad_025, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -Sin(PI025 - rad_025, <span class="hljs-number"><span class="hljs-number">8</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;            . ///   rad,   . ///  ( Math): <span class="hljs-number"><span class="hljs-number">10</span></span>% (fps)  steps = <span class="hljs-number"><span class="hljs-number">17</span></span> &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="rad"&gt;   .      pi/<span class="hljs-number"><span class="hljs-number">4.</span></span> &lt;/param&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="steps"&gt;  :  ,   .  pi/<span class="hljs-number"><span class="hljs-number">4</span></span>   E<span class="hljs-number"><span class="hljs-number">-15</span></span>  <span class="hljs-number"><span class="hljs-number">8.</span></span> &lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">double</span></span> Sin(<span class="hljs-type"><span class="hljs-type">double</span></span> rad, <span class="hljs-type"><span class="hljs-type">int</span></span> steps) { <span class="hljs-type"><span class="hljs-type">double</span></span> ret; <span class="hljs-type"><span class="hljs-type">double</span></span> a; //,     <span class="hljs-type"><span class="hljs-type">double</span></span> aa; // *  <span class="hljs-type"><span class="hljs-type">int</span></span> i_f; //  <span class="hljs-type"><span class="hljs-type">int</span></span> sign; // (  -  +,     = +) ret = <span class="hljs-number"><span class="hljs-number">0</span></span>; sign = <span class="hljs-number"><span class="hljs-number">-1</span></span>; aa = rad * rad; a = rad; i_f = <span class="hljs-number"><span class="hljs-number">1</span></span>; //      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; steps; n++) { sign *= <span class="hljs-number"><span class="hljs-number">-1</span></span>; ret += sign * a / Fact(i_f); a *= aa; i_f += <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;            . ///   rad,   . ///  ( Math): <span class="hljs-number"><span class="hljs-number">10</span></span>% (fps), <span class="hljs-number"><span class="hljs-number">26</span></span>% (test)  steps = <span class="hljs-number"><span class="hljs-number">17</span></span> &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="rad"&gt;   .      pi/<span class="hljs-number"><span class="hljs-number">4.</span></span> &lt;/param&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="steps"&gt;  :  ,   .  pi/<span class="hljs-number"><span class="hljs-number">4</span></span>   E<span class="hljs-number"><span class="hljs-number">-15</span></span>  <span class="hljs-number"><span class="hljs-number">8.</span></span> &lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">double</span></span> Cos(<span class="hljs-type"><span class="hljs-type">double</span></span> rad, <span class="hljs-type"><span class="hljs-type">int</span></span> steps) { <span class="hljs-type"><span class="hljs-type">double</span></span> ret; <span class="hljs-type"><span class="hljs-type">double</span></span> a; <span class="hljs-type"><span class="hljs-type">double</span></span> aa; // *  <span class="hljs-type"><span class="hljs-type">int</span></span> i_f; //  <span class="hljs-type"><span class="hljs-type">int</span></span> sign; // (  -  +,     = +) ret = <span class="hljs-number"><span class="hljs-number">0</span></span>; sign = <span class="hljs-number"><span class="hljs-number">-1</span></span>; aa = rad * rad; a = <span class="hljs-number"><span class="hljs-number">1</span></span>; i_f = <span class="hljs-number"><span class="hljs-number">0</span></span>; //      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; steps; n++) { sign *= <span class="hljs-number"><span class="hljs-number">-1</span></span>; ret += sign * a / Fact(i_f); a *= aa; i_f += <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;   (n!).  n &gt; fact.Length,  <span class="hljs-number"><span class="hljs-number">-1.</span></span> &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="n"&gt; ,     . &lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">double</span></span> Fact(<span class="hljs-type"><span class="hljs-type">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; n &lt; fact.Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fact[n]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Debug</span></span>.Log("    . n = " + n + ",   = " + fact.Length); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;  . &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; static <span class="hljs-type"><span class="hljs-type">void</span></span> Init_Fact() { <span class="hljs-type"><span class="hljs-type">int</span></span> steps; steps = <span class="hljs-number"><span class="hljs-number">46</span></span>; fact = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span>[steps]; fact[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> n = <span class="hljs-number"><span class="hljs-number">1</span></span>; n &lt; steps; n++) { fact[n] = fact[n - <span class="hljs-number"><span class="hljs-number">1</span></span>] * n; } }</code> </pre> <br></div></div><br><h3>  Polinômios </h3><br>  Me deparei com esse método na Internet, o autor precisava de uma função de pesquisa rápida do Sin para o dobro de baixa precisão (erro &lt;0,000 001) sem usar bibliotecas de valores pré-calculados. <br><br>  Prós: <br><br><ul><li><div class="spoiler">  <b class="spoiler_title">Alta velocidade (9-84%)</b> <div class="spoiler_text">  Inicialmente, o polinômio lançado sem alterações mostrou uma velocidade de 9% do Math.Sin original, que é 10 vezes mais lento.  Graças a pequenas alterações, a velocidade aumenta acentuadamente para 84%, o que não é ruim se você fechar os olhos com precisão. <br></div></div></li><li><div class="spoiler">  <b class="spoiler_title">Não são necessários cálculos preliminares adicionais nem memória</b> <div class="spoiler_text">  Se, no topo e mais abaixo, precisamos compor matrizes de variáveis ​​para acelerar os cálculos, então todos os coeficientes-chave foram gentilmente calculados e colocados na fórmula pelo próprio autor na forma de constantes. <br></div></div></li><li><div class="spoiler">  <b class="spoiler_title">Precisão maior que Mathf.Sin (flutuante)</b> <div class="spoiler_text">  Para comparação: <br><br>  0,84147 <b>1</b> - Mathf.Sin (1) (mecanismo Unity); <br>  0,841470984807897 - Math.Sin (1) (função C # padrão); <br>  0,8414709 <b>56802368</b> - sin (1) (GPU, idioma hlsl); <br>  0,84147 <b>1184637935</b> - <b>Sin_0 (1)</b> . <br></div></div></li></ul><br>  Contras: <br><br><ul><li><div class="spoiler">  <b class="spoiler_title">Não universal</b> <div class="spoiler_text">  Você não pode ajustar a precisão manualmente, porque não se sabe quais ferramentas o autor usou para calcular esse polinômio. <br></div></div></li><li><div class="spoiler">  <b class="spoiler_title">Porque</b> <div class="spoiler_text">  Por que o autor precisava de uma função que não requer matrizes e que tenha uma precisão tão baixa (comparada à dupla)? <br></div></div></li></ul><br>  <i><b>Visualização original:</b></i> <br><br><div class="spoiler">  <b class="spoiler_title">Sin_1 (x)</b> <div class="spoiler_text"><pre> <code class="hljs cmake">/// &lt;summary&gt;  ( <span class="hljs-keyword"><span class="hljs-keyword">Math</span></span>): <span class="hljs-number"><span class="hljs-number">9</span></span>% (fps)&lt;/summary&gt; /// &lt;param name=<span class="hljs-string"><span class="hljs-string">"x"</span></span>&gt;     -<span class="hljs-number"><span class="hljs-number">2</span></span>*Pi  <span class="hljs-number"><span class="hljs-number">2</span></span>*Pi &lt;/param&gt; public static double Sin_1(double x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.9999997192673006</span></span> * x - <span class="hljs-number"><span class="hljs-number">0.1666657564532464</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">Math</span></span>.Pow(x, <span class="hljs-number"><span class="hljs-number">3</span></span>) + <span class="hljs-number"><span class="hljs-number">0.008332803647181511</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">Math</span></span>.Pow(x, <span class="hljs-number"><span class="hljs-number">5</span></span>) - <span class="hljs-number"><span class="hljs-number">0.00019830197237204295</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">Math</span></span>.Pow(x, <span class="hljs-number"><span class="hljs-number">7</span></span>) + <span class="hljs-number"><span class="hljs-number">2.7444305061093514</span></span>e-<span class="hljs-number"><span class="hljs-number">6</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">Math</span></span>.Pow(x, <span class="hljs-number"><span class="hljs-number">9</span></span>) - <span class="hljs-number"><span class="hljs-number">2.442176561869478</span></span>e-<span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">Math</span></span>.Pow(x, <span class="hljs-number"><span class="hljs-number">11</span></span>) + <span class="hljs-number"><span class="hljs-number">1.407555708887347</span></span>e-<span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">Math</span></span>.Pow(x, <span class="hljs-number"><span class="hljs-number">13</span></span>) - <span class="hljs-number"><span class="hljs-number">4.240664814288337</span></span>e-<span class="hljs-number"><span class="hljs-number">13</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">Math</span></span>.Pow(x, <span class="hljs-number"><span class="hljs-number">15</span></span>); }</code> </pre><br></div></div><br>  <i><b>Vista superior:</b></i> <br><br><div class="spoiler">  <b class="spoiler_title">Sin_0 (rad)</b> <div class="spoiler_text"><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;summary&gt;  ( Math): <span class="hljs-number"><span class="hljs-number">83</span></span>% (fps)&lt;<span class="hljs-regexp"><span class="hljs-regexp">/summary&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;param name=<span class="hljs-string"><span class="hljs-string">"rad"</span></span>&gt;     -<span class="hljs-number"><span class="hljs-number">2</span></span>*Pi  <span class="hljs-number"><span class="hljs-number">2</span></span>*Pi &lt;<span class="hljs-regexp"><span class="hljs-regexp">/param&gt; public static double Sin_0(double rad) { double x; double xx; double ret; xx = rad * rad; x = rad; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/1 ret = 0.9999997192673006 * x; x *= xx; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/3 ret -= 0.1666657564532464 * x; x *= xx; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/5 ret += 0.008332803647181511 * x; x *= xx; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/7 ret -= 0.00019830197237204295 * x; x *= xx; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/9 ret += 2.7444305061093514e-6 * x; x *= xx; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/11 ret -= 2.442176561869478e-8 * x; x *= xx; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/13 ret += 1.407555708887347e-10 * x; x *= xx; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/15 ret -= 4.240664814288337e-13 * x; return ret; }</span></span></code> </pre><br></div></div><br><h3>  Interpolação linear </h3><br>  Este método é baseado na interpolação linear entre os resultados de dois registros em uma matriz. <br>  As entradas são divididas em mem_sin e mem_cos, elas contêm os resultados pré-calculados da função padrão Math.Sin e Math.Cos em um segmento de parâmetros de entrada de 0 a 0,25 * PI. <br><br>  O princípio das manipulações com um ângulo de 0 a 45 graus não difere da versão aprimorada da série Taylor, mas ao mesmo tempo é chamada uma função que encontra - entre os quais dois registros existe um ângulo - e encontra um valor entre eles. <br><br>  Prós: <br><br><ul><li><div class="spoiler">  <b class="spoiler_title">Alta velocidade (65%)</b> <div class="spoiler_text">  Devido à simplicidade do algoritmo de interpolação, a velocidade atinge 65% da velocidade do Math.Sin.  Eu acho que a velocidade&gt; 33% é satisfatória. <br></div></div></li><li><div class="spoiler">  <b class="spoiler_title">Maior precisão</b> <div class="spoiler_text">  Um exemplo de um caso raro de rejeição: <br>  0,255835595715180 - Math.Sin; <br>  0.2558355957151 <b>79</b> - <b>Sin_3</b> . <br></div></div></li><li><div class="spoiler">  <b class="spoiler_title">Pé rápido</b> <div class="spoiler_text">  Adoro essa função porque nasceu em agonia, escrita por mim e excedeu os requisitos: velocidade&gt; 33%, precisão acima de 1e-14.  Vou dar a ela um nome orgulhoso - Vēlōx Pes. <br></div></div></li></ul><br>  Contras: <br><br><ul><li><div class="spoiler">  <b class="spoiler_title">Requer um lugar na memória</b> <div class="spoiler_text">  Para trabalhar, você deve primeiro calcular duas matrizes: para sin e para cos;  cada matriz pesa ~ 16mb (16 * 2 = 32mb) <br></div></div></li></ul><br>  <i><b>Visualização original:</b></i> <br><br><div class="spoiler">  <b class="spoiler_title">Sin_3 (rad)</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Math_d { const <span class="hljs-type"><span class="hljs-type">double</span></span> PI025 = Math.PI / <span class="hljs-number"><span class="hljs-number">4</span></span>; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>^<span class="hljs-number"><span class="hljs-number">17</span></span> = <span class="hljs-number"><span class="hljs-number">131072</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span> ),   <span class="hljs-number"><span class="hljs-number">10000</span></span> ( ),  <span class="hljs-number"><span class="hljs-number">2</span></span>^<span class="hljs-number"><span class="hljs-number">21</span></span> = <span class="hljs-number"><span class="hljs-number">22097152</span></span> (<span class="hljs-number"><span class="hljs-number">16</span></span> )   +<span class="hljs-number"><span class="hljs-number">-1</span></span> ( ) (  ) &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; const <span class="hljs-type"><span class="hljs-type">int</span></span> length_mem = <span class="hljs-number"><span class="hljs-number">22097152</span></span>; const <span class="hljs-type"><span class="hljs-type">int</span></span> length_mem_M1 = length_mem - <span class="hljs-number"><span class="hljs-number">1</span></span>; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;    sin,    . &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; static <span class="hljs-type"><span class="hljs-type">double</span></span>[] mem_sin; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;    cos,    . &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; static <span class="hljs-type"><span class="hljs-type">double</span></span>[] mem_cos; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;  ,   sin,    . &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> Initialise() { Ini_Mem_Sin(); Ini_Mem_Cos(); } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;       Cos,   . &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="rad"&gt;&lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">double</span></span> Sin_3(<span class="hljs-type"><span class="hljs-type">double</span></span> rad) { <span class="hljs-type"><span class="hljs-type">double</span></span> rad_025; <span class="hljs-type"><span class="hljs-type">int</span></span> i; //    //<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rad &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { rad = -rad + Math.PI; } i = (<span class="hljs-type"><span class="hljs-type">int</span></span>)(rad / PI025); //   rad_025 = rad - PI025 * i; //     ( ) i = i &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>; //      <span class="hljs-number"><span class="hljs-number">8</span></span> //    switch (i) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Sin_Lerp(rad_025); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Cos_Lerp(PI025 - rad_025); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Cos_Lerp(rad_025); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Sin_Lerp(PI025 - rad_025); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -Sin_Lerp(rad_025); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -Cos_Lerp(PI025 - rad_025); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -Cos_Lerp(rad_025); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -Sin_Lerp(PI025 - rad_025); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;   sin    &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; static <span class="hljs-type"><span class="hljs-type">void</span></span> Ini_Mem_Sin() { <span class="hljs-type"><span class="hljs-type">double</span></span> rad; mem_sin = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span>[length_mem]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length_mem; i++) { rad = (i * PI025) / length_mem_M1; mem_sin[i] = Math.Sin(rad); } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;   cos    &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; static <span class="hljs-type"><span class="hljs-type">void</span></span> Ini_Mem_Cos() { <span class="hljs-type"><span class="hljs-type">double</span></span> rad; mem_cos = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">double</span></span>[length_mem]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length_mem; i++) { rad = (i * PI025) / length_mem_M1; mem_cos[i] = Math.Cos(rad); } } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;      sin  <span class="hljs-number"><span class="hljs-number">0</span></span>  pi/<span class="hljs-number"><span class="hljs-number">4.</span></span> &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="rad"&gt;     <span class="hljs-number"><span class="hljs-number">0</span></span>  pi/<span class="hljs-number"><span class="hljs-number">4.</span></span> &lt;/param&gt; static <span class="hljs-type"><span class="hljs-type">double</span></span> Sin_Lerp(<span class="hljs-type"><span class="hljs-type">double</span></span> rad) { <span class="hljs-type"><span class="hljs-type">int</span></span> i_0; <span class="hljs-type"><span class="hljs-type">int</span></span> i_1; <span class="hljs-type"><span class="hljs-type">double</span></span> i_0d; <span class="hljs-type"><span class="hljs-type">double</span></span> percent; <span class="hljs-type"><span class="hljs-type">double</span></span> a; <span class="hljs-type"><span class="hljs-type">double</span></span> b; <span class="hljs-type"><span class="hljs-type">double</span></span> s; percent = rad / PI025; i_0d = percent * length_mem_M1; i_0 = (<span class="hljs-type"><span class="hljs-type">int</span></span>)i_0d; i_1 = i_0 + <span class="hljs-number"><span class="hljs-number">1</span></span>; a = mem_sin[i_0]; b = mem_sin[i_1]; s = i_0d - i_0; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lerp(a, b, s); } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;      cos  <span class="hljs-number"><span class="hljs-number">0</span></span>  pi/<span class="hljs-number"><span class="hljs-number">4.</span></span> &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="rad"&gt;     <span class="hljs-number"><span class="hljs-number">0</span></span>  pi/<span class="hljs-number"><span class="hljs-number">4.</span></span> &lt;/param&gt; static <span class="hljs-type"><span class="hljs-type">double</span></span> Cos_Lerp(<span class="hljs-type"><span class="hljs-type">double</span></span> rad) { <span class="hljs-type"><span class="hljs-type">int</span></span> i_0; <span class="hljs-type"><span class="hljs-type">int</span></span> i_1; <span class="hljs-type"><span class="hljs-type">double</span></span> i_0d; <span class="hljs-type"><span class="hljs-type">double</span></span> percent; <span class="hljs-type"><span class="hljs-type">double</span></span> a; <span class="hljs-type"><span class="hljs-type">double</span></span> b; <span class="hljs-type"><span class="hljs-type">double</span></span> s; percent = rad / PI025; i_0d = percent * length_mem_M1; i_0 = (<span class="hljs-type"><span class="hljs-type">int</span></span>)i_0d; i_1 = i_0 + <span class="hljs-number"><span class="hljs-number">1</span></span>; a = mem_cos[i_0]; b = mem_cos[i_1]; s = i_0d - i_0; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lerp(a, b, s); } /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt;      . (<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + s * (b - a)) &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="a"&gt;  . &lt;/param&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="b"&gt;  . &lt;/param&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="s"&gt;  . <span class="hljs-number"><span class="hljs-number">0</span></span> = a, <span class="hljs-number"><span class="hljs-number">1</span></span> = b, <span class="hljs-number"><span class="hljs-number">0.5</span></span> =   a  b. &lt;/param&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">double</span></span> Lerp(<span class="hljs-type"><span class="hljs-type">double</span></span> a, <span class="hljs-type"><span class="hljs-type">double</span></span> b, <span class="hljs-type"><span class="hljs-type">double</span></span> s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + s * (b - a); } }</code> </pre><br></div></div><br><br>  <u>UPD: Corrigido erro na determinação do índice em Sin_Lerp (), Cos_Lerp (), Ini_Mem_Sin () e Ini_Mem_Cos ().</u> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426355/">https://habr.com/ru/post/pt426355/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426343/index.html">Regras de comportamento cavalheiresco em TI: a história do ITIL</a></li>
<li><a href="../pt426345/index.html">Enigmas interessantes de entrevistas técnicas</a></li>
<li><a href="../pt426347/index.html">ITMO University Digest: Novos Estudos, Experiência de Alumni e Projetos Internacionais</a></li>
<li><a href="../pt426349/index.html">Criamos uma estação de rádio na Internet simples, compacta e barata</a></li>
<li><a href="../pt426351/index.html">Alterações nas certificações e exames da Microsoft</a></li>
<li><a href="../pt426357/index.html">Unity & Vive: Tutorial</a></li>
<li><a href="../pt426359/index.html">Iniciativa antipirataria Yandex não aprovada pelos detentores de direitos autorais</a></li>
<li><a href="../pt426361/index.html">Sobre a maravilha da abelha e como a matamos</a></li>
<li><a href="../pt426363/index.html">Fatos e hipóteses sobre o acidente "Union MS-10"</a></li>
<li><a href="../pt426365/index.html">Não confie no Facebook é tarde demais</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>