<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî¶ ü§öüèΩ üëºüèΩ Erstellen von Kunst mit DCGAN unter Keras ü§§ üêº üïäÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag. Vor sechs Monaten begann ich maschinelles Lernen zu studieren, absolvierte einige Kurse und sammelte einige Erfahrungen damit. Als ich dann...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen von Kunst mit DCGAN unter Keras</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431614/"><p>  Guten Tag.  Vor sechs Monaten begann ich maschinelles Lernen zu studieren, absolvierte einige Kurse und sammelte einige Erfahrungen damit.  Als ich dann alle m√∂glichen Neuigkeiten dar√ºber sah, welche neuronalen Netze cool sind und viel bewirken k√∂nnen, beschloss ich, sie zu studieren.  Ich fing an, das Buch von Nikolenko √ºber tiefes Lernen zu lesen, und kam im Verlauf des Lesens auf mehrere Ideen (die f√ºr die Welt nicht neu sind, aber f√ºr mich von gro√üem Interesse waren), von denen eine darin besteht, ein neuronales Netzwerk zu schaffen, das Kunst f√ºr mich erzeugt, die nicht cool erscheint nur f√ºr mich, den "Vater des Zeichenkindes", aber auch f√ºr andere Menschen.  In diesem Artikel werde ich versuchen, den Weg zu beschreiben, den ich gegangen bin, um die ersten Ergebnisse zu erzielen, die mich zufrieden stellen. </p><a name="habracut"></a><br><h4>  Datenerfassung </h4><br><p>  Als ich das Kapitel √ºber wettbewerbsf√§hige Netzwerke las, wurde mir klar, dass ich jetzt etwas schreiben kann. <br>  Eine der ersten Aufgaben bestand darin, einen Webseiten-Parser zu schreiben, um den Datensatz zu erfassen.  Daf√ºr war die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikiart-</a> Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">perfekt</a> , sie hat eine gro√üe Anzahl von Gem√§lden und alle sind nach Stil gesammelt.  Dies war mein erster Parser, also schrieb ich ihn f√ºr 4-5 Tage, von denen die ersten 3 auf einem v√∂llig falschen Weg stie√üen.  Der richtige Weg war, auf die Registerkarte Netzwerk im Quellcode der Seite zu gehen und zu verfolgen, wie die Bilder angezeigt werden, wenn Sie auf die Schaltfl√§che "Mehr" klicken.  F√ºr die gleichen Anf√§nger wie mich ist es eigentlich gut, den Code zu zeigen. </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.misc <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> imresize, imsave <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> matplotlib.image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> imread <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bs4 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BeautifulSoup <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> itertools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> count <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob</code> </pre> <br><p>  In der ersten Jupiter-Zelle habe ich die erforderlichen Bibliotheken importiert. </p><br><ul><li>  glob - Eine praktische Sache, um eine Liste von Dateien in einem Verzeichnis zu erhalten </li><li>  Anfragen, BeautifulSoup - Schnurrbart zum Parsen </li><li>  json - eine Bibliothek zum Abrufen eines W√∂rterbuchs, das zur√ºckgegeben wird, wenn Sie auf einer Site auf die Schaltfl√§che "Mehr" klicken </li><li>  Gr√∂√üe √§ndern, speichern, imreaden - zum Lesen und Vorbereiten von Bildern. </li></ul><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_page</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(style, pagenum)</span></span></span><span class="hljs-function">:</span></span> page = requests.get(url1 + style + url2 + str(pagenum) + url3) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> page <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_soup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(page)</span></span></span><span class="hljs-function">:</span></span> soup = BeautifulSoup(page.text, <span class="hljs-string"><span class="hljs-string">'html5lib'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> soup <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_dir</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name, s)</span></span></span><span class="hljs-function">:</span></span> path = os.getcwd() + <span class="hljs-string"><span class="hljs-string">'/'</span></span> + s + <span class="hljs-string"><span class="hljs-string">'/'</span></span> + name os.mkdir(path)</code> </pre> <br><p>  Ich beschreibe die Funktionen f√ºr eine bequeme Bedienung. </p><br><p>  Die erste - erh√§lt eine Seite in Form von Text, die zweite macht diesen Text bequemer f√ºr die Arbeit.  Nun, der dritte besteht darin, die erforderlichen Ordner nach Stil zu erstellen. </p><br><pre> <code class="python hljs">styles = [<span class="hljs-string"><span class="hljs-string">'kubizm'</span></span>] url1 = <span class="hljs-string"><span class="hljs-string">'https://www.wikiart.org/ru/paintings-by-style/'</span></span> url2 = <span class="hljs-string"><span class="hljs-string">'?select=featured&amp;json=2&amp;layout=new&amp;page='</span></span> url3 = <span class="hljs-string"><span class="hljs-string">'&amp;resultType=masonry'</span></span></code> </pre> <br><p>  Im Styles-Array h√§tte es eigentlich mehrere Stile geben sollen, aber es kam vor, dass ich sie v√∂llig ungleichm√§√üig heruntergeladen habe. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> style <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> styles: make_dir(style, <span class="hljs-string"><span class="hljs-string">'images'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> style <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> styles: make_dir(style, <span class="hljs-string"><span class="hljs-string">'new256_images'</span></span>)</code> </pre> <br><p>  Erstellen Sie die erforderlichen Ordner.  Im zweiten Zyklus werden Ordner erstellt, in denen das Bild gespeichert und auf ein Quadrat von 256 x 256 reduziert wird. </p><br><p>  (Zuerst dachte ich dar√ºber nach, die Gr√∂√üe der Bilder irgendwie nicht zu normalisieren, damit es nicht zu Verzerrungen kommt, aber mir wurde klar, dass dies entweder unm√∂glich oder zu schwierig f√ºr mich war.) </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> style <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> styles: path = os.getcwd() + <span class="hljs-string"><span class="hljs-string">'\\images\\'</span></span> + style + <span class="hljs-string"><span class="hljs-string">'\\'</span></span> images = [] names = [] titles = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pagenum <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> count(start=<span class="hljs-number"><span class="hljs-number">1</span></span>): page = get_page(style, pagenum) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> page.text[<span class="hljs-number"><span class="hljs-number">0</span></span>]!=<span class="hljs-string"><span class="hljs-string">'{'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> jsons = json.loads(page.text) paintings = jsons[<span class="hljs-string"><span class="hljs-string">'Paintings'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> paintings <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> paintings: images_temp = [] images_dict = item[<span class="hljs-string"><span class="hljs-string">'images'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> images_dict <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: images_temp.append(item[<span class="hljs-string"><span class="hljs-string">'image'</span></span>]) names.append(item[<span class="hljs-string"><span class="hljs-string">'artistName'</span></span>]) titles.append(item[<span class="hljs-string"><span class="hljs-string">'title'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> inner_item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> item[<span class="hljs-string"><span class="hljs-string">'images'</span></span>]: images_temp.append(inner_item[<span class="hljs-string"><span class="hljs-string">'image'</span></span>]) names.append(item[<span class="hljs-string"><span class="hljs-string">'artistName'</span></span>]) titles.append(item[<span class="hljs-string"><span class="hljs-string">'title'</span></span>]) images.append(images_temp) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> char <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-string"><span class="hljs-string">'/'</span></span>,<span class="hljs-string"><span class="hljs-string">'\\'</span></span>,<span class="hljs-string"><span class="hljs-string">'"'</span></span>, <span class="hljs-string"><span class="hljs-string">'?'</span></span>, <span class="hljs-string"><span class="hljs-string">':'</span></span>,<span class="hljs-string"><span class="hljs-string">'*'</span></span>,<span class="hljs-string"><span class="hljs-string">'|'</span></span>,<span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>,<span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>]: titles = [title.replace(char, <span class="hljs-string"><span class="hljs-string">' '</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> titles] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> listimg, name, title <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(images, names, titles): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(name) &gt; <span class="hljs-number"><span class="hljs-number">30</span></span>: name = name[:<span class="hljs-number"><span class="hljs-number">25</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(title) &gt; <span class="hljs-number"><span class="hljs-number">50</span></span>: title = title[:<span class="hljs-number"><span class="hljs-number">50</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(listimg) == <span class="hljs-number"><span class="hljs-number">1</span></span>: response = requests.get(listimg[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> response.status_code == <span class="hljs-number"><span class="hljs-number">200</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path + name + <span class="hljs-string"><span class="hljs-string">' '</span></span> + title + <span class="hljs-string"><span class="hljs-string">'.png'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: f.write(response.content) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">'Error from server'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, img <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(listimg): response = requests.get(img) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> response.status_code == <span class="hljs-number"><span class="hljs-number">200</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path + name + <span class="hljs-string"><span class="hljs-string">' '</span></span> + title + str(i) + <span class="hljs-string"><span class="hljs-string">'.png'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: f.write(response.content) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">'Error from server'</span></span>)</code> </pre> <br><p>  Hier werden die Bilder heruntergeladen und im gew√ºnschten Ordner gespeichert.  Hier √§ndern die Bilder ihre Gr√∂√üe nicht, die Originale werden gespeichert. </p><br><p>  Interessante Dinge passieren in der ersten verschachtelten Schleife: </p><br><p>  Ich habe mich entschlossen, dumm st√§ndig json's zu fragen (json ist das W√∂rterbuch, das der Server zur√ºckgibt, wenn Sie auf die Schaltfl√§che "Mehr" klicken. Das W√∂rterbuch enth√§lt alle Informationen zu den Bildern) und anzuhalten, wenn der Server etwas Unscharfes zur√ºckgibt, das nicht den typischen Werten entspricht .  In diesem Fall sollte das erste Zeichen des zur√ºckgegebenen Textes eine √∂ffnende geschweifte Klammer sein, nach der der Hauptteil des W√∂rterbuchs folgt. </p><br><p>  Es wurde auch festgestellt, dass der Server so etwas wie ein Fotoalbum zur√ºckgeben kann.  Das ist im Wesentlichen eine Reihe von Gem√§lden.  Zuerst dachte ich, dass einzelne Bilder zur√ºckkehren w√ºrden, der Name der K√ºnstler zu ihnen, oder vielleicht so, dass sofort mit einem Namen des K√ºnstlers eine Reihe von Gem√§lden gegeben wird. </p><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> style <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> styles: directory = os.getcwd() + <span class="hljs-string"><span class="hljs-string">'\\images\\'</span></span> + style + <span class="hljs-string"><span class="hljs-string">'\\'</span></span> new_dir = os.getcwd() + <span class="hljs-string"><span class="hljs-string">'\\new256_images\\'</span></span> + style + <span class="hljs-string"><span class="hljs-string">'\\'</span></span> filepaths = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> dir_, _, files <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> os.walk(directory): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> fileName <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> files: <span class="hljs-comment"><span class="hljs-comment">#relDir = os.path.relpath(dir_, directory) #relFile = os.path.join(relDir, fileName) relFile = fileName #print(directory) #print(relFile) filepaths.append(relFile) #print(filepaths[-1]) print(filepaths[0]) for i, fp in enumerate(filepaths): img = imread(directory + fp, 0) #/ 255.0 img = imresize(img, (256, 256)) imsave(new_dir + str(i) + ".png", img)</span></span></code> </pre> <br><p>  Hier werden die Bilder in der Gr√∂√üe ge√§ndert und in dem daf√ºr vorbereiteten Ordner gespeichert. </p><br><p>  Nun, der Datensatz ist zusammengestellt, Sie k√∂nnen mit dem interessantesten fortfahren! </p><br><h4>  Klein anfangen </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1r/px/pn/1rpxpnwyuxkpd6aufijfe5lqoek.png"></div><br><p>  Nachdem ich den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalartikel</a> gelesen hatte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> fing ich an zu kreieren!  Aber was war meine Entt√§uschung, als nichts Gutes herauskam?  Bei diesen Versuchen habe ich das Netzwerk auf den gleichen Bildstil trainiert, aber selbst das hat nicht geklappt. Deshalb habe ich beschlossen, zu lernen, wie man aus dem Multiplikator Zahlen generiert.  Ich werde hier nicht im Detail darauf eingehen, ich werde nur √ºber die Architektur und den Wendepunkt sprechen, dank dessen Zahlen zu generieren begannen. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build_generator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> model = Sequential() model.add(Dense(<span class="hljs-number"><span class="hljs-number">128</span></span> * <span class="hljs-number"><span class="hljs-number">7</span></span> * <span class="hljs-number"><span class="hljs-number">7</span></span>, input_dim = latent_dim)) model.add(BatchNormalization()) model.add(LeakyReLU()) model.add(Reshape((<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>))) model.add(Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">64</span></span>, filter_size, strides=(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU()) model.add(Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">32</span></span>, filter_size, strides=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU()) model.add(Conv2DTranspose(img_channels, filter_size, strides=(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)) model.add(Activation(<span class="hljs-string"><span class="hljs-string">"tanh"</span></span>)) model.summary() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model</code> </pre> <br><ul><li><p>  latent_dim - ein Array von 100 zuf√§llig generierten Zahlen. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build_discriminator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> model = Sequential() model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">64</span></span>, kernel_size=filter_size, strides = (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), input_shape=img_shape, padding=<span class="hljs-string"><span class="hljs-string">"same"</span></span>)) model.add(LeakyReLU(alpha=<span class="hljs-number"><span class="hljs-number">0.2</span></span>)) model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.25</span></span>)) model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">128</span></span>, kernel_size=filter_size, strides = (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">"same"</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU(alpha=<span class="hljs-number"><span class="hljs-number">0.2</span></span>)) model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.25</span></span>)) model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">128</span></span>, kernel_size=filter_size, strides = (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">"same"</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU(alpha=<span class="hljs-number"><span class="hljs-number">0.2</span></span>)) model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.25</span></span>)) model.add(Flatten()) model.add(Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>)) model.add(Activation(<span class="hljs-string"><span class="hljs-string">'sigmoid'</span></span>)) model.summary() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model</code> </pre> <br><p>  Das hei√üt, insgesamt sind die Ausgabegr√∂√üen der Faltungsschichten und die Anzahl der Schichten im Allgemeinen geringer als im Originalartikel.  28x28 weil ich generiere, keine Innenr√§ume! </p><br></li></ul><br><p>  Nun, der Trick, aufgrund dessen alles geklappt hat - bei der geraden Iteration des Trainings betrachtete der Diskriminator die erzeugten Bilder und bei der ungeraden Iteration - die realen. </p><br><p>  Das ist es im Grunde.  Ein √§hnliches DCGAN lernte sehr schnell, zum Beispiel wurde das Bild zu Beginn dieses Unterthemas im 19. Jahrhundert erhalten, </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oh/xw/6j/ohxw6jdykdplojjc6lku6e-mm40.png"></div><br><p>  Diese sind bereits zuversichtlich, aber manchmal keine reellen Zahlen, wie sich in der 99. √Ñra der Bildung herausstellte. </p><br><p>  Zufrieden mit dem vorl√§ufigen Ergebnis h√∂rte ich auf zu lernen und begann dar√ºber nachzudenken, wie ich das Hauptproblem l√∂sen k√∂nnte. </p><br><h4>  Kreatives gegnerisches Netzwerk </h4><br><p>  Der n√§chste Schritt bestand darin, √ºber das GAN mit Beschriftungen zu lesen: Die Klasse des aktuellen Bildes wird dem Diskriminator und Generator bereitgestellt.  Und nach dem Gan mit Labels habe ich etwas √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CAN herausgefunden</a> - die Dekodierung erfolgt im Grunde genommen im Namen des Unterthemas. </p><br><p>  In CAN versucht der Diskriminator, die Klasse des Bildes zu erraten, wenn das Bild aus einer realen Menge stammt.  Und dementsprechend erh√§lt der Diskriminator im Fall des Trainings in einem realen Bild zus√§tzlich zum Standard einen Fehler, wenn er die Klasse als Fehler err√§t. </p><br><p>  Beim Training in einem erzeugten Bild muss der Diskriminator nur vorhersagen, ob dieses Bild real ist oder nicht. </p><br><p>  Der Generator muss au√üerdem, nur um den Diskriminator auszutricksen, den Diskriminator beim Erraten der Bildklasse ratlos machen, dh der Generator wird daran interessiert sein, dass die Ausgaben an die Diskriminatoren so weit wie m√∂glich von 1 vollem Vertrauen entfernt sind. </p><br><p>  Als ich mich an CAN wandte, hatte ich erneut Schwierigkeiten, Demoral aufgrund der Tatsache, dass nichts funktioniert und nicht lernt.  Nach mehreren unangenehmen Fehlern habe ich mich entschlossen, von vorne zu beginnen und alle √Ñnderungen (Ja, das habe ich vorher noch nicht getan), Gewichte und Architektur (um das Training zu unterbrechen) zu speichern. </p><br><p>  Zuerst wollte ich ein Netzwerk erstellen, das f√ºr mich ein einzelnes 256x256-Bild (alle folgenden Bilder dieser Gr√∂√üe) ohne Beschriftung generiert.  Der Wendepunkt hier war, dass im Gegenteil bei jeder Iteration des Trainings dem Diskriminator ein Blick auf die erzeugten und die realen Bilder gegeben werden sollte. </p><br><img src="https://habrastorage.org/webt/gd/ea/xd/gdeaxdnz-zmlb3odvcyb-0qr5nk.png"><br><p>  Dies ist das Ergebnis, bei dem ich angehalten habe und mit dem n√§chsten Schritt fortgefahren bin.  Ja, die Farben unterscheiden sich vom tats√§chlichen Bild, aber ich war mehr an der F√§higkeit des Netzwerks interessiert, Konturen und Objekte hervorzuheben.  Sie kam damit klar. </p><br><p>  Dann k√∂nnten wir zur Hauptaufgabe √ºbergehen - Kunst erzeugen.  Pr√§sentieren Sie den Code sofort und kommentieren Sie ihn auf dem Weg. </p><br><p>  Zun√§chst m√ºssen Sie wie immer alle Bibliotheken importieren. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.preprocessing.image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> array_to_img, img_to_array, load_img <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> date <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tf <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> argparse <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> matplotlib.image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> imread <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.misc.pilutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> imresize, imsave <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cv2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> keras <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Sequential, Model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.layers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dense, Activation, Reshape, Flatten, Dropout, Input <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.layers.convolutional <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Conv2D, Conv2DTranspose, MaxPooling2D <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.layers.normalization <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BatchNormalization <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.layers.advanced_activations <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LeakyReLU <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.optimizers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Adam, SGD <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras.datasets <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mnist <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> keras <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> initializers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random</code> </pre> <br><p>  Generator erstellen. </p><br><p>  Die Ausgabe der Ebenen unterscheidet sich wiederum vom Artikel.  Irgendwo, um Speicherplatz zu sparen (Bedingungen: ein Heimcomputer mit gtx970), und irgendwo wegen des Erfolgs bei der Konfiguration </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build_generator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> model = Sequential() model.add(Dense(<span class="hljs-number"><span class="hljs-number">128</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span> * <span class="hljs-number"><span class="hljs-number">8</span></span>, input_dim = latent_dim)) model.add(BatchNormalization()) model.add(LeakyReLU()) model.add(Reshape((<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>))) model.add(Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">512</span></span>, filter_size_g, strides=(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU()) model.add(Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">512</span></span>, filter_size_g, strides=(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU()) model.add(Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">256</span></span>, filter_size_g, strides=(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU()) model.add(Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">128</span></span>, filter_size_g, strides=(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU()) model.add(Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">64</span></span>, filter_size_g, strides=(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU()) model.add(Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">32</span></span>, filter_size_g, strides=(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU()) model.add(Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">16</span></span>, filter_size_g, strides=(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU()) model.add(Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">8</span></span>, filter_size_g, strides=(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU()) model.add(Conv2DTranspose(img_channels, filter_size_g, strides=(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)) model.add(Activation(<span class="hljs-string"><span class="hljs-string">"tanh"</span></span>)) model.summary() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model</code> </pre> <br><p>  Die Diskriminatorerstellungsfunktion gibt zwei Modelle zur√ºck, von denen eines versucht herauszufinden, ob das Bild echt ist, und das andere versucht, die Klasse des Bildes herauszufinden. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build_discriminator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num_classes)</span></span></span><span class="hljs-function">:</span></span> model = Sequential() model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">64</span></span>, kernel_size=filter_size_d, strides = (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), input_shape=img_shape, padding=<span class="hljs-string"><span class="hljs-string">"same"</span></span>)) model.add(LeakyReLU(alpha=<span class="hljs-number"><span class="hljs-number">0.2</span></span>)) model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.25</span></span>)) model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">128</span></span>, kernel_size=filter_size_d, strides = (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">"same"</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU(alpha=<span class="hljs-number"><span class="hljs-number">0.2</span></span>)) model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.25</span></span>)) model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">256</span></span>, kernel_size=filter_size_d, strides = (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">"same"</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU(alpha=<span class="hljs-number"><span class="hljs-number">0.2</span></span>)) model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.25</span></span>)) model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">512</span></span>, kernel_size=filter_size_d, strides = (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">"same"</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU(alpha=<span class="hljs-number"><span class="hljs-number">0.2</span></span>)) model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.25</span></span>)) model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">512</span></span>, kernel_size=filter_size_d, strides = (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">"same"</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU(alpha=<span class="hljs-number"><span class="hljs-number">0.2</span></span>)) model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.25</span></span>)) model.add(Conv2D(<span class="hljs-number"><span class="hljs-number">512</span></span>, kernel_size=filter_size_d, strides = (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), padding=<span class="hljs-string"><span class="hljs-string">"same"</span></span>)) model.add(BatchNormalization(momentum=<span class="hljs-number"><span class="hljs-number">0.8</span></span>)) model.add(LeakyReLU(alpha=<span class="hljs-number"><span class="hljs-number">0.2</span></span>)) model.add(Dropout(<span class="hljs-number"><span class="hljs-number">0.25</span></span>)) model.add(Flatten()) model.summary() img = Input(shape=img_shape) features = model(img) validity = Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>)(features) valid = Activation(<span class="hljs-string"><span class="hljs-string">'sigmoid'</span></span>)(validity) label1 = Dense(<span class="hljs-number"><span class="hljs-number">1024</span></span>)(features) lrelu1 = LeakyReLU(alpha=<span class="hljs-number"><span class="hljs-number">0.2</span></span>)(label1) label2 = Dense(<span class="hljs-number"><span class="hljs-number">512</span></span>)(label1) lrelu2 = LeakyReLU(alpha=<span class="hljs-number"><span class="hljs-number">0.2</span></span>)(label2) label3 = Dense(num_classes)(label2) label = Activation(<span class="hljs-string"><span class="hljs-string">'softmax'</span></span>)(label3) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Model(img, valid), Model(img, label)</code> </pre> <br><p>  Funktion zur Schaffung eines Wettbewerbsmodells.  In einem Wettbewerbsmodell wird der Diskriminator nicht trainiert. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generator_containing_discriminator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(g, d, d_label)</span></span></span><span class="hljs-function">:</span></span> noise = Input(shape=(latent_dim,)) img = g(noise) d.trainable = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> d_label.trainable = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> valid, target_label = d(img), d_label(img) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Model(noise, [valid, target_label])</code> </pre> <br><p>  Funktion zum Herunterladen eines Stapels mit echten Bildern und Etiketten.  Daten - Ein Array von Adressen, die sp√§ter definiert werden.  In der gleichen Funktion wird das Bild normalisiert. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_images_classes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(batch_size, data)</span></span></span><span class="hljs-function">:</span></span> X_train = np.zeros((batch_size, img_rows, img_cols, img_channels)) y_labels = np.zeros(batch_size) choice_arr = np.random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(data), batch_size) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(batch_size): rand_number = np.random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(data[choice_arr[i]])) temp_img = cv2.imread(data[choice_arr[i]][rand_number]) X_train[i] = temp_img y_labels[i] = choice_arr[i] X_train = (X_train - <span class="hljs-number"><span class="hljs-number">127.5</span></span>)/<span class="hljs-number"><span class="hljs-number">127.5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X_train, y_labels</code> </pre> <br><p>  Funktion f√ºr sch√∂ne Ausgabe des Bildstapels.  Tats√§chlich wurden alle Bilder aus diesem Artikel von dieser Funktion gesammelt. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine_images</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(generated_images)</span></span></span><span class="hljs-function">:</span></span> num = generated_images.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] width = int(math.sqrt(num)) height = int(math.ceil(float(num)/width)) shape = generated_images.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>] image = np.zeros((height*shape[<span class="hljs-number"><span class="hljs-number">0</span></span>], width*shape[<span class="hljs-number"><span class="hljs-number">1</span></span>], img_channels), dtype=generated_images.dtype) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index, img <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(generated_images): i = int(index/width) j = index % width image[i*shape[<span class="hljs-number"><span class="hljs-number">0</span></span>]:(i+<span class="hljs-number"><span class="hljs-number">1</span></span>)*shape[<span class="hljs-number"><span class="hljs-number">0</span></span>], j*shape[<span class="hljs-number"><span class="hljs-number">1</span></span>]:(j+<span class="hljs-number"><span class="hljs-number">1</span></span>)*shape[<span class="hljs-number"><span class="hljs-number">1</span></span>]] = \ img[:, :, :,] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> image</code> </pre> <br><p>  Und hier sind die gleichen Daten.  Es gibt in mehr oder weniger praktischer Form eine Reihe von Bildadressen zur√ºck, die wir oben in Ordnern angeordnet haben </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> styles_folder = os.listdir(path=os.getcwd() + <span class="hljs-string"><span class="hljs-string">"\\new256_images\\"</span></span>) num_styles = len(styles_folder) data = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(num_styles): data.append(glob.glob(os.getcwd() + <span class="hljs-string"><span class="hljs-string">'\\new256_images\\'</span></span> + styles_folder[i] + <span class="hljs-string"><span class="hljs-string">'\\*'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data, num_styles</code> </pre> <br><p>  Um die √Ñra zu √ºberstehen, wurde eine zuf√§llige gro√üe Zahl festgelegt, da sie zu faul war, um die Anzahl aller Bilder zu berechnen.  In der gleichen Funktion wird das Laden von Waagen bereitgestellt, wenn das Training fortgesetzt werden muss.  Alle 5 Epochen bleiben Gewicht und Architektur erhalten. </p><br><p>  Es lohnt sich auch zu schreiben, dass ich versucht habe, den Eingabebildern Rauschen hinzuzuf√ºgen, aber im letzten Training habe ich beschlossen, dies nicht zu tun. <br>  Es werden gegl√§ttete Klassenbezeichnungen verwendet, die das Lernen sehr erleichtern. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">train_another</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(epochs = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span><span class="hljs-function"><span class="hljs-params">, BATCH_SIZE = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">, weights = False, month_day = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, epoch = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> data, num_styles = get_data() generator = build_generator() discriminator, d_label = build_discriminator(num_styles) discriminator.compile(loss=losses[<span class="hljs-number"><span class="hljs-number">0</span></span>], optimizer=d_optim) d_label.compile(loss=losses[<span class="hljs-number"><span class="hljs-number">1</span></span>], optimizer=d_optim) generator.compile(loss=<span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span></span>, optimizer=g_optim) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> month_day != <span class="hljs-string"><span class="hljs-string">''</span></span>: generator.load_weights(os.getcwd() + <span class="hljs-string"><span class="hljs-string">'/'</span></span> + month_day + epoch + <span class="hljs-string"><span class="hljs-string">' gen_weights.h5'</span></span>) discriminator.load_weights(os.getcwd() + <span class="hljs-string"><span class="hljs-string">'/'</span></span> + month_day + epoch + <span class="hljs-string"><span class="hljs-string">' dis_weights.h5'</span></span>) d_label.load_weights(os.getcwd() + <span class="hljs-string"><span class="hljs-string">'/'</span></span> + month_day + epoch + <span class="hljs-string"><span class="hljs-string">' dis_label_weights.h5'</span></span>) dcgan = generator_containing_discriminator(generator, discriminator, d_label) dcgan.compile(loss=losses[<span class="hljs-number"><span class="hljs-number">0</span></span>], optimizer=g_optim) discriminator.trainable = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> d_label.trainable = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> epoch <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(epochs): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(int(<span class="hljs-number"><span class="hljs-number">15000</span></span>/BATCH_SIZE)): noise = np.random.normal(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, (BATCH_SIZE, latent_dim)) real_images, real_labels = get_images_classes(BATCH_SIZE, data) <span class="hljs-comment"><span class="hljs-comment">#real_images += np.random.normal(size = img_shape, scale= 0.1) generated_images = generator.predict(noise) X = real_images real_labels = real_labels - 0.1 + np.random.rand(BATCH_SIZE)*0.2 y_classif = keras.utils.to_categorical(np.zeros(BATCH_SIZE) + real_labels, num_styles) y = 0.8 + np.random.rand(BATCH_SIZE)*0.2 d_loss = [] d_loss.append(discriminator.train_on_batch(X, y)) discriminator.trainable = False d_loss.append(d_label.train_on_batch(X, y_classif)) print("epoch %d batch %d d_loss : %f, label_loss: %f" % (epoch, index, d_loss[0], d_loss[1])) X = generated_images y = np.random.rand(BATCH_SIZE) * 0.2 d_loss = discriminator.train_on_batch(X, y) print("epoch %d batch %d d_loss : %f" % (epoch, index, d_loss)) noise = np.random.normal(0, 1, (BATCH_SIZE, latent_dim)) discriminator.trainable = False d_label.trainable = False y_classif = keras.utils.to_categorical(np.zeros(BATCH_SIZE) + 1/num_styles, num_styles) y = np.random.rand(BATCH_SIZE) * 0.3 g_loss = dcgan.train_on_batch(noise, [y, y_classif]) d_label.trainable = True discriminator.trainable = True print("epoch %d batch %d g_loss : %f, label_loss: %f" % (epoch, index, g_loss[0], g_loss[1])) if index % 50 == 0: image = combine_images(generated_images) image = image*127.5+127.5 cv2.imwrite( os.getcwd() + '\\generated\\epoch%d_%d.png' % (epoch, index), image) image = combine_images(real_images) image = image*127.5+127.5 cv2.imwrite( os.getcwd() + '\\generated\\epoch%d_%d_data.png' % (epoch, index), image) if epoch % 5 == 0: date_today = date.today() month, day = date_today.month, date_today.day #      json d_json = discriminator.to_json() #     json_file = open(os.getcwd() + "/%d.%d dis_model.json" % (day, month), "w") json_file.write(d_json) json_file.close() #      json d_l_json = d_label.to_json() #     json_file = open(os.getcwd() + "/%d.%d dis_label_model.json" % (day, month), "w") json_file.write(d_l_json) json_file.close() #      json gen_json = generator.to_json() #     json_file = open(os.getcwd() + "/%d.%d gen_model.json" % (day, month), "w") json_file.write(gen_json) json_file.close() discriminator.save_weights(os.getcwd() + '/%d.%d %d_epoch dis_weights.h5' % (day, month, epoch)) d_label.save_weights(os.getcwd() + '/%d.%d %d_epoch dis_label_weights.h5' % (day, month, epoch)) generator.save_weights(os.getcwd() + '/%d.%d %d_epoch gen_weights.h5' % (day, month, epoch))</span></span></code> </pre> <br><p>  Initialisieren Sie Variablen und f√ºhren Sie das Training durch.  Aufgrund der geringen "Leistung" meines Computers ist ein Training mit maximal 16 Bildern m√∂glich. </p><br><pre> <code class="python hljs">img_rows = <span class="hljs-number"><span class="hljs-number">256</span></span> img_cols = <span class="hljs-number"><span class="hljs-number">256</span></span> img_channels = <span class="hljs-number"><span class="hljs-number">3</span></span> img_shape = (img_rows, img_cols, img_channels) latent_dim = <span class="hljs-number"><span class="hljs-number">100</span></span> filter_size_g = (<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>) filter_size_d = (<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>) d_strides = (<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) color_mode = <span class="hljs-string"><span class="hljs-string">'rgb'</span></span> losses = [<span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span></span>, <span class="hljs-string"><span class="hljs-string">'categorical_crossentropy'</span></span>] g_optim = Adam(<span class="hljs-number"><span class="hljs-number">0.0002</span></span>, beta_2 = <span class="hljs-number"><span class="hljs-number">0.5</span></span>) d_optim = Adam(<span class="hljs-number"><span class="hljs-number">0.0002</span></span>, beta_2 = <span class="hljs-number"><span class="hljs-number">0.5</span></span>) train_another(<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre> <br><p>  Im Allgemeinen m√∂chte ich lange Zeit einen Beitrag √ºber diese Idee von mir schreiben, jetzt ist nicht die beste Zeit daf√ºr, da dieses Neuron drei Tage lang studiert hat und sich jetzt in der 113. √Ñra befindet, aber heute habe ich interessante Bilder gefunden, also habe ich beschlossen, dass es Zeit ist w√ºrde schon einen Beitrag schreiben! </p><br><img src="https://habrastorage.org/webt/zg/5k/iu/zg5kiuwt0jr-nankjexltegph9a.png"><br><p>  Dies sind die Bilder, die heute herausgekommen sind.  Vielleicht kann ich durch ihre Benennung dem Leser meine pers√∂nliche Wahrnehmung dieser Bilder vermitteln.  Es ist ziemlich auff√§llig, dass das Netzwerk nicht ausreichend trainiert ist (oder m√∂glicherweise √ºberhaupt nicht mit solchen Methoden trainiert wird), insbesondere wenn man bedenkt, dass die Bilder durch Anschreiben aufgenommen wurden, aber heute habe ich ein Ergebnis erhalten, das mir gefallen hat. </p><br><p>  Zuk√ºnftige Pl√§ne sehen eine Umschulung dieser Konfiguration vor, bis klar wird, wozu sie in der Lage ist.  Es ist auch geplant, ein Netzwerk zu schaffen, das diese Bilder auf vern√ºnftige Gr√∂√üen vergr√∂√üert.  Dies wurde bereits erfunden und es gibt Implementierungen. </p><br><p>  Ich w√ºrde mich sehr √ºber konstruktive Kritik, gute Ratschl√§ge und Fragen freuen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431614/">https://habr.com/ru/post/de431614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431602/index.html">Russische Entwickler pr√§sentierten in London ein virtuelles Rehabilitationssystem</a></li>
<li><a href="../de431604/index.html">Lokalisierung in Go mit Basispaketen</a></li>
<li><a href="../de431608/index.html">Das US-Unternehmen DriveSavers ist das weltweit erste Unternehmen, das einen iPhone-Hacking-Service f√ºr Einzelpersonen anbietet</a></li>
<li><a href="../de431610/index.html">Projektmanager Lifehacks</a></li>
<li><a href="../de431612/index.html">Spieluhr und Drehgeber auf FPGA-Karte</a></li>
<li><a href="../de431616/index.html">Einf√ºhrung in benutzerdefinierte CSS-Eigenschaften</a></li>
<li><a href="../de431618/index.html">Harry Potter und die Schwierigkeiten der √úbersetzung: ROSMAN und MAJAON gegen das Original</a></li>
<li><a href="../de431620/index.html">"Ich wurde Therapeut oder Psychologe" - Vitaliy Fridman √ºber UX-Tests und mobile Schnittstellen</a></li>
<li><a href="../de431622/index.html">Sehen Sie Flutter Live at Wrike 4. Dezember</a></li>
<li><a href="../de431624/index.html">Sie m√ºssen nicht Fehler beseitigen, sondern den Grund f√ºr ihr Auftreten: ein Fall von einem Spieleentwickler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>