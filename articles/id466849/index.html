<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏽 👣 🗑️ noexcept-ctcheck atau beberapa macro sederhana untuk membantu kompiler menulis kode noexcept 🌫️ 👨🏽‍🚀 🧘🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika mengembangkan dalam C ++, Anda harus menulis kode dari waktu ke waktu di mana pengecualian tidak boleh terjadi. Sebagai contoh, ketika kita per...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>noexcept-ctcheck atau beberapa macro sederhana untuk membantu kompiler menulis kode noexcept</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466849/"><p>  Ketika mengembangkan dalam C ++, Anda harus menulis kode dari waktu ke waktu di mana pengecualian tidak boleh terjadi.  Sebagai contoh, ketika kita perlu menulis swap bebas pengecualian untuk tipe asli atau mendefinisikan pernyataan pemindahan noexcept untuk kelas kita, atau secara manual mengimplementasikan destruktor nontrivial. </p><br><p>  Dalam C ++ 11, pengubah noexcept ditambahkan ke bahasa, yang memungkinkan pengembang untuk memahami bahwa pengecualian tidak dapat dibuang dari fungsi yang ditandai dengan noexcept.  Oleh karena itu, fungsi dengan tanda seperti itu dapat digunakan dengan aman dalam konteks di mana pengecualian tidak boleh muncul. </p><br><p>  Misalnya, jika saya memiliki jenis dan fungsi ini: </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first_resource</span></span></span><span class="hljs-class"> {</span></span>...}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">second_resource</span></span></span><span class="hljs-class"> {</span></span>...}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first_resource &amp; r)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(second_resource &amp; r)</span></span></span></span>;</code> </pre> <br><p>  dan ada kelas <code>resources_owner</code> tertentu yang memiliki objek seperti <code>first_resource</code> dan <code>second_resource</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resources_owner</span></span></span><span class="hljs-class"> {</span></span> first_resource first_resource_; second_resource second_resource_; ... };</code> </pre> <br><p>  maka saya dapat menulis destructor <code>resources_owner</code> sebagai berikut: </p><br><pre> <code class="cpp hljs">resources_owner::~resources_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  release()   ,    . release(first_resource_); //    close()   ,  //   try-catch. try{ close(second_resource_); } catch(...) {} }</span></span></code> </pre> <br><p>  Di satu sisi, kecuali di C ++ 11 membuat kehidupan seorang pengembang C ++ lebih mudah.  Tetapi implementasi noexcept saat ini di C ++ modern memiliki satu sisi buruk ... </p><br><h1 id="kompilyator-ne-pomogaet-kontrolirovat-soderzhimoe-noexcept-funkciy-i-metodov">  Kompiler tidak membantu mengontrol isi fungsi dan metode noexcept </h1><a name="habracut"></a><br><p>  Misalkan dalam contoh di atas saya salah: untuk beberapa alasan, saya menganggap <code>release()</code> ditandai sebagai noexcept, tetapi pada kenyataannya itu tidak dan dapat melempar pengecualian.  Ini berarti bahwa ketika saya menulis destruktor menggunakan <code>release()</code> pelemparan <code>release()</code> : </p><br><pre> <code class="cpp hljs">resources_owner::~resources_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { release(first_resource_); <span class="hljs-comment"><span class="hljs-comment">//  try-catch   ... }</span></span></code> </pre> <br><p>  maka saya mohon untuk masalah.  Cepat atau lambat, <code>release()</code> ini <code>release()</code> akan melempar pengecualian dan seluruh aplikasi saya akan macet karena secara otomatis disebut <code>std::terminate()</code> .  Akan lebih buruk jika tidak crash aplikasi saya, tetapi orang lain, di mana mereka menggunakan perpustakaan saya dengan destructor yang bermasalah untuk <code>resources_owner</code> . </p><br><p>  Atau variasi lain dari masalah yang sama.  Misalkan saya tidak salah bahwa <code>release()</code> memang ditandai sebagai tidak kecuali.  Itu tadi. </p><br><p>  Itu ditandai dalam versi 1.0 dari perpustakaan pihak ketiga dari mana saya mengambil <code>first_resource</code> dan <code>release()</code> .  Dan kemudian, setelah beberapa tahun, saya memutakhirkan ke versi 3.0 dari perpustakaan ini, tetapi dalam <code>release()</code> versi 3.0 <code>release()</code> tidak lagi memiliki pengubah noexcept. </p><br><p>  Baiklah apa?  Versi utama baru, mereka dapat dengan mudah memecahkan API. </p><br><p>  Hanya sekarang, kemungkinan besar, saya akan lupa untuk memperbaiki implementasi destructor <code>resources_owner</code> .  Dan jika alih-alih saya orang lain terlibat dalam dukungan <code>resource_owner</code> , yang tidak pernah melihat ke destruktor ini, maka perubahan dalam <code>release()</code> tanda tangan mungkin tidak akan diketahui. </p><br><p>  Oleh karena itu, saya pribadi tidak suka fakta bahwa kompiler tidak memperingatkan programmer dengan cara apa pun sehingga programmer di dalam metode / fungsi noexcept membuat panggilan metode / fungsi pengecualian. </p><br><p>  Akan lebih baik jika kompiler akan mengeluarkan peringatan seperti itu. </p><br><h1 id="spasenie-utopayuschih-delo-ruk-samih-utopayuschih">  Penyelamatan tenggelam adalah karya dari diri mereka yang tenggelam </h1><br><p>  OK, kompiler tidak memberikan peringatan apa pun.  Dan tidak ada yang dapat dilakukan tentang pengembang sederhana ini.  Jangan berurusan dengan modifikasi kompiler C ++ untuk kebutuhan Anda sendiri.  Terutama jika Anda harus menggunakan bukan satu kompiler, tetapi versi berbeda dari kompiler C ++ berbeda. </p><br><p>  Apakah mungkin untuk mendapatkan bantuan dari kompiler tanpa masuk ke jeroan ayam itiknya?  Yaitu  Apakah mungkin untuk membuat semacam alat untuk mengontrol isi metode / fungsi noexcept, bahkan jika metode dendro-fecal? </p><br><p>  Kamu bisa.  Ceroboh, tapi mungkin. </p><br><h1 id="otkuda-nogi-rastut">  Dari mana kaki tumbuh? </h1><br><p>  Pendekatan yang dijelaskan dalam artikel ini diuji dalam praktik ketika menyiapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi berikutnya dari server HTTP kecil kami yang tertanam RESTinio</a> . </p><br><p>  Faktanya adalah karena RESTinio dipenuhi dengan fungsionalitas, kami telah kehilangan pandangan tentang masalah keselamatan pengecualian di beberapa tempat.  Secara khusus, dari waktu ke waktu menjadi jelas bahwa pengecualian kadang-kadang dapat terbang keluar dari panggilan balik yang dikirim ke Asio (yang tidak seharusnya), serta pengecualian, pada prinsipnya, dapat terbang keluar saat membersihkan sumber daya. </p><br><p>  Untungnya, dalam praktiknya, masalah-masalah ini tidak pernah terwujud, tetapi hutang teknis telah menumpuk dan sesuatu harus dilakukan untuk mengatasinya.  Dan Anda harus melakukan sesuatu dengan kode yang sudah ditulis.  Yaitu  kode non-noexcept yang berfungsi harus dikonversikan menjadi kode noexcept yang berfungsi. </p><br><p>  Ini dilakukan dengan bantuan beberapa makro, yang diatur oleh kode di tempat yang tepat.  Misalnya, kasus sepele: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Message_Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trigger_error_and_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Message_Builder msg_builder )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// An exception from logger/msg_builder shouldn't prevent // a call to close(). restinio::utils::log_error_noexcept( m_logger, std::move(msg_builder) ); RESTINIO_ENSURE_NOEXCEPT_CALL( close() ); }</span></span></code> </pre> <br><p>  Dan ini adalah fragmen yang tidak terlalu sepele: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.empty()); RESTINIO_STATIC_ASSERT_NOEXCEPT( m_context_table.pop_response_context_nonchecked()); RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.front()); RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.front().dequeue_group()); RESTINIO_STATIC_ASSERT_NOEXCEPT(make_asio_compaible_error( <span class="hljs-keyword"><span class="hljs-keyword">asio_convertible_error_t</span></span>::write_was_not_executed)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; !m_context_table.empty(); m_context_table.pop_response_context_nonchecked() ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec = make_asio_compaible_error( <span class="hljs-keyword"><span class="hljs-keyword">asio_convertible_error_t</span></span>::write_was_not_executed ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; current_ctx = m_context_table.front(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !current_ctx.empty() ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> wg = current_ctx.dequeue_group(); restinio::utils::suppress_exceptions_quietly( [&amp;] { wg.invoke_after_write_notificator_if_exists( ec ); } ); } } }</code> </pre> <br><p>  Menggunakan makro ini berjabat tangan beberapa kali, menunjuk ke tempat-tempat yang secara tidak sengaja saya anggap sebagai tidak ada kecuali, tetapi ternyata tidak. </p><br><p>  Jadi pendekatan yang diuraikan di bawah ini, tentu saja, adalah lisoped buatan sendiri dengan roda persegi, tapi itu berjalan ... Maksud saya berhasil. </p><br><p>  Lebih lanjut dalam artikel ini, kita akan membahas implementasi yang diisolasi dari kode RESTinio ke dalam set makro yang terpisah. </p><br><h1 id="sut-podhoda">  Inti dari pendekatan </h1><br><p>  Inti dari pendekatan ini adalah meneruskan pernyataan / operator (stmt), yang perlu diperiksa untuk noexcept, ke dalam makro tertentu.  Makro ini menggunakan <code>static_assert(noexcept(stmt), msg)</code> untuk memverifikasi bahwa stmt benar-benar noexcept, dan kemudian mengganti stmt dalam kode. </p><br><p>  Pada dasarnya, ini adalah: </p><br><pre> <code class="cpp hljs">ENSURE_NOEXCEPT_STATEMENT(release(some_resource));</code> </pre> <br><p>  akan diganti dengan sesuatu seperti: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(release(some_resource)), <span class="hljs-string"><span class="hljs-string">"release(some_resource) is expected to be noexcept"</span></span>); release(some_resource);</code> </pre> <br><h2 id="pochemu-byl-sdelan-vybor-v-polzu-makrosov">  Mengapa pilihan dibuat demi makro dibuat? </h2><br><p>  Pada prinsipnya, orang dapat melakukannya tanpa makro dan orang dapat menulis <code>static_assert(noexcept(...))</code> tepat di kode segera sebelum tindakan diperiksa.  Tetapi macro memiliki setidaknya beberapa kebajikan yang memberi nilai pada skala yang mendukung penggunaan macro secara spesifik. </p><br><p>  Pertama, makro mengurangi duplikasi kode.  Ada perbandingan: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(release(some_resource)), <span class="hljs-string"><span class="hljs-string">"release(some_resource) is expected to be noexcept"</span></span>); release(some_resource);</code> </pre> <br><p>  dan </p><br><pre> <code class="cpp hljs">ENSURE_NOEXCEPT_STATEMENT(release(some_resource));</code> </pre> <br><p>  jelas bahwa dengan makro ekspresi utama, yaitu  <code>release(some_resource)</code> hanya dapat ditulis satu kali.  Ini mengurangi kemungkinan kode "merayap" dari waktu ke waktu, dengan disertai, ketika koreksi dilakukan di satu tempat dan dilupakan di tempat kedua. </p><br><p>  Kedua, makro dan, karenanya, cek yang tersembunyi di belakangnya bisa sangat mudah dinonaktifkan.  Katakanlah, jika kelimpahan static_assert-s mulai mempengaruhi kecepatan kompilasi (walaupun saya tidak melihat efek seperti itu).  Atau, yang lebih penting, ketika memperbarui beberapa perpustakaan pihak ketiga, kesalahan kompilasi dari static_assert yang tersembunyi di balik makro dapat menaburkan langsung ke sungai.  Makro yang dinonaktifkan untuk sementara dapat memungkinkan pembaruan kode dengan lancar, termasuk makro verifikasi berurutan pertama dalam satu file, kemudian pada yang kedua, kemudian pada yang ketiga, dll. </p><br><p>  Jadi makro, meskipun mereka adalah fitur yang ketinggalan zaman dan sangat kontroversial dalam C ++, dalam kasus khusus ini, kehidupan pengembang disederhanakan. </p><br><h2 id="osnovnoy-makros-ensure_noexcept_statement">  Makro utama ENSURE_NOEXCEPTPT_STATEMENT </h2><br><p>  ENSURE_NOEXCEPTPT_STATEMENT makro utama diimplementasikan sepele: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENSURE_NOEXCEPT_STATEMENT(stmt) \ do { \ static_assert(noexcept(stmt), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"this statement is expected to be noexcept: "</span></span></span><span class="hljs-meta"> #stmt); \ stmt; \ } while(false)</span></span></code> </pre> <br><p>  Ini digunakan untuk memverifikasi bahwa metode / fungsi yang dipanggil memang bukan pengecualian dan bahwa panggilan mereka tidak perlu dibingkai oleh blok try-catch.  Sebagai contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_complex_container</span></span></span><span class="hljs-class"> {</span></span> one_container first_data_part_; another_container second_data_part_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(some_complex_container &amp; a, some_complex_container &amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; <span class="hljs-comment"><span class="hljs-comment">//  swap  noexcept,    . ENSURE_NOEXCEPT_STATEMENT(swap(a.first_data_part_, b.first_data_part_)); ENSURE_NOEXCEPT_STATEMENT(swap(a.second_data_part_, b.second_data_part_)); ... } ... void clean() noexcept { //  clean()  noexcept,    . ENSURE_NOEXCEPT_STATEMENT(first_data_part_.clean()); ENSURE_NOEXCEPT_STATEMENT(second_data_part_.clean()); ... } ... };</span></span></code> </pre> <br><p>  Selain itu, ada juga makro ENSURE_NOT_NOEXCEPT_STATEMENT.  Ini digunakan untuk memastikan bahwa blok try-catch tambahan diperlukan di sekitar panggilan sehingga kemungkinan pengecualian tidak terbang keluar: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_resource_owner</span></span></span><span class="hljs-class"> {</span></span> some_resource resource_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~some_resource_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  release   noexcept,  try-catch     //      . ENSURE_NOT_NOEXCEPT_STATEMENT(release(resource_)); } catch(...) {} ... } ... };</span></span></code> </pre> <br><h2 id="vspomogatelnye-makrosy-static_assert_noexcept-i-static_assert_not_noexcept">  Makro pembantu STATIC_ASSERT_NOEXCEPT dan STATIC_ASSERT_NOT_NOEXCEPT </h2><br><p>  Sayangnya, makro ENSURE_NOEXCEPT_STATEMENT dan ENSURE_NOT_NOEXCEPT_STATEMENT hanya dapat digunakan untuk pernyataan / pernyataan, tetapi tidak untuk ekspresi yang mengembalikan nilai.  Yaitu  Anda tidak dapat menulis dengan ENSURE_NOEXCEPT_STATEMENT seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resource = ENSURE_NOEXCEPT_STATEMENT(acquire_resource(params));</code> </pre> <br><p>  Oleh karena itu, ENSURE_NOEXCEPTPT_STATEMENT tidak dapat digunakan, misalnya, dalam loop di mana Anda sering harus menulis sesuatu seperti: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = something.get_first(); i != some_other_object; i = i.get_next()) {...}</code> </pre> <br><p>  dan Anda perlu memastikan bahwa <code>get_first()</code> panggilan <code>get_first()</code> , <code>get_next()</code> , serta penugasan nilai-nilai baru untuk saya tidak membuang pengecualian. </p><br><p>  Untuk mengatasi situasi seperti itu, makro STATIC_ASSERT_NOEXCEPT dan STATIC_ASSERT_NOT_NOEXCEPT ditulis, di belakangnya hanya static_assert yang disembunyikan dan tidak lebih.  Dengan menggunakan makro ini, saya dapat mencapai hasil yang saya butuhkan dalam beberapa cara (kompilasi fragmen khusus ini tidak diperiksa): </p><br><pre> <code class="cpp hljs">STATIC_ASSERT_NOEXCEPT(something.get_first()); STATIC_ASSERT_NOEXCEPT(something.get_first().get_next()); STATIC_ASSERT_NOEXCEPT(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(something.get_first())&gt;() = something.get_first().get_next()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = something.get_first(); i != some_other_object; i = i.get_next()) {...}</code> </pre> <br><p>  Jelas, ini bukan solusi terbaik, karena  itu mengarah pada duplikasi kode dan meningkatkan risiko "merayap" dengan pemeliharaan lebih lanjut.  Tetapi sebagai langkah pertama, makro sederhana ini ternyata bermanfaat. </p><br><h1 id="biblioteka-noexcept-ctcheck">  Pustaka Noexcept-ctcheck </h1><br><p>  Ketika saya membagikan pengalaman ini di blog saya dan di Facebook, saya menerima proposal untuk mengatur perkembangan di atas di perpustakaan yang terpisah.  Yang dilakukan: github sekarang memiliki pustaka header-only <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mungil noexcept-compile-time-check (atau noexcept-ctcheck, jika Anda menghemat surat)</a> .  Jadi semua hal di atas dapat Anda ambil dan coba.  Benar, nama-nama makro sedikit lebih panjang dari apa yang digunakan dalam artikel.  Yaitu  NOEXCEPT_CTCHECK_ENSURE_NOEXCEPT_STATEMENT alih-alih ENSURE_NOEXCEPTPT_STATEMENT. </p><br><h2 id="chto-v-noexcept-ctcheck-ne-popalo-poka">  Apa yang tidak masuk ke noexcept-ctcheck (belum?) </h2><br><p>  Ada keinginan untuk membuat makro ENSURE_NOEXCEPTPT_EXPRESSION, yang dapat digunakan seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resource = ENSURE_NOEXCEPT_EXPRESSION(acquire_resource(params));</code> </pre> <br><p>  Dalam perkiraan pertama, dia mungkin terlihat seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENSURE_NOEXCEPT_EXPRESSION(expr) \ ([&amp;]() noexcept -&gt; decltype(auto) { \ static_assert(noexcept(expr), #expr </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" is expected to be noexcept"</span></span></span><span class="hljs-meta">); \ return expr; \ }())</span></span></code> </pre> <br><p>  Tapi ada kecurigaan yang kabur bahwa ada beberapa jebakan yang belum saya pikirkan.  Secara umum, tangan belum mencapai ENSURE_NOEXCEPT_EXPRESSION :( </p><br><h1 id="a-esli-pomechtat">  Dan jika kamu bermimpi? </h1><br><p>  Mimpi lama saya adalah untuk mendapatkan blok noexcept di C ++ di mana kompiler itu sendiri memeriksa untuk melempar pengecualian dan mengeluarkan peringatan jika pengecualian dapat dilempar.  Menurut saya ini akan membuatnya lebih mudah untuk menulis kode pengecualian-aman.  Dan tidak hanya dalam kasus-kasus nyata yang disebutkan di atas (swap, move-operator, destructors).  Misalnya, blok noexcept dapat membantu dalam situasi ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modify_some_complex_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   . one_container_.modify(); // ,   . ,      . //         try. noexcept { current_age_.increment(); } //    ,      . try { another_container_.modify(); ... } catch(...) { noexcept { //  ,     . current_age_.decrement(); one_container_.rollback_modifications(); } throw; } }</span></span></code> </pre> <br><p>  Di sini, untuk kebenaran kode, sangat penting bahwa tindakan yang dilakukan di dalam blok noexcept tidak membuang pengecualian.  Dan jika kompiler dapat melacak ini, maka ini akan menjadi bantuan serius bagi pengembang. </p><br><p>  Tapi mungkin blok noexcept hanyalah kasus khusus dari masalah yang lebih umum.  Yaitu: memeriksa harapan programmer bahwa beberapa blok kode memiliki properti tertentu.  Baik itu tidak adanya pengecualian, tidak ada efek samping, tidak adanya rekursi, ras data, dll. </p><br><p>  Refleksi pada topik ini beberapa tahun yang lalu mengarah pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gagasan menyiratkan dan mengharapkan atribut</a> .  Gagasan ini tidak lebih dari posting blog, karena  sementara dia menjauh dari minat dan peluang saya saat ini.  Tetapi tiba-tiba itu akan menarik bagi seseorang dan seseorang akan mendorong untuk menciptakan sesuatu yang lebih layak. </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Pada artikel ini, saya mencoba untuk berbicara tentang pengalaman saya dalam menyederhanakan penulisan kode pengecualian-aman.  Menggunakan makro, tentu saja, tidak membuat kode lebih indah dan ringkas.  Tapi itu berhasil.  Dan bahkan makro primitif seperti itu meningkatkan koefisien tidur nyenyak saya cukup signifikan.  Jadi, jika orang lain belum memikirkan cara mengontrol konten metode / fungsi noexcept mereka sendiri, maka mungkin artikel ini akan menginspirasi Anda untuk memikirkan topik ini. </p><br><p>  Dan jika seseorang menemukan cara untuk menyederhanakan hidup mereka ketika menulis kode noexcept, maka akan menarik untuk mengetahui apa metode ini, di mana itu membantu dan di mana itu tidak.  Dan seberapa puas Anda dengan apa yang Anda gunakan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466849/">https://habr.com/ru/post/id466849/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466833/index.html">Hal Penting untuk Diketahui Tentang Tensorflow 2.0</a></li>
<li><a href="../id466837/index.html">Akhir pekan di sepeda listrik dengan generator gas</a></li>
<li><a href="../id466839/index.html">Kisah penciptaan Norton Commander. Bagian 1/3</a></li>
<li><a href="../id466841/index.html">Mengapa bantal pemanas, jika ada laptop: studi tentang resistensi termal di tingkat atom</a></li>
<li><a href="../id466845/index.html">Wawancara terbalik: pertanyaan apa yang harus ditanyakan perusahaan?</a></li>
<li><a href="../id466851/index.html">Agilex line - 10nm Intel FPGA</a></li>
<li><a href="../id466855/index.html">Menciptakan Tower Defense in Unity: Skenario dan Waves of Enemies</a></li>
<li><a href="../id466857/index.html">Eksekusi aplikasi latar belakang di iOS 13</a></li>
<li><a href="../id466859/index.html">Menggunakan Layanan Federasi AD untuk Memberi Otorisasi Pengguna AWS dengan Distribusi Hak</a></li>
<li><a href="../id466861/index.html">Cara melarikan diri dari kenyataan menggunakan hackathon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>