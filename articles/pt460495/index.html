<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèº üíÜüèΩ üéûÔ∏è Container-to-pipeline: CRI-O agora √© o padr√£o no OpenShift Container Platform 4 üí≥ üïé üôå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A plataforma Red Hat OpenShift Container Platform 4 permite transmitir a cria√ß√£o de hosts para a implanta√ß√£o de cont√™ineres , inclusive na infraestrut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Container-to-pipeline: CRI-O agora √© o padr√£o no OpenShift Container Platform 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/460495/"> A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plataforma Red Hat OpenShift Container Platform 4</a> permite transmitir a cria√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hosts para a implanta√ß√£o de cont√™ineres</a> , inclusive na infraestrutura de provedores de servi√ßos em nuvem, em plataformas de virtualiza√ß√£o ou em sistemas bare-metal.  Para criar uma plataforma de nuvem em todo o sentido, tivemos que assumir um controle r√≠gido de todos os elementos usados ‚Äã‚Äãe, assim, aumentar a confiabilidade de um processo de automa√ß√£o complexo. <br><br><img src="https://habrastorage.org/webt/h5/hn/x9/h5hnx9ulnrjawbfhd2dncjqmxvm.png" width="100%"><br><br>  A solu√ß√£o √≥bvia foi usar o Red Hat Enterprise Linux CoreOS (uma varia√ß√£o do Red Hat Enterprise Linux) e o CRI-O como padr√£o, e aqui est√° o porqu√™ ... <br><a name="habracut"></a><br>  Como o t√≥pico da navega√ß√£o √© muito bem-sucedido para encontrar analogias na explica√ß√£o da opera√ß√£o de Kubernetes e cont√™ineres, vamos tentar falar sobre os problemas de neg√≥cios que o CoreOS e o CRI-O resolvem, usando o exemplo da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">inven√ß√£o</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Brunel para a produ√ß√£o de blocos de rigging</a> .  Em 1803, Mark Brunel recebeu a tarefa de fabricar 100.000 blocos de cordame para as necessidades da crescente marinha brit√¢nica.  Um bloco de eleva√ß√£o √© um tipo de equipamento usado para prender cordas √†s velas.  At√© o in√≠cio do s√©culo 19, esses blocos eram feitos √† m√£o, mas Brunel era capaz de automatizar a produ√ß√£o e come√ßou a produzir blocos padronizados usando m√°quinas.  A automa√ß√£o desse processo significou que, como resultado, todos os blocos eram quase os mesmos, poderiam ser facilmente substitu√≠dos em caso de avaria e poderiam ser feitos em grandes quantidades. <br><br>  Agora imagine que Brunel teria que fazer esse trabalho para 20 modelos de navios diferentes (vers√µes Kubernetes) e para cinco planetas diferentes com correntes e ventos mar√≠timos completamente diferentes (provedores de nuvem).  Al√©m disso, era necess√°rio que todos os navios (clusters OpenShift), independentemente dos planetas navegados, se comportassem de forma id√™ntica do ponto de vista dos capit√£es (operadores que controlam a opera√ß√£o dos clusters).  Continuando a analogia mar√≠tima, os capit√£es de navios n√£o se importam absolutamente com os blocos de aparelhamento (CRI-O) usados ‚Äã‚Äãem seus navios - a principal coisa para eles √© que esses blocos s√£o fortes e confi√°veis. <br><br>  O OpenShift 4, como plataforma de nuvem, enfrenta um desafio comercial muito semelhante.  Novos n√≥s devem ser criados no momento da cria√ß√£o do cluster, no caso de uma falha em um dos n√≥s ou ao dimensionar o cluster.  Ao criar e inicializar um novo n√≥, os componentes cr√≠ticos do host, incluindo o CRI-O, devem ser configurados de acordo.  Como em qualquer outra produ√ß√£o, as ‚Äúmat√©rias-primas‚Äù devem ser fornecidas no in√≠cio.  No caso de navios, metal e madeira atuam como mat√©ria-prima.  No entanto, se voc√™ criar um host para implantar cont√™ineres em um cluster OpenShift 4, dever√° ter arquivos de configura√ß√£o e servidores de API fornecidos na entrada.  Depois disso, o OpenShift fornecer√° o n√≠vel de automa√ß√£o necess√°rio ao longo de todo o ciclo de vida, oferecendo o suporte necess√°rio ao produto para os usu√°rios finais e, dessa forma, compensando os investimentos na plataforma. <br><br>  O OpenShift 4 foi criado de forma a fornecer a capacidade de atualizar convenientemente o sistema durante todo o ciclo de vida da plataforma (para as vers√µes 4.X) para todos os principais fornecedores de computa√ß√£o em nuvem, plataformas de virtualiza√ß√£o e at√© sistemas bare metal.  Para isso, os n√≥s devem ser criados com base em elementos intercambi√°veis.  Quando um cluster exige uma nova vers√£o do Kubernetes, ele tamb√©m recebe a vers√£o CRI-O correspondente no CoreOS.  Como a vers√£o do CRI-O est√° vinculada diretamente ao Kubernetes, tudo isso simplifica muito qualquer permuta√ß√£o para teste, solu√ß√£o de problemas ou suporte.  Al√©m disso, essa abordagem reduz os custos para usu√°rios finais e Red Hat. <br><br>  Essa √© uma vis√£o fundamentalmente nova dos clusters Kubernetes, que estabelece as bases para o planejamento de novos recursos altamente √∫teis e atraentes.  O CRI-O (interface de tempo de execu√ß√£o do container Container Project - Open Container Initiative, abreviado CRI-OCI) foi a op√ß√£o mais bem-sucedida para cria√ß√£o em massa de n√≥s, necess√°ria para trabalhar com o OpenShift.  O CRI-O substituir√° o mecanismo Docker usado anteriormente, oferecendo aos usu√°rios do OpenShift um mecanismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">econ√¥mico, est√°vel, simples e chato</a> - sim, voc√™ ouviu direito - um cont√™iner chato projetado especificamente para trabalhar com o Kubernetes. <br><br><h3>  O mundo dos cont√™ineres abertos </h3><br>  O mundo vem se movendo em dire√ß√£o a cont√™ineres abertos.  Seja em Kubernetes ou em n√≠veis mais baixos, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">desenvolvimento de padr√µes de cont√™ineres</a> leva a um ecossistema de inova√ß√£o em todos os n√≠veis. <br><br>  Tudo come√ßou com a cria√ß√£o da Open Containers Initiative <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em junho de 2015</a> .  Nesse est√°gio inicial do trabalho, as especifica√ß√µes para a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">imagem</a> do container <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">(imagem)</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tempo de execu√ß√£o</a> foram formadas.  Isso tornou poss√≠vel garantir que as ferramentas possam usar um √∫nico padr√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">imagens</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cont√™iner</a> e um √∫nico formato para trabalhar com elas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mais</a> tarde, foram adicionadas especifica√ß√µes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">distribui√ß√£o</a> , que permitiam aos usu√°rios trocar facilmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">imagens de cont√™ineres</a> . <br><br>  A comunidade Kubernetes desenvolveu um √∫nico padr√£o de interface conect√°vel chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Container Runtime Interface (CRI)</a> .  Gra√ßas a isso, os usu√°rios do Kubernetes puderam conectar v√°rios mecanismos para trabalhar com cont√™ineres, al√©m do Docker. <br><br>  Os engenheiros da Red Hat e do Google viram uma demanda de mercado por um mecanismo de cont√™iner que pudesse aceitar solicita√ß√µes da Kubelet usando o protocolo CRI e introduziu cont√™ineres compat√≠veis com as especifica√ß√µes OCI mencionadas acima.  Ent√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">havia um OCID</a> .  Mas com licen√ßa, porque dissemos que esse material ser√° dedicado ao CRI-O?  De fato, apenas com o lan√ßamento da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vers√£o 1.0, o</a> projeto foi renomeado para CRI-O. <br><br>  <b><i>Fig.</i></b>  <b><i>1</i></b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7-/-n/qb/7--nqbszwtnoy38f-tnbuzdmucm.png"></div><br><br><h3>  Inova√ß√£o com CRI-O e CoreOS </h3><br>  Com o lan√ßamento da plataforma OpenShift 4, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mecanismo de cont√™iner</a> usado na plataforma padr√£o foi alterado e o Docker foi substitu√≠do pelo CRI-O, que oferecia um ambiente de lan√ßamento de cont√™iner econ√¥mico, est√°vel, simples e chato que se desenvolve paralelamente ao Kubernetes.  Isso simplifica bastante o suporte e a configura√ß√£o do cluster.  A configura√ß√£o do mecanismo e do host do cont√™iner, assim como o gerenciamento, torna-se automatizada no OpenShift 4. <br><br>  Pare, como est√°? <br><br>  Isso mesmo, com o advento do OpenShift 4, agora n√£o h√° mais a necessidade de se conectar a hosts individuais e instalar um mecanismo de cont√™iner, configurar armazenamento, configurar servidores para pesquisa ou configurar uma rede.  A plataforma OpenShift 4 foi completamente redesenhada para usar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Operator Framework</a> n√£o apenas em termos de aplicativos do usu√°rio final, mas tamb√©m em termos de opera√ß√µes b√°sicas no n√≠vel da plataforma, como implantar imagens, configurar o sistema ou instalar atualiza√ß√µes. <br><br>  O Kubernetes sempre permite que os usu√°rios gerenciem aplicativos, determinando o estado desejado e usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Controladores</a> para garantir que o estado real seja o mais pr√≥ximo poss√≠vel do estado especificado.  Essa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">abordagem, usando um determinado estado e um estado real,</a> abre grandes oportunidades, tanto do ponto de vista do desenvolvimento quanto do ponto de vista das opera√ß√µes.  Os desenvolvedores podem determinar o estado necess√°rio, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">transferi-lo para o</a> operador na forma de um arquivo YAML ou JSON e, em seguida, o operador pode criar a inst√¢ncia de aplicativo necess√°ria no ambiente operacional, enquanto o estado operacional dessa inst√¢ncia corresponder√° totalmente ao especificado. <br><br>  Usando operadores na plataforma, o OpenShift 4 traz esse novo paradigma (usando o conceito de conjunto e estado real) para o gerenciamento do RHEL CoreOS e CRI-O.  As tarefas de configura√ß√£o e vers√£o do sistema operacional e do mecanismo de cont√™iner s√£o automatizadas usando o chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Machine Config Operator (MCO)</a> .  O MCO simplifica bastante o trabalho do administrador de cluster, automatizando essencialmente os √∫ltimos est√°gios da instala√ß√£o, bem como as opera√ß√µes subseq√ºentes ap√≥s a instala√ß√£o (opera√ß√µes do segundo dia).  Tudo isso faz do OpenShift 4 uma verdadeira plataforma em nuvem.  Vamos nos concentrar nisso um pouco mais tarde. <br><br><h3>  Lan√ßamento de cont√™iner </h3><br>  Os usu√°rios tiveram a oportunidade de usar o mecanismo CRI-O na plataforma OpenShift a partir da vers√£o 3.7 no status do Tech Preview e da vers√£o 3.9 no status de Disponibilidade geral (atualmente suportada).  Al√©m disso, a Red Hat faz uso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">extensivo</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CRI-O para iniciar cargas de trabalho de produ√ß√£o</a> no OpenShift Online desde a vers√£o 3.10.  Tudo isso permitiu √† equipe que trabalha no CRI-O obter uma vasta experi√™ncia no lan√ßamento em massa de cont√™ineres em grandes clusters Kubernetes.  Para obter um entendimento b√°sico de como o Kubernetes usa o CRI-O, vamos dar uma olhada na ilustra√ß√£o a seguir, que mostra como a arquitetura funciona. <br><br>  <b><i>Fig.</i></b>  <b><i>2. Como os cont√™ineres funcionam no cluster Kubernetes</i></b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1a/zr/kz/1azrkzz-ey6euphpkgqpazncwci.png"></div><br><br>  O CRI-O simplifica a cria√ß√£o de novos hosts de cont√™iner, sincronizando todo o n√≠vel superior ao inicializar novos n√≥s e ao liberar novas vers√µes da plataforma OpenShift.  Uma auditoria de plataforma inteira permite atualiza√ß√µes / revers√µes transacionais e tamb√©m evita conflitos nas depend√™ncias entre o kernel da cauda do cont√™iner, o mecanismo do cont√™iner, o Kubelets e o Kubernetes Master.  Com o gerenciamento centralizado de todos os componentes da plataforma, com controle e gerenciamento de vers√£o, voc√™ sempre pode rastrear um caminho claro do estado A ao estado B. Isso simplifica o processo de atualiza√ß√£o, melhora a seguran√ßa, melhora os relat√≥rios de desempenho e ajuda a reduzir o custo de atualiza√ß√£o e instala√ß√£o de novas vers√µes. <br><br><h3>  Demonstra√ß√£o do poder de elementos intercambi√°veis </h3><br>  Como mencionado anteriormente, o uso do Machine Config Operator para gerenciar o host e o mecanismo do cont√™iner no OpenShift 4 fornece um novo n√≠vel de automa√ß√£o que antes n√£o era poss√≠vel na plataforma Kubernetes.  Para demonstrar os novos recursos, mostramos como voc√™ pode fazer altera√ß√µes no arquivo crio.conf.  Para n√£o ficar confuso com a terminologia, tente se concentrar nos resultados. <br><br>  Primeiro, vamos criar o que √© chamado de configura√ß√£o de tempo de execu√ß√£o do cont√™iner - a Configura√ß√£o do Tempo de Execu√ß√£o do Cont√™iner.  Considere isso um recurso do Kubernetes que representa a configura√ß√£o do CRI-O.  Na realidade, esta √© uma vers√£o especializada do que √© chamado MachineConfig, que √© qualquer configura√ß√£o implantada em uma m√°quina RHEL CoreOS dentro de um cluster OpenShift. <br><br>  Esse recurso personalizado, chamado ContainerRuntimeConfig, foi inventado para facilitar a configura√ß√£o do CRI-O pelos administradores de cluster.  Esta √© uma ferramenta suficientemente poderosa que s√≥ pode ser aplicada a determinados n√≥s, dependendo das configura√ß√µes do MachineConfigPool.  Considere isso um grupo de m√°quinas que servem ao mesmo prop√≥sito. <br><br>  Preste aten√ß√£o nas duas √∫ltimas linhas que mudaremos no arquivo /etc/crio/crio.conf.  Essas duas linhas s√£o muito semelhantes √†s linhas no arquivo crio.conf, s√£o elas: <br><br><pre><code class="plaintext hljs">vi ContainerRuntimeConfig.yaml</code> </pre> <br>  Conclus√£o: <br><br><pre> <code class="plaintext hljs">apiVersion: machineconfiguration.openshift.io/v1 kind: ContainerRuntimeConfig metadata: name: set-log-and-pid spec: machineConfigPoolSelector: matchLabels: debug-crio: config-log-and-pid containerRuntimeConfig: pidsLimit: 2048 logLevel: debug</code> </pre><br>  Agora envie esse arquivo para o cluster Kubernetes e verifique se ele realmente foi criado.  Observe que a opera√ß√£o √© realizada da mesma maneira que com qualquer outro recurso do Kubernetes: <br><br><pre> <code class="plaintext hljs">oc create -f ContainerRuntimeConfig.yaml oc get ContainerRuntimeConfig</code> </pre><br>  Conclus√£o: <br><br><pre> <code class="plaintext hljs">NAME AGE set-log-and-pid 22h</code> </pre><br>  Depois de criar o ContainerRuntimeConfig, precisamos modificar um dos MachineConfigPools para fazer o Kubernetes entender que queremos aplicar essa configura√ß√£o a um grupo espec√≠fico de m√°quinas no cluster.  Nesse caso, mudaremos MachineConfigPool para os n√≥s principais: <br><br><pre> <code class="plaintext hljs">oc edit MachineConfigPool/master</code> </pre><br>  Conclus√£o (para maior clareza, o ponto principal √© deixado): <br><br><pre> <code class="plaintext hljs">... metadata: creationTimestamp: 2019-04-10T23:42:28Z generation: 1 labels: debug-crio: config-log-and-pid operator.machineconfiguration.openshift.io/required-for-upgrade: "" ...</code> </pre><br>  Nesse momento, o MCO come√ßa a criar um novo arquivo crio.conf para o cluster.  Nesse caso, um arquivo de configura√ß√£o completo pode ser exibido usando a API do Kubernetes.  Lembre-se, ContainerRuntimeConfig √© apenas uma vers√£o especializada do MachineConfig, para que possamos ver o resultado observando as linhas em MachineConfigs: <br><br><pre> <code class="plaintext hljs">oc get MachineConfigs | grep rendered</code> </pre><br>  Conclus√£o: <br><br><pre> <code class="plaintext hljs">rendered-master-c923f24f01a0e38c77a05acfd631910b 4.0.22-201904011459-dirty 2.2.0 16h rendered-master-f722b027a98ac5b8e0b41d71e992f626 4.0.22-201904011459-dirty 2.2.0 4m rendered-worker-9777325797fe7e74c3f2dd11d359bc62 4.0.22-201904011459-dirty 2.2.0 16h</code> </pre><br>  Observe que o arquivo de configura√ß√£o resultante para os n√≥s principais acabou sendo uma vers√£o mais recente que as configura√ß√µes originais.  Para visualiz√°-lo, execute o seguinte comando.  De passagem, observamos que este √© provavelmente um dos melhores scripts de linha √∫nica na hist√≥ria do Kubernetes: <br><br><pre> <code class="plaintext hljs">python3 -c "import sys, urllib.parse; print(urllib.parse.unquote(sys.argv[1]))" $(oc get MachineConfig/rendered-master-f722b027a98ac5b8e0b41d71e992f626 -o YAML | grep -B4 crio.conf | grep source | tail -n 1 | cut -d, -f2) | grep pid</code> </pre><br>  Conclus√£o: <br><br><pre> <code class="plaintext hljs">pids_limit = 2048</code> </pre><br>  Agora verifique se a configura√ß√£o foi aplicada a todos os n√≥s principais.  Primeiro, obtemos uma lista de n√≥s no cluster: <br><br><pre> <code class="plaintext hljs">oc get node | grep master Output: ip-10-0-135-153.us-east-2.compute.internal Ready master 23h v1.12.4+509916ce1 ip-10-0-154-0.us-east-2.compute.internal Ready master 23h v1.12.4+509916ce1 ip-10-0-166-79.us-east-2.compute.internal Ready master 23h v1.12.4+509916ce1</code> </pre><br>  Agora olhe para o arquivo instalado.  Voc√™ ver√° que o arquivo foi atualizado com as novas diretivas pid e debug que especificamos no recurso ContainerRuntimeConfig.  Eleg√¢ncia em si: <br><br><pre> <code class="plaintext hljs">oc debug node/ip-10-0-135-153.us-east-2.compute.internal ‚Äî cat /host/etc/crio/crio.conf | egrep 'debug||pid'</code> </pre><br>  Conclus√£o: <br><br><pre> <code class="plaintext hljs">... pids_limit = 2048 ... log_level = "debug" ...</code> </pre><br>  Todas essas altera√ß√µes no cluster foram feitas mesmo sem iniciar o SSH.  Todo o trabalho foi realizado entrando em contato com o n√≥ principal do Kuberentes.  Ou seja, esses novos par√¢metros foram configurados apenas nos n√≥s principais.  Ao mesmo tempo, os n√≥s de trabalho n√£o foram alterados, o que demonstra as vantagens da metodologia Kubernetes, usando os estados definido e atual, aplicados aos hosts de cont√™ineres e mecanismos de cont√™ineres com elementos intercambi√°veis. <br><br>  O exemplo acima mostra a capacidade de fazer altera√ß√µes em um pequeno cluster do OpenShift Container Platform 4 com tr√™s n√≥s em funcionamento ou em um grande cluster de produ√ß√£o com 3000 n√≥s.  De qualquer forma, a quantidade de trabalho ser√° a mesma - e muito pequena - apenas configure o arquivo ContainerRuntimeConfig e altere um r√≥tulo no MachineConfigPool.  E voc√™ pode fazer isso com qualquer vers√£o da plataforma OpenShift Container Platform 4.X usada pelo Kubernetes ao longo de seu ciclo de vida. <br><br>  Freq√ºentemente, as empresas de tecnologia est√£o se desenvolvendo t√£o rapidamente que n√£o conseguimos explicar por que escolhemos determinadas tecnologias para os componentes b√°sicos.  Os mecanismos de cont√™iner t√™m sido historicamente o componente com o qual os usu√°rios interagem diretamente.  Como a popularidade dos cont√™ineres come√ßou naturalmente com o advento dos mecanismos de cont√™iner, os usu√°rios geralmente demonstram interesse neles.  Essa √© outra raz√£o pela qual a Red Hat optou pelo CRI-O.  Os cont√™ineres est√£o evoluindo, com foco na orquestra√ß√£o hoje, e chegamos √† conclus√£o de que o CRI-O oferece a melhor experi√™ncia ao trabalhar com o OpenShift 4. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460495/">https://habr.com/ru/post/pt460495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460483/index.html">5 m√©todos para executar um brainstorm eficaz</a></li>
<li><a href="../pt460485/index.html">Como um torneio online pode desencorajar o "fim na pr√≥xima semana"</a></li>
<li><a href="../pt460489/index.html">Os 11 principais erros no desenvolvimento do BCP</a></li>
<li><a href="../pt460491/index.html">Sensor de temperatura e umidade do Arduino com envio e plotagem (Parte 1)</a></li>
<li><a href="../pt460493/index.html">"Aplicativos matadores" para PC dos anos 80: VisiCalc e WordStar</a></li>
<li><a href="../pt460497/index.html">Uso intuitivo dos m√©todos de Monte Carlo com cadeias de Markov</a></li>
<li><a href="../pt460499/index.html">Tr√™s vencedores do Pr√™mio Dijkstra: como foram o Hydra 2019 e o SPTDC 2019</a></li>
<li><a href="../pt460501/index.html">Exemplo de implementa√ß√£o de integra√ß√£o cont√≠nua usando o BuildBot</a></li>
<li><a href="../pt460503/index.html">Configura√ß√£o sem fio do Raspberry PI 3 B +</a></li>
<li><a href="../pt460505/index.html">Seduza tr√™s cruzamentos, ou por que os projetos s√£o t√£o dif√≠ceis de terminar a tempo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>