<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>„ÄΩÔ∏è üèåÔ∏è üêò Compacta√ß√£o de grandes matrizes de n√∫meros primos ‚öΩÔ∏è üö± üôã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As propriedades dos n√∫meros primos raramente permitem trabalhar com eles de forma diferente da forma de uma matriz pr√©-calculada - e de prefer√™ncia o ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compacta√ß√£o de grandes matrizes de n√∫meros primos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417753/"><img src="https://habrastorage.org/webt/sr/yf/y8/sryfy8c2vpyfx-euoq7v_v3p_sa.jpeg" alt="sandbox" align="left"><br><p>  As propriedades dos n√∫meros primos raramente permitem trabalhar com eles de forma diferente da forma de uma matriz pr√©-calculada - e de prefer√™ncia o mais volumosa poss√≠vel.  O formato de armazenamento natural na forma de n√∫meros inteiros com capacidade de um ou outro d√≠gito sofre ao mesmo tempo algumas desvantagens que se tornam significativas com o crescimento do volume de dados. <br></p><p></p><p>  Portanto, o formato de n√∫meros inteiros n√£o assinados de 16 bits com o tamanho de uma tabela √© de cerca de 13 kilobytes, cont√©m apenas 6542 primos: seguidos pelo n√∫mero 65531 s√£o os valores de profundidade de bits mais alta.  Tal mesa √© adequada apenas como um brinquedo. <br></p><p></p><p>  O formato inteiro de 32 bits mais popular na programa√ß√£o parece muito mais s√≥lido - permite armazenar cerca de 203 milh√µes de formatos simples.  Mas essa tabela j√° ocupa cerca de 775 megabytes. <br></p><p></p><p>  O formato de 64 bits tem ainda mais perspectivas.  No entanto, com um poder te√≥rico da ordem de 1e + 19 valores, a tabela teria um tamanho de 64 exabytes. <br></p><br><a name="habracut"></a><br><p></p><p>  N√£o se acredita realmente que nossa humanidade progressiva jamais calcule, no futuro previs√≠vel, uma tabela de n√∫meros primos desse volume.  E o ponto aqui n√£o √© tanto em volumes, mas tamb√©m no tempo de contagem dos algoritmos dispon√≠veis.  Digamos, se a tabela de todas as simples de 32 bits ainda puder ser calculada independentemente em algumas horas (Fig. 1), ent√£o, para a tabela, pelo menos uma ordem de magnitude maior, levar√° v√°rios dias.  Mas esses volumes hoje - este √© apenas o n√≠vel inicial. <br></p><br><br><img src="https://habrastorage.org/webt/ut/qn/gq/utqngqsvjfyolxj1afp9n--6jxw.jpeg" alt="fig. 1"><br><br><p>  Como pode ser visto no diagrama, o tempo de c√°lculo espec√≠fico ap√≥s o empurr√£o inicial passa suavemente para o crescimento assint√≥tico.  Ele √© bastante lento.  mas isso √© crescimento, o que significa que a minera√ß√£o de todos os dados ao longo do tempo ser√° cada vez mais dif√≠cil.  Se voc√™ quiser fazer alguma inova√ß√£o significativa, ter√° que paralelizar o trabalho entre os n√∫cleos (e ele se assemelha bem) e pendur√°-lo nos supercomputadores.  Com a perspectiva de simplificar os primeiros 10 bilh√µes em uma semana e 100 bilh√µes - apenas em um ano.  Certamente, existem algoritmos mais r√°pidos para calcular simples do que o fracasso trivial usado em minha li√ß√£o de casa, mas, em ess√™ncia, isso n√£o muda a quest√£o: depois de duas ou tr√™s ordens de magnitude, a situa√ß√£o se torna semelhante. <br></p><p></p><p>  Portanto, seria bom uma vez ter realizado o trabalho de contagem, armazenar o resultado em uma forma de tabela pronta e us√°-lo conforme necess√°rio. <br></p><p></p><p>  Devido √† obviedade da ideia, a rede encontra muitos links para listas prontas de n√∫meros primos j√° calculadas por algu√©m.  Infelizmente, na maioria dos casos, eles s√£o adequados apenas para artesanato de estudantes: um deles, por exemplo, vagueia de um local para outro e inclui 50 milh√µes de trabalhos simples.  Esse valor s√≥ pode surpreender os n√£o iniciados: j√° foi mencionado acima que em um computador dom√©stico em poucas horas voc√™ pode calcular independentemente a tabela de todos os simples de 32 bits e √© quatro vezes maior.  Provavelmente cerca de 15 a 20 anos atr√°s, essa lista foi de fato uma conquista her√≥ica para a comunidade leiga.  Hoje, na era dos dispositivos com v√°rios n√∫cleos, multi-gigahertz e multi-gigabytes, isso n√£o √© mais impressionante. <br></p><p></p><p>  Tive a sorte de me familiarizar com o acesso a uma tabela muito mais representativa de tabelas simples, que usarei mais como ilustra√ß√£o e sacrif√≠cio para minhas experi√™ncias de campo.  Para fins de conspira√ß√£o, vou cham√°-la de <b>1TPrimo</b> .  Ele cont√©m todos os n√∫meros primos menores que um trilh√£o. <br></p><p></p><p>  Usando o 1TPrimo como exemplo, √© f√°cil ver com quais volumes voc√™ precisa lidar.  Com uma capacidade de cerca de 37,6 bilh√µes de valores no formato inteiro de 64 bits, esta lista tem 280 gigabytes.  A prop√≥sito - a parte que pode caber em 32 d√≠gitos representa apenas 0,5% do n√∫mero de n√∫meros representados nela.  Isso deixa absolutamente claro que qualquer trabalho s√©rio com n√∫meros primos inevitavelmente tende a totalizar profundidades de 64 bits (ou mais). <br></p><p></p><p>  Assim, a tend√™ncia sombria √© √≥bvia: uma tabela de n√∫meros primos, de alguma forma s√©ria, inevitavelmente tem um volume tit√¢nico.  E devemos de alguma forma combater isso. <br></p><p></p><p>  A primeira coisa que vem √† mente quando se olha para uma tabela (Fig. 2) √© que ela consiste em valores consecutivos quase id√™nticos que diferem apenas em uma ou duas das √∫ltimas casas decimais: <br></p><br><p><br><img src="https://habrastorage.org/webt/y7/hk/f5/y7hkf5s75ii-jdujarftwhpd14i.jpeg" alt="fig. 2"><br><br></p><br><p>  Simplesmente, das considera√ß√µes abstratas mais gerais: se o arquivo tiver muitos dados duplicados, ele dever√° ser compactado pelo arquivador.  De fato, a compacta√ß√£o da tabela 1TPrimo com o popular utilit√°rio 7-zip nas configura√ß√µes padr√£o deu uma taxa de compacta√ß√£o bastante alta: 8,5.  √â verdade que o tempo de processamento - com o tamanho enorme da tabela de origem - em um servidor de 8 n√∫cleos, com uma carga m√©dia de todos os n√∫cleos de 80 a 90%, foi de 14 horas e 12 minutos.  Os algoritmos de compress√£o universal s√£o projetados para algumas id√©ias abstratas e generalizadas sobre dados.  Em alguns casos especiais, algoritmos de compacta√ß√£o especializados criados com os recursos conhecidos do conjunto de dados recebidos podem demonstrar indicadores muito mais eficazes, aos quais esse trabalho √© dedicado.  E qu√£o eficaz ser√° claro abaixo. <br></p><p></p><p>  Os valores num√©ricos pr√≥ximos dos n√∫meros primos vizinhos pedem uma decis√£o de n√£o armazenar esses valores eles mesmos, mas os intervalos (diferen√ßas) entre eles.  Nesse caso, economias significativas podem ser obtidas devido ao fato de a profundidade de bits dos intervalos ser muito menor que a profundidade de bits dos dados iniciais (Fig. 3). <br></p><br><p><br><img src="https://habrastorage.org/webt/7-/lk/ka/7-lkkafdhzaus8yglobx1t5t25w.jpeg" alt="fig. 3"><br><br></p><br><p>  E parece que isso n√£o depende da profundidade de bits dos simples que geram o intervalo.  Uma pesquisa exaustiva mostra que os valores t√≠picos de intervalos para n√∫meros primos obtidos de v√°rios lugares na tabela 1TPrimo est√£o dentro de unidades, dezenas, √†s vezes centenas, e - como a primeira senten√ßa de trabalho - eles provavelmente poderiam caber no intervalo de 8 bits n√∫meros inteiros n√£o assinados, ou seja, bytes.  Seria muito conveniente e, em compara√ß√£o com o formato de 64 bits, isso imediatamente levaria a uma compress√£o de dados de 8 vezes - apenas em algum lugar no n√≠vel demonstrado pelo arquivador de 7 zip.  Al√©m disso, a simplicidade dos algoritmos de compacta√ß√£o e descompacta√ß√£o deve, em princ√≠pio, ter um grande impacto na velocidade da compacta√ß√£o e do acesso aos dados em compara√ß√£o com o 7-zip.  Parece tentador. <br></p><p></p><p>  √â absolutamente claro que os dados convertidos de seus valores absolutos para os intervalos relativos entre eles s√£o adequados apenas para restaurar uma s√©rie de valores que seguem uma linha desde o in√≠cio da tabela principal.  Mas se adicionarmos uma estrutura m√≠nima de √≠ndice de bloco a essa tabela de intervalos, ent√£o, com custos indiretos adicionais insignificantes, isso nos permitir√° restaurar - mas j√° bloquear por bloco - o elemento da tabela por seu n√∫mero e o elemento mais pr√≥ximo por um valor definido arbitrariamente, e essas opera√ß√µes, juntamente com a opera√ß√£o principal amostras de sequ√™ncia - em geral, esgota a maior parte das consultas poss√≠veis para esses dados.  O processamento estat√≠stico, √© claro, se tornar√° mais complicado, mas continuar√° sendo bastante transparente, como  n√£o h√° truque espec√≠fico para recuper√°-lo "em tempo real" dos intervalos dispon√≠veis ao acessar o bloco de dados necess√°rio. <br></p><p></p><p>  Mas infelizmente.  Um experimento num√©rico simples com dados do 1TPrimo mostra que j√° no final da terceira dezenas de milh√µes (isso √© menos de um cent√©simo de um por cento do volume do 1TPrimo) - e depois em qualquer outro lugar - os intervalos entre os primos adjacentes ficam regularmente fora do intervalo de 0..255. <br></p><p></p><p>  No entanto, um experimento num√©rico um pouco complicado revela que o crescimento do intervalo m√°ximo entre os primos vizinhos com o crescimento da pr√≥pria tabela √© muito, muito lento - o que significa que a ideia ainda √© boa de alguma forma. <br></p><p></p><p>  O segundo olhar mais atento √† tabela de intervalos sugere que √© poss√≠vel armazenar n√£o a diferen√ßa em si, mas a metade.  Como todos os n√∫meros primos maiores que 2 s√£o obviamente √≠mpares, respectivamente, suas diferen√ßas s√£o obviamente pares.  Consequentemente, as diferen√ßas podem ser reduzidas em 2 sem perda de valor;  e para completar, pode-se tamb√©m subtrair um do quociente obtido, a fim de usar utilmente o valor zero que n√£o foi reivindicado de outra forma (Fig. 4).  Essa redu√ß√£o de intervalos ser√° denominada a seguir monol√≠tica, em contraste com a forma inicial frouxa e porosa, na qual todos os valores √≠mpares e zero acabaram n√£o sendo reclamados. <br></p><br><p><br><img src="https://habrastorage.org/webt/ix/ob/fp/ixobfp-kfzmw2gkwjrkkmwcfxn4.jpeg" alt="fig. 4"><br><br></p><br><p>  Deve-se notar que, como o intervalo entre os dois primeiros simples (2 e 3) n√£o se enquadra nesse esquema, 2 dever√° ser exclu√≠do da tabela de intervalos e manter esse fato em mente o tempo todo. <br></p><p></p><p>  Essa t√©cnica simples permite codificar intervalos de 2 a 512 no intervalo de valores de 0 a 255. Mais uma vez, surge a esperan√ßa de que o m√©todo da diferen√ßa nos permita agrupar uma sequ√™ncia de primos muito mais poderosa.  E com raz√£o: uma s√©rie de 37,6 bilh√µes de valores apresentados na lista 1TPrimo revelou apenas 6 (seis!) Intervalos que n√£o est√£o na faixa 2..512. <br></p><p></p><p>  Mas essas foram boas not√≠cias;  o ruim √© que esses seis intervalos est√£o espalhados pela lista bastante livremente, e o primeiro deles j√° ocorre no final do primeiro ter√ßo da lista, transformando os dois ter√ßos restantes em lastro inadequados para esse m√©todo de compress√£o (Fig. 5): <br></p><br><p><br><img src="https://habrastorage.org/webt/k_/0y/aw/k_0yaw46rbatmne64qzj0vp9mus.jpeg" alt="fig. 5"><br><br></p><br><p>  Tal descarga (algumas infelizes seis pe√ßas por quase quarenta bilh√µes! - e para voc√™ ...) mesmo com uma mosca na pomada para comparar - para mostrar a honra do alcatr√£o.  Mas, infelizmente, este √© um padr√£o, n√£o um acidente.  Se tra√ßarmos a primeira apar√™ncia de intervalos entre primos, dependendo do tamanho dos dados, fica claro que esse fen√¥meno reside na gen√©tica dos primos, embora progrida extremamente lentamente (Fig. 6 *). <br></p><br><p><br><img src="https://habrastorage.org/webt/sj/c_/ah/sjc_ah1hgw7ud9xewa3_s47edhq.jpeg" alt="fig. 6"><br><br></p><br><p>  * Programa√ß√£o compilada de acordo com o site tem√°tico de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Thomas R. Nisley</a> , <br>  que s√£o v√°rias ordens de magnitude superiores ao poder da lista 1TPrimo </p><br><p></p><p>  Mas mesmo esse progresso muito lento indica sem ambiguidade: √© poss√≠vel limitar-se a uma certa profundidade de intervalo de bits predeterminada apenas a um certo poder predeterminado da lista.  Ou seja, n√£o √© adequado como solu√ß√£o universal. <br></p><p></p><p>  No entanto, o fato de o m√©todo proposto de compacta√ß√£o de uma sequ√™ncia de n√∫meros primos permitir a implementa√ß√£o de uma tabela compacta simples com uma capacidade de quase 12 bilh√µes de valores j√° √© um resultado.  Essa tabela ocupa um volume de 11,1 gigabytes - contra 89,4 gigabytes em um formato trivial de 64 bits.  Certamente, para v√°rias aplica√ß√µes, essa solu√ß√£o pode ser suficiente. <br></p><p></p><p>  E o que √© interessante: o procedimento para converter uma tabela 1TPrimo de 64 bits para o formato de intervalos de 8 bits com uma estrutura de bloco, usando apenas um n√∫cleo do processador (para paraleliza√ß√£o, voc√™ teria que recorrer a uma complica√ß√£o significativa do programa, e n√£o valia a pena) e n√£o mais do que 5 % da carga do processador (na maioria das vezes gasta em opera√ß√µes de arquivo) levou apenas 19 minutos. Contra, lembro-me, 14 horas em oito n√∫cleos, com 80-90% da carga gasta pelo arquivador de 7 zip. <br></p><p></p><p>  Obviamente, apenas o primeiro ter√ßo da tabela foi submetido a essa tradu√ß√£o, na qual o intervalo de intervalos n√£o excede 512. Portanto, se levarmos as 14 horas completas para o mesmo ter√ßo, 19 minutos devem ser comparados com quase 5 horas do arquivador de 7 zip.  Com uma quantidade compar√°vel de compacta√ß√£o (8 e 8,5), a diferen√ßa √© de cerca de 15 vezes.  Considerando que a maior parte do tempo de trabalho do programa de transmiss√£o era ocupada por opera√ß√µes de arquivos, a diferen√ßa seria ainda mais acentuada em um sistema de disco mais r√°pido.  E intelectualmente, o tempo de opera√ß√£o do 7-zip em oito n√∫cleos ainda deve ser contado em um thread e, em seguida, a compara√ß√£o se tornar√° realmente adequada. <br></p><p></p><p>  A sele√ß√£o desse banco de dados difere muito pouco da sele√ß√£o da tabela de dados descompactados e √© quase inteiramente determinada pelo tempo das opera√ß√µes do arquivo.  Os n√∫meros espec√≠ficos dependem fortemente do hardware espec√≠fico; no meu servidor, em m√©dia, o acesso a um bloco de dados arbitr√°rio levou 37,8 Œºs, enquanto a leitura sequencial de blocos - 4,2 Œºs por bloco, para a descompacta√ß√£o completa do bloco - menos de 1 Œºs.  Ou seja, n√£o faz sentido comparar a descompress√£o de dados com o trabalho de um arquivador padr√£o.  E esta √© uma grande vantagem. <br></p><p></p><p>  E, finalmente, as observa√ß√µes oferecem mais uma terceira solu√ß√£o que remove quaisquer restri√ß√µes ao poder dos dados: intervalos de codifica√ß√£o com valores de comprimento vari√°vel.  Essa t√©cnica tem sido amplamente utilizada em aplicativos relacionados √† compacta√ß√£o.  Seu significado √© que, se for encontrado na entrada que alguns valores s√£o frequentemente encontrados, alguns s√£o menos comuns e alguns s√£o muito raros, ent√£o podemos codificar o primeiro com c√≥digos curtos, o segundo com c√≥digos mais aut√™nticos e o terceiro - muito longo (talvez at√© muito longo, porque n√£o importa: mesmo assim, esses dados s√£o muito raros).  Como resultado, o comprimento total dos c√≥digos recebidos pode ser muito menor que os dados de entrada. <br></p><p></p><p>  J√° observando o gr√°fico da apar√™ncia dos intervalos na Fig. 7, podemos supor que, se os intervalos forem 2, 4, 6, etc.  aparecer antes dos intervalos, digamos, 100, 102, 104 etc., o primeiro deve continuar ocorrendo com muito mais frequ√™ncia do que o segundo.  E vice-versa - se os intervalos 514 aparecerem apenas a partir de 11,99 bilh√µes, 516 - a partir de 16,2 bilh√µes e 518 - geralmente a partir de 87,7 bilh√µes, ent√£o eles ser√£o muito raros.  Ou seja, a priori, podemos assumir a rela√ß√£o inversa entre o tamanho do intervalo e sua frequ√™ncia em uma sequ√™ncia de n√∫meros primos.  E isso significa - voc√™ pode construir uma estrutura simples que implemente c√≥digos de comprimento vari√°vel para eles. <br></p><p></p><p>  Obviamente, as estat√≠sticas sobre a frequ√™ncia dos intervalos devem se tornar determinantes para a escolha de um m√©todo de codifica√ß√£o espec√≠fico.  Felizmente, em contraste com os dados arbitr√°rios, a frequ√™ncia dos intervalos entre os primos - que por si s√≥ s√£o uma sequ√™ncia estritamente determinada, de uma vez por todas - √© tamb√©m uma caracter√≠stica estritamente determinada, de uma vez por todas definida. <br></p><p></p><p>  A Figura 7 mostra a resposta em frequ√™ncia dos intervalos para toda a lista 1TPrimo: <br></p><br><p><br><img src="https://habrastorage.org/webt/7q/ga/ii/7qgaii-1mwxlmuvicojaklwrbuk.jpeg" alt="fig. 7"><br><br></p><br><p>  Aqui √© necess√°rio mencionar novamente que o intervalo entre os primeiros primos 2 e 3 √© exclu√≠do do gr√°fico: esse intervalo √© 1 e ocorre exatamente uma vez na sequ√™ncia de primos, independentemente do poder da lista.  Esse intervalo √© t√£o peculiar que √© mais f√°cil remover 2 da lista de simples do que se afastar constantemente das reservas.  O sim √© declarado que o <b>n√∫mero 2 √© virtual prime</b> : n√£o √© vis√≠vel nas listas, mas est√° l√°.  Como aquele esquilo. <br></p><p></p><p>  √Ä primeira vista, o gr√°fico de frequ√™ncia confirma completamente a suposi√ß√£o a priori dada por alguns par√°grafos acima.  Mostra claramente a heterogeneidade estat√≠stica dos intervalos e a alta frequ√™ncia de valores pequenos em compara√ß√£o com os grandes.  No entanto, na segunda vis√£o mais convexa, o gr√°fico acaba sendo muito mais interessante (Fig. 8): <br></p><br><p><br><img src="https://habrastorage.org/webt/qm/4_/xu/qm4_xuzdshet30cdd9ucm7t4q0m.jpeg" alt="fig. 8"><br><br></p><br><p>  Inesperadamente, verifica-se que os intervalos mais freq√ºentes n√£o s√£o 2 e 4, como parecia ser de considera√ß√µes gerais, mas 6, 12 e 18, seguidos por 10 - e somente ent√£o 2 e 4 com frequ√™ncia quase igual (diferen√ßa em 7 d√≠gitos ap√≥s o ponto decimal).  Al√©m disso, a multiplicidade de valores de pico do n√∫mero 6 √© rastreada em todo o gr√°fico. <br></p><p></p><p>  Ainda mais interessante, essa natureza inadvertidamente revelada do gr√°fico √© universal - e, com todos os detalhes, com todas as suas tor√ß√µes - durante toda a sequ√™ncia de intervalos simples representados pela lista 1TPrimo, √© prov√°vel que seja universal para qualquer sequ√™ncia de intervalos simples (√© claro, uma afirma√ß√£o t√£o ousada precisa de provas, que com grande prazer transfiro para os ombros dos especialistas em teoria dos n√∫meros).  A Figura 10 mostra uma compara√ß√£o das estat√≠sticas do intervalo completo (linha escarlate) com amostras de intervalo limitadas coletadas em v√°rios locais arbitr√°rios na lista 1TPrimo (linhas de outras cores): <br></p><br><p><br><img src="https://habrastorage.org/webt/xs/jk/hd/xsjkhdqm8aztn2qztye3ftpf0yw.jpeg" alt="fig. 9"><br></p><br><p>  Pode-se ver neste gr√°fico que todas essas amostras se repetem exatamente, com apenas uma pequena diferen√ßa nas partes esquerda e direita da figura: elas parecem ser levemente giradas no sentido anti-hor√°rio em torno do ponto de intervalo com um valor de 24. Essa rota√ß√£o √© provavelmente devida ao fato de que quanto maior a esquerda partes dos gr√°ficos s√£o constru√≠das em amostras com profundidades de bits mais baixas.  Nessas amostras, ainda n√£o existem, ou grandes intervalos s√£o raros, que se tornam frequentes em amostras com profundidades de bits mais altas.  Consequentemente, sua aus√™ncia √© a favor da frequ√™ncia de intervalos com valores mais baixos.  Em amostras com profundidades de bits mais altas, muitos novos intervalos com grandes valores aparecem; portanto, a frequ√™ncia de intervalos menores diminui ligeiramente.  Muito provavelmente, o ponto de piv√¥, com um aumento no poder da lista, mudar√° para valores maiores.  Em algum lugar, pr√≥ximo a ele, est√° o ponto de equil√≠brio do gr√°fico, onde a soma de todos os valores √† direita √© aproximadamente igual √† soma de todos os valores √† esquerda. <br></p><p></p><p>  Essa natureza interessante da frequ√™ncia dos intervalos sugere abandonar a estrutura trivial dos c√≥digos de comprimento vari√°vel.  Normalmente, essa estrutura consiste em um pacote de bits de v√°rios comprimentos e finalidades.  Por exemplo, primeiro vem um certo n√∫mero de bits de prefixo definido para um valor espec√≠fico, por exemplo, 0. H√° um bit de parada atr√°s deles, que deve indicar a conclus√£o do prefixo e, portanto, deve diferir do prefixo: 1 nesse caso.  O prefixo pode n√£o ter nenhum comprimento, ou seja, repetidamente, a amostragem pode come√ßar imediatamente com um bit de parada, determinando assim a menor seq√º√™ncia.  O bit de parada √© geralmente seguido por um sufixo, cujo comprimento √© determinado de alguma maneira predeterminada pelo comprimento do prefixo.      ,       ,      ‚Äî        .      ,        -  .    -    (, , - )  ,          . <br></p><p></p><p>              ,   . <br></p><p></p><p> E aqui mais uma coisa importante deve ser declarada.  √Ä primeira vista, a ciclicidade observada implica a divis√£o dos intervalos em triplos: <code>{2,4, <b>6</b> }</code> , <code>{8,10, <b>12</b> }</code> , <code>{14,16, <b>18</b> }</code> e assim por diante (os valores com a frequ√™ncia m√°xima em cada tripla s√£o marcados em negrito) .  No entanto, de fato, o ciclo aqui √© um pouco diferente. <br></p><p></p><p>  N√£o citarei toda a linha de racioc√≠nio, que, de fato, n√£o existe: foi um palpite intuitivo, complementado por um m√©todo de enumera√ß√£o abrupta de op√ß√µes, c√°lculos e amostras que levou v√°rios dias intermitentemente.  A ciclicidade revelada como resultado consiste em <b>seis</b> intervalos <code>{2,4, <b>6</b> ,8,10, <b>12</b> }</code> , <code>{14,16, <b>18</b> ,20,22, <b>24</b> }</code> , <code>{26,28, <b>30</b> ,32,34, <b>36</b> }</code> e assim por diante (os intervalos de frequ√™ncia m√°xima s√£o novamente destacados em negrito). <br></p><p></p><p>  Em poucas palavras, o algoritmo de empacotamento proposto √© o seguinte. <br></p><p></p><p>  Dividir os intervalos em seis de n√∫meros pares nos permite representar qualquer intervalo <code>g</code> na forma <code>g = i * 12 + t</code> , onde <code>i</code> √© o √≠ndice dos seis aos quais esse intervalo pertence ( <code>i = {0,1,2,3, ...}</code> ) e <code>t</code> √© uma cauda que representa um dos valores de uma rigidamente definida, delimitada e id√™ntica para qualquer seis do conjunto <code>{2,4,6,8,10,12}</code> .  A resposta em frequ√™ncia do √≠ndice destacado acima √© quase exatamente inversamente proporcional ao seu valor, portanto, √© l√≥gico converter o √≠ndice seis em uma estrutura trivial de um c√≥digo de tamanho vari√°vel, um exemplo do que √© dado acima.  As caracter√≠sticas de frequ√™ncia do pin√ßa permitem dividi-lo em dois grupos que podem ser codificados com cadeias de bits de diferentes comprimentos: os valores 6 e 12, que s√£o mais frequentemente encontrados, s√£o codificados com um bit, os valores 2, 4, 8 e 10, encontrados com muito menos frequ√™ncia, s√£o codificados com dois bits.  Obviamente, √© necess√°rio mais um bit para distinguir entre essas duas op√ß√µes. <br></p><p></p><p>  Uma matriz contendo pacotes de bits √© complementada por campos fixos que especificam os valores iniciais dos dados apresentados no bloco e outras quantidades necess√°rias para restaurar uma sequ√™ncia ou simples arbitr√°ria de valores simples a partir dos intervalos armazenados no bloco. <br></p><p></p><p>  Al√©m dessa estrutura de √≠ndice de bloco, o uso de c√≥digos de comprimento vari√°vel √© complicado pelos custos adicionais em compara√ß√£o com intervalos de bits fixos. <br></p><p></p><p>  Ao usar intervalos de tamanho fixo, determinar o bloco no qual procurar um n√∫mero primo por seu n√∫mero de s√©rie √© uma tarefa bastante simples, porque o n√∫mero de intervalos por bloco √© conhecido antecipadamente.  Mas a busca de uma solu√ß√£o simples para o valor mais pr√≥ximo n√£o tem uma solu√ß√£o direta.  Como alternativa, voc√™ pode usar alguma f√≥rmula emp√≠rica que permita encontrar o n√∫mero aproximado do bloco com o intervalo necess√°rio, ap√≥s o qual ser√° necess√°rio procurar o bloco desejado por meio de uma pesquisa exaustiva. <br></p><p></p><p>  Para uma tabela com c√≥digos de comprimento vari√°vel, a mesma abordagem √© necess√°ria para as duas tarefas: tanto para buscar um valor por n√∫mero quanto para procurar por valor.  Como o comprimento dos c√≥digos varia, nunca se sabe de antem√£o quantas diferen√ßas est√£o armazenadas em um bloco espec√≠fico e em qual bloco o valor desejado est√°.  Foi determinado experimentalmente que, com um tamanho de bloco de 512 bytes (que inclui alguns bytes de cabe√ßalho), a capacidade do bloco pode subir de 10 a 12% do valor m√©dio.  Blocos menores d√£o uma dispers√£o relativa ainda maior.  Ao mesmo tempo, o valor m√©dio da capacidade do bloco tende a diminuir lentamente √† medida que a tabela cresce.  A sele√ß√£o de f√≥rmulas emp√≠ricas para determina√ß√£o imprecisa do bloco inicial para procurar o valor desejado, tanto por n√∫mero quanto por valor, √© uma tarefa n√£o trivial.  Como alternativa, voc√™ pode usar a indexa√ß√£o mais complexa e sofisticada. <br></p><p></p><p>  Isso, de fato, √© tudo. <br></p><p></p><p>  Abaixo, as sutilezas de compress√£o de uma tabela prim√°ria usando c√≥digos de comprimento vari√°vel e as estruturas associadas a ela s√£o descritas de maneira mais formal e detalhada, e √© fornecido o c√≥digo para as fun√ß√µes de intervalo de empacotamento e descompacta√ß√£o em C. <br></p><p></p><p>  O resultado. <br></p><p></p><p>  A quantidade de dados convertidos da Tabela 1TPrimo em c√≥digos de comprimento vari√°vel, complementados por uma estrutura de √≠ndice de bloco, tamb√©m descrita abaixo, totalizou 26.309.295.104 bytes (24,5 GB), ou seja, a taxa de compacta√ß√£o atinge 11,4.  Obviamente, com o aumento da profundidade de bits, a taxa de compress√£o aumentar√°. <br></p><p></p><p>  O tempo de transmiss√£o de 280 GB da tabela 1TPrimo no novo formato foi de 1 hora.  Este √© o resultado esperado ap√≥s experimentos com intervalos de compacta√ß√£o em n√∫meros inteiros de byte.  Nos dois casos, a convers√£o da tabela de origem consiste principalmente em opera√ß√µes de arquivo e quase n√£o carrega o processador (no segundo caso, a carga ainda √© maior devido √† maior complexidade computacional do algoritmo).  O tempo de acesso aos dados tamb√©m n√£o √© muito diferente dos intervalos de byte √∫nico, mas o tempo para descompactar um bloco completo do mesmo tamanho levou 1,5 Œºs, devido √† maior complexidade do algoritmo para extrair c√≥digos de tamanho vari√°vel. <br></p><p></p><p>  A tabela (Fig. 10) resume as caracter√≠sticas volum√©tricas das tabelas de n√∫meros primos mencionadas neste texto. <br></p><br><p><br><img src="https://habrastorage.org/webt/dc/jw/6o/dcjw6oz2efm88nqvzolxsz7mx6m.jpeg" alt="fig. 10"></p><br><p></p><p><br></p><h3>  Descri√ß√£o do algoritmo de compress√£o </h3><br><h4>  Termos e Nota√ß√£o </h4><br>  <code>P (prime): P1=3, P2=5, P3=7 ... Pn, Pn1</code> s√£o n√∫meros primos de acordo com seus n√∫meros de s√©rie.  Mais uma vez (e pela √∫ltima vez) enfatizo que <code>P0=2</code> √© um n√∫mero primo virtual;  por uma quest√£o de uniformidade formal, esse n√∫mero √© fisicamente exclu√≠do da lista de n√∫meros primos. <br><p></p><p>  <code>G (gap)</code> - o intervalo entre dois primos consecutivos <code>Gn = Pn1 - Pn; G={2,4,6,8 ...}</code>  <code>Gn = Pn1 - Pn; G={2,4,6,8 ...}</code> . <br></p><p></p><p>  <code>D (dense)</code> - reduzido a um intervalo de forma monol√≠tica: <code>D = G/2 -1; D={0,1,2,3 ...}</code>  <code>D = G/2 -1; D={0,1,2,3 ...}</code> .  Os seis intervalos na forma monol√≠tica se parecem com <code>{0,1,2,3,4,5}, {6,7,8,9,10,11}, {12,13,14,15,16,17}</code> etc. <br></p><p></p><p>  <code>Q (quotient)</code> - √≠ndice dos seis reduzido para uma forma monol√≠tica, <code>Q = D div 6; Q={0,1,2,3 ...}</code> <code>Q = D div 6; Q={0,1,2,3 ...}</code> <br></p><p></p><p>  <code>R (remainder)</code> - o restante dos seis monol√≠ticos <code>R = D mod 6. R</code> sempre tem um valor no intervalo <code>{0,1,2,3,4,5}</code> . <br></p><p></p><p>  Os valores <code>Q</code> e <code>R</code> obtidos pelo m√©todo acima a partir de qualquer intervalo arbitr√°rio <code>G</code> , devido √†s suas caracter√≠sticas de frequ√™ncia est√°veis, est√£o sujeitos a compress√£o e armazenamento na forma de pacotes de bits de comprimento vari√°vel, descritos abaixo.  As cadeias de bits que codificam os valores <code>Q</code> e <code>R</code> em um pacote s√£o criadas de diferentes maneiras: para codificar o √≠ndice <code>Q</code> , a cadeia de bits do prefixo <code>H</code> , fluxo <code>F</code> e o bit auxiliar <code>S</code> , e o grupo de bits do infixo <code>X</code> e do bit auxiliar <code>A</code> √© usado para codificar o restante <code>R</code> <br></p><p></p><p>  <code>A (arbiter)</code> - um bit que determina o tamanho do infixo <code>X</code> : 0 - infixo de um bit, 1 - dois bits. <br></p><p></p><p>  <code>X (infix)</code> - <code>X (infix)</code> 1 ou 2 bits, juntamente com o bit √°rbitro <code></code> , determinando mutuamente o valor de <code>R</code> forma tabular (a tabela tamb√©m mostra a frequ√™ncia dos seis primeiros com esses infixos para refer√™ncia): <br></p><br><p><br><img src="https://habrastorage.org/webt/kp/hk/a4/kphka4ymveajnxr8icfzgggln4e.jpeg" alt="bits de infixo"><br><br></p><br><p>  <code>F (fluxion)</code> √© uma fluxion, uma derivada do √≠ndice <code>Q</code> comprimento vari√°vel <code>L={0,1,2...}</code> , projetada para distinguir entre a sem√¢ntica das strings de bits <code>(), 0, 00, 000,</code> ou <code>1, 01, 001</code> , etc. d. <br></p><p></p><p>  Uma cadeia de bits de unidades de comprimento <code>L</code> √© expressa como <code>2^L - 1</code> (o sinal <code>^</code> significa exponencia√ß√£o).  Na nota√ß√£o C, o mesmo valor pode ser obtido pela express√£o <code>1&lt;&lt;L - 1</code> .  Ent√£o o valor da fluxia de comprimento <code>L</code> pode ser obtido de <code>Q</code> express√£o <br></p><p></p><p></p><pre> F = Q - (1 &lt;&lt; L - 1),
</pre><p></p><p>  e restaurar <code>Q</code> da fluxia por express√£o <br></p><p></p><p></p><pre> Q = (1 &lt;&lt; L - 1) + F.
</pre><p></p><p>  Como exemplo, para as quantidades <code>Q = {0..15}</code> , as seguintes cadeias de bits fluxia ser√£o obtidas: <br></p><br><p><br><img src="https://habrastorage.org/webt/j0/kb/4y/j0kb4y3ob_yutugxxvpwlddqofc.jpeg" alt="bits de fluxo"><br><br></p><br><p>  Os √∫ltimos dois campos de bits necess√°rios para compactar / restaurar valores s√£o: <br></p><p></p><p>  <code>H (header)</code> - prefixo, uma sequ√™ncia de bits definida como 0. <br></p><p></p><p>  <code>S (stop)</code> - bit de parada definido como 1, finalizando o prefixo. <br></p><p></p><p>  De fato, esses bits s√£o processados ‚Äã‚Äãprimeiro em cadeias de bits, permitindo determinar durante a descompacta√ß√£o ou definir durante o empacotamento o tamanho do fluxo e o in√≠cio dos campos de √°rbitro e fluxo - imediatamente ap√≥s o bit de parada. <br></p><p></p><p>  <code>W (width)</code> - a largura do c√≥digo inteiro em bits. <br></p><p></p><p>  A estrutura completa do pacote de bits √© mostrada na Fig. 11: <br></p><br><p><br><img src="https://habrastorage.org/webt/ke/7u/tz/ke7utzoka0xkdd9dzzux6yden7e.jpeg" alt="fig. 11"><br><br></p><br><p>  Os valores de <code>Q</code> e <code>R</code> recuperados dessas cadeias nos permitem restaurar o valor inicial do intervalo: <br></p><p></p><p></p><pre> D = Q * 6 + R,
 G = (D + 1) * 2,
</pre><p></p><p>  e a sequ√™ncia de intervalos restaurados permite restaurar os n√∫meros primos originais de um determinado valor base do bloco (bloco inicial de intervalos), adicionando a ele todos os intervalos de um determinado bloco sequencialmente. <br></p><p></p><p>  Para trabalhar com cadeias de bits, √© usada uma vari√°vel inteira de 32 bits, na qual os bits menos significativos s√£o processados ‚Äã‚Äãe, ap√≥s us√°-los, os bits s√£o deslocados para a esquerda ao empacotar ou para a direita ao descompactar. <br></p><p></p><br><h4>  Estrutura de bloco </h4><br><p></p><p>  Al√©m das cadeias de bits, um bloco cont√©m informa√ß√µes necess√°rias para buscar ou adicionar bits, al√©m de determinar o conte√∫do de um bloco. <br></p><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    typedef unsigned char BYTE; typedef unsigned short WORD; typedef unsigned int LONG; typedef unsigned long long HUGE; typedef int BOOL; #define TRUE 1 #define FALSE 0 #define BLOCKSIZE (256) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ :   , #define HEADSIZE (8+8+2+2+2) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   , #define BODYSIZE (BLOCKSIZE-HEADSIZE) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/           typedef struct { HUGE base; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,      HUGE card; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        WORD count; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      WORD delta; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ base+delta =      WORD offset; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        BYTE body[BODYSIZE]; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    } crunch_block; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,   put()  get() crunch_block block; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ NB:  len/val</span></span>  rev/rel     /<span class="hljs-regexp"><span class="hljs-regexp">/  ,    ,   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . static struct tail_t { BYTE len; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      S  A BYTE val; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,   A  - S BYTE rev; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    BYTE rel; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    } tails[6] = { { 4, 3, 2, 3 }, { 4, 7, 5, 3 }, { 3, 1, 0, 4 }, { 4,11, 1, 4 }, { 4,15, 3, 4 }, { 3, 5, 4, 4 } }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/             BOOL put(int gap) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1.      int Q, R, L; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   (),  (),   int val = gap /</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; Q = val / <span class="hljs-number"><span class="hljs-number">6</span></span>; R = val % <span class="hljs-number"><span class="hljs-number">6</span></span>; L = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .., <span class="hljs-number"><span class="hljs-number">0</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> val = Q + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (val) { val <span class="hljs-meta"><span class="hljs-meta">&gt;&gt;= </span></span><span class="hljs-number"><span class="hljs-number">1</span></span>; L++; } /<span class="hljs-regexp"><span class="hljs-regexp">/    L val = Q - (1 &lt;&lt; L) + 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  val &lt;&lt;= tails[R].len; val += tails[R].val; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      val &lt;&lt;= L; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   L += L + tails[R].len; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2.   val  L   buffer   put_index if (block.offset + L &gt; BODYSIZE * 8) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ !      return FALSE; Q = (block.offset /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,      R = block.offset % <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     block.offset += L; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      block.count++; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     block.delta += gap; if (R &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/        { val &lt;&lt;= R; val |= block.body[Q]; L += R; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     L = L /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> + ((L % <span class="hljs-number"><span class="hljs-number">8</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     while (L-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { block.body[Q++] = (char)val; val &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } return TRUE; } /<span class="hljs-regexp"><span class="hljs-regexp">/          int get_index; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      int get() { if (get_index &gt;= BODYSIZE * 8) return 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      int val = *((int*)&amp;block.body[get_index /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>]) &gt;&gt; get_index % <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-number"><span class="hljs-number">4</span></span>   if (val == <span class="hljs-number"><span class="hljs-number">0</span></span>) return -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> !       int Q, R, L, F, M, len; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> , , , ,     L = <span class="hljs-number"><span class="hljs-number">0</span></span>; while (!(val &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>)) { val &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; L++; } /<span class="hljs-regexp"><span class="hljs-regexp">/  -     if ((val &amp; 3) == 1) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       R = (val &gt;&gt; 2) &amp; 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   else R = ((val &gt;&gt; 2) &amp; 3) + 2; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   len = tails[R].rel; get_index += 2 * L + len; val &gt;&gt;= len; M = ((1 &lt;&lt; L) - 1); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   F = val &amp; M; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    Q = F + M; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   return 2 * (1 + (6 * Q + tails[R].rev)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         }</span></span></code> </pre><br><p></p><br><h4>  Aprimoramentos </h4><br><p></p><p>  Se alimentarmos a base de intervalos obtida para o mesmo arquivador de 7 zip, em uma hora e meia de trabalho intensivo em um servidor de 8 n√∫cleos, ele poder√° compactar o arquivo de entrada em quase 5%.  Ou seja, no banco de dados de intervalos de comprimento vari√°vel do ponto de vista do arquivador, ainda existe alguma redund√¢ncia.  Portanto, h√° motivos para especular um pouco (no bom sentido da palavra) sobre o t√≥pico de reduzir ainda mais a redund√¢ncia de dados. <br></p><p></p><p>  O determinismo fundamental da sequ√™ncia de intervalos entre os n√∫meros primos torna poss√≠vel fazer c√°lculos exatos da efici√™ncia da codifica√ß√£o por um m√©todo ou por outro.  Em particular, pequenos esbo√ßos (e um tanto ca√≥ticos) permitiram tirar uma conclus√£o fundamental sobre as vantagens da codifica√ß√£o de seis sobre triplos e sobre as vantagens do m√©todo proposto sobre c√≥digos triviais de comprimento vari√°vel (Fig. 12): <br></p><br><p><br><img src="https://habrastorage.org/webt/w9/_l/9q/w9_l9qaibojgrxt5izuw4j7lxzc.jpeg" alt="fig. 12"><br><br></p><br><p>  No entanto, os altos irritantes do gr√°fico vermelho indicam de forma transparente que pode haver outros m√©todos de codifica√ß√£o que tornariam o gr√°fico ainda mais suave. <br></p><p></p><p>  Outra dire√ß√£o sugere verificar a frequ√™ncia de intervalos consecutivos.  De considera√ß√µes gerais: como os intervalos 6, 12 e 18 s√£o os mais comuns em uma popula√ß√£o de n√∫meros primos, √© prov√°vel que sejam encontrados com mais frequ√™ncia em pares (dupletos), triplos (trig√™meos) e combina√ß√µes semelhantes de intervalos.  Se a repetibilidade de dupletos (e talvez at√© trig√™meos ... bem, de repente!) Acaba sendo estatisticamente significativa na massa total de intervalos, faz sentido traduzi-los em algum c√≥digo separado. <br></p><p></p><p>  O experimento em grande escala revela uma certa predomin√¢ncia de dupletos individuais sobre outros.  No entanto, se a lideran√ßa absoluta for esperada para o par <code>(6,6)</code> - 1,37% de todos os dupletos - os outros vencedores desta classifica√ß√£o ser√£o muito menos √≥bvios: <br></p><p><br><img src="https://habrastorage.org/webt/4m/jq/o-/4mjqo-jyxt27cpw6e6bnasgxl0s.jpeg" alt="estat√≠sticas de doublet"><br><br></p><br><p>  E, como o dupleto <code>(6,6)</code> sim√©trico, e todos os outros dupletos observados s√£o assim√©tricos e s√£o encontrados no ranking por duplas espelhadas com a mesma frequ√™ncia, parece que o registro recorde do dupleto <code>(6,6)</code> nesta s√©rie deve ser dividido pela metade entre duplos indistingu√≠veis <code>(6,6)</code> e <code>(6,6)</code> , o que leva 0,68% at√© o limite da lista de pr√™mios.  E isso confirma mais uma vez a observa√ß√£o de que nenhuma hip√≥tese verdadeira sobre n√∫meros primos pode acontecer sem surpresas. <br></p><p></p><p>  As estat√≠sticas dos trig√™meos tamb√©m demonstram a lideran√ßa de tais triplos intervalos, que n√£o se encaixam perfeitamente na suposi√ß√£o especulativa procedente da maior frequ√™ncia dos intervalos 6, 12, 18. Em ordem decrescente de popularidade, os l√≠deres de frequ√™ncia entre os trig√™meos s√£o os seguintes: <br></p><p><br><img src="https://habrastorage.org/webt/nn/if/sw/nnifswq5tugkq5kypoe44qllyj4.jpeg" alt="estat√≠sticas triplas"><br><br></p><p>  etc. <br></p><p></p><p>  Receio, no entanto, que os resultados de minhas especula√ß√µes sejam menos interessantes para os programadores do que para os matem√°ticos, talvez por causa das corre√ß√µes inesperadas feitas pela pr√°tica em suposi√ß√µes intuitivas.  √â improv√°vel que seja poss√≠vel extrair qualquer dividendo substancial da porcentagem mencionada de frequ√™ncia em favor de um aumento adicional na taxa de compacta√ß√£o, enquanto a complexidade do algoritmo amea√ßa crescer muito significativamente. <br></p><p></p><p></p><h4>  Limita√ß√µes </h4><br><p></p><p>  J√° foi observado acima que o aumento no valor m√°ximo dos intervalos em conex√£o com a capacidade dos n√∫meros primos √© muito, muito lento.  Em particular, pode ser visto na Fig. 6 que o intervalo entre quaisquer primos que podem ser representados no formato de um n√∫mero inteiro n√£o assinado de 64 bits ser√° obviamente menor que 1600. <br></p><p></p><p>  A implementa√ß√£o descrita permite empacotar e descompactar corretamente os valores de intervalo de 18 bits (na verdade, o primeiro erro de empacotamento ocorre com um intervalo de entrada de 442358).  N√£o tenho imagina√ß√£o suficiente para supor que o banco de dados de intervalos primos possa crescer para esses valores: de improviso, √© algo em torno de n√∫meros inteiros de 100 bits e para calcular com mais precis√£o a pregui√ßa.  Em um caso de inc√™ndio, expandir o intervalo de intervalos √†s vezes n√£o ser√° dif√≠cil. <br></p><p></p><p>  Obrigado por ler neste lugar :) <br></p><br><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt417753/">https://habr.com/ru/post/pt417753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt417743/index.html">Amplificadores lend√°rios - Anatomia da tend√™ncia hist√≥rica: Cold Transistor Sound</a></li>
<li><a href="../pt417745/index.html">Experi√™ncia Pessoal: Engenharia de Dados na Upwork</a></li>
<li><a href="../pt417747/index.html">Re: ‚ÄúCompara√ß√£o de frameworks JS: React, Vue e Hyperapp‚Äù</a></li>
<li><a href="../pt417749/index.html">Projeto Loon como projeto comercial: o primeiro contrato √© assinado</a></li>
<li><a href="../pt417751/index.html">Kunstkamera: E-meter - Dispositivo de Scientology para medir thetans</a></li>
<li><a href="../pt417755/index.html">Estudo: 80% das OICs de 2017 s√£o consideradas fraudulentas</a></li>
<li><a href="../pt417757/index.html">Criando um bot para participar do mini cup da AI. Experi√™ncia GPU</a></li>
<li><a href="../pt417759/index.html">Seja meu pato de borracha</a></li>
<li><a href="../pt417761/index.html">O GitLab est√° migrando do Azure para o Google Cloud Platform. Not√≠cias sobre mudan√ßas e datas de manuten√ß√£o</a></li>
<li><a href="../pt417763/index.html">MVIDroid: uma revis√£o da nova biblioteca MVI (Model-View-Intent)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>