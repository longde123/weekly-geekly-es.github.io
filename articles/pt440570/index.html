<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎤 👩🏾‍💼 👨🏼‍⚕️ Mapas de Sombra Reflexiva: Parte 2 - Implementação 👩‍👩‍👧‍👧 👩🏻‍🔬 👨🏾‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! Este artigo apresenta uma implementação simples do Reflective Shadow Maps (o algoritmo é descrito em um artigo anterior ). A seguir, explica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapas de Sombra Reflexiva: Parte 2 - Implementação</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440570/">  Olá Habr!  Este artigo apresenta uma implementação simples do <b>Reflective Shadow Maps</b> (o algoritmo é descrito em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> ).  A seguir, explicarei como fiz e quais foram as armadilhas.  Algumas possíveis otimizações também serão consideradas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/80f/588/6da/80f5886da498099f2e9716d4c0a53e3d.png" alt="imagem"><br>  <i>Figura 1: Da esquerda para a direita: sem RSM, com RSM, diferença</i> <br><a name="habracut"></a><br><h2>  Resultado </h2><br>  Na <i>Figura 1,</i> você pode ver o resultado obtido usando o <b>RSM</b> .  Para criar essas imagens, foram utilizados o "Stanford Rabbit" e três quadrângulos multicoloridos.  Na imagem à esquerda, você pode ver o resultado da renderização sem <b>RSM</b> , usando apenas a <b>luz do ponto</b> .  Tudo na sombra é completamente preto.  A imagem no centro mostra o resultado com o <b>RSM</b> .  As seguintes diferenças são notáveis: em todos os lugares há cores mais brilhantes, rosa, inundando o chão e o coelho, o sombreamento não é completamente preto.  A última imagem mostra a diferença entre a primeira e a segunda e, portanto, a contribuição do <b>RSM</b> .  Bordas e artefatos mais apertados são visíveis na imagem do meio, mas isso pode ser resolvido ajustando o tamanho do núcleo, a intensidade da iluminação indireta e o número de amostras. <br><br><h2>  Implementação </h2><br>  O algoritmo foi implementado em seu próprio mecanismo.  Os shaders são escritos em HLSL e a renderização é no DirectX 11. Eu já configurei <b>sombreamento adiado</b> e <b>mapeamento de sombra</b> para luz direcional (fonte de luz direcional) antes de escrever este artigo.  Primeiro, implementei o <b>RSM</b> para luz direcional e somente depois de adicionar suporte para o <b>mapa de sombras</b> e o <b>RSM</b> para luz pontual. <br><br><h3>  Extensão do mapa de sombra </h3><br>  Tradicionalmente, o <b>Shadow Maps</b> (SM) nada mais é do que um mapa de profundidade.  Isso significa que você nem precisa de um sombreador de pixel / fragmento para preencher o SM.  No entanto, para o <b>RSM,</b> você precisará de alguns buffers extras.  Você precisa armazenar a <b>posição do</b> espaço no mundo, o espaço <b>no</b> mundo <b>normal</b> e o <b>fluxo</b> ( <b>emissão de</b> luz).  Isso significa que você precisa de um sombreador de pixel / fragmento com vários destinos de renderização.  Lembre-se de que, para esta técnica, é necessário cortar a <b>seleção</b> do <b>rosto</b> , não a frente. <br><br>  O uso das arestas frontais da <b>separação de</b> faces é uma maneira amplamente usada para evitar artefatos de sombra, mas isso não funciona com o <b>RSM</b> . <br><br>  Você passa as posições e normais do espaço mundial para o pixel shader e as grava nos buffers apropriados.  Se você usar <b>o mapeamento normal</b> , também calcule-os no pixel shader.  <b>O fluxo é</b> calculado lá, multiplicando o material albedo pela cor da fonte de luz.  Para a <b>luz do ponto,</b> você precisa multiplicar o valor resultante pelo ângulo de incidência.  Para <b>luz direcional,</b> é obtida <b>uma</b> imagem não sombreada. <br><br><h3>  Preparando para o cálculo da iluminação </h3><br>  Há algumas coisas que você precisa fazer para a passagem principal.  Você deve vincular todos os buffers usados ​​na sombra como texturas.  Você também precisa de números aleatórios.  O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo oficial</a> diz que você precisa pré-calcular esses números e salvá-los no buffer para reduzir o número de operações no passo de amostragem do <b>RSM</b> .  Como o algoritmo é pesado em termos de desempenho, concordo totalmente com o artigo oficial.  Também é recomendável aderir à coerência temporal (use o mesmo padrão de amostragem para todos os cálculos de iluminação indireta).  Isso evitará oscilações quando cada quadro usar uma sombra diferente. <br><br>  Você precisa de dois números aleatórios de ponto flutuante no intervalo [0, 1] para cada amostra.  Esses números aleatórios serão usados ​​para determinar as coordenadas da amostra.  Você também precisará da mesma matriz usada para converter posições do espaço do mundo (espaço do mundo) em espaço da sombra (espaço da fonte de luz).  Você também precisará desses parâmetros para amostragem, o que dará uma cor preta se você fizer uma amostra além das bordas da textura. <br><br><h3>  Iluminação de passagem </h3><br>  Agora a parte mais difícil de entender.  Eu recomendo que você calcule a iluminação indireta depois de calcular a iluminação direta para uma fonte de luz específica.  Isso ocorre porque você precisa de um quad em tela cheia para <b>luz direcional</b> .  No entanto, para <b>luzes pontuais</b> e <b>pontuais,</b> geralmente você deseja usar malhas de uma determinada forma com <b>seleção</b> para preencher menos pixels. <br><br>  No código abaixo, a iluminação indireta é calculada para o pixel.  A seguir, explicarei o que está acontecendo lá. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReflectiveShadowMapping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 P, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divideByW, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ float4 textureSpacePosition = mul(lightViewProjectionTextureMatrix, float4(P, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divideByW) textureSpacePosition.xyz /= textureSpacePosition.w; float3 indirectIllumination = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rMax = rsmRMax; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rsmSampleCount; ++i) { float2 rnd = rsmSamples[i].xy; float2 coords = textureSpacePosition.xy + rMax * rnd; float3 vplPositionWS = g_rsmPositionWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 vplNormalWS = g_rsmNormalWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 flux = g_rsmFluxMap.Sample(g_clampedSampler, coords.xy).xyz; float3 result = flux * ((max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(vplNormalWS, P – vplPositionWS)) * max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, vplPositionWS – P))) / <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(length(P – vplPositionWS), <span class="hljs-number"><span class="hljs-number">4</span></span>)); result *= rnd.x * rnd.x; indirectIllumination += result; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(indirectIllumination * rsmIntensity); }</code> </pre> <br>  O primeiro argumento para a função é <b>P</b> , que é a posição do espaço do mundo (no espaço do mundo) para um pixel específico.  <b>DivideByW é</b> usado para a divisão prospectiva necessária para obter o valor <b>Z</b> correto.  <b>N</b> é o espaço do mundo normal. <br><br><pre> <code class="cpp hljs">float4 textureSpacePosition = mul(lightViewProjectionTextureMatrix, float4(P, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divideByW) textureSpacePosition.xyz /= textureSpacePosition.w; float3 indirectIllumination = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rMax = rsmRMax;</code> </pre><br>  Nesta parte do código, a posição do espaço de luz (em relação à fonte de luz) é calculada, a variável de iluminação indireta é inicializada, na qual os valores calculados de cada amostra serão somados e a variável <b>rMax</b> é <b>definida a</b> partir da equação de iluminação do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo oficial</a> , cujo valor explicarei na próxima seção. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rsmSampleCount; ++i) { float2 rnd = rsmSamples[i].xy; float2 coords = textureSpacePosition.xy + rMax * rnd; float3 vplPositionWS = g_rsmPositionWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 vplNormalWS = g_rsmNormalWsMap .Sample(g_clampedSampler, coords.xy).xyz; float3 flux = g_rsmFluxMap.Sample(g_clampedSampler, coords.xy).xyz;</code> </pre><br>  Aqui começamos o ciclo e preparamos nossas variáveis ​​para a equação.  Para fins de otimização, as amostras aleatórias que calculei já contêm deslocamentos de coordenadas, ou seja, para obter as coordenadas UV, só preciso adicionar <b>rMax * rnd</b> às coordenadas do espaço de luz.  Se os UVs resultantes estiverem fora da faixa [0,1], as amostras devem ser pretas.  O que é lógico, pois eles vão além do alcance da iluminação. <br><br><pre> <code class="cpp hljs"> float3 result = flux * ((max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(vplNormalWS, P – vplPositionWS)) * max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, vplPositionWS – P))) / <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(length(P – vplPositionWS), <span class="hljs-number"><span class="hljs-number">4</span></span>)); result *= rnd.x * rnd.x; indirectIllumination += result; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(indirectIllumination * rsmIntensity);</code> </pre><br>  Essa é a parte em que a equação de iluminação indireta é calculada ( <i>Figura 2</i> ) e também pesada de acordo com a distância da coordenada espaço-luz à amostra.  A equação parece intimidadora, e o código não ajuda a entender tudo, então vou explicar com mais detalhes. <br><br>  A variável <b>Φ</b> (phi) é o <b>fluxo de</b> luz, que é a intensidade da radiação.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O artigo anterior</a> descreve o <b>fluxo com</b> mais detalhes. <br><br>  Escalas de <b>fluxo</b> com duas obras de arte escalares.  O primeiro é entre o normal da fonte de luz (texel) e a direção da fonte de luz para a posição atual.  O segundo está entre o vetor corrente normal e o vetor de direção da posição atual para a posição da fonte de luz (texel).  Para não fazer uma contribuição negativa à iluminação (se o pixel não estiver aceso), os produtos escalares são limitados ao intervalo [0, ∞].  Nesta equação, a normalização é feita no final, suponho, por razões de desempenho.  É igualmente aceitável normalizar vetores de direção antes de executar produtos escalares. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab4/dd3/258/ab4dd3258620fc3bae4a044df4072cf5.png" alt="imagem"><br>  <i>Figura 2: Equação da iluminância de um ponto com posição <b>xe</b> fonte de luz de pixel direcional <b>n</b> normal <b>p</b></i> <br><br>  O resultado desse passe pode ser misturado com um backbuffer (iluminação direta) e o resultado será como na <i>Figura 1</i> . <br><br><h2>  Armadilhas </h2><br>  Ao implementar esse algoritmo, tive alguns problemas.  Vou falar sobre esses problemas para que você não pise no mesmo rake. <br><br><h3>  Amostrador errado </h3><br>  Passei um tempo considerável descobrindo por que minha iluminação indireta parecia repetitiva.  As texturas da Crytek Sponza estão ocultas, então você precisa de um amostrador para isso.  Mas para o <b>RSM</b> não é muito adequado. <br><br><div class="spoiler">  <b class="spoiler_title">Opengl</b> <div class="spoiler_text">  OpenGL define texturas <b>RSM</b> para GL_CLAMP_TO_BORDER <br></div></div><br><h3>  Valores personalizados </h3><br>  Para melhorar o fluxo de trabalho, é importante poder alterar algumas variáveis ​​pressionando um botão.  Por exemplo, a intensidade da iluminação indireta e o intervalo de amostragem ( <b>rMax</b> ).  Esses parâmetros devem ser ajustados para cada fonte de luz.  Se você possui uma ampla faixa de amostragem, obtém iluminação indireta de qualquer lugar, o que é útil para cenas grandes.  Para mais iluminação indireta local, você precisará de um alcance menor.  <i>A Figura 3</i> mostra a iluminação indireta global e local. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/c98/7f7/a08c987f7a9bf46344a623bafebfc903.png" alt="imagem"><br>  <i>Figura 3: Demonstração da dependência do <b>rMax</b> .</i> <br><br><h3>  Passagem separada </h3><br>  No começo, pensei em fazer iluminação indireta em um sombreador, no qual considero a iluminação direta.  Para <b>luz direcional,</b> isso funciona porque você ainda desenha um quad em tela cheia.  No entanto, para <b>luzes pontuais</b> e <b>pontuais,</b> é necessário otimizar o cálculo da iluminação indireta.  Portanto, considerei a iluminação indireta uma passagem separada, necessária se você também quiser fazer <b>a interpolação do espaço da tela</b> . <br><br><h3>  Cache </h3><br>  Esse algoritmo não é amigável com o cache.  Ele realiza amostragem em pontos aleatórios em várias texturas.  O número de amostras sem otimizações também é inaceitavelmente grande.  Com uma resolução de 1280 * 720 e o número de amostras <b>RSM</b> 400, você fará 1.105.920.000 amostras para cada fonte de luz. <br><br><h3>  Os prós e contras </h3><br>  Vou listar os prós e contras desse algoritmo de cálculo de iluminação indireta. <br><table><tbody><tr><td>  Para </td><td>  <b>Contra</b> </td></tr><tr><td>  Algoritmo fácil de entender </td><td>  Não é amigo do cache </td></tr><tr><td>  Integra-se bem ao renderizador diferido </td><td>  Configuração variável necessária </td></tr><tr><td>  Pode ser usado em outros algoritmos ( <b>LPV</b> ) </td><td>  Escolha forçada entre iluminação indireta local e global </td></tr></tbody></table><h2>  Otimizações </h2><br>  Fiz várias tentativas para aumentar a velocidade desse algoritmo.  Conforme descrito no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo oficial</a> , você pode implementar <b>a interpolação do espaço da tela</b> .  Eu fiz isso e processando um pouco mais rápido.  Abaixo, descreverei algumas otimizações e farei uma comparação (em quadros por segundo) entre as seguintes implementações, usando uma cena com 3 paredes e um coelho: sem <b>RSM</b> , implementação ingênua do <b>RSM</b> , interpolada pelo <b>RSM</b> . <br><br><h3>  Z-check </h3><br>  Uma das razões pelas quais meu <b>RSM</b> funcionou de maneira ineficiente foi porque também calculei a iluminação indireta para pixels que faziam parte do skybox.  Skybox definitivamente não precisa disso. <br><br><h3>  Amostragem aleatória da CPU </h3><br>  O cálculo preliminar de amostras não apenas fornecerá maior coerência temporal, como também evitará que você precise recalcular essas amostras no shader. <br><br><h3>  Interpolação espaço-tela </h3><br>  Um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo oficial</a> sugere o uso do alvo de renderização em baixa resolução para calcular a iluminação indireta.  Para cenas com muitas normais suaves e paredes retas, as informações de iluminação podem ser facilmente interpoladas entre os pontos com menor resolução.  Não descreverei a interpolação em detalhes, para que este artigo seja um pouco mais curto. <br><br><h2>  Conclusão </h2><br>  Abaixo estão os resultados para um número diferente de amostras.  Tenho alguns comentários sobre esses resultados: <br><br><ul><li>  Logicamente, o FPS permanece em torno de 700 para um número diferente de amostras quando o cálculo do <b>RSM</b> não é executado. </li><li>  A interpolação fornece alguma sobrecarga e não é muito útil com um pequeno número de amostras. </li><li>  Mesmo com 100 amostras, a imagem final parecia muito boa.  Isso pode ser devido à interpolação, que "borra" a iluminação indireta. </li></ul><br><table><tbody><tr><td>  Contagem de amostras </td><td>  FPS sem RSM </td><td>  FPS para Naive RSM </td><td>  FPS para RSM interpolado </td></tr><tr><td>  100 </td><td>  ~ 700 </td><td>  152 </td><td>  264 </td></tr><tr><td>  200 </td><td>  ~ 700 </td><td>  89 </td><td>  179 </td></tr><tr><td>  300 </td><td>  ~ 700 </td><td>  62 </td><td>  138 </td></tr><tr><td>  400 </td><td>  ~ 700 </td><td>  44 </td><td>  116 </td></tr></tbody></table></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440570/">https://habr.com/ru/post/pt440570/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440560/index.html">Alexander Belokrylov e Dmitry Chuyko sobre o Liberica JDK em jug.msk.ru</a></li>
<li><a href="../pt440562/index.html">Windows Phone - TUDO, é de novo ou de novo</a></li>
<li><a href="../pt440564/index.html">Rede neural GPT-2 da OpenAI. Início rápido</a></li>
<li><a href="../pt440566/index.html">Acelerando sem obstáculos ou conhecendo o SIMD</a></li>
<li><a href="../pt440568/index.html">Estamos escrevendo um aplicativo de aprendizado em Go e Javascript para avaliar o retorno real das ações. Parte 2 - Testando o back-end</a></li>
<li><a href="../pt440574/index.html">Russian AI Cup 2018, história 9 lugares</a></li>
<li><a href="../pt440576/index.html">Alterações importantes no CTE no PostgreSQL 12</a></li>
<li><a href="../pt440582/index.html">Os carros elétricos são puxados para o fundo da corporação automobilística?</a></li>
<li><a href="../pt440584/index.html">O que há de errado com o Raspberry Pi</a></li>
<li><a href="../pt440586/index.html">Consenso Exonum: Como Funciona</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>