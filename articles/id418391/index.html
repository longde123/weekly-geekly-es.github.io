<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤™ğŸ¼ ğŸ‘§ğŸ¼ ğŸ› OSPF (Bagian Satu) ğŸ‘¦ğŸ½ ğŸ¤›ğŸ½ ğŸ˜¯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini ditulis untuk saya sendiri, sehingga, jika perlu, segarkan ingatan saya dengan cepat dan pahami teorinya. Saya memutuskan untuk menerbitka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OSPF (Bagian Satu)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418391/"> Artikel ini ditulis untuk saya sendiri, sehingga, jika perlu, segarkan ingatan saya dengan cepat dan pahami teorinya.  Saya memutuskan untuk menerbitkannya, mungkin itu akan berguna bagi seseorang, atau mungkin saya keliru dalam sesuatu. <br><br>  Pada artikel ini kita akan mencoba memahami teori protokol OSPF.  Kami tidak akan menyelidiki sejarah dan proses pembuatan protokol, informasi ini berlimpah di hampir setiap artikel tentang OSPF.  Kami akan mencoba memahami secara lebih rinci bagaimana OSPF bekerja dan bagaimana ia membangun tabel peruteannya.  Penting untuk memberikan definisi umum tentang protokol: <br><br>  <b>OSPF</b> (Open Shortest Path First) adalah protokol routing dinamis yang didasarkan pada teknologi link-state dan menggunakan algoritma Dijkstra untuk menemukan jalur terpendek. <br><br>  Pertanyaan segera muncul - Apa itu teknologi pelacakan saluran?  Saya pikir nama ini tidak sepenuhnya berhasil.  Kebetulan ada dua jenis protokol routing dinamis: Link-state dan Distance-Vector.  Pertimbangkan prinsip kerja mereka: <br><br>  Dalam protokol Distance-Vector, router mengenali informasi rute melalui router yang terhubung langsung ke segmen jaringan yang sama.  Yaitu, router memiliki informasi tentang topologi hanya dalam batas-batas router tetangganya dan tidak tahu bagaimana topologi di belakang router ini diatur, dengan fokus hanya pada metrik.  Dalam protokol Link-state, setiap router seharusnya tidak dengan mudah mengetahui rute terbaik ke semua jaringan jarak jauh, tetapi juga memiliki dalam memori peta jaringan yang lengkap dengan semua koneksi yang ada antara router lain termasuk.  Ini dicapai dengan membangun basis LSDB khusus, tetapi lebih lanjut tentang ini nanti. <br><a name="habracut"></a><br>  Jadi, mari kita mulai dengan bagaimana LSDB dibangun dari mana router belajar tentang semua rute?  Kami membangun topologi awal untuk studi.  Ini terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea4/c83/539/ea4c835392207c07ca33dd8ec883a707.jpg" alt="gambar"><br><br>  Kami akan mengkonfigurasi OSPF.  Di mana OSPF dimulai?  C membuat lingkungan antar router - setelah mengaktifkan OSPF pada antarmuka router, router mulai mengirim pesan Hello.  Pesan ini dikirim ke alamat multicast - 224.0.0.5 setiap 10 detik (Halo Timer).  Kami akan mengaktifkan OSPF pada router vIOS1 terlebih dahulu. <br><br>  Mari kita lihat seperti apa paket Hello: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ca/3bf/881/6ca3bf881cddaf569bdfb54bd3913666.jpg" alt="gambar"><br><br>  Dalam pesan tersebut, penting untuk memperhatikan bidang-bidang seperti Area ID, Source OSPF Router.  Ketika proses OSPF dimulai, ID Router dipilih, yang diperlukan untuk mengidentifikasi router di antara router OSPF lainnya.  Aturan untuk memilih parameter ini adalah sebagai berikut: <br><br>  1. Dikonfigurasi oleh ABCD perintah router-id khusus - dalam format alamat ip. <br>  2. Satu antarmuka loopback dan beberapa antarmuka dengan alamat berbeda dikonfigurasikan: <br><br><ul><li>  Alamat yang diberikan ke antarmuka loopback akan menjadi Router ID. </li></ul><br>  3. Konfigurasi beberapa antarmuka loopback dengan beberapa alamat IP di masing-masing: <br><br><ul><li>  Alamat IP tertinggi yang diberikan pada antarmuka loopback adalah Router ID. </li></ul><br>  4. Mengkonfigurasi beberapa antarmuka dengan alamat IP pada masing-masing: <br><br><ul><li>  Alamat IP terbesar dari semua antarmuka aktif adalah Router ID. </li></ul><br>  Sekarang mari kita beralih ke bidang ID Area - ini adalah konsep yang lebih penting dan mendasar dalam OSPF.  Untuk bekerja dengan sejumlah besar router, OSPF menggunakan zona.  Setiap antarmuka router harus dimiliki oleh salah satu zona.  Dalam topologi kami, antarmuka Gi0 / 0 dari vIOS1, vIOS2, vIOS3, router vIOS4 milik zona 0. Area 0 disebut Backbone dan merupakan pusat untuk semua zona lainnya.  Setiap zona lain harus terhubung ke zona Backbone (virtual-link belum dipertimbangkan).  Dalam analisis lebih lanjut, konsep-konsep ini akan menjadi lebih jelas. <br><br>  Jadi, kami menyalakan OSPF pada vIOS1 dan mulai mengirim paket Hello setiap 10 detik.  Nyalakan OSPF pada vIOS2 dan lihat bagaimana hubungan tetangga dibuat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c3/721/8d4/9c37218d473f4f96d9c762300ed21bd1.jpg" alt="gambar"><br><br>  Jadi, kami dengan hati-hati memantau urutan pesan.  Pertama, Hello hanya mengirim router 1.1.1.1 (192.168.1.1), segera setelah kami mengaktifkan OSPF pada 192.168.1.2, paket Hello akan dikirim.  vIOS1 dan vIOS2 akan menerima paket Hello dari satu sama lain dan agar lingkungan dapat berlangsung, penting bahwa parameter berikut ini sama dalam konfigurasi OSPF pada kedua router: <br><br><ul><li>  Hello Interval - frekuensi pengiriman pesan Hello </li><li>  Router Dead Interval - periode waktu di mana tetangga dianggap tidak tersedia jika tidak ada Hello. </li><li>  ID Area - lingkungan hanya dapat dibangun melalui antarmuka dalam satu zona. </li><li>  Otentikasi - kata sandi yang digunakan untuk otentikasi dan jenis otentikasi, jika ada. </li><li>  Bendera area rintisan - bendera opsional yang ditetapkan pada semua router yang termasuk area rintisan </li></ul><br>  Jika Anda melihat paket Hello yang ditunjukkan di atas, semua parameter ini ditunjukkan dalam paket Hello.  Segera setelah salah satu router (vIOS1) menerima paket Hello baru dan memeriksa semua kondisi, itu akan segera mengirim paket Hello di mana ia akan menunjukkan alamat router baru (vIOS2) di bidang Active Neighbor, vIOS2 akan menerima sendiri dan melihat dirinya di bidang tetangga, akan menambahkan vIOS1 ke tetangga dan akan mengirim paket unicast ke 192.168.1.1 (vIOS1), di mana ia akan mengindikasikannya sebagai tetangga.  Jadi untuk berbicara, mereka telah menjadi tetangga dan sekarang kesenangan dimulai - pertukaran informasi dan pembangunan LSDB yang sangat dasar.  Untuk pendirian lingkungan, saya sarankan Anda untuk membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> berikut. <br><br>  Basis LSDB akan berisi informasi tentang rute dan LSDB ini setelah pembentukan lingkungan harus identik pada semua router dalam zona yang sama.  Dan, pertama-tama, router setelah membangun sebuah lingkungan memulai proses sinkronisasi database mereka satu sama lain (vIOS1 dengan vIOS2).  Seperti yang Anda lihat, semuanya dimulai dengan pertukaran pesan Deskripsi DB (DBD).  Untuk membuatnya lebih jelas, mari kita bicara tentang jenis pesan yang digunakan OSPF: <br><br><ul><li>  Halo - digunakan untuk menemukan tetangga, memeriksa parameter, membangun hubungan lingkungan dengan mereka dan memantau ketersediaan. </li><li>  Deskripsi Basis Data (DBD) - Memeriksa status sinkronisasi basis data pada router. </li><li>  Link-State Request (LSR) - meminta catatan khusus tentang status saluran dari router ke router untuk sinkronisasi. </li><li>  Link-State Update (LSU) - Mengirim catatan status saluran tertentu sebagai tanggapan atas permintaan. </li><li>  Pengakuan Link-State (LSAck) - mengakui penerimaan jenis paket lainnya. </li></ul><br>  Penting juga untuk memperkenalkan konsep seperti LSA: <br><br>  <b>Link State Advertising (LSA)</b> - Unit data yang menggambarkan kondisi lokal router atau jaringan.  Banyak LSA yang menggambarkan router dan jaringan membentuk Link State Database (LSDB).  LSDB terdiri dari beberapa jenis LSA.  Sangat rinci tentang setiap LSA yang ditulis dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> .  Pesan DBD menggunakan banyak tanda untuk menentukan keadaan sinkronisasi, dan pesan ini berisi informasi tentang basis datanya sendiri.  Yaitu, vIOS1 melaporkan dalam pesan ini bahwa dalam database saya ada informasi tentang jaringan seperti 192.168.0 / 24, 1.1.1.0/24 (LSA Type 1), dan vIOS2 pada gilirannya melaporkan bahwa ia memiliki catatan tentang Jaringan: 192.168.2.0/24, 2.2.2.0/24 (LSA Type 1).  Setelah menerima pesan DBD, masing-masing router mengirim LSAck dalam konfirmasi pesan yang diterima, dan kemudian membandingkan informasi dalam database tetangga dengan miliknya.  Jika ternyata tidak ada informasi yang tersedia, router akan mengirimkan Permintaan LS, di mana ia meminta informasi lengkap tentang LSA.  Misalnya, vIOS1 meminta Permintaan LS dari vIOS2, vIOS2 merespons dengan Pembaruan LS, yang sudah berisi informasi terperinci tentang setiap rute.  Di bawah ini adalah Pembaruan LS: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a79/2cc/672/a792cc672c63e0a95c5b17951567b565.jpg" alt="gambar"><br><br>  Seperti yang Anda lihat, dalam posting ini, vIOS2 berbicara tentang subnet yang dikenalnya dan informasi yang terkait dengannya.  Juga, vIOS1 berbicara tentang LSDB-nya.  Dan pada akhirnya, router memiliki LSDB yang sama.  Setelah proses selesai, algoritma Dijkstra (Jalur Terpendek Pertama) diluncurkan.  Ini menghitung semua rute yang diketahui dari LSDB dan menempatkan yang terbaik dari mereka ke dalam tabel routing.  Yang terbaik dengan metrik lebih rendah, tetapi lebih pada nanti. <br><br>  Mari kita pikirkan pertanyaannya, apa yang terjadi jika kita mengaktifkan OSPF di vIOS3?  Karena vIOS3 harus membuat LSDB dan menyinkronkannya dengan router lain, muncul pertanyaan dengan siapa sebenarnya yang harus disinkronkan?  Dengan vIOS1 atau vIOS2?  Dengan masing-masing secara individual?  Seberapa optimal ini?  Oleh karena itu, dalam OSPF ada yang namanya DR-Designated router.  Kami memperkenalkan konsep ini: <br><br>  <b>Router khusus (router yang ditunjuk, DR)</b> - mengelola proses distribusi LSA di jaringan.  Setiap router jaringan membangun hubungan lingkungan dengan DR.  Informasi tentang perubahan dalam jaringan dikirim oleh DR, router yang mendeteksi perubahan ini, dan DR bertanggung jawab untuk memastikan bahwa informasi ini dikirim ke router lain di jaringan. <br><br>  Dengan kata lain, jika router baru muncul di segmen jaringan, maka itu akan menyinkronkan LSDB-nya dengan DR.  Penting juga untuk dicatat bahwa tidak hanya baru, tetapi semua router lain akan menginformasikan DR tentang hal ini ketika jaringan berubah atau rute baru muncul, dan sisanya akan mengambil informasi ini dari DR.  Tetapi kemudian muncul pertanyaan - Apa yang akan terjadi jika DR gagal?  Bagaimana DR dipilih? <br><br>  Ketika gagal, DR baru harus dipilih.  Hubungan lingkungan baru harus dibentuk dan, sampai database router disinkronkan dengan database DR baru, jaringan tidak akan tersedia untuk penerusan paket.  Untuk menghilangkan kelemahan ini, pilih BDR - Router yang ditunjuk pencadangan: <br><br>  <b>Router yang ditunjuk untuk pencadangan (BDR).</b>  Setiap router jaringan membangun hubungan lingkungan tidak hanya dengan DR, tetapi juga BDR.  DR dan BDR juga menjalin hubungan lingkungan satu sama lain.  Ketika DR gagal, BDR menjadi DR dan melakukan semua fungsinya.  Karena router jaringan telah membangun hubungan lingkungan dengan BDR, waktu tidak tersedianya jaringan diminimalkan.  Jadi, di jaringan kami, kami tidak hanya mendapatkan DR, tetapi juga BDR.  Router lain akan menerima dan melaporkan informasi yang relevan tentang jaringan hanya melalui mereka.  DR dan BDR hanya dapat dipilih dalam satu segmen, bukan zona!  Yaitu, untuk router vIOS1, vIOS2, vIOS3, vIOS4, satu DR dan BDR akan dipilih, dan, misalnya, antara vIOS dan vIOS1 DR dan BDR mereka akan ditentukan relatif terhadap segmen jaringan mereka, bahkan jika mereka berada di Area yang sama 0. Untuk komunikasi dengan DR dan BDR, router menggunakan alamat multicast 224.0.0.6. <br><br>  Pertanyaan selanjutnya adalah: Bagaimana DR / BDR dipilih?  Kriteria berikut berlaku: <br><br><ol><li>  DR: OSPF antarmuka router prioritas tertinggi. </li><li>  BDR: Router dengan prioritas tertinggi kedua dari antarmuka OSPF. </li><li>  Jika prioritas antarmuka OSPF adalah sama, ID router tertinggi digunakan untuk menentukan pilihan.  Seperti yang kami katakan, router mendefinisikan Router-ID mereka.  Pada awalnya, ketika OSPF diluncurkan pada vIOS1 dan vIOS2, selain membangun lingkungan, pemilihan DR / BDR juga terjadi.  VIOS2 dengan ID - 2.2.2.2 dimenangkan dalam perselisihan ini, ketika vIOS1 memiliki ID - 1.1.1.1.  vIOS1 terpilih sebagai BDR.  Penting untuk dicatat bahwa proses pemilihan DR dan BDR tidak terjadi segera setelah menerima paket Hello pertama dari router kedua.  Untuk melakukan ini, ada timer khusus yang setara dengan Router Dead Interval - 40 detik.  Jika selama ini paket Hello dengan ID terbaik tidak diterima, maka pilihan akan dibuat berdasarkan paket Hello yang ada. </li></ol><br>  Hanya sekarang kita dapat kembali ke pertanyaan - apa yang akan terjadi jika kita mengaktifkan OSPF di vIOS3?  Setelah mengaktifkan OSPF, vIOS3 akan mulai mengirim dan mendengarkan paket Hello.  Ini akan menerima paket Hello dari vIOS1 dan vIOS2, yang akan menunjukkan router mana yang DR dan BDR dan mengerti dengan siapa itu harus menyinkronkan LSDB.  Penting untuk dicatat bahwa ketika router dengan ID yang lebih baik muncul, maka DR / BDR tidak berubah sampai salah satu dari mereka crash.  Setelah itu, vIOS3 mulai menyinkronkan LSDB dengan router ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f8e/8b2/35a/f8e8b235a0eb24d311d6b745dac5910e.jpg" alt="gambar"><br><br>  Setelah menerima informasi baru dari vIOS3, DR mengirim pesan LS Update ke semua router ke alamat 224.0.0.5, ke mana router lain, setelah menerima paket, mengirim LS Acknowledge ke DR, tetapi ke alamat 224.0.0.6 (alamat untuk DR / BDR). <br><br>  Menurut skema yang sama, kami juga menghubungkan vIOS4.  Setelah sinkronisasi, semua router memiliki LSDB yang sama.  Mari kita lihat bagaimana kondisi lingkungan vIOS3.  Tampilkan ip perintah tetangga ospf: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf2/3eb/51f/bf23eb51f7a7ab94f64be8726dae9370.jpg" alt="gambar"><br><br>  Seperti yang bisa kita lihat, DR 2.2.2.2, BDR 1.1.1.1, dan 2WAY / DROTHER dipilih dengan vIOS4.  Negara tetangga dirujuk di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">atas</a> . <br><br>  Dan berikut adalah status lingkungan pada vIOS1 dengan lingkungan yang sudah ada dengan vIOS: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f3c/583/7e7/f3c5837e7b1d99243357857cc4cb1352.jpg" alt="gambar"><br><br>  Seperti yang Anda lihat, dia memiliki dua DR karena dia memiliki tetangga di segmen jaringan yang lain. <br><br><h3>  Multizona </h3><br>  Pertimbangkan cara kerja OSPF ketika banyak zona digunakan.  Ubah topologi kami dengan menambahkan router baru: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54c/b16/f0c/54cb16f0c9293e15b65544b3b89573a4.jpg" alt="gambar"><br><br>  Untuk memulainya, kita akan mengkonfigurasi OSPF pada vIOS1 dan vIOS sehingga antarmuka Gi0 / 1 mereka pada vIOS dan vIOS1 akan berada di zona 1. Mari kita lihat perubahan apa.  vIOS1 sekarang memiliki antarmuka di Area 0 (Gi0 / 0) dan Area 1 (Gi0 / 0).  Router seperti itu disebut ABR - Area Border Router (di bawah ini kami memberikan definisi ABR yang lebih benar).  ABR akan mengirim informasi rute dari satu zona ke zona lainnya.  Ini dilakukan melalui LSA Tipe 3: <br><br>  <b>Tipe 3 LSA - Ringkasan Jaringan LSA</b> - ringkasan pengumuman status saluran jaringan: <br><br><ul><li>  Iklan Spread by Edge Routers </li><li>  Pengumuman menggambarkan rute ke jaringan di luar area lokal </li><li>  Berisi informasi tentang jaringan dan biaya jalur ke jaringan ini, tetapi tidak mengirim informasi tentang topologi jaringan </li><li>  Secara default, router tepi mengirimkan iklan terpisah untuk setiap jaringan yang dikenalnya.  Jika perlu, pada jaringan ABR dapat diringkas </li><li>  Link-state ID - nomor jaringan tujuan. </li></ul><br>  Pada intinya, antar zona, prinsip operasi protokol menyerupai protokol Distance-vector, hanya mentransmisikan informasi rute dengan metrik.  Berikut adalah Pembaruan LS dari vIOS1 di Area 0, yang berisi 3 buah LSA Tipe 3: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f3/681/fa8/3f3681fa87bb1a94778d4bec031f37a1.jpg" alt="gambar"><br><br>  Pada intinya, struktur LSA Tipe 3 tidak jauh berbeda dari LSA Tipe 1, tetapi mereka mempengaruhi protokol dengan cara yang berbeda.  Ketika LSA yang diperbarui diterima atau jika ada LSA Tipe 1 &amp; 2 hilang, SPF (algoritma jalur terpendek) dihidupkan ulang dan menghitung ulang LSDB. <br><br>  Setelah menerima LSA Tipe 3, proses ini tidak terjadi - rute dengan metrik dalam LSA Tipe 3. LSA ini menyimpan data melalui mana ABR rute yang diberikan diterima (ABR ditentukan dalam bidang Perute Router) dan metrik untuk mencapai ABR ini sudah tersedia di LSDB.  Dengan demikian, metrik dari LSA Tipe 3 diringkas dengan metrik rute ke ABR dan kami mendapatkan rute selesai tanpa memulai kembali SPF.  Proses ini disebut <b>perhitungan Partial SPF</b> .  Ini cukup penting karena pada jaringan besar, ukuran LSDB bisa sangat besar dan menjalankan SPF sering tidak baik.  Juga, penciptaan LSA Tipe 3 menunjukkan bahwa mengubah dan menghitung ulang LSDB adalah satu bidang.  ABR hanya melaporkan bahwa dengan beberapa rute apa yang telah berubah. <br><br>  Penting juga untuk dicatat bahwa rute apa pun dari zona non-nol ke zona non-nol melewati Area 0. Jika ada ABR, itu tidak dapat dihubungkan ke Area 0 (kami mengecualikan opsi dengan virtual-link).  Area 0 adalah inti yang menghubungkan semua zona lainnya dan menyediakan perutean antar zona.  Definisi ABR terlihat seperti ini: <br><br>  <b>Border router (area border router, ABR)</b> - menghubungkan satu atau lebih zona ke zona trunk dan bertindak sebagai gateway untuk lalu lintas antar-zona.  Perute tepi selalu memiliki setidaknya satu antarmuka di zona trunk.  Untuk setiap zona terlampir, router mempertahankan basis data status saluran yang terpisah. <br>  Kami berurusan dengan pendirian lingkungan, penciptaan LSDB dan SPF, dengan zona biasa.  Sekarang mari kita lihat konvergensi dan respons OSPF terhadap perubahan topologi. <br><br>  Mari kita lihat topologi kita dan bayangkan bahwa vIOS3 berhenti berfungsi (keadaan saluran tidak berubah).  Ini akan membantu dalam membangun kembali topologi Timer Interval Mati - 40 detik.  Jika selama interval ini, router tidak menerima paket Hello dari tetangga, maka lingkungan akan runtuh.  Dalam kasus kami, DR akan mengirim Pembaruan LS dengan LSA Tipe 2, yang menunjukkan bahwa tidak ada vIOS3 di antara router yang terhubung, ini akan menyebabkan SPF untuk memulai dan menghitung ulang LSDB tanpa LSA diterima dari vIOS3.  Penting untuk dicatat bahwa pada router vIOS4 biasa, bahkan kelelahan Timer Interval Mati dan hilangnya kedekatan dengan vIOS3 tidak menyebabkan perhitungan ulang topologi, itu adalah pesan Pembaruan LS dengan LSA Tipe 2 yang memulai proses ini. <br><br>  <b>Tipe 2 LSA - Jaringan LSA -</b> Pengumuman Status <b>Tautan Jaringan</b> : <br><br><ul><li>  Didistribusikan oleh DR di beberapa jaringan akses </li><li>  Jaringan LSA tidak dibuat untuk jaringan di mana DR tidak dipilih </li><li>  Hanya didistribusikan dalam satu zona </li><li>  Link-state ID - alamat IP dari antarmuka DR </li></ul><br>  Jadi, mengabaikan data yang telah berhenti berfungsi terjadi dengan bantuan pesan ini.  Ini indikasi tetangga yang menjadi pemicu untuk membuang rute yang tidak relevan. <br><br>  Nyalakan kembali vIOS3 dan buat lingkungan lagi.  Eksperimen selanjutnya akan menjadi reaksi untuk menonaktifkan antarmuka Gi0 / 1 pada vIOS3.  Segera setelah vIOS3 mendeteksi penurunan tautan, ia langsung mengirim Pembaruan LS ke DR ke alamat 224.0.0.6, di mana dilaporkan bahwa rute tertentu telah jatuh dengan menetapkan bendera di LSA - LS Age yang setara dengan 3600 detik.  Untuk LSDB, ini adalah Max Age dan semua LSA dengan Max Age tidak diperhitungkan dalam SPF, sehingga mereka tidak akan berada dalam tabel routing.  Pertanyaannya adalah: Ketika Usia LSA secara alami mencapai Max Age, apa yang terjadi?  Untuk melakukan ini, OSPF memiliki LSRefreshTime - sama dengan setengah dari Max Age, setiap 1800 LS Update dikirim dari router untuk memperbarui data timer: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/43a/dd0/8c4/43add08c439f2826bb85e434a2280ae5.jpg" alt="gambar"><br><br>  Lebih lanjut, DR telah memproses Pembaruan LS ini, mengirimkan LS LS ke semua router lain ke alamat 224.0.0.5.  Segera setelah router mendapatkan informasi baru - mereka mengirim LSAck.  Ini memastikan konvergensi yang baik dalam OSPF. <br><br><h3>  Memilih rute terbaik </h3><br>  Router memilih rute terbaik berdasarkan nilai metrik terendah.  Namun, OSPF juga memperhitungkan beberapa faktor lain saat memilih rute.  Dalam hal ini, sumber rute dan jenisnya penting.  Pemilihan rute prioritas adalah sebagai berikut: <br><br><ul><li>  Rute internal suatu zona (intra-area) </li><li>  Rute antar zona (interarea) </li><li>  Rute Eksternal Tipe 1 (E1) </li><li>  Rute Eksternal Tipe 2 (E2) </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun biaya rute E2 tidak berubah ketika mentransfernya dengan zona (biaya jalur ke ASBR tidak ditambahkan), ketika biaya rute E2 bertepatan, biaya jalur ke ASBR yang mengumumkan rute tersebut dibandingkan. Metrik diperhitungkan saat Anda harus memilih dari rute dengan tipe yang sama. Sebagai metrik, konsep seperti biaya digunakan. Ini dihitung dengan rumus: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biaya = bandwidth referensi / bandwidth tautan. Bandwidth referensi - dasar dari bandwidth. Secara default, pada Cisco itu sama dengan 100Mbit. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencegahan Loop ABR.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang kami katakan di atas, antara zona prinsip operasi OSPF mirip dengan protokol distance-vector. </font><font style="vertical-align: inherit;">Dengan menggunakan mekanisme pencegahan loop, kita bisa mendapatkan bahwa jalur yang tidak optimal dipilih. </font><font style="vertical-align: inherit;">Misalnya, antara zona ada aturan seperti Split Horizon dari protokol distance-vektor. </font><font style="vertical-align: inherit;">Pertimbangkan ini sebagai contoh, jika kita mengubah topologi kita di perbatasan zona 0 dan 4 sebagai berikut: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/318/d56/328/318d56328823c86abf8df0b5439e76b7.jpg" alt="gambar"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maka kita mendapatkan bahwa vIOS18 akan memilih jalur yang tidak optimal dengan metrik 100 melalui antarmuka Gi0 / 0. </font><font style="vertical-align: inherit;">Ini terjadi karena fakta bahwa vIOS18 tidak akan memperhitungkan LSA Tipe 3 yang diterima bukan dari zona 0. Juga, aturan di atas melarang mentransfer LSA Tipe 3 ini kembali ke zona 0.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418391/">https://habr.com/ru/post/id418391/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418381/index.html">Apa yang Baru di DevTools di Versi Chrome 68</a></li>
<li><a href="../id418383/index.html">Animasi Android berdasarkan Kotlin dan RxJava</a></li>
<li><a href="../id418385/index.html">Bagaimana Saya Merakit Komputer untuk Game Lama</a></li>
<li><a href="../id418387/index.html">Fisikawan berdialog tentang jiwa</a></li>
<li><a href="../id418389/index.html">RabbitMQ vs Kafka: Menggunakan Kafka di Aplikasi yang Berorientasi Acara</a></li>
<li><a href="../id418393/index.html">[Jumat] Bagaimana kami menggergaji Web 3D</a></li>
<li><a href="../id418395/index.html">Elon Musk: generator lokal medan elektromagnetik akan melindungi penjajah di Mars</a></li>
<li><a href="../id418397/index.html">Manajemen Jumat: Webinar Skillbox Gratis</a></li>
<li><a href="../id418399/index.html">Pada gelombang Selectel FM</a></li>
<li><a href="../id418401/index.html">Bagaimana saya tidak menjadi Anda: posting cinta untuk administrator sistem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>