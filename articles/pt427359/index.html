<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👉🏿 👨‍👩‍👦‍👦 🚶🏽 Como ECS, C # Job System e SRP alteram a arquitetura 👸🏾 👩🏽‍⚕️ ☺️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Trabalhamos com o Unity há muito tempo e não pudemos deixar de convidar o pessoal deles para o Pixonic DevGAMM Talks, que foi em setembro. O engenheir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como ECS, C # Job System e SRP alteram a arquitetura</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/427359/">  Trabalhamos com o Unity há muito tempo e não pudemos deixar de convidar o pessoal deles para o Pixonic DevGAMM Talks, que foi em setembro.  O engenheiro de campo Valentin Simonov contou como planejar a arquitetura dos jogos, levando em consideração as vantagens das novas tecnologias.  A Unity trabalha neles há vários anos para alcançar um nível de desempenho anteriormente inatingível.  Você pode ouvir a apresentação no YouTube e ler a transcrição com slides logo abaixo do recorte. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/w4DkVpXLu2c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <a name="habracut"></a><br>  E se eu disser que você pode aumentar a produtividade do seu jogo em 10 vezes?  De fato, isso não é inteiramente verdade, mas há alguma verdade em toda piada.  Quero falar sobre o que estamos trabalhando agora, qual será o futuro do Unity e o que você pode usar agora. <br><br>  Unidade faz jogos completamente diferentes.  Aqui estão alguns exemplos que eu mesmo interpreto.  Eles usam recursos diferentes e precisam de desempenho diferente, uma abordagem diferente para o desenvolvimento. <br><br><img src="https://habrastorage.org/webt/ln/vm/4k/lnvm4ktwudkqejfeve_v5vkk50m.png"><br><br>  E estamos trabalhando em um projeto que chamamos de desempenho por padrão.  Esses são alguns recursos especiais que, se usados ​​corretamente, obterão um aumento significativo no desempenho.  Em algumas tarefas, medimos x10 e até x11.  Especialmente nos problemas de simulação de um grande número de objetos que interagem entre si. <br><br>  Mas quando falamos de Perfomance por padrão, queremos dizer que você terá que mudar a abordagem do desenvolvimento, alterar muito a abordagem da arquitetura dos jogos.  E, de fato, nem todo mundo precisa disso. <br><br>  Uma pergunta popular: “O que você está fazendo no seu ECS?  Você remove todo o GameObject, remove toda a transformação, hierarquia e componentes? ”  Não, todos nós deixamos.  Você pode trabalhar com o Unity exatamente da mesma maneira que está agora, mas se quiser mais desempenho, precisará conhecer as tecnologias sobre as quais quero falar brevemente. <br><br>  E quero mencionar outra tecnologia chamada Scriptable Render Pipelines (SRP) - ela permite que você escreva com mais eficiência um pipeline de renderização para o seu jogo.  Você provavelmente viu a demonstração que mostramos em um dos Unite.  Aqui no PC em tempo real, um número gigante de unidades é simulado, algo em torno de 60 mil (atinge 100 mil e começa a desacelerar um pouco): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0969LalB7vw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  E os novos recursos sobre os quais quero falar são: Sistema de componentes de entidades (ECS), Sistema de tarefas em C #, nosso novo supercompilador Burst e Pipelines de renderização de scripts (SRP). <br><br><img src="https://habrastorage.org/webt/vl/eh/vq/vlehvq_jnr-zg_vrr6wpluip2ui.png"><br><br>  Repito: cabe a você escolher se quer ir em frente conosco, aprender novas tecnologias ou se está bem em desenvolver jogos que ganham dinheiro bem e são simplesmente criados. <br><br>  Para entender o que estamos tentando resolver, é importante entender o estado do ferro em 2018. <br><br><img src="https://habrastorage.org/webt/b0/rp/fl/b0rpflxbgvksdmbp-s9mw2pvgwq.png"><br><br>  Observe como o desempenho e o número de núcleos da CPU estão aumentando.  De um ponto, o desempenho de thread único caiu.  Ou seja, agora temos muitos núcleos, mas sua produtividade não está crescendo tão rápido.  Portanto, gostaríamos de usar o poder de todos os núcleos. <br><br><img src="https://habrastorage.org/webt/p7/a2/ri/p7a2rir7c_2icejklwngmijjxso.png"><br><br>  Meu telefone possui 8 núcleos: 4 fortes e 4 fracos.  E um telefone moderno pode funcionar tão rápido quanto um computador moderno (mas não por muito tempo devido ao superaquecimento).  Você também precisa entender que aumentar o desempenho não é apenas usar todos os núcleos, mas também otimizar o desempenho de núcleo único. <br><br>  E a última imagem, que sempre damos como exemplo de como o desempenho do processo aumenta e a velocidade de acesso à memória não aumenta muito: <br><br><img src="https://habrastorage.org/webt/gm/sw/dw/gmswdwp-tar5zfybjn02xq00e_g.png"><br><br>  Pode-se ver que agora o acesso à memória é extremamente lento.  Os fabricantes de processadores fazem muito para nivelar essa diferença - adicione caches, as CPUs estão envolvidas em cálculos especulativos, tentando prever qual código será executado a seguir.  E se você não pensa nisso quando cria seu jogo (ou quando criamos um mecanismo para você), não podemos tirar o máximo proveito dos processadores modernos. <br><br>  Muitos de vocês provavelmente passam horas olhando para uma imagem semelhante no Unity: <br><br><img src="https://habrastorage.org/webt/u3/li/ab/u3liabzolenmypdfmbax3udkwgy.png"><br><br>  Aqui você pode ver que há multithreading, mas os núcleos e threads restantes geralmente não estão ocupados.  Algo está sendo feito, mas eu gostaria de ocupá-los completamente. <br><br>  Agora temos a renderização, essa é uma caixa preta.  Você tem uma opção: Encaminhar ou Adiar, além de várias configurações de materiais, shaders, Buffers de Comando e assim por diante.  Você pode criar uma imagem bonita, mas muitos algoritmos são extremamente difíceis de implementar. <br><br><img src="https://habrastorage.org/webt/vf/oy/uw/vfoyuw4vl7ga1z3aht8uzmd1iwi.png"><br><br>  E todos sabemos sobre arquitetura no Unity: componentes, GameObjects, hierarquia de transformações, todo o código, todos os dados no MonoBehaviour e cada componente processa seus dados. <br><br><img src="https://habrastorage.org/webt/0u/zm/bn/0uzmbnnpvak4sbanz01fruudnpu.png"><br><br>  Mas há problemas com o estado atual das coisas.  Mais cedo ou mais tarde, você se depara com isso e entende como precisa e não precisa.  A hierarquia de objetos em si tem uma certa sobrecarga e algumas entidades não precisam ser GameObjects.  E se você tiver um grande número de componentes e atualizações, tudo ficará muito mais lento.  Certa vez, escrevi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este artigo</a> , que ainda é relevante se você quiser saber como não fazê-lo. <br><br><img src="https://habrastorage.org/webt/mo/wp/ph/mowpphiwnugvj62nvi0cng6d9wc.png"><br><br>  E o mais importante no contexto dos processadores é que todos os componentes, todos os dados estão espalhados na memória, o que interrompe o uso do cache do processador. <br><br>  Agora eu quero passar rapidamente por novos recursos. <br><br><img src="https://habrastorage.org/webt/gz/7m/pe/gz7mpecj1dov6grvyikove3neyg.png"><br><br>  Não vou me concentrar muito no que é o ECS e como ele funciona.  O ponto é que temos Entidade, que é apenas o ID de certas entidades no jogo - elas armazenam dados na forma de componentes, ou seja,  apenas dados, sem código.  E os sistemas processam a Entidade com determinados componentes e, de alguma forma, alteram esses dados. <br><br>  Por que estamos fazendo nosso ECS e como será melhor que os concorrentes?  Existem alguns pontos.  Primeiro, não oficialmente, mas achamos que faríamos o motor agora.  É claro que não queremos nos livrar do GameObjects, os componentes atuais do Unity, jogar completamente tudo fora e instalar o ECS.  Mas queremos avançar em direção a um motor melhor. <br><br><img src="https://habrastorage.org/webt/ty/3a/c6/ty3ac6irgsqt6d88mn-6v6pbuki.png"><br><br>  Contamos com alto desempenho.  Não faz muito tempo, Mike Acton se juntou a nós (se você está em desenvolvimento em C ++, sabe que ele é um dos evangelistas da Programação Orientada a Dados).  E queremos fazer com que todo o sistema funcione o mais rápido possível - mais rápido que o C ++. <br><br>  Também pensamos em como integrar coisas diferentes nativamente no ECS.  Há algum tempo, anunciamos que estávamos criando uma nova rede e ela também é baseada no ECS - será possível criar um jogo multiplayer no ECS e compartilhar código entre o cliente e o servidor. <br><br>  Trabalhando em ferramentas de depuração no Unity.  I.e.  enquanto o ECS existe, por assim dizer, separadamente do GameObjects e componentes, e isso é muito inconveniente.  Queremos simplificar as coisas. <br><br>  Agora há um DebugView que se parece com isso: <br><br><img src="https://habrastorage.org/webt/pv/dg/qe/pvdgqexi8tewv1l5gsgrrrxzeg4.png"><br><br>  Aqui você pode ver que tipo de Entidade você tem, quais sistemas quanto tempo leva para processar, quais sistemas funcionam com quais componentes e para cada componente você pode ver no inspetor, quais dados cada Entidade possui nos componentes (observe que a API geralmente muda e muitos Os tutoriais já podem estar desatualizados). <br><br>  Além disso, se você ouviu falar sobre o nosso novo desenvolvimento Unity for Small Things (este é um tempo de execução muito pequeno que permite criar jogos para mensageiros instantâneos) - tudo também é construído no ECS lá. <br><br>  Recentemente, o boom de desenvolvimento e transição para o ECS é uma tecnologia muito popular e todos precisam conhecê-la. <br><br>  Temos uma conferência para programadores, por isso é difícil ficar sem um slide de código.  Há muito código lá, então é difícil extrair algum tipo de peça inteligível para deixar algo claro. <br><br><img src="https://habrastorage.org/webt/3s/d1/rb/3sd1rbsazp2tciwbfuax8xzmupe.png"><br><br>  Na verdade, peguei um sistema no exemplo que funciona com o C # Job System (mais sobre isso mais tarde) e fazemos muito para reduzir a quantidade de código, adicione uma sintaxe shugar. <br><br>  Existe um sistema que funciona com os componentes RotationData e também precisa das transformações GameObject, representadas por um TransformAccessArray especial.  E todas as atualizações do sistema que criamos Job, executamos este Job, ele é atualizado em algum lugar, podem ser divididas em vários grupos e executadas em threads diferentes. <br><br>  Como usar no projeto?  Assim como em outras implementações do ECS, você precisa entender que precisa pensar de uma maneira completamente diferente (diferente dos GameObjects e Transforms).  E se acostume com essa ideia.  É claro que você precisa começar desde o início do projeto, porque muitas vezes recebo perguntas como "fizemos o jogo e queremos mudar para o ECS - como?".  No jogo final, isso é muito difícil de fazer. <br><br><img src="https://habrastorage.org/webt/kw/ow/r9/kwowr9ar6zht1xoprdmg37v6sms.png"><br><br>  Precisamos pensar na interação com o Unity, já que o ECS vive separadamente, em seu pequeno mundo.  Damos algumas oportunidades de interação com GameObjects e Transforms, mas com física, renderização etc., aqui fica cada vez mais complicado.  E enquanto você precisa aturar o fato de que grande parte da interface familiar não estará disponível, mas também estamos trabalhando nisso. <br><br>  E imediatamente você precisa pensar no fato de escrever sistemas no Job System, o que é muito mais eficiente. <br><br><img src="https://habrastorage.org/webt/c8/bw/po/c8bwpoy0xq2pngb3w9ayxv78gtk.png"><br><br>  Algumas palavras sobre o Job System.  Queremos criar uma maneira muito simples de escrever código multiencadeado.  Ao mesmo tempo, escreva em C #, verifique tudo para você, não dê a oportunidade de cometer erros ou mostre por que, onde e como você os cometeu.  Limitamos os recursos de idioma que você pode usar nos Trabalhos e chamamos esse subconjunto C # de Alto Desempenho C #.  Você não tem referências no código do trabalho, nenhuma linha, todos os dados precisam ser copiados - você não pode usar um grande número de recursos de idioma, dificultando muito a gravação de vários segmentos na perna. <br><br>  Também apresentamos coleções e integração muito rápidas com o ECS.  Essa estrutura do ECS e do sistema de tarefas permite uma execução muito rápida do código. <br><br>  Ao mesmo tempo, não apenas oferecemos a oportunidade de usar essas tecnologias - trabalhamos com esses sistemas e criamos novas APIs para que elas possam ser usadas nos trabalhos. <br><br><img src="https://habrastorage.org/webt/x-/e4/x7/x-e4x7xnicynebmtj7cbbye4b90.png"><br><br>  Criamos o Async Raycasts para a física, com o qual você pode dizer "Quero 600 rakecasts, faça isso comigo algum dia, por favor".  Estamos trabalhando para garantir que, usando essas tecnologias, seja possível expandir os sistemas atuais, por exemplo, animação por meio da API do Playbles.  E estamos pensando em criar novos sistemas no Unity que não serão fechados em C ++ e cujo código estará em C # e estará disponível para você. <br><br><img src="https://habrastorage.org/webt/q_/lk/da/q_lkdawzdu72-jn_kmaapysa3ym.png"><br><br>  Se você pegar o código de Jó, é bem simples.  Job é uma estrutura na qual existe um método Execute, onde fazemos algum trabalho executando esse Job.  Consequentemente, nosso Agendador interno algum dia entenderá onde é melhor executá-lo, resolverá todas as dependências.  Aqui temos um JobHandle, que podemos usar como dependência para alguns outros trabalhos. <br><br>  Como usar no projeto?  É bom que você use Jobs desde o início, mas isso não é necessário aqui.  Se você tiver algum tipo de sistema crítico de desempenho, por exemplo, simulação, busca de caminhos, rede ou algo mais - você pode descobrir como otimizá-lo com esta ferramenta. <br><br><img src="https://habrastorage.org/webt/_p/ez/de/_pezdeftr_wilpohozdzt-bjzcc.png"><br><br>  Mas, para isso, você precisa dar alguns grandes passos, entender como armazenar dados corretamente.  O ECS, de fato, nos permite armazenar dados corretamente, porque separamos os dados do código e nossa implementação do ECS armazena os dados dos componentes linearmente na memória e, executando esses componentes por algum sistema, você usa todos os recursos do processador, tudo é armazenado no cache e etc.  Tentamos fazer isso muito rapidamente. <br><br>  Em seguida, você divide esse trabalho em tarefas paralelas, escreve o código do trabalho e executa-o.  E (provavelmente) tudo funciona para você.  Obviamente, você precisa testar e, o mais importante, testar na plataforma de destino, dependendo do número de núcleos etc.  Mas o uso do Job System e ECS, como eu disse, também afeta muito a maneira como você planeja sua arquitetura de jogos. <br><br>  Então tudo é muito mais simples.  O Burst Compiler é a nossa tecnologia exclusiva, um compilador especial dessa sub-rede C # (High Performance C #) no código da máquina da plataforma atual, que você publicará em seu projeto. <br><br><img src="https://habrastorage.org/webt/2s/ag/qg/2sagqggfsgpjvfjuqsd1tcy_e5g.png"><br><br>  Os caras fizeram alguma mágica que provavelmente ninguém, exceto eles, entende, mas isso acelera o código do trabalho 10 vezes, o que é super legal.  E o mais legal é que ele não requer nenhuma ação da sua parte - se você tiver um código de tarefa, basta adicionar o atributo [BurstCompile], a Burst compila seu código e obtém desempenho "gratuito".  Esta é a nossa nova tecnologia e você pode experimentá-la agora. <br><br><img src="https://habrastorage.org/webt/lb/-2/2o/lb-22ophaiyv_c9vwtehvj48iqk.png"><br><br>  E a última coisa que quero mencionar brevemente é o Scriptable Render Pipeline (SRP), no qual trabalhamos há muito tempo e que foi projetado para oferecer a você a oportunidade de escrever uma renderização muito personalizada para o seu jogo específico. <br><br><img src="https://habrastorage.org/webt/ng/vh/32/ngvh32ztmpxvgkqzhfyujehhwoe.png"><br><br>  O Pipeline de renderização é um algoritmo que faz o descarte (quais objetos serão desenhados), renderização e pós-processamento.  Agora temos uma caixa preta que Forward ou Adiada - eles já são bons, temos gráficos muito legais em telefones celulares, PCs e consoles.  Mas eles têm muitas restrições, porque não podem ser expandidas.  Usando esse novo recurso, SRP, você pode escrever seu Pipeline, remover algo de lá, adicionar, fazer o que quiser. <br><br><img src="https://habrastorage.org/webt/gj/gj/0b/gjgj0bdrlc_7nahtzi5tkx6ccu0.png"><br><br>  Atualmente, estamos trabalhando em dois exemplos de gasodutos.  Um LWRP, direcionado para telefones celulares e dispositivos fracos, e HDRP, direcionado para PCs, consoles e nos quais pessoas famosas do setor trabalham.  Antes disso, eles fizeram jogos AAA.  Certamente, você viu nossa demo Book of the Dead. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/NoemmTLnK6k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Aqui usamos o HDRP para mostrar todo o poder dessa tecnologia. <br><br>  Para usar isso, você também precisará executar um número bastante grande de etapas heróicas, porque com o novo Pipeline, quase nada é compatível com o que temos agora.  I.e.  se você atualizar com o Legacy, forneceremos um utilitário que atualizará a maioria dos materiais para você, mas você precisará reescrever seus shaders, ou seja,  as texturas provavelmente parecerão diferentes. <br><br><img src="https://habrastorage.org/webt/0l/mu/h2/0lmuh2hegzr_croq8bi_jfnhl68.png"><br><br>  Muito legal se você pode começar do zero e experimentar seu Pipeline.  Se você quiser fazer algo no seu Pipeline, entre em contato conosco. <br><br>  Novamente, entenda o que você precisa, porque agora você tem mais oportunidades de fazer algo, mas precisará de pessoas que possam fazê-lo ou precisará aprender como fazê-lo. <br><br><img src="https://habrastorage.org/webt/bc/bm/ff/bcbmffmyzfoguauzz3na8ese_xg.png"><br><br>  Na minha opinião, isso é legal, porque aqueles que nos acompanham com essas novas tecnologias terão mais demanda no mercado.  É isso, espero que alguém olhe para essas tecnologias, crie jogos bonitos e divertidos. <br><br><h3>  Perguntas da platéia </h3><br>  <b>- Quando posso obter o ECS e desenvolvê-lo?</b> <br><br>  - Você pode usar o ECS, o problema é que, na sua forma atual, é mais direcionado para pessoas focadas no desempenho, ou seja,  algum tipo de projeto AAA.  E a tarefa do Unity é disponibilizar o desempenho por padrão para todos.  Portanto, precisamos de um determinado sistema, um complemento para o ECS, que nos permita usar o ECS com a mesma facilidade que usamos agora o MonoBehavior.  Embora não exista esse complemento, não acho que o ECS será lançado em uma versão completa.  E descobrimos que criamos um recurso que 1% de nossos usuários usarão.  E isso não é uma tarefa da Unity.  Conheço pessoas que já usam o ECS em produção, mas lembre-se de que esse recurso ainda está em desenvolvimento e agora estamos resolvendo a questão de como criar a interface mais conveniente.  E a próxima tarefa (não menos difícil) é como criar algum tipo de API que resida no ECS e que você possa usá-lo com a mesma facilidade que o MonoBehaviour.  I.e.  não há resposta para a pergunta "quando exatamente". <br><br>  <b>- O ECS e o restante dos itens estão focados em pegar um GameObject básico e criar 150 mil de seus clones e gerenciá-los.</b>  <b>Mas e se eu tiver poucos objetos, mas eles tiverem entidades diferentes?</b> <br><br>  - Você pode, em princípio, não fazer nada, esta tecnologia não obriga a usá-la.  Se você pode obter um aumento de desempenho usando essas tecnologias, deve usá-las.  Se isso não for relevante para você, você continuará usando o Unity como está.  Portanto, não entre em pânico. <br><br>  <b>- Temos um cliente no Unity, um servidor no .NET, tentamos um servidor no Unity, nada resulta disso.</b>  <b>Mas, ao mesmo tempo, também quero usar as tecnologias que estão no Unity no servidor.</b> <b><br></b> <br>  - Estamos trabalhando nisso e entendemos que agora não podemos fornecer uma solução eficaz para servidores.  Nós compramos a empresa Multiplay há algum tempo para criar hospedagem de alta qualidade para jogos Unity.  Trabalhamos em rede separadamente e estamos comprometidos em otimizar o mecanismo para que mais coisas possam ser implementadas.  Assim, quando tudo se reunir, teremos uma excelente solução multiplayer. <br><br><h3>  Mais conversas com o Pixonic DevGAMM Talks </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando o Consul para dimensionar serviços com estado</a> (Ivan Bubnov, DevOps no BIT.GAMES); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CICD: implantação contínua em sistemas de cluster distribuídos sem tempo de inatividade</a> (Egor Panov, administrador de sistema Pixonic); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A prática de usar o modelo de ator na plataforma de back-end do jogo Quake Champions</a> (Roman Rogozin, desenvolvedor de back-end Saber Interactive); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Arquitetura de meta servidor de tiro on-line móvel Tacticool</a> (Pavel Platto, Engenheiro de Software Líder no PanzerDog); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Princípio do KISS em desenvolvimento</a> (Konstantin Gladyshev, programador líder de jogos da 1C Game Studios); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lógica geral do jogo no cliente e no servidor</a> (Anton Grigoriev, Diretor Técnico Adjunto da Pixonic). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pepino na nuvem: usando scripts BDD para teste de estresse do produto</a> (Anton Kosyakin, gerente técnico de produto da plataforma ALICE). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427359/">https://habr.com/ru/post/pt427359/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427349/index.html">Programador para a nova família tinyAVR baseada no conversor chinês CH340 barato</a></li>
<li><a href="../pt427351/index.html">Semana 40 de segurança: Vulnerabilidades no CMS Drupal e mais</a></li>
<li><a href="../pt427353/index.html">Drones mostram: como coordenamos um enxame de helicópteros dançantes</a></li>
<li><a href="../pt427355/index.html">Compilação CJM, principais habilidades do diretor de arte e compreensão do usuário</a></li>
<li><a href="../pt427357/index.html">Escrevendo shaders no Unity. GrabPass, PerRendererData</a></li>
<li><a href="../pt427361/index.html">Recursos de filtragem de janelas no FPGA</a></li>
<li><a href="../pt427363/index.html">Implementação do LoRaWAN em uma empresa agrícola. Tudo sobre construção, lançamento e soluções</a></li>
<li><a href="../pt427365/index.html">Relatório do RedSlerm sobre monitoramento (Monit, Zabbix)</a></li>
<li><a href="../pt427367/index.html">Conferência BLACK HAT USA. Como um hacker de Hollywood usa câmeras de vigilância. Parte 1</a></li>
<li><a href="../pt427369/index.html">Conferência BLACK HAT USA. Como um hacker de Hollywood usa câmeras de vigilância. Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>