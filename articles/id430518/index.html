<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥟 😺 🏑 Cara merender bingkai Middle Earth: Shadow of Mordor 👩🏼‍✈️ 🤴🏻 😆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Middle Earth: Shadow of Mordor diluncurkan pada 2014. Permainan itu sendiri adalah kejutan besar, dan fakta bahwa itu adalah spin-off dari jalan cerit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara merender bingkai Middle Earth: Shadow of Mordor</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430518/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ow/br/se/owbrsedfx4zll9o8sxbxx2fbnza.gif"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Middle Earth: Shadow of Mordor</a> diluncurkan pada 2014.  Permainan itu sendiri adalah kejutan besar, dan fakta bahwa itu adalah spin-off dari jalan cerita Lord of the Ring cukup tak terduga.  Permainan ini memperoleh sukses besar, dan pada saat penulisan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Monolith</a> telah merilis sekuel - Shadow of War.  Grafik gim ini sangat indah, terutama mengingat gim ini dirilis untuk generasi konsol yang berbeda, termasuk Xbox 360 dan PS3.  Versi PC dipoles dengan cukup baik, berisi opsi grafis tambahan dan paket tekstur resolusi tinggi yang sepenuhnya mengungkapkan potensi permainan. <br><br>  Gim ini menggunakan penyaji tangguhan DX11 yang relatif baru.  Saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Renderdoc</a> untuk mempelajari teknik rendering game secara mendalam.  Ketika bekerja, parameter grafik maksimum yang mungkin (ultra) digunakan dan semua "lotion" yang mungkin dimasukkan, seperti transparansi yang independen dari pesanan, tessellation, oklusi di ruang layar dan berbagai blur gerakan. <br><a name="habracut"></a><br><h2>  Bingkai </h2><br>  Berikut ini adalah kerangka yang akan kami analisis.  Pemain ini terletak di platform kayu di wilayah Udun.  Shadow of Mordor menggunakan mekanisme yang mirip dengan mekanisme permainan seperti Assassin's Creed, di mana Anda dapat memanjat bangunan dan menara, dan kemudian menikmati lanskap digital di sekitarnya dari atap. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73d/325/3e0/73d3253e0323327f95babf989f060f93.jpg" alt="gambar"></div><br><h2>  Bagian kedalaman </h2><br>  Sekitar 140 panggilan render pertama melakukan lintasan pendahuluan cepat untuk membuat elemen elevasi dan bangunan terbesar ke buffer kedalaman.  Sebagian besar objek tidak termasuk dalam kartu pendahuluan ini, tetapi akan membantu jika permainan memiliki jumlah panggilan undian yang sangat besar dan Anda dapat melihat jauh ke kejauhan.  Menariknya, karakter yang selalu berada di tengah layar dan menempati sebagian kecil dari ruang layar tidak termasuk dalam bagian ini.  Seperti di banyak game dunia terbuka lainnya, mesin menggunakan nilai z terbalik.  Teknik ini mengikat pesawat dekat ke 1,0 dan pesawat jauh ke 0,0 untuk meningkatkan akurasi pada jarak besar dan mencegah konflik z.  Baca lebih lanjut tentang akurasi z-buffer di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/ba6/57d/181ba657ddc430ee3a892e852cc276e9.png" alt="gambar"></div><br><h4>  G-buffer </h4><br>  Segera setelah ini, pass G-buffer dimulai, yang dilakukan di sekitar 2700 panggilan undian.  Jika Anda membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">analisis</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya tentang Castlevania: Lords of Shadow 2</a> atau mempelajari artikel serupa lainnya, maka bagian ini seharusnya tidak asing bagi Anda.  Properti permukaan dicatat dalam satu set buffer, yang kemudian dibaca dalam perhitungan perhitungan pencahayaan untuk menghitung reaksi permukaan terhadap cahaya.  Shadow of Mordor menggunakan renderer ditangguhkan klasik, tetapi sejumlah kecil target render G-buffer digunakan untuk mencapai tujuan ini (3).  Sebagai perbandingan: Mesin Unreal dalam bagian ini menggunakan 5-6 buffer.  G-buffer memiliki skema berikut: <br><br><h5>  Buffer normal </h5><br><table><tbody><tr><td>  <strong><font color="#ff0000">R</font></strong> </td><td>  <strong><font color="#00ff00">G</font></strong> </td><td>  <strong><font color="#0000ff">B</font></strong> </td><td>  <strong>A</strong> </td></tr><tr><td>  <strong>Normal.x</strong> </td><td>  <strong>Normal</strong> </td><td>  <strong>Normal.z</strong> </td><td>  <strong>ID</strong> </td></tr></tbody></table><br>  Buffer normals menyimpan normals di ruang dunia dalam format "8 bit per channel".  Ini hampir tidak cukup, dan kadang-kadang tidak sama sekali, untuk menggambarkan permukaan rata yang bervariasi dengan lancar.  Jika Anda melihat lebih dekat, ini bisa dilihat di beberapa genangan air di dalam game.  Saluran alfa digunakan sebagai ID yang menandai berbagai jenis objek.  Sebagai contoh, saya menemukan bahwa 255 merujuk pada karakter, 128 ke bagian animasi dari bendera, dan langit ditandai dengan ID 1, karena nantinya pengidentifikasi ini digunakan untuk memfilternya pada tahap penambahan (langit mendapatkan mekar radial sendiri). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/za/jf/y8/zajfy84cg-abqarjiybgm3qcztw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9k/aq/4v/9kaq4vempyj-n14_kdfte3d51ss.png"></div><br>  <i>Dalam artikel asli, ini dan banyak gambar lainnya dianimasikan untuk kejelasan yang lebih besar, jadi saya sarankan mencari di sana.</i> <br><br><h5>  Buffer Albedo </h5><br><table><tbody><tr><td>  <strong><font color="#ff0000">R</font></strong> </td><td>  <strong><font color="#00ff00">G</font></strong> </td><td>  <strong><font color="#0000ff">B</font></strong> </td><td>  <strong>A</strong> </td></tr><tr><td>  <strong>Albedo.r</strong> </td><td>  <strong>Albedo.g</strong> </td><td>  <strong>Albedo.b</strong> </td><td>  <b>Oklusi rongga</b> </td></tr></tbody></table><br>  Buffer albedo menyimpan ketiga komponen albedo dan oklusi skala kecil (kadang-kadang disebut rongga oklusi), yang digunakan untuk menaungi detail kecil yang tidak dapat dijangkau oleh peta bayangan atau pasca-pemrosesan dalam ruang layar.  Ini terutama digunakan untuk keperluan dekoratif, misalnya, lubang dan lipatan pada pakaian, celah-celah kecil di pohon, pola kecil pada pakaian Talion, dll. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t6/ul/bz/t6ulbzqtlw3ncodrlnd49uxtmwa.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/28/52/lr/2852lrdq75bxtqpkywvutfsm4se.png"></div><br>  Saat memproses musuh di shader, Albedo memperhitungkan tekstur darah (yang menarik, Talion tidak pernah mendapat luka yang terlihat).  Tekstur darah adalah input untuk fase rendering pakaian dan tubuh musuh, tetapi tidak menentukan warna darah, yang merupakan input dalam buffer konstan, tetapi menentukan faktor / level darah untuk mengontrol jumlah darah yang ditampilkan.  Juga, orientasi normal digunakan untuk mengukur efek, memungkinkan Anda untuk mengontrol arah percikan darah.  Kemudian albedo pada dasarnya teduh dengan kecerahan luka yang diterima oleh musuh, diambil dari tempat yang sesuai pada peta darah, dan juga memodifikasi properti lain, seperti specular, untuk mendapatkan efek darah yang meyakinkan.  Saya tidak dapat menemukan bagian dari bingkai di mana peta diberikan, tetapi saya berasumsi bahwa mereka dicatat tepat di awal bingkai ketika pedang terbuka, dan kemudian digunakan di sini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1y/_r/rt/1y_rrtgi8bsuryvjmqmpdvzwpfk.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mi/tv/nu/mitvnumojb0zx4qhzohrgrj810e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qp/wx/t7/qpwxt7y4r-k3ugakdasysx1vtvm.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6d/-r/lz/6d-rlzgi7fvdep6xrxnakmjp9yg.png"></div><br><h5>  Buffer specular </h5><br><table><tbody><tr><td>  <strong><font color="#ff0000">R</font></strong> </td><td>  <strong><font color="#00ff00">G</font></strong> </td><td>  <strong><font color="#0000ff">B</font></strong> </td><td>  <strong>A</strong> </td></tr><tr><td>  <b>Kekasaran</b> </td><td>  <b>Intensitas specular</b> </td><td>  <b>Fresnel</b> </td><td>  <b>Faktor hamburan bawah permukaan</b> </td></tr></tbody></table><br>  Buffer specular berisi properti permukaan lain yang dapat diharapkan terlihat dalam game, seperti kekasaran (ini bukan kekasaran, tetapi tingkat specular yang diskalakan, tetapi dapat ditafsirkan dengan cara ini), intensitas specular (kecerahan specular) yang menskala Albedo untuk mendapatkan specular warna yang benar, faktor reflektifitas (umumnya disebut dalam literatur sebagai F0, karena merupakan input untuk respons cermin Fresnel) dan komponen hamburan bawah permukaan (hamburan bawah permukaan).  Komponen yang terakhir digunakan untuk menerangi bahan tembus cahaya seperti jaringan tipis, tanaman, dan kulit.  Jika nanti kita menyelami studi tentang shader pencahayaan, kita menemukan bahwa di sini kita menggunakan variasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model specular dinormalisasi menurut Blinn-Fong</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qx/rv/8c/qxrv8c9xk-4-akibiogsgnvxszw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wv/xw/_f/wvxw_f6h-5vgmu6cvlucuum3sei.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fb/f3/v1/fbf3v1y8ardyfkjtshlv8zf5ld8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ql/zq/lz/qlzqlzbbxwy_mlx05pwxwpxmrga.png"></div><br><h5>  Decals ditangguhkan </h5><br>  Seperti yang kita lihat di atas, Shadow of Mordor menampilkan jejak darah yang cukup rinci pada karakter yang terluka.  Ketika Talion melambaikan pedangnya, lingkungan juga menerima bagiannya dari darah orc gelap.  Namun, teknik lain digunakan untuk lingkungan - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">decals tangguhan</a> .  Teknik ini terdiri dari memproyeksikan serangkaian tekstur datar ke permukaan apa yang sebelumnya diberikan.  Dengan cara ini, isi buffer-G diganti dengan konten baru ini sebelum melakukan izin pencahayaan.  Dalam kasus darah, semprotan berdarah saja sudah cukup, dan ketika merender banyak stiker secara bergantian, lanskap yang agak suram dengan cepat dibuat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8_/zo/no/8_zonoux0rx6h_cemftpprebcke.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/sc/qn/pkscqng3m2s0c2hj-e-fs1eonis.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/a4/uf/rs/a4ufrsgki8blucgm4g8zq3n95ha.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dj/jl/3c/djjl3c5s2dsimxwtoim-c5vk3rg.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wj/hj/cb/wjhjcbcfdu0ts1kpnmh_2_tvhdq.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8r/tk/fi/8rtkfinzlyym0jweyx0gpizv4zs.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/ns/pw/uhnspwmomqsrlnoctsokx8q878a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/di/7m/70/di7m700h63pqtmaiydgrezyt0w4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8t/ky/sz/8tkyszkhinic56jqebsteeudram.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0a/tu/kj/0atukjo4vjzv3djehm6sttjhqps.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-5/vm/ja/-5vmjatrsxyfdjhqm5nhsmu_vxw.png"></div><br>  Hal terakhir yang diberikan dalam bagian G-buffer adalah langit, tekstur langit resolusi sangat tinggi (8192 × 2048) dalam format HDR BC6H.  Saya harus melakukan sedikit koreksi nada, karena dalam HDR semua warna terlalu gelap. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95a/6b2/dda/95a6b2dda3a632aebe8fc902f143232d.jpg" alt="gambar"></div><br><h3>  Tessellation </h3><br>  "Fitur" permainan yang sangat menarik (jika dihidupkan) adalah tessellation.  Ini digunakan untuk banyak hal yang berbeda, mulai dari medan hingga rendering karakter (serta alat peraga dan objek karakter).  Di sini, tessellation tidak membagi mesh mesh yang rendah, tetapi membuat poligon dari cloud titik, menggunakan tingkat pembagian yang diperlukan, tergantung pada kriteria tingkat detail, misalnya, pada jarak ke kamera.  Contoh yang menarik adalah jubah Talion, yang ditransmisikan ke GPU sebagai point cloud (setelah simulasi fisika), dan shader tessellation membuat ulang poligon. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1i/jf/3i/1ijf3ikncscrhyvhjyyan6kdx80.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wj/fp/il/wjfpil_rw7_t1z7pxrfntobcrse.png"></div><br><h3>  Transparansi bebas pesanan </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b78/f09/897/b78f09897b7ed45f990f51f91291c967.png"></div><br>  Salah satu hal pertama yang mengejutkan saya dengan keanehannya adalah lulus perawatan rambut, karena melakukan shader khusus yang sangat kompleks.  Dalam opsi grafik, opsi OIT (Order-Independent Transparency) untuk rambut disebutkan, yaitu, memang seharusnya begitu.  Pertama, ia melakukan output ke buffer terpisah dan menghitung jumlah total piksel transparan yang saling bertumpukan, sambil menyimpan properti dalam struktur "dalam" yang mirip dengan buffer-G.  Kemudian, shader lain mengurutkan fragmen individu individu sesuai dengan kedalamannya.  Tampaknya panah juga merender dengan cara ini (mungkin, bulu mereka membutuhkan penyortiran yang tepat).  Ini adalah efek yang sangat halus yang tidak menambahkan perbedaan grafik khusus, tetapi masih detail yang menarik.  Berikut adalah contoh sederhana: gambar di atas menunjukkan jumlah fragmen yang tumpang tindih (semakin merah, semakin banyak fragmen).  Transparansi reguler masih diurutkan berdasarkan CPU dan diterjemahkan sebagai alpha tradisional.  Hanya entitas individu yang termasuk dalam pass OIT. <br><br><h3>  Bayangan Mordor </h3><br>  SoM memiliki banyak sumber bayangan.  Selain peta bayangan tradisional sumber cahaya dinamis, SoM menggunakan oklusi ambien dua saluran di ruang layar, oklusi skala mikro yang dibuat untuk hampir semua objek dalam game, dan tekstur oklusi mirip dengan peta ketinggian dengan tampilan atas. <br><br><h5>  Oklusi di ruang layar </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cb/58c/fc5/2cb58cfc57777d65a15af4813977c962.png"></div><br>  Pass pertama merender menggunakan ambient G-buffer dan oklusi specular dalam ruang layar.  Shader itu sendiri adalah siklus besar yang tidak terlipat yang mengambil sampel baik peta kedalaman ukuran penuh dan peta kedalaman rata-rata yang sebelumnya dikurangi, mencari sampel tetangga dalam pola tertentu.  Ia menggunakan tekstur persegi 4x4 untuk memilih vektor pseudo-acak dalam mencari sumber oklusi.  Ini membuat buffer oklusi bising, yang kemudian dihaluskan oleh blur sederhana dalam dua lintasan.  Fitur yang paling menarik di sini adalah bahwa ada dua saluran oklusi yang berbeda: salah satunya digunakan sebagai oklusi spekulatif, dan yang lainnya sebagai oklusi difus.  Dalam implementasi SSAO standar, satu saluran dihitung yang berlaku untuk semua pencahayaan yang dipanggang.  Di sini, kartu SSAO juga dibaca untuk transmisi ke jalur pencahayaan directional, tempat kartu itu digunakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/re/xf/kj/rexfkjx49htyufzecfeg2n7lsau.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dl/va/nz/dlvanzzg8bpcqughsrout8kaxlg.png"></div><br><h5>  Kartu bayangan </h5><br>  Acara selanjutnya adalah rendering peta bayangan.  Karena aksi permainan terutama terjadi di ruang terbuka, sebagian besar cahaya dan bayangan diambil dari cahaya directional utama.  Di sini kita menggunakan teknik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cascading shadow map</a> (variasi di antaranya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://">shadow map yang dibagi paralel</a> ), teknik yang cukup standar untuk mengaplikasikan bayangan pada jarak jauh, yang terdiri dari rendering adegan yang sama dari satu sudut pandang sumber cahaya untuk area ruang yang berbeda.  Biasanya, bayangan peta jauh dari area jangkauan kamera berada pada jarak yang jauh atau memiliki resolusi lebih rendah dari yang sebelumnya, pada dasarnya mengurangi resolusi di daerah di mana detail masih tidak diperlukan karena fakta bahwa geometri terlalu jauh.  Dalam adegan ini, permainan membuat tiga kaskade bayangan 4096 × 4096 (pada kenyataannya, permainan memiliki tempat untuk empat).  Kaskade atas sangat dekat dengan Talion, dan yang lebih rendah mencakup gunung dan objek yang sangat jauh dari kamera.  Saat bekerja dengan bayangan, permainan menggunakan trik yang sama dengan koordinat z terbalik seperti pada peta kedalaman. \ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/347/7bc/a65/3477bca65b8cff92dfcfd68c9d66b8a8.jpg"></div><br><h5>  Buffer bayangan </h5><br>  Langkah selanjutnya adalah membuat buffer bayangan.  Ini adalah tekstur saluran tunggal, berdasarkan pada informasi oklusi dari peta bayangan sebelumnya, ini mengkodekan faktor bayangan dalam interval [0, 1].  Untuk membuat kehalusan di sekitar tepi, peta bayangan disampel 4 kali menggunakan keadaan sampler bilinear khusus, yang menerima 4 sampel dan membandingkannya dengan nilai yang diberikan (ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://">Penyaringan Tutup Persentase</a> ).  Mendapatkan banyak sampel dan rata-rata hasilnya sering disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Persentase Lebih Dekat Bayangan Lembut</a> .  Selain membaca peta bayangan, komponen terakhir dari buffer specular (yaitu, koefisien hamburan bawah permukaan) juga disampel, yang dikalikan dengan "faktor cahaya berdarah".  Tampaknya ini perlu untuk menghilangkan bayangan dari benda-benda ini, sehingga sedikit lebih banyak cahaya melewatinya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7f/b55/63f/b7fb5563faae1553e0f970374ee0b774.jpg"></div><br><h5>  Tekstur proyeksi arah </h5><br>  Sumber cahaya dan bayangan lainnya adalah tekstur tampilan atas yang diambil sampelnya dari sumber cahaya terarah.  Ini adalah cor warna yang ditambahkan ke warna sumber cahaya directional, ditambah efek naungan global yang berlaku untuk pencahayaan directional.  Tampaknya beberapa di antaranya dibuat secara manual di atas peta pencahayaan level yang dibuat secara otomatis dengan tampilan atas.  Tampaknya tepi bayangan untuk geometri statis disesuaikan secara manual (mungkin untuk menghindari konflik dengan peta bayangan nyata), dan beberapa bagian juga tampak sedikit diwarnai dengan tangan.  Mungkin tugas dari tekstur ini adalah penambahan biaya rendah dari oklusi ambien skala besar dan simulasi pencahayaan global yang ringan di samping pencahayaan terarah.  Gambar di bawah ini menunjukkan rona, penyumbatan, dan produk dari kedua faktor, yang memberi kita gambaran tentang seperti apa topeng warna akhir itu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6v/vf/6a/6vvf6aaf5khdrbclmwpzp9_faka.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7e/fs/fe/7efsferrjbdtsu9megpk0gtfidc.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/bk/sv/sdbksv3a4jlkgzxui4nvl-suylq.png"></div><br>  Hasil dari semua lintasan penerangan disimpan dalam target render dari format R11G11B10F.  Beginilah hasilnya.  Saya melakukan koreksi nada pada hasil untuk membuat efek pencahayaan terarah pada tingkat lebih terlihat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/28e/a63/f2a28ea6372642667b3778dfc32b193f.jpg"></div><br>  Semua gunung yang jauh (tidak ditampilkan dalam gambar di atas) juga diterangi oleh cahaya directional, tetapi mereka disorot sebagai kasing terpisah sehingga pencahayaan dapat dikontrol dengan lebih baik.  Beberapa diskalakan, tetapi yang lebih jauh sebenarnya adalah penipu dengan peta normal dan albedo yang dibuat secara cerdik.  Mereka memiliki sumber pencahayaan directional khusus yang hanya mempengaruhi pegunungan. <br><br><h3>  Pencahayaan statis </h3><br>  Shadow of Mordor menggunakan implementasi pencahayaan statis yang sangat intensif memori, yang menggunakan tekstur volume yang sangat besar.  Gambar di bawah ini menunjukkan tiga tekstur statis untuk jumlah penerangan yang digunakan untuk menerangi bagian area ini secara difus.  Masing-masing dari mereka adalah tekstur besar terkompresi 512x512x128 BC6H, yaitu, mereka menempati 32 MB per tekstur atau 96 MB secara umum (kami bermain dengan pengaturan kualitas maksimum).  Tekstur warna menunjukkan intensitas memasuki voxel.  Dua lainnya menunjukkan kekuatan atau besarnya intensitas ini sepanjang enam arah xyz dan -xyz, dan normal digunakan untuk memilih tiga komponen (xyz positif atau negatif, yang paling konsisten dengan normal).  Setelah membangun vektor ini, kami mengambil produk vektornya dengan kuadrat normal, dan ini menjadi faktor penskalaan untuk intensitas.  Rumusnya adalah sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l9/yw/vk/l9ywvkgxuoti8bbppke_2c8o068.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ez/j3/uf/ezj3ufolhefyqxafjqskci0msho.png"></div><br>  Volume Cahaya Statis juga membuat peta kubik untuk pencahayaan specular, yang kemungkinan ditangkap di tengah SLV.  Yang cukup menarik, tekstur volume menyimpan nilai HDR yang dikompres dalam BC6H, dan peta kubik disimpan dalam format BC3 (DXT5), yang tidak dapat menyimpan nilai floating point.  Untuk mengimbangi pembatasan ini, saluran alfa mempertahankan kecerahan, yang kemudian diukur dari 1-10.  Ini adalah keputusan yang aneh, dan bagi saya, ini lebih mirip implementasi Legacy.  Jangan lupa bahwa game ini dirilis untuk konsol generasi sebelumnya, yang tidak mendukung format tekstur HDR baru. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k3/qo/z-/k3qoz-zblorjdxi7jyqthripztg.png"></div><br>  Bingkai di bawah ini menunjukkan hasil "sebelum dan sesudah" dengan mempertimbangkan dampak dari gambar rata-rata.  Untuk visualisasi, saya melakukan koreksi nada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4i/iq/yo/4iiqyosjg2tmdud840rxbhstofa.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/su/of/cd/suofcd-ls4myfuivd5vqb9ykbgi.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/37/rq/wb/37rqwb76ngards_rywaxhb_x9xw.png"></div><br><h3>  Kabut atmosfer </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9af/086/c47/9af086c474cada9250daae007ec3c8bc.jpg"></div><br>  Shadow of Mordor memiliki sistem cuaca dan waktu, berkat itu matahari bersinar atau hujan menyirami permainan di Mordor.  Sistem ini dikendalikan oleh jumlah komponen, dan salah satu yang paling penting adalah kabut.  Shadow of Mordor menggunakan model kabut atmosfer yang cukup sederhana namun sehat secara fisik, termasuk hamburan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rayleigh</a> tunggal, serta hamburan oleh partikel bola (hamburan Mie). <br><br>  Ini dimulai dengan menghitung posisi kamera relatif terhadap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pusat bumi</a> .  Beberapa rumus trigonometri memungkinkan untuk menentukan di mana kamera berada di atmosfer, di mana piksel berada, dan berapa jarak yang ditempuh sinar di atmosfer pada ketinggian maksimum atmosfer yang diberikan.  Dalam kasus kami, atmosfer memiliki ketinggian 65.000 meter di atas permukaan planet ini.  Dengan informasi ini, Rayleigh dan koefisien partikel bola digunakan untuk menghitung kedua jenis kepadatan partikel kabut dan warnanya.  Kepadatan ini mengaburkan piksel yang sudah diarsir, menyebarkan cahaya memasuki kamera dari permukaan yang diarsir, dan berkontribusi terhadap kabut.  Saat mensimulasikan hamburan seperti itu, kecerahan dan arah matahari diperhitungkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ye/at/id/yeatidzdiemga1gntnm1zg9uz8k.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zj/39/zr/zj39zryuhmwdyadmcp0nb_g1uz8.png"></div><br><h3>  Kecepatan rana dan koreksi nada </h3><br>  Saat menghitung kecepatan rana, pendekatan yang cukup standar digunakan: mengurangi resolusi buffer kecerahan secara berurutan, dihitung dari buffer warna HDR utama, ke dalam rantai tekstur, yang masing-masing berukuran setengah ukuran tekstur sebelumnya, dimulai dengan tekstur 1/3 dari buffer frame utama.  Dengan penurunan resolusi ini, 4 sampel diambil, rata-rata nilai piksel tetangga, yaitu, setelah mengubah semua nilai rata-rata menjadi satu texel, hasil akhirnya menjadi kecerahan rata-rata.  Setelah tekstur mencapai ukuran 16 × 9 texels, penghitung shader diluncurkan, menjumlahkan semua texels yang tersisa.  Nilai ini segera dibaca dalam pass koreksi nada untuk mengubah nilai kecerahan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ig/bi/h4/igbih41dc2x9aytucfgq1z_iuye.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/os/gw/t8/osgwt8co0pqgvomovsydsemapuw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qh/bc/qv/qhbcqvqxy5hgvtn9x0c9kd1an6e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g-/dw/fm/g-dwfm48oqtvuu1bizc1sikm7sq.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zg/8w/oz/zg8wozwpviq0nnt4-kef9b9azis.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/56/ik/dc/56ikdcoixmrbo0whghswhxdzxhk.png"></div><br>  Untuk koreksi nada, operator Reinhardt digunakan, formula optimal yang dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Dalam kode hlsl, ini akan terlihat seperti ini: <br><br><pre><code class="cpp hljs">float3 hdrColor = tex2D(HDRTexture, uv.xy); hdrColor *= exposureValue; <span class="hljs-comment"><span class="hljs-comment">// This was calculated by the compute shader in the luminance downsampling pass float3 x = max(0.0, hdrColor - 0.004); float3 finalColor = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);</span></span></code> </pre> <br>  Jika kita memplot kurva ini, kita akan melihat bahwa operator ini membuang 10% dari nilai putih bahkan dengan nilai input 2.0, pada saat yang sama secara paksa meninggalkan sebagian kecil dari interval bawah sepenuhnya hitam.  Ini menciptakan gambar gelap yang tidak jenuh. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc2/ea1/097/cc2ea10970239fb761b995496c049a8b.jpg" alt="gambar"></div><br><h3>  Tahap alfa </h3><br>  Langkah alpha agak tidak biasa karena membuat objek langsung ke buffer LDR.  Game lain juga membuatnya di buffer HDR sehingga mereka dapat berpartisipasi dalam shutter pass.  Namun demikian, tekstur kecerahan yang dihitung sebelumnya terbatas pada semua objek yang diterangi alfa (dalam beberapa kasus, misalnya, untuk objek yang memancarkan cahaya, kecepatan rana dihitung menggunakan konstanta shader, bukan pencarian tekstur), dan oleh karena itu kecepatan rana diterapkan secara otomatis saat rendering, dan tidak dilakukan dalam postprocessing.  Kasus yang sangat spesifik menggunakan alfa dalam permainan adalah transisi ke mode hantu (di dalamnya hantu Celebrimbor ditampilkan di atas karakter pemain, ditempa dalam cincin kedaulatan alam semesta LOTR, sehingga, permainan menunjukkan bahwa ia selalu berada di dekatnya, meskipun tidak terlihat).  Gim ini melewati beberapa parameter ke jerat kedua karakter, yang mengontrol opacity dan memungkinkan gim untuk mengaburkan sebagian Talion dan secara bertahap menunjukkan Celebrimore.  Objek lain dalam game dalam mode hantu juga membuat versi hantu di atas objek buram, seperti musuh dan menara.  Ini adalah adegan lain dengan transisi ke dunia hantu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ux/ca/zs/uxcazsok9pqzuusfrb__dutdphw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6g/1c/9e/6g1c9esdqit50db_mbck516ma-0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f_/dq/ss/f_dqss-avlzlyrb4s6_z6kqog0e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uw/yy/va/uwyyvakydfnsksy49ntfltpbwp8.png"></div><br><h3>  Hujan </h3><br>  Dalam kerangka utama yang kami periksa, tidak ada hujan, tetapi cuacanya adalah bagian penting dari permainan yang ingin saya sebutkan di sini.  Ini dihasilkan dan disimulasikan dalam GPU, dan diberikan tepat pada akhir fase alpha.  Compute shader dijalankan yang melakukan simulasi dan menulis posisi ke buffer.  Posisi-posisi ini diambil oleh shader lain, yang dengan bantuan panggilan tidak langsung yang di-instal membuat banyak contoh paha depan seperti posisi-posisi yang dihitung pada lintasan sebelumnya.  Vertex shader memiliki quad sederhana, yang, jika perlu, dideformasi dan diputar ke arah kamera.  Untuk mencegah hujan menembus permukaan, vertex shader juga membaca peta ketinggian dari tampilan atas, yang memungkinkan Anda untuk menolak semua tetes di bawah permukaan yang tumpang tindih.  Peta ketinggian ini diberikan tepat di awal bingkai.  Vertex shader yang sama memberi tahu pixel shader tempat mendapatkan sampel dari tekstur drop;  jika dropnya dekat dengan permukaan, ia memilih area tekstur yang mengandung animasi splash.  Selain itu, tetesan air hujan melakukan perhitungan kabut dalam pixel shader untuk berbaur dengan adegan lainnya.  Berikut ini adalah tangkapan layar dari perspektif yang sama pada hari hujan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xv/yv/ds/xvyvds_w25ybjxilgvr5crbcpo4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3c/ox/ax/3coxaxhejifprppkaheiahszfcm.png"></div><br>  Ketika efek hujan diaktifkan, buffer specular dimodifikasi secara global untuk membuat permukaan basah, dan gelombang hujan dirender ke buffer normal.  Animasi ini diberi batas waktu, jadi hanya satu frame dari animasi melingkar yang digunakan.  Buffer normal yang ditunjukkan di bawah ini dimodifikasi untuk menunjukkan gelombang yang diberikan ke buffer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ur/du/mz/urdumzhuebf1o2pnud_b2ztlfik.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p3/cv/t_/p3cvt_qq7vo9txgwycf7l2oec2y.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/3d/u3/vc3du3ytthqfsw1h7vwzr0tfxom.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6y/tk/rk/6ytkrkj0w38kvccrtrjpey95c_w.png"></div><br><h3>  Lens Flare dan Bloom </h3><br>  Setelah rendering alfa selesai, suar lensa diberikan di atasnya.  Serangkaian paha depan bergeser diberikan mulai dari titik di mana cahaya arah berasal (dalam kasus kami, matahari).  Segera setelah ini, mekar lulus dilakukan.  Ini adalah teknik yang cukup standar, yang terdiri dari serangkaian ukuran yang diperkecil dan tekstur kabur yang mengandung piksel yang kecerahannya melebihi batas tertentu.  Dua lintasan mekar digunakan, umum dengan Gaussian blur untuk seluruh adegan dan blur radial khusus yang hanya berlaku untuk langit.  Radial blur adalah salah satu operasi yang menggunakan ID khusus dari G-buffer peta normal, karena hanya piksel di langit yang diperhitungkan.  Sebagai bonus, blur ini akan mencicipi peta kedalaman dan dapat membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sinar senja</a> berbiaya rendah.  Karena kami bekerja dengan buffer LDR pada tahap ini, nilai ambang mekar berbeda dari nilai dari karpet HDR (nilai di atas ambang batas, biasanya 1,0, mengarah ke perhitungan), dan ini berarti bahwa nilai mekar yang diperoleh darinya sedikit terbatas.  Bagaimanapun, ini bagus untuk permainan dan inilah hasilnya.  Pada gambar di bawah ini, warna-warna tekstur mip bloom terlihat sedikit aneh karena setiap piksel diskalakan oleh kecerahan yang terdapat dalam saluran alpha.  Kecerahan ini dihitung sebelumnya, pada tahap koreksi nada.  Dalam pengomposisian akhir, bloom dihitung sebagai <strong>bloom.rgb · bloom.a · bloomScale</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h3/2y/ra/h32yra8lvz_-pxsab9raxyfobei.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/le/2k/dx/le2kdxxuaqtjrdnhdvxfobubyhw.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jb/kz/mk/jbkzmkd2ans3vxvs_we9eowudvs.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xs/gs/dg/xsgsdgnvhckxgckfhs7k4hvpc7u.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v3/yr/hh/v3yrhhxazolya5nu8fn7id66p6k.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q8/r1/wl/q8r1wlekxf0tae6ivo6bfyjngie.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gw/5c/tj/gw5ctjh8owpukokne73nskb4n48.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8k/te/sg/8ktesgsr6ser_l6ssaorfcpniww.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j6/u6/ts/j6u6tsvqcjuwqqzepsfeogf330i.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ee/tf/vg/eetfvgkcuahvbbonuhfnpinh32w.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m-/zw/bc/m-zwbcp4qvnr69vn1unq1clh3ws.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ei/ta/-s/eita-ssnu2cqzwkspcrjan42-ua.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/db/cb/cs/dbcbcsoo_znq2ex30ixasi-c8le.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i4/ja/ro/i4jarols6px4f0nnbai-rk5r87u.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/na/ag/mj/naagmjq8e75kxcxmyhberqpslag.png"></div><br><h3>  Antialiasing + Kedalaman Lapangan </h3><br>  Tidak ada banyak yang bisa dikatakan tentang kedua operasi ini, pendekatan standar industri digunakan.  Lulus sederhana melalui antialiasing FXAA dilakukan segera setelah menyusun mekar dengan gambar LDR, dan kedalaman bidang dilakukan segera setelahnya.  Untuk kedalaman bidang, game membuat dua versi buram final buffer yang berkurang.  Kemudian kedalaman piksel digunakan untuk mencampur gambar yang buram dan normal, yang memberikan efek defocusing.  Demi kejelasan, dalam penangkapan ini, saya melebih-lebihkan efek kedalaman bidang.  Gim ini memiliki mode tangkapan layar bawaan, memungkinkan Anda untuk dengan mudah mengkonfigurasi kondisi ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ug/et/zf/ugetzfmh2jbbcpvrzb1e6dpwbhu.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p_/x4/fk/p_x4fkleolfxxnpvs9vnveywipy.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bi/vg/bp/bivgbpqa_nmzkx4zgiuzmu3nm6e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w2/vn/hg/w2vnhg6eoxe92rjat51qf65pggo.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uf/0g/kj/uf0gkjnripqq4ctkcpsremqrqnk.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bx/k5/z4/bxk5z47piwcgchqepehqpyypwgu.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ue/dc/xq/uedcxqx7svcjyq6g0-tp4uc1gho.png"></div><br><h3>  Motion blur </h3><br>  Motion blur terdiri dari dua lintasan.  Pertama, data dari orientasi kamera sebelumnya dan saat ini ditransfer ke buffer kecepatan layar penuh.  Dalam hal ini, dua saluran tekstur dipenuhi dengan kecepatan di ruang layar.  Sekarang, saluran r berisi besarnya perubahan piksel dalam arah horisontal layar, dan saluran g berisi besarnya dalam arah vertikal.  Ini adalah bagaimana strip radial diperoleh saat menggerakkan kamera.  Karakter ditampilkan lagi, kali ini mengisi saluran biru berdasarkan pose saat ini dan sebelumnya, seperti halnya dengan kamera.  Saluran biru digunakan untuk menandai apakah rendering harus di-render atau tidak.  Saluran alpha juga diisi dengan nilai konstan (0,0598), tetapi saya belum menyelidiki nilainya atau tujuannya.  Resolusi buffer kecepatan direduksi menjadi tekstur yang sangat kecil dengan rata-rata pada rentang kecepatan yang relatif luas dalam tekstur asli.  Pada lintasan terakhir, ini memberi setiap piksel perkiraan tentang apa radius blur akan berada dalam lintasan blur nyata. <br><br>  Kemudian blur pass membaca tekstur kecepatan, peta kedalaman, buffer warna asli, dan tekstur noise.  Yang terakhir digunakan untuk menyembunyikan efek gambar cermin, yang dapat terjadi dengan jenis blur dengan radius besar.  Kemudian, penyangga gambar disampel beberapa kali ke arah yang ditunjukkan oleh penyangga kecepatan, warna dirata-ratakan, yang mengarah pada pengaburan gambar ke arah vektor gerakan.  Juga, efek ini diskalakan sesuai dengan frame rate yang digunakan game.  Untuk penangkapan ini, saya harus membatasi permainan hingga 30fps, karena pada 60fps dan di atas ini hampir tidak terlihat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zn/4r/-7/zn4r-7rgnvx9zuh6asjnzqxknno.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hr/x_/yu/hrx_yug350grzjbnn6r6d9b7spa.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/94/i5/bc/94i5bcpjozmzuykcwfh9vksqjk8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n7/mr/zo/n7mrzoppnprexpqv5h7uj-xobvu.png"></div><br><h3>  Koreksi warna </h3><br>  Lulus akhir dari koreksi warna dilakukan dengan menggunakan "kubus warna".  Kubus warna adalah tekstur 3D yang komponen rgb-nya melekat pada koordinat xyz dari tekstur.  Koordinat xyz ini mengandung warna yang harus kita ganti dengan warna aslinya.  Dalam kasus kami, tabel pencarian (LUT) adalah netral (mis. Koordinat dan warna mengandung nilai yang sama), jadi saya memodifikasi adegan yang sama menggunakan preset yang disediakan gim di editor kamera. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-i/dk/rd/-idkrdltmru5ndotkyzhmdbwth4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/az/-x/it/az-xitiqseycg8t_mz0kuhjxh1m.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/p0/ds/emp0dsyarj3nhdi-s453p0p0rsa.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1e/9q/fa/1e9qfapyuezjdafa8licevb6csu.png"></div><br><h3>  Bingkai akhir </h3><br>  Setelah pembuatan bingkai utama dalam buffer terpisah, UI diberikan.  Ini memastikan bahwa terlepas dari ukuran yang dipilih untuk buffer belakang, UI akan selalu membuat jelas dan indah dalam ukuran jendela asli, sementara permainan dapat mengubah resolusi jika perlu untuk memastikan kecepatan.  Pada akhirnya, kedua tekstur dicampur bersama berdasarkan data saluran alpha UI, dan kemudian dirender ke dalam frame buffer akhir, yang siap untuk ditampilkan di layar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cv/ba/t9/cvbat95whbpymp0cfpnjmohp_oo.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i0/y0/qm/i0y0qmb9x6liyqlpcd4vs2rli3y.png"></div><br>  Saya harap Anda menikmati analisis saya.  Saya ingin mengucapkan terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Adrian Correge</a> atas karya luar biasa yang menginspirasi saya untuk mempelajari grafik, serta staf studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monolith</a> untuk permainan yang benar-benar tak terlupakan ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430518/">https://habr.com/ru/post/id430518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430506/index.html">Seni gelap kebangkitan: cara memulihkan data dari media yang rusak</a></li>
<li><a href="../id430508/index.html">DevOps: apa itu sebenarnya?</a></li>
<li><a href="../id430510/index.html">Bagaimana cara menulis kode yang semua orang akan mengerti?</a></li>
<li><a href="../id430512/index.html">Bagaimana freelancer hidup: jangan bekerja dengan klien yang tahu segalanya dan biarkan diri Anda menunda-nunda</a></li>
<li><a href="../id430514/index.html">Blockchain Charity - DataArt Menangkan Malta Blockchain Summit Hackathon</a></li>
<li><a href="../id430520/index.html">Memperkenalkan MongoDB Data Musim Semi</a></li>
<li><a href="../id430522/index.html">Apakah Anda memerlukan budaya perusahaan di bidang TI? Pengakuan manajer merek studio Krasnodar Plarium</a></li>
<li><a href="../id430524/index.html">Arsitektur Jaringan Saraf Tiruan</a></li>
<li><a href="../id430526/index.html">Mesin slot: dari mana asalnya di USSR dan bagaimana pengaturannya</a></li>
<li><a href="../id430528/index.html">Pemrograman dengan PyUSB 1.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>