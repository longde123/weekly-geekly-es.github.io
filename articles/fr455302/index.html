<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♠️ 👴🏼 🧠 Framework d'API Golang 🧑🏼‍🤝‍🧑🏼 👇🏼 👸🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans le processus de faire connaissance avec Golang, j'ai décidé de créer le cadre de l'application, qui me sera utile pour travailler à l'avenir. Le ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Framework d'API Golang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455302/"><p>  Dans le processus de faire connaissance avec Golang, j'ai décidé de créer le cadre de l'application, qui me sera utile pour travailler à l'avenir.  Le résultat a été, à mon avis, une bonne pièce, que j'ai décidé de partager, et en même temps de discuter des moments qui se sont produits lors de la création du cadre. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/599/73a/8a9/59973a8a925f690405c0f171fdd53048.jpg" alt="image"></p><br><p>  En principe, la conception du langage Go laisse entendre qu'il n'a pas besoin de faire des applications à grande échelle (je veux dire le manque de génériques et un mécanisme de gestion des erreurs peu puissant).  Mais nous savons toujours que la taille des applications ne diminue généralement pas, mais le plus souvent au contraire.  Par conséquent, il est préférable de créer immédiatement un framework sur lequel il sera possible de chaîner de nouvelles fonctions sans sacrifier le support du code. </p><a name="habracut"></a><br><p>  J'ai essayé d'insérer moins de code dans l'article, mais j'ai ajouté des liens vers des lignes de code spécifiques sur Github dans l'espoir qu'il serait plus pratique de voir l'image entière. </p><br><p>  Tout d'abord, j'ai esquissé un plan pour ce qui devrait être dans la demande.  Puisque je parlerai de chaque élément séparément dans l'article, je donnerai d'abord le principal de cette liste comme contenu. </p><br><ul><li>  Choisissez le gestionnaire de packages </li><li> Choisissez un cadre pour créer une API </li><li>  Sélectionnez l'outil pour l'injection de dépendance (DI) </li><li>  Itinéraires de demande Web </li><li>  Réponses JSON / XML selon les en-têtes de demande </li><li>  ORM </li><li>  Migrations </li><li>  Créer des classes de base pour les couches de modèle Service-&gt; Repository-&gt; Entity </li><li>  Dépôt CRUD de base </li><li>  Service CRUD de base </li><li>  Contrôleur CRUD de base </li><li>  Demande de validation </li><li>  Configurations et variables d'environnement </li><li>  Commandes de la console </li><li>  Journalisation </li><li>  Intégration de l'enregistreur avec Sentry ou un autre système d'alerte </li><li>  Définition d'une alerte pour les erreurs </li><li>  Tests unitaires avec redéfinition des services via DI </li><li>  Pourcentage et carte de code de couverture de test </li><li>  Swagger </li><li>  Docker compose </li></ul><br><h2 id="menedzher-paketov">  Gestionnaire de paquets </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Après avoir lu les</a> descriptions des différentes implémentations, j'ai choisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">govendor</a> et pour le moment j'étais satisfait du choix.  La raison est simple - elle vous permet d'installer des dépendances à l'intérieur du répertoire avec l'application, de stocker des informations sur les packages et leurs versions. </p><br><p>  Les informations sur les packages et leurs versions sont stockées dans un <a href="">fichier</a> vendor.json.  Il y a aussi un inconvénient à cette approche.  Si vous ajoutez un package avec ses dépendances, ainsi que des informations sur le package, des informations sur ses dépendances seront également incluses dans le fichier.  Le fichier se développe rapidement et il n'est plus possible de déterminer clairement quelles dépendances sont les principales et quelles sont les dérivées. </p><br><p>  Dans PHP composer ou dans npm, les principales dépendances sont décrites dans un seul fichier, et toutes les dépendances principales et dérivées et leurs versions sont automatiquement enregistrées dans le fichier de verrouillage.  Cette approche est plus pratique à mon avis.  Mais pour l'instant, la mise en œuvre du gouverneur m'a suffi. </p><br><h2 id="freymvork">  Cadre </h2><br><p>  Du framework je n'ai pas besoin de grand chose, d'un routeur pratique, de la validation des requêtes.  Tout cela a été trouvé dans le populaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gin</a> .  Il s'est arrêté dessus. </p><br><h2 id="dependency-injection">  Injection de dépendance </h2><br><p>  Avec DI, j'ai dû souffrir un peu.  D'abord choisi Dig.  Et au début, tout était super.  Services décrits, Dig construit davantage les dépendances, de manière pratique.  Mais il s'est avéré que les services ne pouvaient pas être redéfinis, par exemple, pendant les tests.  Par conséquent, à la fin, je suis arrivé à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conclusion</a> que j'ai pris un simple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sarulabs / di de</a> conteneur de service. </p><br><p>  Je devais juste le fourche, car hors de la boîte, il vous permet d'ajouter des services et interdit de les redéfinir.  Et lors de l'écriture d'autotests, à mon avis, il est plus pratique d'initialiser le conteneur comme dans l'application, puis de redéfinir certains services, en spécifiant des stubs à la place.  Dans fork, il a ajouté une méthode pour remplacer la description du service. </p><br><p> Mais à la fin, à la fois dans le cas de Dig et dans le cas du conteneur de service, j'ai dû mettre les tests dans un package séparé.  Sinon, il s'avère que les tests sont exécutés séparément dans des packages ( <code>go test model/service</code> ), mais ils ne démarrent pas immédiatement pour l'ensemble de l'application ( <code>go test ./...</code> ), en raison des dépendances cycliques qui surviennent dans ce cas. </p><br><h2 id="otvety-v-formate-jsonxml-v-sootvetstvii-s-zagolovkami-zaprosa">  Réponses JSON / XML selon les en-têtes de demande </h2><br><p>  Dans Gin, je ne l'ai pas trouvé, j'ai donc ajouté une <a href="">méthode</a> au contrôleur de base qui génère une réponse en fonction de l'en-tête de la demande. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c BaseController)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context *gin.Context, obj </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, code </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> context.GetHeader(<span class="hljs-string"><span class="hljs-string">"Accept"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"application/xml"</span></span>: context.XML(code, obj) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: context.JSON(code, obj) } }</code> </pre><br><h2 id="orm">  ORM </h2><br><p>  Avec ORM n'a pas ressenti le long tourment du choix.  Il y avait beaucoup de choix.  Mais selon la description des fonctionnalités, j'ai aimé GORM, qui est l'un des plus populaires au moment de la sélection.  Il existe un support pour les SGBD les plus couramment utilisés.  Au moins PostgreSQL et MySQL sont définitivement là.  Il propose également des méthodes de gestion du schéma de base que vous pouvez utiliser lors de la création de migrations. </p><br><h2 id="migracii">  Migrations </h2><br><p>  Pour les migrations, j'ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">opté pour</a> le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">package gorm-goose</a> .  Je mets un package séparé globalement et commence la migration vers celui-ci.  Au début, une telle implémentation était gênante, car la connexion à la base de données devait être décrite dans un <a href="">fichier db / dbconf.yml distinct</a> .  Mais il s'est avéré que la chaîne de connexion qu'elle contient pouvait être décrite de telle manière que la valeur soit prise dans la variable d'environnement. </p><br><pre> <code class="plaintext hljs">development: driver: postgres open: $DB_URL</code> </pre> <br><p>  Et c'est assez pratique.  Au moins avec docker-compose, je n'ai pas eu à dupliquer la <a href="">chaîne de connexion</a> . </p><br><p>  Gorm-goose prend également en charge les annulations de migration, ce que je trouve très utile. </p><br><h2 id="bazovyy-crud-repozitoriy">  Dépôt CRUD de base </h2><br><p>  Je préfère que tout ce qui fait référence aux ressources soit placé dans une couche de référentiel distincte.  À mon avis, avec cette approche, le code de logique métier est plus propre.  Dans ce cas, le code logique métier sait seulement qu'il doit travailler avec les données qu'il prend dans le référentiel.  Et ce qui se passe dans le référentiel, la logique métier n'est pas importante.  Le référentiel peut fonctionner avec une base de données relationnelle, avec un stockage KV, avec un disque, ou peut-être avec l'API d'un autre service.  Le code logique métier sera le même dans tous ces cas. </p><br><p>  Le référentiel CRUD implémente l' <a href="">interface</a> suivante </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> CrudRepositoryInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { BaseRepositoryInterface GetModel() (entity.InterfaceEntity) Find(id <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) (entity.InterfaceEntity, error) List(parameters ListParametersInterface) (entity.InterfaceEntity, error) Create(item entity.InterfaceEntity) entity.InterfaceEntity Update(item entity.InterfaceEntity) entity.InterfaceEntity Delete(id <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) error }</code> </pre> <br><p>  Autrement dit, CRUD implémente les opérations <code>Create()</code> , <code>Find()</code> , <code>List()</code> , <code>Update()</code> , <code>Delete()</code> et la méthode <code>GetModel()</code> . </p><br><p>  À propos de <a href="">GetModel ()</a> .  Il existe un référentiel de base <code>CrudRepository</code> qui implémente les opérations CRUD de base.  Dans les référentiels qui l'intègrent en eux-mêmes, il suffit d'indiquer avec quel modèle ils doivent travailler.  Pour ce faire, la méthode <code>GetModel()</code> doit renvoyer un modèle GORM.  Ensuite, nous avons dû utiliser le résultat de <code>GetModel()</code> utilisant la réflexion dans les méthodes CRUD. </p><br><p>  <a href="">Par exemple</a> </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c CrudRepository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(entity.InterfaceEntity, error)</span></span></span></span> { item := reflect.New(reflect.TypeOf(c.GetModel()).Elem()).Interface() err := c.db.First(item, id).Error <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item, err }</code> </pre> <br><p>  En effet, dans ce cas, il a fallu abandonner le typage statique au profit du typage dynamique.  À de tels moments, le manque de génériques dans la langue est particulièrement ressenti. </p><br><p>  Pour que les référentiels qui fonctionnent avec des modèles spécifiques implémentent leurs propres règles de filtrage des listes dans la méthode <code>List()</code> , j'ai d'abord implémenté la liaison tardive afin que la méthode responsable de la construction de la requête de sélection soit appelée à partir de la méthode <code>List()</code> .  Et cette méthode pourrait être implémentée dans un référentiel spécifique.  Il est difficile d'abandonner en quelque sorte les schémas de pensée qui se sont formés en travaillant avec d'autres langues.  Mais en le regardant avec un regard neuf et en appréciant «l'élégance» du chemin choisi, il l'a refait à une approche plus proche de Go.  Pour ce faire, simplement dans <code>CrudRepository</code> via l'interface, <a href="">un générateur de requêtes est</a> déclaré, qui est déjà <a href=""><code>  List()</code></a> . </p><br><pre> <code class="go hljs">listQueryBuilder ListQueryBuilderInterface</code> </pre><br><p>  Cela s'avère assez drôle.  Limiter le langage à une liaison tardive, ce qui semble à première vue comme une faille, encourage une séparation plus claire du code. </p><br><h2 id="bazovyy-crud-servis">  Service CRUD de base </h2><br><p>  Il n'y a rien d'intéressant ici, car il n'y a pas de logique métier dans le cadre.  Les appels des méthodes CRUD au référentiel sont simplement <a href="">mandatés</a> . </p><br><p>  Dans la couche services, la logique métier doit être implémentée. </p><br><h2 id="bazovyy-crud-kontroller">  Contrôleur CRUD de base </h2><br><p>  Le contrôleur implémente <a href="">les méthodes CRUD</a> .  Ils traitent les paramètres de la demande, le contrôle est transféré à la méthode de service correspondante, et en fonction de la réponse du service, une réponse est formée pour le client. </p><br><p>  Avec le contrôleur, j'ai eu la même histoire qu'avec le référentiel concernant les listes de filtrage.  En conséquence, j'ai refait l'implémentation avec une liaison tardive maison et ajouté un <a href="">hydrateur</a> , qui, en fonction des paramètres de la demande, forme une structure avec des paramètres pour filtrer la liste. </p><br><p>  Dans l'hydrateur fourni avec le contrôleur CRUD, seuls les paramètres de pagination sont traités.  Dans les contrôleurs spécifiques dans lesquels le contrôleur CRUD est intégré, l' <a href="">hydrateur</a> peut être <a href="">redéfini</a> . </p><br><h2 id="validaciya-zaprosov">  Demande de validation </h2><br><p>  La validation est effectuée par Gin.  Par exemple, lors de l'ajout d'un enregistrement (méthode <code>Create()</code> ), il suffit de <a href="">décorer les</a> éléments de la structure d'entité </p><br><pre> <code class="go hljs">Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`binding:"required"`</span></span></code> </pre> <br><p>  La méthode <a href=""><code>ShouldBindJSON()</code></a> du <a href=""><code>ShouldBindJSON()</code></a> prend en charge la vérification des paramètres de requête pour la conformité aux exigences décrites dans le décorateur. </p><br><h2 id="konfigi-i-peremennye-okruzheniya">  Configurations et variables d'environnement </h2><br><p>  J'ai vraiment aimé l'implémentation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Viper</a> , surtout en conjonction avec Cobra. </p><br><p>  Lire la configuration que j'ai <a href="">décrite dans main.go.</a>  Les paramètres de base qui ne contiennent pas de secrets sont décrits <a href="">dans le fichier base.env</a> .  Vous pouvez les remplacer dans le fichier .env qui est ajouté à .gitignore.  En .env, vous pouvez décrire des valeurs secrètes pour l'environnement. </p><br><p>  Les variables d'environnement ont une priorité plus élevée. </p><br><h2 id="konsolnye-komandy">  Commandes de la console </h2><br><p>  Pour la description des commandes de la console, j'ai choisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cobra</a> .  Qu'il est bon d'utiliser Cobra avec Viper.  Nous pouvons <a href="">décrire la commande</a> </p><br><pre> <code class="go hljs">serverCmd.PersistentFlags().StringVar(&amp;serverPort, <span class="hljs-string"><span class="hljs-string">"port"</span></span>, defaultServerPort, <span class="hljs-string"><span class="hljs-string">"Server port"</span></span>)</code> </pre> <br><p>  Et <a href="">liez la variable d'environnement</a> à la valeur du paramètre de commande </p><br><pre> <code class="go hljs">viper.BindPFlag(<span class="hljs-string"><span class="hljs-string">"SERVER_PORT"</span></span>, serverCmd.PersistentFlags().Lookup(<span class="hljs-string"><span class="hljs-string">"port"</span></span>))</code> </pre> <br><p>  En fait, toute l'application de ce framework est console.  Le serveur Web est lancé par l'une des commandes de la console du serveur. </p><br><pre> <code class="bash hljs">gin -i run server</code> </pre> <br><h2 id="logirovanie">  Journalisation </h2><br><p>  J'ai choisi le package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">logrus</a> pour la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">journalisation</a> , car il contient tout ce dont j'ai généralement besoin: définir les niveaux de journalisation, où se connecter, ajouter des hooks, par exemple, pour envoyer des journaux au système d'alerte. </p><br><h2 id="integraciya-loggera-s-sistemoy-alertinga">  Intégration de l'enregistreur avec le système d'alerte </h2><br><p>  J'ai choisi Sentry, car tout s'est avéré assez simple grâce à l'intégration facile avec logrus: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">logrus_sentry</a> .  J'ai fait les <a href="">paramètres</a> avec l'URL de Sentry <code>SENTRY_DSN</code> et le délai pour envoyer à Sentry <code>SENTRY_TIMEOUT</code> .  Il s'est avéré que par défaut, le délai d'attente est petit, sinon erroné, 300 ms, et de nombreux messages n'ont pas été remis. </p><br><h2 id="nastroyka-alertinga-dlya-oshibok">  Définition d'une alerte pour les erreurs </h2><br><p>  J'ai fait un traitement de panique séparément pour le <a href="">serveur Web</a> et pour <a href="">les commandes de la console</a> . </p><br><h2 id="yunit-testy-s-pereopredeleniem-servisov-cherez-di">  Tests unitaires avec redéfinition des services via DI </h2><br><p>  Comme indiqué ci-dessus, un package séparé devait être alloué pour les tests unitaires.  Étant donné que la bibliothèque sélectionnée pour créer un conteneur de services ne permettait pas de redéfinir les services, dans fork a ajouté une méthode pour redéfinir la description des services.  De ce fait, dans le test unitaire, vous pouvez <a href="">utiliser</a> la même description de services que dans l'application </p><br><pre> <code class="go hljs">dic.InitBuilder()</code> </pre> <br><p>  Et <a href="">redéfinissez</a> seulement certaines descriptions de service dans les talons de cette façon </p><br><pre> <code class="go hljs">dic.Builder.Set(di.Def{ Name: dic.UserRepository, Build: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctn di.Container)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewUserRepositoryMock(), <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }, })</code> </pre> <br><p>  Ensuite, vous pouvez <a href="">créer un conteneur</a> et utiliser les services nécessaires dans le test: </p><br><pre> <code class="go hljs">dic.Container = dic.Builder.Build() userService := dic.Container.Get(dic.UserService).(service.UserServiceInterface)</code> </pre> <br><p>  Ainsi, nous testerons userService, qui au lieu du vrai référentiel utilisera le stub fourni. </p><br><p>  Pourcentage et carte de code de couverture de test <br>  J'étais complètement satisfait de l'utilitaire standard de test go. </p><br><p>  Vous pouvez exécuter des tests individuellement </p><br><pre> <code class="bash hljs">go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/unit/user_service_test.go -v</code> </pre> <br><p>  Vous pouvez exécuter tous les tests en même temps </p><br><pre> <code class="bash hljs">go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ./... -v</code> </pre> <br><p>  Vous pouvez créer une carte de couverture et calculer le pourcentage de couverture </p><br><pre> <code class="bash hljs">go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ./... -v -coverpkg=./... -coverprofile=coverage.out</code> </pre> <br><p>  Et voir une carte de la couverture du code avec des tests dans un navigateur </p><br><pre> <code class="bash hljs">go tool cover -html=coverage.out</code> </pre> <br><h2 id="swagger">  Swagger </h2><br><p>  Il existe un projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gin-swagger</a> pour Gin, qui peut être utilisé à la fois pour générer des spécifications pour Swagger et pour générer une documentation basée sur celui-ci.  Mais, comme il s'est avéré, afin de générer des spécifications pour des opérations spécifiques, il est nécessaire d'indiquer des commentaires sur des fonctions spécifiques du contrôleur.  Cela ne s'est pas avéré très pratique pour moi, car je ne voulais pas dupliquer le code d'opérations CRUD dans chaque contrôleur.  Au lieu de cela, dans des contrôleurs spécifiques, j'incorpore simplement un contrôleur CRUD comme décrit ci-dessus.  Je ne voulais pas vraiment non plus créer de fonctions de stub pour cela. </p><br><p>  Par conséquent, je suis arrivé à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conclusion</a> que la spécification est générée à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">goswagger</a> , car dans ce cas, les opérations <a href="">peuvent être décrites sans être liées à des fonctions spécifiques</a> . </p><br><pre> <code class="bash hljs">swagger generate spec -o doc/swagger.yml</code> </pre> <br><p>  Soit dit en passant, avec goswagger, vous pouvez même aller de l'inverse et générer le code du serveur Web basé sur la spécification Swagger.  Mais avec cette approche, il y avait des difficultés à utiliser ORM, et je l'ai finalement abandonné. </p><br><p>  La documentation est générée à l'aide de gin-swagger, pour cela un fichier de spécifications pré-généré est <a href="">indiqué</a> . </p><br><h2 id="docker-compose">  Docker compose </h2><br><p>  Dans le cadre, j'ai ajouté une description de deux conteneurs - <a href="">pour le code et pour la base</a> .  Au début du conteneur avec le code, nous attendons que le conteneur avec la base soit complètement lancé.  Et à chaque démarrage, nous effectuons des migrations si nécessaire.  Les paramètres de connexion à la base de données pour les migrations sont décrits, comme mentionné ci-dessus, dans <a href="">dbconf.yml</a> , où il était possible d'utiliser la <a href="">variable d'environnement</a> pour transférer les paramètres de connexion à la base de données. </p><br><p>  Merci de votre attention.  Dans le processus, j'ai dû m'adapter aux caractéristiques de la langue.  Je serais intéressé de connaître l'opinion de collègues qui ont passé plus de temps avec Go.  Certes, certains moments pourraient être rendus plus élégants, donc je serai heureux de recevoir des critiques utiles.  Lien vers le cadre: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/zubroide/go-api-boilerplate</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455302/">https://habr.com/ru/post/fr455302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455286/index.html">Dents de sagesse: ne peuvent pas être enlevées</a></li>
<li><a href="../fr455288/index.html">Nouvelles de la semaine: bloqueur de publicités pour entreprises dans les clés de chiffrement Chrome, FSB et Yandex, la communication devient plus chère</a></li>
<li><a href="../fr455290/index.html">Le guide complet de Prométhée en 2019</a></li>
<li><a href="../fr455292/index.html">Comment augmenter 4 fois la durée d'exécution des appareils avec auto-alimentation</a></li>
<li><a href="../fr455294/index.html">Guide: comment choisir un vélo électrique en utilisant Twitter comme exemple - parler de cadres</a></li>
<li><a href="../fr455306/index.html">Réponses à vos questions sur les raisons pour lesquelles vous avez besoin d'un éditeur pour publier un livre</a></li>
<li><a href="../fr455308/index.html">Endroit prometteur</a></li>
<li><a href="../fr455310/index.html">Attaques sur les canaux de contournement: désormais non seulement les PC mais aussi les smartphones sont attaqués (revue analytique)</a></li>
<li><a href="../fr455312/index.html">Additionneur complet un bit sur des puces inhabituelles</a></li>
<li><a href="../fr455314/index.html">Qu'est-ce qu'un réseau de services</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>