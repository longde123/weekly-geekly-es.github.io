<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ï üë©üèø‚Äçüè≠ ü¶â Kryptografische Token von PKCS # 11: Anzeigen und Exportieren von Zertifikaten, √úberpr√ºfen ihrer G√ºltigkeit üïü üéµ üë®üèæ‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den Kommentaren zum Artikel ‚ÄûEin plattform√ºbergreifendes Dienstprogramm in englischer Sprache zum Anzeigen russisch qualifizierter x509-Zertifikate...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kryptografische Token von PKCS # 11: Anzeigen und Exportieren von Zertifikaten, √úberpr√ºfen ihrer G√ºltigkeit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443480/"><img src="https://habrastorage.org/webt/jg/xr/s2/jgxrs2y4nfsgsn6ljt8l0wpevgy.png" align="left" alt="Bild">  In den Kommentaren zum Artikel ‚ÄûEin plattform√ºbergreifendes Dienstprogramm in englischer Sprache zum Anzeigen russisch qualifizierter x509-Zertifikate‚Äú wurde von einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Pas-</a> Benutzer der Wunsch gefordert, nicht nur ‚ÄûZertifikatsanalyse‚Äú durchzuf√ºhren, sondern auch ‚ÄûKetten von Stammzertifikaten zu erhalten und eine PKI-Validierung durchzuf√ºhren, zumindest f√ºr Zertifikate mit Token mit einem nicht extrahierenden Schl√ºssel ".  Das Erhalten einer Zertifikatskette wurde in einem der vorherigen Artikel beschrieben.  Es ging zwar um in Dateien gespeicherte Zertifikate, aber wir haben versprochen, Mechanismen f√ºr die Arbeit mit Zertifikaten hinzuzuf√ºgen, die auf PKCS # 11-Token gespeichert sind.  Und genau das ist am Ende passiert. <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/cg/vd/fw/cgvdfwfqdxc1tbvkkpcec_vzye8.png"><br><br>  Das Dienstprogramm zum Parsen und Anzeigen ist in Tcl / Tk geschrieben. Um PKCS # 11-Token / Smartcards hinzuzuf√ºgen, Zertifikate anzuzeigen und die G√ºltigkeit von Zertifikaten zu √ºberpr√ºfen, mussten verschiedene Probleme gel√∂st werden: <br><br><ul><li>  den Mechanismus zum Erhalten von Zertifikaten vom Token / der Smartcard bestimmen; </li><li>  √úberpr√ºfen Sie das Zertifikat anhand der Liste der widerrufenen CRL-Zertifikate. </li><li>  √úberpr√ºfen Sie das G√ºltigkeitszertifikat durch den OCSP-Mechanismus. </li></ul><br><h3>  <font color="#0000ff">Zugriff auf PKCS # 11 Token</font> </h3><br>  Um auf das Token und die darauf gespeicherten Zertifikate zuzugreifen, verwenden wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TclPKCS11-</a> Paket.  Das Paket wird sowohl in Bin√§rdateien als auch in Quellcodes verteilt.  Die Quellcodes werden sp√§ter n√ºtzlich sein, wenn wir dem Paket Token-Unterst√ºtzung mit russischer Kryptographie hinzuf√ºgen.  Es gibt zwei M√∂glichkeiten, das TclPKCS11-Paket herunterzuladen oder den Befehl tcl des Formulars zu verwenden: <br><br><pre><code class="plaintext hljs">load &lt; tclpkcs11&gt; Tclpkcs11</code> </pre> <br>  Oder laden Sie es einfach als pki :: pkcs11-Paket herunter, nachdem Sie die Bibliothek tclpkcs11 und die Datei pkgIndex.tcl in ein f√ºr Sie geeignetes Verzeichnis gestellt haben (in unserem Fall ist dies das Unterverzeichnis pkcs11 des aktuellen Verzeichnisses) und dem Pfad auto_path hinzugef√ºgt haben: <br><br><pre> <code class="plaintext hljs">#lappend auto_path [file dirname [info scrypt]] lappend auto_path pkcs11 package require pki package require pki::pkcs11</code> </pre> <br>  Da wir an Token interessiert sind, die haupts√§chlich die russische Kryptographie unterst√ºtzen, werden wir aus dem TclPKCS11-Paket die folgenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen verwenden</a> : <br><blockquote><pre> <code class="plaintext hljs">::pki::pkcs11::loadmodule &lt;filename&gt; -&gt; handle ::pki::pkcs11::unloadmodule &lt;handle&gt; -&gt; true/false ::pki::pkcs11::listslots &lt;handle&gt; -&gt; list: slotId label flags ::pki::pkcs11::listcerts &lt;handle&gt; &lt;slotId&gt; -&gt; list: keylist ::pki::pkcs11::login &lt;handle&gt; &lt;slotId&gt; &lt;password&gt; -&gt; true/false ::pki::pkcs11::logout &lt;handle&gt; &lt;slotId&gt; -&gt; true/false</code> </pre> </blockquote>  Reservieren Sie sofort, dass die Anmelde- und Abmeldefunktionen hier nicht ber√ºcksichtigt werden.  Dies liegt an der Tatsache, dass in diesem Artikel nur Zertifikate behandelt werden und es sich um √∂ffentliche Tokenobjekte handelt.  Um auf √∂ffentliche Objekte zugreifen zu k√∂nnen, m√ºssen Sie sich nicht √ºber den PIN-Code auf dem Token anmelden. <br><br>  Die erste Funktion :: pki :: pkcs11 :: loadmodule besteht darin, die PKCS # 11-Bibliothek zu laden, die das Token / die Smartcard unterst√ºtzt, auf der sich die Zertifikate befinden.  Eine Bibliothek kann entweder durch den Kauf eines Tokens erworben oder aus dem Internet heruntergeladen oder auf einem Computer vorinstalliert werden.  In jedem Fall m√ºssen Sie wissen, welche Bibliothek Ihr Token unterst√ºtzt.  Die Funktion loadmodule gibt ein Handle an die geladene Bibliothek zur√ºck: <br><br><pre> <code class="plaintext hljs">set filelib "/usr/local/lib64/librtpkcs11ecp_2.0.so" set handle [::pki::pkcs11::loadmodule $filelib]</code> </pre> <br>  Dementsprechend gibt es eine Funktion zum Entladen einer geladenen Bibliothek: <br><br><pre> <code class="plaintext hljs">::pki::pkcs11::unloadmodule $handle</code> </pre> <br>  Nachdem die Bibliothek geladen wurde und wir das Handle haben, k√∂nnen Sie eine Liste der von dieser Bibliothek unterst√ºtzten Slots abrufen: <br><br><pre> <code class="plaintext hljs">::pki::pkcs11::listslots $handle {0 {ruToken ECP } {TOKEN_PRESENT RNG LOGIN_REQUIRED USER_PIN_INITIALIZED TOKEN_INITIALIZED REMOVABLE_DEVICE HW_SLOT}} {1 { } {REMOVABLE_DEVICE HW_SLOT}} . . . {14 { } {REMOVABLE_D EVICE HW_SLOT}}</code> </pre> <br>  In diesem Beispiel enth√§lt die Liste 15 (f√ºnfzehn von 0 bis 14) Elemente.  So viele Slots kann die Token-Familie RuToken unterst√ºtzen.  Jedes Element der Liste selbst ist wiederum eine Liste von drei Elementen: <br><br><pre> <code class="plaintext hljs">{{ } { } {   }}</code> </pre> <br>  Das erste Element der Liste ist die Steckplatznummer.  Das zweite Element der Liste ist die Bezeichnung im Token-Slot (32 Byte).  Wenn der Steckplatz leer ist, enth√§lt das zweite Element 32 Leerzeichen.  Und das letzte, dritte Element der Liste enth√§lt Flags.  Wir werden nicht den gesamten Satz von Flags betrachten.  Was uns an diesen Flags interessiert, ist das Vorhandensein des TOKEN_PRESENT-Flags.  Dieses Flag zeigt an, dass sich das Token im Steckplatz befindet und sich die f√ºr uns interessanten Zertifikate auf dem Token befinden k√∂nnen.  Flags sind eine sehr n√ºtzliche Sache, sie beschreiben den Status des Tokens, den Status von PIN-Codes usw.  Basierend auf dem Wert der Flags werden PKCS # 11-Token verwaltet: <br><br><img src="https://habrastorage.org/webt/yq/7x/n1/yq7xn1qbusjtjirrudo1ebhjzhc.png"><br><br>  Jetzt hindert Sie nichts mehr daran, die Prozedur slots_with_token zu schreiben, die eine Liste der Slots mit den Beschriftungen der darin enthaltenen Token zur√ºckgibt: <br><br><pre> <code class="plaintext hljs">#!/usr/bin/tclsh lappend auto_path pkcs11 package require pki package require pki::pkcs11 #    proc ::slots_with_token {handle} { set slots [pki::pkcs11::listslots $handle] # puts "Slots: $slots" array set listtok [] foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set listtok($slotid) $slotlabel } } #     parray listtok return [array get listtok] } set filelib "/usr/local/lib64/librtpkcs11ecp_2.0.so" if {[catch {set handle [::pki::pkcs11::loadmodule $filelib]} res]} { puts "Cannot load library $filelib : $res" exit } #   set listslots {} set listslots [::slots_with_token $handle] #        while {[llength $listslots] == 0} { puts " " after 3000 set listslots [::slots_with_token $handle] } #        foreach {slotid labeltok} $listslots { puts "Number slot: $slotid" puts "Label token: $labeltok" }</code> </pre> <br>  Wenn Sie dieses Skript ausf√ºhren, nachdem Sie es in der Datei slots_with_token.tcl gespeichert haben, erhalten wir als Ergebnis: <br><br><pre> <code class="bash hljs">$ ./slots_with_token.tcl listtok(0) = ruToken ECP listtok(1) = RuTokenECP20 Number slot: 0 Label token: RuTokenECP20 Number slot: 1 Label token: ruToken ECP $</code> </pre> <br>  Von den 15 verf√ºgbaren Slots f√ºr diese Bibliothek sind nur zwei betroffen, null und der erste. <br>  Jetzt hindert nichts mehr daran, eine Liste von Zertifikaten zu erhalten, die sich auf einem bestimmten Token befinden: <br><br><pre> <code class="plaintext hljs">set listcerts [::pki::pkcs11::listcerts $handle $slotid]</code> </pre> <br>  Jedes Listenelement enth√§lt Informationen zu einem Zertifikat.  Um Informationen aus dem Zertifikat zu erhalten, verwendet die Funktion :: pki :: pkcs11 :: listcerts die Funktion :: pki :: x509 :: parse_cert aus dem pki-Paket.  Die Funktion :: pki :: pkcs11 :: listcerts erg√§nzt diese Liste jedoch mit Daten, die dem PKCS # 11-Protokoll inh√§rent sind, n√§mlich: <br><br><ul><li>  pkcs11_ label element (in der Terminologie des PKCS # 11-Attributs CKA_LABEL); </li><li>  pkcs11_id-Element (in der Terminologie des PKCS # 11-Attributs CKA_ID); </li><li>  pkcs11_handle-Element, das eine Angabe der geladenen PKCS # 11-Bibliothek enth√§lt; </li><li>  pkcs11_slotid-Element, das die Nummer des Steckplatzes mit dem Token enth√§lt, auf dem sich dieses Zertifikat befindet; </li><li>  Ein Tybelement, das den Wert pkcs11 f√ºr das Zertifikat enth√§lt, das sich auf dem Token befindet. </li></ul><br>  Denken Sie daran, dass die verbleibenden Elemente haupts√§chlich von der Funktion pki :: parse_cert bestimmt werden. <br>  Im Folgenden wird beschrieben, wie Sie eine Liste von Labels (listCert) von Zertifikaten (CKA_LABEL, pkcs11_label) und ein Array von analysierten Bezeichnern (:: certs_p11) erhalten.  Der Schl√ºssel f√ºr den Zugriff auf das Element des Zertifikatarrays ist die Zertifikatbezeichnung (CKA_LABEL, pkcs11_label): <br><br><pre> <code class="plaintext hljs">#  proc listcerttok {handle token_slotlabel token_slotid} { #     set listCer {} #   array set ::arrayCer [] set ::certs_p11 [pki::pkcs11::listcerts $handle $token_slotid] if {[llength $::certs_p11] == 0} { puts {Certificates are not on the token:$tokenslotlabel} return $listCer } foreach certinfo_list $::certs_p11 { unset -nocomplain certinfo array set certinfo $certinfo_list set certinfo(pubkeyinfo) [::pki::x509::parse_cert_pubkeyinfo $certinfo(cert)] set ::arrayCer($certinfo(pkcs11_label)) $certinfo(cert) lappend listCer $certinfo(pkcs11_label) } return $listCer }</code> </pre> <br>  Und jetzt, da wir Zertifikate analysiert haben, zeigen wir leise eine Liste ihrer Labels in der Combobox an: <br><br><img src="https://habrastorage.org/webt/wd/7_/si/wd7_siithrzlh1gfwa5tm78rpbg.png"><br><br>  Wie man √∂ffentliche GOST-Schl√ºssel analysiert, haben wir im vorherigen Artikel betrachtet. <br><br>  Zwei W√∂rter zum Zertifikatsexport.  Zertifikate werden sowohl in PEM-Codierung als auch in DER-Codierung (DER-Schaltfl√§chen, PEM-Format) exportiert.  Das pki-Paket verf√ºgt √ºber eine praktische Funktion pki :: _ encode_pem zum Konvertieren in das PEM-Format: <br><br><pre> <code class="plaintext hljs">set bufpem [::pki::_encode_pem &lt;der-buffer&gt; &lt;Headline&gt; &lt;Lastline&gt;]</code> </pre> <br>  zum Beispiel: <br><br><pre> <code class="plaintext hljs">set certpem [::pki::encode_pen $cert_der "-----BEGIN CERTIFICATE-----" "-----END CERTIFICATE-----"]</code> </pre> <br>  Durch Auswahl des Etiketts f√ºr septische Zertifikate in der Combobox erhalten wir Zugriff auf den Hauptteil des Zertifikats: <br><br><pre> <code class="plaintext hljs">#    set nick [.saveCert.labExp.listCert get] #        foreach certinfo_list $::certs_p11 { unset -nocomplain cert_parse array set cert_parse $certinfo_list if {$cert_parse(pkcs11_label) == $nick} { #   set cert_parse(pubkeyinfo) [::pki::x509::parse_cert_pubkeyinfo $cert_parse(cert)] break } } #   file|pkcs11 set ::tekcert "pkcs11"</code> </pre> <br>  Ein weiterer Mechanismus zum Parsen und Anzeigen des Zertifikats wurde hier bereits erl√§utert. <br><br><h3>  <font color="#0000ff">Zertifikatsvalidierung</font> </h3><br>  Beim Parsen des Zertifikats speichern die Variablen :: notbefore und :: notafter das Datum, ab dem das Zertifikat f√ºr kryptografische Vorg√§nge (Signieren, Verschl√ºsseln usw.) verwendet werden kann, sowie das Ablaufdatum des Zertifikats.  Das Verfahren zur √úberpr√ºfung der G√ºltigkeitsdauer eines Zertifikats hat folgende Form: <br><br><pre> <code class="plaintext hljs">proc cert_valid_date {} { #       #    set startdate $::notbefore #    set enddate $::notafter #      set now [clock seconds] set isvalid 1 set reason "Certificate is valid" if {$startdate &gt; $now} { set isvalid 0 #      set reason "Certificate is not yet valid" } elseif {$now &gt; $enddate} { set isvalid 0 #    set reason "Certificate has expired" } return [list $isvalid $reason] }</code> </pre> <br>  Die zur√ºckgegebene Liste enth√§lt zwei Elemente.  Das erste Element kann entweder 0 (Null) oder 1 (Eins) enthalten.  Der Wert "1" zeigt an, dass das Zertifikat g√ºltig ist, und 0 gibt an, dass das Zertifikat ung√ºltig ist.  Der Grund, warum das Zertifikat nicht g√ºltig ist, wird im zweiten Element angegeben.  Dieses Element kann einen von drei Werten enthalten: <br><br><ul><li>  Zertifikat g√ºltig (das erste Element der Liste ist 1): </li><li>  Zertifikat ist noch nicht g√ºltig (Zertifikat ist noch nicht abgelaufen) </li><li>  Zertifikat ist abgelaufen. </li></ul><br>  Die G√ºltigkeit des Zertifikats wird nicht nur durch seine G√ºltigkeitsdauer bestimmt.  Das Zertifikat kann vom Zertifizierungszentrum sowohl von sich aus als auch auf Antrag des Zertifikatsinhabers ausgesetzt oder gek√ºndigt werden, beispielsweise bei Verlust des Mediums mit dem privaten Schl√ºssel.  In diesem Fall wird das Zertifikat von der Zertifizierungsstelle in die Liste der widerrufenen COS / CRL-Zertifikate aufgenommen, die von der Zertifizierungsstelle verteilt werden.  In der Regel ist der CRL-Verteilungspunkt im Zertifikat enthalten.  Aus der Liste der widerrufenen Zertifikate wird die G√ºltigkeit des Zertifikats √ºberpr√ºft. <br><br><h3>  <font color="#0000ff">Validierung der Zertifikatsg√ºltigkeit durch SOS / CRL</font> </h3><br>  Der erste Schritt besteht darin, das SOS abzurufen, es dann zu analysieren und das Zertifikat darauf zu √ºberpr√ºfen. <br>  Die Liste der COC / CRL-Ausstellungspunkte befindet sich in der Zertifikatserweiterung mit oid 2.5.29.31 (id-ce-cRLDistributionPoints): <br><br><pre> <code class="plaintext hljs">array set extcert $cert_parse(extensions) set ::crlfile "" if {[info exists extcert(2.5.29.31)]} { set ::crlfile [crlpoints [lindex $extcert(2.5.29.31) 1]] } else { puts "cannot load CRL" }</code> </pre> <br>  Das Laden der Datei mit SOS / CRL ist wie folgt: <br><br><pre> <code class="plaintext hljs">set filecrl "" set pointcrl "" foreach pointcrl $::crlfile { set filecrl [readca $pointcrl $dir] if {$filecrl != ""} { set f [file join $dir [file tail $pointcrl]] set fd [open $fw] chan configure $fd -translation binary puts -nonewline $fd $filecrl close $fd set filecrl $f break } # CRL  .     CRL } if {$filecrl == ""} { puts "Cannot load CRL" }</code> </pre> <br>  Tats√§chlich wird die Readca-Prozedur verwendet, um die COC / CRL zu laden: <br><br><pre> <code class="plaintext hljs">proc readca {url dir} { set cer "" #   if { "https://" == [string range $url 0 7]} { #    tls http::register https 443 ::tls::socket } #     if {[catch {set token [http::geturl $url -binary 1] #    set ere [http::status $token] if {$ere == "ok"} { #        set code [http::ncode $token] if {$code == 200} { #      set cer [http::data $token] } elseif {$code == 301 || $code == 302} { #    ,   set newURL [dict get [http::meta $token] Location] #     set cer [readca $newURL $dir] } else { #    set cer "" } } } error]} { #   ,     set cer "" } return $cer }</code> </pre><br>  Die dir-Variable speichert den Pfad zu dem Verzeichnis, in dem die COS / CRL gespeichert wird, und die URL-Variable enth√§lt die zuvor empfangene Liste der CRL-Verteilungspunkte. <br><br>  Beim Empfang von SOS / CRL musste ich mich pl√∂tzlich der Tatsache stellen, dass diese Liste f√ºr einige Zertifikate √ºber das https (tls) -Protokoll im anonymen Modus empfangen werden musste.  Ehrlich gesagt ist dies √ºberraschend: Die CRL-Liste ist ein √∂ffentliches Dokument und ihre Integrit√§t wird durch eine elektronische Signatur gesch√ºtzt. Meiner Meinung nach habe ich √ºber anonymes https Zugriff darauf.  Aber es gibt nichts zu tun, Sie m√ºssen das tls-Paket verbinden - Paket erfordert tls. <br><br>  Wenn SOS / CRL nicht heruntergeladen werden konnte, kann das Zertifikat nicht √ºberpr√ºft werden, wenn der Zugriffspunkt mit dem OCSP-Dienst nicht im Zertifikat angegeben ist.  Dies wird jedoch in einem der folgenden Artikel er√∂rtert. <br><br>  Es gibt also ein Zertifikat zur √úberpr√ºfung, es gibt eine Liste von SOS / CRL, es bleibt das Zertifikat zu √ºberpr√ºfen.  Leider enth√§lt das pki-Paket keine entsprechenden Funktionen.  Daher musste ich eine Prozedur schreiben, um die G√ºltigkeit des Zertifikats (dessen Nicht-Widerruf) aus der Liste der widerrufenen Zertifikate zu √ºberpr√ºfen <br><br><div class="spoiler">  <b class="spoiler_title">validaty_cert_from_crl:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">proc validaty_cert_from_crl {crl sernum issuer} { array set ret [list] if { [string range $crl 0 9 ] == "-----BEGIN" } { array set parsed_crl [::pki::_parse_pem $crl "-----BEGIN X509 CRL-----" "-----END X509 CRL-----"] set crl $parsed_crl(data) } ::asn::asnGetSequence crl crl_seq ::asn::asnGetSequence crl_seq crl_base ::asn::asnPeekByte crl_base peek_tag if {$peek_tag == 0x02} { #   .CRL ::asn::asnGetInteger crl_base ret(version) incr ret(version) } else { set ret(version) 1 } ::asn::asnGetSequence crl_base crl_full ::asn::asnGetObjectIdentifier crl_full ret(signtype) ::::asn::asnGetSequence crl_base crl_issue set ret(issue) [::pki::x509::_dn_to_string $crl_issue] #     /CRL if {$ret(issue) != $issuer } { #/CRL    set ret(error) "Bad Issuer" return [array get ret] } binary scan $crl_issue H* ret(issue_hex) #  ::asn::asnGetUTCTime crl_base ret(publishDate) #   ::asn::asnGetUTCTime crl_base ret(nextDate) #   ::asn::asnPeekByte crl_base peek_tag if {$peek_tag != 0x30} { #    return [array get ret] } ::asn::asnGetSequence crl_base lcert # binary scan $lcert H* ret(lcert) while {$lcert != ""} { ::asn::asnGetSequence lcert lcerti #    ::asn::asnGetBigInteger lcerti ret(sernumrev) set ret(sernumrev) [::math::bignum::tostr $ret(sernumrev)] #      CRL if {$ret(sernumrev) != $sernum} { continue } # .    ::asn::asnGetUTCTime lcerti ret(revokeDate) if {$lcerti != ""} { #   ::asn::asnGetSequence lcerti lcertir ::asn::asnGetSequence lcertir reasone ::asn::asnGetObjectIdentifier reasone ret(reasone) ::asn::asnGetOctetString reasone reasone2 ::asn::asnGetEnumeration reasone2 ret(reasoneData) } break; } return [array get ret] }</code> </pre></div></div><br>  Die Parameter f√ºr diese Funktion sind die Zertifikatsperrliste (crl), die Seriennummer des zu √ºberpr√ºfenden Zertifikats (sernum) und dessen Herausgeber (Aussteller). <br><br>  Die Zertifikatsperrliste (crl) wird wie folgt geladen: <br><br><pre> <code class="plaintext hljs">set f [open $filecrl r] chan configure $f -translation binary set crl [read $f] close $f</code> </pre> <br>  Die Seriennummer des verifizierten Zertifikats (sernum) und seines Herausgebers (Ausstellers) wird aus dem analysierten Zertifikat entnommen und in den Variablen :: sncert und :: issuercert gespeichert. <br><br>  Alle Prozeduren finden Sie im Quellcode.  Den Quellcode des Dienstprogramms und seiner Distributionen f√ºr Linux, OS X (macOS) und MS Windows finden Sie hier. <br><br><div class="spoiler">  <b class="spoiler_title">hier</b> <div class="spoiler_text"><ul><li>  <a href="">Quellcode</a> </li><li>  <a href="">Linux32</a> </li><li>  <a href="">Linux64</a> </li><li>  <a href="">OS X.</a> </li><li>  <a href="">WIN32</a> </li><li>  <a href="">WIN64</a> </li></ul><br></div></div><br>  Das Dienstprogramm beh√§lt auch die M√∂glichkeit, in einer Datei gespeicherte Zertifikate anzuzeigen und zu √ºberpr√ºfen: <br><br><img src="https://habrastorage.org/webt/ja/tv/nl/jatvnlolqcsggytw3nn8x51zpls.png"><br><br>  √úbrigens k√∂nnen auch die angezeigten Zertifikate aus Dateien sowie die auf dem Token gespeicherten exportiert werden.  Dies erleichtert das Konvertieren von Zertifikatdateien vom DER-Format in PEM und umgekehrt. <br><br>  Jetzt haben wir einen einzigen Viewer f√ºr Zertifikate, die sowohl in Dateien als auch auf PKCS # 11-Token / Smartcards gespeichert sind. <br><br>  Ja, ich habe den Punkt verpasst: Um die G√ºltigkeit des Zertifikats zu √ºberpr√ºfen, klicken Sie auf die Schaltfl√§che ‚ÄûAdditionaly‚Äú und w√§hlen Sie den Men√ºpunkt ‚ÄûValidaty by CRL‚Äú oder dr√ºcken Sie die rechte Maustaste, wenn sich der Cursor auf den Hauptinformationen befindet Feld und w√§hlen Sie auch den Men√ºpunkt "Validation by CRL": <br><br><img src="https://habrastorage.org/webt/ig/ph/rm/igphrmcbunw9b8jtkdiepfjaqpm.png"><br><br>  Dieser Screenshot zeigt das Durchsuchen und √úberpr√ºfen von Zertifikaten in einem Cloud-Token. <br><br>  Abschlie√üend stellen wir Folgendes fest.  In seinen Kommentaren zu dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> bemerkte der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Pas-</a> Benutzer sehr korrekt √ºber PKCS # 11-Token, dass sie ‚Äûselbst alles z√§hlen k√∂nnen‚Äú.  Ja, Token sind eigentlich kryptografische Computer.  In den folgenden Artikeln werden wir nicht nur dar√ºber sprechen, wie Zertifikate mithilfe des OCSP-Protokolls √ºberpr√ºft werden, sondern auch dar√ºber, wie kryptografische Mechanismen (wir sprechen nat√ºrlich von GOST-Kryptografie) von Token / Smarts zur Berechnung des Hashs (GOST R 34-10-) verwendet werden. 94/2012), die Bildung und √úberpr√ºfung von Unterschriften usw. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443480/">https://habr.com/ru/post/de443480/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443468/index.html">Welche Netzwerk√ºberwachungstools sind in der Version von Gartner f√ºhrend geworden?</a></li>
<li><a href="../de443470/index.html">Die Geschichte des Schreibens am Beispiel eines gro√üen Projekts</a></li>
<li><a href="../de443472/index.html">M√ºssen Sie in die Cloud gehen? 7 Tipps, wie man nichts vermasselt</a></li>
<li><a href="../de443476/index.html">Wie SimCity eine ganze Generation von Stadtplanern inspirierte</a></li>
<li><a href="../de443478/index.html">Synthetische und reale Testdaten: Vor- und Nachteile, Fallstricke</a></li>
<li><a href="../de443482/index.html">AIOps in der Praxis - was kann Huawei FabricInsight</a></li>
<li><a href="../de443484/index.html">6 unerwartete M√§nner von Julia</a></li>
<li><a href="../de443486/index.html">ReLEx SMILE: Wie man keine Fehler in Prognosen macht</a></li>
<li><a href="../de443488/index.html">Funktionskomponenten mit React Hooks. Warum sind sie besser?</a></li>
<li><a href="../de443492/index.html">Ein Spiel f√ºr Liebhaber und Experten unter Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>