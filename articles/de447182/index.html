<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏼‍🤝‍🧑🏻 💋 🍯 Betriebssysteme: Drei einfache Teile. Teil 3: Prozess-API (Übersetzung) 🧓🏼 👎🏾 👂🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung in Betriebssysteme 
 Hallo Habr! Ich möchte Sie auf eine Reihe von Artikelübersetzungen einer meiner Meinung nach interessanten Literatur a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Betriebssysteme: Drei einfache Teile. Teil 3: Prozess-API (Übersetzung)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447182/"><h1>  Einführung in Betriebssysteme </h1><br>  Hallo Habr!  Ich möchte Sie auf eine Reihe von Artikelübersetzungen einer meiner Meinung nach interessanten Literatur aufmerksam machen - OSTEP.  Dieser Artikel beschreibt ziemlich ausführlich die Arbeit von Unix-ähnlichen Betriebssystemen, nämlich die Arbeit mit Prozessen, verschiedenen Schedulern, Speicher und anderen ähnlichen Komponenten, aus denen das moderne Betriebssystem besteht.  Das Original aller Materialien können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier sehen</a> .  Bitte beachten Sie, dass die Übersetzung unprofessionell (ziemlich frei) durchgeführt wurde, aber ich hoffe, dass ich die allgemeine Bedeutung beibehalten habe. <br><br>  Laborarbeiten zu diesem Thema finden Sie hier: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Original</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Original</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meine persönliche Anpassung</a> </li></ul><br>  Andere Teile: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Intro</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Abstraktion: der Prozess</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Einführung in die Prozess-API</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4: Einführung in den Scheduler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5: MLFQ Scheduler</a> </li></ul><br>  Und du kannst meinen Kanal im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegramm</a> ansehen =) <br><a name="habracut"></a><br>  <b>Alarm!</b>  Für diese Vorlesung gibt es ein Labor!  schau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dir github an</a> <br><br><h2>  Prozess-API </h2><br><br>  Betrachten Sie ein Beispiel für das Erstellen eines Prozesses auf einem UNIX-System.  Dies geschieht durch zwei Systemaufrufe <b>fork ()</b> und <b>exec ()</b> . <br><br><h3>  Fork () -Aufruf </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/1c2/8cf/bc3/1c28cfbc3118476d2601d0ff26f7c59a.jpg" alt="Bild"><br><br>  Stellen Sie sich ein Programm vor, das einen fork () -Aufruf ausführt.  Das Ergebnis seiner Implementierung wird wie folgt sein. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ba/93b/4f9/1ba93b4f9b7722347477f9af19586f08.jpg" alt="Bild"><br><br>  Zunächst geben wir die Funktion main () ein und führen die Ausgabe der Zeichenfolge auf dem Bildschirm aus.  Die Zeichenfolge enthält die Prozesskennung, die im Original als <b>PID</b> oder Prozesskennung bezeichnet wird.  Diese Kennung wird unter UNIX verwendet, um auf einen Prozess zu verweisen.  Der nächste Befehl ruft fork () auf.  Zu diesem Zeitpunkt wird eine fast exakte Kopie des Prozesses erstellt.  Für das Betriebssystem sieht es so aus, als würde das System so ausgeführt, als ob zwei Kopien desselben Programms die Funktion fork () beenden würden.  Der neu erstellte untergeordnete Prozess (relativ zu dem übergeordneten Prozess, der ihn erstellt hat) wird nicht mehr ausgeführt, beginnend mit der Funktion main ().  Es ist zu beachten, dass der untergeordnete Prozess keine exakte Kopie des übergeordneten Prozesses ist, insbesondere hat er einen eigenen Adressraum, eigene Register, einen eigenen Zeiger auf ausführbare Anweisungen und dergleichen.  Daher ist der an den Aufrufer der Funktion fork () zurückgegebene Wert unterschiedlich.  Insbesondere erhält der übergeordnete Prozess den PID-Wert des Prozesses des Kindes als Rückgabe, und das Kind erhält einen Wert gleich 0. Basierend auf diesen Rückgabecodes ist es bereits möglich, die Prozesse zu trennen und jeden von ihnen zu zwingen, seine Arbeit zu erledigen.  Darüber hinaus ist die Ausführung dieses Programms nicht genau definiert.  Nach der Aufteilung in zwei Prozesse beginnt das Betriebssystem, diesen ebenfalls zu folgen und ihre Arbeit zu planen.  Bei der Ausführung auf einem Single-Core-Prozessor funktioniert einer der Prozesse weiter, in diesem Fall der übergeordnete und dann der untergeordnete Prozess.  Beim Neustart kann die Situation anders sein. <br><br><h3>  Rufen Sie wait () an </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/ddd/a05/362/ddda05362e52440bb4428f32e6be4b56.jpg" alt="Bild"><br><br>  Betrachten Sie das folgende Programm.  In diesem Programm <b>wartet</b> der übergeordnete Prozess aufgrund des Vorhandenseins des Aufrufs <b>wait ()</b> immer darauf, dass der untergeordnete Prozess seine Arbeit beendet.  In diesem Fall erhalten wir eine streng definierte Textausgabe auf dem Bildschirm. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/611/ca4/3f5/611ca43f586590836259eb1ebfdfe5f1.jpg" alt="Bild"><br><br><h3>  Rufen Sie exec () auf </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/a1c/50e/9ac/a1c50e9acba31fa12983d15a95f2b969.jpg" alt="Bild"><br><br>  Betrachten Sie den Aufruf von <b>exec ()</b> .  Dieser Systemaufruf ist nützlich, wenn wir ein völlig anderes Programm ausführen möchten.  Hier rufen wir <b>execvp ()</b> auf, um das Programm wc auszuführen, bei dem es sich um ein <b>Wortzählprogramm</b> handelt.  Was passiert, wenn exec () aufgerufen wird?  Der Name der ausführbaren Datei und einige Parameter werden als Argumente an diesen Aufruf übergeben.  Danach werden der Code und die statischen Daten aus dieser ausführbaren Datei heruntergeladen und ein eigenes Segment mit Code überschrieben.  Die verbleibenden Speicherbereiche wie Stapel und Heap werden neu initialisiert.  Danach führt das Betriebssystem das Programm einfach aus und übergibt ihm eine Reihe von Argumenten.  Wir haben also keinen neuen Prozess erstellt, sondern einfach das aktuell laufende Programm in ein anderes laufendes Programm umgewandelt.  Nach der Ausführung von exec () erweckt der Nachkomme den Eindruck, dass das ursprüngliche Programm im Prinzip nicht gestartet zu sein schien. <br><br>  Diese Komplikation beim Starten ist für die Unix-Shell absolut normal und ermöglicht es dieser Shell, Code nach dem Aufruf von <b>fork ()</b> , jedoch vor dem Aufruf von <b>exec ()</b> auszuführen.  Ein Beispiel für einen solchen Code kann darin bestehen, die Umgebung der Shell an die Anforderungen des zu startenden Programms anzupassen, bevor es direkt gestartet wird. <br><br>  <b>Shell</b> ist nur ein Anwenderprogramm.  Sie zeigt Ihnen die Eingabeaufforderung und wartet darauf, dass Sie etwas darauf schreiben.  Wenn Sie dort den Namen des Programms schreiben, findet die Shell in den meisten Fällen ihren Speicherort, ruft die fork () -Methode auf. Um einen neuen Prozess zu erstellen, ruft sie einige der exec () -Typen auf und wartet, bis sie mit dem wait () -Aufruf ausgeführt wird.  Wenn der untergeordnete Prozess beendet ist, kehrt die Shell vom Aufruf wait () zurück, zeigt die Eingabeaufforderung erneut an und wartet auf die Eingabe des nächsten Befehls. <br><br>  Durch die Trennung von fork () und exec () kann die Shell beispielsweise Folgendes ausführen: <br>  <b>wc file&gt; new_file.</b> <br><br>  In diesem Beispiel wird die Ausgabe von wc in eine Datei umgeleitet.  Die Art und Weise, wie die Shell dies erreicht, ist recht einfach: Wenn Sie einen <b>untergeordneten</b> Prozess erstellen, bevor Sie <b>exec ()</b> aufrufen, schließt die Shell den Standardausgabestream und öffnet die Datei <b>new_file</b> , sodass die gesamte Ausgabe des gestarteten <b>wc-</b> Programms in die Datei anstatt auf den Bildschirm umgeleitet wird. <br><br>  <b>Unix-Pipes werden</b> auf ähnliche Weise implementiert, mit dem Unterschied, dass sie den Befehl pipe () verwenden.  In diesem Fall wird der Ausgabestream des Prozesses mit der Pipe-Warteschlange im Kernel verbunden, an die der Eingabestream eines anderen Prozesses angehängt wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447182/">https://habr.com/ru/post/de447182/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447168/index.html">Lokales autonomes Datenerfassungssystem</a></li>
<li><a href="../de447172/index.html">Fast der einfachste MIMO-Kanal mit Fading (Kronecker-Modell enthalten)</a></li>
<li><a href="../de447174/index.html">Der Mythos des Personalhungers oder die Grundregeln für offene Stellen</a></li>
<li><a href="../de447178/index.html">5 effektive Möglichkeiten für den Einsatz von Process Mining-Technologie</a></li>
<li><a href="../de447180/index.html">Übersicht und Vergleich von Ingress Controllern für Kubernetes</a></li>
<li><a href="../de447184/index.html">Was ist Initial Exchange Offering (IEO) und wie unterscheidet es sich von ICO?</a></li>
<li><a href="../de447186/index.html">So starten Sie einen ML-Prototyp an einem Tag. Bericht Yandex.Taxi</a></li>
<li><a href="../de447190/index.html">Vorhersagen von Mathematikern. Wir analysieren die wichtigsten Methoden zur Erkennung von Anomalien</a></li>
<li><a href="../de447192/index.html">Welche Rolle kann Technologie in der alten Kunst des Gewürzmischens spielen?</a></li>
<li><a href="../de447194/index.html">Rendering-Funktionen in Metro: Exodus c Raytracing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>