<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ò ‚¨úÔ∏è üë©üèº‚Äçüéì Kotlin Flow-Implementierung in C # ü§≤üèΩ üçà ‚è©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 


 In den letzten Jahren habe ich f√ºr Android auf Kotlin entwickelt. Vor nicht allzu langer Zeit haben wir mangels RxJava auf der K...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin Flow-Implementierung in C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473258/"><p><img src="https://habrastorage.org/webt/np/oj/_1/npoj_1aorlizriqchnnruansj6q.png" alt="Bild"></p><br><p>  Hallo allerseits! </p><br><p>  In den letzten Jahren habe ich f√ºr Android auf Kotlin entwickelt.  Vor nicht allzu langer Zeit haben wir mangels RxJava auf der Kotlin-Multiplattform begonnen, Coroutinen und Flow-Cold-Streams f√ºr Kotlin sofort zu verwenden.  Vor Android habe ich viele Jahre mit C # verbracht, und es gab meine Coroutinen schon sehr lange, nur dass sie nicht so genannt werden.  Aber ich habe nichts √ºber das Analogon von Flow on Async / Warten geh√∂rt.  Das Hauptwerkzeug f√ºr die reaktive Programmierung ist Rx.Net (tats√§chlich wurde rx hier geboren).  Also entschied ich mich f√ºr Nostalgie und versuchte ein Fahrrad zu sehen. </p><br><p>  Es versteht sich ferner, dass der Leser sich der Dinge bewusst ist, die im vorherigen Absatz besprochen wurden.  F√ºr Ungeduldige - sofort <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mit dem Repository verkn√ºpfen</a> . </p><br><p>  Haftungsausschluss: Dieser Code ist nicht f√ºr die Verwendung in der Produktion vorgesehen.  Dies ist ein Konzept, nichts weiter.  M√∂glicherweise funktioniert etwas nicht genau wie beabsichtigt. </p><a name="habracut"></a><br>
<h4 id="iflow-i-iflowcollector">  IFlow und IFlowCollector </h4><br><p>  Beginnen wir damit, die Flow- und FlowCollector-Schnittstellen in C # auf der Stirn neu zu schreiben. <br>  Es war: </p><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Flow</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">out T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">collect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(collector: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">FlowCollector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlowCollector</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Es wurde: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IFlow</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Collect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IFlowCollector&lt;T&gt; collector</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IFlowCollector</span></span>&lt;<span class="hljs-title"><span class="hljs-title">in</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T item</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br><p>  Ich glaube, die Unterschiede sind verst√§ndlich und werden durch die unterschiedliche Implementierung der Asynchronit√§t erkl√§rt. </p><br><p>  Um diese Schnittstellen nutzen zu k√∂nnen, m√ºssen sie implementiert sein.  Folgendes ist passiert: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Flow</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IFlow</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Func&lt;IFlowCollector&lt;T&gt;, Task&gt; _emitter; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Flow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Func&lt;IFlowCollector&lt;T&gt;, Task&gt; emitter</span></span></span><span class="hljs-function">)</span></span> { _emitter = emitter; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Collect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IFlowCollector&lt;T&gt; collector</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _emitter(collector); } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FlowCollector</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IFlowCollector</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Func&lt;T, Task&gt; _handler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlowCollector</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Func&lt;T, Task&gt; handler</span></span></span><span class="hljs-function">)</span></span> { _handler = handler; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _handler(item); } }</code> </pre> <br><p>  Im Konstruktor von flow √ºbergeben wir eine Funktion, die Werte ausgibt.  Und f√ºr den Konstruktor des Kollektors eine Funktion, die jeden ausgegebenen Wert verarbeitet. </p><br><p>  Sie k√∂nnen es so verwenden </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> flow = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Flow&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> collector =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> collector.Emit(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> collector.Emit(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> collector.Emit(<span class="hljs-number"><span class="hljs-number">3</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowCollector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> item =&gt; Console.WriteLine(item)); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> flow.Collect(collector);</code> </pre> <br><p>  Ich denke, im obigen Code ist alles klar.  Zuerst erstellen wir einen Flow, dann einen Collector (Handler f√ºr jedes Element).  Dann starten wir Flow, nachdem wir einen Sammler darauf "signiert" haben.  Wenn Sie etwas Zucker hinzuf√ºgen (siehe Github), erhalten wir ungef√§hr Folgendes: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Flow&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> collector =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> collector.Emit(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> collector.Emit(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> collector.Emit(<span class="hljs-number"><span class="hljs-number">3</span></span>); }) .Collect(Console.WriteLine);</code> </pre> <br><p>  Auf Kotlin sieht es so aus: </p><br><pre> <code class="kotlin hljs">scope.launch{ flow{ emit(<span class="hljs-number"><span class="hljs-number">1</span></span>) delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>) ‚Ä¶ }.collect{ printl(it) } }</code> </pre> <br><p>  Pers√∂nlich mag ich vor allem die Option auf Sharpe nicht, den Elementtyp beim Erstellen eines Flows explizit anzugeben.  Aber der Punkt hier ist nicht, dass die Typinferenz in Kotlin viel steiler ist.  Die Flow-Funktion sieht folgenderma√üen aus: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@BuilderInference</span></span></span></span><span class="hljs-function"><span class="hljs-params"> block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">suspend</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">FlowCollector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Flow&lt;T&gt; = SafeFlow(block)</code> </pre> <br><p>  Wie wir sehen k√∂nnen, ist der Blockparameter mit der BuilderInference-Annotation gekennzeichnet, die dem Compiler mitteilt, dass der Typ diesem Parameter entnommen werden soll.  Wei√ü jemand, ob es m√∂glich ist, √§hnliche Dateien f√ºr C # auf Roslyn einzureichen? </p><br><h4 id="cancellationtoken">  CancellationToken </h4><br><p>  In rx gibt es ein Abonnement, von dem Sie sich abmelden k√∂nnen.  In Kotlin Flow ist Job f√ºr die Stornierung verantwortlich, die vom Builder oder Coroutine Scope zur√ºckgegeben wird.  Wir brauchen auch definitiv ein Tool, mit dem Flow fr√ºhzeitig abgeschlossen werden kann.  Um asynchrone Vorg√§nge abzubrechen, habe ich in C # keine Angst vor diesem Wort. Es wird das Muster "Stornierungstoken" verwendet.  CancellationToken ist eine Klasse, deren Objekt Informationen zu der abgebrochenen asynchronen Operation bereitstellt.  Es wirft sich beim Start in eine asynchrone Operation, und diese Operation selbst k√ºmmert sich um ihren Zustand.  Und der Zustand √§ndert sich von au√üen. </p><br><p>  Kurz gesagt, wir m√ºssen das CancellationToken in unseren Flow und FlowCollector werfen. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IFlow</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Collect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IFlowCollector&lt;T&gt; collector, CancellationToken cancellationToken = </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">default</span></span></span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IFlowCollector</span></span>&lt;<span class="hljs-title"><span class="hljs-title">in</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T item, CancellationToken cancellationToken = </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">default</span></span></span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br><p>  Ich werde die Implementierung hier nicht einf√ºgen - siehe Github. <br>  Der Test sieht nun folgenderma√üen aus: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> flowTask = Flow&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (collector, cancellationToken) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> collector.Emit(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">2000</span></span>, cancellationToken); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> collector.Emit(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">2000</span></span>, cancellationToken); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> collector.Emit(<span class="hljs-number"><span class="hljs-number">3</span></span>); }) .Collect(item =&gt; Log(item), cts.Token); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cancelationTask = Task.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">3000</span></span>); cts.Cancel(); }); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> flowTask;</code> </pre> <br><p>  Der Punkt ist dies.  Parallel zu Flow starten wir einen Vorgang, der nach 3 Sekunden abgebrochen wird.  Infolgedessen kann Flow das dritte Element nicht ausgeben und endet mit einer TaskCanceledException, die das erforderliche Verhalten darstellt. </p><br><h4 id="nemnogo-praktiki">  Ein bisschen √úbung </h4><br><p>  Versuchen wir, das zu nutzen, was in der Praxis passiert ist.  Wickeln Sie beispielsweise ein Ereignis in unseren Flow ein.  In Rx.Net gibt es daf√ºr sogar eine Bibliotheksmethode FromEventPattern. </p><br><p>  Um mich nicht mit der realen Benutzeroberfl√§che herumzuschlagen, habe ich die ClicksEmulator-Klasse geschrieben, die in zuf√§lligen Intervallen bedingte Mausklicks generiert. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ClicksEmulator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Button { Left, Right } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ClickEventArgs</span></span> : <span class="hljs-title"><span class="hljs-title">EventArgs</span></span> { <span class="hljs-comment"><span class="hljs-comment">//‚Ä¶ public int X { get; } public int Y { get; } public Button Button { get; } } public event EventHandler&lt;ClickEventArgs&gt; ButtonClick; public async Task Start(CancellationToken cancellationToken = default) {‚Ä¶ } }</span></span></code> </pre> <br><p>  Ich habe die Implementierung als weggelassen  Sie ist hier nicht sehr wichtig.  Die Hauptsache ist das Ereignis ButtonClick, das wir in Flow verwandeln wollen.  Dazu schreiben wir eine Erweiterungsmethode </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IFlow&lt;ClicksEmulator.ClickEventArgs&gt; Clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ClicksEmulator emulator) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FlowFactory.Flow&lt;ClicksEmulator.ClickEventArgs&gt;(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (collector, cancellationToken) =&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clickHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, ClicksEmulator.ClickEventArgs args</span></span></span><span class="hljs-function">)</span></span> =&gt; collector.Emit(args); emulator.ButtonClick += clickHandler; cancellationToken.Register(() =&gt; { emulator.ButtonClick -= clickHandler; }); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">-1</span></span>, cancellationToken); }); }</code> </pre> <br><p>  Zuerst deklarieren wir einen Ereignishandler, der nichts anderes tut, als das Argument des Ereignisses an den Kollektor zu √ºbergeben.  Dann abonnieren wir Ereignisse und registrieren eine Abmeldung im Falle einer Stornierung (Vervollst√§ndigung) des Flusses.  Nun, dann warten wir endlos und h√∂ren ButtonClick-Ereignisse, bis das CancellationToken ausgel√∂st wird. </p><br><p>  Wenn Sie callbackFlow oder channelFlow in Kotlin verwendet oder Cold Observable von Listenern in Rx erstellt haben, werden Sie feststellen, dass die Codestruktur in allen F√§llen sehr √§hnlich ist.  Das ist in Ordnung, aber es stellt sich die Frage: Was ist in diesem Fall besser als Flow als ein grobes Ereignis?  Die ganze Kraft von Jetstreams liegt in Operatoren, die verschiedene Transformationen an ihnen durchf√ºhren: Filtern, Mapping und viele andere, komplexere.  Aber wir haben sie noch nicht.  Versuchen wir etwas dagegen zu unternehmen. </p><br><h4 id="filter-map-onnext">  Filter, Karte, OnNext </h4><br><p>  Beginnen wir mit einem der einfachsten Operatoren - Filter.  Wie der Name schon sagt, werden die Flusselemente gem√§√ü dem angegebenen Pr√§dikat gefiltert.  Dies ist eine Erweiterungsmethode, die nur mit gefilterten Elementen auf den urspr√ºnglichen Fluss und den R√ºckfluss angewendet wird.  Es stellt sich heraus, dass wir jedes Element aus dem urspr√ºnglichen Fluss nehmen, pr√ºfen und weiter ausgeben m√ºssen, wenn das Pr√§dikat true zur√ºckgibt.  Also lass es uns tun: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IFlow&lt;T&gt; Filter&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IFlow&lt;T&gt; source, Func&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; predicate) =&gt; FlowFactory.Flow&lt;T&gt;((collector, cancellationToken) =&gt; source.Collect(item =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (predicate(item)) collector.Emit(item); }, cancellationToken) );</code> </pre> <br><p>  Wenn wir nur mit der linken Maustaste klicken m√ºssen, k√∂nnen wir Folgendes schreiben: </p><br><pre> <code class="cs hljs">emulator .Clicks() .Filter(click =&gt; click.Button == ClicksEmulator.Button.Left) .Collect(item =&gt; Log(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item.Button}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item.X}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item.Y}</span></span></span><span class="hljs-string">"</span></span>), cts.Token);</code> </pre><br><p>  Analog schreiben wir die Operatoren Map und OnNext.  Der erste konvertiert jedes Element des urspr√ºnglichen Flusses mithilfe der √ºbergebenen Mapper-Funktion in ein anderes.  Der zweite gibt den Flow mit denselben Elementen wie das Original zur√ºck, f√ºhrt jedoch f√ºr jedes eine Aktion aus (normalerweise Protokollierung). <br></p><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IFlow&lt;R&gt; Map&lt;T, R&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IFlow&lt;T&gt; source, Func&lt;T, R&gt; mapper) =&gt; FlowFactory.Flow&lt;R&gt;((collector, cancellationToken) =&gt; source.Collect( item =&gt; collector.Emit(mapper(item)), cancellationToken ) ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IFlow&lt;T&gt; OnNext&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IFlow&lt;T&gt; source, Action&lt;T&gt; action) =&gt; FlowFactory.Flow&lt;T&gt;((collector, cancellationToken) =&gt; source.Collect(item =&gt; { action(item); collector.Emit(item); }, cancellationToken) );</code> </pre> <br><p>  Und ein Anwendungsbeispiel: </p><br><pre> <code class="cs hljs">emulator .Clicks() .OnNext(click =&gt; Log(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{click.Button}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{click.X}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{click.Y}</span></span></span><span class="hljs-string">"</span></span>)) .Map(click =&gt; click.Button == ClicksEmulator.Button.Left ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>) .Collect(item =&gt; Log(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item}</span></span></span><span class="hljs-string">"</span></span>), cts.Token);</code> </pre> <br><p>  Im Allgemeinen wurden viele Betreiber f√ºr Jetstreams erfunden, sie sind beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier zu finden</a> . </p><br><p>  Und nichts hindert daran, eines davon f√ºr IFlow zu implementieren. </p><br><p>  Diejenigen, die mit Rx.Net vertraut sind, wissen, dass dort neben neuen und spezifischen Operatoren f√ºr IObservable auch Erweiterungsmethoden von Linq-to-Objects verwendet werden. Auf diese Weise k√∂nnen Sie Streams als ‚ÄûEreignissammlungen‚Äú betrachten und mit dem √ºblichen Linq bearbeiten Methoden.  Warum sollten Sie nicht versuchen, IFlow auf die Linq-Schienen zu setzen, anstatt die Aussagen selbst zu schreiben? </p><br><h4 id="iasyncenumerable">  IAsyncEnumerable </h4><br><p>  In C # 8 wurde eine asynchrone Version von IEnumerable eingef√ºhrt - IAsyncEnumerable - eine Erfassungsschnittstelle, die asynchron iteriert werden kann.  Der grundlegende Unterschied zwischen IAsyncEnumerable und reaktiven Streams (IObservable und IFlow) besteht darin.  IAsyncEnumerable ist wie IEnumerable ein Pull-Modell.  Wir durchlaufen die Sammlung, wie viel und wann wir sie ben√∂tigen, und ziehen selbst Elemente daraus.  Streams sind Push.  Wir abonnieren Ereignisse und ‚Äûreagieren‚Äú auf sie, wenn sie kommen - daf√ºr sind sie reaktiv.  Mit dem Pull-Modell kann jedoch ein Push-√§hnliches Verhalten erzielt werden.  Dies wird als langes Polling <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://en.wikipedia.org/wiki/Push_technology#Long_polling bezeichnet</a> .  Das Wesentliche ist Folgendes: Wir durchlaufen die Sammlung, fordern ihr n√§chstes Element an und warten so lange wir m√∂chten, bis die Sammlung es uns zur√ºckgibt, d. H.  bis die n√§chste Veranstaltung kommt.  IAsyncEnumerable erm√∂glicht es uns im Gegensatz zu IEnumerable, asynchron zu warten.  Kurz gesagt, wir m√ºssen IAsyncEnumerable auf IFlow irgendwie ziehen. </p><br><p>  Wie Sie wissen, ist die IAsyncEnumerator-Schnittstelle daf√ºr verantwortlich, das aktuelle Element der IAsyncEnumerable-Auflistung zur√ºckzugeben und zum n√§chsten Element zu wechseln.  In diesem Fall m√ºssen wir Elemente aus IFlow √ºbernehmen, und IFlowCollector f√ºhrt dies aus.  Es stellt sich heraus, dass hier ein Objekt diese Schnittstellen implementiert: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FlowCollectorEnumerator</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IFlowCollector</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IAsyncEnumerator</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> SemaphoreSlim _backpressureSemaphore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemaphoreSlim(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> SemaphoreSlim _longPollingSemaphore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemaphoreSlim(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _isFinished; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Current { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> ValueTask </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisposeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T item, CancellationToken cancellationToken</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _backpressureSemaphore.WaitAsync(cancellationToken); Current = item; _longPollingSemaphore.Release(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Finish</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _backpressureSemaphore.WaitAsync(); _isFinished = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _longPollingSemaphore.Release(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveNextAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _backpressureSemaphore.Release(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _longPollingSemaphore.WaitAsync(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !_isFinished; } }</code> </pre><br><p>  Die Hauptmethoden hier sind <em>Emit</em> , <em>Finish</em> und <em>MoveNextAsync</em> . <br>  <strong>Emit</strong> am Anfang wartet auf den Moment, in dem der n√§chste Artikel aus der Sammlung angefordert wird.  Das hei√üt,  Gibt einen Artikel erst aus, wenn er ben√∂tigt wird.  Dies nennt man Gegendruck, daher der Name des Semaphors.  Dann wird das aktuelle Element festgelegt und es wird gemeldet, dass eine lange Abfrageanforderung das Ergebnis erhalten kann. <br>  <strong>MoveNextAsync</strong> wird aufgerufen, wenn ein anderes Element aus der Sammlung <strong>abgerufen</strong> wird.  Er gibt _backpressureSemaphore frei und wartet darauf, dass Flow das n√§chste Element ausl√∂st.  Dann wird ein Zeichen zur√ºckgegeben, dass die Sammlung beendet wurde.  Dieses Flag setzt die Finish-Methode. </p><br><p>  <strong>Finish</strong> funktioniert nach dem gleichen Prinzip wie Emit, nur dass anstelle des n√§chsten Elements das Vorzeichen f√ºr das Ende der Sammlung gesetzt wird. </p><br><p>  Jetzt m√ºssen wir diese Klasse verwenden. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AsyncEnumerableExtensions</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IAsyncEnumerable&lt;T&gt; CollectEnumerable&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IFlow&lt;T&gt; flow, CancellationToken cancellationToken = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowCollectorEnumerator&lt;T&gt;(); flow .Collect(collector, cancellationToken) .ContinueWith(_ =&gt; collector.Finish(), cancellationToken); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowEnumerableAdapter&lt;T&gt;(collector); } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FlowEnumerableAdapter</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IAsyncEnumerable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IAsyncEnumerator&lt;T&gt; _enumerator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlowEnumerableAdapter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAsyncEnumerator&lt;T&gt; enumerator</span></span></span><span class="hljs-function">)</span></span> { _enumerator = enumerator; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IAsyncEnumerator&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAsyncEnumerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken cancellationToken = </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">default</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _enumerator; } }</code> </pre><br><p>  Die ExtensionEnumerable-Erweiterungsmethode f√ºr IFlow erstellt einen FlowCollectorEnumerator und signiert einen Flow darauf. Anschlie√üend wird die Finish () -Methode aufgerufen.  Und es wird ein FlowEnumerableAdapter zur√ºckgegeben, der die einfachste Implementierung von IAsyncEnumerable ist, wobei der FlowCollectorEnumerator als IEnumerator verwendet wird. <br>  Wir versuchen was passiert ist. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clicks = emulator .Clicks() .OnNext(item =&gt; Log(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item.Button}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item.X}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item.Y}</span></span></span><span class="hljs-string">"</span></span>)) .CollectEnumerable(cts.Token) .Where(click =&gt; click.Button == ClicksEmulator.Button.Right) .Select(click =&gt; click.Y &lt; <span class="hljs-number"><span class="hljs-number">540</span></span> ? <span class="hljs-string"><span class="hljs-string">"TOP"</span></span> : <span class="hljs-string"><span class="hljs-string">"LEFT"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> click <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> clicks) { Log(<span class="hljs-string"><span class="hljs-string">$"Clicked at: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{click}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre> <br><p>  Hier erhalten wir Flow-Klicks (), protokollieren jeden Klick und verwandeln IFlow in IAsyncEnumerable.  Dann gelten die ber√ºhmten Linq-Operatoren: Wir lassen nur die rechten Klicks und bekommen, in welchem ‚Äã‚ÄãTeil des Bildschirms sie gemacht werden. </p><br><p>  Betrachten Sie als n√§chstes ein komplizierteres Beispiel.  Wir werden den rechten Klick durch einen doppelten linken Klick ersetzen.  Das hei√üt,  Wir m√ºssen jedes Element nicht einem anderen, sondern der Sammlung zuordnen.  Oder in Flow, konvertiert in eine Sammlung. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clicks = emulator .Clicks() .OnNext(item =&gt; Log(<span class="hljs-string"><span class="hljs-string">$"Original: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item.Button}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item.X}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item.Y}</span></span></span><span class="hljs-string">"</span></span>)) .CollectEnumerable(cts.Token) .Select(click =&gt; click.Button == ClicksEmulator.Button.Left ? Flow&lt;ClicksEmulator.ClickEventArgs&gt;(collector =&gt; collector.Emit(click)) : Flow&lt;ClicksEmulator.ClickEventArgs&gt;(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> collector =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> changedClick = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClicksEmulator.ClickEventArgs(click.X, click.Y, ClicksEmulator.Button.Left); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> collector.Emit(changedClick); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> collector.Emit(changedClick); }) ) .SelectMany(flow =&gt; flow.CollectEnumerable()); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> click <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> clicks) { Log(<span class="hljs-string"><span class="hljs-string">$"Changed: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{click.Button}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{click.X}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{click.Y}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre><br><p>  Zu diesem Zweck gibt es in Linq einen SelectMany-Operator.  Das Gegenst√ºck zu Jetstreams ist FlatMap.  Ordnen Sie zun√§chst jeden Klick in IFlow zu: f√ºr den linken Klick - Fluss mit diesem einen Klick, f√ºr den rechten - Fluss von zwei linken Klicks mit einer Verz√∂gerung zwischen ihnen.  Und dann verwandeln wir in SelectMany IFlow in IAyncEnumerable. </p><br><p>  Und es funktioniert!  Das hei√üt,  Viele Operatoren m√ºssen f√ºr IFlow nicht implementiert werden - Sie k√∂nnen Linq verwenden. </p><br><h4 id="zaklyuchenie">  Fazit </h4><br><p>  Rx.Net - war und ist das Hauptwerkzeug bei der Arbeit mit asynchronen Ereignissequenzen in C #.  Dies ist jedoch eine ziemlich gro√üe Bibliothek in Bezug auf die Codegr√∂√üe.  Wie wir gesehen haben, k√∂nnen √§hnliche Funktionen viel einfacher erhalten werden - nur zwei Schnittstellen plus etwas Bindung.  Dies ist dank der Verwendung von Sprachfunktionen m√∂glich - async / await.  Als Rx geboren wurde, wurde diese Funktion noch nicht in C # √ºbernommen. </p><br><p>  Vielen Dank f√ºr Ihre Aufmerksamkeit! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473258/">https://habr.com/ru/post/de473258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473246/index.html">Die mathematische Rechtfertigung f√ºr die Unangemessenheit, die Rolltreppe in der U-Bahn herunterzufahren</a></li>
<li><a href="../de473248/index.html">Arduino DIY Projekte: D√§monischer Karussell Roboter Schie√üstand</a></li>
<li><a href="../de473252/index.html">Selbstentwicklung eines Programmierers und die Frage ‚ÄûWarum?‚Äú</a></li>
<li><a href="../de473254/index.html">"Musik des gro√üen Bruders": wie Dystopie klingt und wer √ºber Verschw√∂rungstheorie und anthropogene Postapokalypse sang</a></li>
<li><a href="../de473256/index.html">Wie die NASA einen Satelliten im erdnahen Orbit ergreifen und auftanken will</a></li>
<li><a href="../de473262/index.html">Warum ist die negative Wahrnehmung des Bildungsprozesses mit seinen positiven Ergebnissen verbunden?</a></li>
<li><a href="../de473266/index.html">Struktur als Systemansatz</a></li>
<li><a href="../de473270/index.html">Wie die K√§mpfer temperiert wurden ru-> neta. Eine echte Geschichte</a></li>
<li><a href="../de473272/index.html">Der bedingungslose Glaube an Autorit√§t behindert die Anpassungsf√§higkeit</a></li>
<li><a href="../de473274/index.html">Digitale Veranstaltungen in Moskau vom 28. Oktober bis 3. November</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>