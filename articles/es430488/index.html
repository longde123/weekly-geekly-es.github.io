<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Intercambio as铆ncrono de datos con una aplicaci贸n remota a trav茅s de SSH   锔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buen d铆a amigos y colegas. Mi nombre sigue siendo Dmitry Smirnov y sigo siendo, para mi gran placer, el desarrollador de ISPsystem. Hace alg煤n tiempo,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Intercambio as铆ncrono de datos con una aplicaci贸n remota a trav茅s de SSH</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ispsystem/blog/430488/">  Buen d铆a amigos y colegas.  Mi nombre sigue siendo Dmitry Smirnov y sigo siendo, para mi gran placer, el desarrollador de ISPsystem.  Hace alg煤n tiempo, comenc茅 a trabajar en un proyecto completamente nuevo que me inspir贸 mucho, porque el nuevo es en nuestro caso la falta de c贸digo heredado y soporte para compiladores antiguos.  Hola, Boost, C ++ 17 y todas las otras alegr铆as del desarrollo moderno. <br><br>  Dio la casualidad de que todos mis proyectos pasados fueron multiproceso, respectivamente, ten铆a muy poca experiencia con soluciones asincr贸nicas.  Esto es lo que se convirti贸 en lo m谩s agradable para m铆 en este desarrollo, adem谩s de las herramientas modernas y potentes. <br><br>  Una de las 煤ltimas tareas relacionadas fue la necesidad de escribir un contenedor sobre la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libssh2</a> en las realidades de una aplicaci贸n asincr贸nica usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Boost.Asio</a> , y capaz de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">generar</a> no m谩s de dos hilos.  Te contar茅 sobre esto. <br><br><img src="https://habrastorage.org/webt/j2/fm/-k/j2fm-k44ityxe7_xjzcrwxwy7hw.jpeg"><br><br>  Nota: el autor supone que el lector est谩 familiarizado con los conceptos b谩sicos del desarrollo asincr贸nico y boost :: asio. <br><a name="habracut"></a><br><h2>  Desaf铆o </h2><br>  En t茅rminos generales, la tarea era la siguiente: conectarse a un servidor remoto utilizando una clave rsa o nombre de usuario y contrase帽a;  cargar un script en la m谩quina remota y ejecutarlo;  lea sus respuestas y env铆ele comandos a trav茅s de la misma conexi贸n.  En este caso, por supuesto, sin bloquear el flujo (que es la mitad del conjunto total posible). <br><br>  <b>Descargo de responsabilidad</b> : S茅 que Poco trabaja con SSH, pero no encontr茅 una manera de casarlo con Asio, y fue m谩s interesante escribir algo propio :-). <br><br><h2>  Inicializaci贸n </h2><br>  Para inicializar y minimizar la biblioteca, decid铆 usar el singleton habitual: <br><br><div class="spoiler">  <b class="spoiler_title">Init ()</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LibSSH2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> LibSSH2 instance; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LibSSH2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (libssh2_init(<span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"libssh2 initialization failed"</span></span>); } } ~LibSSH2() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"shutdown libssh2"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; libssh2_exit(); } };</code> </pre> <br><br></div></div><br>  Hay, por supuesto, escollos en esta decisi贸n, de acuerdo con mi manual favorito, "Mil y una maneras de dispararle una pierna en C ++".  Si alguien genera una transmisi贸n que se olvida de pinchar, y la principal termina antes, pueden surgir efectos especiales interesantes.  Pero en este caso, no tendr茅 en cuenta esta posibilidad. <br><br><h2>  Entidades clave </h2><br>  Despu茅s de analizar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejemplo</a> , queda claro que para nuestra peque帽a biblioteca necesitamos tres entidades simples: socket, sesi贸n y canal.  Como es bueno tener herramientas sincr贸nicas, dejaremos a Asio a un lado por ahora. <br><br>  Comencemos con un z贸calo simple: <br><br><div class="spoiler">  <b class="spoiler_title">Z贸calo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Socket</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Socket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(socket(AF_INET, SOCK_STREAM, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_sock == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"failed to create socket"</span></span>); } } ~Socket() { close(m_sock); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_sock = <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br></div></div><br>  Ahora sesi贸n: <br><br><div class="spoiler">  <b class="spoiler_title">La sesi贸n</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Session</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Session</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> enable_compression)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_session</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(libssh2_session_init())</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_session == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"failed to create libssh2 session"</span></span>); } libssh2_session_set_blocking(m_session, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (enable_compression) { libssh2_session_flag(m_session, LIBSSH2_FLAG_COMPRESS, <span class="hljs-number"><span class="hljs-number">1</span></span>); } } ~Session() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> desc = <span class="hljs-string"><span class="hljs-string">"Shutting down libssh2 session"</span></span>; libssh2_session_disconnect(m_session, desc.c_str()); libssh2_session_free(m_session); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: LIBSSH2_SESSION *m_session; }</code> </pre><br></div></div><br>  Como ahora tenemos un socket y una sesi贸n, ser铆a bueno escribir una funci贸n de espera para un socket en las realidades de libssh2: <br><br><div class="spoiler">  <b class="spoiler_title">Z贸calo de espera</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ pollfd fds{}; fds.fd = sock; fds.events = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((libssh2_session_block_directions(session) &amp; LIBSSH2_SESSION_BLOCK_INBOUND) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { fds.events |= POLLIN; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((libssh2_session_block_directions(session) &amp; LIBSSH2_SESSION_BLOCK_OUTBOUND) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { fds.events |= POLLOUT; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> poll(&amp;fds, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre> <br></div></div><br>  En realidad, esto no es pr谩cticamente diferente del ejemplo anterior, excepto que utiliza select en lugar de sondeo. <br><br>  El canal permanece.  Hay varios tipos de canales en libssh2: simple, SCP, tcp directo.  Nos interesa el canal m谩s simple y b谩sico: <br><br><div class="spoiler">  <b class="spoiler_title">Canal</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleChannel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimpleChannel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(session)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((m_channel = libssh2_channel_open_session(session) == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; GetSessionLastError() == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_channel == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"Critical error while opening simple channel"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SendEof() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (libssh2_channel_send_eof(m_channel) == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (libssh2_channel_wait_eof(m_channel) == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } } ~SimpleChannel() { CloseChannel(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CloseChannel() { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((rc = libssh2_channel_close(m_channel)) == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } libssh2_channel_free(m_channel); } LIBSSH2_CHANNEL *m_channel; };</code> </pre> <br></div></div><br>  Ahora que todas las herramientas b谩sicas est谩n listas, queda por establecer una conexi贸n con el host y realizar las manipulaciones necesarias.  La grabaci贸n as铆ncrona en el canal y la sincr贸nica, por supuesto, ser谩n muy diferentes, pero el proceso de establecer una conexi贸n no lo es. <br><br>  Por lo tanto, escribimos la clase base: <br><br><div class="spoiler">  <b class="spoiler_title">Conexi贸n b谩sica</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseConnectionImpl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseConnectionImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SshConnectData &amp;connect_data)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">///&lt;    ,     : m_session(connect_data.enable_compression) , m_connect_data(connect_data) { LibSSH2::Init(); ConnectSocket(); HandShake(); ProcessKnownHosts(); Auth(); } ///       bool CheckSocket(int type) const { pollfd fds{}; fds.fd = m_sock; fds.events = type; return poll(&amp;fds, 1, 0) == 1; } bool WantRead() const { return CheckSocket(POLLIN); } bool WantWrite() const { return CheckSocket(POLLOUT); } /*   ,   ,       *  - . */ void ConnectSocket() {...} void HandShake() {...} void Auth() {...} class Socket m_sock; class Session m_session; class SimpleChannel; SshConnectData m_connect_data; };</span></span></span></span></code> </pre> <br></div></div><br>  Ahora estamos listos para escribir la clase m谩s simple para conectarse al host remoto y ejecutar cualquier comando en 茅l: <br><br><div class="spoiler">  <b class="spoiler_title">Conexi贸n sincr贸nica</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Connection</span></span></span><span class="hljs-class">:</span></span>:Impl : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BaseConnectionImpl { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SshConnectData &amp;connect_data)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseConnectionImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(connect_data)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Begin&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteToChannel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LIBSSH2_CHANNEL *channel, Begin ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((rc = libssh2_channel_write(channel, ptr, size)) == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } size -= rc; ptr += rc; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size != <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;command, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;in = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">SimpleChannel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> return_code = libssh2_channel_exec(channel, command.c_str()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (return_code != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; return_code != LIBSSH2_ERROR_EAGAIN) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"Critical error while executing ssh command"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!in.empty()) { WriteToChannel(channel, in.c_str(), in.size()); channel.SendEof(); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> response; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, 4096&gt; buffer{}; rc = libssh2_channel_read(channel, buffer.data(), buffer.size()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { boost::range::copy(boost::adaptors::slice(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, rc), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(response)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; rc != LIBSSH2_ERROR_EAGAIN) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"libssh2_channel_read error ("</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(rc) + <span class="hljs-string"><span class="hljs-string">")"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (rc &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc == LIBSSH2_ERROR_EAGAIN) { WaitSocket(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } };</code> </pre> <br></div></div><br>  Hasta ahora, todo lo que escribimos ha sido una simple reducci贸n de ejemplos de libssh2 a una forma m谩s civilizada.  Pero ahora, teniendo todas las herramientas simples para escribir datos en el canal de forma sincr贸nica, podemos pasar a Asio. <br><br>  Tener un socket est谩ndar es bueno, pero no demasiado pr谩ctico si necesita esperar asincr贸nicamente para que lea / escriba mientras realiza su propio negocio en el proceso.  Aqu铆 boost :: asio :: ip :: tcp :: socket viene al rescate, con un m茅todo maravilloso: <br><br><pre> <code class="cpp hljs">async_wait(wait_type, WaitHandler)</code> </pre> <br>  Est谩 maravillosamente construido a partir de un socket normal, para el cual ya configuramos la conexi贸n de antemano y potenciamos :: asio :: io_context, el contexto de ejecuci贸n de nuestra aplicaci贸n. <br><br><div class="spoiler">  <b class="spoiler_title">Constructor de conexiones as铆ncronas</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncConnection</span></span></span><span class="hljs-class">:</span></span>:Impl : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BaseConnectionImpl, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_shared_from_this&lt;AsyncConnection::Impl&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Impl(boost::asio::io_context &amp;context, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SshConnectData &amp;connect_data) : BaseConnectionImpl(connect_data) , m_tcp_socket(context, tcp::v4(), m_sock.GetSocket()) { m_tcp_socket.non_blocking(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } };</code> </pre> <br></div></div><br><br>  Ahora necesitamos comenzar la ejecuci贸n de alg煤n comando en el host remoto y, tan pronto como lleguen los datos, enviarlo a alguna devoluci贸n de llamada. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncRun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;command, CallbackType &amp;&amp;callback)</span></span></span><span class="hljs-function"> </span></span>{ m_read_callback = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(callback); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec = libssh2_channel_exec(*m_channel, command.c_str()); TryRead(); }</code> </pre> <br>  Por lo tanto, al ejecutar el comando, transferimos el control al m茅todo TryRead (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_read_in_progress) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } m_tcp_socket.async_wait(tcp::socket::wait_read, [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, self = shared_from_this()](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WantRead()) { ReadHandler(ec); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_complete) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } TryRead(); }); }</code> </pre><br>  En primer lugar, verificamos si el proceso de lectura ya se est谩 ejecutando en alguna llamada anterior.  Si no, entonces comenzamos a esperar la disponibilidad del socket para la lectura.  Una lambda normal con la captura de shared_from_this () se usa como controlador de espera. <br><br>  Presta atenci贸n a la llamada a WantRead ().  Async_wait, como result贸, tambi茅n tiene sus defectos, y simplemente puede regresar por tiempo de espera.  Para evitar acciones innecesarias en este caso, decid铆 verificar el socket a trav茅s de una encuesta sin tiempo de espera: 驴el socket realmente quiere leer ahora?  Si no, entonces ejecutamos TryRead () nuevamente y esperamos.  De lo contrario, comenzamos inmediatamente a leer y transferir datos a la devoluci贸n de llamada. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp;error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error != boost::system::errc::success) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } m_read_in_progress = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ec = LIBSSH2_ERROR_EAGAIN; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>, 4096&gt; buffer {}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((ec = libssh2_channel_read(*m_channel, buffer.data(), buffer.size())) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> tmp; boost::range::copy(boost::adaptors::slice(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, ec), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(tmp)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_read_callback != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { m_read_callback(tmp); } } m_read_in_progress = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Por lo tanto, se inicia un ciclo de lectura as铆ncrono sin fin desde la aplicaci贸n en ejecuci贸n.  El siguiente paso para nosotros ser谩 enviar instrucciones a la aplicaci贸n: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;data, WriteCallbackType &amp;&amp;callback)</span></span></span><span class="hljs-function"> </span></span>{ m_input += data; m_write_callback = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(callback); TryWrite(); }</code> </pre><br>  Los datos y la devoluci贸n de llamada transferidos a la grabaci贸n asincr贸nica se guardar谩n dentro de la conexi贸n.  Y ejecuta el siguiente ciclo, solo que esta vez las entradas: <br><br><div class="spoiler">  <b class="spoiler_title">Ciclo de grabaci贸n</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_input.empty() || m_write_in_progress) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } m_tcp_socket.async_wait(tcp::socket::wait_write, [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, self = shared_from_this()](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WantWrite()) { WriteHandler(ec); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_complete) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } TryWrite(); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp;error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error != boost::system::errc::success) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } m_write_in_progress = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ec = LIBSSH2_ERROR_EAGAIN; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!m_input.empty()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ptr = m_input.c_str(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> read_size = m_input.size(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((ec = libssh2_channel_write(*m_channel, ptr, read_size)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { read_size -= ec; ptr += ec; } AssertResult(ec); m_input.erase(<span class="hljs-number"><span class="hljs-number">0</span></span>, m_input.size() - read_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ec == LIBSSH2_ERROR_EAGAIN) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_input.empty() &amp;&amp; m_write_callback != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { m_write_callback(); } m_write_in_progress = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br></div></div><br>  Por lo tanto, escribiremos datos en el canal hasta que todos se transfieran con 茅xito.  Luego devolveremos el control a la persona que llama para que se pueda transferir un nuevo dato.  De esta manera, no solo puede enviar instrucciones a alguna aplicaci贸n en el host, sino tambi茅n, por ejemplo, cargar archivos de cualquier tama帽o en peque帽as porciones, sin bloquear el hilo, lo cual es importante. <br><br>  Usando esta biblioteca, pude ejecutar con 茅xito un script en un servidor remoto que rastrea los cambios en el sistema de archivos, mientras le铆a su salida y enviaba varios comandos.  En general: una experiencia muy valiosa en la adaptaci贸n de la biblioteca de estilo si para un proyecto moderno de C ++ con Boost. <br><br>  Estar茅 encantado de leer los consejos de los usuarios m谩s experimentados de Boost.Asio para obtener m谩s informaci贸n y mejorar mi soluci贸n :-). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430488/">https://habr.com/ru/post/es430488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430478/index.html">Comercio de bots para el mercado de criptomonedas. Por donde empezar</a></li>
<li><a href="../es430480/index.html">Mientras escrib铆amos la aplicaci贸n en el hackathon del Desaf铆o de Aplicaciones Espaciales de la NASA</a></li>
<li><a href="../es430482/index.html">El tema de las placas de armadura en la cultura de Oriente y Occidente</a></li>
<li><a href="../es430484/index.html">Escenarios t铆picos de implementaci贸n de NGFW</a></li>
<li><a href="../es430486/index.html">C贸mo viven los freelancers: de un desarrollador a un redactor t茅cnico</a></li>
<li><a href="../es430490/index.html">Antic铆pese, eduque, decida: c贸mo y por qu茅 EPAM crea el Centro de Competencias de Java</a></li>
<li><a href="../es430492/index.html">Intel Neural Compute Stick. Mente artificial en una unidad flash USB - 2</a></li>
<li><a href="../es430494/index.html">InfoWatch Traffic Monitor. Al borde de errores y caracter铆sticas</a></li>
<li><a href="../es430496/index.html">NB-IoT: 驴c贸mo funciona? Parte 1</a></li>
<li><a href="../es430498/index.html">Omitir el Control de cuentas de usuario (UAC) imitando directorios confiables</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>