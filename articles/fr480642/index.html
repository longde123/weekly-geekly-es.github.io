<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóΩ üë©üèº‚Äç‚öïÔ∏è üçà Introduction aux ELF Linux: Comprendre et analyser ‚úÖ üë©üèæ‚Äçüè≠ üéÖüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a des choses dans le monde que nous tenons pour acquises, m√™me si ce sont de v√©ritables chefs-d'≈ìuvre. Une telle chose est les utilitaires Linux ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduction aux ELF Linux: Comprendre et analyser</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480642/"> Il y a des choses dans le monde que nous tenons pour acquises, m√™me si ce sont de v√©ritables chefs-d'≈ìuvre.  Une telle chose est les utilitaires Linux tels que ls et ps.  Bien qu'ils soient g√©n√©ralement per√ßus comme simples, c'est loin d'√™tre le cas si l'on regarde √† l'int√©rieur.  Il en va de m√™me pour ELF, Executable et Linkable Format.  Un format de fichier utilis√© universellement, mais peu le comprennent.  Ce guide rapide vous aidera √† comprendre. <br><br><img src="https://habrastorage.org/webt/ka/0m/em/ka0memy9zppvjiut58hua0_cyt8.jpeg"><br><br>  Apr√®s avoir lu ce guide, vous apprendrez: <br><br><ul><li>  Pourquoi le format ELF est-il n√©cessaire et pour quels types de fichiers est-il utilis√© </li><li>  Structure du fichier ELF et d√©tails du format </li><li>  Comment lire et analyser le contenu binaire d'un fichier ELF </li><li>  Quels outils sont utilis√©s pour analyser les fichiers binaires? </li></ul><a name="habracut"></a><br><h2>  Qu'est-ce qu'un fichier ELF? </h2><br>  ELF signifie Executable and Linkable Format et d√©finit la structure des fichiers binaires, des biblioth√®ques et des fichiers de base.  La sp√©cification de format permet au syst√®me d'exploitation d'interpr√©ter correctement les instructions de la machine contenues dans le fichier.  Un fichier ELF est g√©n√©ralement le fichier de sortie d'un compilateur ou d'un √©diteur de liens et a un format binaire.  √Ä l'aide d'outils adapt√©s, il peut √™tre analys√© et √©tudi√©. <br><br><h3>  Pourquoi √©tudier ELF en d√©tail? </h3><br>  Avant de plonger dans les d√©tails techniques, il ne sera pas inutile d'expliquer pourquoi la compr√©hension du format ELF est utile.  Tout d'abord, il vous permet d'√©tudier le fonctionnement interne du syst√®me d'exploitation.  En cas de probl√®me, cette connaissance vous aidera √† mieux comprendre ce qui s'est exactement pass√© et pour quelle raison.  En outre, la possibilit√© d'examiner les fichiers ELF peut √™tre utile pour trouver des failles de s√©curit√© et d√©tecter les fichiers suspects.  Et enfin, pour une meilleure compr√©hension du processus de d√©veloppement.  M√™me si vous programmez dans un langage de haut niveau comme Go, vous saurez toujours mieux ce qui se passe dans les coulisses. <br><br>  Alors pourquoi √©tudier ELF? <br><br><ul><li>  Pour une compr√©hension g√©n√©rale du syst√®me d'exploitation </li><li>  Pour le d√©veloppement de logiciels </li><li>  Digital Forensics and Incident Response (DFIR) </li><li>  Recherche de logiciels malveillants (analyse binaire) </li></ul><br><h3>  De la source au processus </h3><br>  Quel que soit le syst√®me d'exploitation que nous utilisons, il est n√©cessaire de traduire en quelque sorte les fonctions du code source en langage CPU - code machine.  Les fonctions peuvent √™tre les plus √©l√©mentaires, par exemple, ouvrir un fichier sur le disque ou afficher quelque chose √† l'√©cran.  Au lieu d'utiliser directement le langage CPU, nous utilisons un langage de programmation dot√© de fonctionnalit√©s standard.  Le compilateur traduit ensuite ces fonctions en code objet.  Ce code objet est ensuite li√© dans le programme complet, √† l'aide de l'√©diteur de liens.  Le r√©sultat est un fichier binaire qui peut √™tre ex√©cut√© sur une plate-forme sp√©cifique et un type sp√©cifique de CPU. <br><br><h3>  Avant de commencer </h3><br>  Ce message contient de nombreuses √©quipes.  Il est pr√©f√©rable de les ex√©cuter sur une machine de test.  Copiez les fichiers binaires existants avant d'ex√©cuter ces commandes dessus.  Nous √©crirons √©galement un petit programme C que vous pourrez compiler.  En fin de compte, la pratique est la meilleure fa√ßon d'apprendre quelque chose. <br><br><h2>  Anatomie d'un fichier ELF </h2><br>  Une id√©e fausse commune est que les fichiers ELF sont uniquement pour les fichiers binaires ou ex√©cutables.  Nous avons d√©j√† dit qu'ils peuvent √™tre utilis√©s pour des parties de fichiers ex√©cutables (code objet).  Un autre exemple est les fichiers de biblioth√®que et les vidages de m√©moire (fichiers de base et fichiers a.out).  La sp√©cification ELF est √©galement utilis√©e sous Linux pour le noyau et les modules du noyau. <br><br><img src="https://habrastorage.org/webt/dt/5y/vq/dt5yvqm-oju3s6todxbbd6ivzw0.png"><br><br><h3>  La structure </h3><br>  En raison de l'extensibilit√© des fichiers ELF, la structure peut varier pour diff√©rents fichiers.  Le fichier ELF comprend: <br><br><ol><li>  En-t√™te ELF </li><li>  les donn√©es </li></ol><br>  Avec la commande readelf, nous pouvons regarder la structure du fichier, et cela ressemblera √† ceci: <br><br><img src="https://habrastorage.org/webt/vo/ng/w-/vongw-d8cy_mvkf9jgcizbdpq0c.png"><br><br><h3>  En-t√™te ELF </h3><br>  Comme vous pouvez le voir sur la capture d'√©cran, l'en-t√™te ELF commence par un ¬´nombre magique¬ª.  Ce "nombre magique" donne des informations sur le fichier.  Les 4 premiers octets d√©terminent qu'il s'agit d'un fichier ELF (45 = E, 4c = L, 46 = F, ils sont pr√©c√©d√©s de 7f). <br><br>  L'en-t√™te ELF est requis.  Il est n√©cessaire pour que les donn√©es soient correctement interpr√©t√©es lors de la liaison et de l'ex√©cution.  Pour une meilleure compr√©hension du fonctionnement interne d'un fichier ELF, il est utile de savoir √† quoi servent ces informations. <br><br><h3>  Classe </h3><br>  Apr√®s avoir d√©clar√© un type ELF, un champ de classe suit.  Cette valeur signifie l'architecture √† laquelle le fichier est destin√©.  Il peut √™tre 01 (architecture 32 bits) ou 02 (64 bits).  Ici, nous voyons 02, qui est traduit par la commande readelf comme un fichier ELF64, c'est-√†-dire que ce fichier utilise une architecture 64 bits.  Ce n'est pas surprenant, un processeur moderne est install√© dans ma voiture. <br><br><h3>  Les donn√©es </h3><br>  Vient ensuite le champ ¬´data¬ª, qui a deux options: 01 - LSB (Least Significant Bit), √©galement connu sous le nom de little-endian, ou 02 - MSB (Most Significant Bit, big-endian).  Ces valeurs aident √† interpr√©ter le reste des objets du fichier.  Ceci est important car diff√©rents types de processeurs g√®rent diff√©remment les structures de donn√©es.  Dans notre cas, LSB est utilis√©, car le processeur a une architecture AMD64. <br><br>  L'effet LSB devient visible lors de l'utilisation de l'utilitaire hexdump sur un fichier binaire.  Voyons l'en-t√™te ELF pour / bin / ps. <br><br><pre><code class="bash hljs">$ hexdump -n 16 /bin/ps 0000000 457f 464c 0102 0001 0000 0000 0000 0000 0000010</code> </pre> <br>  Nous voyons que les paires de valeurs sont diff√©rentes, en raison de l'interpr√©tation de l'ordre des donn√©es. <br><br><h3>  La version </h3><br>  Suit ensuite une autre valeur magique "01", qui est le num√©ro de version.  Seule la version 01 est actuellement disponible, donc ce nombre ne signifie rien d'int√©ressant. <br><br><h3>  OS / ABI </h3><br>  Chaque syst√®me d'exploitation a sa propre fa√ßon d'appeler les fonctions, ils ont beaucoup en commun, mais en plus, chaque syst√®me a de petites diff√©rences.  L'ordre de l'appel de fonction est d√©termin√© par l'interface binaire d'application (ABI).  Les champs OS / ABI d√©crivent l'ABI utilis√© et sa version.  Dans notre cas, la valeur est 00, ce qui signifie que des extensions sp√©cifiques ne sont pas utilis√©es.  Dans la sortie, cela est indiqu√© comme syst√®me V. <br><br><h3>  Version ABI </h3><br>  Si n√©cessaire, une version ABI peut √™tre indiqu√©e. <br><br><h3>  Voiture </h3><br>  Le titre indique √©galement le type de machine attendu (AMD64). <br><br><h3>  Tapez </h3><br>  Le champ type indique √† quoi sert le fichier.  Voici quelques types de fichiers courants. <br><br>  CORE (valeur 4) <br>  DYN (fichier objet partag√©), biblioth√®que (valeur 3) <br>  EXEC (fichier ex√©cutable), fichier ex√©cutable (valeur 2) <br>  REL (fichier r√©adressable), fichier avant la liaison (valeur 1) <br><br><h3>  Voir le titre complet </h3><br>  Bien que certains champs puissent √™tre consult√©s en lecture seule, il y en a en fait plus.  Par exemple, vous pouvez savoir √† quel processeur le fichier est destin√©.  Utilisez hexdump pour voir l'en-t√™te ELF complet et toutes les valeurs. <br><br><pre> <code class="bash hljs">7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 |.ELF............| 02 00 3e 00 01 00 00 00 a8 2b 40 00 00 00 00 00 |..&gt;......+@.....| 40 00 00 00 00 00 00 00 30 65 01 00 00 00 00 00 |@.......0e......| 00 00 00 00 40 00 38 00 09 00 40 00 1c 00 1b 00 |....@.8...@.....|</code> </pre> <br>  (sortie hexdump -C -n 64 / bin / ps) <br><br>  Le champ en surbrillance d√©termine le type de machine.  La valeur 3e est d√©cimale 62, ce qui correspond √† AMD64.  Pour avoir une id√©e de tous les types de fichiers, consultez <a href="" rel="nofollow">ce</a> fichier d'en-t√™te. <br><br>  Bien que vous puissiez faire tout cela dans un vidage hexad√©cimal, il est logique d'utiliser un outil qui fait le travail pour vous.  L'utilitaire dumpelf peut √™tre utile.  Il affiche une sortie format√©e correspondant √† l'en-t√™te ELF.  Il sera bon d'√©tudier quels champs sont utilis√©s et quelles sont leurs valeurs typiques. <br><br>  Maintenant, o√π nous avons expliqu√© la signification de ces champs, il est temps de regarder ce qu'est la vraie magie derri√®re eux et de passer aux rubriques suivantes! <br><br><h3>  Donn√©es de fichier </h3><br>  En plus de l'en-t√™te, les fichiers ELF se composent de trois parties. <br><br><ul><li>  En-t√™tes ou segments de programme </li><li>  Section ou en-t√™tes de section </li><li>  Les donn√©es </li></ul><br>  Avant de plonger dans ces en-t√™tes, il serait utile de savoir que le fichier ELF a deux ¬´types¬ª diff√©rents.  L'un d'eux est con√ßu pour l'√©diteur de liens et permet l'ex√©cution de code (segments).  L'autre concerne les commandes et les donn√©es (sections).  Selon l'objectif, le type d'en-t√™te appropri√© est utilis√©.  Commen√ßons par l'en-t√™te du programme, qui se trouve dans les fichiers ex√©cutables ELF. <br><br><h3>  Titres de programme </h3><br>  Un fichier ELF se compose de z√©ro ou plusieurs segments et d√©crit comment cr√©er un processus, une image m√©moire pour l'ex√©cution au moment de l'ex√©cution.  Lorsque le noyau voit ces segments, il les place dans l'espace d'adressage virtuel √† l'aide de l'appel syst√®me mmap (2).  En d'autres termes, il convertit des instructions pr√©-pr√©par√©es en une image en m√©moire.  Si le fichier ELF est un binaire normal, il n√©cessite ces en-t√™tes de programme, sinon il ne fonctionnera tout simplement pas.  Ces en-t√™tes sont utilis√©s, avec les structures de donn√©es correspondantes, pour former le processus.  Pour les biblioth√®ques partag√©es, le processus est similaire. <br><br><img src="https://habrastorage.org/webt/p4/ja/c_/p4jac_lojwvn9movhy8w5rad1g0.png"><br>  En-t√™te de programme dans un fichier ELF binaire <br><br>  Nous voyons 9 titres de programme dans cet exemple.  Au d√©but, il est difficile de comprendre ce qu'ils signifient.  Plongeons-nous dans les d√©tails. <br><br><h3>  GNU_EH_FRAME </h3><br>  Il s'agit de la file d'attente tri√©e utilis√©e par le compilateur GCC.  Il stocke les gestionnaires d'exceptions.  En cas de probl√®me, ils sont utilis√©s pour g√©rer correctement la situation. <br><br><h3>  GNU_STACK </h3><br>  Cet en-t√™te est utilis√© pour enregistrer les informations de pile.  Une caract√©ristique int√©ressante est que la pile n'a pas besoin d'√™tre ex√©cutable, car cela pourrait entra√Æner des failles de s√©curit√©. <br><br>  Si le segment GNU_STACK est manquant, la pile ex√©cutable est utilis√©e.  Les utilitaires scanelf et execstack affichent les d√©tails du p√©riph√©rique de pile. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># scanelf -e /bin/ps TYPE STK/REL/PTL FILE ET_EXEC RW- R-- RW- /bin/ps # execstack -q /bin/ps - /bin/ps</span></span></code> </pre> <br>  Commandes pour afficher l'en-t√™te du programme: <br><br><ul><li>  dumpelf (pax-utils) </li><li>  elfls -S / bin / ps </li><li>  eu-readelf - en-t√™tes de programme / bin / ps </li></ul><br><h3>  Sections ELF </h3><br><h4>  En-t√™tes de section </h4><br>  Les en-t√™tes de section d√©finissent toutes les sections d'un fichier.  Comme d√©j√† mentionn√©, ces informations sont utilis√©es pour la liaison et la relocalisation. <br><br>  Les sections apparaissent dans un fichier ELF apr√®s que le compilateur GNU C convertit le code C en assembleur et que l'assembleur GNU cr√©e des objets. <br><br>  Comme le montre la figure ci-dessus, un segment peut avoir 0 ou plusieurs sections.  Il existe quatre sections principales pour les fichiers ex√©cutables: .text, .data, .rodata et .bss.  Chacune de ces sections d√©marre avec des autorisations diff√©rentes, qui peuvent √™tre affich√©es avec readelf -S. <br><br><h4>  .text </h4><br>  Contient du code ex√©cutable.  Il sera conditionn√© dans un segment avec des droits de lecture et d'ex√©cution.  Il est t√©l√©charg√© une fois et son contenu ne change pas.  Cela peut √™tre vu avec l'utilitaire objdump. <br><br><pre> <code class="bash hljs">12 .text 0000a3e9 0000000000402120 0000000000402120 00002120 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE</code> </pre> <br><h4>  .data </h4><br>  Donn√©es initialis√©es avec des autorisations de lecture et d'√©criture. <br><br><h4>  .rodata </h4><br>  Donn√©es initialis√©es avec des autorisations en lecture seule.  (= A). <br><br><h4>  .bss </h4><br>  Donn√©es non initialis√©es avec des autorisations de lecture / √©criture.  (= WA) <br><br><pre> <code class="bash hljs">[24] .data PROGBITS 00000000006172e0 000172e0 0000000000000100 0000000000000000 WA 0 0 8 [25] .bss NOBITS 00000000006173e0 000173e0 0000000000021110 0000000000000000 WA 0 0 32</code> </pre> <br><br>  Commandes pour afficher les sections et les titres. <br><br><ul><li>  dumpelf </li><li>  elfls -p / bin / ps </li><li>  eu-readelf ‚Äìsection-headers / bin / ps </li><li>  readelf -S / bin / ps </li><li>  objdump -h / bin / ps </li></ul><br><h4>  Groupes de sections </h4><br>  Certaines sections peuvent √™tre regroup√©es comme si elles formaient un seul ensemble.  De nouveaux √©diteurs de liens prennent en charge cette fonctionnalit√©.  Mais alors que ce n'est pas courant. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># readelf -g /bin/ps There are no section groups in this file.</span></span></code> </pre> <br>  Bien que cela ne semble pas tr√®s int√©ressant, la connaissance des outils d'analyse de fichiers ELF offre de grands avantages.  Pour cette raison, un aper√ßu de ces outils et de leur fonction est donn√© √† la fin de l'article. <br><br><h3>  Binaires statiques et dynamiques </h3><br>  Lorsqu'il s'agit de fichiers binaires ELF, il sera utile de savoir comment ces deux types de fichiers sont li√©s.  Ils peuvent √™tre statiques et dynamiques, et cela s'applique aux biblioth√®ques qu'ils utilisent.  Si le binaire est ¬´dynamique¬ª, cela signifie qu'il utilise des biblioth√®ques externes qui contiennent certaines fonctions communes, telles que l'ouverture d'un fichier ou la cr√©ation d'une socket r√©seau.  Les binaires statiques, en revanche, incluent toutes les biblioth√®ques n√©cessaires. <br><br>  Si vous souhaitez v√©rifier si le fichier est statique ou dynamique, utilisez la commande file.  Elle montrera quelque chose comme ceci: <br><br><pre> <code class="bash hljs">$ file /bin/ps /bin/ps: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), &lt;b&gt;dynamically linked (uses shared libs)&lt;/b&gt;, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GNU/Linux 2.6.24, BuildID[sha1]=2053194ca4ee8754c695f5a7a7cff2fb8fdd297e, stripped</code> </pre> <br>  Pour d√©terminer quelles biblioth√®ques externes sont utilis√©es, utilisez simplement ldd sur le m√™me binaire: <br><br><pre> <code class="bash hljs">$ ldd /bin/ps linux-vdso.so.1 =&gt; (0x00007ffe5ef0d000) libprocps.so.3 =&gt; /lib/x86_64-linux-gnu/libprocps.so.3 (0x00007f8959711000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f895934c000) /lib64/ld-linux-x86-64.so.2 (0x00007f8959935000)</code> </pre> <br>  Conseil: Pour voir d'autres d√©pendances, il est pr√©f√©rable d'utiliser l'utilitaire lddtree. <br><br><h2>  Outils d'analyse binaire </h2><br>  Si vous souhaitez analyser des fichiers ELF, il sera certainement utile de regarder d'abord les outils existants.  Il existe des bo√Ætes √† outils pour le d√©veloppement inverse des binaires et du code ex√©cutable.  Si vous d√©butez dans l'analyse des fichiers ELF, commencez par l'analyse statique.  L'analyse statique implique que nous examinions les fichiers sans les d√©marrer.  Lorsque vous commencez √† mieux comprendre leur travail, passez √† l'analyse dynamique.  Ex√©cutez les exemples et examinez leur comportement r√©el. <br><br><h3>  Outils populaires </h3><br><h4>  Radare2 </h4><br>  La bo√Æte √† outils Radare2 a √©t√© cr√©√©e par Sergi Alvarez.  Le chiffre 2 implique que le code a √©t√© compl√®tement r√©√©crit par rapport √† la premi√®re version.  Maintenant, il est utilis√© par de nombreux chercheurs pour √©tudier le fonctionnement du code. <br><br><h4>  Logiciels </h4><br>  La plupart des syst√®mes Linux ont des binutils install√©s.  D'autres packages peuvent vous aider √† voir plus d'informations.  La bo√Æte √† outils appropri√©e simplifiera votre travail, surtout si vous analysez des fichiers ELF.  J'ai compil√© ici une liste de packages et d'utilitaires pour l'analyse des fichiers ELF. <br><br>  <b>elfutils</b> <br>  / usr / bin / eu-addr2line <br>  / usr / bin / eu-ar - une alternative √† ar, pour cr√©er et traiter des fichiers d'archives <br>  / usr / bin / eu-elfcmp <br>  / usr / bin / eu-elflint - v√©rifier la conformit√© aux sp√©cifications gABI et psABI <br>  / usr / bin / eu-findtextrel - recherche de d√©localisations de texte <br>  / usr / bin / eu-ld - combine les fichiers objet et archive <br>  / usr / bin / eu-make-debug-archive <br>  / usr / bin / eu-nm - affiche les symboles de l'objet et des fichiers ex√©cutables <br>  / usr / bin / eu-objdump - affiche les informations du fichier objet <br>  / usr / bin / eu-ranlib - cr√©e un index des fichiers d'archive <br>  / usr / bin / eu-readelf - affiche le fichier ELF sous une forme lisible <br>  / usr / bin / eu-size - affiche la taille de chaque section (texte, donn√©es, bss, etc.) <br>  / usr / bin / eu-stack - affiche la pile du processus en cours ou le vidage du noyau <br>  / usr / bin / eu-strings - affiche les cha√Ænes de texte (comme l'utilitaire strings) <br>  / usr / bin / eu-strip - supprime la table des caract√®res du fichier ELF <br>  / usr / bin / eu-unstrip - ajoute des symboles et des informations de d√©bogage au binaire <br>  Remarque: le paquet elfutils sera un bon d√©but, il contient la plupart des outils d'analyse <br><br>  <b>elfkickers</b> <br>  / usr / bin / ebfc - compilateur de langage Brainfuck <br>  / usr / bin / elfls - affiche les en-t√™tes de programme et les en-t√™tes de section avec des drapeaux <br>  / usr / bin / elftoc - convertit un binaire en programme C <br>  / usr / bin / infect - un utilitaire injectant un compte-gouttes cr√©e un fichier setuid dans / tmp <br>  / usr / bin / objres - cr√©e un objet √† partir de donn√©es r√©guli√®res ou binaires <br>  / usr / bin / rebind - modifie la liaison et la visibilit√© des caract√®res dans les fichiers ELF <br>  / usr / bin / sstrip - supprime les composants inutiles d'un fichier ELF <br>  Remarque: l'auteur du package ELFKickers se concentre sur la manipulation des fichiers ELF, ce qui vous permet d'obtenir plus d'informations lorsque vous travaillez avec les ¬´mauvais¬ª binaires ELF <br><br>  <b>pax-utils</b> <br>  / usr / bin / dumpelf - vidage de la structure ELF interne <br>  / usr / bin / lddtree - comme ldd, avec la d√©finition du niveau des d√©pendances affich√© <br>  / usr / bin / pspax - affiche des informations ELF / PaX sur les processus en cours d'ex√©cution <br>  / usr / bin / scanelf - un large √©ventail d'informations, y compris les d√©tails PaX <br>  / usr / bin / scanmacho - affiche les d√©tails des binaires Mach-O (Mac OS X) <br>  / usr / bin / symtree - affiche les caract√®res d'arbre <br>  Remarque: certains utilitaires de ce package peuvent analyser r√©cursivement les r√©pertoires et sont id√©aux pour analyser l'int√©gralit√© du contenu d'un r√©pertoire.  L'accent est mis sur les outils de recherche PaX.  En plus de prendre en charge ELF, vous pouvez extraire des informations des fichiers binaires Mach-O. <br><br>  Exemple de sortie <br><pre> <code class="bash hljs">scanelf -a /bin/ps TYPE PAX PERM ENDIAN STK/REL/PTL TEXTREL RPATH BIND FILE ET_EXEC PeMRxS 0755 LE RW- R-- RW- - - LAZY /bin/ps</code> </pre> <br><br>  <b>prelink</b> <br>  / usr / bin / execstack - vous pouvez afficher ou modifier des informations pour savoir si la pile est ex√©cutable <br>  / usr / bin / prelink - d√©place les appels dans les fichiers ELF pour acc√©l√©rer le processus <br><br><h2>  Foire aux questions </h2><br><h3>  Qu'est-ce qu'un ABI? </h3><br>  ABI est l'interface binaire d'application et d√©finit une interface de bas niveau entre le syst√®me d'exploitation et le code ex√©cutable. <br><br><h3>  Qu'est-ce que ELF? </h3><br>  ELF est un format ex√©cutable et liable.  Il s'agit d'une sp√©cification de format qui d√©finit comment les instructions sont √©crites dans du code ex√©cutable. <br><br><h3>  Comment puis-je voir le type de fichier? </h3><br>  Utilisez la commande file pour la premi√®re √©tape de l'analyse.  Cette commande est capable d'afficher les d√©tails extraits des num√©ros et des titres "magiques". <br><br><h2>  Conclusion </h2><br>  Les fichiers ELF sont destin√©s √† l'ex√©cution et √† la liaison.  Selon le but, ils contiennent les segments et sections n√©cessaires.  Le noyau du syst√®me d'exploitation analyse les segments et les mappe en m√©moire (√† l'aide de mmap).  Les sections sont affich√©es par un √©diteur de liens qui cr√©e un fichier ex√©cutable ou un objet partag√©. <br><br>  Les fichiers ELF sont tr√®s flexibles et prennent en charge diff√©rents types de CPU, d'architectures de machine et de syst√®mes d'exploitation.  Il est √©galement extensible, chaque fichier est con√ßu diff√©remment, en fonction des pi√®ces requises.  En utilisant les bons outils, vous pouvez comprendre le but du fichier et examiner le contenu des fichiers binaires.  Vous pouvez afficher les fonctions et les lignes contenues dans le fichier.  Un bon d√©but pour ceux qui recherchent des logiciels malveillants, ou pour comprendre pourquoi le processus se comporte (ou non) d'une certaine mani√®re. <br><br><h2>  Ressources pour une √©tude plus approfondie </h2><br>  Si vous voulez en savoir plus sur ELF et la r√©tro-ing√©nierie, vous pouvez voir le travail que nous faisons dans Linux Security Expert.  Dans le cadre du programme, nous avons <a href="https://linuxsecurity.expert/training/domains/reverse-engineering" rel="nofollow">un module de r√©tro-ing√©nierie</a> avec des travaux pratiques en laboratoire. <br><br>  Pour ceux d'entre vous qui aiment lire, un bon et profond document: <a href="http://www.skyfree.org/linux/references/ELF_Format.pdf" rel="nofollow">ELF Format</a> et un <a href="http://www.muppetlabs.com/~breadbox/software/ELF.txt" rel="nofollow">article r√©dig√© par</a> Brian Raiter, √©galement connu sous le nom d'ELFkickers.  Pour ceux qui aiment comprendre la source, consultez l'en- <a href="" rel="nofollow">t√™te ELF document√©</a> d'Apple. <br><br>  Astuce: <br>  Si vous souhaitez am√©liorer l'analyse des fichiers, commencez √† utiliser les <a href="https://linuxsecurity.expert/security-tools/binary-analysis-tools" rel="nofollow">outils d'analyse populaires</a> actuellement disponibles. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480642/">https://habr.com/ru/post/fr480642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480614/index.html">ENUM rapide</a></li>
<li><a href="../fr480618/index.html">Jeu √©lectronique Tic Tac Toe. O√π suis-je venu</a></li>
<li><a href="../fr480620/index.html">SD-WAN et DNA pour aider l'administrateur: caract√©ristiques des architectures et de la pratique</a></li>
<li><a href="../fr480622/index.html">Comment utiliser correctement la capacit√© de stockage disponible</a></li>
<li><a href="../fr480626/index.html">H√©ritage des syst√®mes et processus h√©rit√©s ou Les 90 premiers jours dans le r√¥le de CTO</a></li>
<li><a href="../fr480644/index.html">Le manifeste sur l'abolition de 146 du Code p√©nal et le boycott de la Sberbank et des d√©tenteurs de droits d'auteur-parasites. Pour l'open source et nginx</a></li>
<li><a href="../fr480646/index.html">Habr - meilleurs articles, auteurs et statistiques 2019</a></li>
<li><a href="../fr480650/index.html">Dont les cheveux sont plus forts: morphologie des cheveux</a></li>
<li><a href="../fr480652/index.html">Cam√©ra PoE de 250 m√®tres sur fil - c'est possible</a></li>
<li><a href="../fr480654/index.html">Julia battra-t-elle Python comme Python l'a fait avec Java?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>