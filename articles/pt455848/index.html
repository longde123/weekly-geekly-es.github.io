<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéé üêÖ üë©‚Äçüëß‚Äçüë¶ T√©cnica para evitar comportamento indefinido ao acessar um singleton üêì üë®üèº‚Äç‚öñÔ∏è üí≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O artigo discute as causas e m√©todos para evitar comportamento indefinido ao acessar um singleton no c ++ moderno. Exemplos de c√≥digo de thread √∫nico ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>T√©cnica para evitar comportamento indefinido ao acessar um singleton</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455848/">  O artigo discute as causas e m√©todos para evitar comportamento indefinido ao acessar um singleton no c ++ moderno.  Exemplos de c√≥digo de thread √∫nico s√£o fornecidos.  Nada espec√≠fico do compilador, tudo de acordo com o padr√£o. <br><a name="habracut"></a><br><h3>  1. Introdu√ß√£o </h3><br>  Para come√ßar, recomendo que voc√™ leia outros artigos sobre singleton no Habr√©: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tr√™s idades do padr√£o Singleton</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Singleton e inst√¢ncias comuns</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3 maneiras de quebrar o princ√≠pio da responsabilidade √∫nica</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Singleton - padr√£o ou antipadr√£o?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando o Padr√£o Singleton</a> <br><br>  E, finalmente, um artigo que abordou o mesmo t√≥pico, mas entrou (mesmo que apenas porque as desvantagens e limita√ß√µes n√£o foram consideradas): <br>  objetos inicializados (ou seja, objetos <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vida √∫til de um √∫nico objeto e</a> <br><br>  Seguinte: <br><br><ul><li>  este <b>n√£o</b> √© um artigo sobre propriedades arquitet√¥nicas de singleton; </li><li>  este <b>n√£o</b> √© um artigo ‚Äúcomo fazer um singleton branco e fofo com um singleton terr√≠vel e terr√≠vel‚Äù; </li><li>  essa <b>n√£o</b> √© <b>uma</b> campanha √∫nica; </li><li>  n√£o √© uma cruzada contra singleton; </li><li>  este <b>n√£o</b> √© <b>um</b> artigo final feliz. </li></ul><br>  Este artigo √© sobre um aspecto muito importante, mas ainda t√©cnico, do uso de singleton no C ++ moderno.  A aten√ß√£o principal do artigo √© dedicada ao momento de destrui√ß√£o do singleton, como  na maioria das fontes, a quest√£o da destrui√ß√£o √© pouco divulgada.  Geralmente, a √™nfase est√° no momento em que o singleton foi criado, e na destrui√ß√£o, na melhor das hip√≥teses, diz algo como "destru√≠do na ordem inversa". <br><br>  <b>Pedimos que voc√™ siga o escopo do artigo nos coment√°rios, especialmente para n√£o organizar o padr√£o singleton versus o holivar antipadr√£o singleton.</b> <br><br>  Ent√£o vamos l√°. <br><br><h3>  O que o padr√£o diz </h3><br>  As cita√ß√µes s√£o do rascunho final em C ++ 14 N3936, como  os rascunhos dispon√≠veis do C ++ 17 n√£o s√£o marcados como "finais". <br>  Dou a se√ß√£o mais importante em sua totalidade.  Lugares importantes s√£o destacados por mim. <br><br><blockquote>  3.6.3 Rescis√£o [basic.start.term] <br><br>  1. Destrutores (12.4) para objetos inicializados (ou seja, objetos cuja vida √∫til (3.8) come√ßou) com dura√ß√£o de armazenamento est√°tico s√£o chamados como resultado do retorno do main e como resultado da chamada std :: exit (18.5).  Destrutores para objetos inicializados com dura√ß√£o de armazenamento de encadeamento em um determinado encadeamento s√£o chamados como resultado do retorno da fun√ß√£o inicial desse encadeamento e como resultado desse encadeamento que chama std :: exit.  <b>As conclus√µes dos destruidores para todos os objetos inicializados com dura√ß√£o de armazenamento de encadeamento dentro desse encadeamento s√£o sequenciadas antes do in√≠cio dos destruidores de qualquer objeto com dura√ß√£o de armazenamento est√°tico.</b>  <b>Se a conclus√£o do construtor ou a inicializa√ß√£o din√¢mica de um objeto com dura√ß√£o de armazenamento do encadeamento for sequenciada antes da de outro, a conclus√£o do destruidor do segundo ser√° sequenciada antes do in√≠cio do destruidor do primeiro.</b>  <b>Se a conclus√£o do construtor ou a inicializa√ß√£o din√¢mica de um objeto com dura√ß√£o de armazenamento est√°tico for sequenciada antes da de outro, a conclus√£o do destruidor do segundo ser√° sequenciada antes do in√≠cio do destruidor do primeiro.</b>  [Nota: Esta defini√ß√£o permite destrui√ß√£o simult√¢nea.  ‚ÄìFinal nota] Se um objeto for inicializado estaticamente, ele ser√° destru√≠do na mesma ordem como se o objeto fosse inicializado dinamicamente.  Para um objeto do tipo matriz ou classe, todos os subobjetos desse objeto s√£o destru√≠dos antes que qualquer objeto de escopo de bloco com dura√ß√£o de armazenamento est√°tico inicializado durante a constru√ß√£o dos subobjetos seja destru√≠do.  Se a destrui√ß√£o de um objeto com dura√ß√£o de armazenamento est√°tico ou de thread sair por meio de uma exce√ß√£o, std :: terminate ser√° chamado (15.5.1). <br><br>  2. <b>Se uma fun√ß√£o contiver um objeto de escopo de bloco com dura√ß√£o de armazenamento est√°tico ou de thread que foi destru√≠do e a fun√ß√£o for chamada durante a destrui√ß√£o de um objeto com dura√ß√£o de armazenamento est√°tico ou de thread, o programa ter√° um comportamento indefinido se o fluxo de controle passar atrav√©s da defini√ß√£o do objeto de luneta destru√≠da anteriormente.</b>  Da mesma forma, o comportamento √© indefinido se o objeto de escopo do bloco for usado indiretamente (ou seja, atrav√©s de um ponteiro) ap√≥s sua destrui√ß√£o. <br><br>  <b>3. Se a conclus√£o da inicializa√ß√£o de um objeto com dura√ß√£o de armazenamento est√°tico for sequenciada antes de uma chamada para std :: atexit (consulte "cstdlib", 18.5), a chamada para a fun√ß√£o passada para std :: atexit ser√° sequenciada antes da chamada para o destruidor do objeto.</b>  <b>Se uma chamada para std :: atexit for sequenciada antes da conclus√£o da inicializa√ß√£o de um objeto com dura√ß√£o de armazenamento est√°tico, a chamada para o destruidor do objeto ser√° sequenciada antes da chamada para a fun√ß√£o passada para std :: atexit.</b>  <b>Se uma chamada para std :: atexit for sequenciada antes de outra chamada para std :: atexit, a chamada para a fun√ß√£o passada para a segunda chamada std :: atexit ser√° sequenciada antes da chamada para a fun√ß√£o passada para a primeira chamada std :: atexit .</b> <br><br>  4. Se houver um uso de um objeto ou fun√ß√£o de biblioteca padr√£o n√£o permitido nos manipuladores de sinal (18.10) que n√£o ocorra antes (1.10) da destrui√ß√£o de objetos com dura√ß√£o de armazenamento est√°tico e execu√ß√£o das fun√ß√µes registradas std :: atexit (18.5 ), o programa tem um comportamento indefinido.  [Nota: Se houver um uso de um objeto com dura√ß√£o de armazenamento est√°tico que n√£o ocorra antes da destrui√ß√£o do objeto, o programa ter√° um comportamento indefinido.  Terminar cada encadeamento antes de uma chamada para std :: exit ou a sa√≠da do main √© suficiente, mas n√£o √© necess√°rio, para atender a esses requisitos.  Esses requisitos permitem que os gerenciadores de encadeamentos sejam objetos de dura√ß√£o de armazenamento est√°tico.  - Nota final] <br><br>  5. Chamar a fun√ß√£o std :: abort () declarada em ‚Äúcstdlib‚Äù finaliza o programa sem executar nenhum destruidor e sem chamar as fun√ß√µes passadas para std :: atexit () ou std :: at_quick_exit (). </blockquote>  Interpreta√ß√£o: <br><br><ul><li>  a destrui√ß√£o de objetos com dura√ß√£o de armazenamento de encadeamento √© realizada na ordem inversa de sua cria√ß√£o; </li><li>  estritamente depois disso, objetos com dura√ß√£o de armazenamento est√°tico s√£o destru√≠dos e chamadas s√£o feitas para fun√ß√µes registradas com std :: atexit na ordem inversa de cria√ß√£o desses objetos e registro de tais fun√ß√µes; </li><li>  Uma tentativa de acessar um objeto destru√≠do com dura√ß√£o de armazenamento de encadeamento ou dura√ß√£o de armazenamento est√°tico cont√©m comportamento indefinido.  A reinicializa√ß√£o de tais objetos n√£o √© fornecida. </li></ul><br>  Nota: as vari√°veis ‚Äã‚Äãglobais no padr√£o s√£o referidas como "vari√°vel n√£o local com dura√ß√£o de armazenamento est√°tico".  Como resultado, verifica-se que todas as vari√°veis ‚Äã‚Äãglobais, todas as singletones (est√°ticas locais) e todas as chamadas para std :: atexit caem em uma √∫nica fila LIFO √† medida que s√£o criadas / registradas. <br><br>  As informa√ß√µes √∫teis para o artigo tamb√©m est√£o contidas na se√ß√£o <b>3.6.2 Inicializa√ß√£o de vari√°veis ‚Äã‚Äãn√£o locais [basic.start.init]</b> .  Trago apenas o mais importante: <br><blockquote>  A inicializa√ß√£o din√¢mica de uma vari√°vel n√£o local com dura√ß√£o de armazenamento est√°tico √© ordenada ou desordenada.  [...] Vari√°veis ‚Äã‚Äãcom inicializa√ß√£o ordenada definida dentro de uma √∫nica unidade de tradu√ß√£o devem ser inicializadas na ordem de suas defini√ß√µes na unidade de tradu√ß√£o. </blockquote>  Interpreta√ß√£o (levando em considera√ß√£o o texto completo da se√ß√£o): vari√°veis ‚Äã‚Äãglobais em uma unidade de tradu√ß√£o s√£o inicializadas na ordem da declara√ß√£o. <br><br><h3>  O que estar√° no c√≥digo </h3><br>  Todos os exemplos de c√≥digo fornecidos no artigo s√£o publicados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> . <br><br>  O c√≥digo consiste em tr√™s camadas, como se fosse escrito por pessoas diferentes: <br><br><ul><li>  singleton; </li><li>  utilit√°rio (classe usando singleton); </li><li>  usu√°rio (vari√°veis ‚Äã‚Äãglobais e principal). </li></ul><br>  Singleton e o utilit√°rio s√£o como uma biblioteca de terceiros, e o usu√°rio √© o usu√°rio. <br>  A camada de utilit√°rio foi projetada para isolar a camada de usu√°rio da camada de singleton.  Nos exemplos, o usu√°rio tem a oportunidade de acessar o singleton, mas agiremos como se isso fosse imposs√≠vel. <br><br>  O usu√°rio primeiro faz tudo certo e, em seguida, com um movimento do pulso, tudo quebra.  Primeiro, tentamos corrigi-lo na camada de utilidade e, se n√£o der certo, na camada de singleton. <br><br>  No c√≥digo, caminharemos constantemente ao longo da borda - agora no lado claro, depois no escuro.  Para facilitar a mudan√ßa para o lado obscuro, foi escolhido o caso mais dif√≠cil - acessar um singleton a partir do destruidor de utilit√°rios. <br><br>  <b>Por que o caso de chamar do destruidor √© o mais dif√≠cil?</b>  Como o destruidor de utilidades pode ser chamado no processo de minimiza√ß√£o do aplicativo, quando a pergunta "o singleton foi destru√≠do ou ainda n√£o" se torna relevante. <br><br>  <b>O caso √© algum tipo de sint√©tico.</b>  <b>Na pr√°tica, n√£o s√£o necess√°rias chamadas para um singleton do destruidor.</b>  Mesmo quando necess√°rio.  Por exemplo, para registrar a destrui√ß√£o de objetos. <br><br>  Tr√™s classes de singleton s√£o usadas: <br><br><ul><li>  SingletonClassic - sem ponteiros inteligentes.  De fato, n√£o √© diretamente cl√°ssico, mas definitivamente o mais cl√°ssico dentre os tr√™s considerados; </li><li>  SingletonShared - com std :: shared_ptr; </li><li>  SingletonWeak - com std :: weak_ptr. </li></ul><br>  Todos os singletones s√£o modelos.  O par√¢metro do modelo √© usado para herdar dele.  Na maioria dos exemplos, eles s√£o parametrizados pela classe Payload, que fornece uma fun√ß√£o p√∫blica para adicionar dados ao std :: set. <br><br>  O destruidor de utilidades na maioria dos exemplos tenta preencher uma centena de valores l√°.  A sa√≠da de diagn√≥stico para o console tamb√©m √© usada a partir do construtor singleton, do destruidor singleton e da inst√¢ncia (). <br><br>  <b>Por que √© t√£o dif√≠cil?</b>  Para facilitar a compreens√£o de que estamos do lado escuro.  O apelo ao singleton destru√≠do √© um comportamento indefinido, mas n√£o pode ser manifestado de forma alguma externamente.  O preenchimento de valores no std :: set destru√≠do tamb√©m certamente n√£o garante manifesta√ß√µes externas, mas n√£o h√° uma maneira mais confi√°vel (de fato, no GCC no Linux em exemplos incorretos com o singleton cl√°ssico, o std :: set destru√≠do √© preenchido com √™xito e no MSVS sob Windows - trava).  Com comportamento indefinido, a sa√≠da para o console pode <b>n√£o</b> ocorrer.  Portanto, nos exemplos corretos, esperamos a aus√™ncia de acesso a instance () ap√≥s o destruidor, bem como a aus√™ncia de um travamento e a aus√™ncia de travamento, e nos incorretos, a presen√ßa de um apelo ou travamento ou travamento ou de uma s√≥ vez em qualquer combina√ß√£o ou qualquer outra coisa. <br><br><h3>  Singleton cl√°ssico </h3><br><div class="spoiler">  <b class="spoiler_title">Payload.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;set&gt; class Payload { public: Payload() = default; ~Payload() = default; Payload(const Payload &amp;) = delete; Payload(Payload &amp;&amp;) = delete; Payload&amp; operator=(const Payload &amp;) = delete; Payload&amp; operator=(Payload &amp;&amp;) = delete; void add(int value) { m_data.emplace(value); } private: std::set&lt;int&gt; m_data; };</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">SingletonClassic.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; template&lt;typename T&gt; class SingletonClassic : public T { public: ~SingletonClassic() { std::cout &lt;&lt; "~SingletonClassic()" &lt;&lt; std::endl; } SingletonClassic(const SingletonClassic &amp;) = delete; SingletonClassic(SingletonClassic &amp;&amp;) = delete; SingletonClassic&amp; operator=(const SingletonClassic &amp;) = delete; SingletonClassic&amp; operator=(SingletonClassic &amp;&amp;) = delete; static SingletonClassic&amp; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; static SingletonClassic inst; return inst; } private: SingletonClassic() { std::cout &lt;&lt; "SingletonClassic()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br><h3>  Exemplo 1 de SingletonClassic </h3><br><div class="spoiler">  <b class="spoiler_title">Classic_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sa√≠da do console</b> <div class="spoiler_text">  instance () <br>  SingletonClassic () <br>  instance () <br>  ~ SingletonClassic () <br></div></div><br>  O utilit√°rio chama o singleton no construtor para garantir que o singleton seja criado antes da cria√ß√£o do utilit√°rio. <br><br>  O usu√°rio cria dois std :: unique_ptr: um vazio, o segundo contendo o utilit√°rio. <br><br>  A ordem da cria√ß√£o: <br><br>  - vazio std :: unique_ptr. <br>  - singleton; <br>  - utilidade. <br><br>  E, consequentemente, a ordem de destrui√ß√£o: <br><br>  - utilidade; <br>  - singleton; <br>  - vazio std :: unique_ptr. <br><br>  A chamada do destruidor de utilit√°rio para o singleton est√° correta. <br><br><h3>  SingletonClassic example 2 </h3><br>  Tudo √© o mesmo, mas o usu√°rio pegou e arruinou tudo com uma linha. <br><br><div class="spoiler">  <b class="spoiler_title">Classic_Example2_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is still the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sa√≠da do console</b> <div class="spoiler_text">  instance () <br>  SingletonClassic () <br>  ~ SingletonClassic () <br>  instance () <br></div></div><br>  A ordem da cria√ß√£o e destrui√ß√£o √© preservada.  Parece que tudo est√° parado.  Mas n√£o.  Invocando emptyUnique.swap (utilityUnique), o usu√°rio confirmou um comportamento indefinido. <br><br>  <b>Por que o usu√°rio fez coisas t√£o est√∫pidas?</b>  Porque ele n√£o sabe nada sobre a estrutura interna da biblioteca, o que lhe forneceu um singleton e uma utilidade. <br><br>  <b>E se voc√™ conhece a estrutura interna da biblioteca?</b>  ... de qualquer maneira, no c√≥digo real, √© muito f√°cil se envolver.  E voc√™ tem que sair por uma penosa penalidade, porque  entender o que exatamente aconteceu n√£o ser√° f√°cil. <br><br>  <b>Por que n√£o exigir que a biblioteca seja usada corretamente?</b>  <b>Bem, existem todos os tipos de docas para escrever, exemplos ...</b> E por que n√£o criar uma biblioteca que n√£o √© t√£o f√°cil de estragar? <br><br><h3>  SingletonClassic example 3 </h3><br>  Durante a prepara√ß√£o do artigo por v√°rios dias, acreditei que era imposs√≠vel eliminar o comportamento indefinido do exemplo anterior na camada de utilidade, e a solu√ß√£o estava dispon√≠vel apenas na camada de singleton.  Mas, com o tempo, surgiu uma solu√ß√£o. <br><br>  Antes de abrir os spoilers com o c√≥digo e a explica√ß√£o, sugiro que o leitor tente encontrar uma sa√≠da da situa√ß√£o por conta pr√≥pria (apenas na camada de utilidade!).  N√£o excluo que existem melhores solu√ß√µes. <br><br><div class="spoiler">  <b class="spoiler_title">Classic_Example3_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { thread_local auto flag_strong = std::make_shared&lt;char&gt;(0); m_flag_weak = flag_strong; SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { if ( !m_flag_weak.expired() ) { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } } private: std::weak_ptr&lt;char&gt; m_flag_weak; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); { // To demonstrate normal processing before application ends auto utility = ClassicSingleThreadedUtility(); } // Guaranteed destruction order is still the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect ... // ... but utility uses a variable with thread storage duration to detect thread termination. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sa√≠da do console</b> <div class="spoiler_text">  instance () <br>  SingletonClassic () <br>  instance () <br>  instance () <br>  ~ SingletonClassic () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Explica√ß√£o</b> <div class="spoiler_text">  O problema ocorre apenas ao minimizar o aplicativo.  O comportamento indefinido pode ser eliminado ensinando o utilit√°rio a reconhecer quando o aplicativo √© minimizado.  Para fazer isso, usamos uma vari√°vel flag_strong do tipo std :: shared_ptr, que possui um qualificador de dura√ß√£o de armazenamento de encadeamento (consulte trechos do padr√£o no artigo acima) - √© como uma est√°tica, mas s√≥ √© destru√≠da quando o encadeamento atual termina <b>antes que qualquer est√°tica seja destru√≠da</b> , inclusive antes da destrui√ß√£o singleton.  A vari√°vel flag_strong √© uma para todo o fluxo, e cada inst√¢ncia do utilit√°rio armazena sua c√≥pia fraca. <br><br>  Em um sentido restrito, a solu√ß√£o pode ser chamada de hack, porque  √© indireto e n√£o √≥bvio.  Al√©m disso, ele alerta muito cedo e, √†s vezes (em um aplicativo multithread), geralmente alerta falso.  Mas, em um sentido amplo, isso n√£o √© um hack, mas uma solu√ß√£o completamente definida pelas propriedades padr√£o - desvantagens e vantagens. <br></div></div><br><h3>  Singletonshared </h3><br>  Vamos seguir para um singleton modificado com base em std :: shared_ptr. <br><br><div class="spoiler">  <b class="spoiler_title">SingletonShared.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; template&lt;typename T&gt; class SingletonShared : public T { public: ~SingletonShared() { std::cout &lt;&lt; "~SingletonShared()" &lt;&lt; std::endl; } SingletonShared(const SingletonShared &amp;) = delete; SingletonShared(SingletonShared &amp;&amp;) = delete; SingletonShared&amp; operator=(const SingletonShared &amp;) = delete; SingletonShared&amp; operator=(SingletonShared &amp;&amp;) = delete; static std::shared_ptr&lt;SingletonShared&gt; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; // "new" and no std::make_shared because of private c-tor static auto inst = std::shared_ptr&lt;SingletonShared&gt;(new SingletonShared); return inst; } private: SingletonShared() { std::cout &lt;&lt; "SingletonShared()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br>  <b>Ai-ai-ai, o novo operador n√£o deve ser usado no c√≥digo moderno, mas std :: make_shared √© necess√°rio!</b>  E isso √© evitado pelo construtor particular do singleton. <br><br>  <b>Ha!</b>  <b>Eu tamb√©m tenho um problema!</b>  <b>Declare std :: make_shared um amigo singleton!</b>  ... e obtenha uma varia√ß√£o do antipadr√£o PublicMorozov: usando o mesmo std :: make_shared, ser√° poss√≠vel criar inst√¢ncias adicionais do singleton que n√£o s√£o fornecidas pela arquitetura. <br><br><h3>  Exemplos 1 e 2 compartilhados </h3><br>  Corresponda totalmente aos exemplos n¬∫ 1 e 2 da vers√£o cl√°ssica.  Altera√ß√µes significativas foram feitas apenas na camada de singleton, o utilit√°rio permaneceu essencialmente o mesmo.  Assim como nos exemplos com o singleton cl√°ssico, o exemplo-1 est√° correto e o exemplo-2 mostra um comportamento indefinido. <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Payload.h&gt; #include &lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonShared&lt;Payload&gt;::instance(); } ~SharedSingleThreadedUtility() { if ( auto instance = SingletonShared&lt;Payload&gt;::instance() ) for ( int i = 0; i &lt; 100; ++i ) instance-&gt;add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sa√≠da do console</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  instance () <br>  ~ SingletonShared () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shared_Example2_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonShared&lt;Payload&gt;::instance(); } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( auto instance = SingletonShared::instance() ) // for ( int i = 0; i &lt; 100; ++i ) // instance-&gt;add(i); // ... so this code will demonstrate UB in colour auto instance = SingletonShared&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance-&gt;add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sa√≠da do console</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  ~ SingletonShared () <br>  instance () <br></div></div><br><h3>  Exemplo 3 de SingletonShared </h3><br>  E agora tentaremos resolver esse problema melhor do que no exemplo n√∫mero 3 dos cl√°ssicos. <br>  A solu√ß√£o √© √≥bvia: voc√™ s√≥ precisa estender a vida √∫til do singleton armazenando uma c√≥pia de std :: shared_ptr retornada pelo singleton no utilit√°rio.  E essa solu√ß√£o, completa com o SingletonShared, foi amplamente replicada em fontes abertas. <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example3_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;Payload&gt;::instance()) { } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( m_singleton ) // for ( int i = 0; i &lt; 100; ++i ) // m_singleton-&gt;add(i); // ... so this code will allow to demonstrate UB in colour for ( int i = 0; i &lt; 100; ++i ) m_singleton-&gt;add(i); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); int main() { // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct ... // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect... // ... but utility have made a copy of shared_ptr when it was available, // so it's correct again. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sa√≠da do console</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  ~ SingletonShared () <br></div></div><br>  E agora, aten√ß√£o, a pergunta √©: <b>voc√™ realmente queria prolongar a vida de um singleton?</b> <br>  Ou voc√™ queria se livrar do comportamento indefinido e escolher a extens√£o da vida como uma maneira de ficar na superf√≠cie? <br><br>  A incorreta teoria na forma de substitui√ß√£o de metas por meios leva ao risco de impasse (ou refer√™ncia c√≠clica - chame como voc√™ deseja). <br><br>  <b>Sim nuuuuuu, √© assim que voc√™ deve se esfor√ßar tanto !?</b>  <b>Voc√™ ter√° que pensar em tanto tempo e certamente n√£o o far√° por acidente!</b> <br><br><div class="spoiler">  <b class="spoiler_title">CallbackPayload.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt; class CallbackPayload { public: CallbackPayload() = default; ~CallbackPayload() = default; CallbackPayload(const CallbackPayload &amp;) = delete; CallbackPayload(CallbackPayload &amp;&amp;) = delete; CallbackPayload&amp; operator=(const CallbackPayload &amp;) = delete; CallbackPayload&amp; operator=(CallbackPayload &amp;&amp;) = delete; void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { m_callbackFn = std::move(fn); } private: std::function&lt;void()&gt; m_callbackFn; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SomethingWithVeryImportantDestructor.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; class SomethingWithVeryImportantDestructor { public: SomethingWithVeryImportantDestructor() { std::cout &lt;&lt; "SomethingWithVeryImportantDestructor()" &lt;&lt; std::endl; } ~SomethingWithVeryImportantDestructor() { std::cout &lt;&lt; "~SomethingWithVeryImportantDestructor()" &lt;&lt; std::endl; } SomethingWithVeryImportantDestructor(const SomethingWithVeryImportantDestructor &amp;) = delete; SomethingWithVeryImportantDestructor(SomethingWithVeryImportantDestructor &amp;&amp;) = delete; SomethingWithVeryImportantDestructor&amp; operator=(const SomethingWithVeryImportantDestructor &amp;) = delete; SomethingWithVeryImportantDestructor&amp; operator=(SomethingWithVeryImportantDestructor &amp;&amp;) = delete; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shared_Example4_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CallbackPayload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span></span><span class="hljs-meta"> class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;CallbackPayload&gt;::instance()) { std::cout &lt;&lt; "SharedSingleThreadedUtility()" &lt;&lt; std::endl; } ~SharedSingleThreadedUtility() { std::cout &lt;&lt; "~SharedSingleThreadedUtility()" &lt;&lt; std::endl; } void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { if ( m_singleton ) m_singleton-&gt;setCallback(std::move(fn)); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;CallbackPayload&gt;&gt; m_singleton; }; int main() { auto utility = std::make_shared&lt;SharedSingleThreadedUtility&gt;(); auto something = std::make_shared&lt;SomethingWithVeryImportantDestructor&gt;(); // lambda with "utility" and "something" captured utility-&gt;setCallback( [utility, something](){} ); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sa√≠da do console</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  SharedSingleThreadedUtility () <br>  SomethingWithVeryImportantDestructor () <br></div></div><br>  Um singleton foi criado. <br><br>  Um utilit√°rio foi criado. <br><br>  <b>Algo S-Very-Important-Destructor foi criado</b> (eu adicionei isso por intimida√ß√£o, porque na Internet existem posts como "bem, o destruidor singleton n√£o ser√° chamado, ent√£o, o que √© isso, deve existir o tempo todo) programas ‚Äù). <br><br>  Mas nenhum destruidor foi chamado para nenhum desses objetos! <br><br>  Por causa do que?  Devido √† substitui√ß√£o de gols por meios. <br><br><h3>  Singletonweak </h3><br><div class="spoiler">  <b class="spoiler_title">SingletonWeak.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; template&lt;typename T&gt; class SingletonWeak : public T { public: ~SingletonWeak() { std::cout &lt;&lt; "~SingletonWeak()" &lt;&lt; std::endl; } SingletonWeak(const SingletonWeak &amp;) = delete; SingletonWeak(SingletonWeak &amp;&amp;) = delete; SingletonWeak&amp; operator=(const SingletonWeak &amp;) = delete; SingletonWeak&amp; operator=(SingletonWeak &amp;&amp;) = delete; static std::weak_ptr&lt;SingletonWeak&gt; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; // "new" and no std::make_shared because of private c-tor static auto inst = std::shared_ptr&lt;SingletonWeak&gt;(new SingletonWeak); return inst; } private: SingletonWeak() { std::cout &lt;&lt; "SingletonWeak()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br>  Essa modifica√ß√£o do singleton em fontes abertas, se dada, certamente n√£o √© frequente.  Eu conheci algumas variantes estranhas viradas do avesso com um std :: weak_ptr, que parece ser usado, o que, aparentemente, oferece ao utilit√°rio nada mais do que prolongar a vida de um singleton: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Singletons usando std :: weak_ptr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√â o caminho certo para criar a classe sinlgeton por weak_ptr</a> </li></ul><br>  A op√ß√£o que proponho, quando aplicada corretamente nas camadas de singleton e utilit√°rio: <br><br><ul><li>  protege contra a√ß√µes na camada do usu√°rio descrita nos exemplos acima, incluindo a preven√ß√£o de conflitos; </li><li>  determina o momento em que o aplicativo √© dobrado com mais precis√£o do que o aplicativo thread_local no Classic_Example3_correct, ou seja,  permite que voc√™ se aproxime da borda; </li><li>  N√£o sofro do problema te√≥rico de substituir objetivos por meios (n√£o sei se algo tang√≠vel que n√£o um impasse pode aparecer nesse problema te√≥rico). </li></ul><br>  No entanto, h√° uma desvantagem: prolongar a vida √∫til de um singleton <b>ainda</b> pode permitir que <b>ele se</b> aproxime <b>ainda mais</b> da borda. <br><br><h3>  Exemplo 1 de SingletonWeak </h3><br>  Semelhante ao Shared_Example3_correct.cpp. <br><br><div class="spoiler">  <b class="spoiler_title">Weak_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;Payload&gt;::instance()) { } ~WeakSingleThreadedUtility() { // Sometimes this check may result as "false" even in case of incorrect usage, // and there's no way to guarantee a demonstration of undefined behaviour in colour if ( auto strong = m_weak.lock() ) for ( int i = 0; i &lt; 100; ++i ) strong-&gt;add(i); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of WeakSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;WeakSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;WeakSingleThreadedUtility&gt;(); int main() { // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct ... // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect... // ... but utility have made a weak copy of shared_ptr when it was available, // so it's correct again. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sa√≠da do console</b> <div class="spoiler_text">  instance () <br>  SingletonWeak () <br>  ~ SingletonWeak () <br></div></div><br>  <b>Por que precisamos do SingletonWeak, porque ningu√©m incomoda o utilit√°rio de usar o SingletonShared como SingletonWeak?</b>  Sim, ningu√©m se incomoda.  E mesmo ningu√©m incomoda o utilit√°rio de usar SingletonWeak como SingletonShared.  Mas us√°-los para a finalidade pretendida √© um pouco mais f√°cil do que us√°-los para outros fins. <br><br><h3>  Exemplo 2 de SingletonWeak </h3><br>  Semelhante ao Shared_Example4_incorrect, mas apenas o deadlock n√£o ocorre neste caso. <br><br><div class="spoiler">  <b class="spoiler_title">Weak_Example2_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CallbackPayload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span></span><span class="hljs-meta"> class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;CallbackPayload&gt;::instance()) { std::cout &lt;&lt; "WeakSingleThreadedUtility()" &lt;&lt; std::endl; } ~WeakSingleThreadedUtility() { std::cout &lt;&lt; "~WeakSingleThreadedUtility()" &lt;&lt; std::endl; } void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { if ( auto strong = m_weak.lock() ) strong-&gt;setCallback(std::move(fn)); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;CallbackPayload&gt;&gt; m_weak; }; int main() { auto utility = std::make_shared&lt;WeakSingleThreadedUtility&gt;(); auto something = std::make_shared&lt;SomethingWithVeryImportantDestructor&gt;(); // lambda with "utility" and "something" captured utility-&gt;setCallback( [utility, something](){} ); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sa√≠da do console</b> <div class="spoiler_text">  instance () <br>  SingletonWeak () <br>  WeakSingleThreadedUtility () <br>  SomethingWithVeryImportantDestructor () <br>  ~ SingletonWeak () <br>  ~ SomethingWithVeryImportantDestructor () <br>  ~ WeakSingleThreadedUtility () <br></div></div><br><h3>  Em vez de uma conclus√£o </h3><br>  <b>E o que, tal modifica√ß√£o de um singleton eliminar√° o comportamento indefinido?</b>  Prometi que n√£o haveria um final feliz.  Os exemplos a seguir mostram que a√ß√µes h√°beis de sabotagem na camada do usu√°rio podem destruir at√© a biblioteca correta com um singleton (mas devemos admitir que <b>isso</b> dificilmente pode ser feito por acidente). <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example5_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdlib&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;Payload&gt;::instance()) { } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( m_singleton ) // for ( int i = 0; i &lt; 100; ++i ) // m_singleton-&gt;add(i); // ... so this code will allow to demonstrate UB in colour for ( int i = 0; i &lt; 100; ++i ) m_singleton-&gt;add(i); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton; }; void cracker() { SharedSingleThreadedUtility(); } // 1. Register cracker() using std::atexit // 2. Create singleton // 3. Create utility auto reg = [](){ std::atexit(&amp;cracker); return 0; }(); auto utility = SharedSingleThreadedUtility(); // This guarantee destruction in order: // - utility; // - singleton. // This order is correct. // Additionally, there's a copy of shared_ptr in the class instance... // ... but there was std::atexit registered before singleton, // so cracker() will be invoked after destruction of utility and singleton. // There's second try to create a singleton - and it's incorrect. int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sa√≠da do console</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  ~ SingletonShared () <br>  instance () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Weak_Example3_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdlib&gt; class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;Payload&gt;::instance()) { } ~WeakSingleThreadedUtility() { // Sometimes this check may result as "false" even in case of incorrect usage, // and there's no way to guarantee a demonstration of undefined behaviour in colour if ( auto strong = m_weak.lock() ) for ( int i = 0; i &lt; 100; ++i ) strong-&gt;add(i); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak; }; void cracker() { WeakSingleThreadedUtility(); } // 1. Register cracker() using std::atexit // 2. Create singleton // 3. Create utility auto reg = [](){ std::atexit(&amp;cracker); return 0; }(); auto utility = WeakSingleThreadedUtility(); // This guarantee destruction in order: // - utility; // - singleton. // This order is correct. // Additionally, there's a copy of shared_ptr in the class instance... // ... but there was std::atexit registered before singleton, // so cracker() will be invoked after destruction of utility and singleton. // There's second try to create a singleton - and it's incorrect. int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sa√≠da do console</b> <div class="spoiler_text">  instance () <br>  SingletonWeak () <br>  ~ SingletonWeak () <br>  instance () <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455848/">https://habr.com/ru/post/pt455848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455834/index.html">Benchmarks para servidores Linux: 5 ferramentas abertas</a></li>
<li><a href="../pt455840/index.html">Como trabalhar com v√°rias consultas. Composi√ß√£o, Redutor, FP</a></li>
<li><a href="../pt455842/index.html">Espalhe uma lista vinculada individualmente. Edi√ß√£o Swift</a></li>
<li><a href="../pt455844/index.html">Criando um analisador Roslyn usando o teste de encapsulamento como exemplo</a></li>
<li><a href="../pt455846/index.html">Computa√ß√£o Distribu√≠da em Julia</a></li>
<li><a href="../pt455850/index.html">Caixa de ferramentas para pesquisadores - terceira edi√ß√£o: localizando e trabalhando com fontes</a></li>
<li><a href="../pt455852/index.html">Eleva√ß√£o sinusal e implanta√ß√£o simult√¢nea</a></li>
<li><a href="../pt455854/index.html">Como implementar menus de contexto no iOS 13</a></li>
<li><a href="../pt455856/index.html">Sensor sem fio de temperatura, umidade e press√£o atmosf√©rica no nRF52832</a></li>
<li><a href="../pt455858/index.html">Redes de TV a cabo para os menores. Parte 9: Headend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>