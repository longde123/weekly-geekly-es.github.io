<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌🏽 🏂🏾 ✋🏻 Topologie und umfassende Analyse für einen ahnungslosen Spieleentwickler: Komprimieren einzelner 3D-Vektoren 🚶🏽 👩🏿‍⚕️ 🥐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie Sie bereits aus meinen vorherigen Artikeln wissen, möchte ich die Spieleentwicklung als Ausrede verwenden, um komplexe Mathematik zu demonstrieren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Topologie und umfassende Analyse für einen ahnungslosen Spieleentwickler: Komprimieren einzelner 3D-Vektoren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482348/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/910/fcb/d9f/910fcbd9f721b1ceea2de3b3a56bcb2c.png" alt="Bild"></div><br>  Wie Sie bereits aus meinen vorherigen Artikeln wissen, möchte ich die Spieleentwicklung als Ausrede verwenden, um komplexe Mathematik zu demonstrieren, für die die meisten Menschen sonst keinen Nutzen hätten.  Und dieser Artikel ist keine Ausnahme!  Ich möchte eine sehr coole Technik zeigen, die den für mich interessanten Punkten entspricht: <br><br><ul><li>  Der Prozess ist klar genug </li><li>  es ist viel schneller als die übliche Technik, die die gleiche Aufgabe ausführt </li><li>  Es verwendet eine sehr ungewöhnliche Eigenschaft, Gleitkommazahlen im Gleitkommaformat darzustellen, was impliziert, dass ... </li><li>  <strong>es funktioniert nicht in der klassischen Analyse</strong> .  Damit dieser Algorithmus theoretisch funktioniert, müssen Sie in die wunderbare Welt der nicht-klassischen Mathematik eintauchen!  Und wenn dies Ihre Neugier nicht geweckt hat, weiß ich nicht, was ich sonst tun soll. </li></ul><br>  Dieser Artikel ist ziemlich lang und theoretisch, da er ein gründliches Studium der Erklärungen erfordert. Nehmen Sie sich also Zeit und lesen Sie die Teile noch einmal durch, von denen Sie dachten, dass sie beim ersten Mal nicht so offensichtlich waren. <br><br><h2>  Ein bisschen über den Kontext (GPU) </h2><br>  Einer der wichtigen Aspekte, auf die Sie bei der Entwicklung von Spielen und im weiteren Sinne - in jedem Bereich mit aktivem Grafikeinsatz - achten sollten, ist die Bandbreite der GPU.  Der Zentralprozessor und die GPU sind separate physische Geräte und müssen synchronisiert werden, um Daten auszutauschen.  Wenn Sie bereits eine Parallelverarbeitung durchgeführt haben, bedeutet dies einen erheblichen Zeitverlust, wenn zwei Geräte synchronisiert werden müssen.  Das Zusammenspiel von CPU und GPU ist in dieser Hinsicht nicht anders. Daher bemühen wir uns, die Datenübertragung sowohl hinsichtlich der Anzahl der Vorgänge als auch der übertragenen Datenmenge so gering wie möglich zu halten. <br><a name="habracut"></a><br>  Die Minimierung der Anzahl der Datenübertragungsvorgänge erfolgt normalerweise durch Puffern: Wir bemühen uns, alle Daten in die kleinstmögliche Anzahl von Arrays zu packen und dann alles auf einmal zu übertragen, damit wir uns nicht mehr darum kümmern müssen.  Die Minimierung der Datenmenge bei Übertragungsvorgängen ist ein völlig anderes Thema, und die Lösungen für dieses Problem sind fast immer individuell.  Als extremes Beispiel hierfür können Sie sehen, <a href="http://advances.realtimerendering.com/s2013/Tatarchuk-Destiny-SIGGRAPH2013.pdf">wie die Destiny-Rendering-Engine die Position, Oberflächennormalen, Material-Flags und 96-Bit-BSDF-Parameter mit vollständiger Anisotropie anpasst, d. H.</a>  <a href="http://advances.realtimerendering.com/s2013/Tatarchuk-Destiny-SIGGRAPH2013.pdf">drei Gleitkommazahlen</a> (ab S. 62).  Gute Ergebnisse lassen sich jedoch mit allgemeinen Methoden erzielen, denen dann individuelle Optimierungslösungen hinzugefügt werden. <br><br>  Heute werden wir die <strong>verlustfreie Komprimierung einzelner 3D-Vektoren</strong> diskutieren.  Dieser Satz enthält mehrere Schlüsselwörter: <br><br><ul><li>  <strong>Einzelne 3D-Vektoren</strong> : 3D-Vektoren mit einer Länge von 1 </li><li>  <strong>verlustfreie Komprimierung</strong> : Verkleinern Sie die Beschreibungen einzelner 3D-Vektoren ohne Genauigkeitsverlust.  Dies ist das Gegenteil von <em>verlustbehafteter Komprimierung.</em> </li><li>  <strong>Separat</strong> : Die Vektorcodierung und -decodierung wird ohne Informationen über die Nachbarn durchgeführt.  Wenn die Situation umgekehrt wäre, könnte es sich um eine Art <em>Stapelkomprimierung handeln</em> , bei der nicht einzelne Vektoren komprimiert werden, sondern deren Arrays </li></ul><br>  Bevor ich fortfahre, muss ich den hervorragenden Artikel <a href="http://jcgt.org/published/0003/02/01/" rel="noopener"><em>„Eine Übersicht über effiziente Darstellungen für unabhängige Einheitsvektoren</em> <em>“</em></a> von Cigolle, Donow, Evangelakos, Mara, McGuire und Meyer erwähnen, von dem ich mich für meinen Beitrag inspirieren ließ.  Ich muss <strong><em>sofort</em></strong> sagen <strong><em>,</em></strong> dass der <strong>Algorithmus, über den ich sprechen werde, weniger effizient ist als der im Artikel vorgestellte <em>Okt.-</em> Algorithmus</strong> .  Wenn Sie maximale Effizienz wünschen, lesen Sie den Artikel und verwenden Sie <em>oct</em> .  Der Zweck meines Beitrags ist es, die Schönheit der Verwendung sehr ungewöhnlicher Mathematik zu demonstrieren und gleichzeitig, wie wir später sehen werden, einen sehr praktischen Algorithmus zu erstellen. <br><br><h2>  Topologie direkt in Ihrem Videospiel </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/a95/4bc/41ca954bca54597431a9a0ebb7a9fe97.png"></div><br>  <i>Im Fall der Einheitskugel sind nur θ und φ wichtig, da ρ immer 1 ist und daher redundant ist.</i> <br><br>  Ausgangspunkt des Algorithmus ist die Beobachtung, dass Einheits-3D-Vektoren Punkten auf einer Kugel entsprechen.  Wie Sie wahrscheinlich wissen, ist eine Kugel eine zweidimensionale Oberfläche, dh für die eindeutige Identifizierung von Punkten auf einer Kugel sind nur zwei Koordinaten erforderlich.  Ein sehr verbreitetes Beispiel hierfür sind Kugelkoordinaten, bei denen ein Punkt auf der Kugel durch zwei Winkel θ und φ definiert ist. <br><br>  Interessanterweise ist eine ziemlich unangenehme Eigenschaft, dass obwohl die Kugel und das gefüllte Quadrat (ein möglicher Raum für 2D-Koordinaten) 2D-Objekte sind, es tatsächlich keine Korrespondenz zwischen ihnen gibt.  Dies bedeutet, dass es keine Möglichkeit gibt, jedem einzelnen Punkt des Quadrats einen eindeutigen Punkt auf der Kugel zuzuordnen (zumindest in kontinuierlicher Weise).  Man sagt, dass sie <em>nicht homöomorph sind</em> (mit anderen Worten, einer hat eine Grenze und der andere nicht).  Ein unangenehmes Ergebnis davon ist, dass einige 2D-Koordinaten in dem Sinne verloren gehen, dass verschiedene Koordinaten identischen Punkten auf der Kugel entsprechen (im Fall von sphärischen Koordinaten, wenn φ 0 ist, ist der entsprechende Punkt unabhängig von der Koordinate θ der Nordpol).  Bei der Komprimierung verlieren wir wertvolle Bitmuster, mit denen wir die Punkte einer Kugel beschreiben können! <br><br>  Wenn Sie mehr Mathematik wollen und beweisen möchten, dass das Quadrat und die Kugel nicht homöomorph sind, können Sie die Tatsache nutzen, dass die Kugel im Gegensatz zum Quadrat nicht kontrahierbar ist und die Kontrahierbarkeit eine topologische Eigenschaft ist.  Der Borsuk-Ulam-Satz kann auch als Beweis verwendet werden.  Sie sagten mir auch, dass Homotopie-Gruppen beim Beweis helfen können, aber dies liegt bereits außerhalb meines Fachgebiets. <br><br>  Dieses Problem tritt jedoch nicht nur bei sphärischen Koordinaten auf;  Darunter leidet jede kontinuierliche 2D-Darstellung der Punkte der Kugel.  Denken Sie jedoch für die Zukunft daran. <br><br>  Sphärische Koordinaten haben auch andere schlechte Eigenschaften: <br><br><ul><li>  Sie haben eine schlechte Verteilung über die Kugel.  Wenn zufällige sphärische Koordinaten generiert und zurück in 3D-Punkte konvertiert werden, bilden sie Cluster um die Pole und sind in der Nähe des Äquators ziemlich dünn.  Dies ist auf die Tatsache zurückzuführen, dass 3D-Vektoren in der Nähe des Äquators weniger genau unterscheidbar sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87c/e1d/15a/87ce1d15ad314b007f0093b83a738538.png"></div><br>  <i>Verteilung auf einer Kugel von 10.000 gleichmäßig verteilten Kugelkoordinaten</i> </li><li>  Ihre Verpackung und ihr Auspacken sind kostspielig.  Für das Packen (3D → 2D) werden eine Operation <em>acos</em> und eine <em>atan2</em> benötigt, was ziemlich kostspielige inverse trigonometrische Funktionen sind, und für das Auspacken (2D → 3D) werden zwei Operationen <em>cos</em> und zwei Operationen <em>sin benötigt</em> , die ebenfalls bei weitem nicht wirtschaftlich sind. </li></ul><br>  Lesen Sie den obigen Artikel, um mehr über andere Vergleiche von Kugelkoordinaten und andere Komprimierungsmethoden zu erfahren. <br><br><h2>  Die Aufgabe, Bitmuster zu erhalten ... und die Geschwindigkeit </h2><br>  Die Methode, die wir betrachten werden, hat einen großen Vorteil - ihre Berechnung ist viel schneller, mehr als doppelt so schnell wie die des nicht optimierten naiven Benchmarks (getestet beim Packen und Entpacken von 10 Millionen zufälligen Vektoren in C ++ in Visual Studio 19 auf Intel Core i5 7. Generation).  Darüber hinaus weist das Verfahren keine Singularität auf, das heißt, jeder gepackte Punkt entspricht im Gegensatz zu den oben erwähnten sphärischen Koordinaten einem einzelnen ungepackten Punkt. <br><br>  Wie bereits erwähnt, gibt es keinen Homöomorphismus zwischen der Einheitskugel und dem Einheitsquadrat. Das heißt, wir können nicht jeden einzelnen Punkt auf dem Quadrat ordnungsgemäß an einen anderen einzelnen Punkt auf der Kugel anhängen.  Aber lassen Sie uns die folgenden Konstruktionen betrachten - bisher wird uns nur die nördliche Hemisphäre beschäftigen, in der es Punkte mit einer positiven oder Nullkoordinate Z gibt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/b7a/709/8a0b7a709482f110e7936fc71187e70d.png"></div><br>  <i>Wir haben die nördliche Hemisphäre in die Scheibe „abgeflacht“ <strong>und dabei die Z-Koordinate jedes Punktes</strong> verworfen (oder ihm den Wert 0 zugewiesen).</i> <br><br>  Wir haben einen Weg gefunden, um jeden Punkt auf der Nordhalbkugel mit jedem Punkt auf einer einzelnen Scheibe zu verbinden.  Einige bemerkenswerte Punkte: <br><br><ul><li>  der Nordpol fällt in (0, 0). </li><li>  Jeder Punkt auf der Halbkugelgrenze bleibt derselbe.  Insbesondere haben die Halbkugel und die Scheibe die gleiche Grenze.  Dies ist logisch, da die Punkte auf der Halbkugelgrenze Z = 0 haben, dh, wenn wir die Z-Koordinate verwerfen, ändern wir nichts. </li></ul><br><h3>  Plattenkomprimierung: eine einfache komplexe Aufgabe </h3><br>  Die folgende Konstruktion erfordert eine kleine Einführung.  Nur für den Fall, ich sage, dass komplexe Zahlen eine Erweiterung des Raums von reellen Zahlen sind (gewöhnliche Zahlen wie 0, 1, 129,43, pi, 335/117, Quadratwurzel 2 usw.), die eine spezielle Zahl verwenden, die <em>ich</em> <em>imaginär</em> nenne <em>Einheit</em> .  Komplexe Zahlen haben die Form <em>a + ib</em> , wobei <em>a</em> und <em>b</em> einige reelle Zahlen (der Real- bzw. der Imaginärteil) sind und <em>i</em> die Eigenschaft i² = -1 hat.  Dies ermöglicht es uns, komplexe Zahlen mit Punkten auf einer 2D-Ebene abzugleichen.  Nehmen wir für <em>z eine</em> komplexe Zahl der Form <em>z = a + ib</em> , so können wir <em>z als</em> Punkt mit Koordinaten ( <em>a</em> , <em>b</em> ) auf der Ebene darstellen.  Die Extraktionsfunktionen des "Realteils" und des "Imaginärteils" der komplexen Zahl <em>z werden</em> mit <em>Re (z)</em> und <em>Im (z) bezeichnet</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c7/3d5/9b2/3c73d59b25bb8db10409e8c763b90154.png"></div><br>  <i>Die komplexe Zahl <em>z</em> und ihre Werte.</i> <br><br>  Neben den Real- und Imaginärteilen der komplexen Zahl können auch die Länge und der Winkel berücksichtigt werden, die sie mit der X-Achse bilden, was als <em>polare Darstellung bezeichnet wird</em> .  Die Polarlänge und der Polarwinkel sind die Norm <em>| z |</em>  und Argument <em>Arg (z)</em> .  Eine bequeme Eigenschaft beider Darstellungen ist, dass die <strong>Addition komplexer Zahlen durch Addition des Real- und Imaginärteils</strong> und die <strong>Multiplikation komplexer Zahlen durch Multiplikation der Normen und Addition der Argumente erfolgt</strong> . <br><br>  Hier interessieren uns zwei Operationen: Quadrieren und Ermitteln der Quadratwurzel einer komplexen Zahl.  Das Quadrieren einer komplexen Zahl entspricht genau den reellen Zahlen: Multiplizieren Sie sie einfach mit sich selbst, indem Sie <strong>die Norm im</strong> Wesentlichen <strong>quadrieren und das Argument verdoppeln</strong> .  Beachten Sie, dass wenn die Norm einer komplexen Zahl kleiner als 1 ist, ihre Länge beim Quadrieren kleiner als 1 bleibt.  Wenn wir also jede komplexe Zahl auf der Platte nehmen, die einen positiven Realteil hat, und sie alle in ein Quadrat setzen, erhalten wir im Wesentlichen die gesamte Platte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cf/7f3/af0/0cf7f3af09328146ee38a26f4e72eddb.png"></div><br>  <i>Auf der linken Seite befinden sich mehrere komplexe Zahlen in der Hälfte der Scheibe mit dem positiven Realteil (X-Koordinate).</i>  <i>Rechts ist das Ergebnis der Quadratur all dieser Punkte.</i>  <i>Die Hälfte der Festplatte füllt jetzt die gesamte Festplatte!</i> <br><br>  Ein Trick ist mit dem „Verdoppeln eines Arguments“ verbunden: Er hängt von der Seite der X-Achse ab, auf der der Punkt liegt.  Die Regel ist unten gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/ed7/ddd/8cced7ddd2e812dd5d4361131a500f95.png"></div><br>  <i>Eine komplexe Zahl mit einem positiven Imaginärteil (Y-Koordinate) dreht sich nach links und eine komplexe Zahl mit einem negativen Imaginärteil (Y-Koordinate) dreht sich nach rechts.</i> <br><br>  Wie bei reellen Zahlen ist die Quadratwurzel die Umkehrung der Quadratur: Für eine gegebene komplexe Zahl <em>z</em> sind die Quadratwurzeln (zwei von ihnen) die Zahlen <em>c</em> , so dass <em>c² = z ist</em> .  Wie im Fall von reellen Zahlen <em>ist</em> auch <em>-c</em> die Quadratwurzel von <em>z</em> , wenn <em>c</em> die Quadratwurzel von <em>z</em> <em>ist</em> .  Die der Zahlen <em>c</em> und <em>-c</em> , deren Argument gleich der Hälfte des Arguments <em>z ist</em> , wird als Hauptwert der Quadratwurzel bezeichnet (dies ist vergleichbar mit der positiven Quadratwurzel einer reellen Zahl anstelle der negativen Quadratwurzel). <br><br>  Wenn Sie verstehen, dass wenn eine komplexe Zahl quadriert wird, ihre Norm quadriert wird und sich ihr Argument verdoppelt, können Sie leicht erraten, dass der Hauptwert der Quadratwurzel die Quadratwurzel aus der Norm entnimmt und das Argument halbiert (gemäß der oben gezeigten Regel, wobei die Pfeile jedoch auf den Kopf gestellt sind). .  Wie beim Quadrieren bleibt die Norm kleiner als 1, wenn die Quadratwurzel einer komplexen Zahl mit einer Norm von weniger als 1 gezogen wird.  Daher wird die Einheitsplatte in ihre halbpositiven reellen Zahlen "komprimiert". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51f/7cc/5f0/51f7cc5f0b9616d7f82f09a29e3c14c7.png"></div><br>  <i>Links befinden sich mehrere Punkte auf einer einzelnen Platte.</i>  <i>Die rechte Seite zeigt das Ergebnis der Quadratwurzelung aller dieser Punkte.</i>  <i>Die ganze Scheibe passt jetzt in die Hälfte von sich!</i> <br><br>  Dies ist die Grundlage des Algorithmus: Tatsächlich komprimieren wir die gesamte Einheitsscheibe mit dem positiven Realteil zur Hälfte.  Wie Sie sich erinnern, haben wir kürzlich die obere Hälfte einer Kugel zu einer einzigen Scheibe abgeflacht.  Nun lohnt es sich zu sehen, was wir damit machen werden. <br><br><h3>  Alles zusammen </h3><br>  Lassen Sie uns zusammenfassen, was wir gerade getan haben: Wir haben die Hälfte der Kugel zu einer Einheitsscheibe abgeflacht, die Z-Koordinate aller ihrer Punkte verworfen und die Einheitsscheibe mit dem positiven Realteil unter Verwendung des komplexen Quadratwurzel-Hauptwerts in ihre eigene Hälfte gequetscht.  Tatsächlich haben wir die halbe Kugel auf die halbe Scheibe abgeflacht!  Jetzt können wir mit ein paar Änderungen dasselbe tun, um die verbleibende Hälfte der Kugel in die verbleibende Hälfte der Scheibe zu komprimieren. <br><br>  Die untere Hälfte der Kugel (alle Punkte der Kugel mit einer negativen Z-Koordinate) wird ebenfalls durch wiederholtes Ablegen der Z-Koordinaten zu einer Einheitsscheibe abgeflacht. Für alle komplexen Zahlen <em>z</em> in der Scheibe nehmen wir jedoch den Wert entgegengesetzt zur Hauptquadratwurzel von <em>z</em> (d. H. Wir nehmen <em>-c</em> anstelle von <em>c)</em> )  Da der Hauptwert der Quadratwurzel immer einen positiven Realteil hat, hat der entgegengesetzte Wert immer einen negativen Realteil;  Tatsächlich haben wir die verbleibende Hälfte der Kugel in die verbleibende Hälfte der Scheibe abgeflacht, und die Komprimierungsstufe ist nun abgeschlossen! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/910/fcb/d9f/910fcbd9f721b1ceea2de3b3a56bcb2c.png"></div><br>  <i>Voller Komprimierungsschritt.</i>  <i>Beachten Sie, dass die nördliche und die südliche Hemisphäre (blau und orange) zu zwei Kopien einer einzelnen Platte abgeflacht und dann zu zwei Hälften einer einzelnen Platte komprimiert werden.</i> <br><br>  Der Komprimierungsalgorithmus lautet wie folgt: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">packUnitVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unit)</span></span></span><span class="hljs-function"> disk </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Complex(unit.x, unit.y) packed = principalSquareRoot(disk) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unit.z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? -packed : packed</code> </pre> <br>  Und so haben wir in nur drei Zeilen Pseudocode die gesamte Theorie angewendet, die wir untersucht haben, um einen effektiven Algorithmus zu erstellen.  Wenn Ihre Umgebung keine Formel für den Hauptwert der Quadratwurzel hat, finden Sie diese <a href="https://en.wikipedia.org/wiki/Square_root" rel="noopener">auf Wikipedia</a> (besondere Aufmerksamkeit sollte der Auswahl des Vorzeichens des Imaginärteils gewidmet werden).  Hier ist die Referenz-C ++ - Implementierung, die ich in meinem Code verwende: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Principal complex square root of 'x + iy' float2 csqrt(float x, float y) { float r = sqrt(x * x + y * y); return float2(sqrt((r + x) / 2), (y &lt; 0 ? -1 : 1) * sqrt((r - x) / 2)); }</span></span></code> </pre> <br><h3>  Komm zurück </h3><br>  Wir haben die Komprimierung gemeistert und fahren nun mit dem Auspacken fort. <br><br>  Das Auspacken erfolgt in umgekehrter Reihenfolge aller Komprimierungsschritte: <br><br><ul><li>  Wir erweitern sowohl die positive als auch die negative Hälfte der materiellen Teile einer einzelnen Scheibe in zwei volle Scheiben </li><li>  Ordnen Sie jeder vollen Scheibe die entsprechende Halbkugel zu </li></ul><br>  Kurz gesagt, wir beginnen mit dem gepackten Wert von <em>p</em> , quadrieren ihn, um zu dem Punkt auf der Scheibe zurückzukehren, der von einer der Hemisphären erhalten wurde, und verwenden dann das Zeichen <em>Re (p)</em> , um herauszufinden, von welcher Hemisphäre der Punkt auf der Scheibe stammt.  Mit der Gleichung <em>x² + y² + z² = 1</em> , die die Punkte auf der Einheitskugel definiert, können wir die fehlende Z-Koordinate des gepackten Punktes <em>nachbilden</em> . <br><br>  Es ist zu beachten, dass die Berechnung des Quadrats des gepackten Werts immer den richtigen Punkt der Scheibe ergibt, unabhängig von ihrer anfänglichen Halbkugel (obere oder untere), da <em>z² =</em> <em>(-z) ²</em> . <br><br>  Der Dekomprimierungsalgorithmus lautet wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackUnitVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packed)</span></span></span><span class="hljs-function">: disk </span></span>= packed * packed unit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vec3() unit.x = disk.real() unit.y = disk.imag() unit.z = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> - unit.x * unit.x - unit.y * unit.y) * (packed.real() &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unit</code> </pre> <br>  Und so haben wir einen Algorithmus erhalten, der sehr effizient eine 2D-Darstellung einzelner 3D-Vektoren erstellt, die im Gegensatz zu sphärischen Koordinaten keine Bitmuster verliert und keine Singularität aufweist.  Wenn Sie einige Optimierungstricks nicht berücksichtigen, um die Berechnungen zu beschleunigen, ist dies eine fast fertige Version des Algorithmus. <br><br>  … oder nicht?  Wenn Sie genau hinschauten, bemerkten Sie, dass hier etwas nicht stimmt.  Ich sagte, dass die Kugel und das Einheitsquadrat nicht homöomorph sind und dennoch irgendwie einen eindeutigen Punkt auf der Scheibe an jeden eindeutigen Punkt auf der Kugel binden konnten?  Darüber hinaus haben wir keine nicht-klassische Mathematik erwähnt. Was passiert also? <br><br>  Tatsächlich hat unser Algorithmus einen schwerwiegenden Nachteil: Er funktioniert für jeden Punkt in der gesamten Kugel, mit Ausnahme von Punkten auf der Nordhalbkugel mit Y = 0 und X &lt;= 0, die beim Packen und Entpacken fälschlicherweise mit dem entsprechenden Punkt auf der Nordhalbkugel verglichen werden. <br><br>  Der Grund dafür ist, dass, wenn ihre Koordinaten Z verworfen werden, die entsprechende komplexe Zahl eine negative reelle Zahl ist und keinen Imaginärteil hat.  Wenn wir den Hauptwert der Quadratwurzel einer negativen reellen Zahl nehmen, erhalten wir wiederum eine vollständig imaginäre komplexe Zahl, die keinen reellen Teil hat (dies ähnelt der Tatsache, dass der Hauptwert der Quadratwurzel von -1 gleich <em>i ist</em> ).  Dann versuchen wir, das Vorzeichen der Z-Koordinate im Wesentlichen auf Null zu halten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6bc/720/d08/6bc720d085469f478453dc4c961e2036.png"></div><br>  <i>Problemstreifen.</i>  <i>Punkte mit Y = 0 und X &lt;= 0 werden in eine Reihe rein imaginärer Zahlen mit undefinierbaren Realteilen gepackt.</i> <br><br>  Mal sehen, was passiert, wenn wir zwei solche Punkte packen (nicht vergessen, dass x &lt;= 0 ist). <br><br><blockquote><pre>  |  Nordpunkt |  South Point
  Einheit |  (x, 0, z) |  (x, 0, -z)
  Datenträger |  x + 0i |  x + 0i
 verpackt |  0 + √ (-x) i |  -0 - √ (-x) i </pre></blockquote><br>  Da der Imaginärteil der Projektion beider Punkte auf die Scheibe gleich Null ist, können wir das Vorzeichen der Z-Koordinate nicht im Vorzeichen des Realteils des Hauptwerts der Quadratwurzel speichern, da es selbst gleich Null ist.  Wir können einfach darüber nachdenken und akzeptieren, dass der Algorithmus für diese Punkte nicht funktioniert - oder wir können weitermachen. <br><br><h2>  Vergiss was wir gelernt haben </h2><br>  In allen mir bekannten Bereichen und Zweigen der Mathematik wird angenommen, dass 0 = -0 ist.  Dies folgt aus der Definition von <em>-a</em> , die das Gegenteil von <em>a ist</em> und besagt, dass <em>"-a die einzige Zahl ist, die 0 ergibt, wenn sie mit a summiert wird"</em> .  Da 0 auch in Bezug auf Addition ein Nullelement ist ( <em>0 + a = a + 0 = a</em> ), müssen Sie nur 0 zu 0 hinzufügen, um 0 zu erhalten, und zwar 0 selbst. <br><br>  In der Softwareentwicklung ist jedoch alles anders.  In den meisten Darstellungen von Gleitkommazahlen wird zusammen mit dem Exponenten und der Mantisse ein zusätzliches Bit zum Speichern des Zeichens verwendet.  Das heißt, wenn der Exponent und die Mantisse 0 sind, kann das Vorzeichenbit verwendet werden, um zwischen positiven und negativen Nullen zu unterscheiden.  In den meisten Programmiersprachen (wenn nicht allen) werden beide Nullen als eine einzige Null behandelt (versuchen Sie es einfach mit <em>0 == -0</em> ), aber es gibt einen Unterschied. Dies kann festgestellt werden, wenn Sie versuchen, „-0“ und „0“ an das Terminal auszugeben "- so werden sie abgeleitet. <br><br>  Dies ist sehr wichtig für uns: Der Wert Null kann tatsächlich zum Speichern von Informationen über das Zeichen verwendet werden!  Tatsächlich wird es trotzdem korrekt gespeichert.  in unserem Fall ist das Problem, dass es nicht richtig gelesen wird.  Wenn wir uns die vorletzte Zeile im Entpack-Algorithmus ansehen, werden wir Folgendes sehen: <br><br><pre> <code class="cpp hljs">packed.real() &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Diese Operation liest das Vorzeichen des Realteils des gepackten Werts, um zu bestimmen, zu welcher Hemisphäre der Punkt gehört - Norden oder Süden.  Wenn <em>packet.real ()</em> jedoch 0 oder -0 ist, wird das Zeichen vom Vergleichsoperator ignoriert und der ternäre Operator gibt immer 1 zurück. Die richtige Art, das Zeichen zu lesen, ist eine <em>echte</em> Anfrage nach dem Status des Vorzeichenbits, z. B. mit <em>std :: signbit</em> von C ++ oder <em>np .signbit</em> von Numpy nach Python - die Funktion ist sprachabhängig.  Denken Sie daran, dass das Vorzeichenbit 1 ist, wenn die Zahl negativ ist, und 0, wenn die Zahl positiv ist. <br><br>  So erhalten wir eine korrigierte und hundertprozentig funktionierende Funktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackUnitVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packed)</span></span></span><span class="hljs-function">: disk </span></span>= packed * packed unit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vec3() unit.x = disk.real() unit.y = disk.imag() unit.z = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> - unit.x * unit.x - unit.y * unit.y) * (signbit(packed.real()) ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unit</code> </pre> <br>  Das ist alles!  Damit ist der Algorithmus abgeschlossen.  Nicht-klassische Mathematik äußert sich in der Tatsache, dass wir die Tatsache verwenden, dass 0 von -0 abweicht, was für alle Bereiche der Mathematik, die ich kenne, falsch ist.  Es gibt jedoch eine Möglichkeit, diese Fremdartigkeit in einem theoretischen, mathematisch strengen Sinn logisch zu machen. <br><br><h2>  Räume, die sich nicht an die Regeln halten: eine gerade Linie mit zwei Ursprungspunkten </h2><br>  Um das Folgende besser zu verstehen, sollten Sie die Konzepte von Äquivalenzklassen und Nachbarschaften kennen.  Dies ist optional, wird aber klarer. <br><br>  Wir können die Konsistenz dieser Kuriosität mit einem "Vorzeichen Null" sicherstellen, beginnend mit einem interessanten topologischen Raum: einer geraden Linie mit zwei Ursprungspunkten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7df/bdc/b66/7dfbdcb665e09552d349b0fb6d606f52.png"></div><br>  <i>Eine gerade Linie mit zwei Ursprungspunkten ist eine gewöhnliche reale numerische Achse, die für sich selbst irgendwie um eine zusätzliche 0 gewachsen ist.</i> <br><br>  Eine gerade Linie mit zwei Ursprungspunkten ergibt sich, wenn wir zwei reelle numerische Achsen nehmen und jede Zahl mit Ausnahme von 0 mit dem Gegenteil verbinden. Formal ist eine gerade Linie mit zwei Ursprungspunkten ein Quotientenraum R² mit einer Äquivalenzbeziehung, die zwei Zahlen identifiziert, wenn sie gleich <em>und sind</em> sind nicht 0. Das Ergebnis ist eine gerade Linie von reellen Zahlen mit zwei unterschiedlichen Nullen, die von jedem Punkt gleich weit entfernt sind, sich aber gleichzeitig voneinander unterscheiden.  Formal haben zwei beliebige Nachbarschaften jeder der Nullen immer einen nicht leeren Schnittpunkt. <br><br>  Wir können dies erweitern und versuchen, das in diesem Artikel verwendete "disk-like" -Objekt zu definieren.  Früher haben wir das Vorzeichen der Z-Koordinate des Punktes im Realteil der Hauptquadratwurzel seiner Projektion auf die komplexe Scheibe gewaltsam beibehalten, auch wenn dieser Realteil 0 ist. Dies bedeutet, dass wir keine komplexen Zahlen verwendet haben, sondern ein ähnliches Konzept: eine komplexe Zahl, Der Imaginärteil ist eine reelle Zahl, und der Realteil ist ein Punkt auf einer Linie mit zwei Ursprungspunkten, sodass wir den Realteil gleich +0 und -0 unterscheiden können.  Tatsächlich verwenden wir <strong>komplexe Zahlen mit zwei Ursprungspunkten!</strong> <br><br>  Tatsächlich fanden wir keine Bijektion (Eins-zu-Eins-Zuordnung) zwischen der Kugel und der Einheitsscheibe, sondern eine Bijektion zwischen der Kugel und der Einheitsscheibe mit zwei Ursprungspunkten.  Ich habe nicht geprüft, ob diese Bijektion ein Homöomorphismus ist (ein Homöomorphismus ist eine in beide Richtungen fortlaufende Bijektion), aber vielleicht werde ich es eines Tages tun. <br><br><h3>  Ein bisschen Topologie am Ende </h3><br>  Abschließend möchte ich betonen, dass die komplexe Ebene, die wir mit zwei Ursprungspunkten verwendet haben, zwar nicht aus derselben Konstruktion wie die gerade Linie mit zwei Ursprungspunkten folgt, dass sie jedoch einer anderen komplexen Ebene mit zwei Ursprungspunkten entspricht, die ähnlich konstruiert ist wie eine gerade Linie mit zwei herkunft. <br><br>  Im Fall einer geraden Linie mit zwei Ursprungspunkten haben wir an allen Stellen außer 0 zwei Kopien der reellen numerischen Achse geklebt. Wir können dasselbe mit zwei Kopien der komplexen Ebene tun, indem wir jedes Paar gleicher komplexer Zahlen, die nicht 0 sind, zusammenkleben und auf ähnliche Weise komplex werden eine Ebene mit zwei Ursprungspunkten.  Diese Konstruktion unterscheidet sich von der Konstruktion einer neuen komplexen Ebene aus einer geraden Linie mit zwei Ursprungspunkten und einer gewöhnlichen reellen numerischen Achse: Die erstere ist ein Faktorraum, und die letztere ist ein Produkt von Räumen.  Der einzige Unterschied zwischen den beiden resultierenden Räumen besteht jedoch darin, wie in jedem Raum unterschiedliche Nullen geschrieben werden: Im ersten Fall werden sie als ( <em>0 + 0i) a</em> und ( <em>0 + 0i) b gezählt</em> (zwei Nullen aus zwei nicht zusammengeklebten Räumen). und in letzterem werden sie als <em>(0a + 0i)</em> und <em>(0b + 0i</em> <em>)</em> gelesen.  Tatsächlich sind beide Räume homöomorph, sodass Sie einen sicher dort verwenden können, wo der andere benötigt wird. <br><br><h2>  Fazit </h2><br>  Ich hoffe, Sie haben diesen Ausflug in die Welt der bizarren und obskuren Mathematik genossen.  Ich betone noch einmal die Tatsache, dass sich dieser Algorithmus streng genommen schlechter verhält als der <em>Oct-</em> Algorithmus aus dem eingangs erwähnten Artikel.  Obwohl es in der Ausführungszeit kurz oder sogar schneller ist, ist seine Punkteverteilung auf der Kugel bei weitem nicht so gut.  Ich habe damals diesen Artikel geschrieben, um zu zeigen, wie eine scheinbar fremde Mathematik, ähnlich wie abstrakter Unsinn, tatsächlich eine sehr interessante Anwendung in der realen Welt haben kann.  außerdem finde ich diesen abstrakten Quatsch entzückend.  Ich hoffe, Sie haben aus dem Artikel etwas Nützliches gelernt, danke fürs Lesen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482348/">https://habr.com/ru/post/de482348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482332/index.html">Wie ein Enthusiast unter DOS ein Wi-Fi-Netzwerk aufbaute</a></li>
<li><a href="../de482336/index.html">Händler haben Zugang zu Pressekonferenzen der Central Bank of England, bevor diese öffentlich ausgestrahlt werden</a></li>
<li><a href="../de482338/index.html">Visual Studio für Mac: Steuern Sie Ihre IDE mit Schlüsseln</a></li>
<li><a href="../de482340/index.html">Von Junior'a nach Middle'a: Parser</a></li>
<li><a href="../de482344/index.html">Machen Sie sich bereit für die Einführung eines Social Ratings in Russland</a></li>
<li><a href="../de482352/index.html">Als ich fast 150k in den Wind warf oder die Geschichte der Installation von Fremdbelüftung in der Wohnung</a></li>
<li><a href="../de482354/index.html">ConfigureAwait: Häufig gestellte Fragen</a></li>
<li><a href="../de482356/index.html">Verwenden von Windows Server ohne Explorer aus der Sicht eines normalen Windows-Benutzers</a></li>
<li><a href="../de482358/index.html">Wie Panik in Rust wirkt</a></li>
<li><a href="../de482360/index.html">Habra-Detektiv: Sie sind mit UFOs befreundet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>