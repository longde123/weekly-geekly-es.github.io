<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèΩ üèÇüèæ ‚úãüèª Topologie und umfassende Analyse f√ºr einen ahnungslosen Spieleentwickler: Komprimieren einzelner 3D-Vektoren üö∂üèΩ üë©üèø‚Äç‚öïÔ∏è ü•ê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie Sie bereits aus meinen vorherigen Artikeln wissen, m√∂chte ich die Spieleentwicklung als Ausrede verwenden, um komplexe Mathematik zu demonstrieren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Topologie und umfassende Analyse f√ºr einen ahnungslosen Spieleentwickler: Komprimieren einzelner 3D-Vektoren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482348/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/910/fcb/d9f/910fcbd9f721b1ceea2de3b3a56bcb2c.png" alt="Bild"></div><br>  Wie Sie bereits aus meinen vorherigen Artikeln wissen, m√∂chte ich die Spieleentwicklung als Ausrede verwenden, um komplexe Mathematik zu demonstrieren, f√ºr die die meisten Menschen sonst keinen Nutzen h√§tten.  Und dieser Artikel ist keine Ausnahme!  Ich m√∂chte eine sehr coole Technik zeigen, die den f√ºr mich interessanten Punkten entspricht: <br><br><ul><li>  Der Prozess ist klar genug </li><li>  es ist viel schneller als die √ºbliche Technik, die die gleiche Aufgabe ausf√ºhrt </li><li>  Es verwendet eine sehr ungew√∂hnliche Eigenschaft, Gleitkommazahlen im Gleitkommaformat darzustellen, was impliziert, dass ... </li><li>  <strong>es funktioniert nicht in der klassischen Analyse</strong> .  Damit dieser Algorithmus theoretisch funktioniert, m√ºssen Sie in die wunderbare Welt der nicht-klassischen Mathematik eintauchen!  Und wenn dies Ihre Neugier nicht geweckt hat, wei√ü ich nicht, was ich sonst tun soll. </li></ul><br>  Dieser Artikel ist ziemlich lang und theoretisch, da er ein gr√ºndliches Studium der Erkl√§rungen erfordert. Nehmen Sie sich also Zeit und lesen Sie die Teile noch einmal durch, von denen Sie dachten, dass sie beim ersten Mal nicht so offensichtlich waren. <br><br><h2>  Ein bisschen √ºber den Kontext (GPU) </h2><br>  Einer der wichtigen Aspekte, auf die Sie bei der Entwicklung von Spielen und im weiteren Sinne - in jedem Bereich mit aktivem Grafikeinsatz - achten sollten, ist die Bandbreite der GPU.  Der Zentralprozessor und die GPU sind separate physische Ger√§te und m√ºssen synchronisiert werden, um Daten auszutauschen.  Wenn Sie bereits eine Parallelverarbeitung durchgef√ºhrt haben, bedeutet dies einen erheblichen Zeitverlust, wenn zwei Ger√§te synchronisiert werden m√ºssen.  Das Zusammenspiel von CPU und GPU ist in dieser Hinsicht nicht anders. Daher bem√ºhen wir uns, die Daten√ºbertragung sowohl hinsichtlich der Anzahl der Vorg√§nge als auch der √ºbertragenen Datenmenge so gering wie m√∂glich zu halten. <br><a name="habracut"></a><br>  Die Minimierung der Anzahl der Daten√ºbertragungsvorg√§nge erfolgt normalerweise durch Puffern: Wir bem√ºhen uns, alle Daten in die kleinstm√∂gliche Anzahl von Arrays zu packen und dann alles auf einmal zu √ºbertragen, damit wir uns nicht mehr darum k√ºmmern m√ºssen.  Die Minimierung der Datenmenge bei √úbertragungsvorg√§ngen ist ein v√∂llig anderes Thema, und die L√∂sungen f√ºr dieses Problem sind fast immer individuell.  Als extremes Beispiel hierf√ºr k√∂nnen Sie sehen, <a href="http://advances.realtimerendering.com/s2013/Tatarchuk-Destiny-SIGGRAPH2013.pdf">wie die Destiny-Rendering-Engine die Position, Oberfl√§chennormalen, Material-Flags und 96-Bit-BSDF-Parameter mit vollst√§ndiger Anisotropie anpasst, d. H.</a>  <a href="http://advances.realtimerendering.com/s2013/Tatarchuk-Destiny-SIGGRAPH2013.pdf">drei Gleitkommazahlen</a> (ab S. 62).  Gute Ergebnisse lassen sich jedoch mit allgemeinen Methoden erzielen, denen dann individuelle Optimierungsl√∂sungen hinzugef√ºgt werden. <br><br>  Heute werden wir die <strong>verlustfreie Komprimierung einzelner 3D-Vektoren</strong> diskutieren.  Dieser Satz enth√§lt mehrere Schl√ºsselw√∂rter: <br><br><ul><li>  <strong>Einzelne 3D-Vektoren</strong> : 3D-Vektoren mit einer L√§nge von 1 </li><li>  <strong>verlustfreie Komprimierung</strong> : Verkleinern Sie die Beschreibungen einzelner 3D-Vektoren ohne Genauigkeitsverlust.  Dies ist das Gegenteil von <em>verlustbehafteter Komprimierung.</em> </li><li>  <strong>Separat</strong> : Die Vektorcodierung und -decodierung wird ohne Informationen √ºber die Nachbarn durchgef√ºhrt.  Wenn die Situation umgekehrt w√§re, k√∂nnte es sich um eine Art <em>Stapelkomprimierung handeln</em> , bei der nicht einzelne Vektoren komprimiert werden, sondern deren Arrays </li></ul><br>  Bevor ich fortfahre, muss ich den hervorragenden Artikel <a href="http://jcgt.org/published/0003/02/01/" rel="noopener"><em>‚ÄûEine √úbersicht √ºber effiziente Darstellungen f√ºr unabh√§ngige Einheitsvektoren</em> <em>‚Äú</em></a> von Cigolle, Donow, Evangelakos, Mara, McGuire und Meyer erw√§hnen, von dem ich mich f√ºr meinen Beitrag inspirieren lie√ü.  Ich muss <strong><em>sofort</em></strong> sagen <strong><em>,</em></strong> dass der <strong>Algorithmus, √ºber den ich sprechen werde, weniger effizient ist als der im Artikel vorgestellte <em>Okt.-</em> Algorithmus</strong> .  Wenn Sie maximale Effizienz w√ºnschen, lesen Sie den Artikel und verwenden Sie <em>oct</em> .  Der Zweck meines Beitrags ist es, die Sch√∂nheit der Verwendung sehr ungew√∂hnlicher Mathematik zu demonstrieren und gleichzeitig, wie wir sp√§ter sehen werden, einen sehr praktischen Algorithmus zu erstellen. <br><br><h2>  Topologie direkt in Ihrem Videospiel </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/a95/4bc/41ca954bca54597431a9a0ebb7a9fe97.png"></div><br>  <i>Im Fall der Einheitskugel sind nur Œ∏ und œÜ wichtig, da œÅ immer 1 ist und daher redundant ist.</i> <br><br>  Ausgangspunkt des Algorithmus ist die Beobachtung, dass Einheits-3D-Vektoren Punkten auf einer Kugel entsprechen.  Wie Sie wahrscheinlich wissen, ist eine Kugel eine zweidimensionale Oberfl√§che, dh f√ºr die eindeutige Identifizierung von Punkten auf einer Kugel sind nur zwei Koordinaten erforderlich.  Ein sehr verbreitetes Beispiel hierf√ºr sind Kugelkoordinaten, bei denen ein Punkt auf der Kugel durch zwei Winkel Œ∏ und œÜ definiert ist. <br><br>  Interessanterweise ist eine ziemlich unangenehme Eigenschaft, dass obwohl die Kugel und das gef√ºllte Quadrat (ein m√∂glicher Raum f√ºr 2D-Koordinaten) 2D-Objekte sind, es tats√§chlich keine Korrespondenz zwischen ihnen gibt.  Dies bedeutet, dass es keine M√∂glichkeit gibt, jedem einzelnen Punkt des Quadrats einen eindeutigen Punkt auf der Kugel zuzuordnen (zumindest in kontinuierlicher Weise).  Man sagt, dass sie <em>nicht hom√∂omorph sind</em> (mit anderen Worten, einer hat eine Grenze und der andere nicht).  Ein unangenehmes Ergebnis davon ist, dass einige 2D-Koordinaten in dem Sinne verloren gehen, dass verschiedene Koordinaten identischen Punkten auf der Kugel entsprechen (im Fall von sph√§rischen Koordinaten, wenn œÜ 0 ist, ist der entsprechende Punkt unabh√§ngig von der Koordinate Œ∏ der Nordpol).  Bei der Komprimierung verlieren wir wertvolle Bitmuster, mit denen wir die Punkte einer Kugel beschreiben k√∂nnen! <br><br>  Wenn Sie mehr Mathematik wollen und beweisen m√∂chten, dass das Quadrat und die Kugel nicht hom√∂omorph sind, k√∂nnen Sie die Tatsache nutzen, dass die Kugel im Gegensatz zum Quadrat nicht kontrahierbar ist und die Kontrahierbarkeit eine topologische Eigenschaft ist.  Der Borsuk-Ulam-Satz kann auch als Beweis verwendet werden.  Sie sagten mir auch, dass Homotopie-Gruppen beim Beweis helfen k√∂nnen, aber dies liegt bereits au√üerhalb meines Fachgebiets. <br><br>  Dieses Problem tritt jedoch nicht nur bei sph√§rischen Koordinaten auf;  Darunter leidet jede kontinuierliche 2D-Darstellung der Punkte der Kugel.  Denken Sie jedoch f√ºr die Zukunft daran. <br><br>  Sph√§rische Koordinaten haben auch andere schlechte Eigenschaften: <br><br><ul><li>  Sie haben eine schlechte Verteilung √ºber die Kugel.  Wenn zuf√§llige sph√§rische Koordinaten generiert und zur√ºck in 3D-Punkte konvertiert werden, bilden sie Cluster um die Pole und sind in der N√§he des √Ñquators ziemlich d√ºnn.  Dies ist auf die Tatsache zur√ºckzuf√ºhren, dass 3D-Vektoren in der N√§he des √Ñquators weniger genau unterscheidbar sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87c/e1d/15a/87ce1d15ad314b007f0093b83a738538.png"></div><br>  <i>Verteilung auf einer Kugel von 10.000 gleichm√§√üig verteilten Kugelkoordinaten</i> </li><li>  Ihre Verpackung und ihr Auspacken sind kostspielig.  F√ºr das Packen (3D ‚Üí 2D) werden eine Operation <em>acos</em> und eine <em>atan2</em> ben√∂tigt, was ziemlich kostspielige inverse trigonometrische Funktionen sind, und f√ºr das Auspacken (2D ‚Üí 3D) werden zwei Operationen <em>cos</em> und zwei Operationen <em>sin ben√∂tigt</em> , die ebenfalls bei weitem nicht wirtschaftlich sind. </li></ul><br>  Lesen Sie den obigen Artikel, um mehr √ºber andere Vergleiche von Kugelkoordinaten und andere Komprimierungsmethoden zu erfahren. <br><br><h2>  Die Aufgabe, Bitmuster zu erhalten ... und die Geschwindigkeit </h2><br>  Die Methode, die wir betrachten werden, hat einen gro√üen Vorteil - ihre Berechnung ist viel schneller, mehr als doppelt so schnell wie die des nicht optimierten naiven Benchmarks (getestet beim Packen und Entpacken von 10 Millionen zuf√§lligen Vektoren in C ++ in Visual Studio 19 auf Intel Core i5 7. Generation).  Dar√ºber hinaus weist das Verfahren keine Singularit√§t auf, das hei√üt, jeder gepackte Punkt entspricht im Gegensatz zu den oben erw√§hnten sph√§rischen Koordinaten einem einzelnen ungepackten Punkt. <br><br>  Wie bereits erw√§hnt, gibt es keinen Hom√∂omorphismus zwischen der Einheitskugel und dem Einheitsquadrat. Das hei√üt, wir k√∂nnen nicht jeden einzelnen Punkt auf dem Quadrat ordnungsgem√§√ü an einen anderen einzelnen Punkt auf der Kugel anh√§ngen.  Aber lassen Sie uns die folgenden Konstruktionen betrachten - bisher wird uns nur die n√∂rdliche Hemisph√§re besch√§ftigen, in der es Punkte mit einer positiven oder Nullkoordinate Z gibt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/b7a/709/8a0b7a709482f110e7936fc71187e70d.png"></div><br>  <i>Wir haben die n√∂rdliche Hemisph√§re in die Scheibe ‚Äûabgeflacht‚Äú <strong>und dabei die Z-Koordinate jedes Punktes</strong> verworfen (oder ihm den Wert 0 zugewiesen).</i> <br><br>  Wir haben einen Weg gefunden, um jeden Punkt auf der Nordhalbkugel mit jedem Punkt auf einer einzelnen Scheibe zu verbinden.  Einige bemerkenswerte Punkte: <br><br><ul><li>  der Nordpol f√§llt in (0, 0). </li><li>  Jeder Punkt auf der Halbkugelgrenze bleibt derselbe.  Insbesondere haben die Halbkugel und die Scheibe die gleiche Grenze.  Dies ist logisch, da die Punkte auf der Halbkugelgrenze Z = 0 haben, dh, wenn wir die Z-Koordinate verwerfen, √§ndern wir nichts. </li></ul><br><h3>  Plattenkomprimierung: eine einfache komplexe Aufgabe </h3><br>  Die folgende Konstruktion erfordert eine kleine Einf√ºhrung.  Nur f√ºr den Fall, ich sage, dass komplexe Zahlen eine Erweiterung des Raums von reellen Zahlen sind (gew√∂hnliche Zahlen wie 0, 1, 129,43, pi, 335/117, Quadratwurzel 2 usw.), die eine spezielle Zahl verwenden, die <em>ich</em> <em>imagin√§r</em> nenne <em>Einheit</em> .  Komplexe Zahlen haben die Form <em>a + ib</em> , wobei <em>a</em> und <em>b</em> einige reelle Zahlen (der Real- bzw. der Imagin√§rteil) sind und <em>i</em> die Eigenschaft i¬≤ = -1 hat.  Dies erm√∂glicht es uns, komplexe Zahlen mit Punkten auf einer 2D-Ebene abzugleichen.  Nehmen wir f√ºr <em>z eine</em> komplexe Zahl der Form <em>z = a + ib</em> , so k√∂nnen wir <em>z als</em> Punkt mit Koordinaten ( <em>a</em> , <em>b</em> ) auf der Ebene darstellen.  Die Extraktionsfunktionen des "Realteils" und des "Imagin√§rteils" der komplexen Zahl <em>z werden</em> mit <em>Re (z)</em> und <em>Im (z) bezeichnet</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c7/3d5/9b2/3c73d59b25bb8db10409e8c763b90154.png"></div><br>  <i>Die komplexe Zahl <em>z</em> und ihre Werte.</i> <br><br>  Neben den Real- und Imagin√§rteilen der komplexen Zahl k√∂nnen auch die L√§nge und der Winkel ber√ºcksichtigt werden, die sie mit der X-Achse bilden, was als <em>polare Darstellung bezeichnet wird</em> .  Die Polarl√§nge und der Polarwinkel sind die Norm <em>| z |</em>  und Argument <em>Arg (z)</em> .  Eine bequeme Eigenschaft beider Darstellungen ist, dass die <strong>Addition komplexer Zahlen durch Addition des Real- und Imagin√§rteils</strong> und die <strong>Multiplikation komplexer Zahlen durch Multiplikation der Normen und Addition der Argumente erfolgt</strong> . <br><br>  Hier interessieren uns zwei Operationen: Quadrieren und Ermitteln der Quadratwurzel einer komplexen Zahl.  Das Quadrieren einer komplexen Zahl entspricht genau den reellen Zahlen: Multiplizieren Sie sie einfach mit sich selbst, indem Sie <strong>die Norm im</strong> Wesentlichen <strong>quadrieren und das Argument verdoppeln</strong> .  Beachten Sie, dass wenn die Norm einer komplexen Zahl kleiner als 1 ist, ihre L√§nge beim Quadrieren kleiner als 1 bleibt.  Wenn wir also jede komplexe Zahl auf der Platte nehmen, die einen positiven Realteil hat, und sie alle in ein Quadrat setzen, erhalten wir im Wesentlichen die gesamte Platte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cf/7f3/af0/0cf7f3af09328146ee38a26f4e72eddb.png"></div><br>  <i>Auf der linken Seite befinden sich mehrere komplexe Zahlen in der H√§lfte der Scheibe mit dem positiven Realteil (X-Koordinate).</i>  <i>Rechts ist das Ergebnis der Quadratur all dieser Punkte.</i>  <i>Die H√§lfte der Festplatte f√ºllt jetzt die gesamte Festplatte!</i> <br><br>  Ein Trick ist mit dem ‚ÄûVerdoppeln eines Arguments‚Äú verbunden: Er h√§ngt von der Seite der X-Achse ab, auf der der Punkt liegt.  Die Regel ist unten gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/ed7/ddd/8cced7ddd2e812dd5d4361131a500f95.png"></div><br>  <i>Eine komplexe Zahl mit einem positiven Imagin√§rteil (Y-Koordinate) dreht sich nach links und eine komplexe Zahl mit einem negativen Imagin√§rteil (Y-Koordinate) dreht sich nach rechts.</i> <br><br>  Wie bei reellen Zahlen ist die Quadratwurzel die Umkehrung der Quadratur: F√ºr eine gegebene komplexe Zahl <em>z</em> sind die Quadratwurzeln (zwei von ihnen) die Zahlen <em>c</em> , so dass <em>c¬≤ = z ist</em> .  Wie im Fall von reellen Zahlen <em>ist</em> auch <em>-c</em> die Quadratwurzel von <em>z</em> , wenn <em>c</em> die Quadratwurzel von <em>z</em> <em>ist</em> .  Die der Zahlen <em>c</em> und <em>-c</em> , deren Argument gleich der H√§lfte des Arguments <em>z ist</em> , wird als Hauptwert der Quadratwurzel bezeichnet (dies ist vergleichbar mit der positiven Quadratwurzel einer reellen Zahl anstelle der negativen Quadratwurzel). <br><br>  Wenn Sie verstehen, dass wenn eine komplexe Zahl quadriert wird, ihre Norm quadriert wird und sich ihr Argument verdoppelt, k√∂nnen Sie leicht erraten, dass der Hauptwert der Quadratwurzel die Quadratwurzel aus der Norm entnimmt und das Argument halbiert (gem√§√ü der oben gezeigten Regel, wobei die Pfeile jedoch auf den Kopf gestellt sind). .  Wie beim Quadrieren bleibt die Norm kleiner als 1, wenn die Quadratwurzel einer komplexen Zahl mit einer Norm von weniger als 1 gezogen wird.  Daher wird die Einheitsplatte in ihre halbpositiven reellen Zahlen "komprimiert". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51f/7cc/5f0/51f7cc5f0b9616d7f82f09a29e3c14c7.png"></div><br>  <i>Links befinden sich mehrere Punkte auf einer einzelnen Platte.</i>  <i>Die rechte Seite zeigt das Ergebnis der Quadratwurzelung aller dieser Punkte.</i>  <i>Die ganze Scheibe passt jetzt in die H√§lfte von sich!</i> <br><br>  Dies ist die Grundlage des Algorithmus: Tats√§chlich komprimieren wir die gesamte Einheitsscheibe mit dem positiven Realteil zur H√§lfte.  Wie Sie sich erinnern, haben wir k√ºrzlich die obere H√§lfte einer Kugel zu einer einzigen Scheibe abgeflacht.  Nun lohnt es sich zu sehen, was wir damit machen werden. <br><br><h3>  Alles zusammen </h3><br>  Lassen Sie uns zusammenfassen, was wir gerade getan haben: Wir haben die H√§lfte der Kugel zu einer Einheitsscheibe abgeflacht, die Z-Koordinate aller ihrer Punkte verworfen und die Einheitsscheibe mit dem positiven Realteil unter Verwendung des komplexen Quadratwurzel-Hauptwerts in ihre eigene H√§lfte gequetscht.  Tats√§chlich haben wir die halbe Kugel auf die halbe Scheibe abgeflacht!  Jetzt k√∂nnen wir mit ein paar √Ñnderungen dasselbe tun, um die verbleibende H√§lfte der Kugel in die verbleibende H√§lfte der Scheibe zu komprimieren. <br><br>  Die untere H√§lfte der Kugel (alle Punkte der Kugel mit einer negativen Z-Koordinate) wird ebenfalls durch wiederholtes Ablegen der Z-Koordinaten zu einer Einheitsscheibe abgeflacht. F√ºr alle komplexen Zahlen <em>z</em> in der Scheibe nehmen wir jedoch den Wert entgegengesetzt zur Hauptquadratwurzel von <em>z</em> (d. H. Wir nehmen <em>-c</em> anstelle von <em>c)</em> )  Da der Hauptwert der Quadratwurzel immer einen positiven Realteil hat, hat der entgegengesetzte Wert immer einen negativen Realteil;  Tats√§chlich haben wir die verbleibende H√§lfte der Kugel in die verbleibende H√§lfte der Scheibe abgeflacht, und die Komprimierungsstufe ist nun abgeschlossen! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/910/fcb/d9f/910fcbd9f721b1ceea2de3b3a56bcb2c.png"></div><br>  <i>Voller Komprimierungsschritt.</i>  <i>Beachten Sie, dass die n√∂rdliche und die s√ºdliche Hemisph√§re (blau und orange) zu zwei Kopien einer einzelnen Platte abgeflacht und dann zu zwei H√§lften einer einzelnen Platte komprimiert werden.</i> <br><br>  Der Komprimierungsalgorithmus lautet wie folgt: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">packUnitVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unit)</span></span></span><span class="hljs-function"> disk </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Complex(unit.x, unit.y) packed = principalSquareRoot(disk) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unit.z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? -packed : packed</code> </pre> <br>  Und so haben wir in nur drei Zeilen Pseudocode die gesamte Theorie angewendet, die wir untersucht haben, um einen effektiven Algorithmus zu erstellen.  Wenn Ihre Umgebung keine Formel f√ºr den Hauptwert der Quadratwurzel hat, finden Sie diese <a href="https://en.wikipedia.org/wiki/Square_root" rel="noopener">auf Wikipedia</a> (besondere Aufmerksamkeit sollte der Auswahl des Vorzeichens des Imagin√§rteils gewidmet werden).  Hier ist die Referenz-C ++ - Implementierung, die ich in meinem Code verwende: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Principal complex square root of 'x + iy' float2 csqrt(float x, float y) { float r = sqrt(x * x + y * y); return float2(sqrt((r + x) / 2), (y &lt; 0 ? -1 : 1) * sqrt((r - x) / 2)); }</span></span></code> </pre> <br><h3>  Komm zur√ºck </h3><br>  Wir haben die Komprimierung gemeistert und fahren nun mit dem Auspacken fort. <br><br>  Das Auspacken erfolgt in umgekehrter Reihenfolge aller Komprimierungsschritte: <br><br><ul><li>  Wir erweitern sowohl die positive als auch die negative H√§lfte der materiellen Teile einer einzelnen Scheibe in zwei volle Scheiben </li><li>  Ordnen Sie jeder vollen Scheibe die entsprechende Halbkugel zu </li></ul><br>  Kurz gesagt, wir beginnen mit dem gepackten Wert von <em>p</em> , quadrieren ihn, um zu dem Punkt auf der Scheibe zur√ºckzukehren, der von einer der Hemisph√§ren erhalten wurde, und verwenden dann das Zeichen <em>Re (p)</em> , um herauszufinden, von welcher Hemisph√§re der Punkt auf der Scheibe stammt.  Mit der Gleichung <em>x¬≤ + y¬≤ + z¬≤ = 1</em> , die die Punkte auf der Einheitskugel definiert, k√∂nnen wir die fehlende Z-Koordinate des gepackten Punktes <em>nachbilden</em> . <br><br>  Es ist zu beachten, dass die Berechnung des Quadrats des gepackten Werts immer den richtigen Punkt der Scheibe ergibt, unabh√§ngig von ihrer anf√§nglichen Halbkugel (obere oder untere), da <em>z¬≤ =</em> <em>(-z) ¬≤</em> . <br><br>  Der Dekomprimierungsalgorithmus lautet wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackUnitVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packed)</span></span></span><span class="hljs-function">: disk </span></span>= packed * packed unit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vec3() unit.x = disk.real() unit.y = disk.imag() unit.z = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> - unit.x * unit.x - unit.y * unit.y) * (packed.real() &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unit</code> </pre> <br>  Und so haben wir einen Algorithmus erhalten, der sehr effizient eine 2D-Darstellung einzelner 3D-Vektoren erstellt, die im Gegensatz zu sph√§rischen Koordinaten keine Bitmuster verliert und keine Singularit√§t aufweist.  Wenn Sie einige Optimierungstricks nicht ber√ºcksichtigen, um die Berechnungen zu beschleunigen, ist dies eine fast fertige Version des Algorithmus. <br><br>  ‚Ä¶ oder nicht?  Wenn Sie genau hinschauten, bemerkten Sie, dass hier etwas nicht stimmt.  Ich sagte, dass die Kugel und das Einheitsquadrat nicht hom√∂omorph sind und dennoch irgendwie einen eindeutigen Punkt auf der Scheibe an jeden eindeutigen Punkt auf der Kugel binden konnten?  Dar√ºber hinaus haben wir keine nicht-klassische Mathematik erw√§hnt. Was passiert also? <br><br>  Tats√§chlich hat unser Algorithmus einen schwerwiegenden Nachteil: Er funktioniert f√ºr jeden Punkt in der gesamten Kugel, mit Ausnahme von Punkten auf der Nordhalbkugel mit Y = 0 und X &lt;= 0, die beim Packen und Entpacken f√§lschlicherweise mit dem entsprechenden Punkt auf der Nordhalbkugel verglichen werden. <br><br>  Der Grund daf√ºr ist, dass, wenn ihre Koordinaten Z verworfen werden, die entsprechende komplexe Zahl eine negative reelle Zahl ist und keinen Imagin√§rteil hat.  Wenn wir den Hauptwert der Quadratwurzel einer negativen reellen Zahl nehmen, erhalten wir wiederum eine vollst√§ndig imagin√§re komplexe Zahl, die keinen reellen Teil hat (dies √§hnelt der Tatsache, dass der Hauptwert der Quadratwurzel von -1 gleich <em>i ist</em> ).  Dann versuchen wir, das Vorzeichen der Z-Koordinate im Wesentlichen auf Null zu halten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6bc/720/d08/6bc720d085469f478453dc4c961e2036.png"></div><br>  <i>Problemstreifen.</i>  <i>Punkte mit Y = 0 und X &lt;= 0 werden in eine Reihe rein imagin√§rer Zahlen mit undefinierbaren Realteilen gepackt.</i> <br><br>  Mal sehen, was passiert, wenn wir zwei solche Punkte packen (nicht vergessen, dass x &lt;= 0 ist). <br><br><blockquote><pre>  |  Nordpunkt |  South Point
  Einheit |  (x, 0, z) |  (x, 0, -z)
  Datentr√§ger |  x + 0i |  x + 0i
 verpackt |  0 + ‚àö (-x) i |  -0 - ‚àö (-x) i </pre></blockquote><br>  Da der Imagin√§rteil der Projektion beider Punkte auf die Scheibe gleich Null ist, k√∂nnen wir das Vorzeichen der Z-Koordinate nicht im Vorzeichen des Realteils des Hauptwerts der Quadratwurzel speichern, da es selbst gleich Null ist.  Wir k√∂nnen einfach dar√ºber nachdenken und akzeptieren, dass der Algorithmus f√ºr diese Punkte nicht funktioniert - oder wir k√∂nnen weitermachen. <br><br><h2>  Vergiss was wir gelernt haben </h2><br>  In allen mir bekannten Bereichen und Zweigen der Mathematik wird angenommen, dass 0 = -0 ist.  Dies folgt aus der Definition von <em>-a</em> , die das Gegenteil von <em>a ist</em> und besagt, dass <em>"-a die einzige Zahl ist, die 0 ergibt, wenn sie mit a summiert wird"</em> .  Da 0 auch in Bezug auf Addition ein Nullelement ist ( <em>0 + a = a + 0 = a</em> ), m√ºssen Sie nur 0 zu 0 hinzuf√ºgen, um 0 zu erhalten, und zwar 0 selbst. <br><br>  In der Softwareentwicklung ist jedoch alles anders.  In den meisten Darstellungen von Gleitkommazahlen wird zusammen mit dem Exponenten und der Mantisse ein zus√§tzliches Bit zum Speichern des Zeichens verwendet.  Das hei√üt, wenn der Exponent und die Mantisse 0 sind, kann das Vorzeichenbit verwendet werden, um zwischen positiven und negativen Nullen zu unterscheiden.  In den meisten Programmiersprachen (wenn nicht allen) werden beide Nullen als eine einzige Null behandelt (versuchen Sie es einfach mit <em>0 == -0</em> ), aber es gibt einen Unterschied. Dies kann festgestellt werden, wenn Sie versuchen, ‚Äû-0‚Äú und ‚Äû0‚Äú an das Terminal auszugeben "- so werden sie abgeleitet. <br><br>  Dies ist sehr wichtig f√ºr uns: Der Wert Null kann tats√§chlich zum Speichern von Informationen √ºber das Zeichen verwendet werden!  Tats√§chlich wird es trotzdem korrekt gespeichert.  in unserem Fall ist das Problem, dass es nicht richtig gelesen wird.  Wenn wir uns die vorletzte Zeile im Entpack-Algorithmus ansehen, werden wir Folgendes sehen: <br><br><pre> <code class="cpp hljs">packed.real() &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Diese Operation liest das Vorzeichen des Realteils des gepackten Werts, um zu bestimmen, zu welcher Hemisph√§re der Punkt geh√∂rt - Norden oder S√ºden.  Wenn <em>packet.real ()</em> jedoch 0 oder -0 ist, wird das Zeichen vom Vergleichsoperator ignoriert und der tern√§re Operator gibt immer 1 zur√ºck. Die richtige Art, das Zeichen zu lesen, ist eine <em>echte</em> Anfrage nach dem Status des Vorzeichenbits, z. B. mit <em>std :: signbit</em> von C ++ oder <em>np .signbit</em> von Numpy nach Python - die Funktion ist sprachabh√§ngig.  Denken Sie daran, dass das Vorzeichenbit 1 ist, wenn die Zahl negativ ist, und 0, wenn die Zahl positiv ist. <br><br>  So erhalten wir eine korrigierte und hundertprozentig funktionierende Funktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackUnitVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packed)</span></span></span><span class="hljs-function">: disk </span></span>= packed * packed unit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vec3() unit.x = disk.real() unit.y = disk.imag() unit.z = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> - unit.x * unit.x - unit.y * unit.y) * (signbit(packed.real()) ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unit</code> </pre> <br>  Das ist alles!  Damit ist der Algorithmus abgeschlossen.  Nicht-klassische Mathematik √§u√üert sich in der Tatsache, dass wir die Tatsache verwenden, dass 0 von -0 abweicht, was f√ºr alle Bereiche der Mathematik, die ich kenne, falsch ist.  Es gibt jedoch eine M√∂glichkeit, diese Fremdartigkeit in einem theoretischen, mathematisch strengen Sinn logisch zu machen. <br><br><h2>  R√§ume, die sich nicht an die Regeln halten: eine gerade Linie mit zwei Ursprungspunkten </h2><br>  Um das Folgende besser zu verstehen, sollten Sie die Konzepte von √Ñquivalenzklassen und Nachbarschaften kennen.  Dies ist optional, wird aber klarer. <br><br>  Wir k√∂nnen die Konsistenz dieser Kuriosit√§t mit einem "Vorzeichen Null" sicherstellen, beginnend mit einem interessanten topologischen Raum: einer geraden Linie mit zwei Ursprungspunkten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7df/bdc/b66/7dfbdcb665e09552d349b0fb6d606f52.png"></div><br>  <i>Eine gerade Linie mit zwei Ursprungspunkten ist eine gew√∂hnliche reale numerische Achse, die f√ºr sich selbst irgendwie um eine zus√§tzliche 0 gewachsen ist.</i> <br><br>  Eine gerade Linie mit zwei Ursprungspunkten ergibt sich, wenn wir zwei reelle numerische Achsen nehmen und jede Zahl mit Ausnahme von 0 mit dem Gegenteil verbinden. Formal ist eine gerade Linie mit zwei Ursprungspunkten ein Quotientenraum R¬≤ mit einer √Ñquivalenzbeziehung, die zwei Zahlen identifiziert, wenn sie gleich <em>und sind</em> sind nicht 0. Das Ergebnis ist eine gerade Linie von reellen Zahlen mit zwei unterschiedlichen Nullen, die von jedem Punkt gleich weit entfernt sind, sich aber gleichzeitig voneinander unterscheiden.  Formal haben zwei beliebige Nachbarschaften jeder der Nullen immer einen nicht leeren Schnittpunkt. <br><br>  Wir k√∂nnen dies erweitern und versuchen, das in diesem Artikel verwendete "disk-like" -Objekt zu definieren.  Fr√ºher haben wir das Vorzeichen der Z-Koordinate des Punktes im Realteil der Hauptquadratwurzel seiner Projektion auf die komplexe Scheibe gewaltsam beibehalten, auch wenn dieser Realteil 0 ist. Dies bedeutet, dass wir keine komplexen Zahlen verwendet haben, sondern ein √§hnliches Konzept: eine komplexe Zahl, Der Imagin√§rteil ist eine reelle Zahl, und der Realteil ist ein Punkt auf einer Linie mit zwei Ursprungspunkten, sodass wir den Realteil gleich +0 und -0 unterscheiden k√∂nnen.  Tats√§chlich verwenden wir <strong>komplexe Zahlen mit zwei Ursprungspunkten!</strong> <br><br>  Tats√§chlich fanden wir keine Bijektion (Eins-zu-Eins-Zuordnung) zwischen der Kugel und der Einheitsscheibe, sondern eine Bijektion zwischen der Kugel und der Einheitsscheibe mit zwei Ursprungspunkten.  Ich habe nicht gepr√ºft, ob diese Bijektion ein Hom√∂omorphismus ist (ein Hom√∂omorphismus ist eine in beide Richtungen fortlaufende Bijektion), aber vielleicht werde ich es eines Tages tun. <br><br><h3>  Ein bisschen Topologie am Ende </h3><br>  Abschlie√üend m√∂chte ich betonen, dass die komplexe Ebene, die wir mit zwei Ursprungspunkten verwendet haben, zwar nicht aus derselben Konstruktion wie die gerade Linie mit zwei Ursprungspunkten folgt, dass sie jedoch einer anderen komplexen Ebene mit zwei Ursprungspunkten entspricht, die √§hnlich konstruiert ist wie eine gerade Linie mit zwei herkunft. <br><br>  Im Fall einer geraden Linie mit zwei Ursprungspunkten haben wir an allen Stellen au√üer 0 zwei Kopien der reellen numerischen Achse geklebt. Wir k√∂nnen dasselbe mit zwei Kopien der komplexen Ebene tun, indem wir jedes Paar gleicher komplexer Zahlen, die nicht 0 sind, zusammenkleben und auf √§hnliche Weise komplex werden eine Ebene mit zwei Ursprungspunkten.  Diese Konstruktion unterscheidet sich von der Konstruktion einer neuen komplexen Ebene aus einer geraden Linie mit zwei Ursprungspunkten und einer gew√∂hnlichen reellen numerischen Achse: Die erstere ist ein Faktorraum, und die letztere ist ein Produkt von R√§umen.  Der einzige Unterschied zwischen den beiden resultierenden R√§umen besteht jedoch darin, wie in jedem Raum unterschiedliche Nullen geschrieben werden: Im ersten Fall werden sie als ( <em>0 + 0i) a</em> und ( <em>0 + 0i) b gez√§hlt</em> (zwei Nullen aus zwei nicht zusammengeklebten R√§umen). und in letzterem werden sie als <em>(0a + 0i)</em> und <em>(0b + 0i</em> <em>)</em> gelesen.  Tats√§chlich sind beide R√§ume hom√∂omorph, sodass Sie einen sicher dort verwenden k√∂nnen, wo der andere ben√∂tigt wird. <br><br><h2>  Fazit </h2><br>  Ich hoffe, Sie haben diesen Ausflug in die Welt der bizarren und obskuren Mathematik genossen.  Ich betone noch einmal die Tatsache, dass sich dieser Algorithmus streng genommen schlechter verh√§lt als der <em>Oct-</em> Algorithmus aus dem eingangs erw√§hnten Artikel.  Obwohl es in der Ausf√ºhrungszeit kurz oder sogar schneller ist, ist seine Punkteverteilung auf der Kugel bei weitem nicht so gut.  Ich habe damals diesen Artikel geschrieben, um zu zeigen, wie eine scheinbar fremde Mathematik, √§hnlich wie abstrakter Unsinn, tats√§chlich eine sehr interessante Anwendung in der realen Welt haben kann.  au√üerdem finde ich diesen abstrakten Quatsch entz√ºckend.  Ich hoffe, Sie haben aus dem Artikel etwas N√ºtzliches gelernt, danke f√ºrs Lesen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482348/">https://habr.com/ru/post/de482348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482332/index.html">Wie ein Enthusiast unter DOS ein Wi-Fi-Netzwerk aufbaute</a></li>
<li><a href="../de482336/index.html">H√§ndler haben Zugang zu Pressekonferenzen der Central Bank of England, bevor diese √∂ffentlich ausgestrahlt werden</a></li>
<li><a href="../de482338/index.html">Visual Studio f√ºr Mac: Steuern Sie Ihre IDE mit Schl√ºsseln</a></li>
<li><a href="../de482340/index.html">Von Junior'a nach Middle'a: Parser</a></li>
<li><a href="../de482344/index.html">Machen Sie sich bereit f√ºr die Einf√ºhrung eines Social Ratings in Russland</a></li>
<li><a href="../de482352/index.html">Als ich fast 150k in den Wind warf oder die Geschichte der Installation von Fremdbel√ºftung in der Wohnung</a></li>
<li><a href="../de482354/index.html">ConfigureAwait: H√§ufig gestellte Fragen</a></li>
<li><a href="../de482356/index.html">Verwenden von Windows Server ohne Explorer aus der Sicht eines normalen Windows-Benutzers</a></li>
<li><a href="../de482358/index.html">Wie Panik in Rust wirkt</a></li>
<li><a href="../de482360/index.html">Habra-Detektiv: Sie sind mit UFOs befreundet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>