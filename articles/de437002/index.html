<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèª üî≠ üç® G√ºltiger ASP.NET Core ‚è∞ üßóüèΩ üêÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Speziell f√ºr Buchliebhaber aus der Reihe "C ++ in 24 Stunden" habe ich beschlossen, einen Artikel √ºber ASP.NET Core zu schreiben. 


 Wenn Sie noch ni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>G√ºltiger ASP.NET Core</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437002/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/sy/y_/ph/syy_ph0f1cwt9upm9frbr6z5ggi.jpeg" alt="G√ºltiger ASP.NET Core"></a> </p><br><p>  Speziell f√ºr Buchliebhaber aus der Reihe "C ++ in 24 Stunden" habe ich beschlossen, einen Artikel √ºber ASP.NET Core zu schreiben. </p><br><p>  Wenn Sie noch nie unter .NET oder einer √§hnlichen Plattform entwickelt haben, macht es keinen Sinn, f√ºr Sie unter den Schnitt zu gehen.  Wenn Sie jedoch wissen m√∂chten, was IoC, DI, DIP, Interseptoren, Middleware und Filter sind (dh alles, was sich von Core von klassischem .NET unterscheidet), m√ºssen Sie w√§hrend der Entwicklung unbedingt auf "Lesen Sie mehr" klicken Ohne all dies zu verstehen, ist es eindeutig nicht korrekt. </p><a name="habracut"></a><br><h2 id="ioc-di-dip">  IoC, DI, DIP </h2><br><p>  Wenn ein Theater mit einem Kleiderb√ºgel beginnt, beginnt ASP.NET Core mit einer Abh√§ngigkeitsinjektion.  Um mit DI umgehen zu k√∂nnen, m√ºssen Sie verstehen, was IoC ist. </p><br><p>  Wenn man √ºber IoC spricht, erinnert man sich oft an das Hollywood-Prinzip: "Rufen Sie uns nicht an, wir rufen Sie an."  Was bedeutet "Sie m√ºssen uns nicht anrufen, wir rufen Sie selbst an." </p><br><p> Unterschiedliche Quellen geben unterschiedliche Muster an, auf die IoC angewendet werden kann.  Und h√∂chstwahrscheinlich geht es ihnen gut und sie erg√§nzen sich einfach.  Hier sind einige dieser Muster: Fabrik, Service Locator, Vorlagenmethode, Beobachter, Strategie. </p><br><p>  Schauen wir uns IoC am Beispiel einer einfachen Konsolenanwendung an. </p><br><p>  Angenommen, wir haben zwei einfache Klassen, die eine Schnittstelle mit einer Methode implementieren: </p><br><pre><code class="plaintext hljs">class ConsoleLayer : ILayer { public void Write(string text) { Console.WriteLine(text); } } class DebugLayer : ILayer { public void Write(string text) { Debug.WriteLine(text); } } interface ILayer { void Write(string text); }</code> </pre> <br><p>  Beide h√§ngen von der Abstraktion ab (in diesem Fall fungiert die Schnittstelle als Abstraktion). </p><br><p>  Angenommen, wir haben ein √ºbergeordnetes Objekt, das diese Klassen verwendet: </p><br><pre> <code class="plaintext hljs"> class Logging : ILayer { private ILayer _instance; public Logging(int i) { if (i == 1) { _instance = new ConsoleLayer(); } else { _instance = new DebugLayer(); } } public void Write(string text) { _instance.Write(text); } }</code> </pre> <br><p>  Abh√§ngig vom Konstruktorparameter wird die Variable _instance von einer bestimmten Klasse initialisiert.  Wenn Sie Write aufrufen, wird die Ausgabe an die Konsole oder an Debug abgeschlossen.  Alles scheint ziemlich gut zu sein und entspricht sogar dem ersten Teil des Prinzips der Abh√§ngigkeitsinversion </p><br><blockquote>  √úbergeordnete Objekte sind unabh√§ngig von untergeordneten Objekten.  Sowohl diese als auch diese h√§ngen von Abstraktionen ab. </blockquote><p>  In unserem Fall fungiert ILayer als Abstraktion. </p><br><p>  Wir m√ºssen aber auch ein Objekt von noch h√∂herem Niveau haben.  Eine, die die Protokollierungsklasse verwendet </p><br><pre> <code class="plaintext hljs"> static void Main(string[] args) { var log = new Logging(1); log.Write("Hello!"); Console.Read(); }</code> </pre> <br><p>  Durch Initialisieren der Protokollierung mit 1 erhalten wir in der Protokollierungsklasse eine Instanz der Klasse, die Daten an die Konsole ausgibt.  Wenn wir die Protokollierung mit einer anderen Nummer initialisieren, gibt log.Write Daten an Debug aus.  Alles scheint zu funktionieren, aber es funktioniert schlecht.  Unser √ºbergeordnetes Objekt Main h√§ngt von den Details des Codes des untergeordneten Objekts ab - der Protokollierungsklasse.  Wenn wir etwas in dieser Klasse √§ndern, m√ºssen wir den Code der Hauptklasse √§ndern.  Um dies zu verhindern, werden wir eine Umkehrung der Kontrolle vornehmen - Umkehrung der Kontrolle.  Lassen Sie die Hauptklasse steuern, was in der Protokollierungsklasse geschieht.  Die Logging-Klasse erh√§lt als Konstruktorparameter eine Instanz einer Klasse, die die ILayer-Schnittstelle implementiert </p><br><pre> <code class="plaintext hljs"> class Logging { private ILayer _instance; public Logging(ILayer instance) { _instance = instance; } public void Write(string text) { _instance.Write(text); } }</code> </pre> <br><p>  Und jetzt wird unsere Hauptklasse so aussehen: </p><br><pre> <code class="plaintext hljs"> static void Main(string[] args) { var log = new Logging(new DebugLayer()); log.Write("Hello!"); Console.Read(); }</code> </pre> <br><p>  Tats√§chlich dekorieren wir unser Protokollierungsobjekt mit dem f√ºr uns erforderlichen Objekt. </p><br><p>  Jetzt entspricht unsere Anwendung dem zweiten Teil des Abh√§ngigkeitsinversionsprinzips: </p><br><blockquote>  Abstraktionen sind unabh√§ngig von den Details.  Details h√§ngen von Abstraktionen ab.  Das hei√üt,  Wir kennen die Details der Vorg√§nge in der Protokollierungsklasse nicht. Wir √ºbergeben dort nur die Klasse, die die erforderliche Abstraktion implementiert. </blockquote><p>  Es gibt einen solchen Begriff enge Kupplung - enge Verbindung.  Je schw√§cher die Verbindung zwischen den Komponenten in der Anwendung ist, desto besser.  Ich m√∂chte darauf hinweisen, dass dieses Beispiel einer einfachen Anwendung das Ideal nicht ein wenig erreicht.  Warum?  Ja, da wir in der Klasse der h√∂chsten Ebene in Main zweimal die Erstellung von Klasseninstanzen mit new verwenden.  Und es gibt eine solche mnemonische Phrase ‚ÄûNeu ist ein Hinweis‚Äú - das hei√üt, je weniger Sie Neu verwenden, desto weniger enge Verbindungen der Komponenten in der Anwendung und desto besser.  Idealerweise sollten wir keinen neuen DebugLayer verwenden, sondern DebugLayer auf andere Weise erhalten.  Welches?  Zum Beispiel aus einem IoC-Container oder mithilfe der Reflexion eines an Main √ºbergebenen Parameters. </p><br><p>  Jetzt haben wir herausgefunden, was Inversion of Control (IoC) ist und was Dependency Inversion (DIP) ist.  Es bleibt zu verstehen, was Dependency Injection (DI) ist.  IoC ist ein Design-Paradigma.  Die Abh√§ngigkeitsinjektion ist ein Muster.  Dies ist, was wir jetzt im Konstruktor der Logging-Klasse haben.  Wir erhalten eine Instanz einer bestimmten Abh√§ngigkeit.  Die Protokollierungsklasse h√§ngt von einer Instanz einer Klasse ab, die ILayer implementiert.  Und diese Instanz wird durch den Konstruktor injiziert. </p><br><h2 id="ioc-container">  IoC-Container </h2><br><p>  Ein IoC-Container ist ein solches Objekt, das viele spezifische Abh√§ngigkeiten (Abh√§ngigkeiten) enth√§lt.  Abh√§ngigkeit kann auch als Service bezeichnet werden - in der Regel handelt es sich um eine Klasse mit einer bestimmten Funktionalit√§t.  Bei Bedarf kann die Abh√§ngigkeit des gew√ºnschten Typs aus dem Beh√§lter entnommen werden.  Das Injizieren von Abh√§ngigkeiten in einen Container ist Inject.  Extrahieren - aufl√∂sen.  Hier ist ein Beispiel f√ºr den einfachsten selbstgeschriebenen IoC-Container: </p><br><pre> <code class="plaintext hljs"> public static class IoCContainer { private static readonly Dictionary&lt;Type, Type&gt; _registeredObjects = new Dictionary&lt;Type, Type&gt;(); public static dynamic Resolve&lt;TKey&gt;() { return Activator.CreateInstance(_registeredObjects[typeof(TKey)]); } public static void Register&lt;TKey, TConcrete&gt;() where TConcrete : TKey { _registeredObjects[typeof(TKey)] = typeof(TConcrete); } }</code> </pre> <br><p>  Nur ein Dutzend Codezeilen, aber Sie k√∂nnen sie bereits verwenden (nat√ºrlich nicht f√ºr die Produktion, sondern f√ºr Bildungszwecke). </p><br><p>  Sie k√∂nnen die Abh√§ngigkeit (z. B. ConsoleLayer oder DebugLayer, die wir im vorherigen Beispiel verwendet haben) folgenderma√üen registrieren: </p><br><pre> <code class="plaintext hljs"> IoCContainer.Register&lt;ILayer, ConsoleLayer&gt;();</code> </pre> <br><p>  Und extrahieren Sie es wie folgt aus dem Container an der erforderlichen Stelle des Programms: </p><br><pre> <code class="plaintext hljs"> ILayer layer = IoCContainer.Resolve&lt;ILayer&gt;(); layer.Write("Hello from IoC!");</code> </pre> <br><p>  In realen Containern ist auch Dispose () implementiert, mit dem Sie unn√∂tige Ressourcen zerst√∂ren k√∂nnen. </p><br><p>  √úbrigens vermittelt der Name IoC-Container nicht genau die Bedeutung, da der Begriff IoC in der Anwendung viel weiter gefasst ist.  Daher wurde in letzter Zeit der Begriff DI-Container immer h√§ufiger verwendet (da die Abh√§ngigkeitsinjektion immer noch angewendet wird). </p><br><h2 id="service-lifetimes--various-extension-methods-in-composition-root">  Lebensdauer + verschiedene Erweiterungsmethoden in Composition Root </h2><br><p>  ASP.NET Core-Anwendungen enthalten die Datei Startup.cs, die den Ausgangspunkt der Anwendung zum Konfigurieren von DI darstellt.  Konfiguriert DI in der ConfigureServices-Methode. </p><br><pre> <code class="plaintext hljs"> public void ConfigureServices(IServiceCollection services) { services.AddScoped&lt;ISomeRepository, SomeRepository&gt;(); }</code> </pre> <br><p>  Dieser Code f√ºgt dem DI-Container die SomeRepository-Klasse hinzu, die die ISomeRepository-Schnittstelle implementiert.  Die Tatsache, dass der Service mithilfe von AddScoped zum Container hinzugef√ºgt wird, bedeutet, dass bei jeder Anforderung einer Seite eine Instanz der Klasse erstellt wird. <br>  Sie k√∂nnen einem Container einen Dienst hinzuf√ºgen, ohne eine Schnittstelle anzugeben. </p><br><pre> <code class="plaintext hljs"> services.AddScoped&lt;SomeRepository&gt;();</code> </pre> <br><p>  Diese Methode wird jedoch nicht empfohlen, da Ihre Anwendung ihre Flexibilit√§t verliert und enge Verbindungen angezeigt werden.  Es wird empfohlen, immer eine Schnittstelle anzugeben, da Sie in diesem Fall jederzeit eine Implementierung der Schnittstelle durch eine andere ersetzen k√∂nnen.  Und wenn die Implementierungen das Liskov-Substitutionsprinzip unterst√ºtzen, √§ndern Sie durch √Ñndern des Namens der Implementierungsklasse mit einem Handgriff die Funktionalit√§t der gesamten Anwendung. </p><br><p>  Es gibt zwei weitere Optionen zum Hinzuf√ºgen eines Dienstes - AddSingleton und AddTransient. <br>  Bei Verwendung von AddSingleton wird der Dienst einmal erstellt, und bei Verwendung der Anwendung wird der Aufruf an dieselbe Instanz gesendet.  Verwenden Sie diese Methode besonders vorsichtig, da Speicherlecks und Multithreading-Probleme m√∂glich sind. </p><br><p>  AddSingleton hat eine kleine Funktion.  Es kann entweder beim ersten Zugriff darauf initialisiert werden </p><br><pre> <code class="plaintext hljs"> services.AddSingleton&lt;IYourService, YourService&gt;();</code> </pre> <br><p>  entweder sofort beim Hinzuf√ºgen zum Konstruktor </p><br><pre> <code class="plaintext hljs"> services.AddSingleton&lt;IYourService&gt;(new YourService(param));</code> </pre> <br><p>  Auf die zweite Weise k√∂nnen Sie dem Konstruktor sogar einen Parameter hinzuf√ºgen. <br>  Wenn Sie dem Konstruktor eines Dienstes, der nicht nur mit AddSingleton, sondern auch mit AddTransient / AddScoped hinzugef√ºgt wurde, einen Parameter hinzuf√ºgen m√∂chten, k√∂nnen Sie den Lambda-Ausdruck verwenden: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;IYourService&gt;(o =&gt; new YourService(param));</code> </pre> <br><p>  Wenn Sie AddTransient verwenden, wird bei jedem Zugriff ein Dienst erstellt.  Ideal f√ºr leichte Dienste, die keinen Speicher und keine Ressourcen verbrauchen. </p><br><p>  Wenn mit AddSingleton und AddScoped alles mehr oder weniger klar sein soll, muss AddTransient gekl√§rt werden.  Die offizielle Dokumentation enth√§lt ein Beispiel, in dem ein bestimmter Dienst dem DI-Container sowohl als Parameter des Konstruktors eines anderen Dienstes als auch separat unabh√§ngig hinzugef√ºgt wird.  Und falls es separat mit AddTransient hinzugef√ºgt wird, erstellt es seine Instanz zweimal.  Ich werde ein sehr, sehr vereinfachtes Beispiel geben.  Im wirklichen Leben wird es nicht zur Verwendung empfohlen, weil  Klassen erben der Einfachheit halber keine Schnittstellen.  Nehmen wir an, wir haben eine einfache Klasse: </p><br><pre> <code class="plaintext hljs"> public class Operation { public Guid OperationId { get; private set; } public Operation() { OperationId = Guid.NewGuid(); } }</code> </pre> <br><p>  Und es gibt eine zweite Klasse, die die erste als abh√§ngigen Dienst enth√§lt und diese Abh√§ngigkeit als Konstruktorparameter empf√§ngt: </p><br><pre> <code class="plaintext hljs"> public class OperationService { public Operation Operation { get; } public OperationService (Operation operation) { Operation = operation; } }</code> </pre> <br><p>  Jetzt injizieren wir zwei Dienste: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;Operation&gt;(); services.AddScoped&lt;OperationService&gt;();</code> </pre> <br><p>  F√ºgen Sie in einigen Controllern in Aktion den Empfang unserer Abh√§ngigkeiten hinzu und zeigen Sie die Werte im Debug-Fenster an. </p><br><pre> <code class="plaintext hljs"> public IActionResult Index([FromServices] Operation operation, [FromServices] OperationService operationService) { Debug.WriteLine(operation.OperationId); Debug.WriteLine(operationService.Operation.OperationId); return View(); }</code> </pre> <br><p>  Als Ergebnis erhalten wir 2 verschiedene Guid-Werte.  Wenn wir jedoch AddTransient durch AddScoped ersetzen, erhalten wir als Ergebnis zwei identische Werte. </p><br><p>  Der IoC-Container der ASP.NET Core-Anwendung enth√§lt standardm√§√üig einige Dienste.  Beispielsweise ist IConfiguration ein Dienst, mit dem Sie Anwendungseinstellungen aus den Dateien appsettings.json und appsettings.Development.json abrufen k√∂nnen.  IHostingEnvironment und ILoggerFactory, mit denen Sie die aktuelle Konfiguration und eine Hilfsklasse abrufen k√∂nnen, die die Protokollierung erm√∂glicht. </p><br><p>  Klassen werden mit der folgenden typischen Konstruktion aus dem Container abgerufen (das h√§ufigste Beispiel): </p><br><pre> <code class="plaintext hljs"> private readonly IConfiguration _configuration; public SomePageController(IConfiguration configuration) { _configuration = configuration; } public async Task&lt;IActionResult&gt; Index() { string connectionString = _configuration["connectionString"]; }</code> </pre> <br><p>  Im Bereich des Controllers wird eine Variable mit privaten schreibgesch√ºtzten Zugriffsmodifikatoren erstellt.  Die Abh√§ngigkeit wird aus dem Container im Konstruktor der Klasse abgerufen und einer privaten Variablen zugewiesen.  Ferner kann diese Variable in beliebigen Methoden oder Aktionscontrollern verwendet werden. <br>  Manchmal m√∂chten Sie keine Variable erstellen, um sie in nur einer Aktion zu verwenden.  Dann k√∂nnen Sie das Attribut [FromServices] verwenden.  Ein Beispiel: </p><br><pre> <code class="plaintext hljs"> public IActionResult About([FromServices] IDateTime dateTime) { ViewData["Message"] = ¬´  " + dateTime.Now; return View(); }</code> </pre> <br><p>  Es sieht seltsam aus, aber um die Methode der statischen Klasse DateTime.Now () im Code nicht aufzurufen, wird manchmal so vorgegangen, dass der Zeitwert vom Dienst als Parameter abgerufen wird.  Somit ist es m√∂glich, jederzeit einen Parameter zu √ºbergeben, was das Schreiben von Tests und in der Regel das Vornehmen von √Ñnderungen an der Anwendung erleichtert. <br>  Das hei√üt nicht, dass Statik b√∂se ist.  Statische Methoden sind schneller.  Und h√∂chstwahrscheinlich kann statisch irgendwo im IoC-Container selbst verwendet werden.  Wenn wir unsere Anwendung jedoch vor allem Statischen und Neuen sch√ºtzen, erhalten wir mehr Flexibilit√§t. </p><br><h2 id="storonnie-di-konteynery">  DI-Container von Drittanbietern </h2><br><p>  Was wir uns angesehen haben und was der ASP.NET Core DI-Container standardm√§√üig tats√§chlich implementiert, ist die Konstruktorinjektion.  Es besteht weiterhin die M√∂glichkeit, Abh√§ngigkeiten mithilfe der sogenannten Eigenschaftsinjektion in Eigenschaften einzuf√ºgen. Diese Funktion ist jedoch in dem in ASP.NET Core integrierten Container nicht verf√ºgbar.  Beispielsweise haben wir m√∂glicherweise eine Klasse, die Sie als Abh√§ngigkeit implementieren, und diese Klasse verf√ºgt √ºber eine Art √∂ffentliches Eigentum.  Stellen Sie sich nun vor, dass wir w√§hrend oder nach dem Einf√ºgen der Abh√§ngigkeit den Wert der Eigenschaft festlegen m√ºssen.  Kehren wir zu einem Beispiel zur√ºck, das dem k√ºrzlich untersuchten Beispiel √§hnelt. <br>  Wenn wir eine solche Klasse haben: </p><br><pre> <code class="plaintext hljs"> public class Operation { public Guid OperationId { get; set; } public Operation() {} }</code> </pre> <br><p>  was wir als Sucht einf√ºhren k√∂nnen, </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;Operation&gt;();</code> </pre> <br><p>  Dann k√∂nnen wir mit dem Standardcontainer den Wert f√ºr die Eigenschaft nicht festlegen. <br>  Wenn Sie diese Gelegenheit nutzen m√∂chten, um einen Wert f√ºr die OperationId-Eigenschaft festzulegen, k√∂nnen Sie einen DI-Container eines Drittanbieters verwenden, der die Eigenschaftsinjektion unterst√ºtzt.  √úbrigens wird die Eigenschaftsinjektion nicht besonders empfohlen.  Es gibt jedoch immer noch Method Injection und Setter Method Injection, die f√ºr Sie n√ºtzlich sein k√∂nnen und die auch vom Standardcontainer nicht unterst√ºtzt werden. </p><br><p>  Container von Drittanbietern k√∂nnen andere sehr n√ºtzliche Funktionen aufweisen.  Wenn Sie beispielsweise einen Container eines Drittanbieters verwenden, k√∂nnen Sie Controller nur mit Abh√§ngigkeiten versehen, deren Name ein bestimmtes Wort enth√§lt.  Und h√§ufig verwendete Fall - DI-Container, optimiert f√ºr die Leistung. <br>  Hier ist eine Liste einiger DI-Container von Drittanbietern, die von ASP.NET Core unterst√ºtzt werden: Autofac, Castle Windsor, LightInject, DryIoC, StructureMap, Unity </p><br><p>  Obwohl Sie einen Standard-DI-Container verwenden, k√∂nnen Sie die Eigenschafts- / Methodeninjektion nicht verwenden, aber Sie k√∂nnen einen abh√§ngigen Dienst als Konstruktorparameter implementieren, indem Sie das Factory-Muster wie folgt implementieren: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;IDataService, DataService&gt;((dsvc) =&gt; { IOtherService svc = dsvc.GetService&lt;IOtherService&gt;(); return new DataService(svc); });</code> </pre> <br><p>  In diesem Fall gibt GetService null zur√ºck, wenn der abh√§ngige Dienst nicht gefunden wird.  Es gibt eine Variante von GetRequiredService, die eine Ausnahme ausl√∂st, wenn der abh√§ngige Dienst nicht gefunden wird. <br>  Der Prozess zum Abrufen eines abh√§ngigen Dienstes mithilfe von GetService wendet tats√§chlich das Dienstlokalisierungsmuster an. </p><br><h2 id="autofac">  Autofac </h2><br><p>  Werfen wir einen Blick auf Autofac mit einem praktischen Beispiel.  Bequemerweise k√∂nnen Dienste aus dem Container sowohl standardm√§√üig als auch √ºber Autofac registriert und empfangen werden. </p><br><p>  Installieren Sie das NuGet-Paket Autofac.Extensions.DependencyInjection. <br>  √Ñndern Sie den von der ConfigureServices-Methode zur√ºckgegebenen Wert von void in IServiceProvider.  Und Eigentum hinzuf√ºgen </p><br><pre> <code class="plaintext hljs"> public IContainer ApplicationContainer { get; private set; }</code> </pre> <br><p>  Danach kann am Ende der ConfigureServices-Methode der Startup-Klasse Code wie der folgende hinzugef√ºgt werden (dies ist nur eine der Optionen zum Registrieren von Diensten): </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;ISomeRepository, SomeRepository&gt;(); var builder = new ContainerBuilder(); builder.Populate(services); builder.RegisterType&lt;AnotherRepository&gt;().As&lt;IAnotherRepository&gt;(); this.ApplicationContainer = builder.Build(); return new AutofacServiceProvider(this.ApplicationContainer);</code> </pre> <br><p>  Hier builder.Populate (Dienste);  F√ºgt dem Container Dienste aus der IServiceCollection hinzu.  Nun und weiter ist es bereits m√∂glich, Dienste bei builder.RegisterType zu registrieren.  Oh ja.  Ich h√§tte es fast vergessen.  Sie m√ºssen den R√ºckgabewert der ConfigureServices-Methode von void in IServiceProvider √§ndern. </p><br><h2 id="aop-s-pomoschyu-aspnet-core---autofac-interseptors">  AOP mit ASP.NET Core - Autofac Interseptors </h2><br><p>  Wenn sie √ºber aspektorientierte Programmierung sprechen, erw√§hnen sie einen anderen Begriff - Querschnittsthemen.  Bedenken sind einige Informationen, die sich auf den Code auswirken.  In der russischen Version verwenden sie das Wort Verantwortung.  Querschnittsthemen sind Verantwortlichkeiten, die sich auf andere Verantwortlichkeiten auswirken.  Aber im Idealfall sollten sie sich nicht gegenseitig beeinflussen, oder?  Wenn sie sich gegenseitig beeinflussen, wird es schwieriger, das Programm zu √§ndern.  Es ist bequemer, wenn wir alle Operationen separat haben.  Protokollierung, Transaktionen, Caching und vieles mehr k√∂nnen mit AOP durchgef√ºhrt werden, ohne den Code der Klassen und Methoden selbst zu √§ndern. </p><br><p>  In der .NET-Welt wird h√§ufig eine Methode verwendet, wenn AOP-Code mithilfe eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postprozessors</a> in einen bereits kompilierten Anwendungscode ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PostSharp</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingebettet wird</a> . Alternativ k√∂nnen Sie Interceptors verwenden. Dies sind Ereignis-Hooks, die dem Anwendungscode hinzugef√ºgt werden k√∂nnen.  Diese Abfangj√§ger verwenden in der Regel den Dekorator, den wir bereits f√ºr ihre Arbeit untersucht haben. </p><br><p>  Lassen Sie uns Ihren eigenen Abfangj√§ger erstellen.  Das einfachste und typischste Beispiel, das am einfachsten zu reproduzieren ist, ist die Protokollierung. <br>  Zus√§tzlich zum Paket Autofac.Extensions.DependencyInjection installieren wir auch das Paket Autofac.Extras.DynamicProxy <br>  Installiert?  F√ºgen Sie eine einfache Protokollklasse hinzu, die beim Zugriff auf bestimmte Dienste aufgerufen wird. </p><br><pre> <code class="plaintext hljs"> public class Logger : IInterceptor { public void Intercept(IInvocation invocation) { Debug.WriteLine($"Calling {invocation.Method.Name} from Proxy"); invocation.Proceed(); } }</code> </pre> <br><p>  Zu unserer Registrierung hinzuf√ºgen Autofac-Registrierung des Abfangj√§gers: </p><br><pre> <code class="plaintext hljs"> builder.Register(i =&gt; new Logger()); builder.RegisterType&lt;SomeRepository &gt;() .As&lt;ISomeRepository &gt;() .EnableInterfaceInterceptors() .InterceptedBy(typeof(Logger));</code> </pre> <br><p>  Und jetzt wird bei jedem Aufruf der Klasse die Intercept-Methode der Logger-Klasse aufgerufen. <br>  So k√∂nnen wir unser Leben vereinfachen und nicht zu Beginn jeder Methode einen Protokolleintrag schreiben.  Wir werden es automatisch haben.  Auf Wunsch k√∂nnen wir es f√ºr die gesamte Anwendung leicht √§ndern oder deaktivieren. </p><br><p>  Wir k√∂nnen auch .InterceptedBy (typeof (Logger)) entfernen;  und f√ºgen Sie das Abfangen von Aufrufen nur f√ºr bestimmte Anwendungsdienste mit dem Attribut [Intercept (typeof (Logger))] hinzu - Sie m√ºssen es vor dem Klassenheader angeben. </p><br><h2 id="middleware">  Middleware </h2><br><p>  ASP.NET verf√ºgt √ºber eine bestimmte Kette von Codeaufrufen, die bei jeder Anforderung auftreten.  Noch bevor die UI / MVC geladen wird, werden bestimmte Aktionen ausgef√ºhrt. </p><br><p>  Das hei√üt, wenn wir zum Beispiel am Anfang der Configure-Methode der Startup.cs-Klasse den Code hinzuf√ºgen </p><br><pre> <code class="plaintext hljs"> app.Use(async (context, next) =&gt; { Debug.WriteLine(context.Request.Path); await next.Invoke(); });</code> </pre> <br><p>  Dann k√∂nnen wir in der Debug-Konsole sehen, welche Dateien unsere Anwendungsanforderungen haben.  Tats√§chlich erhalten wir die Funktionen von AOP "out of box" <br>  Ein wenig nutzloses, aber klares und informatives Beispiel f√ºr die Verwendung von Middleware, das ich Ihnen jetzt zeigen werde: </p><br><pre> <code class="plaintext hljs"> public void Configure(IApplicationBuilder app) { app.Use(async (context, next) =&gt; { await context.Response.WriteAsync("Hello!" + Environment.NewLine); await next.Invoke(); }); app.Run(async context =&gt; { await context.Response.WriteAsync("Hello again."); }); }</code> </pre> <br><p>  Mit jeder Anfrage beginnt eine Anrufkette.  Nach dem Aufruf von next.invoke () wird von jeder App aus der √úbergang zum n√§chsten Aufruf ausgef√ºhrt.  Und alles endet nach App.Run funktioniert. <br>  Sie k√∂nnen Code nur ausf√ºhren, wenn Sie auf eine bestimmte Route zugreifen. <br>  Sie k√∂nnen dies mit app.Map tun: </p><br><pre> <code class="plaintext hljs"> private static void Goodbye(IApplicationBuilder app) { app.Run(async context =&gt; { await context.Response.WriteAsync("Goodbye!"); }); } public void Configure(IApplicationBuilder app) { app.Map("/goodbye", Goodbye); app.Run(async context =&gt; { await context.Response.WriteAsync("Hello!"); }); }</code> </pre> <br><p>  Wenn Sie jetzt nur zur Seite der Site gehen, sehen Sie den Text ‚ÄûHallo!‚Äú. Wenn Sie der Adressleiste / Goodbye hinzuf√ºgen, wird Goodbye angezeigt. </p><br><p>  Zus√§tzlich zu Use and Map k√∂nnen Sie UseWhen oder MapWhen verwenden, um der Middleware-Kette nur unter bestimmten Bedingungen Code hinzuzuf√ºgen. </p><br><p>  Bisher gab es noch nutzlose Beispiele, oder?  Hier ist ein normales Beispiel: </p><br><pre> <code class="plaintext hljs"> app.Use(async (context, next) =&gt; { context.Response.Headers.Add("X-Frame-Options", "DENY"); context.Response.Headers.Add("X-Content-Type-Options", "nosniff"); context.Response.Headers.Add("X-Xss-Protection", "1"); await next(); });</code> </pre> <br><p>  Hier f√ºgen wir jeder Anfrage Header hinzu, um die Seite vor Hackerangriffen zu sch√ºtzen. </p><br><p>  Oder hier ein Beispiel f√ºr die Lokalisierung: </p><br><pre> <code class="plaintext hljs"> var supportedCultures = new[] { new CultureInfo("ru"), new CultureInfo("fr") }; app.UseRequestLocalization(new RequestLocalizationOptions { DefaultRequestCulture = new RequestCulture("ru"), SupportedCultures = supportedCultures, SupportedUICultures = supportedCultures });</code> </pre> <br><p>  Wenn Sie nun den Parameter? Culture = fr zur Seitenadresse hinzuf√ºgen, k√∂nnen Sie die Anwendungssprache auf Franz√∂sisch umstellen (wenn Ihrer Anwendung eine Lokalisierung hinzugef√ºgt wird, funktioniert alles). </p><br><h2 id="filters">  Filter </h2><br><p>  Wenn sich die Middleware-Kette auf Prozesse vor MVC bezieht, arbeiten Filter mit MVC zusammen. <br>  Das folgende schematische Diagramm zeigt, wie Filter funktionieren. </p><br><p><img src="https://habrastorage.org/webt/jz/n1/hv/jzn1hvufowfcck24q1-nnl-xbx8.png" alt="Filter"></p><br><p>  Zun√§chst werden Berechtigungsfilter ausgearbeitet.  Das hei√üt,  Sie k√∂nnen eine Art Filter oder mehrere Filter erstellen und in diese eine Art Autorisierungscode eingeben, der bei Anforderungen funktioniert. </p><br><p>  Dann erf√ºllen sie Ressourcenfilter.  Mit diesen Filtern k√∂nnen Sie beispielsweise einige Informationen aus dem Cache zur√ºckgeben. </p><br><p>  Dann erfolgt eine Datenbindung und Aktionsfilter werden ausgef√ºhrt.  Mit ihrer Hilfe k√∂nnen Sie die an Action √ºbergebenen Parameter und das zur√ºckgegebene Ergebnis bearbeiten. </p><br><p>  Mit Ausnahmefiltern, wie der Name andeutet, k√∂nnen Sie eine allgemeine Fehlerbehandlung f√ºr die Anwendung hinzuf√ºgen.  Es sollte ziemlich praktisch sein, Fehler √ºberall gleich zu behandeln.  Eine Art AOP-shny Plus. </p><br><p>  Mit Ergebnisfiltern k√∂nnen Sie vor oder nach der Ausf√ºhrung des Aktionscontrollers eine Aktion ausf√ºhren.  Sie sind den Aktionsfiltern sehr √§hnlich, werden jedoch nur ausgef√ºhrt, wenn keine Fehler vorliegen.  Geeignet f√ºr Logik, die an Ansicht gebunden ist. </p><br><p>       .            : </p><br><pre> <code class="plaintext hljs"> public class YourCustomFilter : Attribute, IAuthorizationFilter { public async void OnAuthorization(AuthorizationFilterContext context) { // -    ,     ,    context.Result = new ContentResult() { Content = "        " }; } }</code> </pre> <br><p>     DI  (   Startup.cs) </p><br><pre> <code class="plaintext hljs"> services.AddScoped&lt;YourCustomFilter&gt;();</code> </pre> <br><p>      -    Action    </p><br><pre> <code class="plaintext hljs"> [ServiceFilter(typeof(YourCustomFilter))]</code> </pre> <br><p>   ‚Äì    middleware    - action   .              Configure </p><br><pre> <code class="plaintext hljs"> public class MyMiddlewareFilter { public void Configure(IApplicationBuilder applicationBuilder) { applicationBuilder.Use(async (context, next) =&gt; { Debug.WriteLine("  middleware!"); await next.Invoke(); }); } }</code> </pre> <br><p>      Action-     </p><br><pre> <code class="plaintext hljs"> [MiddlewareFilter(typeof(MyMiddlewareFilter))]</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/BRKPP1NYCu4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437002/">https://habr.com/ru/post/de437002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436992/index.html">Versuch und Irrtum bei der Auswahl von HTTP Reverse Proxy</a></li>
<li><a href="../de436994/index.html">Liquibase und Maven</a></li>
<li><a href="../de436996/index.html">Abschlusskurs zur Python-Spezialisierung von Mail.ru Group</a></li>
<li><a href="../de436998/index.html">Schutz von Mikrochips vor Reverse Engineering und unbefugtem Betreten</a></li>
<li><a href="../de437000/index.html">Wie man Menschen den Umgang mit Git beibringt</a></li>
<li><a href="../de437004/index.html">Tr√§umen YML-Programmierer von ansiblen Tests?</a></li>
<li><a href="../de437006/index.html">Wanhao Duplicator 10 3D-Drucker Bewertung</a></li>
<li><a href="../de437008/index.html">NLP. Die Grundlagen. Techniken. Selbstentwicklung. Teil 1</a></li>
<li><a href="../de437010/index.html">Echos der Vergangenheit: Young's Erfahrung auf der Basis der neuen R√∂ntgenspektroskopie-Methode</a></li>
<li><a href="../de437014/index.html">Die Aufgabe von N K√∂rpern oder wie man eine Galaxie in die Luft jagt, ohne die K√ºche zu verlassen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>