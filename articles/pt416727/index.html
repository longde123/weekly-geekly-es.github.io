<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòë üßë ü¶å Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 2: ‚ÄúControle de ataques de hackers‚Äù, parte 3 üëÅ‚Äçüó® ü§ûüèª ‚ùáÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula n¬∫ 6.858. "Seguran√ßa de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 2: ‚ÄúControle de ataques de hackers‚Äù, parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416727/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula n¬∫ 6.858.  "Seguran√ßa de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security √© um curso sobre o desenvolvimento e implementa√ß√£o de sistemas de computador seguros.  As palestras abrangem modelos de amea√ßas, ataques que comprometem a seguran√ßa e t√©cnicas de seguran√ßa baseadas em trabalhos cient√≠ficos recentes.  Os t√≥picos incluem seguran√ßa do sistema operacional (SO), recursos, gerenciamento de fluxo de informa√ß√µes, seguran√ßa de idiomas, protocolos de rede, seguran√ßa de hardware e seguran√ßa de aplicativos da web. <br><br>  Palestra 1: ‚ÄúIntrodu√ß√£o: modelos de amea√ßas‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: ‚ÄúControle de ataques de hackers‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Voc√™ pode me dizer qual √© a falta de uma abordagem de seguran√ßa que use uma <b>p√°gina de prote√ß√£o</b> ? <br><br>  <b>P√∫blico:</b> leva mais tempo! <br><br>  <b>Professor:</b> exatamente!  Ent√£o, imagine que essa pilha seja muito, muito pequena, mas selecionei uma p√°gina inteira para garantir que essa coisinha n√£o fosse atacada por um ponteiro.  Esse √© um processo muito intensivo em termos espaciais e as pessoas n√£o implantam algo assim em um ambiente de trabalho.  Isso pode ser √∫til para testar "bugs", mas voc√™ nunca faria isso para um programa real.  Acho que agora voc√™ entende o que √© um depurador de mem√≥ria de <b>cerca el√©trica</b> . <br><br>  <b>P√∫blico:</b> Por que a <b>p√°gina de prote√ß√£o</b> deve ser t√£o grande? <br><br>  <b>Professor: O</b> motivo √© que eles geralmente dependem de hardware, como prote√ß√£o no n√≠vel da p√°gina, para determinar o tamanho da p√°gina.  Para a maioria dos computadores, 2 p√°ginas de 4 KB de tamanho s√£o alocadas para cada buffer alocado, totalizando 8 KB.  Como o heap consiste em objetos, uma p√°gina separada √© alocada para cada fun√ß√£o do <b>malloc</b> .  Em alguns modos, esse depurador n√£o retorna o espa√ßo reservado ao programa, portanto, a <b>cerca el√©trica √©</b> muito voraz em termos de mem√≥ria e n√£o deve ser compilada com o c√≥digo em funcionamento. <br><br><img src="https://habrastorage.org/webt/cm/l6/oh/cml6ohlrz3im72yoa5u_6n9pomg.jpeg"><br><br>  Outra abordagem de seguran√ßa que vale a pena dar uma olhada √© chamada <b>ponteiros de gordura</b> , ou "ponteiros grossos".  Nesse caso, o termo ‚Äúgrosso‚Äù significa que uma grande quantidade de dados √© anexada ao ponteiro.  Nesse caso, a id√©ia √© que queremos alterar a pr√≥pria representa√ß√£o do ponteiro para incluir informa√ß√µes sobre os limites em sua composi√ß√£o. <br><br>  Um ponteiro regular de 32 bits consiste em 32 bits e os endere√ßos est√£o localizados dentro dele.  Se considerarmos o "ponteiro grosso", ele consiste em 3 partes.  A primeira parte √© uma base de 4 bytes, √† qual tamb√©m est√° anexado um final de 4 bytes.  Na primeira parte, o objeto come√ßa, na segunda termina e, na terceira, tamb√©m com 4 bytes, o endere√ßo <b>cur √©</b> inclu√≠do.  E dentro desses limites comuns h√° um ponteiro. <br><br><img src="https://habrastorage.org/webt/jd/2o/83/jd2o83flkobiu3caqetom5wpwj8.jpeg"><br><br>  Portanto, quando o compilador gera um c√≥digo de acesso para esse "ponteiro espesso", ele atualiza o conte√∫do da √∫ltima parte do <b>endere√ßo cur</b> e verifica simultaneamente o conte√∫do das duas primeiras partes para garantir que nada de ruim tenha acontecido com o ponteiro durante o processo de atualiza√ß√£o. <br><br>  Imagine que eu tenho esse c√≥digo: <b>int * ptr = malloc (8)</b> , este √© um ponteiro para o qual 8 bytes s√£o alocados.  Em seguida, tenho um <b>loop while</b> que est√° prestes a atribuir algum valor ao ponteiro e, a seguir, o incremento do ponteiro <b>ptr ++</b> .  Cada vez que esse c√≥digo √© executado no endere√ßo atual do ponteiro de endere√ßo atual, ele verifica se o ponteiro est√° dentro dos limites especificados na primeira e na segunda partes. <br><br>  Este √© o caso no novo c√≥digo que o compilador gera.  Um grupo on-line geralmente levanta a quest√£o do que √© "c√≥digo de ferramenta".  Este √© o c√≥digo que o compilador gera.  Voc√™, como programador, v√™ apenas o que √© mostrado √† direita - essas 4 linhas.  Por√©m, antes dessa opera√ß√£o, o compilador insere um novo c√≥digo C no <b>endere√ßo atual</b> , atribui um valor ao ponteiro e verifica os limites a cada vez. <br><br><img src="https://habrastorage.org/webt/w7/am/vx/w7amvxvkol7dhdi3qdrpkupsgga.jpeg"><br><br>  E se, ao usar o novo c√≥digo, o valor ultrapassar os limites, a fun√ß√£o ser√° interrompida.  Isso √© chamado de "c√≥digo da ferramenta".  Isso significa que voc√™ pega o c√≥digo-fonte usando um programa C, adiciona o novo c√≥digo-fonte C e compila o novo programa.  Portanto, a id√©ia b√°sica por tr√°s dos <b>indicadores Fat</b> √© bastante simples. <br><br>  Existem algumas desvantagens nessa abordagem.  A maior desvantagem √© o tamanho grande do ponteiro.  E isso significa que voc√™ n√£o pode simplesmente pegar o "ponteiro grosso" e pass√°-lo inalterado, para fora da biblioteca de shell.  Porque pode haver uma expectativa de que o ponteiro tenha um tamanho padr√£o e o programa forne√ßa esse tamanho, no qual ele "n√£o se encaixa", por causa do qual tudo explodir√°.  Tamb√©m existem problemas se voc√™ deseja incluir ponteiros desse tipo em uma <b>estrutura</b> ou algo parecido, porque eles podem redimensionar a <b>estrutura</b> . <br><br>  Portanto, uma coisa muito popular no c√≥digo C √© pegar algo do tamanho de uma <b>estrutura</b> e, em seguida, fazer algo com base nesse tamanho - reservar espa√ßo em disco para estruturas desse tamanho e assim por diante. <br><br>  E uma coisa mais delicada √© que esses indicadores, como regra, n√£o podem ser atualizados de maneira at√¥mica.  Para arquiteturas de 32 bits, √© t√≠pico escrever uma vari√°vel de 32 bits at√¥mica.  Mas ‚Äúponteiros grossos‚Äù cont√™m 3 tamanhos <b>inteiros</b> ; portanto, se voc√™ tiver um c√≥digo que espere que o ponteiro tenha um valor at√¥mico, poder√° ter problemas.  Porque, para fazer algumas dessas verifica√ß√µes, √© necess√°rio examinar o endere√ßo atual e, em seguida, os tamanhos, e talvez seja necess√°rio aument√°-los, e assim por diante.  Portanto, isso pode causar erros muito sutis se voc√™ usar c√≥digo que tenta desenhar paralelos entre ponteiros regulares e grossos.  Assim, voc√™ pode usar <b>ponteiros de gordura</b> em alguns casos, como <b>cercas Electroc</b> , mas os efeitos colaterais de seu uso s√£o t√£o significativos que, na pr√°tica normal, essas abordagens n√£o s√£o usadas. <br><br>  E agora falaremos sobre a verifica√ß√£o de limites em rela√ß√£o √† estrutura dos dados de sombra.  A id√©ia principal da estrutura √© que voc√™ saiba o tamanho de cada objeto que voc√™ vai colocar, ou seja, o tamanho que voc√™ precisa reservar para esse objeto.  Portanto, por exemplo, se voc√™ tiver um ponteiro que chame com a fun√ß√£o <b>malloc</b> , precisar√° especificar o tamanho do objeto: <b>char xp = malloc (size)</b> . <br><br><img src="https://habrastorage.org/webt/40/5x/vq/405xvqrcdftphffsqkxgqxprhfo.jpeg"><br><br>  Se voc√™ tem algo parecido com uma vari√°vel est√°tica como este <b>char p [256]</b> , o compilador pode descobrir automaticamente quais devem ser os limites para sua localiza√ß√£o. <br><br>  Portanto, para cada um desses ponteiros, √© necess√°rio inserir duas opera√ß√µes.  Isso √© principalmente aritm√©tico, como <b>q = p + 7</b> , ou algo semelhante.  Essa inser√ß√£o √© feita desreferenciando um link do tipo <b>deref * q = 'q'</b> .  Voc√™ pode se perguntar por que n√£o pode confiar no link ao colar?  Por que precisamos fazer essas aritm√©ticas?  O fato √© que, ao usar C e c ++, voc√™ tem um ponteiro apontando para uma passagem para o final v√°lido do objeto √† direita, ap√≥s o qual √© usado como uma condi√ß√£o de parada.  Ent√£o, voc√™ vai para o objeto e, assim que alcan√ßa esse ponteiro final, na verdade para o loop ou interrompe a opera√ß√£o. <br><br>  Portanto, se ignorarmos a aritm√©tica, sempre causamos um erro grave, no qual o ponteiro vai al√©m dos limites, o que pode realmente atrapalhar o trabalho de muitas aplica√ß√µes.  Portanto, n√£o podemos simplesmente inserir o link, porque como voc√™ sabe que isso acontece fora dos limites estabelecidos?  A aritm√©tica nos permite dizer se √© ou n√£o, e aqui tudo ser√° legal e correto.  Como essa cunha usando aritm√©tica permite rastrear onde o ponteiro est√° localizado em rela√ß√£o √† sua linha de base original. <br><br>  Portanto, a pr√≥xima pergunta √©: como realmente implementamos a valida√ß√£o de borda?  Porque precisamos de alguma forma corresponder o endere√ßo espec√≠fico do ponteiro com algum tipo de informa√ß√£o de limite para esse ponteiro.  E, portanto, muitas de suas decis√µes anteriores usam coisas como, por exemplo, uma tabela de hash ou uma √°rvore, o que permite realizar a pesquisa correta.  Portanto, dado o endere√ßo do ponteiro, fa√ßo algumas pesquisas nessa estrutura de dados e descubro quais limites ele possui.  Dadas essas fronteiras, decido se posso deixar a a√ß√£o acontecer ou n√£o.  O problema √© que essa √© uma pesquisa lenta, porque essas estruturas de dados est√£o se ramificando e, ao examinar uma √°rvore, voc√™ precisa examinar v√°rias dessas ramifica√ß√µes at√© encontrar o valor certo.  E mesmo que seja uma tabela de hash, voc√™ deve seguir as cadeias de c√≥digo e assim por diante.  Portanto, precisamos definir uma estrutura de dados muito eficaz que rastreie seus limites, uma que tornaria essa verifica√ß√£o muito simples e clara.  Ent√£o, vamos ao que interessa agora. <br><br>  Mas, antes de fazer isso, deixe-me falar brevemente sobre como a abordagem de <b>aloca√ß√£o de mem√≥ria de amigos</b> funciona.  Porque essa √© uma das coisas que costumamos fazer. <br>  <b>A aloca√ß√£o de mem√≥ria de amigos</b> divide a mem√≥ria em parti√ß√µes com um poder m√∫ltiplo de 2 e tenta alocar solicita√ß√µes de mem√≥ria nelas.  Vamos ver como isso funciona.  No in√≠cio, a <b>aloca√ß√£o de amigos</b> trata a mem√≥ria n√£o alocada como um grande bloco - esse √© o ret√¢ngulo superior de 128 bits.  Em seguida, quando voc√™ solicita um bloco menor para aloca√ß√£o din√¢mica, ele tenta dividir esse espa√ßo de endere√ßo em partes em incrementos de 2 at√© encontrar um bloco suficiente para suas necessidades. <br><br>  Suponha que uma solicita√ß√£o do tipo <b>a = malloc (28)</b> chegou, ou seja, uma solicita√ß√£o para alocar 28 bytes.  Temos um bloco de 128 bytes que √© desperd√≠cio demais para ser alocado para esta solicita√ß√£o.  Portanto, nosso bloco √© dividido em dois blocos de 64 bytes - de 0 a 64 bytes e de 64 bytes a 128 bytes.  E esse tamanho tamb√©m √© grande para nossa solicita√ß√£o, portanto, o <b>buddy</b> divide novamente um bloco de 64 bytes em 2 partes e recebe 2 blocos de 32 bytes. <br><br><img src="https://habrastorage.org/webt/uj/mt/er/ujmter8tqrakf5gu4pel0v8eawc.jpeg"><br><br>  Menos √© imposs√≠vel, porque 28 bytes n√£o cabem e 32 √© o tamanho m√≠nimo mais adequado.  Ent√£o agora esse bloco de 32 bytes ser√° alocado para o nosso endere√ßo a.  Suponha que tenhamos outra consulta para <b>b = malloc (50)</b> .  <b>O amigo</b> verifica os blocos selecionados e, como 50 √© maior que a metade de 64, mas menor que 64, coloca o valor b no bloco mais √† direita. <br><br>  Finalmente, temos outra solicita√ß√£o de 20 bytes: <b>c = malloc (20)</b> , esse valor √© colocado no bloco do meio. <br><br><img src="https://habrastorage.org/webt/mu/zh/cm/muzhcmr1dbp7u7fhz6myj4d1iom.jpeg"><br><br>  <b>O Buddy</b> tem uma propriedade interessante: quando voc√™ libera mem√≥ria em um bloco e ao lado dele √© um bloco do mesmo tamanho, ap√≥s liberar os dois blocos, o <b>buddy</b> combina dois blocos vizinhos vazios em um. <br><br><img src="https://habrastorage.org/webt/72/0z/9t/720z9tqbxfmo-umch8rnd9uffry.jpeg"><br><br>  Por exemplo, quando dermos o comando <b>free ¬©</b> , <b>liberaremos o</b> bloco <b>do</b> meio, mas a uni√£o n√£o ocorrer√°; portanto, o bloco ao lado ainda estar√° ocupado.  Por√©m, ap√≥s liberar o primeiro bloco usando o comando <b>free (a)</b> , os dois blocos ser√£o mesclados em um.  Ent√£o, se liberarmos o valor de b, os blocos vizinhos ser√£o mesclados novamente e obteremos um bloco inteiro de 128 bytes de tamanho, como era no come√ßo.  A vantagem dessa abordagem √© que voc√™ pode encontrar facilmente onde est√° o amigo atrav√©s de uma aritm√©tica simples e determinar os limites da mem√≥ria.  √â assim que a aloca√ß√£o de mem√≥ria funciona com a abordagem de <b>aloca√ß√£o de mem√≥ria</b> do <b>Buddy</b> . <br><br>  Todas as minhas palestras costumam ser feitas, n√£o √© uma abordagem t√£o in√∫til?  Imagine que, no in√≠cio, eu tinha um pedido de 65 bytes, teria que alocar todo o bloco de 128 bytes para ele.  Sim, isso √© um desperd√≠cio, na verdade voc√™ n√£o possui mem√≥ria din√¢mica e n√£o pode mais alocar recursos no mesmo bloco.  Mas, novamente, isso √© um compromisso, porque √© muito f√°cil fazer um c√°lculo, como fazer uma fus√£o e coisas assim.  Portanto, se voc√™ quiser uma aloca√ß√£o de mem√≥ria mais precisa, precisar√° usar uma abordagem diferente. <br><br>  Ent√£o, o que o <b>sistema de verifica√ß√£o de rejei√ß√£o de buggy (BBC)</b> faz? <br><br><img src="https://habrastorage.org/webt/bw/ps/a9/bwpsa9a28xloyxprpcco0vw79ca.jpeg"><br><br>  Ela realiza v√°rios truques, um dos quais √© a separa√ß√£o do bloco de mem√≥ria em duas partes, uma das quais cont√©m um objeto e a segunda √© uma adi√ß√£o a ele.  Assim, temos 2 tipos de limites - os limites do objeto e os limites da distribui√ß√£o da mem√≥ria.  A vantagem √© que n√£o h√° necessidade de armazenar o endere√ßo base, e √© poss√≠vel uma pesquisa r√°pida usando uma tabela de linhas. <br><br>  Todos os nossos tamanhos de distribui√ß√£o s√£o 2 √† pot√™ncia de <b>n</b> , onde <b>n</b> √© um n√∫mero inteiro.  Esse princ√≠pio <b>2n</b> √© chamado de <b>pot√™ncia de dois</b> .  Portanto, n√£o precisamos de muitos bits para imaginar o tamanho de um determinado tamanho de distribui√ß√£o.  Por exemplo, se o tamanho do cluster for 16, basta selecionar 4 bits - este √© o conceito de um logaritmo, ou seja, 4 √© um expoente de <b>n</b> , no qual voc√™ precisa aumentar o n√∫mero 2 para obter 16. <br><br>  Essa √© uma abordagem bastante econ√¥mica para aloca√ß√£o de mem√≥ria, porque o n√∫mero m√≠nimo de bytes √© usado, mas deve ser um m√∫ltiplo de 2, ou seja, voc√™ pode ter 16 ou 32, mas n√£o 33 bytes.  Al√©m disso, a <b>verifica√ß√£o de rejei√ß√£o do Buggy</b> permite armazenar informa√ß√µes sobre valores de limite em uma matriz linear (1 byte por registro) e permite alocar mem√≥ria em 1 slot com um tamanho de 16 bytes.  alocar mem√≥ria com granularidade de slot.  O que isso significa? <br><br><img src="https://habrastorage.org/webt/3w/26/nm/3w26nmli9ja80jxthanvcktdhqq.jpeg"><br><br>  Se tivermos um slot de 16 bytes onde colocaremos o valor <b>p = malloc (16)</b> , o valor na tabela ser√° semelhante √† <b>tabela [p / slot.size] = 4</b> . <br><br><img src="https://habrastorage.org/webt/al/x7/vj/alx7vjrhny1zzkkjusqvt3iuv3c.jpeg"><br><br>  Suponha que agora precisamos colocar um valor de 32 bytes no tamanho <b>p = malloc (32)</b> .  Precisamos atualizar a tabela de borda para corresponder ao novo tamanho.  E isso √© feito duas vezes: primeiro como <b>tabela [p / slot.size] = 5</b> e, em seguida, como <b>tabela [(p / slot.size) + 1] = 5</b> - a primeira vez no primeiro slot, que est√° alocado para essa mem√≥ria, e o segundo vezes - para o segundo slot.  Assim, alocamos 32 bytes de mem√≥ria.  √â assim que o log de distribui√ß√£o de tamanho se parece.  Portanto, para dois slots de aloca√ß√£o de mem√≥ria, a tabela de limites √© atualizada duas vezes.  Isso est√° claro?  Este exemplo √© destinado a pessoas que duvidam que logs e tabelas tenham um significado ou n√£o.  Como as tabelas s√£o multiplicadas toda vez que ocorre a aloca√ß√£o de mem√≥ria. <br><br>  Vamos ver o que acontece com a tabela de borda.  Suponha que tenhamos um c√≥digo C que se parece com isso: <b>p '= p + i</b> , ou seja, o ponteiro <b>p' √©</b> obtido de <b>p</b> adicionando alguma vari√°vel <b>i</b> .  Ent√£o, como obtemos o tamanho da mem√≥ria alocado para <b>p</b> ?  Para fazer isso, voc√™ olha para a tabela usando as seguintes condi√ß√µes l√≥gicas: <br><br>  <b>size = 1 &lt;&lt; tabela [p &gt;&gt; log de slot_size]</b> <br><br><img src="https://habrastorage.org/webt/bo/pw/nv/bopwnvj0ek93xhrzu4vqwhcqcf8.jpeg"><br><br>  √Ä direita, temos o tamanho dos dados alocados para <b>p</b> , que deve ser 1. Em seguida, voc√™ os move para a esquerda e olha para a tabela, pega esse tamanho de ponteiro e depois para a direita, onde est√° localizado o log da tabela de tamanho de slot.  Se a aritm√©tica funcionar, vincularemos corretamente o ponteiro √† tabela de borda.  Ou seja, o tamanho do ponteiro deve ser maior que 1, mas menor que o tamanho do slot.  √Ä esquerda, temos o valor, e √† direita - o tamanho do slot e o valor do ponteiro est√° localizado entre eles. <br><br>  Suponha que o tamanho do ponteiro seja 32 bytes e, na tabela, dentro dos colchetes, teremos o n√∫mero 5. <br><br>  Suponha que desejemos encontrar a palavra-chave base desse ponteiro: <b>base = p &amp; n (tamanho - 1)</b> .  O que vamos fazer nos d√° uma certa massa, e essa massa nos permitir√° restaurar a <b>base</b> localizada aqui.  Imagine que nosso tamanho √© 16, em bin√°rio √© 16 = ... 0010000.  As retic√™ncias significam que ainda existem muitos zeros, mas estamos interessados ‚Äã‚Äãnesta unidade e nos zeros atr√°s dela.  Se considerarmos (16 -1), ser√° algo assim: (16 - 1) = ... 0001111.  No c√≥digo bin√°rio, o inverso disso ser√° assim: ~ (16-1) ... 1110000. <br><br><img src="https://habrastorage.org/webt/8q/yj/xz/8qyjxz4dqge5f0oygbg1bhszkks.jpeg"><br><br><img src="https://habrastorage.org/webt/ue/2h/hb/ue2hhb2uzpelqgvzpmzi75c6-mo.jpeg"><br><br>  Assim, isso nos permite limpar basicamente o bit, que ser√° essencialmente renderizado a partir do ponteiro atual e nos dar√° sua <b>base</b> .  Gra√ßas a isso, ser√° muito simples verificar se esse ponteiro est√° dentro dos limites.  Portanto, podemos simplesmente verificar se <b>(p ')&gt; = base</b> e se o valor ( <b>p'</b> - base) √© menor que o tamanho selecionado. <br><br><img src="https://habrastorage.org/webt/x6/w8/il/x6w8ilmsiya6i3irbyat6nd51cy.jpeg"><br><br>  √â uma coisa bastante simples de descobrir se o ponteiro est√° dentro dos limites de mem√≥ria.  N√£o vou entrar em detalhes, basta dizer que toda aritm√©tica bin√°ria √© resolvida da mesma maneira.  Esses truques permitem evitar c√°lculos mais complexos. <br><br>  H√° mais uma quinta propriedade da <b>verifica√ß√£o de rejei√ß√£o</b> do <b>Buggy</b> - ela usa um sistema de mem√≥ria virtual para evitar ultrapassar os limites definidos para o ponteiro.  A id√©ia principal √© que, se tivermos uma aritm√©tica para o ponteiro com a qual determinamos a sa√≠da, podemos definir um bit de ordem superior para o ponteiro. <br><br><img src="https://habrastorage.org/webt/ns/56/tz/ns56tz8drovqvtuwnrsc6qanksc.jpeg"><br><br>  Ao fazer isso, garantimos que a exclus√£o da refer√™ncia do ponteiro n√£o causar√° problemas de hardware.  Definir o <b>bit de ordem alta</b> por si s√≥ n√£o causa problemas; a desreferencia√ß√£o do ponteiro pode causar um problema. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/r4KjHEgg9Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  A vers√£o completa do curso est√° dispon√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Obrigado por ficar conosco.  Voc√™ gosta dos nossos artigos?  Deseja ver materiais mais interessantes?  Ajude-nos fazendo um pedido ou recomendando a seus amigos, um <b>desconto de 30% para os usu√°rios da Habr em um an√°logo exclusivo de servidores b√°sicos que inventamos para voc√™:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Toda a verdade sobre o VPS (KVM) E5-2650 v4 (6 n√∫cleos) 10GB DDR4 240GB SSD 1Gbps de US $ 20 ou como dividir o servidor?</a>  (as op√ß√µes est√£o dispon√≠veis com RAID1 e RAID10, at√© 24 n√∫cleos e at√© 40GB DDR4). <br><br>  <b>Dell R730xd 2 vezes mais barato?</b>  Somente n√≥s temos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2 TVs Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 a partir de US $ 249</a> na Holanda e nos EUA!</b>  Leia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como criar um pr√©dio de infraestrutura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe usando servidores Dell R730xd E5-2650 v4 custando 9.000 euros por um centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416727/">https://habr.com/ru/post/pt416727/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416713/index.html">Relat√≥rio do Clube de Roma 2018, cap√≠tulo 3.14: ‚ÄúNem um √∫nico PIB ...‚Äù</a></li>
<li><a href="../pt416719/index.html">Extens√£o PHP e Kotlin Native. Parte Dois, Consciente</a></li>
<li><a href="../pt416721/index.html">DIY House: casas de boneca para adultos</a></li>
<li><a href="../pt416723/index.html">Acessibilidade da API: interfaces de linguagem natural</a></li>
<li><a href="../pt416725/index.html">Kotlin DSL: Teoria e Pr√°tica</a></li>
<li><a href="../pt416729/index.html">O programa PYCON RUSSIA est√° pronto: 25 relat√≥rios e 3 workshops de palestrantes do Google, Red Hat, Yelp, Yandex</a></li>
<li><a href="../pt416731/index.html">Frost on glass: como fazer pl√°stico metglass resistente</a></li>
<li><a href="../pt416737/index.html">A * Path Finding Algorithm em um jogo Voxel 3d Unity</a></li>
<li><a href="../pt416739/index.html">Novo ASUS na Computex 2018</a></li>
<li><a href="../pt416741/index.html">Os invasores usavam certificados D-Link roubados em seu software de roubo de senha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>