<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😑 🧑 🦌 Curso MIT "Segurança de sistemas de computadores". Palestra 2: “Controle de ataques de hackers”, parte 3 👁‍🗨 🤞🏻 ❇️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula nº 6.858. "Segurança de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Segurança de sistemas de computadores". Palestra 2: “Controle de ataques de hackers”, parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416727/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula nº 6.858.  "Segurança de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security é um curso sobre o desenvolvimento e implementação de sistemas de computador seguros.  As palestras abrangem modelos de ameaças, ataques que comprometem a segurança e técnicas de segurança baseadas em trabalhos científicos recentes.  Os tópicos incluem segurança do sistema operacional (SO), recursos, gerenciamento de fluxo de informações, segurança de idiomas, protocolos de rede, segurança de hardware e segurança de aplicativos da web. <br><br>  Palestra 1: “Introdução: modelos de ameaças” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: “Controle de ataques de hackers” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Você pode me dizer qual é a falta de uma abordagem de segurança que use uma <b>página de proteção</b> ? <br><br>  <b>Público:</b> leva mais tempo! <br><br>  <b>Professor:</b> exatamente!  Então, imagine que essa pilha seja muito, muito pequena, mas selecionei uma página inteira para garantir que essa coisinha não fosse atacada por um ponteiro.  Esse é um processo muito intensivo em termos espaciais e as pessoas não implantam algo assim em um ambiente de trabalho.  Isso pode ser útil para testar "bugs", mas você nunca faria isso para um programa real.  Acho que agora você entende o que é um depurador de memória de <b>cerca elétrica</b> . <br><br>  <b>Público:</b> Por que a <b>página de proteção</b> deve ser tão grande? <br><br>  <b>Professor: O</b> motivo é que eles geralmente dependem de hardware, como proteção no nível da página, para determinar o tamanho da página.  Para a maioria dos computadores, 2 páginas de 4 KB de tamanho são alocadas para cada buffer alocado, totalizando 8 KB.  Como o heap consiste em objetos, uma página separada é alocada para cada função do <b>malloc</b> .  Em alguns modos, esse depurador não retorna o espaço reservado ao programa, portanto, a <b>cerca elétrica é</b> muito voraz em termos de memória e não deve ser compilada com o código em funcionamento. <br><br><img src="https://habrastorage.org/webt/cm/l6/oh/cml6ohlrz3im72yoa5u_6n9pomg.jpeg"><br><br>  Outra abordagem de segurança que vale a pena dar uma olhada é chamada <b>ponteiros de gordura</b> , ou "ponteiros grossos".  Nesse caso, o termo “grosso” significa que uma grande quantidade de dados é anexada ao ponteiro.  Nesse caso, a idéia é que queremos alterar a própria representação do ponteiro para incluir informações sobre os limites em sua composição. <br><br>  Um ponteiro regular de 32 bits consiste em 32 bits e os endereços estão localizados dentro dele.  Se considerarmos o "ponteiro grosso", ele consiste em 3 partes.  A primeira parte é uma base de 4 bytes, à qual também está anexado um final de 4 bytes.  Na primeira parte, o objeto começa, na segunda termina e, na terceira, também com 4 bytes, o endereço <b>cur é</b> incluído.  E dentro desses limites comuns há um ponteiro. <br><br><img src="https://habrastorage.org/webt/jd/2o/83/jd2o83flkobiu3caqetom5wpwj8.jpeg"><br><br>  Portanto, quando o compilador gera um código de acesso para esse "ponteiro espesso", ele atualiza o conteúdo da última parte do <b>endereço cur</b> e verifica simultaneamente o conteúdo das duas primeiras partes para garantir que nada de ruim tenha acontecido com o ponteiro durante o processo de atualização. <br><br>  Imagine que eu tenho esse código: <b>int * ptr = malloc (8)</b> , este é um ponteiro para o qual 8 bytes são alocados.  Em seguida, tenho um <b>loop while</b> que está prestes a atribuir algum valor ao ponteiro e, a seguir, o incremento do ponteiro <b>ptr ++</b> .  Cada vez que esse código é executado no endereço atual do ponteiro de endereço atual, ele verifica se o ponteiro está dentro dos limites especificados na primeira e na segunda partes. <br><br>  Este é o caso no novo código que o compilador gera.  Um grupo on-line geralmente levanta a questão do que é "código de ferramenta".  Este é o código que o compilador gera.  Você, como programador, vê apenas o que é mostrado à direita - essas 4 linhas.  Porém, antes dessa operação, o compilador insere um novo código C no <b>endereço atual</b> , atribui um valor ao ponteiro e verifica os limites a cada vez. <br><br><img src="https://habrastorage.org/webt/w7/am/vx/w7amvxvkol7dhdi3qdrpkupsgga.jpeg"><br><br>  E se, ao usar o novo código, o valor ultrapassar os limites, a função será interrompida.  Isso é chamado de "código da ferramenta".  Isso significa que você pega o código-fonte usando um programa C, adiciona o novo código-fonte C e compila o novo programa.  Portanto, a idéia básica por trás dos <b>indicadores Fat</b> é bastante simples. <br><br>  Existem algumas desvantagens nessa abordagem.  A maior desvantagem é o tamanho grande do ponteiro.  E isso significa que você não pode simplesmente pegar o "ponteiro grosso" e passá-lo inalterado, para fora da biblioteca de shell.  Porque pode haver uma expectativa de que o ponteiro tenha um tamanho padrão e o programa forneça esse tamanho, no qual ele "não se encaixa", por causa do qual tudo explodirá.  Também existem problemas se você deseja incluir ponteiros desse tipo em uma <b>estrutura</b> ou algo parecido, porque eles podem redimensionar a <b>estrutura</b> . <br><br>  Portanto, uma coisa muito popular no código C é pegar algo do tamanho de uma <b>estrutura</b> e, em seguida, fazer algo com base nesse tamanho - reservar espaço em disco para estruturas desse tamanho e assim por diante. <br><br>  E uma coisa mais delicada é que esses indicadores, como regra, não podem ser atualizados de maneira atômica.  Para arquiteturas de 32 bits, é típico escrever uma variável de 32 bits atômica.  Mas “ponteiros grossos” contêm 3 tamanhos <b>inteiros</b> ; portanto, se você tiver um código que espere que o ponteiro tenha um valor atômico, poderá ter problemas.  Porque, para fazer algumas dessas verificações, é necessário examinar o endereço atual e, em seguida, os tamanhos, e talvez seja necessário aumentá-los, e assim por diante.  Portanto, isso pode causar erros muito sutis se você usar código que tenta desenhar paralelos entre ponteiros regulares e grossos.  Assim, você pode usar <b>ponteiros de gordura</b> em alguns casos, como <b>cercas Electroc</b> , mas os efeitos colaterais de seu uso são tão significativos que, na prática normal, essas abordagens não são usadas. <br><br>  E agora falaremos sobre a verificação de limites em relação à estrutura dos dados de sombra.  A idéia principal da estrutura é que você saiba o tamanho de cada objeto que você vai colocar, ou seja, o tamanho que você precisa reservar para esse objeto.  Portanto, por exemplo, se você tiver um ponteiro que chame com a função <b>malloc</b> , precisará especificar o tamanho do objeto: <b>char xp = malloc (size)</b> . <br><br><img src="https://habrastorage.org/webt/40/5x/vq/405xvqrcdftphffsqkxgqxprhfo.jpeg"><br><br>  Se você tem algo parecido com uma variável estática como este <b>char p [256]</b> , o compilador pode descobrir automaticamente quais devem ser os limites para sua localização. <br><br>  Portanto, para cada um desses ponteiros, é necessário inserir duas operações.  Isso é principalmente aritmético, como <b>q = p + 7</b> , ou algo semelhante.  Essa inserção é feita desreferenciando um link do tipo <b>deref * q = 'q'</b> .  Você pode se perguntar por que não pode confiar no link ao colar?  Por que precisamos fazer essas aritméticas?  O fato é que, ao usar C e c ++, você tem um ponteiro apontando para uma passagem para o final válido do objeto à direita, após o qual é usado como uma condição de parada.  Então, você vai para o objeto e, assim que alcança esse ponteiro final, na verdade para o loop ou interrompe a operação. <br><br>  Portanto, se ignorarmos a aritmética, sempre causamos um erro grave, no qual o ponteiro vai além dos limites, o que pode realmente atrapalhar o trabalho de muitas aplicações.  Portanto, não podemos simplesmente inserir o link, porque como você sabe que isso acontece fora dos limites estabelecidos?  A aritmética nos permite dizer se é ou não, e aqui tudo será legal e correto.  Como essa cunha usando aritmética permite rastrear onde o ponteiro está localizado em relação à sua linha de base original. <br><br>  Portanto, a próxima pergunta é: como realmente implementamos a validação de borda?  Porque precisamos de alguma forma corresponder o endereço específico do ponteiro com algum tipo de informação de limite para esse ponteiro.  E, portanto, muitas de suas decisões anteriores usam coisas como, por exemplo, uma tabela de hash ou uma árvore, o que permite realizar a pesquisa correta.  Portanto, dado o endereço do ponteiro, faço algumas pesquisas nessa estrutura de dados e descubro quais limites ele possui.  Dadas essas fronteiras, decido se posso deixar a ação acontecer ou não.  O problema é que essa é uma pesquisa lenta, porque essas estruturas de dados estão se ramificando e, ao examinar uma árvore, você precisa examinar várias dessas ramificações até encontrar o valor certo.  E mesmo que seja uma tabela de hash, você deve seguir as cadeias de código e assim por diante.  Portanto, precisamos definir uma estrutura de dados muito eficaz que rastreie seus limites, uma que tornaria essa verificação muito simples e clara.  Então, vamos ao que interessa agora. <br><br>  Mas, antes de fazer isso, deixe-me falar brevemente sobre como a abordagem de <b>alocação de memória de amigos</b> funciona.  Porque essa é uma das coisas que costumamos fazer. <br>  <b>A alocação de memória de amigos</b> divide a memória em partições com um poder múltiplo de 2 e tenta alocar solicitações de memória nelas.  Vamos ver como isso funciona.  No início, a <b>alocação de amigos</b> trata a memória não alocada como um grande bloco - esse é o retângulo superior de 128 bits.  Em seguida, quando você solicita um bloco menor para alocação dinâmica, ele tenta dividir esse espaço de endereço em partes em incrementos de 2 até encontrar um bloco suficiente para suas necessidades. <br><br>  Suponha que uma solicitação do tipo <b>a = malloc (28)</b> chegou, ou seja, uma solicitação para alocar 28 bytes.  Temos um bloco de 128 bytes que é desperdício demais para ser alocado para esta solicitação.  Portanto, nosso bloco é dividido em dois blocos de 64 bytes - de 0 a 64 bytes e de 64 bytes a 128 bytes.  E esse tamanho também é grande para nossa solicitação, portanto, o <b>buddy</b> divide novamente um bloco de 64 bytes em 2 partes e recebe 2 blocos de 32 bytes. <br><br><img src="https://habrastorage.org/webt/uj/mt/er/ujmter8tqrakf5gu4pel0v8eawc.jpeg"><br><br>  Menos é impossível, porque 28 bytes não cabem e 32 é o tamanho mínimo mais adequado.  Então agora esse bloco de 32 bytes será alocado para o nosso endereço a.  Suponha que tenhamos outra consulta para <b>b = malloc (50)</b> .  <b>O amigo</b> verifica os blocos selecionados e, como 50 é maior que a metade de 64, mas menor que 64, coloca o valor b no bloco mais à direita. <br><br>  Finalmente, temos outra solicitação de 20 bytes: <b>c = malloc (20)</b> , esse valor é colocado no bloco do meio. <br><br><img src="https://habrastorage.org/webt/mu/zh/cm/muzhcmr1dbp7u7fhz6myj4d1iom.jpeg"><br><br>  <b>O Buddy</b> tem uma propriedade interessante: quando você libera memória em um bloco e ao lado dele é um bloco do mesmo tamanho, após liberar os dois blocos, o <b>buddy</b> combina dois blocos vizinhos vazios em um. <br><br><img src="https://habrastorage.org/webt/72/0z/9t/720z9tqbxfmo-umch8rnd9uffry.jpeg"><br><br>  Por exemplo, quando dermos o comando <b>free ©</b> , <b>liberaremos o</b> bloco <b>do</b> meio, mas a união não ocorrerá; portanto, o bloco ao lado ainda estará ocupado.  Porém, após liberar o primeiro bloco usando o comando <b>free (a)</b> , os dois blocos serão mesclados em um.  Então, se liberarmos o valor de b, os blocos vizinhos serão mesclados novamente e obteremos um bloco inteiro de 128 bytes de tamanho, como era no começo.  A vantagem dessa abordagem é que você pode encontrar facilmente onde está o amigo através de uma aritmética simples e determinar os limites da memória.  É assim que a alocação de memória funciona com a abordagem de <b>alocação de memória</b> do <b>Buddy</b> . <br><br>  Todas as minhas palestras costumam ser feitas, não é uma abordagem tão inútil?  Imagine que, no início, eu tinha um pedido de 65 bytes, teria que alocar todo o bloco de 128 bytes para ele.  Sim, isso é um desperdício, na verdade você não possui memória dinâmica e não pode mais alocar recursos no mesmo bloco.  Mas, novamente, isso é um compromisso, porque é muito fácil fazer um cálculo, como fazer uma fusão e coisas assim.  Portanto, se você quiser uma alocação de memória mais precisa, precisará usar uma abordagem diferente. <br><br>  Então, o que o <b>sistema de verificação de rejeição de buggy (BBC)</b> faz? <br><br><img src="https://habrastorage.org/webt/bw/ps/a9/bwpsa9a28xloyxprpcco0vw79ca.jpeg"><br><br>  Ela realiza vários truques, um dos quais é a separação do bloco de memória em duas partes, uma das quais contém um objeto e a segunda é uma adição a ele.  Assim, temos 2 tipos de limites - os limites do objeto e os limites da distribuição da memória.  A vantagem é que não há necessidade de armazenar o endereço base, e é possível uma pesquisa rápida usando uma tabela de linhas. <br><br>  Todos os nossos tamanhos de distribuição são 2 à potência de <b>n</b> , onde <b>n</b> é um número inteiro.  Esse princípio <b>2n</b> é chamado de <b>potência de dois</b> .  Portanto, não precisamos de muitos bits para imaginar o tamanho de um determinado tamanho de distribuição.  Por exemplo, se o tamanho do cluster for 16, basta selecionar 4 bits - este é o conceito de um logaritmo, ou seja, 4 é um expoente de <b>n</b> , no qual você precisa aumentar o número 2 para obter 16. <br><br>  Essa é uma abordagem bastante econômica para alocação de memória, porque o número mínimo de bytes é usado, mas deve ser um múltiplo de 2, ou seja, você pode ter 16 ou 32, mas não 33 bytes.  Além disso, a <b>verificação de rejeição do Buggy</b> permite armazenar informações sobre valores de limite em uma matriz linear (1 byte por registro) e permite alocar memória em 1 slot com um tamanho de 16 bytes.  alocar memória com granularidade de slot.  O que isso significa? <br><br><img src="https://habrastorage.org/webt/3w/26/nm/3w26nmli9ja80jxthanvcktdhqq.jpeg"><br><br>  Se tivermos um slot de 16 bytes onde colocaremos o valor <b>p = malloc (16)</b> , o valor na tabela será semelhante à <b>tabela [p / slot.size] = 4</b> . <br><br><img src="https://habrastorage.org/webt/al/x7/vj/alx7vjrhny1zzkkjusqvt3iuv3c.jpeg"><br><br>  Suponha que agora precisamos colocar um valor de 32 bytes no tamanho <b>p = malloc (32)</b> .  Precisamos atualizar a tabela de borda para corresponder ao novo tamanho.  E isso é feito duas vezes: primeiro como <b>tabela [p / slot.size] = 5</b> e, em seguida, como <b>tabela [(p / slot.size) + 1] = 5</b> - a primeira vez no primeiro slot, que está alocado para essa memória, e o segundo vezes - para o segundo slot.  Assim, alocamos 32 bytes de memória.  É assim que o log de distribuição de tamanho se parece.  Portanto, para dois slots de alocação de memória, a tabela de limites é atualizada duas vezes.  Isso está claro?  Este exemplo é destinado a pessoas que duvidam que logs e tabelas tenham um significado ou não.  Como as tabelas são multiplicadas toda vez que ocorre a alocação de memória. <br><br>  Vamos ver o que acontece com a tabela de borda.  Suponha que tenhamos um código C que se parece com isso: <b>p '= p + i</b> , ou seja, o ponteiro <b>p' é</b> obtido de <b>p</b> adicionando alguma variável <b>i</b> .  Então, como obtemos o tamanho da memória alocado para <b>p</b> ?  Para fazer isso, você olha para a tabela usando as seguintes condições lógicas: <br><br>  <b>size = 1 &lt;&lt; tabela [p &gt;&gt; log de slot_size]</b> <br><br><img src="https://habrastorage.org/webt/bo/pw/nv/bopwnvj0ek93xhrzu4vqwhcqcf8.jpeg"><br><br>  À direita, temos o tamanho dos dados alocados para <b>p</b> , que deve ser 1. Em seguida, você os move para a esquerda e olha para a tabela, pega esse tamanho de ponteiro e depois para a direita, onde está localizado o log da tabela de tamanho de slot.  Se a aritmética funcionar, vincularemos corretamente o ponteiro à tabela de borda.  Ou seja, o tamanho do ponteiro deve ser maior que 1, mas menor que o tamanho do slot.  À esquerda, temos o valor, e à direita - o tamanho do slot e o valor do ponteiro está localizado entre eles. <br><br>  Suponha que o tamanho do ponteiro seja 32 bytes e, na tabela, dentro dos colchetes, teremos o número 5. <br><br>  Suponha que desejemos encontrar a palavra-chave base desse ponteiro: <b>base = p &amp; n (tamanho - 1)</b> .  O que vamos fazer nos dá uma certa massa, e essa massa nos permitirá restaurar a <b>base</b> localizada aqui.  Imagine que nosso tamanho é 16, em binário é 16 = ... 0010000.  As reticências significam que ainda existem muitos zeros, mas estamos interessados ​​nesta unidade e nos zeros atrás dela.  Se considerarmos (16 -1), será algo assim: (16 - 1) = ... 0001111.  No código binário, o inverso disso será assim: ~ (16-1) ... 1110000. <br><br><img src="https://habrastorage.org/webt/8q/yj/xz/8qyjxz4dqge5f0oygbg1bhszkks.jpeg"><br><br><img src="https://habrastorage.org/webt/ue/2h/hb/ue2hhb2uzpelqgvzpmzi75c6-mo.jpeg"><br><br>  Assim, isso nos permite limpar basicamente o bit, que será essencialmente renderizado a partir do ponteiro atual e nos dará sua <b>base</b> .  Graças a isso, será muito simples verificar se esse ponteiro está dentro dos limites.  Portanto, podemos simplesmente verificar se <b>(p ')&gt; = base</b> e se o valor ( <b>p'</b> - base) é menor que o tamanho selecionado. <br><br><img src="https://habrastorage.org/webt/x6/w8/il/x6w8ilmsiya6i3irbyat6nd51cy.jpeg"><br><br>  É uma coisa bastante simples de descobrir se o ponteiro está dentro dos limites de memória.  Não vou entrar em detalhes, basta dizer que toda aritmética binária é resolvida da mesma maneira.  Esses truques permitem evitar cálculos mais complexos. <br><br>  Há mais uma quinta propriedade da <b>verificação de rejeição</b> do <b>Buggy</b> - ela usa um sistema de memória virtual para evitar ultrapassar os limites definidos para o ponteiro.  A idéia principal é que, se tivermos uma aritmética para o ponteiro com a qual determinamos a saída, podemos definir um bit de ordem superior para o ponteiro. <br><br><img src="https://habrastorage.org/webt/ns/56/tz/ns56tz8drovqvtuwnrsc6qanksc.jpeg"><br><br>  Ao fazer isso, garantimos que a exclusão da referência do ponteiro não causará problemas de hardware.  Definir o <b>bit de ordem alta</b> por si só não causa problemas; a desreferenciação do ponteiro pode causar um problema. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/r4KjHEgg9Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  A versão completa do curso está disponível <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Obrigado por ficar conosco.  Você gosta dos nossos artigos?  Deseja ver materiais mais interessantes?  Ajude-nos fazendo um pedido ou recomendando a seus amigos, um <b>desconto de 30% para os usuários da Habr em um análogo exclusivo de servidores básicos que inventamos para você:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Toda a verdade sobre o VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps de US $ 20 ou como dividir o servidor?</a>  (as opções estão disponíveis com RAID1 e RAID10, até 24 núcleos e até 40GB DDR4). <br><br>  <b>Dell R730xd 2 vezes mais barato?</b>  Somente nós temos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2 TVs Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 a partir de US $ 249</a> na Holanda e nos EUA!</b>  Leia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como criar um prédio de infraestrutura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe usando servidores Dell R730xd E5-2650 v4 custando 9.000 euros por um centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416727/">https://habr.com/ru/post/pt416727/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416713/index.html">Relatório do Clube de Roma 2018, capítulo 3.14: “Nem um único PIB ...”</a></li>
<li><a href="../pt416719/index.html">Extensão PHP e Kotlin Native. Parte Dois, Consciente</a></li>
<li><a href="../pt416721/index.html">DIY House: casas de boneca para adultos</a></li>
<li><a href="../pt416723/index.html">Acessibilidade da API: interfaces de linguagem natural</a></li>
<li><a href="../pt416725/index.html">Kotlin DSL: Teoria e Prática</a></li>
<li><a href="../pt416729/index.html">O programa PYCON RUSSIA está pronto: 25 relatórios e 3 workshops de palestrantes do Google, Red Hat, Yelp, Yandex</a></li>
<li><a href="../pt416731/index.html">Frost on glass: como fazer plástico metglass resistente</a></li>
<li><a href="../pt416737/index.html">A * Path Finding Algorithm em um jogo Voxel 3d Unity</a></li>
<li><a href="../pt416739/index.html">Novo ASUS na Computex 2018</a></li>
<li><a href="../pt416741/index.html">Os invasores usavam certificados D-Link roubados em seu software de roubo de senha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>