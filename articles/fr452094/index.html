<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèæ ‚ôìÔ∏è üë®üèº‚Äçüíª .NET: outils pour travailler avec le multithreading et l'asynchronie. Partie 1 üèõÔ∏è üè£ üôÜüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je publie l'article original sur Habr, dont la traduction est publi√©e sur le blog Codingsight . 
 La deuxi√®me partie est disponible ici. 

 La n√©cessi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET: outils pour travailler avec le multithreading et l'asynchronie. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452094/">  <i>Je publie l'article original sur Habr, dont la traduction est publi√©e sur le blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Codingsight</a> .</i> <br>  <i>La deuxi√®me partie est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici.</a></i> <br><br>  La n√©cessit√© de faire quelque chose de mani√®re asynchrone, sans attendre le r√©sultat ici et maintenant, ou de partager beaucoup de travail entre plusieurs unit√©s qui l'ex√©cutent, √©tait m√™me avant l'av√®nement des ordinateurs.  Avec leur apparition, un tel besoin est devenu tr√®s tangible.  Maintenant, en 2019, en tapant cet article sur un ordinateur portable avec un processeur Intel Core √† 8 c≈ìurs, sur lequel pas cent processus fonctionnent en m√™me temps, mais encore plus de threads.  √Ä c√¥t√© se trouve un t√©l√©phone l√©g√®rement us√©, achet√© il y a quelques ann√©es, avec un processeur √† 8 c≈ìurs √† bord.  Les ressources th√©matiques sont pleines d'articles et de vid√©os o√π leurs auteurs admirent les smartphones phares de cette ann√©e o√π ils mettent des processeurs 16 c≈ìurs.  Pour moins de 20 $ / heure, MS Azure fournit une machine virtuelle avec 128 processeurs principaux et 2 To de RAM.  Malheureusement, il est impossible de maximiser et de limiter cette puissance sans pouvoir contr√¥ler l'interaction des flux. <br><a name="habracut"></a><br><h3>  Terminologie </h3><br>  <b>Processus</b> - Un objet OS, un espace d'adressage isol√©, contient des threads. <br>  <b>Thread (Thread)</b> - un objet OS, la plus petite unit√© d'ex√©cution, une partie d'un processus, les threads partagent la m√©moire et d'autres ressources entre eux au sein du processus. <br>  <b>Le multit√¢che</b> est une fonctionnalit√© du syst√®me d'exploitation, la possibilit√© d'ex√©cuter plusieurs processus en m√™me temps <br>  <b>Multicore</b> - une propri√©t√© du processeur, la possibilit√© d'utiliser plusieurs c≈ìurs pour le traitement des donn√©es <br>  <b>Multiprocessing</b> - une propri√©t√© d'un ordinateur, la capacit√© de travailler simultan√©ment avec plusieurs processeurs physiquement <br>  <b>Le multithreading</b> est une propri√©t√© d'un processus, la possibilit√© de r√©partir le traitement des donn√©es entre plusieurs threads. <br>  <b>Parall√©lisme</b> - effectuer plusieurs actions physiquement en m√™me temps par unit√© de temps <br>  <b>Asynchronie</b> - l'ex√©cution d'une op√©ration sans attendre la fin de ce traitement, le r√©sultat de l'ex√©cution peut √™tre trait√© ult√©rieurement. <br><br><h3>  M√©taphore </h3><br>  Toutes les d√©finitions ne sont pas bonnes et certaines n√©cessitent des explications suppl√©mentaires, donc j'ajouterai une m√©taphore pour cuisiner le petit d√©jeuner √† la terminologie officiellement introduite.  Pr√©parer le petit-d√©jeuner dans cette m√©taphore est un processus. <br><br>  Cuisiner le petit d√©jeuner le matin, je ( <b>CPU</b> ) viens √† la cuisine ( <b>ordinateur</b> ).  J'ai 2 mains ( <b>noyaux</b> ).  La cuisine dispose d'un certain nombre d'appareils ( <b>IO</b> ): four, bouilloire, grille-pain, r√©frig√©rateur.  J'allume le gaz, j'y mets une po√™le et je verse de l'huile dedans, sans attendre qu'il se r√©chauffe ( <b>asynchrone, Non-Blocking-IO-Wait</b> ), je sors les ≈ìufs du r√©frig√©rateur et les casse dans une assiette, puis je les frappe d'une main ( <b>Fil # 1</b> ), et le second ( <b>Thread # 2</b> ) je tiens l'assiette (Shared Resource).  Maintenant, j'allumerais toujours la bouilloire, mais il n'y a pas assez de mains ( <b>Thread Starvation</b> ) Pendant ce temps, la po√™le est chauff√©e (Traitement du r√©sultat) o√π je verse ce que j'ai fouett√©.  J'atteins la bouilloire et l'allume et regarde stupidement comment l'eau y bouillonne ( <b>Blocking-IO-Wait</b> ), bien que je puisse laver l'assiette pendant ce temps, o√π je bat l'omelette. <br><br>  J'ai fait cuire une omelette en utilisant seulement 2 mains, et je n'en ai pas plus, mais en m√™me temps, 3 op√©rations ont eu lieu au moment de fouetter une omelette: fouetter une omelette, tenir une assiette, chauffer une po√™le √† frire. Le CPU est la partie la plus rapide de l'ordinateur, IO l'est le plus souvent ralentit tout, si souvent une solution efficace consiste √† prendre quelque chose de CPU tout en recevant des donn√©es d'E / S. <br><br>  Poursuivant la m√©taphore: <br><br><ul><li>  Si dans le processus de pr√©paration d'une omelette, j'essayerais √©galement de changer de v√™tements, ce serait un exemple de multit√¢che.  Une nuance importante: les ordinateurs avec cela sont bien meilleurs que les gens. </li><li>  Une cuisine avec plusieurs chefs, par exemple dans un restaurant, est un ordinateur multic≈ìur. </li><li>  De nombreux restaurants de restauration dans un centre commercial - centre de donn√©es </li></ul><br><h3>  Outils .NET </h3><br>  En travaillant avec des threads, comme dans beaucoup d'autres choses, .NET est bon.  Avec chaque nouvelle version, il pr√©sente de plus en plus de nouveaux outils pour travailler avec eux, de nouvelles couches d'abstraction sur les threads OS.  En travaillant avec la construction d'abstractions, les d√©veloppeurs de framework utilisent l'approche qui laisse la possibilit√© lors de l'utilisation d'abstraction de haut niveau, elle descendra d'un ou plusieurs niveaux ci-dessous.  Le plus souvent, cela n'est pas n√©cessaire.En outre, cela ouvre la possibilit√© qu'un fusil de chasse soit abattu dans le pied, mais parfois, dans de rares cas, cela peut √™tre le seul moyen de r√©soudre un probl√®me qui ne r√©sout pas au niveau d'abstraction actuel. <br><br>  Par outils, j'entends √† la fois les interfaces de programme (API) fournies par le cadre et les packages tiers, et une solution logicielle compl√®te qui simplifie la recherche de tout probl√®me associ√© au code multithread. <br><br><h4>  D√©but du flux </h4><br>  La classe Thread, la classe la plus basique de .NET pour travailler avec les threads.  Le constructeur accepte l'un des deux d√©l√©gu√©s: <br><br><ul><li>  ThreadStart - Aucun param√®tre </li><li>  ParametrizedThreadStart - avec un param√®tre de type objet. </li></ul><br>  Le d√©l√©gu√© sera ex√©cut√© dans le thread nouvellement cr√©√© apr√®s avoir appel√© la m√©thode Start, si un d√©l√©gu√© du type ParametrizedThreadStart a √©t√© pass√© au constructeur, alors un objet doit √™tre pass√© √† la m√©thode Start.  Ce m√©canisme est n√©cessaire pour transf√©rer toute information locale vers le flux.  Il convient de noter que la cr√©ation d'un flux est une op√©ration co√ªteuse et que le flux lui-m√™me est un objet lourd, au moins parce que 1 Mo de m√©moire est allou√© √† la pile et n√©cessite une interaction avec l'API du syst√®me d'exploitation. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(...).Start(...);</code> </pre> <br>  La classe ThreadPool repr√©sente le concept d'un pool.  Dans .NET, le pool de threads est un travail d'ing√©nierie et les d√©veloppeurs Microsoft ont mis beaucoup d'efforts pour le faire fonctionner de mani√®re optimale dans une grande vari√©t√© de sc√©narios. <br><br>  <b>Concept g√©n√©ral:</b> <br><br>  <i>Depuis le d√©but, l'application en arri√®re-plan cr√©e plusieurs threads en r√©serve et offre la possibilit√© de les utiliser.</i>  <i>Si les threads sont utilis√©s fr√©quemment et en grand nombre, le pool se d√©veloppe pour r√©pondre au besoin du code appelant.</i>  <i>Lorsqu'il n'y a pas de flux libres dans le pool au bon moment, il attendra le retour de l'un des flux ou en cr√©era un nouveau.</i>  <i>Il s'ensuit que le pool de threads est excellent pour certaines actions courtes et mal adapt√© aux op√©rations qui fonctionnent en tant que service dans l'ensemble de l'application.</i> <i><br><br></i>  <i>Pour utiliser un thread du pool, il existe une m√©thode QueueUserWorkItem qui accepte un d√©l√©gu√© de type WaitCallback, qui est la m√™me signature que ParametrizedThreadStart, et le param√®tre qui lui est transmis remplit la m√™me fonction.</i> <br><br><pre> <code class="cs hljs">ThreadPool.QueueUserWorkItem(...);</code> </pre><br>  La m√©thode de pool de threads moins connue RegisterWaitForSingleObject est utilis√©e pour organiser les op√©rations d'E / S non bloquantes.  Le d√©l√©gu√© pass√© √† cette m√©thode sera appel√© lorsque le WaitHandle pass√© √† la m√©thode est ¬´Released¬ª. <br><br><pre> <code class="cs hljs">ThreadPool.RegisterWaitForSingleObject(...)</code> </pre><br>  .NET a un temporisateur de flux et il diff√®re des temporisateurs WinForms / WPF en ce que son gestionnaire sera appel√© dans un flux extrait du pool. <br><br><pre> <code class="cs hljs">System.Threading.Timer</code> </pre><br>  Il existe √©galement un moyen assez exotique d'envoyer un d√©l√©gu√© au thread depuis le pool - la m√©thode BeginInvoke. <br><br><pre> <code class="cs hljs">DelegateInstance.BeginInvoke</code> </pre><br>  Je veux √©galement m'attarder sur la transmission d'une fonction qui appelle la plupart des m√©thodes ci-dessus - CreateThread de Kernel32.dll Win32 API.  Il existe un moyen, gr√¢ce au m√©canisme des m√©thodes externes, d'appeler cette fonction.  Je n'ai vu un tel d√©fi qu'une seule fois dans un terrible exemple de code h√©rit√©, et la motivation de l'auteur √† le faire est toujours un myst√®re pour moi. <br><br><pre> <code class="cs hljs">Kernel32.dll CreateThread</code> </pre><br><h4>  Afficher et d√©boguer les threads </h4><br>  Les threads que vous avez cr√©√©s personnellement par tous les composants tiers et le pool .NET peuvent √™tre affich√©s dans la fen√™tre Threads Visual Studio.  Cette fen√™tre affichera des informations sur les flux uniquement lorsque l'application est en cours de d√©bogage et en mode arr√™t (mode arr√™t).  Ici, vous pouvez facilement visualiser les noms de pile et les priorit√©s de chaque thread, basculer le d√©bogage sur un thread sp√©cifique.  La propri√©t√© Priority de la classe Thread vous permet de d√©finir la priorit√© du thread, que OC et CLR percevront comme une recommandation lors de la division du temps CPU entre les threads. <br><br><img src="https://habrastorage.org/webt/ow/kq/i5/owkqi5zdx2m8oe7iava3q1mikri.png"><br><br><h4>  Biblioth√®que parall√®le de t√¢ches </h4><br>  La biblioth√®que parall√®le de t√¢ches (TPL) est apparue dans .NET 4.0.  Maintenant, c'est la norme et l'outil principal pour travailler avec l'asynchronie.  Tout code utilisant une approche plus ancienne est consid√©r√© comme h√©rit√©.  L'unit√© de base de TPL est la classe Task de l'espace de noms System.Threading.Tasks.  La t√¢che est une abstraction sur un thread.  Avec la nouvelle version de C #, nous avons eu une mani√®re √©l√©gante de travailler avec les op√©rateurs Task - async / wait.  Ces concepts ont permis d'√©crire du code asynchrone comme s'il √©tait simple et synchrone, ce qui a permis m√™me aux personnes peu familiaris√©es avec la cuisine interne des threads d'√©crire des applications qui les utilisent, des applications qui ne g√®lent pas pendant de longues op√©rations.  Utiliser async / wait est un sujet pour un ou m√™me plusieurs articles, mais je vais essayer de comprendre l'essentiel de quelques phrases: <br><br><ul><li>  async est un modificateur de la m√©thode renvoyant Task ou void </li><li>  et wait est l'instruction d'attente de non-blocage de la t√¢che. </li></ul><br>  Encore une fois: l'op√©rateur wait, dans le cas g√©n√©ral (il y a des exceptions), lib√©rera le thread d'ex√©cution en cours, et lorsque la t√¢che terminera son ex√©cution, et le thread (en fait, il est plus correct de dire le contexte, mais plus √† ce sujet plus tard) sera libre de continuer la m√©thode.  Dans .NET, ce m√©canisme est impl√©ment√© de la m√™me mani√®re que yield return, lorsqu'une m√©thode √©crite se transforme en une classe enti√®re, qui est une machine √† √©tats et peut √™tre ex√©cut√©e en plusieurs parties en fonction de ces √©tats.  Toute personne int√©ress√©e peut √©crire n'importe quel code simple en utilisant asyn / wait, compiler et afficher l'assembly √† l'aide de JetBrains dotPeek avec le code g√©n√©r√© par le compilateur activ√©. <br><br>  Consid√©rez les options de lancement et d'utilisation de Task.  En utilisant l'exemple de code ci-dessous, nous cr√©ons une nouvelle t√¢che qui ne fait rien d'utile ( <i>Thread.Sleep (10000)</i> ), mais dans la vie r√©elle, cela devrait √™tre une sorte de travail complexe impliquant du CPU. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TCO = System.Threading.Tasks.TaskCreationOptions; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VoidAsyncMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cancellationSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.StartNew( <span class="hljs-comment"><span class="hljs-comment">// Code of action will be executed on other context () =&gt; Thread.Sleep(10000), cancellationSource.Token, TCO.LongRunning | TCO.AttachedToParent | TCO.PreferFairness, scheduler ); // Code after await will be executed on captured context }</span></span></code> </pre><br>  La t√¢che est cr√©√©e avec un certain nombre d'options: <br><br><ul><li>  LongRunning est un indice que la t√¢che ne sera pas termin√©e rapidement, ce qui signifie qu'il pourrait √™tre utile de ne pas prendre un thread du pool, mais d'en cr√©er un autre pour cette t√¢che afin de ne pas nuire aux autres. </li><li>  AttachedToParent - Les t√¢ches peuvent √™tre organis√©es dans une hi√©rarchie.  Si cette option a √©t√© utilis√©e, la t√¢che peut √™tre dans un √©tat lorsqu'elle s'est termin√©e et attend que les enfants se terminent. </li><li>  PreferFairness - signifie qu'il serait bien d'ex√©cuter les t√¢ches envoy√©es plus t√¥t pour ex√©cution avant celles qui ont √©t√© envoy√©es plus tard.  Mais ce n'est qu'une recommandation et le r√©sultat n'est pas garanti. </li></ul><br>  Le deuxi√®me param√®tre de la m√©thode a pass√© CancellationToken.  Afin de traiter correctement l'annulation d'une op√©ration apr√®s son lancement, le code ex√©cut√© doit √™tre rempli avec des v√©rifications d'√©tat de CancellationToken.  S'il n'y a aucune v√©rification, la m√©thode Cancel appel√©e sur l'objet CancellationTokenSource ne pourra arr√™ter l'ex√©cution de la t√¢che qu'avant son d√©marrage. <br><br>  Le dernier param√®tre a pass√© l'objet planificateur de type TaskScheduler.  Cette classe et ses descendants sont con√ßus pour contr√¥ler les strat√©gies de distribution de Task'ov par thread, par d√©faut, Task sera ex√©cut√©e sur un thread al√©atoire du pool. <br><br>  L'op√©rateur d'attente est appliqu√© √† la t√¢che cr√©√©e, ce qui signifie que le code √©crit apr√®s, le cas √©ch√©ant, sera ex√©cut√© dans le m√™me contexte (souvent cela signifie qu'il se trouve sur le m√™me thread) que le code avant wait. <br><br>  La m√©thode est marqu√©e comme async void, ce qui signifie que vous pouvez y utiliser l'op√©rateur wait, mais le code appelant ne peut pas attendre son ex√©cution.  Si cette fonctionnalit√© est n√©cessaire, la m√©thode doit renvoyer Task.  Les m√©thodes marqu√©es async void sont assez courantes: en r√®gle g√©n√©rale, ce sont des gestionnaires d'√©v√©nements ou d'autres m√©thodes qui fonctionnent sur le principe du feu et oublient.  Si vous devez non seulement donner la possibilit√© d'attendre la fin de l'ex√©cution, mais √©galement renvoyer le r√©sultat, vous devez utiliser Task. <br><br>  Cependant, sur la t√¢che renvoy√©e par la m√©thode StartNew, comme sur n'importe quelle autre, vous pouvez appeler la m√©thode ConfigureAwait avec le faux param√®tre, puis l'ex√©cution apr√®s l'attente se poursuivra non pas sur le contexte captur√©, mais sur un contexte arbitraire.  Cela doit toujours √™tre fait lorsque le contexte d'ex√©cution n'est pas important pour le code apr√®s l'attente.  Il est √©galement une recommandation de MS lors de l'√©criture de code qu'il sera emball√© sous forme de biblioth√®que. <br><br>  Attardons-nous un peu plus sur la fa√ßon dont vous pouvez attendre la fin de la t√¢che.  Voici un exemple de code, avec des commentaires, lorsque l'attente est conditionnellement bonne et conditionnellement mauvaise. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnotherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> AsyncMethod(); <span class="hljs-comment"><span class="hljs-comment">// good result = AsyncMethod().Result; // bad AsyncMethod().Wait(); // bad IEnumerable&lt;Task&gt; tasks = new Task[] { AsyncMethod(), OtherAsyncMethod() }; await Task.WhenAll(tasks); // good await Task.WhenAny(tasks); // good Task.WaitAll(tasks.ToArray()); // bad }</span></span></code> </pre><br>  Dans le premier exemple, nous attendons que la t√¢che se termine et sans bloquer le thread appelant, nous ne reviendrons au traitement du r√©sultat que lorsqu'il est d√©j√† l√†, jusqu'√† ce que le thread appelant soit laiss√© √† lui-m√™me. <br><br>  Dans la deuxi√®me option, nous bloquons le thread appelant jusqu'√† ce que le r√©sultat de la m√©thode soit calcul√©.  C'est mauvais non seulement parce que nous avons pris le thread, une ressource si pr√©cieuse du programme, par simple oisivet√©, mais aussi parce que si le code de la m√©thode que nous appelons a attendu et que le contexte de synchronisation implique de retourner au thread appelant apr√®s wait, nous obtiendrons un blocage. : le thread appelant attend le calcul du r√©sultat de la m√©thode asynchrone, la m√©thode asynchrone essaie en vain de continuer son ex√©cution dans le thread appelant. <br><br>  Un autre inconv√©nient de cette approche est la gestion compliqu√©e des erreurs.  Le fait est que les erreurs dans le code asynchrone lors de l'utilisation de async / wait sont tr√®s faciles √† g√©rer - elles se comportent comme si le code √©tait synchrone.  Alors que, si nous appliquons l' <s>exorcisme, l'</s> attente synchrone √† la t√¢che, l'exception d'origine se transforme en une AggregateException, c'est-√†-dire  Pour g√©rer une exception, vous devrez examiner le type InnerException et √©crire la cha√Æne if √† l'int√©rieur d'un bloc catch ou utiliser la capture catch lors de la construction au lieu de la cha√Æne de blocs catch plus famili√®re en C #. <br><br>  Le troisi√®me et dernier exemple sont √©galement marqu√©s mauvais pour la m√™me raison et contiennent tous les m√™mes probl√®mes. <br><br>  Les m√©thodes WhenAny et WhenAll sont extr√™mement pratiques pour attendre un groupe de Task'ov, elles enveloppent un groupe de Task'ov en un, qui fonctionnera soit sur la premi√®re op√©ration de Task'a du groupe, soit lorsque tout le monde aura termin√© son ex√©cution. <br><br><h4>  Arr√™t de d√©bit </h4><br>  Pour diverses raisons, il peut √™tre n√©cessaire d'arr√™ter le flux apr√®s son d√©marrage.  Il existe plusieurs fa√ßons de proc√©der.  La classe Thread a deux m√©thodes avec des noms appropri√©s - <b>Abort</b> et <b>Interruption</b> .  Le premier n'est pas recommand√© pour utilisation, car  apr√®s son appel √† tout moment al√©atoire, au cours du traitement d'une instruction, une <b>ThreadAbortedException</b> sera lev√©e.  Vous ne vous attendez pas √† ce qu'une telle exception se bloque lors de l'incr√©mentation d'une variable enti√®re, non?  Et lorsque vous utilisez cette m√©thode, c'est une situation tr√®s r√©elle.  Si vous souhaitez emp√™cher le CLR de lever une telle exception dans une section sp√©cifique du code, vous pouvez l' <b>encapsuler</b> dans des appels √† <b>Thread.BeginCriticalRegion</b> , <b>Thread.EndCriticalRegion</b> .  Tout code √©crit dans un bloc finally est encapsul√© avec de tels appels.  Pour cette raison, dans les entrailles du code cadre, vous pouvez trouver des blocs avec un essai vide, mais pas un vide finalement.  Microsoft ne recommande donc pas d'utiliser cette m√©thode, car ils ne l'ont pas incluse dans le noyau .net. <br><br>  La m√©thode d'interruption fonctionne de mani√®re plus pr√©visible.  Il peut interrompre un thread √† l'exception de <b>ThreadInterruptedException</b> uniquement lorsque le thread est √† l'√©tat inactif.  Dans cet √©tat, il se met en suspension en attendant WaitHandle, lock ou apr√®s avoir appel√© Thread.Sleep. <br><br>  Les deux options d√©crites ci-dessus sont mauvaises pour leur impr√©visibilit√©.  La solution consiste √† utiliser la structure <b>CancellationToken</b> et la classe <b>CancellationTokenSource</b> .  La conclusion est la suivante: une instance de la classe CancellationTokenSource est cr√©√©e et seule la personne qui la poss√®de peut arr√™ter l'op√©ration en appelant la m√©thode <b>Cancel</b> .  Seul le CancellationToken est transmis √† l'op√©ration elle-m√™me.  Les propri√©taires du CancellationToken ne peuvent pas annuler l'op√©ration eux-m√™mes, mais peuvent uniquement v√©rifier si l'op√©ration a √©t√© annul√©e.  Pour ce faire, il existe une propri√©t√© bool√©enne <b>IsCancellationRequested</b> et la m√©thode <b>ThrowIfCancelRequested</b> .  Ce dernier <b>d√©clenchera</b> une <b>exception TaskCancelledException</b> si la m√©thode Cancel est appel√©e sur l'instance CancellationToken annul√©e de CancellationTokenSource.  Et c'est cette m√©thode que je recommande d'utiliser.  C'est mieux que les options pr√©c√©dentes en obtenant un contr√¥le total sur les points o√π l'op√©ration d'exception peut √™tre interrompue. <br><br>  L'option la plus cruelle pour arr√™ter le thread est d'appeler la fonction TerminateThread de l'API Win32.  Le comportement du CLR apr√®s avoir appel√© cette fonction peut √™tre impr√©visible.  Sur MSDN, ce qui suit est √©crit √† propos de cette fonction: <i>¬´TerminateThread est une fonction dangereuse qui ne doit √™tre utilis√©e que dans les cas les plus extr√™mes.</i>  <i>"</i> <br><br><h4>  Convertir l'ancienne API en t√¢che bas√©e sur la m√©thode FromAsync </h4><br>  Si vous avez eu la chance de travailler sur un projet qui a √©t√© lanc√© apr√®s que les t√¢ches ont √©t√© introduites et a cess√© de provoquer une horreur silencieuse pour la plupart des d√©veloppeurs, alors vous n'aurez pas √† faire face √† de nombreuses anciennes API, des tiers et votre √©quipe ont √©t√© tortur√©s dans le pass√©.  Heureusement, l'√©quipe de d√©veloppement de .NET Framework a pris soin de nous, m√™me si l'objectif √©tait peut-√™tre de prendre soin de nous.  Quoi qu'il en soit, .NET dispose d'un certain nombre d'outils pour convertir sans peine du code √©crit dans d'anciennes approches de programmation asynchrone en un nouveau.  L'un d'eux est la m√©thode FromAsync de TaskFactory.  En utilisant l'exemple de code ci-dessous, j'encapsule les anciennes m√©thodes asynchrones de la classe WebRequest dans Task en utilisant cette m√©thode. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> state = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; WebRequest wr = WebRequest.CreateHttp(<span class="hljs-string"><span class="hljs-string">"http://github.com"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.FromAsync( wr.BeginGetResponse, we.EndGetResponse );</code> </pre><br>  <i>Ceci n'est qu'un exemple et il est peu probable que vous ayez √† le faire avec des types int√©gr√©s, mais tout ancien projet regorge simplement de m√©thodes BeginDoSomething qui renvoient des m√©thodes IAsyncResult et EndDoSomething qui l'acceptent.</i> <br><br><h4>  Conversion de l'API h√©rit√©e en t√¢che bas√©e sur la classe TaskCompletionSource </h4><br>  Un autre outil important √† consid√©rer est la classe <b>TaskCompletionSource</b> .  En termes de fonctions, de but et de principe de fonctionnement, il peut en quelque sorte rappeler la m√©thode RegisterWaitForSingleObject de la classe ThreadPool sur laquelle j'ai √©crit ci-dessus.  En utilisant cette classe, vous pouvez facilement et commod√©ment encapsuler les anciennes API asynchrones dans Task. <br><br>  <i>Vous direz que j'ai d√©j√† parl√© de la m√©thode FromAsync de la classe TaskFactory destin√©e √† ces fins.</i>  <i>Ici, nous devrons rappeler toute l'histoire du d√©veloppement de mod√®les asynchrones dans .net que Microsoft propose depuis 15 ans: avant le mod√®le asynchrone bas√© sur les t√¢ches (TAP), il y avait le mod√®le de programmation asynchrone (APP), qui concernait les m√©thodes <b>Begin</b> DoSomething qui renvoient les m√©thodes <b>IAsyncResult</b> et <b>End</b> DoSomething qui l'acceptent et la m√©thode FromAsync est tr√®s bien pour l'h√©ritage de ces ann√©es, mais au fil du temps, elle a √©t√© remplac√©e par le mod√®le asynchrone bas√© sur les √©v√©nements ( <b>EAP</b> ), qui supposait qu'un √©v√©nement serait d√©clench√© lorsque l'op√©ration asynchrone serait termin√©e.</i> <br><br>  TaskCompletionSource est tout simplement g√©nial pour encapsuler des t√¢ches et des API h√©rit√©es construites autour du mod√®le d'√©v√©nement.  L'essence de son travail est la suivante: un objet de cette classe a une propri√©t√© publique de type Task dont l'√©tat peut √™tre contr√¥l√© via les m√©thodes SetResult, SetException, etc. de la classe TaskCompletionSource.  Aux endroits o√π l'op√©rateur d'attente a √©t√© appliqu√© √† cette t√¢che, il sera ex√©cut√© ou bloqu√© avec une exception, selon la m√©thode appliqu√©e √† TaskCompletionSource.  Si tout n'est toujours pas clair, regardons cet exemple de code, o√π une ancienne API EAP est encapsul√©e dans la t√¢che √† l'aide de TaskCompletionSource: lorsque l'√©v√©nement est d√©clench√©, la t√¢che sera transf√©r√©e √† l'√©tat Termin√© et la m√©thode qui a appliqu√© l'op√©rateur d'attente √† cette t√¢che reprend l'ex√©cution obtenir l'objet <b>r√©sultat</b> . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;Result&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SomeApiInstance someApiObj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Result&gt;(); someApiObj.Done += result =&gt; completionSource.SetResult(result); someApiObj.Do(); result completionSource.Task; }</code> </pre><br><h4>  Trucs et astuces de TaskCompletionSource </h4><br>  Envelopper les anciennes API n'est pas tout ce que vous pouvez faire avec TaskCompletionSource.  L'utilisation de cette classe ouvre une possibilit√© int√©ressante de conception de diverses API sur des t√¢ches qui n'occupent pas de threads.  Et le flux, on s'en souvient, est une ressource ch√®re et leur nombre est limit√© (principalement par la RAM).  Cette limitation est facilement obtenue en d√©veloppant, par exemple, une application Web charg√©e avec une logique m√©tier complexe.  Consid√©rez les possibilit√©s dont je parle d'impl√©menter une telle astuce comme l'interrogation longue. <br><br>  <i>En bref, l'essentiel de l'astuce est le suivant: vous devez obtenir des informations de l'API sur certains √©v√©nements se produisant de son c√¥t√©, tandis que l'API, pour une raison quelconque, ne peut pas signaler l'√©v√©nement, mais ne peut que renvoyer l'√©tat.</i>  <i>Un exemple de cela est toutes les API construites sur HTTP avant l'√©poque de WebSocket ou lorsqu'il est impossible pour une raison quelconque d'utiliser cette technologie.</i>  <i>Le client peut demander au serveur HTTP.</i>  <i>Un serveur HTTP ne peut pas lui-m√™me provoquer une communication avec un client.</i>  <i>Une solution simple consiste √† interroger le serveur par minuterie, mais cela cr√©e une charge suppl√©mentaire sur le serveur et un retard suppl√©mentaire en moyenne TimerInterval / 2. Pour contourner ce probl√®me, une astuce appel√©e Long Polling a √©t√© invent√©e, qui implique de retarder la r√©ponse du serveur jusqu'√† l'expiration du d√©lai ou un √©v√©nement se produira.</i>  <i>Si un √©v√©nement s'est produit, il est trait√©; sinon, la demande est envoy√©e √† nouveau.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!eventOccures &amp;&amp; !timeoutExceeded) { CheckTimout(); CheckEvent(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Mais une telle solution se r√©v√©lera terriblement d√®s que le nombre de clients en attente de l'√©v√©nement augmentera, car  Chacun de ces clients, en pr√©vision de l'√©v√©nement, occupe un flux entier.  Oui, et nous obtenons un d√©lai suppl√©mentaire de 1 ms sur le d√©clenchement de l'√©v√©nement, le plus souvent il n'est pas significatif, mais pourquoi rendre le logiciel pire qu'il ne peut l'√™tre?  Si vous supprimez Thread.Sleep (1), alors en vain, nous chargerons un c≈ìur de processeur √† 100% inactif, tournant dans un cycle inutile.  En utilisant TaskCompletionSource, vous pouvez facilement refaire ce code et r√©soudre tous les probl√®mes identifi√©s ci-dessus: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LongPollingApi</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, TaskCompletionSource&lt;Msg&gt;&gt; tasks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Msg&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptMessageAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duration</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Msg&gt;(); tasks[userId] = cs; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(Task.Delay(duration), cs.Task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cs.Task.IsCompleted ? cs.Task.Result : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, Msg m</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tasks.TryGetValue(userId, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource)) completionSource.SetResult(m); } }</code> </pre><br>  <i>Ce code n'est pas pr√™t pour la production, mais juste une d√©mo.</i>  <i>Pour l'utiliser dans des cas r√©els, vous devez √©galement g√©rer au moins la situation lorsqu'un message arrive √† un moment o√π personne ne l'attend: dans ce cas, la m√©thode AsseptMessageAsync doit renvoyer une t√¢che d√©j√† termin√©e.</i>  <i>Si ce cas est le plus fr√©quent, vous pouvez penser √† utiliser ValueTask.</i> <br><br>  √Ä la r√©ception d'une demande de message, nous cr√©ons et pla√ßons TaskCompletionSource dans le dictionnaire, puis nous attendons ce qui se passe en premier: l'intervalle de temps sp√©cifi√© expire ou un message est re√ßu. <br><br><h4>  ValueTask: pourquoi et comment </h4><br>  Les op√©rateurs asynchrones / attendent, comme l'op√©rateur de retour de rendement, g√©n√®rent une machine d'√©tat √† partir de la m√©thode, qui cr√©e un nouvel objet, ce qui n'est presque toujours pas important, mais dans de rares cas, cela peut cr√©er un probl√®me.  Ce cas peut √™tre une m√©thode appel√©e tr√®s souvent, parlant de dizaines et de centaines de milliers d'appels par seconde.  Si une telle m√©thode est √©crite de sorte que dans la plupart des cas, elle renvoie un r√©sultat en contournant toutes les m√©thodes en attente, alors .NET fournit un outil pour optimiser cela - la structure ValueTask.  Pour √™tre clair, consid√©rons un exemple de son utilisation: il y a un cache auquel nous allons tr√®s souvent.  Il y a quelques valeurs dedans et ensuite nous les retournons simplement, sinon, nous allons √† un IO lent derri√®re eux.  Je veux faire ce dernier de mani√®re asynchrone, ce qui signifie que toute la m√©thode est asynchrone.  Ainsi, la mani√®re √©vidente d'√©crire une m√©thode est la suivante: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> RequestById(id); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En raison du d√©sir d'optimiser un peu et d'une l√©g√®re crainte de ce que Roslyn g√©n√©rera en compilant ce code, nous pouvons r√©√©crire cet exemple comme suit: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RequestById(id); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En effet, la solution optimale dans ce cas est d'optimiser le hot-path, √† savoir, obtenir la valeur du dictionnaire sans aucune allocation suppl√©mentaire et charge sur le GC, tandis que dans les rares cas o√π nous devons encore aller √† l'IO, tout restera plus / moins vieux: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(RequestById(id)); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examinons de plus pr√®s ce fragment de code: s'il y a une valeur dans le cache, nous cr√©ons une structure, sinon la vraie t√¢che sera envelopp√©e dans une importante. </font><font style="vertical-align: inherit;">Le code appelant ne se soucie pas de la fa√ßon dont ce code a √©t√© ex√©cut√©: ValueTask du point de vue de la syntaxe C # se comportera comme la t√¢che habituelle dans ce cas.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TaskSchedulers: gestion des strat√©gies de lancement de t√¢ches </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La prochaine API que je voudrais consid√©rer est la classe </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et ses d√©riv√©s. </font><font style="vertical-align: inherit;">J'ai d√©j√† mentionn√© ci-dessus que dans TPL il y a la possibilit√© de contr√¥ler les strat√©gies de distribution de Task'ov par thread. </font><font style="vertical-align: inherit;">Ces strat√©gies sont d√©finies dans les descendants de la classe TaskScheduler. </font><font style="vertical-align: inherit;">Presque toutes les strat√©gies qui peuvent √™tre n√©cessaires se trouvent dans la biblioth√®que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ParallelExtensionsExtras</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , d√©velopp√©e par Microsoft, mais ne faisant pas partie de .NET, mais livr√©e sous forme de package Nuget. </font><font style="vertical-align: inherit;">Examinons bri√®vement certains d'entre eux:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CurrentThreadTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ex√©cute une t√¢che sur le thread actuel</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LimitedConcurrencyLevelTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - limite le nombre de t√¢ches ex√©cut√©es simultan√©ment au param√®tre N, qui est accept√© dans le constructeur</font></font></li><li> <b>OrderedTaskScheduler</b> ‚Äî   LimitedConcurrencyLevelTaskScheduler(1),     . </li><li> <b>WorkStealingTaskScheduler</b> ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">work-stealing</a>    .     ThreadPool.   ,   .NET ThreadPool   ,    ,                  .        .  T.O.      WorkStealingTaskScheduler'    ,   ThreadPool     . </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueuedTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - vous permet d'effectuer des t√¢ches selon les r√®gles de file d'attente avec des priorit√©s</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadPerTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - cr√©e un thread s√©par√© pour chaque t√¢che qui s'ex√©cute dessus. </font><font style="vertical-align: inherit;">Il peut √™tre utile pour des t√¢ches d'une dur√©e impr√©visible.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a un bon </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©taill√© </font><font style="vertical-align: inherit;">sur TaskSchedulers sur le blog Microsoft. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour un d√©bogage pratique de tout ce qui concerne les t√¢ches dans Visual Studio, il existe une fen√™tre T√¢ches. </font><font style="vertical-align: inherit;">Dans cette fen√™tre, vous pouvez voir l'√©tat actuel de la t√¢che et acc√©der √† la ligne de code en cours d'ex√©cution.</font></font><br><br><img src="https://habrastorage.org/webt/tb/fv/3l/tbfv3l-sdz-jw0mpcakbt_-lve8.png"><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PLinq et la classe Parallel </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En plus de Task et de tout ce qui a √©t√© dit avec eux dans .NET, il existe deux autres outils int√©ressants: PLinq (Linq2Parallel) et la classe Parallel. Le premier promet l'ex√©cution parall√®le de toutes les op√©rations Linq sur plusieurs threads. Le nombre de threads peut √™tre configur√© avec la m√©thode d'extension WithDegreeOfParallelism. Malheureusement, le plus souvent PLinq en mode ex√©cution par d√©faut n'aura pas assez d'informations sur l'int√©rieur de votre source de donn√©es pour fournir un gain de vitesse significatif, d'autre part, le prix de la tentative est tr√®s bas: il vous suffit d'appeler la m√©thode AsParallel en face de la cha√Æne de m√©thode Linq et d'effectuer des tests de performances. De plus, il est possible de transf√©rer vers PLinq des informations suppl√©mentaires sur la nature de votre source de donn√©es en utilisant le m√©canisme de partitions. Vous pouvez en lire plus </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La classe statique Parallel fournit des m√©thodes pour it√©rer sur une collection Foreach en parall√®le, ex√©cuter une boucle For et ex√©cuter plusieurs d√©l√©gu√©s en parall√®le √† Invoke. L'ex√©cution du thread en cours sera arr√™t√©e jusqu'√† la fin des calculs. Le nombre de threads peut √™tre configur√© en passant ParallelOptions comme dernier argument. √Ä l'aide des options, vous pouvez √©galement sp√©cifier TaskScheduler et CancellationToken.</font></font><br><br><h4>  Conclusions </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque j'ai commenc√© √† √©crire cet article sur la base des √©l√©ments de mon rapport et des informations que j'ai collect√©es au cours de mon travail apr√®s, je ne m'attendais pas √† ce qu'il aboutisse autant. </font><font style="vertical-align: inherit;">Maintenant, lorsque l'√©diteur de texte dans lequel je tape cet article me dit avec reproche que la 15e page est partie, je vais r√©sumer les r√©sultats interm√©diaires. </font><font style="vertical-align: inherit;">D'autres astuces, API, outils visuels et pi√®ges seront abord√©s dans un prochain article. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusions:</font></font></b> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous devez conna√Ætre les outils pour travailler avec les threads, l'asynchronie et le parall√©lisme afin d'utiliser les ressources des PC modernes. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .NET dispose de nombreux outils diff√©rents √† cet effet. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ils ne sont pas tous apparus en m√™me temps, car il est souvent possible de trouver un h√©ritage, mais il existe des moyens de convertir les anciennes API sans trop d'effort. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le travail avec les threads dans .NET est repr√©sent√© par les classes Thread et ThreadPool </font></font></li><li>  Thread.Abort, Thread.Interrupt,  Win32 API TerminateThread      .      CancellationToken' </li><li>  ‚Äî  ,   .   ,     .      TaskCompletionSource </li><li>      .NET        Task'. </li><li>  c# async/await     </li><li>   Task'       TaskScheduler'  </li><li>  ValueTask      hot-paths  memory-traffic </li><li>  Tasks  Threads Visual Studio           </li><li> PLinq  ,            ,        partitioning </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ... </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452094/">https://habr.com/ru/post/fr452094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452082/index.html">Flux flexible des mises √† jour int√©gr√©es: acc√©l√©rez le processus de mise √† jour des applications sur Android</a></li>
<li><a href="../fr452086/index.html">Ce qui est dans mon pixel pour vous: cr√©er des nanopixels en utilisant des m√©tasurfaces plasmon</a></li>
<li><a href="../fr452088/index.html">Reconnaissance routi√®re par segmentation s√©mantique</a></li>
<li><a href="../fr452090/index.html">Cr√©ation d'un g√©n√©rateur de puzzle proc√©dural</a></li>
<li><a href="../fr452092/index.html">Mises √† jour int√©gr√©es √† l'application: acc√©l√©ration des mises √† jour des applications Android</a></li>
<li><a href="../fr452098/index.html">Journaux du d√©veloppeur frontal Habr: refactor et reflex</a></li>
<li><a href="../fr452102/index.html">Jeu photo pour ceux qui aiment les drones: bref sur AirSelfie 2</a></li>
<li><a href="../fr452106/index.html">Nous invitons les conf√©renciers √† la r√©union de bricolage d'√©t√© du 16 juin 2019</a></li>
<li><a href="../fr452108/index.html">Docker: des conseils inoffensifs</a></li>
<li><a href="../fr452110/index.html">Automatisez le remplacement de disque avec Ansible</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>