<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐟 ✌🏼 🍕 Cartucho de Tarantool: Fragmentación del backend de Lua en tres líneas 💥 👴🏿 🌶️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En Mail.ru Group, tenemos Tarantool, un servidor de aplicaciones basado en Lua y una base de datos unida. Es rápido y elegante, pero los recursos de u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cartucho de Tarantool: Fragmentación del backend de Lua en tres líneas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/470812/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/tg/6f/71/tg6f71dbjoo5m5qm5ebndfjxjdu.jpeg"></div><br>  En Mail.ru Group, tenemos Tarantool, un servidor de aplicaciones basado en Lua y una base de datos unida.  Es rápido y elegante, pero los recursos de un solo servidor siempre son limitados.  La escala vertical tampoco es la panacea.  Es por eso que Tarantool tiene algunas herramientas para el escalado horizontal, o el módulo vshard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">[1]</a> .  Le permite distribuir datos a través de múltiples servidores, pero tendrá que jugar con ellos por un tiempo para configurarlos y atornillar la lógica empresarial. <br><br>  Buenas noticias: obtuvimos nuestra parte de baches (por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">[2]</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">[3]</a> ) y creamos otro marco, que simplifica significativamente la solución a este problema. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tarantool Cartridge</a> es el nuevo marco para desarrollar sistemas distribuidos complejos.  Le permite concentrarse en escribir lógica empresarial en lugar de resolver problemas de infraestructura.  Debajo del corte, le diré cómo funciona este marco y cómo podría ayudar a escribir servicios distribuidos. <br><a name="habracut"></a><br><h2>  Entonces, ¿cuál es exactamente el problema? </h2><br>  Tenemos Tarantool y vshard, ¿qué más queremos? <br><br>  Primero, es una cuestión de conveniencia.  Vshard está configurado en tablas Lua.  Pero para que un sistema distribuido de varios procesos de Tarantool funcione correctamente, la configuración debe ser la misma en todas partes.  Nadie querría hacerlo manualmente, por lo que se utilizan todo tipo de scripts, Ansible y sistemas de implementación. <br><br>  El propio cartucho gestiona la configuración vshard basada en <i>su propia configuración distribuida</i> .  De hecho, es un archivo YAML simple, y su copia se almacena en cada instancia de Tarantool.  En otras palabras, el marco monitorea su configuración para que sea igual en todas partes. <br><br>  Segundo, nuevamente es una cuestión de conveniencia.  La configuración de Vshard no está relacionada con el desarrollo de la lógica de negocios y solo distrae a un desarrollador de su trabajo.  Cuando discutimos la arquitectura de un proyecto, lo más probable es que se trate de componentes separados y su interacción.  Es demasiado pronto para pensar siquiera en implementar un clúster para 3 centros de datos. <br><br>  Resolvimos estos problemas una y otra vez y, en algún momento, logramos desarrollar un enfoque para simplificar el trabajo con la aplicación durante todo su ciclo de vida: creación, desarrollo, pruebas, CI / CD, mantenimiento. <br><br>  Cartridge presenta el concepto de roles para cada proceso de Tarantool.  Los roles permiten al desarrollador concentrarse en escribir código.  Todos los roles disponibles en el proyecto se pueden ejecutar en la única instancia de Tarantool, y esto sería suficiente para la prueba. <br><br>  Características clave del cartucho de Tarantool: <br><br><ul><li>  orquestación automatizada de clústeres; <br></li><li>  funcionalidad de aplicación expandida con nuevos roles; <br></li><li>  plantilla de aplicación para desarrollo y despliegue; <br></li><li>  fragmentación automática incorporada; <br></li><li>  integración con el marco Luatest; <br></li><li>  gestión de clústeres utilizando WebUI y API; <br></li><li>  herramientas de empaque y despliegue. <br></li></ul><br><h2>  Hola mundo </h2><br>  No puedo esperar para mostrarle el marco en sí, así que guardemos la historia sobre arquitectura para más adelante, y comencemos con una tarea fácil.  Suponiendo que Tarantool ya esté instalado, todo lo que tenemos que hacer es <br><br><pre><code class="plaintext hljs">$ tarantoolctl rocks install cartridge-cli $ export PATH=$PWD/.rocks/bin/:$PATH</code> </pre> <br>  Como resultado, se instalan las utilidades de línea de comandos, lo que le permite crear su primera aplicación desde la plantilla: <br><br><pre> <code class="plaintext hljs">$ cartridge create --name myapp</code> </pre> <br>  Y esto es lo que obtenemos: <br><br><pre> <code class="plaintext hljs">myapp/ ├── .git/ ├── .gitignore ├── app/roles/custom.lua ├── deps.sh ├── init.lua ├── myapp-scm-1.rockspec ├── test │ ├── helper │ │ ├── integration.lua │ │ └── unit.lua │ ├── helper.lua │ ├── integration/api_test.lua │ └── unit/sample_test.lua └── tmp/</code> </pre> <br>  Este es un repositorio de git con un "Hello, World!" Listo para usar.  aplicación  Intentemos ejecutarlo después de instalar las dependencias (incluido el propio marco): <br><br><pre> <code class="plaintext hljs">$ tarantoolctl rocks make $ ./init.lua --http-port 8080</code> </pre> <br>  Hemos lanzado un nodo de nuestra futura aplicación fragmentada.  Si tiene curiosidad, puede abrir de inmediato la interfaz web, que se ejecuta en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">localhost</a> : 8080, usar un mouse para configurar un clúster de un nodo y disfrutar del resultado, pero no se entusiasme demasiado pronto.  La aplicación aún no sabe cómo hacer nada útil, por lo que le contaré sobre la implementación más adelante, y ahora es el momento de escribir un código. <br><br><h2>  Desarrollando aplicaciones </h2><br>  Imagine que estamos diseñando un sistema que debería recibir datos, guardarlos y crear un informe una vez al día. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc6/dba/8a2/dc6dba8a2a2ff31693cff9a825c44b7f.png"></div><br>  Entonces dibujamos un diagrama con tres componentes: puerta de enlace, almacenamiento y planificador.  Sigamos trabajando en la arquitectura.  Como usamos vshard como almacenamiento, agreguemos vshard-router y vshard-storage al diagrama.  Ni la puerta de enlace ni el planificador accederán directamente al almacenamiento: se crea explícitamente un enrutador para esta tarea. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/151/eb0/ac5/151eb0ac5b9d8a1a6217e0992b502089.png"></div><br>  Este diagrama se ve abstracto porque los componentes aún no reflejan lo que crearemos en el proyecto.  Tendremos que ver cómo este proyecto corresponde a Tarantool real, por lo que agrupamos nuestros componentes por el proceso. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fdc/781/a46/fdc781a46e819a67232bfcd308605b5d.png"></div><br>  No tiene mucho sentido mantener vshard-router y gateway en instancias separadas.  ¿Por qué volveríamos a pasar por la red, si esto ya es responsabilidad del enrutador?  Deben ejecutarse dentro del mismo proceso, es decir, tanto la puerta de enlace como vshard.router.cfg deben inicializarse en el mismo proceso e interactuar localmente. <br><br>  Durante la fase de diseño, fue conveniente trabajar con tres componentes, pero como desarrollador, no quiero pensar en lanzar tres instancias de Tarantool mientras escribo código.  Necesito ejecutar las pruebas y verificar que escribí el código de la puerta de enlace correctamente.  O tal vez quiera mostrar una nueva función a mis compañeros de trabajo.  ¿Por qué tendría problemas con el despliegue de tres instancias?  Así nació el concepto de roles.  Un rol es un módulo Lua normal, y Cartridge gestiona su ciclo de vida.  En este ejemplo, hay cuatro de ellos: puerta de enlace, enrutador, almacenamiento y programador.  Otro proyecto puede tener más roles.  Todos los roles se pueden lanzar en un solo proceso, y sería suficiente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e1/49c/95a/1e149c95aed1d5dc7cf73e298198c719.png"></div><br>  Y cuando el asunto se refiere a la implementación en la puesta en escena o la producción, asignamos un conjunto separado de roles a cada proceso de Tarantool, dependiendo de las capacidades de hardware subyacentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f9/b59/1d7/1f9b591d794e4b459b863f0da01f042b.png"></div><br><h2>  Gestión de topología </h2><br>  También deberíamos almacenar información sobre los roles en ejecución en algún lugar.  Y "en algún lugar" significa la configuración distribuida mencionada anteriormente.  Lo más importante aquí es la topología de clúster.  Aquí puede ver 3 grupos de replicación de 5 procesos de Tarantool: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb6/118/a0f/eb6118a0f7c2381ce82491bd65272ec5.png"></div><br>  No queremos perder los datos, por lo que tratamos la información sobre los procesos en ejecución con cuidado.  Cartridge supervisa la configuración mediante una confirmación de dos fases.  Tan pronto como queramos actualizar la configuración, primero verifica si las instancias están disponibles y listas para aceptar la nueva configuración.  Después de eso, la configuración se aplica en la segunda fase.  Por lo tanto, incluso si una instancia no está disponible temporalmente, nada puede salir mal.  La configuración simplemente no se aplicará y verá un error por adelantado. <br><br>  La sección de topología también tiene un parámetro tan importante como el líder de cada grupo de replicación.  Por lo general, esta es la instancia que acepta las escrituras.  El resto suele ser de solo lectura, aunque puede haber excepciones.  A veces, los desarrolladores valientes no temen los conflictos y pueden escribir datos en varias réplicas al mismo tiempo.  Sin embargo, algunas operaciones no deben realizarse dos veces.  Por eso tenemos un líder. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f96/b85/7f3/f96b857f346a756f27c05651b85a9886.png"></div><br><h2>  Ciclo de vida del papel </h2><br>  Para que una arquitectura de proyecto contenga roles abstractos, el marco de alguna manera debe poder administrarlos.  Naturalmente, los roles se gestionan sin reiniciar el proceso de Tarantool.  Hay cuatro devoluciones de llamada diseñadas para la gestión de roles.  El propio cartucho los llama según la información de la configuración distribuida, aplicando así la configuración a los roles específicos. <br><br><pre> <code class="plaintext hljs">function init() function validate_config() function apply_config() function stop()</code> </pre> <br>  Cada rol tiene una función <code>init</code> .  Se llama una vez: cuando el rol está habilitado o cuando Tarantool se reinicia.  Aquí es conveniente, por ejemplo, inicializar box.space.create, o el programador puede ejecutar alguna fibra de fondo que completaría la tarea a intervalos regulares. <br><br>  La función <code>init</code> sí sola puede no ser suficiente.  Cartridge permite que los roles accedan a la configuración distribuida utilizada para almacenar la topología.  En la misma configuración, podemos declarar una nueva sección y almacenar una parte de la configuración empresarial allí.  En mi ejemplo, esto podría ser un esquema de datos o configuraciones de programación para el rol de planificador. <br><br>  El clúster llama a <code>validate_config</code> y <code>apply_config</code> cada vez que cambia la configuración distribuida.  Cuando se aplica una configuración en una confirmación de dos fases, el clúster verifica que cada rol en cada servidor esté listo para aceptar esta nueva configuración y, si es necesario, informa un error al usuario.  Cuando todos están de acuerdo con la configuración, se llama a <code>apply_config</code> . <br><br>  Los roles también admiten un método de <code>stop</code> para limpiar la basura.  Si decimos que no hay necesidad del planificador en este servidor, puede detener las fibras que comenzó a usar <code>init</code> . <br><br>  Los roles pueden interactuar entre sí.  Estamos acostumbrados a escribir llamadas a funciones de Lua, pero el proceso podría no tener el rol necesario.  Para facilitar el acceso a la red, utilizamos un módulo auxiliar llamado rpc (llamada a procedimiento remoto), que se basa en el módulo estándar de Tarantool net.box.  Esto puede ser útil, por ejemplo, si su puerta de enlace quiere pedirle directamente al programador que realice la tarea ahora, en lugar de hacerlo en un día. <br><br>  Otro punto importante es garantizar la tolerancia a fallas.  Cartridge utiliza el protocolo SWIM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">[4]</a> para controlar el estado.  En resumen, los procesos intercambian "rumores" entre sí a través de UDP, es decir, cada proceso informa a sus vecinos las últimas noticias y ellos responden.  Si de repente no hay respuesta, Tarantool sospecha que algo está mal, y después de un tiempo, declara la muerte y envía este mensaje a todos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/748/1ff/6f2/7481ff6f235c9833ac93d4aa310e2911.png"></div><br>  Según este protocolo, Cartridge organiza la conmutación por error automática.  Cada proceso monitorea su entorno, y si el líder deja de responder repentinamente, la réplica podría reclamar su rol, y Cartridge configuraría los roles en ejecución en consecuencia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49a/925/53b/49a92553be1edd2834c373b14cf17431.png"></div><br>  Debe tener cuidado aquí porque el cambio frecuente de ida y vuelta puede generar conflictos de datos durante la replicación.  La conmutación por error automática no debe activarse al azar.  Debe tener una idea clara de lo que está sucediendo y asegurarse de que la replicación no se bloquee cuando el líder se recupere y recupere su corona. <br><br>  De todo lo que se ha dicho, los roles pueden parecer similares a los microservicios.  En cierto sentido, son pero solo como módulos dentro de los procesos de Tarantool, y hay varias diferencias fundamentales.  Primero, todos los roles del proyecto deben vivir en la misma base de código.  Y todos los procesos de Tarantool deben ejecutarse desde la misma base de código, para que no haya sorpresas, como cuando intentamos inicializar el programador, pero simplemente no hay programador.  Además, no deberíamos permitir diferencias en las versiones de código porque el comportamiento del sistema es complicado de predecir y depurar en tal situación. <br><br>  A diferencia de Docker, no podemos simplemente tomar una "imagen" de un rol, transferirlo a otra máquina y ejecutarlo allí.  Nuestros roles no están tan aislados como los contenedores Docker.  Además, no podemos ejecutar dos roles idénticos en la misma instancia.  El papel está ahí o no está;  en cierto sentido, es un singleton.  Y en tercer lugar, los roles deberían ser los mismos en todo el grupo de replicación porque, de lo contrario, se vería ridículo: los datos son los mismos, pero el comportamiento es diferente. <br><br><h2>  Herramientas de implementación </h2><br>  Prometí mostrarle cómo Cartridge podría ayudar a implementar aplicaciones.  Para facilitar la vida, el marco crea paquetes RPM: <br><br><pre> <code class="plaintext hljs">$ cartridge pack rpm myapp # will create ./myapp-0.1.0-1.rpm $ sudo yum install ./myapp-0.1.0-1.rpm</code> </pre> <br>  El paquete instalado contiene casi todo lo que necesita: tanto la aplicación como las dependencias Lua instaladas.  Tarantool también llega al servidor como una dependencia del paquete RPM, y nuestro servicio está listo para lanzarse.  Todo esto se hace usando systemd, pero primero, debemos hacer alguna configuración, al menos especificar el URI de cada proceso.  Tres serían suficientes para nuestro ejemplo. <br><br><pre> <code class="plaintext hljs">$ sudo tee /etc/tarantool/conf.d/demo.yml &lt;&lt;CONFIG myapp.router: {"advertise_uri": "localhost:3301", "http_port": 8080} myapp.storage_A: {"advertise_uri": "localhost:3302", "http_enabled": False} myapp.storage_B: {"advertise_uri": "localhost:3303", "http_enabled": False} CONFIG</code> </pre> <br>  Hay un aspecto interesante que debe considerarse: en lugar de especificar solo el puerto de protocolo binario, especificamos la dirección pública de todo el proceso, incluido el nombre de host.  Estamos haciendo esto porque los nodos del clúster deberían saber cómo conectarse entre sí.  Sería una mala idea usar la dirección 0.0.0.0 como publicidad_uri, ya que debería ser una dirección IP externa, en lugar de un enlace de socket.  Nada funciona sin él, por lo que Cartridge simplemente no permitiría que se inicie el nodo con el publicidad errónea. <br><br>  Ahora que la configuración está lista, podemos comenzar los procesos.  Como una unidad systemd normal no permite iniciar múltiples procesos, las llamadas unidades instanciadas instalan las aplicaciones en Cartridge: <br><br><pre> <code class="plaintext hljs">$ sudo systemctl start myapp@router $ sudo systemctl start myapp@storage_A $ sudo systemctl start myapp@storage_B</code> </pre> <br>  Hemos especificado el puerto HTTP para la interfaz web del cartucho en la configuración: 8080. Veamos allí y echemos un vistazo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4d/c41/8fc/c4dc418fca8a18c3f3dd2c4430bd1eaa.png"></div><br>  Podemos ver que los procesos aún no están configurados, aunque ya se están ejecutando.  Cartridge aún no sabe cómo se debe realizar la replicación y no puede decidir por sí solo, por lo que está esperando nuestras acciones.  No tenemos muchas opciones: la vida de un nuevo clúster comienza con la configuración del primer nodo.  Luego agregamos otros nodos al clúster, les asignamos roles y la implementación se puede considerar completada con éxito. <br><br>  Vamos a tomar una copa y relajarnos después de una larga semana laboral.  La aplicación está lista para usar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95e/78c/fc5/95e78cfc50600fc8b3acf86d3f553242.png"></div><br><h2>  Resultados </h2><br>  ¿Qué hay de los resultados?  Pruebe, use, deje comentarios y cree tickets en Github. <br><br><h2>  Referencias </h2><br>  [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tarantool »2.2» Referencia »Referencia de rocas» Módulo vshard</a> <br>  [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo implementamos el núcleo del negocio de inversiones de Alfa-Bank basado en Tarantool</a> <br>  [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Arquitectura de facturación de próxima generación: transición a Tarantool</a> <br>  [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SWIM - Protocolo de creación de clústeres</a> <br>  [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub - tarantool / cartucho-cli</a> <br>  [6] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub - tarantool / cartucho</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470812/">https://habr.com/ru/post/470812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470800/index.html">P - anticipación, así como el programa preliminar DUMP Kazan. Vea los informes que han pasado la selección de picadora de carne</a></li>
<li><a href="../470802/index.html">Copia de seguridad, Parte 6: Comparación de herramientas de copia de seguridad</a></li>
<li><a href="../470804/index.html">Premio Alice: 5 ideas del ganador</a></li>
<li><a href="../470806/index.html">Problema de prueba fundamental</a></li>
<li><a href="../470808/index.html">Astra Linux "Eagle" Common Edition: ¿hay vida después de Windows?</a></li>
<li><a href="../470814/index.html">Materiales de android-mitap: herramientas para autotests | Yandex Mapkit 3 | diseño de aplicaciones | IU dirigida por el servidor</a></li>
<li><a href="../470816/index.html">Rusia - TPA - Bielorrusia: Aquí el tercero no es en absoluto superfluo</a></li>
<li><a href="../470818/index.html">Bug Hunt, Blind-XSS y Fox Tricks</a></li>
<li><a href="../470820/index.html">Una prueba rápida de docenas de hipótesis: cómo salimos de la rutina y tenemos una discusión en otra ciudad</a></li>
<li><a href="../470822/index.html">Monitoreo de temperatura en la empresa.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>