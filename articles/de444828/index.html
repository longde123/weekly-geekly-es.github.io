<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥ üßóüèæ üöô Eine einfache Erkl√§rung der Pfadfindungsalgorithmen und A * üë®üèª‚Äçüîß ‚úãüèª üë©üèΩ‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teil 1. Allgemeiner Suchalgorithmus 
 Einf√ºhrung 
 Einen Pfad zu finden ist eines der Themen, die f√ºr Spieleentwickler normalerweise am schwierigsten ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine einfache Erkl√§rung der Pfadfindungsalgorithmen und A *</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444828/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif" alt="Bild"></div><br><h2>  Teil 1. Allgemeiner Suchalgorithmus </h2><br><h2>  Einf√ºhrung </h2><br>  Einen Pfad zu finden ist eines der Themen, die f√ºr Spieleentwickler normalerweise am schwierigsten sind.  Besonders schlecht verstehen die Leute den <strong>A *</strong> -Algorithmus und viele denken, dass dies eine Art unverst√§ndliche Magie ist. <br><br>  Der Zweck dieses Artikels ist es, die Suche nach dem Pfad im Allgemeinen und <strong>A *</strong> im Besonderen auf sehr verst√§ndliche und zug√§ngliche Weise zu erl√§utern und damit dem weit verbreiteten Missverst√§ndnis ein Ende zu setzen, dass dieses Thema komplex ist.  Mit der richtigen Erkl√§rung ist alles ganz einfach. <br><br>  Bitte beachten Sie, dass wir in diesem Artikel die Suche nach einem Weg <em>f√ºr Spiele betrachten werden</em> .  Im Gegensatz zu eher wissenschaftlichen Artikeln werden Suchalgorithmen wie "Tiefe zuerst" oder "Breite zuerst" weggelassen.  Stattdessen werden wir versuchen, so schnell wie m√∂glich von Null auf <strong>A *</strong> zu gelangen. <br><a name="habracut"></a><br>  Im ersten Teil werden die einfachsten Konzepte zum Finden eines Pfades erl√§utert.  Wenn Sie diese Grundkonzepte verstehen, werden Sie feststellen, dass <strong>A *</strong> √ºberraschend offensichtlich ist. <br><br><h2>  Einfache Schaltung </h2><br>  Obwohl Sie diese Konzepte auf beliebig komplexe 3D-Umgebungen anwenden k√∂nnen, beginnen wir mit einem √§u√üerst einfachen Schema: einem 5 x 5-Quadrat-Raster. Der Einfachheit halber habe ich jede Zelle mit einem Gro√übuchstaben markiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2d/66c/ed8/e2d66ced82a4c1d4ed739583bd782245.png"></div><br>  <i>Einfaches Netz.</i> <br><br>  Das allererste, was wir tun werden, ist, uns diese Umgebung als Grafik vorzustellen.  Ich werde nicht im Detail erkl√§ren, was ein Graph ist;  Einfach ausgedr√ºckt ist dies eine Reihe von Kreisen, die durch Pfeile verbunden sind.  Die Kreise werden <em>"Knoten" genannt,</em> und die Pfeile werden <em>"Kanten" genannt.</em> <br><br>  Jeder Knoten repr√§sentiert einen <em>"Zustand",</em> in dem sich das Zeichen befinden kann.  In unserem Fall ist der Status des Charakters seine Position, daher erstellen wir einen Knoten f√ºr jede Gitterzelle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68a/d4b/4db/68ad4b4db470c1ce34434e6489a5a986.png"></div><br>  <i>Knoten, die Gitterzellen darstellen.</i> <br><br>  F√ºgen Sie nun die Rippen hinzu.  Sie geben die Zust√§nde an, die von jedem gegebenen Zustand <em>"erreicht" werden</em> k√∂nnen;  In unserem Fall k√∂nnen wir von jeder Zelle zur n√§chsten wechseln, mit Ausnahme der blockierten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f73/56c/9be/f7356c9be0171d61c31e3e4c21bf9385.png"></div><br>  <i>B√∂gen bezeichnen zul√§ssige Bewegungen zwischen Gitterzellen.</i> <br><br>  Wenn wir von <strong>A</strong> nach <strong>B gelangen k√∂nnen</strong> , sagen wir, dass <strong>B</strong> ein <em>‚ÄûNachbar‚Äú</em> des <strong>A-</strong> Knotens ist. <br><br>  Es ist erw√§hnenswert, dass die Rippen eine <em>Richtung haben</em> ;  Wir brauchen Kanten von <strong>A</strong> nach <strong>B</strong> und von <strong>B</strong> nach <strong>A.</strong>  Dies mag √ºberfl√ºssig erscheinen, aber nicht, wenn komplexere ‚ÄûBedingungen‚Äú auftreten k√∂nnen.  Zum Beispiel kann ein Charakter vom Dach auf den Boden fallen, kann aber nicht vom Boden auf das Dach springen.  Sie k√∂nnen vom Zustand "lebendig" in den Zustand "tot" wechseln, aber nicht umgekehrt.  Usw. <br><br><h2>  Beispiel </h2><br>  Angenommen, wir m√∂chten von <strong>A</strong> nach <strong>T</strong> wechseln <strong>.</strong>  Wir beginnen mit <strong>A.</strong>  Sie k√∂nnen genau zwei Aktionen ausf√ºhren: Gehen Sie zu <strong>B</strong> oder gehen Sie zu <strong>F.</strong> <br><br>  Nehmen wir an, wir sind nach <strong>B gezogen.</strong>  Jetzt k√∂nnen wir zwei Dinge tun: zu <strong>A zur√ºckkehren</strong> oder zu <strong>C</strong> gehen <strong>.</strong>  Wir erinnern uns, dass wir bereits in <strong>A waren</strong> und die Optionen dort in Betracht gezogen haben, daher macht es keinen Sinn, es erneut zu tun (andernfalls k√∂nnen wir den ganzen Tag damit verbringen, <strong>A</strong> ‚Üí <strong>B</strong> ‚Üí <strong>A</strong> ‚Üí <strong>B</strong> ... zu bewegen).  Deshalb gehen wir zu <strong>C.</strong> <br><br>  Wenn wir in <strong>C sind</strong> , k√∂nnen wir uns nirgendwo bewegen.  Die R√ºckkehr zu <strong>B ist</strong> sinnlos, das hei√üt, es ist eine Sackgasse.  Den √úbergang zu <strong>B zu</strong> w√§hlen, als wir in <strong>A waren,</strong> war eine schlechte Idee;  Vielleicht solltest du stattdessen <strong>F</strong> versuchen? <br><br>  Wir wiederholen diesen Vorgang nur so lange, bis wir in <strong>T</strong> landen <strong>.</strong>  In diesem Moment erstellen wir einfach den Pfad von <strong>A neu</strong> und kehren in unseren Schritten zur√ºck.  Wir sind in <strong>T</strong> ;  Wie sind wir dorthin gekommen?  Von <strong>o</strong> ?  Das hei√üt, das Ende des Pfades hat die Form <strong>O</strong> ‚Üí <strong>T.</strong>  Wie sind wir zu <strong>O gekommen</strong> ?  Usw. <br><br>  Denken Sie daran, dass wir uns nicht wirklich <em>bewegen</em> .  Das alles war nur ein Denkprozess.  Wir stehen weiterhin in <strong>A</strong> und werden uns nicht davon entfernen, bis wir den ganzen Weg gefunden haben.  Wenn ich "nach <strong>B gezogen</strong> " sage, meine ich "stell dir vor, wir sind nach <strong>B gezogen</strong> ". <br><br><h2>  Allgemeiner Algorithmus </h2><br>  <strong>Dieser Abschnitt ist der wichtigste Teil des gesamten Artikels</strong> .  Sie <em>m√ºssen</em> es unbedingt verstehen, um die Suche nach dem Weg realisieren zu k√∂nnen;  Der Rest (einschlie√ülich <strong>A *</strong> ) sind nur Details.  In diesem Abschnitt werden Sie verstehen, bis Sie <em>die Bedeutung verstehen</em> . <br><br>  Dar√ºber hinaus ist dieser Abschnitt unglaublich einfach. <br><br>  Versuchen wir, unser Beispiel zu formalisieren und es in einen Pseudocode umzuwandeln. <br><br>  Wir m√ºssen die Knoten verfolgen, die wir vom Startknoten aus erreichen k√∂nnen.  Zu Beginn ist dies nur der Startknoten, aber beim ‚ÄûErkunden‚Äú des Rasters lernen wir, wie Sie zu anderen Knoten gelangen.  Nennen wir diese Liste der <code>reachable</code> Knoten: <br><br><pre> <code class="python hljs">reachable = [start_node]</code> </pre> <br>  Wir m√ºssen auch die bereits √ºberpr√ºften Knoten verfolgen, um sie nicht erneut zu ber√ºcksichtigen.  Nennen <code>explored</code> sie <code>explored</code> : <br><br><pre> <code class="python hljs">explored = []</code> </pre> <br>  <strong>Als n√§chstes werde ich den Kern des Algorithmus skizzieren</strong> : Bei jedem Schritt der Suche w√§hlen wir einen der Knoten aus, die wir erreichen k√∂nnen, und schauen uns an, welche neuen Knoten wir daraus erhalten k√∂nnen.  Wenn wir bestimmen, wie der letzte (Ziel-) Knoten erreicht werden soll, ist das Problem gel√∂st!  Ansonsten setzen wir die Suche fort. <br><br>  So einfach, was entt√§uscht √ºberhaupt?  Und das ist wahr.  Aber das ist der ganze Algorithmus.  Schreiben wir es Schritt f√ºr Schritt mit Pseudocode auf. <br><br>  Wir suchen weiter, bis wir entweder zum Endknoten gelangen (in diesem Fall finden wir den Pfad vom Anfangsknoten zum Endknoten) oder bis uns die Knoten ausgehen, in denen Sie suchen k√∂nnen (in diesem Fall gibt es keinen Weg zwischen dem Start- und dem Endknoten). . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty:</code> </pre> <br>  Wir w√§hlen einen der Knoten aus, zu denen wir gelangen k√∂nnen und der noch nicht untersucht wurde: <br><br><pre> <code class="python hljs"> node = choose_node(reachable)</code> </pre> <br>  Wenn wir gerade gelernt haben, wie man zum letzten Knoten kommt, ist die Aufgabe abgeschlossen!  Wir m√ºssen nur den Pfad erstellen, indem wir den <code>previous</code> Links zur√ºck zum Startknoten folgen: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == goal_node: path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(node) node = node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  Es macht keinen Sinn, den Knoten mehr als einmal zu untersuchen, daher werden wir Folgendes verfolgen: <br><br><pre> <code class="python hljs"> reachable.remove(node) explored.add(node)</code> </pre> <br>  Wir identifizieren Knoten, die wir von hier aus nicht erreichen k√∂nnen.  Wir beginnen mit einer Liste von Knoten neben dem aktuellen und l√∂schen die bereits untersuchten Knoten: <br><br><pre> <code class="python hljs"> new_reachable = get_adjacent_nodes(node) - explored</code> </pre> <br>  Wir nehmen jeden von ihnen: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_reachable:</code> </pre> <br>  Wenn wir bereits wissen, wie wir den Knoten erreichen k√∂nnen, ignorieren Sie ihn.  Andernfalls f√ºgen Sie es der <code>reachable</code> Liste hinzu und verfolgen Sie, wie es hineingekommen ist: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br>  Das Finden des Endknotens ist eine M√∂glichkeit, die Schleife zu verlassen.  Das zweite ist, wenn das <code>reachable</code> leer wird: Wir haben keine Knoten mehr, die erkundet werden k√∂nnen, und wir haben den Endknoten nicht erreicht, dh es gibt keinen Weg vom Anfang zum Endknoten: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Und ... das war's.  Dies ist der gesamte Algorithmus, und der Pfadkonstruktionscode wird in einer separaten Methode zugewiesen: <br><br><pre> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: if adjacent not in reachable adjacent.previous = node # Remember how we got there. reachable.add(adjacent) # If we get here, no path was found :( return None</span></span></code> </pre> <br>  Hier ist die Funktion, die den Pfad erstellt und den <code>previous</code> Links zur√ºck zum Startknoten folgt: <br><br><pre> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  Das ist alles.  <em>Dies ist der</em> Pseudocode <em>jedes</em> Pfadsuchalgorithmus, einschlie√ülich <strong>A *</strong> . <br><br>  Lesen Sie diesen Abschnitt erneut, bis Sie verstanden haben, wie alles funktioniert und, was noch wichtiger ist, <em>warum</em> alles funktioniert.  Es w√§re ideal, ein Beispiel von Hand auf Papier zu zeichnen, aber Sie k√∂nnen sich auch eine interaktive Demo ansehen: <br><br><h2>  Interaktive Demo </h2><br>  Hier ist eine Demo und ein Beispiel f√ºr die Implementierung des oben gezeigten Algorithmus (Sie k√∂nnen ihn auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seite des Originalartikels</a> ausf√ºhren).  <code>choose_node</code> w√§hlt nur einen zuf√§lligen Knoten aus.  Sie k√∂nnen den Algorithmus Schritt f√ºr Schritt starten und die Liste der <code>reachable</code> und <code>explored</code> sowie die Verweise auf die <code>previous</code> Links anzeigen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vt/jk/cb/vtjkcb4tflduq7zu5p-oph2i73s.gif"></div><br>  Beachten Sie, dass die Suche beendet wird, sobald ein Pfad erkannt wird.  Es kann vorkommen, dass einige Knoten nicht einmal ber√ºcksichtigt werden. <br><br><h2>  Fazit </h2><br>  Der hier vorgestellte Algorithmus ist ein allgemeiner Algorithmus f√ºr <em>jeden</em> Pfadsuchalgorithmus. <br><br>  Aber was unterscheidet jeden Algorithmus von einem anderen, warum ist <strong>A *</strong> <strong>A *</strong> ? <br><br>  Hier ist ein Tipp: Wenn Sie die Suche in der Demo mehrmals ausf√ºhren, werden Sie feststellen, dass der Algorithmus nicht immer denselben Pfad findet.  Er findet <em>einen</em> Weg, und dieser Weg ist nicht unbedingt der <em>k√ºrzeste</em> .  Warum? <br><br><h2>  Teil 2. Suchstrategien </h2><br>  Wenn Sie den im vorherigen Abschnitt beschriebenen Algorithmus nicht vollst√§ndig verstehen, kehren Sie zu ihm zur√ºck und lesen Sie ihn erneut, da dies zum Verst√§ndnis weiterer Informationen erforderlich ist.  Wenn Sie es herausfinden, erscheint Ihnen <strong>A *</strong> v√∂llig nat√ºrlich und logisch. <br><br><h2>  Geheime Zutat </h2><br>  Am Ende des vorherigen Teils habe ich zwei Fragen offen gelassen: Wenn jeder Suchalgorithmus denselben Code verwendet, warum verh√§lt sich <strong>A * dann</strong> wie <strong>A *</strong> ?  Und warum findet die Demo manchmal andere Wege? <br><br>  Die Antworten auf beide Fragen h√§ngen miteinander zusammen.  Obwohl der Algorithmus gut definiert ist, habe ich einen Aspekt ungel√∂st gelassen, und wie sich herausstellt, ist er der Schl√ºssel zur Erkl√§rung des Verhaltens von Suchalgorithmen: <br><br><pre> <code class="python hljs">node = choose_node(reachable)</code> </pre> <br>  Es ist diese unschuldig aussehende Zeichenfolge, die alle Suchalgorithmen voneinander unterscheidet.  <code>choose_node</code> h√§ngt von der Implementierungsmethode von <code>choose_node</code> . <br><br>  Warum findet die Demo unterschiedliche Wege?  Weil die Methode <code>choose_node</code> einen Knoten zuf√§llig ausw√§hlt. <br><br><h2>  L√§nge ist wichtig </h2><br>  Bevor wir uns mit den Unterschieden im Verhalten der Funktion <code>choose_node</code> , m√ºssen wir ein kleines Versehen in dem oben beschriebenen Algorithmus beheben. <br><br>  Bei der Betrachtung der an den Strom angrenzenden Knoten haben wir diejenigen ignoriert, die bereits wissen, wie dies erreicht werden kann: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br>  Dies ist ein Fehler: Was w√§re, wenn wir gerade den <em>besten</em> Weg finden w√ºrden, dorthin zu gelangen?  In diesem Fall muss die <code>previous</code> Knotenverbindung ge√§ndert werden, um diesen k√ºrzeren Pfad widerzuspiegeln. <br><br>  Dazu m√ºssen wir die L√§nge des Pfades vom Startknoten zu jedem erreichbaren Knoten kennen.  Wir werden dies die Kosten des Pfades nennen.  Im Moment gehen wir davon aus, dass der Wechsel von einem Knoten zu einem der benachbarten Knoten konstante Kosten von <code>1</code> . <br><br>  Bevor wir mit der Suche beginnen, weisen wir den <code>cost</code> jedes Knotens der <code>infinity</code> .  Dank dessen wird <em>jeder</em> Weg k√ºrzer sein.  Wir werden auch die <code>cost</code> den Knoten <code>start_node</code> auf <code>0</code> . <br><br>  Dann sieht der Code folgenderma√üen aus: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: reachable.add(adjacent) <span class="hljs-comment"><span class="hljs-comment"># If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1</span></span></code> </pre> <br><h2>  Gleiche Suchkosten </h2><br>  Schauen wir uns nun die Methode <code>choose_node</code> .  Wenn wir versuchen, den k√ºrzestm√∂glichen Weg zu finden, ist es keine gute Idee, einen Knoten zuf√§llig auszuw√§hlen. <br><br>  Es ist besser, einen Knoten auszuw√§hlen, den wir vom Anfangsknoten auf dem k√ºrzesten Weg erreichen k√∂nnen.  Aus diesem Grund bevorzugen wir in der Regel k√ºrzere Wege gegen√ºber l√§ngeren.  Dies bedeutet nicht, dass l√§ngere Pfade √ºberhaupt nicht ber√ºcksichtigt werden, sondern dass k√ºrzere Pfade zuerst ber√ºcksichtigt werden.  Da der Algorithmus unmittelbar nach dem Finden eines geeigneten Pfades beendet wird, sollten wir kurze Pfade finden k√∂nnen. <br><br>  Hier ist ein m√∂gliches Beispiel f√ºr die Funktion <code>choose_node</code> : <br><br><pre> <code class="python hljs">function choose_node (reachable): best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> best_node == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> best_node.cost &gt; node.cost: best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Intuitiv erweitert sich die Suche nach diesem Algorithmus "radial" vom Startknoten bis zum Endknoten.  Hier ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine interaktive Demo</a> dieses Verhaltens: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nh/fn/jd/nhfnjd_ztdx3fbuqy5v5_am5hxw.gif"></div><br><h2>  Fazit </h2><br>  Eine einfache √Ñnderung der Methode zur Auswahl des Knotens, die im Folgenden ber√ºcksichtigt wird, erm√∂glichte es uns, einen ziemlich guten Algorithmus zu erhalten: Er findet den k√ºrzesten Weg vom Start- zum Endknoten. <br><br>  Aber dieser Algorithmus bleibt bis zu einem gewissen Grad "dumm".  Er sucht √ºberall weiter, bis er auf einen Endknoten st√∂√üt.  Was ist beispielsweise der Punkt in dem oben gezeigten Beispiel, um in Richtung <strong>A</strong> zu suchen, wenn es offensichtlich ist, dass wir uns vom Endknoten entfernen? <br><br>  Ist es m√∂glich, <code>choose_node</code> intelligenter zu machen?  K√∂nnen wir <em>die Suche auf den Endknoten richten</em> , ohne vorher den richtigen Pfad zu kennen? <br><br>  Es stellt sich heraus, dass wir es k√∂nnen - im n√§chsten Teil gelangen wir schlie√ülich zu <code>choose_node</code> , wodurch wir den allgemeinen Pfad-Suchalgorithmus in <strong>A *</strong> <code>choose_node</code> k√∂nnen. <br><br><h2>  Teil 3. Entfernen Sie den Schleier der Geheimhaltung von A * </h2><br>  Der im vorherigen Teil erhaltene Algorithmus ist recht gut: Er findet den k√ºrzesten Weg vom Startknoten zum letzten.  Er verschwendet jedoch seine Energie: Er betrachtet die Art und Weise, wie eine Person offensichtlich als falsch bezeichnet - sie <em>bewegt sich</em> normalerweise vom Ziel <em>weg</em> .  Wie kann dies vermieden werden? <br><br><h2>  Magischer Algorithmus </h2><br>  Stellen Sie sich vor, wir f√ºhren einen Suchalgorithmus auf einem speziellen Computer mit einem Chip aus, der <em>Magie kann</em> .  Dank dieses erstaunlichen Chips k√∂nnen wir <code>choose_node</code> sehr einfache Weise ausdr√ºcken, wodurch garantiert der k√ºrzeste Pfad erstellt wird, ohne Zeit damit zu verschwenden, <code>choose_node</code> erkunden, die nirgendwohin f√ºhren: <br><br><pre> <code class="python hljs">function choose_node (reachable): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> magic(reachable, <span class="hljs-string"><span class="hljs-string">" ,     "</span></span>)</code> </pre> <br>  Klingt verlockend, aber Magic Chips ben√∂tigen immer noch eine Art Low-Level-Code.  Hier ist eine gute Ann√§herung: <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = magic(node, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Dies ist eine gro√üartige M√∂glichkeit, den n√§chsten Knoten auszuw√§hlen: Sie w√§hlen einen Knoten aus, der uns den k√ºrzesten Weg vom Start- zum Endknoten bietet, was wir brauchen. <br><br>  Wir haben auch die Menge an Magie minimiert: Wir wissen genau, wie <code>node.cost</code> die Kosten f√ºr den Umzug vom Startknoten zu jedem Knoten sind (dies ist <code>node.cost</code> ), und wir verwenden Magie nur, um die Kosten f√ºr den Umzug vom Knoten zum Endknoten vorherzusagen. <br><br><h2>  Nicht magisch, aber ziemlich gro√üartig A * </h2><br>  Leider sind Magic Chips neu und wir brauchen Unterst√ºtzung von veralteten Ger√§ten.  Der gr√∂√üte Teil des Codes passt zu uns, mit Ausnahme dieser Zeile: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Throws MuggleProcessorException cost_node_to_goal = magic(node, "   ")</span></span></code> </pre> <br>  Das hei√üt, wir k√∂nnen keine Magie verwenden, um die Kosten eines unerforschten Pfades herauszufinden.  Dann machen wir eine Vorhersage.  Wir werden optimistisch sein und annehmen, dass zwischen dem aktuellen und dem endg√ºltigen Knoten nichts ist, und wir k√∂nnen uns einfach direkt bewegen: <br><br><pre> <code class="python hljs">cost_node_to_goal = distance(node, goal_node)</code> </pre> <br>  Beachten Sie, dass der <em>k√ºrzeste Weg</em> und der <em>Mindestabstand</em> unterschiedlich sind: Der Mindestabstand impliziert, dass zwischen dem aktuellen und dem Endknoten absolut keine Hindernisse bestehen. <br><br>  Diese Sch√§tzung ist recht einfach zu erhalten.  In unseren Gitterbeispielen ist dies der <em>Abstand von Stadtbl√∂cken</em> zwischen zwei Knoten (d. H. <code>abs(Ax - Bx) + abs(Ay - By)</code> ).  Wenn wir uns diagonal bewegen k√∂nnten, w√§re der Wert gleich <code>sqrt( (Ax - Bx)^2 + (Ay - By)^2 )</code> und so weiter.  Am wichtigsten ist, dass wir niemals eine <em>zu</em> hohe Wertsch√§tzung erhalten. <br><br>  Hier ist also eine nicht <code>choose_node</code> Version von <code>choose_node</code> : <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Eine Funktion, die die Entfernung vom Strom zum Endknoten sch√§tzt, wird als <em>Heuristik bezeichnet</em> , und dieser Suchalgorithmus, meine Damen und Herren, wird als ... <strong>A * bezeichnet</strong> . <br><br><h2>  Interaktive Demo </h2><br>  W√§hrend Sie sich von dem Schock erholen, der durch die Erkenntnis verursacht wurde, dass das mysteri√∂se <strong>A *</strong> tats√§chlich <em>so einfach ist</em> , k√∂nnen Sie sich die Demo ansehen (oder sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalartikel</a> ausf√ºhren).  Sie werden feststellen, dass die Suche im Gegensatz zum vorherigen Beispiel nur sehr wenig Zeit damit verbringt, sich in die falsche Richtung zu bewegen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif"></div><br><h2>  Fazit </h2><br>  Schlie√ülich kamen wir zum <strong>A *</strong> -Algorithmus, der nichts anderes ist als der im ersten Teil des Artikels beschriebene allgemeine Suchalgorithmus mit einigen im zweiten Teil beschriebenen Verbesserungen und unter Verwendung der Funktion <code>choose_node</code> , die den Knoten ausw√§hlt, der uns nach unserer Sch√§tzung n√§her bringt Endknoten.  Das ist alles. <br><br>  Hier ist ein vollst√§ndiger Pseudocode der Hauptmethode als Referenz: <br><br><pre> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here that we haven't explored before? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: # First time we see this node? if adjacent not in reachable: reachable.add(adjacent) # If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1 # If we get here, no path was found :( return None</span></span></code> </pre> <br>  <code>build_path</code> Methode: <br><br><pre> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  Und hier ist die Methode <code>choose_node</code> , die daraus <strong>A * macht</strong> : <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Das ist alles. <br><br>  Aber warum brauchen wir <strong>Teil 4</strong> ? <br><br>  Nachdem Sie nun verstanden haben, wie <strong>A *</strong> funktioniert, m√∂chte ich auf einige erstaunliche Bereiche seiner Anwendung eingehen, die weit davon entfernt sind, Pfade in einem Zellenraster zu finden. <br><br><h2>  Teil 4. A * in der Praxis </h2><br>  Die ersten drei Teile des Artikels beginnen mit den Grundlagen der Pfadsuchalgorithmen und enden mit einer klaren Beschreibung des <strong>A *</strong> -Algorithmus.  All dies ist theoretisch gro√üartig, aber zu verstehen, wie dies in der Praxis anwendbar ist, ist ein v√∂llig anderes Thema. <br><br>  Was passiert zum Beispiel, wenn unsere Welt kein Gitter ist? <br><br>  Was ist, wenn sich ein Charakter nicht sofort um 90 Grad drehen kann? <br><br>  Wie erstelle ich ein Diagramm, wenn die Welt endlos ist? <br><br>  Was ist, wenn uns die L√§nge des Weges egal ist, wir aber auf Sonnenenergie angewiesen sind und so viel wie m√∂glich unter Sonnenlicht stehen m√ºssen? <br><br>  Wie finde ich den k√ºrzesten Weg zu einem der beiden Endknoten? <br><br><h2>  Kostenfunktion </h2><br>  In den ersten Beispielen haben wir nach dem k√ºrzesten Weg zwischen dem Start- und dem Endknoten gesucht.  Anstatt jedoch Teilpfadl√§ngen in der variablen <code>length</code> speichern, haben wir es <code>cost</code> .  Warum? <br><br>  Wir k√∂nnen <strong>A *</strong> nicht nur nach dem <em>k√ºrzesten</em> , sondern auch nach dem <em>besten</em> Weg suchen lassen, und die Definition von ‚Äûam besten‚Äú kann basierend auf unseren Zielen gew√§hlt werden.  Wenn wir den k√ºrzesten Weg ben√∂tigen, sind die Kosten die L√§nge des Weges. Wenn wir jedoch beispielsweise den Kraftstoffverbrauch minimieren m√∂chten, m√ºssen wir ihn als Kosten verwenden.  Wenn wir die ‚ÄûZeit unter der Sonne‚Äú maximieren m√∂chten, sind die Kosten die Zeit ohne Sonne.  Usw. <br><br>  Im allgemeinen Fall bedeutet dies, dass jeder Kante des Diagramms entsprechende Kosten zugeordnet sind.  In den oben gezeigten Beispielen wurde der Wert implizit festgelegt und immer als <code>1</code> , da wir die Schritte auf dem Weg gez√§hlt haben.  Aber wir k√∂nnen die Kosten der Rippe entsprechend dem √§ndern, was wir minimieren m√∂chten. <br><br><h2>  Kriteriumsfunktion </h2><br>  Nehmen wir an, unser Objekt ist ein Auto, und er muss zur Tankstelle.  Jegliches Auftanken passt zu uns.  Es ist der k√ºrzeste Weg zur n√§chsten Tankstelle. <br><br>  Der naive Ansatz besteht darin, nacheinander den k√ºrzesten Weg zu jeder Betankung zu berechnen und den k√ºrzesten auszuw√§hlen.  Dies wird funktionieren, aber es wird ein ziemlich kostspieliger Prozess sein. <br><br>  Was w√§re, wenn wir einen <code>goal_node</code> durch eine Methode ersetzen <code>goal_node</code> , die auf einem bestimmten Knoten erkennen kann, ob er endlich ist oder nicht.  Dank dessen k√∂nnen wir gleichzeitig nach mehreren Zielen suchen.  Wir m√ºssen auch die Heuristik so √§ndern, dass sie die gesch√§tzten Mindestkosten aller m√∂glichen Endknoten zur√ºckgibt. <br><br>  Abh√§ngig von den Besonderheiten der Situation k√∂nnen wir das Ziel m√∂glicherweise nicht <em>perfekt erreichen</em> , oder es kostet zu viel (wenn wir den Charakter durch eine halbe gro√üe Karte senden, ist der Unterschied einen Zoll wichtig?). Die Methode <code>is_goal_node</code> kann also <code>true</code> wenn wir Wir sind "nah genug". <br><br><h2>  Volle Sicherheit ist nicht erforderlich. </h2><br>  Die Darstellung der Welt als diskretes Gitter reicht f√ºr viele Spiele m√∂glicherweise nicht aus.  Nehmen Sie zum Beispiel einen Ego-Shooter oder ein Rennspiel.  Die Welt ist diskret, kann aber nicht als Gitter dargestellt werden. <br><br>  Aber es gibt ein ernsthafteres Problem: Was ist, wenn die Welt endlos ist?  In diesem Fall k√∂nnen wir, selbst wenn wir es in Form eines Gitters darstellen k√∂nnen, einfach kein dem Gitter entsprechendes Diagramm erstellen, da es unendlich sein muss. <br><br>  Es ist jedoch nicht alles verloren.  Nat√ºrlich brauchen wir f√ºr den Graph-Suchalgorithmus definitiv einen Graph.  Aber niemand sagte, dass die Grafik <em>umfassend sein sollte</em> ! <br><br>  Wenn Sie sich den Algorithmus genau ansehen, werden Sie feststellen, dass wir mit dem gesamten Diagramm nichts anfangen.  Wir untersuchen den Graphen lokal und erhalten Knoten, die wir vom betreffenden Knoten aus erreichen k√∂nnen.  Wie aus der Demo <strong>A *</strong> ersichtlich ist, werden einige Knoten des Graphen √ºberhaupt nicht untersucht. <br><br>  Warum erstellen wir das Diagramm nicht einfach im Forschungsprozess? <br><br>  Wir machen die aktuelle Position des Charakters zum Startknoten.  Beim Aufrufen von <code>get_adjacent_nodes</code> kann ermittelt werden, auf welche Weise sich der Charakter von einem bestimmten Knoten aus bewegen und im <code>get_adjacent_nodes</code> benachbarte Knoten erstellen kann. <br><br><h2>  Jenseits von drei Dimensionen </h2><br>  Auch wenn Ihre Welt <i>wirklich</i> ein 2D-Netz ist, m√ºssen andere Aspekte ber√ºcksichtigt werden.  Was ist zum Beispiel, wenn sich ein Zeichen nicht sofort um 90 oder 180 Grad drehen kann, wie dies normalerweise der Fall ist? <br><br>  <em>Der</em> von jedem Suchknoten dargestellte <em>Zustand</em> muss nicht nur eine <em>Position sein</em> .  im Gegenteil, es kann einen beliebig komplexen Satz von Werten enthalten.  Wenn beispielsweise 90-Grad-Drehungen so lange dauern wie der √úbergang von einer Zelle zur anderen, kann der Status des Charakters als <code>[position, heading]</code> .  Jeder Knoten kann nicht nur die Position des Charakters darstellen, sondern auch die Richtung seines Blicks.  und die neuen Kanten des Diagramms (explizit oder indirekt) spiegeln dies wider. <br><br>  Wenn Sie zum urspr√ºnglichen 5x5-Raster zur√ºckkehren, kann die anf√§ngliche Suchposition jetzt <code>[A, East]</code> .  Die benachbarten Knoten sind jetzt <code>[B, East]</code> und <code>[A, South]</code> Wenn wir <strong>F</strong> erreichen m√∂chten, m√ºssen wir zuerst die Richtung so anpassen, dass der Pfad die Form <code>[A, East]</code> , <code>[A, South]</code> , <code>[F, South]</code> . <br><br>  Ego-Shooter?  Mindestens vier Dimensionen: <code>[X, Y, Z, Heading]</code> .  Vielleicht sogar <code>[X, Y, Z, Heading, Health, Ammo]</code> . <br><br>  Beachten Sie, dass die heuristische Funktion umso komplexer sein sollte, je komplexer der Zustand ist.  <strong>A * selbst</strong> ist einfach;  Kunst entsteht oft aus guten Heuristiken. <br><br><h2>  Fazit </h2><br>  Der Zweck dieses Artikels ist es, den Mythos ein f√ºr alle Mal zu zerstreuen, dass <strong>A *</strong> ein mystischer Algorithmus ist, der nicht entschl√ºsselt werden kann.  Im Gegenteil, ich habe gezeigt, dass nichts Geheimnisvolles darin ist, und tats√§chlich kann es ganz einfach abgeleitet werden, indem man von vorne anf√§ngt. <br><br><h3>  Weiterf√ºhrende Literatur </h3><br>  Amit Patel hat eine exzellente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûEinf√ºhrung in den A * -Algorithmus‚Äú</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung</a> auf Habr√©] (und seine anderen Artikel zu verschiedenen Themen sind ebenfalls exzellent!). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444828/">https://habr.com/ru/post/de444828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444816/index.html">DIY Zimmerei: Erwartungen und Realit√§t</a></li>
<li><a href="../de444818/index.html">Citymobil - ein Leitfaden f√ºr Startups zur Erh√∂hung der Stabilit√§t bei Wachstum. Teil 1</a></li>
<li><a href="../de444820/index.html">Mockdown: Der schnellste Weg, um Wireframes zu erstellen</a></li>
<li><a href="../de444822/index.html">JDK 9 / JEP 280: Die Verkettung von Zeichenfolgen wird nie wieder dieselbe sein</a></li>
<li><a href="../de444824/index.html">Wie Amazon- und FedEx-Kurierroboter zuerst aussehen</a></li>
<li><a href="../de444830/index.html">Elektronische Cloud-Signatur in Russland und der Welt</a></li>
<li><a href="../de444832/index.html">"Keine Bereitstellungen am Freitag" und drei weitere unausgesprochene Entwicklungsregeln</a></li>
<li><a href="../de444836/index.html">Sie m√ºssen nicht an das Ged√§chtnis denken, sagten sie ... CLRium Workshop # 5: Garbage Collector</a></li>
<li><a href="../de444838/index.html">OWASP Russia Meetup</a></li>
<li><a href="../de444840/index.html">3. Check Point Erste Schritte R80.20. Layoutvorbereitung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>