<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴 🧗🏾 🚙 Eine einfache Erklärung der Pfadfindungsalgorithmen und A * 👨🏻‍🔧 ✋🏻 👩🏽‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teil 1. Allgemeiner Suchalgorithmus 
 Einführung 
 Einen Pfad zu finden ist eines der Themen, die für Spieleentwickler normalerweise am schwierigsten ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine einfache Erklärung der Pfadfindungsalgorithmen und A *</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444828/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif" alt="Bild"></div><br><h2>  Teil 1. Allgemeiner Suchalgorithmus </h2><br><h2>  Einführung </h2><br>  Einen Pfad zu finden ist eines der Themen, die für Spieleentwickler normalerweise am schwierigsten sind.  Besonders schlecht verstehen die Leute den <strong>A *</strong> -Algorithmus und viele denken, dass dies eine Art unverständliche Magie ist. <br><br>  Der Zweck dieses Artikels ist es, die Suche nach dem Pfad im Allgemeinen und <strong>A *</strong> im Besonderen auf sehr verständliche und zugängliche Weise zu erläutern und damit dem weit verbreiteten Missverständnis ein Ende zu setzen, dass dieses Thema komplex ist.  Mit der richtigen Erklärung ist alles ganz einfach. <br><br>  Bitte beachten Sie, dass wir in diesem Artikel die Suche nach einem Weg <em>für Spiele betrachten werden</em> .  Im Gegensatz zu eher wissenschaftlichen Artikeln werden Suchalgorithmen wie "Tiefe zuerst" oder "Breite zuerst" weggelassen.  Stattdessen werden wir versuchen, so schnell wie möglich von Null auf <strong>A *</strong> zu gelangen. <br><a name="habracut"></a><br>  Im ersten Teil werden die einfachsten Konzepte zum Finden eines Pfades erläutert.  Wenn Sie diese Grundkonzepte verstehen, werden Sie feststellen, dass <strong>A *</strong> überraschend offensichtlich ist. <br><br><h2>  Einfache Schaltung </h2><br>  Obwohl Sie diese Konzepte auf beliebig komplexe 3D-Umgebungen anwenden können, beginnen wir mit einem äußerst einfachen Schema: einem 5 x 5-Quadrat-Raster. Der Einfachheit halber habe ich jede Zelle mit einem Großbuchstaben markiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2d/66c/ed8/e2d66ced82a4c1d4ed739583bd782245.png"></div><br>  <i>Einfaches Netz.</i> <br><br>  Das allererste, was wir tun werden, ist, uns diese Umgebung als Grafik vorzustellen.  Ich werde nicht im Detail erklären, was ein Graph ist;  Einfach ausgedrückt ist dies eine Reihe von Kreisen, die durch Pfeile verbunden sind.  Die Kreise werden <em>"Knoten" genannt,</em> und die Pfeile werden <em>"Kanten" genannt.</em> <br><br>  Jeder Knoten repräsentiert einen <em>"Zustand",</em> in dem sich das Zeichen befinden kann.  In unserem Fall ist der Status des Charakters seine Position, daher erstellen wir einen Knoten für jede Gitterzelle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68a/d4b/4db/68ad4b4db470c1ce34434e6489a5a986.png"></div><br>  <i>Knoten, die Gitterzellen darstellen.</i> <br><br>  Fügen Sie nun die Rippen hinzu.  Sie geben die Zustände an, die von jedem gegebenen Zustand <em>"erreicht" werden</em> können;  In unserem Fall können wir von jeder Zelle zur nächsten wechseln, mit Ausnahme der blockierten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f73/56c/9be/f7356c9be0171d61c31e3e4c21bf9385.png"></div><br>  <i>Bögen bezeichnen zulässige Bewegungen zwischen Gitterzellen.</i> <br><br>  Wenn wir von <strong>A</strong> nach <strong>B gelangen können</strong> , sagen wir, dass <strong>B</strong> ein <em>„Nachbar“</em> des <strong>A-</strong> Knotens ist. <br><br>  Es ist erwähnenswert, dass die Rippen eine <em>Richtung haben</em> ;  Wir brauchen Kanten von <strong>A</strong> nach <strong>B</strong> und von <strong>B</strong> nach <strong>A.</strong>  Dies mag überflüssig erscheinen, aber nicht, wenn komplexere „Bedingungen“ auftreten können.  Zum Beispiel kann ein Charakter vom Dach auf den Boden fallen, kann aber nicht vom Boden auf das Dach springen.  Sie können vom Zustand "lebendig" in den Zustand "tot" wechseln, aber nicht umgekehrt.  Usw. <br><br><h2>  Beispiel </h2><br>  Angenommen, wir möchten von <strong>A</strong> nach <strong>T</strong> wechseln <strong>.</strong>  Wir beginnen mit <strong>A.</strong>  Sie können genau zwei Aktionen ausführen: Gehen Sie zu <strong>B</strong> oder gehen Sie zu <strong>F.</strong> <br><br>  Nehmen wir an, wir sind nach <strong>B gezogen.</strong>  Jetzt können wir zwei Dinge tun: zu <strong>A zurückkehren</strong> oder zu <strong>C</strong> gehen <strong>.</strong>  Wir erinnern uns, dass wir bereits in <strong>A waren</strong> und die Optionen dort in Betracht gezogen haben, daher macht es keinen Sinn, es erneut zu tun (andernfalls können wir den ganzen Tag damit verbringen, <strong>A</strong> → <strong>B</strong> → <strong>A</strong> → <strong>B</strong> ... zu bewegen).  Deshalb gehen wir zu <strong>C.</strong> <br><br>  Wenn wir in <strong>C sind</strong> , können wir uns nirgendwo bewegen.  Die Rückkehr zu <strong>B ist</strong> sinnlos, das heißt, es ist eine Sackgasse.  Den Übergang zu <strong>B zu</strong> wählen, als wir in <strong>A waren,</strong> war eine schlechte Idee;  Vielleicht solltest du stattdessen <strong>F</strong> versuchen? <br><br>  Wir wiederholen diesen Vorgang nur so lange, bis wir in <strong>T</strong> landen <strong>.</strong>  In diesem Moment erstellen wir einfach den Pfad von <strong>A neu</strong> und kehren in unseren Schritten zurück.  Wir sind in <strong>T</strong> ;  Wie sind wir dorthin gekommen?  Von <strong>o</strong> ?  Das heißt, das Ende des Pfades hat die Form <strong>O</strong> → <strong>T.</strong>  Wie sind wir zu <strong>O gekommen</strong> ?  Usw. <br><br>  Denken Sie daran, dass wir uns nicht wirklich <em>bewegen</em> .  Das alles war nur ein Denkprozess.  Wir stehen weiterhin in <strong>A</strong> und werden uns nicht davon entfernen, bis wir den ganzen Weg gefunden haben.  Wenn ich "nach <strong>B gezogen</strong> " sage, meine ich "stell dir vor, wir sind nach <strong>B gezogen</strong> ". <br><br><h2>  Allgemeiner Algorithmus </h2><br>  <strong>Dieser Abschnitt ist der wichtigste Teil des gesamten Artikels</strong> .  Sie <em>müssen</em> es unbedingt verstehen, um die Suche nach dem Weg realisieren zu können;  Der Rest (einschließlich <strong>A *</strong> ) sind nur Details.  In diesem Abschnitt werden Sie verstehen, bis Sie <em>die Bedeutung verstehen</em> . <br><br>  Darüber hinaus ist dieser Abschnitt unglaublich einfach. <br><br>  Versuchen wir, unser Beispiel zu formalisieren und es in einen Pseudocode umzuwandeln. <br><br>  Wir müssen die Knoten verfolgen, die wir vom Startknoten aus erreichen können.  Zu Beginn ist dies nur der Startknoten, aber beim „Erkunden“ des Rasters lernen wir, wie Sie zu anderen Knoten gelangen.  Nennen wir diese Liste der <code>reachable</code> Knoten: <br><br><pre> <code class="python hljs">reachable = [start_node]</code> </pre> <br>  Wir müssen auch die bereits überprüften Knoten verfolgen, um sie nicht erneut zu berücksichtigen.  Nennen <code>explored</code> sie <code>explored</code> : <br><br><pre> <code class="python hljs">explored = []</code> </pre> <br>  <strong>Als nächstes werde ich den Kern des Algorithmus skizzieren</strong> : Bei jedem Schritt der Suche wählen wir einen der Knoten aus, die wir erreichen können, und schauen uns an, welche neuen Knoten wir daraus erhalten können.  Wenn wir bestimmen, wie der letzte (Ziel-) Knoten erreicht werden soll, ist das Problem gelöst!  Ansonsten setzen wir die Suche fort. <br><br>  So einfach, was enttäuscht überhaupt?  Und das ist wahr.  Aber das ist der ganze Algorithmus.  Schreiben wir es Schritt für Schritt mit Pseudocode auf. <br><br>  Wir suchen weiter, bis wir entweder zum Endknoten gelangen (in diesem Fall finden wir den Pfad vom Anfangsknoten zum Endknoten) oder bis uns die Knoten ausgehen, in denen Sie suchen können (in diesem Fall gibt es keinen Weg zwischen dem Start- und dem Endknoten). . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty:</code> </pre> <br>  Wir wählen einen der Knoten aus, zu denen wir gelangen können und der noch nicht untersucht wurde: <br><br><pre> <code class="python hljs"> node = choose_node(reachable)</code> </pre> <br>  Wenn wir gerade gelernt haben, wie man zum letzten Knoten kommt, ist die Aufgabe abgeschlossen!  Wir müssen nur den Pfad erstellen, indem wir den <code>previous</code> Links zurück zum Startknoten folgen: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == goal_node: path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(node) node = node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  Es macht keinen Sinn, den Knoten mehr als einmal zu untersuchen, daher werden wir Folgendes verfolgen: <br><br><pre> <code class="python hljs"> reachable.remove(node) explored.add(node)</code> </pre> <br>  Wir identifizieren Knoten, die wir von hier aus nicht erreichen können.  Wir beginnen mit einer Liste von Knoten neben dem aktuellen und löschen die bereits untersuchten Knoten: <br><br><pre> <code class="python hljs"> new_reachable = get_adjacent_nodes(node) - explored</code> </pre> <br>  Wir nehmen jeden von ihnen: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_reachable:</code> </pre> <br>  Wenn wir bereits wissen, wie wir den Knoten erreichen können, ignorieren Sie ihn.  Andernfalls fügen Sie es der <code>reachable</code> Liste hinzu und verfolgen Sie, wie es hineingekommen ist: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br>  Das Finden des Endknotens ist eine Möglichkeit, die Schleife zu verlassen.  Das zweite ist, wenn das <code>reachable</code> leer wird: Wir haben keine Knoten mehr, die erkundet werden können, und wir haben den Endknoten nicht erreicht, dh es gibt keinen Weg vom Anfang zum Endknoten: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Und ... das war's.  Dies ist der gesamte Algorithmus, und der Pfadkonstruktionscode wird in einer separaten Methode zugewiesen: <br><br><pre> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: if adjacent not in reachable adjacent.previous = node # Remember how we got there. reachable.add(adjacent) # If we get here, no path was found :( return None</span></span></code> </pre> <br>  Hier ist die Funktion, die den Pfad erstellt und den <code>previous</code> Links zurück zum Startknoten folgt: <br><br><pre> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  Das ist alles.  <em>Dies ist der</em> Pseudocode <em>jedes</em> Pfadsuchalgorithmus, einschließlich <strong>A *</strong> . <br><br>  Lesen Sie diesen Abschnitt erneut, bis Sie verstanden haben, wie alles funktioniert und, was noch wichtiger ist, <em>warum</em> alles funktioniert.  Es wäre ideal, ein Beispiel von Hand auf Papier zu zeichnen, aber Sie können sich auch eine interaktive Demo ansehen: <br><br><h2>  Interaktive Demo </h2><br>  Hier ist eine Demo und ein Beispiel für die Implementierung des oben gezeigten Algorithmus (Sie können ihn auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seite des Originalartikels</a> ausführen).  <code>choose_node</code> wählt nur einen zufälligen Knoten aus.  Sie können den Algorithmus Schritt für Schritt starten und die Liste der <code>reachable</code> und <code>explored</code> sowie die Verweise auf die <code>previous</code> Links anzeigen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vt/jk/cb/vtjkcb4tflduq7zu5p-oph2i73s.gif"></div><br>  Beachten Sie, dass die Suche beendet wird, sobald ein Pfad erkannt wird.  Es kann vorkommen, dass einige Knoten nicht einmal berücksichtigt werden. <br><br><h2>  Fazit </h2><br>  Der hier vorgestellte Algorithmus ist ein allgemeiner Algorithmus für <em>jeden</em> Pfadsuchalgorithmus. <br><br>  Aber was unterscheidet jeden Algorithmus von einem anderen, warum ist <strong>A *</strong> <strong>A *</strong> ? <br><br>  Hier ist ein Tipp: Wenn Sie die Suche in der Demo mehrmals ausführen, werden Sie feststellen, dass der Algorithmus nicht immer denselben Pfad findet.  Er findet <em>einen</em> Weg, und dieser Weg ist nicht unbedingt der <em>kürzeste</em> .  Warum? <br><br><h2>  Teil 2. Suchstrategien </h2><br>  Wenn Sie den im vorherigen Abschnitt beschriebenen Algorithmus nicht vollständig verstehen, kehren Sie zu ihm zurück und lesen Sie ihn erneut, da dies zum Verständnis weiterer Informationen erforderlich ist.  Wenn Sie es herausfinden, erscheint Ihnen <strong>A *</strong> völlig natürlich und logisch. <br><br><h2>  Geheime Zutat </h2><br>  Am Ende des vorherigen Teils habe ich zwei Fragen offen gelassen: Wenn jeder Suchalgorithmus denselben Code verwendet, warum verhält sich <strong>A * dann</strong> wie <strong>A *</strong> ?  Und warum findet die Demo manchmal andere Wege? <br><br>  Die Antworten auf beide Fragen hängen miteinander zusammen.  Obwohl der Algorithmus gut definiert ist, habe ich einen Aspekt ungelöst gelassen, und wie sich herausstellt, ist er der Schlüssel zur Erklärung des Verhaltens von Suchalgorithmen: <br><br><pre> <code class="python hljs">node = choose_node(reachable)</code> </pre> <br>  Es ist diese unschuldig aussehende Zeichenfolge, die alle Suchalgorithmen voneinander unterscheidet.  <code>choose_node</code> hängt von der Implementierungsmethode von <code>choose_node</code> . <br><br>  Warum findet die Demo unterschiedliche Wege?  Weil die Methode <code>choose_node</code> einen Knoten zufällig auswählt. <br><br><h2>  Länge ist wichtig </h2><br>  Bevor wir uns mit den Unterschieden im Verhalten der Funktion <code>choose_node</code> , müssen wir ein kleines Versehen in dem oben beschriebenen Algorithmus beheben. <br><br>  Bei der Betrachtung der an den Strom angrenzenden Knoten haben wir diejenigen ignoriert, die bereits wissen, wie dies erreicht werden kann: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br>  Dies ist ein Fehler: Was wäre, wenn wir gerade den <em>besten</em> Weg finden würden, dorthin zu gelangen?  In diesem Fall muss die <code>previous</code> Knotenverbindung geändert werden, um diesen kürzeren Pfad widerzuspiegeln. <br><br>  Dazu müssen wir die Länge des Pfades vom Startknoten zu jedem erreichbaren Knoten kennen.  Wir werden dies die Kosten des Pfades nennen.  Im Moment gehen wir davon aus, dass der Wechsel von einem Knoten zu einem der benachbarten Knoten konstante Kosten von <code>1</code> . <br><br>  Bevor wir mit der Suche beginnen, weisen wir den <code>cost</code> jedes Knotens der <code>infinity</code> .  Dank dessen wird <em>jeder</em> Weg kürzer sein.  Wir werden auch die <code>cost</code> den Knoten <code>start_node</code> auf <code>0</code> . <br><br>  Dann sieht der Code folgendermaßen aus: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: reachable.add(adjacent) <span class="hljs-comment"><span class="hljs-comment"># If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1</span></span></code> </pre> <br><h2>  Gleiche Suchkosten </h2><br>  Schauen wir uns nun die Methode <code>choose_node</code> .  Wenn wir versuchen, den kürzestmöglichen Weg zu finden, ist es keine gute Idee, einen Knoten zufällig auszuwählen. <br><br>  Es ist besser, einen Knoten auszuwählen, den wir vom Anfangsknoten auf dem kürzesten Weg erreichen können.  Aus diesem Grund bevorzugen wir in der Regel kürzere Wege gegenüber längeren.  Dies bedeutet nicht, dass längere Pfade überhaupt nicht berücksichtigt werden, sondern dass kürzere Pfade zuerst berücksichtigt werden.  Da der Algorithmus unmittelbar nach dem Finden eines geeigneten Pfades beendet wird, sollten wir kurze Pfade finden können. <br><br>  Hier ist ein mögliches Beispiel für die Funktion <code>choose_node</code> : <br><br><pre> <code class="python hljs">function choose_node (reachable): best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> best_node == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> best_node.cost &gt; node.cost: best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Intuitiv erweitert sich die Suche nach diesem Algorithmus "radial" vom Startknoten bis zum Endknoten.  Hier ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine interaktive Demo</a> dieses Verhaltens: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nh/fn/jd/nhfnjd_ztdx3fbuqy5v5_am5hxw.gif"></div><br><h2>  Fazit </h2><br>  Eine einfache Änderung der Methode zur Auswahl des Knotens, die im Folgenden berücksichtigt wird, ermöglichte es uns, einen ziemlich guten Algorithmus zu erhalten: Er findet den kürzesten Weg vom Start- zum Endknoten. <br><br>  Aber dieser Algorithmus bleibt bis zu einem gewissen Grad "dumm".  Er sucht überall weiter, bis er auf einen Endknoten stößt.  Was ist beispielsweise der Punkt in dem oben gezeigten Beispiel, um in Richtung <strong>A</strong> zu suchen, wenn es offensichtlich ist, dass wir uns vom Endknoten entfernen? <br><br>  Ist es möglich, <code>choose_node</code> intelligenter zu machen?  Können wir <em>die Suche auf den Endknoten richten</em> , ohne vorher den richtigen Pfad zu kennen? <br><br>  Es stellt sich heraus, dass wir es können - im nächsten Teil gelangen wir schließlich zu <code>choose_node</code> , wodurch wir den allgemeinen Pfad-Suchalgorithmus in <strong>A *</strong> <code>choose_node</code> können. <br><br><h2>  Teil 3. Entfernen Sie den Schleier der Geheimhaltung von A * </h2><br>  Der im vorherigen Teil erhaltene Algorithmus ist recht gut: Er findet den kürzesten Weg vom Startknoten zum letzten.  Er verschwendet jedoch seine Energie: Er betrachtet die Art und Weise, wie eine Person offensichtlich als falsch bezeichnet - sie <em>bewegt sich</em> normalerweise vom Ziel <em>weg</em> .  Wie kann dies vermieden werden? <br><br><h2>  Magischer Algorithmus </h2><br>  Stellen Sie sich vor, wir führen einen Suchalgorithmus auf einem speziellen Computer mit einem Chip aus, der <em>Magie kann</em> .  Dank dieses erstaunlichen Chips können wir <code>choose_node</code> sehr einfache Weise ausdrücken, wodurch garantiert der kürzeste Pfad erstellt wird, ohne Zeit damit zu verschwenden, <code>choose_node</code> erkunden, die nirgendwohin führen: <br><br><pre> <code class="python hljs">function choose_node (reachable): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> magic(reachable, <span class="hljs-string"><span class="hljs-string">" ,     "</span></span>)</code> </pre> <br>  Klingt verlockend, aber Magic Chips benötigen immer noch eine Art Low-Level-Code.  Hier ist eine gute Annäherung: <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = magic(node, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Dies ist eine großartige Möglichkeit, den nächsten Knoten auszuwählen: Sie wählen einen Knoten aus, der uns den kürzesten Weg vom Start- zum Endknoten bietet, was wir brauchen. <br><br>  Wir haben auch die Menge an Magie minimiert: Wir wissen genau, wie <code>node.cost</code> die Kosten für den Umzug vom Startknoten zu jedem Knoten sind (dies ist <code>node.cost</code> ), und wir verwenden Magie nur, um die Kosten für den Umzug vom Knoten zum Endknoten vorherzusagen. <br><br><h2>  Nicht magisch, aber ziemlich großartig A * </h2><br>  Leider sind Magic Chips neu und wir brauchen Unterstützung von veralteten Geräten.  Der größte Teil des Codes passt zu uns, mit Ausnahme dieser Zeile: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Throws MuggleProcessorException cost_node_to_goal = magic(node, "   ")</span></span></code> </pre> <br>  Das heißt, wir können keine Magie verwenden, um die Kosten eines unerforschten Pfades herauszufinden.  Dann machen wir eine Vorhersage.  Wir werden optimistisch sein und annehmen, dass zwischen dem aktuellen und dem endgültigen Knoten nichts ist, und wir können uns einfach direkt bewegen: <br><br><pre> <code class="python hljs">cost_node_to_goal = distance(node, goal_node)</code> </pre> <br>  Beachten Sie, dass der <em>kürzeste Weg</em> und der <em>Mindestabstand</em> unterschiedlich sind: Der Mindestabstand impliziert, dass zwischen dem aktuellen und dem Endknoten absolut keine Hindernisse bestehen. <br><br>  Diese Schätzung ist recht einfach zu erhalten.  In unseren Gitterbeispielen ist dies der <em>Abstand von Stadtblöcken</em> zwischen zwei Knoten (d. H. <code>abs(Ax - Bx) + abs(Ay - By)</code> ).  Wenn wir uns diagonal bewegen könnten, wäre der Wert gleich <code>sqrt( (Ax - Bx)^2 + (Ay - By)^2 )</code> und so weiter.  Am wichtigsten ist, dass wir niemals eine <em>zu</em> hohe Wertschätzung erhalten. <br><br>  Hier ist also eine nicht <code>choose_node</code> Version von <code>choose_node</code> : <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Eine Funktion, die die Entfernung vom Strom zum Endknoten schätzt, wird als <em>Heuristik bezeichnet</em> , und dieser Suchalgorithmus, meine Damen und Herren, wird als ... <strong>A * bezeichnet</strong> . <br><br><h2>  Interaktive Demo </h2><br>  Während Sie sich von dem Schock erholen, der durch die Erkenntnis verursacht wurde, dass das mysteriöse <strong>A *</strong> tatsächlich <em>so einfach ist</em> , können Sie sich die Demo ansehen (oder sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalartikel</a> ausführen).  Sie werden feststellen, dass die Suche im Gegensatz zum vorherigen Beispiel nur sehr wenig Zeit damit verbringt, sich in die falsche Richtung zu bewegen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif"></div><br><h2>  Fazit </h2><br>  Schließlich kamen wir zum <strong>A *</strong> -Algorithmus, der nichts anderes ist als der im ersten Teil des Artikels beschriebene allgemeine Suchalgorithmus mit einigen im zweiten Teil beschriebenen Verbesserungen und unter Verwendung der Funktion <code>choose_node</code> , die den Knoten auswählt, der uns nach unserer Schätzung näher bringt Endknoten.  Das ist alles. <br><br>  Hier ist ein vollständiger Pseudocode der Hauptmethode als Referenz: <br><br><pre> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here that we haven't explored before? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: # First time we see this node? if adjacent not in reachable: reachable.add(adjacent) # If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1 # If we get here, no path was found :( return None</span></span></code> </pre> <br>  <code>build_path</code> Methode: <br><br><pre> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  Und hier ist die Methode <code>choose_node</code> , die daraus <strong>A * macht</strong> : <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Das ist alles. <br><br>  Aber warum brauchen wir <strong>Teil 4</strong> ? <br><br>  Nachdem Sie nun verstanden haben, wie <strong>A *</strong> funktioniert, möchte ich auf einige erstaunliche Bereiche seiner Anwendung eingehen, die weit davon entfernt sind, Pfade in einem Zellenraster zu finden. <br><br><h2>  Teil 4. A * in der Praxis </h2><br>  Die ersten drei Teile des Artikels beginnen mit den Grundlagen der Pfadsuchalgorithmen und enden mit einer klaren Beschreibung des <strong>A *</strong> -Algorithmus.  All dies ist theoretisch großartig, aber zu verstehen, wie dies in der Praxis anwendbar ist, ist ein völlig anderes Thema. <br><br>  Was passiert zum Beispiel, wenn unsere Welt kein Gitter ist? <br><br>  Was ist, wenn sich ein Charakter nicht sofort um 90 Grad drehen kann? <br><br>  Wie erstelle ich ein Diagramm, wenn die Welt endlos ist? <br><br>  Was ist, wenn uns die Länge des Weges egal ist, wir aber auf Sonnenenergie angewiesen sind und so viel wie möglich unter Sonnenlicht stehen müssen? <br><br>  Wie finde ich den kürzesten Weg zu einem der beiden Endknoten? <br><br><h2>  Kostenfunktion </h2><br>  In den ersten Beispielen haben wir nach dem kürzesten Weg zwischen dem Start- und dem Endknoten gesucht.  Anstatt jedoch Teilpfadlängen in der variablen <code>length</code> speichern, haben wir es <code>cost</code> .  Warum? <br><br>  Wir können <strong>A *</strong> nicht nur nach dem <em>kürzesten</em> , sondern auch nach dem <em>besten</em> Weg suchen lassen, und die Definition von „am besten“ kann basierend auf unseren Zielen gewählt werden.  Wenn wir den kürzesten Weg benötigen, sind die Kosten die Länge des Weges. Wenn wir jedoch beispielsweise den Kraftstoffverbrauch minimieren möchten, müssen wir ihn als Kosten verwenden.  Wenn wir die „Zeit unter der Sonne“ maximieren möchten, sind die Kosten die Zeit ohne Sonne.  Usw. <br><br>  Im allgemeinen Fall bedeutet dies, dass jeder Kante des Diagramms entsprechende Kosten zugeordnet sind.  In den oben gezeigten Beispielen wurde der Wert implizit festgelegt und immer als <code>1</code> , da wir die Schritte auf dem Weg gezählt haben.  Aber wir können die Kosten der Rippe entsprechend dem ändern, was wir minimieren möchten. <br><br><h2>  Kriteriumsfunktion </h2><br>  Nehmen wir an, unser Objekt ist ein Auto, und er muss zur Tankstelle.  Jegliches Auftanken passt zu uns.  Es ist der kürzeste Weg zur nächsten Tankstelle. <br><br>  Der naive Ansatz besteht darin, nacheinander den kürzesten Weg zu jeder Betankung zu berechnen und den kürzesten auszuwählen.  Dies wird funktionieren, aber es wird ein ziemlich kostspieliger Prozess sein. <br><br>  Was wäre, wenn wir einen <code>goal_node</code> durch eine Methode ersetzen <code>goal_node</code> , die auf einem bestimmten Knoten erkennen kann, ob er endlich ist oder nicht.  Dank dessen können wir gleichzeitig nach mehreren Zielen suchen.  Wir müssen auch die Heuristik so ändern, dass sie die geschätzten Mindestkosten aller möglichen Endknoten zurückgibt. <br><br>  Abhängig von den Besonderheiten der Situation können wir das Ziel möglicherweise nicht <em>perfekt erreichen</em> , oder es kostet zu viel (wenn wir den Charakter durch eine halbe große Karte senden, ist der Unterschied einen Zoll wichtig?). Die Methode <code>is_goal_node</code> kann also <code>true</code> wenn wir Wir sind "nah genug". <br><br><h2>  Volle Sicherheit ist nicht erforderlich. </h2><br>  Die Darstellung der Welt als diskretes Gitter reicht für viele Spiele möglicherweise nicht aus.  Nehmen Sie zum Beispiel einen Ego-Shooter oder ein Rennspiel.  Die Welt ist diskret, kann aber nicht als Gitter dargestellt werden. <br><br>  Aber es gibt ein ernsthafteres Problem: Was ist, wenn die Welt endlos ist?  In diesem Fall können wir, selbst wenn wir es in Form eines Gitters darstellen können, einfach kein dem Gitter entsprechendes Diagramm erstellen, da es unendlich sein muss. <br><br>  Es ist jedoch nicht alles verloren.  Natürlich brauchen wir für den Graph-Suchalgorithmus definitiv einen Graph.  Aber niemand sagte, dass die Grafik <em>umfassend sein sollte</em> ! <br><br>  Wenn Sie sich den Algorithmus genau ansehen, werden Sie feststellen, dass wir mit dem gesamten Diagramm nichts anfangen.  Wir untersuchen den Graphen lokal und erhalten Knoten, die wir vom betreffenden Knoten aus erreichen können.  Wie aus der Demo <strong>A *</strong> ersichtlich ist, werden einige Knoten des Graphen überhaupt nicht untersucht. <br><br>  Warum erstellen wir das Diagramm nicht einfach im Forschungsprozess? <br><br>  Wir machen die aktuelle Position des Charakters zum Startknoten.  Beim Aufrufen von <code>get_adjacent_nodes</code> kann ermittelt werden, auf welche Weise sich der Charakter von einem bestimmten Knoten aus bewegen und im <code>get_adjacent_nodes</code> benachbarte Knoten erstellen kann. <br><br><h2>  Jenseits von drei Dimensionen </h2><br>  Auch wenn Ihre Welt <i>wirklich</i> ein 2D-Netz ist, müssen andere Aspekte berücksichtigt werden.  Was ist zum Beispiel, wenn sich ein Zeichen nicht sofort um 90 oder 180 Grad drehen kann, wie dies normalerweise der Fall ist? <br><br>  <em>Der</em> von jedem Suchknoten dargestellte <em>Zustand</em> muss nicht nur eine <em>Position sein</em> .  im Gegenteil, es kann einen beliebig komplexen Satz von Werten enthalten.  Wenn beispielsweise 90-Grad-Drehungen so lange dauern wie der Übergang von einer Zelle zur anderen, kann der Status des Charakters als <code>[position, heading]</code> .  Jeder Knoten kann nicht nur die Position des Charakters darstellen, sondern auch die Richtung seines Blicks.  und die neuen Kanten des Diagramms (explizit oder indirekt) spiegeln dies wider. <br><br>  Wenn Sie zum ursprünglichen 5x5-Raster zurückkehren, kann die anfängliche Suchposition jetzt <code>[A, East]</code> .  Die benachbarten Knoten sind jetzt <code>[B, East]</code> und <code>[A, South]</code> Wenn wir <strong>F</strong> erreichen möchten, müssen wir zuerst die Richtung so anpassen, dass der Pfad die Form <code>[A, East]</code> , <code>[A, South]</code> , <code>[F, South]</code> . <br><br>  Ego-Shooter?  Mindestens vier Dimensionen: <code>[X, Y, Z, Heading]</code> .  Vielleicht sogar <code>[X, Y, Z, Heading, Health, Ammo]</code> . <br><br>  Beachten Sie, dass die heuristische Funktion umso komplexer sein sollte, je komplexer der Zustand ist.  <strong>A * selbst</strong> ist einfach;  Kunst entsteht oft aus guten Heuristiken. <br><br><h2>  Fazit </h2><br>  Der Zweck dieses Artikels ist es, den Mythos ein für alle Mal zu zerstreuen, dass <strong>A *</strong> ein mystischer Algorithmus ist, der nicht entschlüsselt werden kann.  Im Gegenteil, ich habe gezeigt, dass nichts Geheimnisvolles darin ist, und tatsächlich kann es ganz einfach abgeleitet werden, indem man von vorne anfängt. <br><br><h3>  Weiterführende Literatur </h3><br>  Amit Patel hat eine exzellente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Einführung in den A * -Algorithmus“</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung</a> auf Habré] (und seine anderen Artikel zu verschiedenen Themen sind ebenfalls exzellent!). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444828/">https://habr.com/ru/post/de444828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444816/index.html">DIY Zimmerei: Erwartungen und Realität</a></li>
<li><a href="../de444818/index.html">Citymobil - ein Leitfaden für Startups zur Erhöhung der Stabilität bei Wachstum. Teil 1</a></li>
<li><a href="../de444820/index.html">Mockdown: Der schnellste Weg, um Wireframes zu erstellen</a></li>
<li><a href="../de444822/index.html">JDK 9 / JEP 280: Die Verkettung von Zeichenfolgen wird nie wieder dieselbe sein</a></li>
<li><a href="../de444824/index.html">Wie Amazon- und FedEx-Kurierroboter zuerst aussehen</a></li>
<li><a href="../de444830/index.html">Elektronische Cloud-Signatur in Russland und der Welt</a></li>
<li><a href="../de444832/index.html">"Keine Bereitstellungen am Freitag" und drei weitere unausgesprochene Entwicklungsregeln</a></li>
<li><a href="../de444836/index.html">Sie müssen nicht an das Gedächtnis denken, sagten sie ... CLRium Workshop # 5: Garbage Collector</a></li>
<li><a href="../de444838/index.html">OWASP Russia Meetup</a></li>
<li><a href="../de444840/index.html">3. Check Point Erste Schritte R80.20. Layoutvorbereitung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>