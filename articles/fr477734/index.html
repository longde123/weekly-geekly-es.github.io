<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüöí üèá ‚¨ÜÔ∏è Comprendre l'UICollectionViewLayout avec l'application Photos üë¥üèª üéå ü§∏üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je m'appelle Nikita, je travaille sur les SDK mobiles chez ABBYY et je m'occupe √©galement du composant d'interface utilisateur pour num...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprendre l'UICollectionViewLayout avec l'application Photos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/abbyy/blog/477734/"> Bonjour, Habr!  Je m'appelle Nikita, je travaille sur les SDK mobiles chez ABBYY et je m'occupe √©galement du composant d'interface utilisateur pour num√©riser et visualiser facilement des documents de plusieurs pages sur un smartphone.  Ce composant r√©duit le temps de d√©veloppement d'applications bas√©es sur <a href="http://www.abbyy.com/ru-ru/mobile-capture-sdk/%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3D%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25B0%25D0%25B5%25D0%25BC_ui">la technologie ABBYY Mobile Capture</a> et se compose de plusieurs parties.  Tout d'abord, un appareil photo pour num√©riser des documents;  deuxi√®mement, un √©cran d'√©diteur avec les r√©sultats de la capture (c'est-√†-dire des photos prises automatiquement) et un √©cran pour corriger les bordures du document. <br><br>  Il suffit au d√©veloppeur d'appeler quelques m√©thodes - et maintenant, dans son application, une cam√©ra est d√©j√† disponible qui num√©rise automatiquement les documents.  Mais, en plus des cam√©ras configur√©es, vous devez fournir aux clients un acc√®s pratique aux r√©sultats de l'analyse, c'est-√†-dire  prises automatiquement des photos.  Et si le client scanne le contrat ou la charte, il peut y avoir beaucoup de telles photos. <br><br>  Dans cet article, je parlerai des difficult√©s survenues lors de la mise en ≈ìuvre de l'√©cran de l'√©diteur avec les r√©sultats de la capture de documents.  L'√©cran lui-m√™me est un deux <code>UICollectionView</code> , je les appellerai grands et petits.  Je vais omettre les possibilit√©s de r√©gler manuellement les bordures du document et d'autres travaux avec le document, et je me concentrerai sur les animations et les fonctionnalit√©s de mise en page pendant le d√©filement.  Ci-dessous sur GIF, vous pouvez voir ce qui s'est pass√© √† la fin.  Un lien vers le r√©f√©rentiel sera √† la fin de l'article. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r2/xs/of/r2xsofivnhzdmlxt67ld_2atq-q.gif"></div><br><br>  Comme r√©f√©rences, je fais souvent attention aux applications du syst√®me Apple.  Lorsque vous regardez attentivement les animations et autres solutions d'interface de leurs applications, vous commencez √† admirer leur attitude attentive aux diverses bagatelles.  Nous allons maintenant regarder l'application <i>Photos</i> (iOS 12) comme r√©f√©rence.  J'attirerai votre attention sur les fonctionnalit√©s sp√©cifiques de cette application, puis nous essaierons de les impl√©menter. <br><a name="habracut"></a><br>  Nous allons couvrir la plupart des <code>UICollectionViewFlowLayout</code> personnalisation <code>UICollectionViewFlowLayout</code> , voir comment les techniques courantes telles que la parallaxe et le carrousel sont impl√©ment√©es, et discuter des probl√®mes associ√©s aux animations personnalis√©es lors de l'insertion et de la suppression de cellules. <br><br><h2>  Examen des fonctionnalit√©s </h2><br>  Pour ajouter des d√©tails, je d√©crirai quelles petites choses sp√©cifiques m'ont plu dans l'application <i>Photos</i> , puis je les impl√©menterai dans l'ordre appropri√©. <br><br><ol><li>  Effet de parallaxe dans une grande collection </li><li>  Les √©l√©ments d'une petite collection sont centr√©s. </li><li>  Taille dynamique des articles dans une petite collection </li><li>  La logique de placement des √©l√©ments d'une petite cellule d√©pend non seulement du contentOffset, mais aussi des interactions de l'utilisateur </li><li>  Animations personnalis√©es pour d√©placer et supprimer </li><li>  L'index de la cellule "active" n'est pas perdu lors du changement d'orientation </li></ol><br><h3>  1. Parallaxe </h3><br>  Qu'est-ce que la parallaxe? <br><blockquote>  Le d√©filement de parallaxe est une technique en infographie o√π les images d'arri√®re-plan passent devant la cam√©ra plus lentement que les images de premier plan, cr√©ant une illusion de profondeur dans une sc√®ne 2D et ajoutant au sentiment d'immersion dans l'exp√©rience virtuelle. </blockquote>  Vous pouvez remarquer que lors du d√©filement, le cadre de la cellule se d√©place plus rapidement que l'image qui s'y trouve. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9u/qc/7j/9uqc7jfa_e81lg-_9h6uleidmdg.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/oc/jt/nv/ocjtnvvyckaotg52-tooulyfddq.png"></div><br>  Commen√ßons!  Cr√©ez une sous-classe de la cellule, placez-y l'UIImageView. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreviewCollectionViewCell</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UICollectionViewCell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imageView = <span class="hljs-type"><span class="hljs-type">UIImageView</span></span>()‚Äã <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: frame) addSubview(imageView) clipsToBounds = <span class="hljs-literal"><span class="hljs-literal">true</span></span> imageView.snp.makeConstraints { $<span class="hljs-number"><span class="hljs-number">0</span></span>.edges.equalToSuperview() } } }</code> </pre><br>  Vous devez maintenant comprendre comment d√©placer l' <code>imageView</code> , cr√©ant un effet de parallaxe.  Pour ce faire, vous devez red√©finir le comportement des cellules lors du d√©filement.  Apple: <br><blockquote>  √âvitez de sous- <code>UICollectionView</code> .  La vue de collection a peu ou pas d‚Äôaspect propre.  Au lieu de cela, il extrait toutes ses vues de votre objet de source de donn√©es et toutes les informations li√©es √† la disposition de l'objet de disposition.  Si vous essayez de disposer des √©l√©ments en trois dimensions, la bonne fa√ßon de le faire est d'impl√©menter une disposition personnalis√©e qui d√©finit la transformation 3D de chaque cellule et de la visualiser de mani√®re appropri√©e. </blockquote>  Ok, cr√©ons notre <b>objet de mise en page</b> .  <code>UICollectionView</code> a une propri√©t√© <code>collectionViewLayout</code> , √† partir de laquelle il apprend des informations sur le positionnement des cellules.  <code>UICollectionViewFlowLayout</code> est une impl√©mentation de l'abr√©g√© <code>UICollectionViewLayout</code> , qui est la propri√©t√© <code>collectionViewLayout</code> . <br><blockquote>  <code>UICollectionViewLayout</code> attend que quelqu'un la sous-classe et fournisse le contenu appropri√©.  <code>UICollectionViewFlowLayout</code> est une classe concr√®te de <code>UICollectionViewLayout</code> qui a tous ses quatre membres impl√©ment√©s, de la mani√®re dont les cellules seront organis√©es de mani√®re en grille. <br></blockquote>  Cr√©ez une sous-classe de <code>UICollectionViewFlowLayout</code> et remplacez sa <code>layoutAttributesForElements(in:)</code> .  La m√©thode renvoie un tableau de <code>UICollectionViewLayoutAttributes</code> , qui fournit des informations sur la fa√ßon d'afficher une cellule particuli√®re. <br><br>  La collection demande des attributs √† chaque fois que <code>contentOffset</code> change, ainsi que lorsque la mise en page n'est pas valide.  De plus, nous allons cr√©er des attributs personnalis√©s en ajoutant la propri√©t√© <code>parallaxValue</code> , qui d√©termine combien le cadre de l'image est retard√© par rapport au cadre de la cellule.  Pour les sous-classes d'attributs, vous devez remplacer <code>NSCopiyng</code> pour elles.  Apple: <br><blockquote>  Si vous sous-classe et impl√©mentez des attributs de disposition personnalis√©s, vous devez √©galement remplacer la m√©thode h√©rit√©e isEqual: pour comparer les valeurs de vos propri√©t√©s.  Dans iOS 7 et versions ult√©rieures, la vue de collection n'applique pas d'attributs de disposition si ces attributs n'ont pas chang√©.  Il d√©termine si les attributs ont chang√© en comparant les anciens et les nouveaux objets d'attribut √† l'aide de la m√©thode isEqual :.  √âtant donn√© que l'impl√©mentation par d√©faut de cette m√©thode v√©rifie uniquement les propri√©t√©s existantes de cette classe, vous devez impl√©menter votre propre version de la m√©thode pour comparer les propri√©t√©s suppl√©mentaires.  Si vos propri√©t√©s personnalis√©es sont toutes √©gales, appelez <code>super</code> et renvoyez la valeur r√©sultante √† la fin de votre impl√©mentation. <br></blockquote>  Comment trouver <code>parallaxValue</code> ?  Calculons de combien vous avez besoin pour d√©placer le centre de la cellule afin qu'elle se trouve au centre.  Si cette distance est sup√©rieure √† la largeur de la cellule, martelez-la.  Sinon, divisez cette distance par la largeur de la <b>cellule</b> .  Plus cette distance est proche de z√©ro, plus l'effet de parallaxe est faible. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParallaxLayoutAttributes</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UICollectionViewLayoutAttributes</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parallaxValue: <span class="hljs-type"><span class="hljs-type">CGFloat?</span></span> }‚Äã <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreviewLayout</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UICollectionViewFlowLayout</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> offsetBetweenCells: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">44</span></span>‚Äã <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldInvalidateLayout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forBoundsChange newBounds: CGRect)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">layoutAttributesClass</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ParallaxLayoutAttributes</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutAttributesForElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rect: CGRect)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes</span></span>]? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.layoutAttributesForElements(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: rect)? .compactMap { $<span class="hljs-number"><span class="hljs-number">0</span></span>.copy() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">ParallaxLayoutAttributes</span></span> } .compactMap(prepareAttributes) }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareAttributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(attributes: ParallaxLayoutAttributes)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ParallaxLayoutAttributes</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> collectionView = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.collectionView <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> width = itemSize.width <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> centerX = width / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> distanceToCenter = attributes.center.x - collectionView.contentOffset.x <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> relativeDistanceToCenter = (distanceToCenter - centerX) / width‚Äã <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(relativeDistanceToCenter) &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> { attributes.parallaxValue = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> attributes.transform = .identity } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { attributes.parallaxValue = relativeDistanceToCenter attributes.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(translationX: relativeDistanceToCenter * offsetBetweenCells, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/2u/pw/f3/2upwf3rrqmsjxh-btqrm3zau7tm.png"></div><br><br><img src="https://habrastorage.org/webt/bz/x_/ol/bzx_olvusogre4usqir2uvl3uxm.png" alt="image"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/pi/9z/fxpi9zj22hrlkywk5ptjieqq9ma.png"></div><br>  Lorsque la collection re√ßoit les attributs n√©cessaires, les cellules les <b>appliquent</b> .  Ce comportement peut √™tre remplac√© dans la sous-classe de la cellule.  <code>imageView</code> sur la valeur en fonction de <code>parallaxValue</code> .  Cependant, pour que le d√©calage des images avec <code>contentMode == .aspectFit</code> fonctionne correctement, cela ne suffit pas, car le cadre d'image ne co√Øncide pas avec le cadre <code>imageView</code> , par lequel le contenu est rogn√© lorsque <code>clipsToBounds == true</code> .  Mettez un masque qui correspond √† la taille de l'image avec le <code>contentMode</code> appropri√© et nous le mettrons √† jour si n√©cessaire.  Maintenant, tout fonctionne! <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreviewCollectionViewCell</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutSubviews</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {‚Äã <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.layoutSubviews() <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imageSize = imageView.image?.size <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imageRect = <span class="hljs-type"><span class="hljs-type">AVMakeRect</span></span>(aspectRatio: imageSize, insideRect: bounds)‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> path = <span class="hljs-type"><span class="hljs-type">UIBezierPath</span></span>(rect: imageRect) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shapeLayer = <span class="hljs-type"><span class="hljs-type">CAShapeLayer</span></span>() shapeLayer.path = path.cgPath layer.mask = shapeLayer } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> layoutAttributes: UICollectionViewLayoutAttributes)</span></span></span></span> {‚Äã <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attrs = layoutAttributes <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">ParallaxLayoutAttributes</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.apply(layoutAttributes) } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parallaxValue = attrs.parallaxValue ?? <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> transition = -(bounds.width * <span class="hljs-number"><span class="hljs-number">0.3</span></span> * parallaxValue) imageView.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(translationX: transition, y: .zero) } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/j_/9e/-h/j_9e-hdvix9nueitnhf0elsk80o.png"></div><br><br><h3>  2. Les √©l√©ments d'une petite collection sont centr√©s </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/6cc/d9e/a78/6ccd9ea78faa45a085233d593c6feddb.gif"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c9/ld/ra/c9ldral4qoinyvhoacyfveqbwtm.png"></div><br>  Ici, tout est tr√®s simple.  Cet effet peut √™tre obtenu en pla√ßant de grands <code>inset</code> √† gauche et √† droite.  Lors du d√©filement vers la droite / gauche, il est n√©cessaire de commencer √† <code>bouncing</code> uniquement lorsque la derni√®re cellule a quitt√© le contenu visible.  Autrement dit, le contenu visible doit √™tre √©gal √† la taille de la cellule. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThumbnailFlowLayout</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> farInset: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> collection = collectionView <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .zero } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (collection.bounds.width - itemSize.width) / <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> insets: <span class="hljs-type"><span class="hljs-type">UIEdgeInsets</span></span> { <span class="hljs-type"><span class="hljs-type">UIEdgeInsets</span></span>(top: .zero, <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>: farInset, bottom: .zero, <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>: farInset) }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { collectionView?.contentInset = insets <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.prepare() } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/me/ty/vvmetyazz7-6mzze8-7knxoasxw.png"></div><br><br><img src="https://habrastorage.org/webt/hr/qa/k6/hrqak6wkoeqsf7nvy8bky_tauym.jpeg" alt="image"><div style="text-align:center;"><img src="https://habrastorage.org/webt/he/pk/br/hepkbrq20vpteyatek3hv8pi8mg.png"></div><br><br>  En savoir plus sur le centrage: lorsque la collection a fini de d√©filer, la mise en page demande un <code>contentOffset</code> pour s'arr√™ter.  Pour ce faire, remplacez <code>targetContentOffset(forProposedContentOffset:withScrollingVelocity:)</code> .  Apple: <br><blockquote>  Si vous souhaitez que le comportement de d√©filement s'aligne sur des limites sp√©cifiques, vous pouvez remplacer cette m√©thode et l'utiliser pour modifier le point auquel s'arr√™ter.  Par exemple, vous pouvez utiliser cette m√©thode pour toujours arr√™ter le d√©filement sur une limite entre les √©l√©ments, par opposition √† l'arr√™t au milieu d'un √©l√©ment. <br></blockquote>  Pour tout rendre beau, nous nous arr√™terons <b>toujours</b> au centre de la cellule la plus proche.  Le calcul du centre de la cellule la plus proche est une t√¢che plut√¥t triviale, mais vous devez √™tre prudent et consid√©rer le <code>contentInset</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">targetContentOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forProposedContentOffset proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> collection = collectionView <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.targetContentOffset(forProposedContentOffset: proposedContentOffset, withScrollingVelocity: velocity) } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cellWithSpacing = itemSize.width + config.distanceBetween <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> relative = (proposedContentOffset.x + collection.contentInset.<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>) / cellWithSpacing <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leftIndex = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, floor(relative)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rightIndex = <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(ceil(relative), <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(itemsCount)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leftCenter = leftIndex * cellWithSpacing - collection.contentInset.<span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rightCenter = rightIndex * cellWithSpacing - collection.contentInset.<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>‚Äã <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(leftCenter - proposedContentOffset.x) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(rightCenter - proposedContentOffset.x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: leftCenter, y: proposedContentOffset.y) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: rightCenter, y: proposedContentOffset.y) } }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n4/dj/ed/n4djedqhgual-kqq4o3vg-mjxay.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/0x/bj/xn/0xbjxn8vk5gxiuwvjvjklvhfusa.png"></div><br><br><h3>  3. La taille dynamique des √©l√©ments d'une petite collection </h3><br>  Si vous faites d√©filer une grande collection, le <code>contentOffset</code> change pour une petite <code>contentOffset</code> .  De plus, la cellule centrale d'une petite collection n'est pas aussi grande que les autres.  Les cellules lat√©rales ont une taille fixe et la cellule centrale co√Øncide avec le rapport d'aspect de l'image qu'elle contient. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e3/c61/03e/6e3c6103e3602c9a3cbf0b7553a05386.gif"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hw/8q/ma/hw8qma82pik2sus_ul5rbvu8rbm.png"></div><br>  Vous pouvez utiliser la m√™me technique que dans le cas de la parallaxe.  Cr√©ons un <code>UICollectionViewFlowLayout</code> personnalis√© pour une petite collection et red√©finissons <code>prepareAttributes(attributes:</code> donn√© que la logique de mise en page de la petite collection sera compliqu√©e, nous cr√©erons une entit√© distincte pour stocker et calculer la g√©om√©trie des cellules. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> indexPath: <span class="hljs-type"><span class="hljs-type">IndexPath</span></span>‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dims: <span class="hljs-type"><span class="hljs-type">Dimensions</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state: <span class="hljs-type"><span class="hljs-type">State</span></span>‚Äã <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(new state: State)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Cell</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Cell</span></span>(indexPath: indexPath, dims: dims, state: state) } }‚Äã <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dimensions</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> defaultSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> aspectRatio: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inset: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> insetAsExpanded: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> }‚Äã <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expanding: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>‚Äã <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> `<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>`: <span class="hljs-type"><span class="hljs-type">State</span></span> { <span class="hljs-type"><span class="hljs-type">State</span></span>(expanding: .zero) } } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/0c/ma/im/0cmaim03nqx9dpkohrfumymr11a.png"></div><br>  <code>UICollectionViewFlowLayout</code> a une propri√©t√© <code>collectionViewContentSize</code> qui d√©termine la taille de la zone qui peut d√©filer.  Afin de ne pas compliquer notre vie, laissons-la constante, quelle que soit la taille de la cellule centrale.  Pour la g√©om√©trie correcte pour chaque cellule, vous devez conna√Ætre l' <code>aspectRatio</code> image et l'√©loignement du centre de la cellule de <code>contentOffset</code> .  Plus la cellule est proche, plus sa <code>size.width / size.height</code> de l' <code>aspectRatio</code> .  Lorsque vous redimensionnez une cellule sp√©cifique, d√©placez les cellules restantes (√† droite et √† gauche) √† l'aide de <code>affineTransform</code> .  Il s'av√®re que pour calculer la g√©om√©trie d'une cellule particuli√®re, vous devez conna√Ætre les attributs des voisins (visibles). <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from layout: ThumbnailLayout, with sideCells: [Cell])</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes?</span></span> {‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attributes = layout.layoutAttributesForItem(at: indexPath)‚Äã attributes?.size = size attributes?.center = center‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> translate = sideCells.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) { (current, cell) -&gt; <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> indexPath &lt; cell.indexPath { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current - cell.additionalWidth / <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> indexPath &gt; cell.indexPath { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current + cell.additionalWidth / <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current } attributes?.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(translationX: translate, y: .zero)‚Äã <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> additionalWidth: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { (dims.defaultSize.height * dims.aspectRatio - dims.defaultSize.width) * state.expanding } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-type"><span class="hljs-type">CGSize</span></span>(width: dims.defaultSize.width + additionalWidth, height: dims.defaultSize.height) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> center: <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> { <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(indexPath.row) * (dims.defaultSize.width + dims.inset) + dims.defaultSize.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: dims.defaultSize.height / <span class="hljs-number"><span class="hljs-number">2</span></span>) } }</code> </pre> <br>  <code>state.expanding</code> est consid√©r√© comme la m√™me chose que <code>parallaxValue</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index: IndexPath, offsetX: CGFloat)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Cell</span></span> {‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell = <span class="hljs-type"><span class="hljs-type">Cell</span></span>( indexPath: index, dims: <span class="hljs-type"><span class="hljs-type">Cell</span></span>.<span class="hljs-type"><span class="hljs-type">Dimensions</span></span>( defaultSize: itemSize, aspectRatio: dataSource(index.row), inset: config.distanceBetween, insetAsExpanded: config.distanceBetweenFocused), state: .<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>)‚Äã <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attribute = cell.attributes(from: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, with: []) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cellOffset = attribute.center.x - itemSize.width / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> widthWithOffset = itemSize.width + config.distanceBetween <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(cellOffset - offsetX) &lt; widthWithOffset { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expanding = <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(cellOffset - offsetX) / widthWithOffset <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell.updated(by: .expand(expanding)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutAttributesForElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rect: CGRect)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes</span></span>]? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> ..&lt; itemsCount) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-type"><span class="hljs-type">IndexPath</span></span>(row: $<span class="hljs-number"><span class="hljs-number">0</span></span>, section: <span class="hljs-number"><span class="hljs-number">0</span></span>) } .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { cell(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: $<span class="hljs-number"><span class="hljs-number">0</span></span>, offsetX: offsetWithoutInsets.x) } .compactMap { $<span class="hljs-number"><span class="hljs-number">0</span></span>.attributes(from: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, with: cells) } }</code> </pre> <br><br><h3>  4. La logique de placement des √©l√©ments d'une petite cellule d√©pend non seulement du contentOffset, mais aussi des interactions des utilisateurs </h3><br>  Lorsqu'un utilisateur fait d√©filer une petite collection, toutes les cellules ont la m√™me taille.  Lorsque vous faites d√©filer une grande collection, ce n'est pas le cas.  ( <i>voir les gifs 3 et 5</i> ).  √âcrivons un animateur qui mettra √† jour les propri√©t√©s de la disposition <code>ThumbnailLayout</code> .  L'animateur stockera <code>DisplayLink</code> en lui-m√™me et appellera le bloc 60 fois par seconde, donnant acc√®s √† la progression actuelle.  Il est facile de <code>easing functions</code> diverses <code>easing functions</code> √† l'animateur.  La mise en ≈ìuvre peut √™tre consult√©e sur le github au lien √† la fin du post. <br><br>  Entrons la propri√©t√© <code>ThumbnailLayout</code> dans <code>ThumbnailLayout</code> , par laquelle l' <code>expanding</code> toutes les <code>Cell</code> sera multipli√©e.  Il s'av√®re que <code>expandingRate</code> indique dans quelle mesure l' <code>aspectRatio</code> image particuli√®re affectera sa taille si elle devient centr√©e.  Avec <code>expandingRate == 0</code> toutes les cellules auront la m√™me taille.  Au d√©but du d√©filement d'une petite collection, nous ex√©cuterons un animateur qui d√©finit l' <code>expandingRate</code> √† 0, et √† la fin du d√©filement, vice versa, √† 1. En fait, lors de la mise √† jour de la disposition, la taille de la cellule centrale et des cellules lat√©rales changera.  Aucun <code>contentOffset</code> avec <code>contentOffset</code> et secousses! <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScrollAnimation</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> `</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">` </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> begin <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> end }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type: <span class="hljs-type"><span class="hljs-type">Type</span></span>‚Äã <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> toValue: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.type == .begin ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentExpanding = thumbnails.config.expandingRate <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> duration = <span class="hljs-type"><span class="hljs-type">TimeInterval</span></span>(<span class="hljs-number"><span class="hljs-number">0.15</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(currentExpanding - toValue))‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> animator = <span class="hljs-type"><span class="hljs-type">Animator</span></span>(onProgress: { current, <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rate = currentExpanding + (toValue - currentExpanding) * current <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thumbnails.config.expandingRate = rate <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thumbnails.invalidateLayout() }, easing: .easeInOut)‚Äã animator.animate(duration: duration) { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> completion() } } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/sy/sz/ff/syszffr_19xmccnvyw-do9lcqhy.png"></div><br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scrollViewWillBeginDragging</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scrollView: UIScrollView)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> scrollView == thumbnails.collectionView { handle(event: .beginScrolling) <span class="hljs-comment"><span class="hljs-comment">// call ScrollAnimation.run(type: .begin) } }‚Äã func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) { if scrollView == thumbnails.collectionView &amp;&amp; !decelerate { thumbnailEndScrolling() } }‚Äã func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) { if scrollView == thumbnails.collectionView { thumbnailEndScrolling() } }‚Äã func thumbnailEndScrolling() { handle(event: .endScrolling) // call ScrollAnimation.run(type: .end) }</span></span></code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/nu/v0/x7/nuv0x7phez1lg2osumphtri1wao.png"></div><br><br><h3>  5. Animations personnalis√©es pour d√©placer et supprimer </h3><br>  Il existe de nombreux articles expliquant comment cr√©er des animations personnalis√©es pour mettre √† jour les cellules, mais dans notre cas, ils ne nous aideront pas.  Les articles et les didacticiels d√©crivent comment remplacer les attributs d'une cellule mise √† jour.  Dans notre cas, la modification de la disposition de la cellule supprim√©e provoque des effets secondaires - l' <code>expanding</code> cellule voisine, qui a tendance √† remplacer celle supprim√©e lors de l'animation, change. <br><br>  La mise √† jour du contenu dans un <code>UICollectionViewFlowLayout</code> fonctionne comme suit.  Apr√®s avoir supprim√© / ajout√© une cellule, la m√©thode <code>prepare(forCollectionViewUpdates:)</code> d√©marre, donnant un tableau de <code>UICollectionViewUpdateItem</code> , qui nous indique √† quelles cellules les index ont √©t√© mis √† jour / supprim√©s / ajout√©s.  Ensuite, la mise en page appellera un groupe de m√©thodes <br><br><pre> <code class="swift hljs">finalLayoutAttributesForDisappearingItem(at:) initialLayoutAttributesForAppearingDecorationElement(ofKind:at:)</code> </pre> <br>  et leurs amis pour la d√©coration / vues suppl√©mentaires.  Lorsque les attributs des donn√©es mises √† jour sont re√ßus, <code>finalizeCollectionViewUpdates</code> est appel√©.  Apple: <br><blockquote>  La vue de collection appelle cette m√©thode comme derni√®re √©tape avant de proc√©der √† l'animation des modifications.  Cette m√©thode est appel√©e dans le bloc d'animation utilis√© pour effectuer toutes les animations d'insertion, de suppression et de d√©placement afin que vous puissiez cr√©er des animations suppl√©mentaires √† l'aide de cette m√©thode si n√©cessaire.  Sinon, vous pouvez l'utiliser pour effectuer des t√¢ches de derni√®re minute associ√©es √† la gestion des informations d'√©tat de votre objet de pr√©sentation. <br></blockquote>  Le probl√®me est que nous ne pouvons sp√©cialiser les attributs que pour la cellule <b>mise</b> √† <b>jour</b> , et nous devons les changer pour toutes les cellules, et de diff√©rentes mani√®res.  La nouvelle cellule centrale doit changer d' <code>aspectRatio</code> et les cellules lat√©rales doivent se <code>transform</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/223/6ad/9e0/2236ad9e0cff5fac58a4b490570340c4.gif"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1b/wa/pf/1bwapfugwecsrwjnnw3imlnviyk.png"></div><br>  Apr√®s avoir examin√© le fonctionnement de l'animation par d√©faut des cellules de collection lors de la suppression / insertion, il est devenu connu que les cellules de la couche dans <code>CABasicAnimation</code> contiennent <code>CABasicAnimation</code> , qui peut y √™tre modifi√©e si vous souhaitez personnaliser l'animation pour les cellules restantes.  Les choses ont empir√© lorsque les journaux ont montr√© qu'entre <code>performBatchUpdates</code> et <code>prepare(forCollectionViewUpdates:)</code> <code>prepareAttributes(attributes:)</code> <code>prepare(forCollectionViewUpdates:)</code> est appel√©, et il peut d√©j√† y avoir le mauvais nombre de cellules, bien que <code>collectionViewUpdates</code> n'ait pas encore commenc√©, il est tr√®s difficile de maintenir et de comprendre cela.  Que peut-on faire √† ce sujet?  Vous pouvez d√©sactiver ces animations int√©gr√©es! <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forCollectionViewUpdates updateItems: [UICollectionViewUpdateItem])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.prepare(forCollectionViewUpdates: updateItems) <span class="hljs-type"><span class="hljs-type">CATransaction</span></span>.begin() <span class="hljs-type"><span class="hljs-type">CATransaction</span></span>.setDisableActions(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finalizeCollectionViewUpdates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">CATransaction</span></span>.commit() }</code> </pre><div style="text-align:center;"><img src="https://habrastorage.org/webt/69/ja/x4/69jax4yhfpsjyr5jej-xxpb6pkc.png"></div><br>  Arm√©s des animateurs d√©j√† √©crits, nous ferons toutes les animations n√©cessaires sur demande de suppression, et nous lancerons la mise √† jour <code>dataSource</code> √† la fin de l'animation.  Ainsi, nous simplifierons l'animation de la collection lors de la mise √† jour, puisque nous contr√¥lons nous-m√™mes quand le nombre de cellules va changer. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( at indexPath: IndexPath, dataSourceUpdate: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>, completion: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) {‚Äã <span class="hljs-type"><span class="hljs-type">DeleteAnimation</span></span>(thumbnails: thumbnails, preview: preview, index: indexPath).run { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previousCount = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thumbnails.itemsCount <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> previousCount == indexPath.row + <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.activeIndex = previousCount - <span class="hljs-number"><span class="hljs-number">1</span></span> } dataSourceUpdate() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thumbnails.collectionView?.deleteItems(at: [indexPath]) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.preview.collectionView?.deleteItems(at: [indexPath]) completion?() } }</code> </pre> <br>  Comment ces animations fonctionneront-elles?  Dans <code>ThumbnailLayout</code> stockons des brochures facultatives qui mettent √† jour la g√©om√©trie de cellules sp√©cifiques. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThumbnailLayout</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">CellUpdate</span></span> = (<span class="hljs-type"><span class="hljs-type">Cell</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Cell</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updates: [<span class="hljs-type"><span class="hljs-type">IndexPath</span></span>: <span class="hljs-type"><span class="hljs-type">CellUpdate</span></span>] = [:] <span class="hljs-comment"><span class="hljs-comment">// ... override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? {‚Äã let cells = (0 ..&lt; itemsCount) .map { IndexPath(row: $0, section: 0) } .map { cell(for: $0, offsetX: offsetWithoutInsets.x) } .map { cell -&gt; Cell in if let update = self.config.updates[cell.indexPath] { return update(cell) } return cell } return cells.compactMap { $0.attributes(from: self, with: cells) } }</span></span></code> </pre> <br>  Avec un tel outil, vous pouvez tout faire avec la g√©om√©trie des cellules, lancer des mises √† jour pendant le travail de l'animateur et les supprimer dans le compliment.  Il y a aussi la possibilit√© de combiner les mises √† jour. <br><br><pre> <code class="swift hljs">updates[index] = newUpdate(updates[index])</code> </pre><br>  Le code d'animation de suppression est plut√¥t lourd; il se trouve dans le fichier <i>DeleteAnimation.swift</i> du r√©f√©rentiel.  L'animation du changement de focus entre les cellules est impl√©ment√©e de la m√™me mani√®re. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/001/d8d/ca0/001d8dca06df6b68773652760a019bf3.gif"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mi/6q/bs/mi6qbskcng_u5ehyixy1q0xp_ce.png"></div><br><br><h3>  6. L'index de la cellule "active" n'est pas perdu lors du changement d'orientation </h3><br>  <code>scrollViewDidScroll(_ scrollView:)</code> est appel√© m√™me si vous <code>scrollViewDidScroll(_ scrollView:)</code> simplement une valeur dans <code>contentOffset</code> , ainsi que lorsque vous changez l'orientation.  Lorsque le d√©filement de deux collections est synchronis√©, certains probl√®mes peuvent survenir lors des mises √† jour de la mise en page.  L'astuce suivante aide: lors des mises √† jour de la mise en page, vous pouvez d√©finir <code>scrollView.delegate</code> sur <code>nil</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScrollSynchronizer</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { preview.collectionView?.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> thumbnails.collectionView?.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unbind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { preview.collectionView?.delegate = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> thumbnails.collectionView?.delegate = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Lors de la mise √† jour de la taille des cellules au moment du changement d'orientation, cela ressemblera √† ceci: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PhotosViewController</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewWillTransition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewWillTransition(to: size, with: coordinator)‚Äã contentView.synchronizer.unbind() coordinator.animate(alongsideTransition: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.contentView.synchronizer.bind() } } }</code> </pre> <br>  Afin de ne pas perdre le <code>contentOffset</code> souhait√© lors de la modification de l'orientation, vous pouvez mettre √† jour <code>targetIndexPath</code> dans <code>scrollView.delegate</code> .  Lorsque vous modifiez l'orientation, la mise en page sera d√©sactiv√©e si vous remplacez <code>shouldInvalidateLayout(forBoundsChange:)</code> .  Lors du changement des <code>bounds</code> mise en page demandera de clarifier <code>contentOffset</code> , pour le clarifier, vous devez red√©finir <code>targetContentOffset(forProposedContentOffset:)</code> .  Apple: <br><blockquote>  Pendant les mises √† jour de mise en page ou lors de la transition entre les mises en page, la vue de collection appelle cette m√©thode pour vous donner la possibilit√© de modifier le d√©calage de contenu propos√© √† utiliser √† la fin de l'animation.  Vous pouvez remplacer cette m√©thode si les animations ou la transition peuvent entra√Æner le positionnement des √©l√©ments d'une mani√®re qui n'est pas optimale pour votre conception. <br><br>  La vue de collection appelle cette m√©thode apr√®s avoir appel√© les m√©thodes <code>prepare()</code> et <code>collectionViewContentSize</code> . </blockquote><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">targetContentOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forProposedContentOffset proposedContentOffset: CGPoint)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> targetOffset = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.targetContentOffset(forProposedContentOffset: proposedContentOffset) <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> layoutHandler = layoutHandler <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> targetOffset } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> offset = <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(layoutHandler.targetIndex) / <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(itemsCount) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>( x: collectionViewContentSize.width * offset - farInset, y: targetOffset.y) }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i5/5r/sf/i55rsfdujvblk7om3yq2yerabhu.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/ng/ls/6w/ngls6wjfkhkajrg3706i_g11lyo.png"></div><br><hr><br> ,  ! <br><br>      <a href="https://github.com/YetAnotherRzmn/PhotosApp">github.com/YetAnotherRzmn/PhotosApp</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477734/">https://habr.com/ru/post/fr477734/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477722/index.html">Google Style Guide en C ++. Partie 8</a></li>
<li><a href="../fr477724/index.html">Habraseminar de la marque RH: sur les talents, la chasse et le contenu</a></li>
<li><a href="../fr477728/index.html">Que faire pour diriger l'√©quipe afin que l'√©quipe ne s'√©puise pas</a></li>
<li><a href="../fr477730/index.html">ChipWhisperer: Attaque d'√©nergie contre Magma</a></li>
<li><a href="../fr477732/index.html">Mauvaise classification des doigts des syst√®mes de navigation sous-marine</a></li>
<li><a href="../fr477736/index.html">Le parcours du testeur: du ¬´frein √† main¬ª √† l'automatisation</a></li>
<li><a href="../fr477738/index.html">iKassa ou comment nous avons apprivois√© le ¬´caissier num√©rique¬ª</a></li>
<li><a href="../fr477740/index.html">Et o√π regarder ce t√©lescope avec votre ≈ìil?</a></li>
<li><a href="../fr477742/index.html">"Bonjour, Checkmarx!" Comment √©crire une demande pour Checkmarx SAST et trouver des vuln√©rabilit√©s int√©ressantes</a></li>
<li><a href="../fr477744/index.html">Pourquoi les professionnels cr√©ent-ils parfois de mauvaises applications?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>