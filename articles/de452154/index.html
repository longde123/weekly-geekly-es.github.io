<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐛 🚑 ⏬ Virtueller Cube - Anstelle von OLAP 📉 🤟🏼 🍞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie das Gegenteil tun und das Gleiche bekommen ... 

 Bei der analytischen (rechnerischen / aggregierten) Datenverarbeitung müssen Sie einen Komp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Virtueller Cube - Anstelle von OLAP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452154/"><blockquote>  <em>Wenn Sie das Gegenteil tun und das Gleiche bekommen ...</em> </blockquote><p>  Bei der analytischen (rechnerischen / aggregierten) Datenverarbeitung müssen Sie einen Kompromiss zwischen Reaktionsfähigkeit, Geschwindigkeit und Komfort finden. </p><br><p>  Einige Systeme sind gut indiziert und gefunden, andere können Daten schnell berechnen und aggregieren, während andere einfach sind.  Irgendwo ist es notwendig, das Vorladen und Indizieren von Daten mit allen damit verbundenen Schwierigkeiten zu organisieren, und irgendwo wird dem Benutzer eine Abstraktion seines Modells von Quell- und aggregierten Daten zusätzlich zu den integrierten oder externen physischen Speichern und Datenbanken bereitgestellt, die direkt während der Berechnungen verwendet werden.  In jedem Fall muss der Benutzer, vom Programmierer bis zum Analysten, einen relativ großen Job erledigen, angefangen bei der Vorbereitung der Rohdaten und dem Kompilieren von Abfragen, der Berechnung von Modellen bis hin zur Visualisierung des Ergebnisses auf Widgets, natürlich „Sexy“ - schön, reaktionsschnell und verständlich - ansonsten Alle geleistete Arbeit wird den Bach runtergehen.  Und oft, wie es das Glück wollte, bemerken wir bei der Auswahl einer Lösung, wie aus einer einfachen und verständlichen Aufgabe auf den ersten Blick ein gruseliges Monster wird, das mit den verfügbaren Mitteln nicht zu bekämpfen ist, und wir müssen dringend etwas erfinden - ein Fahrrad "mit Blackjack und Huren". ©.  Unser Fahrrad ist gefahren, es geht sogar ziemlich gut um die Unebenheiten herum und bewältigt Hindernisse, die man vorher nur erraten konnte. <br> <a href=""><img src="https://habrastorage.org/webt/_c/yq/kp/_cyqkpcr3okpjz01osvwajd-pje.png"></a> </p><br><p>  Im Folgenden wird eine Seite des ursprünglichen internen Geräts des fiktiven "Rubik's Cube" beschrieben - Computerverarbeitung für die interaktive Datenvisualisierung. </p><a name="habracut"></a><br><blockquote>  <em>Eine einfache Aufgabe sollte einfach gelöst werden, und eine schwierige sollte auch einfach sein, aber länger ...</em> </blockquote><p>  Wir begannen, ein System mit kleinen Kräften zu schaffen, und gingen von einfach zu komplex über.  Bei der Erstellung eines Konstruktors waren wir intern davon überzeugt, dass wir den Zweck des Systems gut verstehen und gleichzeitig mit dem Wunsch kämpfen, nicht zu viel zu tun, und dem entgegengesetzten Wunsch, alles und jedes zu automatisieren und einen Rahmen für alles zu schaffen.  Darüber hinaus war eines unserer wunderbaren Frameworks fertig und wurde sogar in der Produktion getestet - jsBeans.  Deshalb haben wir mit der Entwicklung des nächsten Datenverarbeitungssystems begonnen, das gewachsen ist und jetzt gleichzeitig ein autarkes Produkt ist - ein Designer und eine Plattform für die Entwicklung einer ganzen Klasse von Datenverarbeitungssystemen.  Bedingt werden wir es in dem Artikel "Rubik's Cube" nennen, um auf Werbung zu verzichten, aber unserer Meinung nach interessante Lösungen zu beschreiben. </p><br><h2 id="kub-srez-izmerenie">  Würfel, Scheibe, Messung </h2><br><p>  Die Hauptaufgabe besteht darin, aus nicht zusammenhängenden Datensätzen, einschließlich heterogener externer Datenbanken und Dateien, ein mehrdimensionales Modell aus miteinander verbundenen Elementen der Quelldaten und den Ergebnissen ihrer analytischen Verarbeitung zur Visualisierung auf dynamischen Dashboards und miteinander verbundenen Widgets zu erstellen. </p><br><p>  Einfach ausgedrückt als anklickbares Dashboard: </p><br><p><img src="https://habrastorage.org/webt/9r/1u/w1/9r1uw1pcuwqt4i_l0dbav0bqhsk.png" alt="Beispiel für ein Dashboard mit Schulbewertung"></p><br><p>  Ein solches mehrdimensionales Datenmodell in unserem System heißt "Cube" und stellt buchstäblich eine abstrakte Sammlung von veränderlichen Datensätzen dar, die als "Slice" bezeichnet werden und durch gemeinsame Ausgabefelder / -spalten oder interne Felder mit der Bezeichnung "Dimensions" miteinander verbunden sind und zum Filtern von und verwendet werden Slices miteinander verbinden. </p><br><p>  Ein Slice kann abhängig von den Filterbedingungen als virtuelle Tabelle oder Ansicht ( <abbr title="Gemeinsamer Tabellenausdruck">CTE</abbr> ) mit Parametern und einem variablen Anforderungshauptteil dargestellt werden.  Die Hauptsache ist, dass sich die Ausgabedaten abhängig von den Kontextsuchbedingungen (innerhalb des Widgets) und dem globalen Filter ändern, der durch Auswahl von Werten in den Widgets und Verwendung grundlegender Logikfunktionen (UND / ODER / NICHT) und Kombinationen erstellt wird. </p><br><p>  Mit dem globalen Filter können Sie den Zauberwürfel wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video</a> drehen: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Wxvey5PByQQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Wenn das Ausgabefeld eines Slice gleichzeitig eine Messung in einem anderen Slice ist und denselben Namen hat, werden die Werte dieses Felds vom System als „Fakten“ (wenn es sich um <abbr title="Online-Analyseverarbeitung, interaktive Analyseverarbeitung">OLAP handelt</abbr> ) wahrgenommen, die in Form eines globalen Filters festgelegt sind, der die ursprünglichen Datensätze während der Berechnungen und Aggregation ändert .  Infolgedessen kommt es zu einer dynamischen Interaktion von Widgets, bei der die Werte der angezeigten Indikatoren von den ausgewählten Elementen und Filtern abhängen. </p><br><p>  Ein Slice ist ein Datensatz, der "durch Messungen" geändert werden kann - ursprünglich oder als Ergebnis analytischer Berechnungen.  gekennzeichnet durch Ausgabefelder / -spalten, eine Liste der unterstützten Messungen und eine Reihe von Parametern mit Standardwerten;  beschrieben durch eine relativ elegante Abfrage in einem visuellen Editor, der Filterung, Sortierung, Gruppierung / Aggregation, Schnittpunkte (JOIN), Gewerkschaften (UNION), Rekursion und andere Manipulationen unterstützt. </p><br><p>  Slices, die sich gegenseitig als Quellen verwenden, beschreiben die interne Struktur eines Cubes, zum Beispiel: </p><br><p><img src="https://habrastorage.org/webt/u5/ev/ay/u5evay1gcdf76whlfgmdxijmu_0.jpeg" alt="Beispiel für eine würfelstruktur"></p><br><p>  Slicer-Beispiel im Editor: </p><br><p><img src="https://habrastorage.org/webt/ow/p_/on/owp_onr465vphjta2gginzvywf8.png" alt="Beispiel für einen Slicer-Anforderungseditor"></p><br><p>  Ein Slice unterstützt beide Messungen, die explizit in den Ausgabefeldern angegeben sind, und erbt Messungen von den Abfragequellen. Dies bedeutet, dass die Ausgabe des Slice auch aufgrund von Änderungen in anderen Slices-Quellen geändert werden kann.  Mit anderen Worten, die Ergebnisse des Slice können nicht nur nach den Ausgabefeldern, sondern auch nach den internen Feldmessungen der Quellen irgendwo in der Tiefe der Abfrage bis zu den primären Datenbanktabellen gefiltert werden. </p><br><p>  Die Abfragestruktur wird zum Zeitpunkt der Ausführung vom System automatisch erweitert und geändert. Dies hängt von den aktuellen globalen Filter- und Eingabeparametern ab und zieht sie je nach Cube-Modell, deklarierten Messungen und Slices tiefer in die Abfrage. </p><br><p>  Ein Beispiel für einen einfachen globalen Filter im wahrsten Sinne des Wortes, wenn ein Benutzer Werte für mehrere Widgets festgeschrieben oder ausgewählt hat: </p><br><p><img src="https://habrastorage.org/webt/vd/aj/li/vdajlihvw-uymjxya7qr565mx_8.png" alt="Ein Beispiel für einen globalen Filter in einem Dashboard"></p><br><p>  Der globale Filter wird in einer JSON-Anforderung gespeichert: </p><br><p><img src="https://habrastorage.org/webt/t0/uu/lb/t0uulbpjpqaf_pndtyczt3mvt6k.png" alt="JSON-Beispiel eines globalen Filters im Anforderungshauptteil"></p><br><p>  Die Anfrage kommt bereits in vorbereiteter Form an die Primärquelle (an die Datenbank), nachdem mehrere Hauptphasen durchlaufen wurden: </p><br><ul><li>  Anforderungsassemblierung, einschließlich Auswahl und Einbettung optimaler Slices unter Berücksichtigung des aktuellen globalen Filters (wenn der Filter fehlt oder einfach ist, können Sie einfache / schnelle Slices auswählen; wenn der Filter komplex ist - Slices mit komplexer Struktur und zusätzlichen Messungen); </li><li>  Einbetten eines globalen Filters und Hinzufügen von Filtern zu den Hauptteilen von Abfragen und Unterabfragen; </li><li>  Einbetten von Makros und Vorlagenabfrageausdrücken; </li><li>  Abfrageoptimierung, einschließlich Entfernen nicht verwendeter Felder und Ausdrücke; </li><li>  Zusätzliche Operationen mit der Abfrage für die Besonderheiten von Primärdatenbanken (wenn beispielsweise über SQL gesprochen wird und die Datenbank kein WITH enthält, werden benannte Abfragen eingebettet). </li></ul><br><p>  Die letzte Phase ist die Übersetzung der Anforderung in das Format der Primärquelle, beispielsweise in SQL: </p><br><p><img src="https://habrastorage.org/webt/ui/rd/ls/uirdlsovx8idhgtxgyovng8gg2a.png" alt="Unterschiedliches Anforderungsbeispiel mit gehörtem Filter"></p><br><h2 id="kogda-istochniki-raznye">  Wenn die Quellen unterschiedlich sind </h2><br><p>  In der Regel ist alles einfach und klar, wenn Sie mit einem einzigen Data Warehouse arbeiten müssen.  Wenn es jedoch mehrere davon gibt und diese sich grundlegend unterscheiden, müssen Sie für jede bestimmte Aufgabe unterschiedliche Tricks anwenden.  Und Sie möchten immer eine universelle Lösung haben, die immer geeignet ist, vorzugsweise sofort einsatzbereit, mit maximal geringfügigen Änderungen.  Zu diesem Zweck wird eine andere Abstraktion benötigt: Über Data Warehouses wird zum einen die Koordination von Abfrageformaten und -sprachen realisiert und zum anderen die gegenseitige Abhängigkeit der Daten sichergestellt, zumindest auf der Ebene zusätzlicher Filterbedingungen bei Abfragen an eine Quelle durch Werte aus einer anderen. </p><br><p>  Zu diesem Zweck haben wir eine universelle Abfragesprache entwickelt, die sowohl zur Darstellung eines virtuellen Modells von Cube-Daten als auch zur Arbeit mit bedingt beliebigen Speichern geeignet ist, indem die Anforderung in das gewünschte Format und die gewünschte Sprache übersetzt wird.  Durch einen glücklichen Zufall hat sich die Abfragesprache, die ursprünglich für die einfache Zuordnung und Filterung von Daten aus verschiedenen Quellen vorgesehen war, leicht zu einer vollwertigen Sprache für die Suche und Verarbeitung von Daten entwickelt, die es ermöglicht, auf mehreren Seiten und mit vielen Unterabfragen Rechenkonstruktionen von der einfachsten bis zur komplexesten zu erstellen. </p><br><p>  Quellen können in drei Typen unterteilt werden: </p><br><ol><li>  Datendateien, die auf das System heruntergeladen werden müssen; </li><li>  Datenbanken, die die vollständige Datenverarbeitung und andere Vorgänge unterstützen; </li><li>  Speicher, die nur die Datenextraktion mit oder ohne Filterung unterstützen, einschließlich verschiedener Arten von externen Diensten. </li></ol><br><p>  Beim ersten Typ ist alles eindeutig - das Importmodul ist in das System integriert, das verschiedene Eingabeformate analysiert und die Ergebnisse in das Repository eintaucht.  Für den Import wurde auch ein spezieller Konstruktor entwickelt, der separat besprochen werden sollte. </p><br><p>  Der zweite Typ sind in sich geschlossene Datenbanken, für die Sie nur die ursprüngliche Anfrage in das gewünschte Format und die gewünschte Sprache der Anfrage, den Dialekt, übersetzen müssen. </p><br><p>  Der dritte Typ erfordert mindestens Nachbearbeitungsdaten.  Und alle Typen gleichzeitig können auch eine Nachbearbeitung erfordern - Schnittpunkte, Gewerkschaften, Aggregation und endgültige Berechnungen.  Dies geschieht, wenn die Datenverarbeitung in einer Datenbank unter Berücksichtigung der Filterergebnisse in einer anderen externen Datenbank durchgeführt werden muss. </p><br><p>  <em>Das einfachste Beispiel ist, wenn eine Fuzzy-Suche in einer Datenbank durchgeführt wird und am Ausgang eine Aggregation von Indikatoren abgerufen werden muss, die in einer anderen Datenbank auf einem anderen Server gespeichert sind, wobei die Suchergebnisse berücksichtigt werden.</em> </p><br><p>  Um die Arbeit eines solchen Schemas zu implementieren, wird in unserem System ein einfacher Algorithmus implementiert - die anfängliche Anforderung wird gleichzeitig von mehreren Interpreten vorbereitet, von denen jeder entweder die Ausführung der Anforderung ablehnen kann, wenn sie nicht kompatibel ist, oder einen Iterator mit Daten zurückgeben oder die Anforderung konvertieren und die Arbeit der nächsten Anforderungsvorbereitungskette durch einen anderen Interpreter initiieren kann .  Als Ergebnis erhalten wir für eine einzelne Anforderung einen bis mehrere faule Iteratoren, die das gleiche Ergebnis erzielen, jedoch auf unterschiedliche Weise, aus denen das beste ausgewählt wird (gemäß verschiedenen Kriterien, die vom Entwickler in der Konfiguration definiert wurden). </p><br><p>  Die Iteratorauswahlstrategie wird in den Konfigurations- oder Abfrageparametern angegeben.  Derzeit werden mehrere wichtige Strategien unterstützt: </p><br><ul><li>  zuerst, jeder, zuletzt; </li><li>  nach Prioritätstyp der Datenbank; </li><li>  nach Priorität der Ketten, die die Iteratoren bildeten; </li><li>  durch die Gewichtsfunktion der "Anforderungsgewichtung"; </li><li>  Gemäß dem ersten Ergebnis werden alle Iteratoren parallel gestartet und das erste Ergebnis wird erwartet. Infolgedessen wird der schnellste Iterator verwendet, der Rest wird geschlossen. </li></ul><br><p>  Als Ergebnis einer solchen Kombination für eine Eingabeanforderung erhalten wir mehrere Optionen für deren Ausführung, sowohl unter Verwendung unterschiedlicher Quellen als auch mit unterschiedlichen Ausführungsstrategien - Auswahl der Haupt- / Zieldatenbank, in der der Hauptteil der Anforderung ausgeführt wird, und der endgültigen Zusammenstellung der Ergebnisse. </p><br><p>  Wenn das Ziel-DBMS die Verbindung externer Quellen unterstützt, kann eine umgekehrte Schaltung erstellt werden, in der das DBMS mit der System-API verbunden ist, um kleine Datenmengen vom System zu empfangen, um beispielsweise große Volumes "an Ort und Stelle" zu filtern.  Eine solche Integration ist für den Endbenutzer und den Analysten transparent - das Cube-Modell ändert sich nicht und alle Vorgänge werden automatisch vom System ausgeführt. </p><br><p><img src="https://habrastorage.org/webt/az/ie/vx/azievxht98zpnyahcnoymfdcgr8.png" alt="Vereinfachtes Sequenzdiagramm beim Abfragen führen integrierter Datenbanken in einer Abfrage"></p><br><p>  In komplexeren Fällen implementiert das System einen internen In-Memory-Abfrageinterpreter für das bemerkenswerte H2 Embedded-Datenbankmodul, mit dem jede unterstützte Datenbank sofort integriert werden kann.  Im wahrsten Sinne des Wortes funktioniert es so: Die Anforderung wird durch Gruppen von Quellen in Teile unterteilt, die zur Ausführung gesendet werden. Anschließend werden die Zusammenstellung und die endgültige Verarbeitung der Ergebnisse im Speicher in H2 durchgeführt. </p><br><p>  Auf den ersten Blick scheint ein solches Datenintegrationsschema auf der Ebene der internen Interpreter „schwierig“ zu sein. Dies gilt, wenn Sie mit großen Mengen an Eingabedaten arbeiten müssen und Berechnungen nach Schnittpunkten und Zuordnungen von Mengen aus externen Quellen durchführen müssen.  Tatsächlich ist dieser Umstand teilweise ausgeglichen - gleichzeitig wird die Anforderung von mehreren Handlern in unterschiedlichen Versionen ausgeführt, daher wird der Interpreter nur in den extremsten Fällen als sofort einsatzbereite universelle Lösung verwendet.  Letztendlich ist jede Integration durch die typischen Transportkosten für die Vorbereitung, Übertragung über das Netzwerk und den Empfang von Daten begrenzt, und dies ist eine völlig andere Aufgabe. </p><br><h2 id="tehnicheskaya-storona">  Technische Seite </h2><br><p>  Von der technischen Seite, auf die Sie wahrscheinlich nicht verzichten können, wenn Sie dieses Thema ansprechen, ist das System auch nach dem Prinzip konzipiert - mehr zu tun, aber alles so weit wie möglich zu vereinfachen. </p><br><p>  Das Datenverarbeitungssystem wird auf dem jsBeans-Client-Server-Framework als eine Reihe zusätzlicher Module und spezifischer Assemblyprojekte implementiert.  jsBeans wiederum ist in Java implementiert, arbeitet als Anwendungsserver, besteht im Großen und Ganzen aus Rhino, Jetty und Akka und umfasst auch die von unserem Team entwickelte Client-Server-Bean-Technologie sowie eine umfangreiche Bibliothek von Komponenten, die über mehrere Jahre erfolgreicher Anwendung zusammengestellt wurden. </p><br><p>  Der Rubik's Cube ist vollständig und vollständig in JavaScript in Form vieler js-Bins (* .jsb-Dateien) implementiert, von denen einige nur auf dem Server ausgeführt werden.  Der andere Teil befindet sich auf dem Client, und der Rest ist eine Komponentenkomponente, die als verteiltes Ganzes fungiert und deren Teile miteinander interagieren, für den Entwickler transparent, aber unter seiner Kontrolle.  Js-Bins können unterschiedliche Lebensstrategien haben, zum Beispiel mit oder ohne Benutzersitzung und vieles mehr.  Die Bean ist isomorph und ermöglicht es sowohl dem Client als auch dem Server, als virtuelle Instanz einer regulären Klasse damit zu arbeiten.  Der Bin wird durch eine einzelne Datei beschrieben und enthält drei Abschnitte - für Felder und Methoden, die auf dem Client ausgeführt werden, für Serverfelder sowie einen Abschnitt allgemeiner synchronisierter Felder. </p><br><p>  Da sich der Artikel bereits als ausführlich herausgestellt hat, um die Leser nicht zu langweilen, ist es an der Zeit, mit der Fertigstellung fortzufahren, mit der Absicht, bald die Details und die interessantesten architektonischen Lösungen bei der Implementierung von JsBeans und unseren darauf basierenden Projekten zu beschreiben - das konstruierte Visualisierungssubsystem, analytische Prozesse, ontologischer Designer von Themenbereichen, Sprache Abfragen, Datenimport und etwas anderes ... </p><br><h2 id="pochemu-tak">  Warum so? </h2><br><blockquote>  <em>Das ist noch nie passiert und hier wieder ...</em> </blockquote><p>  Anfangs gab es nur wenige Primärdatensätze.  Themenbereiche und Aufgaben wurden vollständig spezifiziert.  Es scheint, warum solche Qualen?  Die Aufgabe sah einfach aus, jeder wollte das Ergebnis sofort erhalten - besonders wenn die schnelle Lösung auf der Oberfläche lag und die richtige Ausdauer und ausgewogene Entscheidungen erforderte, wobei das ursprüngliche Setup eingehalten wurde.  Wir sind in die entgegengesetzte Richtung gegangen, von komplexen und langen Lösungen zu einfachen und schnellen, um bestimmte Probleme zu verallgemeinern. </p><br><p>  Die Hauptbedingung ist, dass neue Dashboards schnell erstellt werden müssen, auch wenn sich der neue Themenbereich und die analytischen Anforderungen stark von den vorherigen unterscheiden.  Offensichtlich werden Sie nicht einmal die Hälfte der zukünftigen Anforderungen erraten, das System muss in erster Linie biegsam sein.  Die Verfeinerung der Komponentenbibliothek, analytische Algorithmen und die Verbindung neuer Arten von Quellen ist ein wesentlicher Bestandteil der Anpassung des Systems.  Mit anderen Worten, der Haufen hat funktioniert - Analysten erstellen Abfragen und Dashboards, und Programmierer erkennen schnell neue Anforderungen für sie.  Und wir als Programmierer haben zunächst versucht, unsere Arbeit in Zukunft zu vereinfachen, um die Benutzerfreundlichkeit nicht zu beeinträchtigen. </p><br><p>  Und das System wurde sofort universell und anpassungsfähig erstellt - wir haben einen „Konstruktor für Konstruktor“ erstellt und ein Framework auf einem Framework entwickelt, das zuvor mit einem ähnlichen, aber noch allgemeineren Zweck erstellt wurde. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Bewertung der Moskauer Schulen auf der Grundlage der Ergebnisse des Einheitlichen Staatsexamens und der Olympiaden</a></strong> ist ein Beispiel für ein Dashboard, das auf die oben beschriebene Weise aus dem Entladen offener Daten der Moskauer Regierung aus dem Portal erstellt wurde. </p><br><p>  <strong>Cube-Rubik</strong> ist eine grundlegende Plattform für die Entwicklung von Informations- und Analysesystemen.  Entworfen als Zweig und logische Fortsetzung von jsBeans.  Es enthält alle notwendigen Module zur Lösung der Probleme der Erfassung, Verarbeitung, Analyse (rechnerisch und prozessorientiert) und Visualisierung. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jsBeans</a></strong> ist ein isomorphes Full-Stack-Webframework, das die Client-Server-JavaScript-Bean-Technologie implementiert und mit einer offenen Lizenz als universelles Tool entwickelt wurde.  Während des Gebrauchs hat es sich in den meisten Fällen als gut erwiesen und passt ideal zu den vor uns liegenden Aufgaben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452154/">https://habr.com/ru/post/de452154/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452138/index.html">13. Check Point Erste Schritte R80.20. Lizenzierung</a></li>
<li><a href="../de452140/index.html">Warum wechseln CFOs in der IT zu einem Betriebskostenmodell?</a></li>
<li><a href="../de452142/index.html">Wie gehen wir mit dem Kopieren von Inhalten oder dem ersten gegnerischen Angriff in Prod um?</a></li>
<li><a href="../de452146/index.html">Was passiert also mit Authentifizierung und Passwörtern? Teil 2 des Javelin Strong Authentication Status Report</a></li>
<li><a href="../de452152/index.html">Welche Lösungen hat Rostelecom für IIoT?</a></li>
<li><a href="../de452158/index.html">TOPchik - ein offenes WordPress-Plugin zur kostenlosen Überprüfung der Site-Positionen für Suchanfragen über die Yandex.XML-API</a></li>
<li><a href="../de452162/index.html">Bot für VK auf Python mit MySQL in einer Stunde, Teil 1</a></li>
<li><a href="../de452164/index.html">ModLook - ModBus-Registerscanner. Wir feiern den 20. Jahrestag des Programms</a></li>
<li><a href="../de452168/index.html">Erstellen eines Rhythmus-Spiels in Unity</a></li>
<li><a href="../de452172/index.html">Komplexe Systeme. Erreichen eines kritischen Niveaus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>