<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐜 🦂 ⚙️ PostgreSQL Antipatterns: tekan kamus di JOIN berat 🏿 ✍🏾 🚶🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami melanjutkan serangkaian artikel yang ditujukan untuk mempelajari cara-cara yang kurang dikenal untuk meningkatkan kinerja pertanyaan PostgreSQL "...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL Antipatterns: tekan kamus di JOIN berat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485398/">  Kami melanjutkan serangkaian artikel yang ditujukan untuk mempelajari cara-cara yang kurang dikenal untuk meningkatkan kinerja pertanyaan PostgreSQL "tampaknya sederhana": <br><br><ul><li>  <a href="https://habr.com/post/484670/">catatan langka akan mencapai tengah BERGABUNG</a> </li><li>  <a href="https://habr.com/post/479920/">sisyphus bergabung dengan array</a> </li><li>  <a href="https://habr.com/post/479508/">berbahaya BERGABUNG dan ATAU</a> </li><li>  <a href="https://habr.com/post/479298/">CTE GABUNG CTE</a> </li></ul><br>  Jangan berpikir bahwa saya tidak terlalu suka BERGABUNG ... :) <br><br>  Tetapi seringkali tanpa itu, permintaan secara signifikan lebih produktif daripada bersamanya.  Oleh karena itu, hari ini kami akan berusaha sepenuhnya untuk menyapu <b>habis sumber daya yang intensif</b> - dengan bantuan kamus. <br><br><img src="https://habrastorage.org/webt/uf/33/uh/uf33uhbf3ke85rlwi6o-nhaygdw.png"><br><a name="habracut"></a><br><blockquote> Dimulai dengan PostgreSQL 12, beberapa situasi yang dijelaskan di bawah ini dapat dimainkan sedikit berbeda karena <a href="https://www.depesz.com/2019/02/19/waiting-for-postgresql-12-allow-user-control-of-cte-materialization-and-change-the-default-behavior/" rel="nofollow">non-materialisasi CTE secara default</a> .  Perilaku ini dapat dikembalikan ke dengan menggunakan kunci <code>MATERIALIZED</code> . </blockquote><br><h2>  Banyak "fakta" pada kosakata terbatas </h2><br>  Mari kita ambil aplikasi yang sangat nyata - Anda perlu mendaftar <a href="https://habr.com/ru/post/483176/">pesan masuk</a> atau tugas aktif dengan pengirim: <br><br><pre> <code class="plaintext hljs">25.01 |  .. |    . 22.01 |  .. |    :   JOIN. 20.01 |  .. |   . 18.01 |  .. |    : JOIN    . 16.01 |  .. |   .</code> </pre><br>  Dalam dunia abstrak, penulis tugas harus didistribusikan secara merata di antara semua karyawan organisasi kami, tetapi dalam kenyataannya, <b><i>tugas datang, sebagai suatu peraturan, dari jumlah orang yang cukup terbatas</i></b> - "dari atasan" ke atas hierarki atau "dari sekutu" dari departemen tetangga (analis, desainer pemasaran ...). <br><br>  Mari kita asumsikan bahwa dalam organisasi kami yang terdiri dari 1000 orang, hanya 20 penulis (biasanya bahkan lebih sedikit) yang menetapkan tugas untuk setiap artis tertentu dan <a href="https://habr.com/ru/post/484670/">menggunakan pengetahuan subjek ini</a> untuk mempercepat permintaan "tradisional". <br><br><div class="spoiler">  <b class="spoiler_title">Generator skrip</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  CREATE TABLE person AS SELECT id , repeat(chr(ascii('a') + (id % 26)), (id % 32) + 1) "name" , '2000-01-01'::date - (random() * 1e4)::integer birth_date FROM generate_series(1, 1000) id; ALTER TABLE person ADD PRIMARY KEY(id); --     CREATE TABLE task AS WITH aid AS ( SELECT id , array_agg((random() * 999)::integer + 1) aids FROM generate_series(1, 1000) id , generate_series(1, 20) GROUP BY 1 ) SELECT * FROM ( SELECT id , '2020-01-01'::date - (random() * 1e3)::integer task_date , (random() * 999)::integer + 1 owner_id FROM generate_series(1, 100000) id ) T , LATERAL( SELECT aids[(random() * (array_length(aids, 1) - 1))::integer + 1] author_id FROM aid WHERE id = T.owner_id LIMIT 1 ) a; ALTER TABLE task ADD PRIMARY KEY(id); CREATE INDEX ON task(owner_id, task_date); CREATE INDEX ON task(author_id);</span></span></code> </pre></div></div><br>  Kami menampilkan 100 tugas terakhir untuk artis tertentu: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> task.* , person.name <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> task <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> person <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> person.id = task.author_id <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> owner_id = <span class="hljs-number"><span class="hljs-number">777</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> task_date <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br><img src="https://habrastorage.org/webt/gt/qo/ba/gtqoba5xxrim1xd0ec98ezjuuxi.png"><br>  <a href="https://explain.tensor.ru/archive/explain/5f4f9c25197bf7c534ffe7a25b1b75a6:0:2020-01-27" rel="nofollow">[lihat menjelaskan.tensor.ru]</a> <br><br>  Ternyata <b>1/3 dari seluruh waktu dan 3/4 pembacaan</b> halaman data dibuat hanya untuk mencari penulis 100 kali - untuk setiap tugas yang ditampilkan.  Tetapi kita tahu bahwa di antara ratusan ini <b>hanya ada 20 yang berbeda</b> - dapatkah pengetahuan ini digunakan? <br><br><h2>  kamus hstore </h2><br>  Kami menggunakan <a href="https://postgrespro.ru/docs/postgresql/12/hstore" rel="nofollow">tipe hstore</a> untuk menghasilkan "kamus" nilai kunci: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> EXTENSION hstore</code> </pre> <br>  Cukup bagi kami untuk memasukkan ID penulis dan namanya di kamus, sehingga nanti kami bisa mengekstrak menggunakan kunci ini: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--    WITH T AS ( SELECT * FROM task WHERE owner_id = 777 ORDER BY task_date DESC LIMIT 100 ) --      , dict AS ( SELECT hstore( -- hstore(keys::text[], values::text[]) array_agg(id)::text[] , array_agg(name)::text[] ) FROM person WHERE id = ANY(ARRAY( SELECT DISTINCT author_id FROM T )) ) --     SELECT * , (TABLE dict) -&gt; author_id::text -- hstore -&gt; key FROM T;</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/vn/2f/ms/vn2fms1aupegpmtrwwh7l3dekoo.png"><br>  <a href="https://explain.tensor.ru/archive/explain/6ee4e4e26ded9567ac9631ceee9bb8c0:0:2020-01-27" rel="nofollow">[lihat menjelaskan.tensor.ru]</a> <br><br>  Butuh <b>2 kali lebih sedikit waktu untuk</b> mendapatkan informasi tentang orang <b>dan 7 kali lebih sedikit data dibaca</b> !  Selain "penipuan", hasil ini membantu kami untuk mencapai <b>ekstraksi massal catatan</b> dari tabel dalam satu pass menggunakan <code>= ANY(ARRAY(...))</code> . <br><br><h4>  Entri tabel: serialisasi dan deserialisasi </h4><br>  Tetapi bagaimana jika kita perlu menyimpan dalam kamus bukan satu bidang teks, tetapi seluruh catatan?  Dalam hal ini, kemampuan PostgreSQL <b>untuk bekerja dengan menulis tabel sebagai nilai tunggal</b> akan membantu kami: <br><br><pre> <code class="sql hljs">... , dict AS ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> hstore( array_agg(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>[] , array_agg(p)::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>[] <span class="hljs-comment"><span class="hljs-comment">--  #1 ) FROM person p WHERE ... ) SELECT * , (((TABLE dict) -&gt; author_id::text)::person).* --  #2 FROM T;</span></span></code> </pre> <br>  Mari kita lihat apa yang terjadi di sini: <br><br><ol><li>  Kami mengambil <b>p sebagai alias untuk catatan lengkap dari tabel orang</b> dan mengumpulkan array dari mereka. </li><li>  <b>Larik entri ini disusun kembali</b> menjadi larik string teks (orang [] :: teks []) untuk memasukkannya ke dalam kamus hstore sebagai larik nilai. </li><li>  Setelah menerima catatan tertaut, kami <b>mengeluarkannya dari kamus dengan kunci</b> sebagai string teks. </li><li>  Kita perlu <b>mengubah</b> teks <b>menjadi nilai dari tipe tabel</b> orang (untuk setiap tabel jenis nama yang sama secara otomatis dibuat). </li><li>  "Menyebarkan" catatan yang diketik ke dalam kolom menggunakan <code>(...).*</code> . </li></ol><br><h2>  kamus json </h2><br>  Tetapi trik seperti itu, seperti yang telah kami terapkan di atas, tidak akan berfungsi jika tidak ada tipe tabel yang sesuai untuk membuat "unfastening".  Situasi yang sama persis akan muncul, dan jika sebagai sumber data untuk serialisasi kami mencoba menggunakan <b>baris CTE, dan bukan tabel "nyata"</b> . <br><br>  Dalam hal ini, <a href="https://postgrespro.ru/docs/postgresql/12/functions-json" rel="nofollow">fungsi untuk bekerja dengan json</a> akan membantu kami: <br><br><pre> <code class="sql hljs">... , p AS ( <span class="hljs-comment"><span class="hljs-comment">--   CTE SELECT * FROM person WHERE ... ) , dict AS ( SELECT json_object( --    json array_agg(id)::text[] , array_agg(row_to_json(p))::text[] --   json    ) FROM p ) SELECT * FROM T , LATERAL( SELECT * FROM json_to_record( ((TABLE dict) -&gt;&gt; author_id::text)::json --     json ) AS j(name text, birth_date date) --     ) j;</span></span></code> </pre> <br>  Perlu dicatat bahwa ketika menggambarkan struktur target, kita tidak bisa mendaftar semua bidang string sumber, tetapi hanya yang benar-benar kita butuhkan.  Jika kita memiliki tabel "asli", maka lebih baik menggunakan fungsi <code>json_populate_record</code> . <br><br>  Kami masih memiliki akses ke kamus sekali, tetapi <b>biaya serialisasi json [cukup] cukup tinggi</b> , jadi masuk akal untuk menggunakan metode ini hanya dalam beberapa kasus ketika CTE Scan "jujur" menunjukkan dirinya lebih buruk. <br><br><h2>  Menguji kinerja </h2><br>  Jadi, kami punya dua cara untuk membuat serialisasi data ke dalam kamus - <b>hstore / json_object</b> .  Selain itu, array kunci dan nilai juga dapat dihasilkan dalam dua cara, dengan konversi internal atau eksternal ke teks: <b>array_agg (i :: text) / array_agg (i) :: text []</b> . <br><br>  Mari kita periksa keefektifan berbagai jenis serialisasi menggunakan contoh sintetis murni - kita membuat <b>serialisasi sejumlah kunci yang berbeda</b> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> dict <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> hstore( array_agg(i::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) , array_agg(i::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, ...) i ) <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dict;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Skrip evaluasi: serialisasi</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * , ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> regexp_replace(ea[array_length(ea, <span class="hljs-number"><span class="hljs-number">1</span></span>)], <span class="hljs-string"><span class="hljs-string">'^Execution Time: (\d+\.\d+) ms$'</span></span>, <span class="hljs-string"><span class="hljs-string">'\1'</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">real</span></span> et <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> array_agg(el) ea <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dblink(<span class="hljs-string"><span class="hljs-string">'port= '</span></span> || current_setting(<span class="hljs-string"><span class="hljs-string">'port'</span></span>) || <span class="hljs-string"><span class="hljs-string">' dbname='</span></span> || current_database(), $$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> dict <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> hstore( array_agg(i::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) , array_agg(i::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, $$ || (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; v) || $$) i ) <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dict $$) T(el <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) ) T ) et <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>) v , LATERAL generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>) i <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> v , <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(et)::<span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> </div></div><br><img src="https://habrastorage.org/webt/le/ho/tk/lehotkorqfxuassbuqsrcexjh6k.png"><br><br>  Pada PostgreSQL 11, hingga sekitar ukuran kamus 2 ^ 12 kunci, <b>serialisasi dalam json membutuhkan waktu lebih sedikit</b> .  Kombinasi json_object dan konversi tipe "internal" dari <code>array_agg(i::text)</code> adalah yang paling efisien. <br><br>  Sekarang mari kita coba membaca nilai dari setiap tombol 8 kali - karena jika Anda tidak mengakses kamus, lalu mengapa itu diperlukan? <br><br><div class="spoiler">  <b class="spoiler_title">Skrip evaluasi: membaca dari kamus</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * , ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> regexp_replace(ea[array_length(ea, <span class="hljs-number"><span class="hljs-number">1</span></span>)], <span class="hljs-string"><span class="hljs-string">'^Execution Time: (\d+\.\d+) ms$'</span></span>, <span class="hljs-string"><span class="hljs-string">'\1'</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">real</span></span> et <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> array_agg(el) ea <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dblink(<span class="hljs-string"><span class="hljs-string">'port= '</span></span> || current_setting(<span class="hljs-string"><span class="hljs-string">'port'</span></span>) || <span class="hljs-string"><span class="hljs-string">' dbname='</span></span> || current_database(), $$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> dict <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> json_object( array_agg(i::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) , array_agg(i::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, $$ || (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; v) || $$) i ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dict) -&gt; (i % ($$ || (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; v) || $$) + <span class="hljs-number"><span class="hljs-number">1</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, $$ || (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; (v + <span class="hljs-number"><span class="hljs-number">3</span></span>)) || $$) i $$) T(el <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) ) T ) et <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>) v , LATERAL generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>) i <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> v , <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(et)::<span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> </div></div><br><img src="https://habrastorage.org/webt/et/fq/vj/etfqvjlzj4qy4rjqwskzteg36aw.png"><br><br>  Dan ... sudah sekitar <b>2 ^ 6 kunci, membaca dari kamus json mulai kehilangan untuk</b> membaca dari hstore beberapa kali, untuk jsonb hal yang sama terjadi pada 2 ^ 9. <br><blockquote>  Kesimpulan akhir: <br><br><ul><li>  jika Anda perlu <b>BERGABUNG dengan catatan berulang kali</b> - lebih baik menggunakan "tabel matching" </li><li>  jika kamus Anda diharapkan <b>kecil dan Anda akan membaca sedikit darinya</b> - Anda dapat menggunakan json [b] </li><li>  dalam semua kasus lain, <b>hstore + array_agg (i :: text)</b> akan lebih efisien </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485398/">https://habr.com/ru/post/id485398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485388/index.html">Aturan, menderita, tersenyum</a></li>
<li><a href="../id485390/index.html">Kompetisi hibah mikro sumber terbuka untuk proyek data terbuka</a></li>
<li><a href="../id485392/index.html">Bot telegram yang memonitor domain</a></li>
<li><a href="../id485394/index.html">Bagaimana infrastruktur Internet lahir</a></li>
<li><a href="../id485396/index.html">Pemeriksaan Kesehatan Regu: Mengukur Kesehatan Tim</a></li>
<li><a href="../id485404/index.html">Kami menyadari efek visual dari film "The Matrix"</a></li>
<li><a href="../id485416/index.html">Cara praktis untuk memetakan data di Kotlin</a></li>
<li><a href="../id485418/index.html">PHPUnit. "Bagaimana cara menguji controller sialanku", atau menguji keraguan</a></li>
<li><a href="../id485424/index.html">Bagaimana Saya Mengajari Anak-Anak Python</a></li>
<li><a href="../id485426/index.html">Mobil di Belanda: statistik dan informasi untuk 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>