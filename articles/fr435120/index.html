<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏾 🛌🏼 👐🏿 Fonctions lambda en SQL ... réfléchissons 🕵🏻 👩🏽‍💼 🤟🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De quoi parlera l'article, et donc son nom l'indique. 

 De plus, l'auteur expliquera pourquoi cela est nécessaire de son point de vue, et expliquera ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fonctions lambda en SQL ... réfléchissons</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435120/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/ch/fp/slchfpm_a-deoh62fqiazjgdc5k.png" alt="image"></div><br>  De quoi parlera l'article, et donc son nom l'indique. <br><br>  De plus, l'auteur expliquera pourquoi cela est nécessaire de son point de vue, et expliquera que SUBJ n'est pas seulement une technologie à la mode, mais aussi «une entreprise doublement nécessaire - à la fois agréable et utile». <br><a name="habracut"></a><br>  Il est toujours intéressant de voir comment plusieurs personnes talentueuses font quelque chose (un langage de programmation, pourquoi pas), sachant exactement quel problème elles résolvent et quelles tâches elles se fixent.  Et aussi tester leur création sur eux-mêmes.  À ne pas comparer avec les créations monumentales des comités géants, qui mettent au premier plan le maintien de l'harmonie de l'univers, qui sait comment. <br><br>  Comparez, par exemple, le sort de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FORTRAN</a> et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PL / 1</a> .  Qui se souviendra maintenant de ce PL / 1. <br><br>  De ce point de vue, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AWK</a> , par exemple, est très réussi.  Il vaut la peine de dire qu'en son nom A est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alfred Aho</a> , l'un des auteurs de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dragon Book</a> , W est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Peter Weinberger</a> , qui avait un coup de main à Fortran-77, K est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Brian Kernigan</a> , où serait-il sans lui.  Le langage est destiné au traitement de flux de texte à la volée dans des canaux entre les processus. <br><br>  Le langage est sans type ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce n'est pas tout à fait vrai</a> ), sa syntaxe est très similaire à C, il a des capacités de filtrage, des tableaux associatifs, des événements de début / fin de flux, un événement de nouvelle ligne ... <br><br>  L'auteur a toujours été impressionné par cette langue également par le fait que son interprète n'a pas besoin d'être installé, sous les systèmes de type UNIX, il est toujours là, et sous Windows, il suffit de copier le fichier exécutable et tout fonctionne.  Mais ce n'est pas le cas. <br><br>  Dans le processus, l'auteur doit utiliser le bundle SQL + AWK assez souvent, et c'est pourquoi.  SQL est toujours un langage initialement déclaratif conçu pour contrôler les flux de données.  Il offre des possibilités très limitées de travailler avec le contexte d'exécution de requête sous la forme de fonctions d'agrégation. <br><br>  Comment, par exemple, construire un histogramme bidimensionnel en utilisant SQL? <br><br><pre><code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   100 x 100 SELECT count(), round(x, -2) AS cx, round(y, -2) AS cy FROM samples GROUP BY cx, xy</span></span></code> </pre> <br>  Mais disons que l'utilisation de GROUP BY implique le tri, et ce n'est pas un plaisir bon marché si vous avez des centaines de millions (voire plus) de lignes. <br><div class="spoiler">  <b class="spoiler_title">UPD: dans les commentaires, ils m'ont corrigé que ce n'est pas entièrement vrai (ou pas du tout)</b> <div class="spoiler_text">  Le processeur SQL a la capacité d'exécuter des fonctions d'agrégation dans le processus de construction d'un hachage selon le critère de regroupement.  Pour cela, il est nécessaire qu'il possède la quantité de mémoire libre suffisante pour placer la carte de hachage en mémoire. <br><br>  Ensuite, les contextes des groupes seront mis à jour à mesure que le tableau est lu et à la fin de cette lecture, nous aurons déjà le résultat calculé. <br>  La même technique peut être étendue aux fonctions de fenêtre (ci-dessous), seul le contexte sera «plus épais». <br><br>  Dans le cas où le nombre de groupes est inconnu à l'avance ou très important, le processeur SQL est obligé de créer un index temporaire et de le parcourir lors d'un deuxième passage. <br><br>  Dans des cas simples, par exemple, comme ici - un simple COUNT, une option universelle est possible - un index temporaire (cx, cy, count), puis avec un petit nombre de groupes, tout sera en mémoire sur les pages en cache.  Dans les cas complexes, les fonctions de fenêtre, l'état du groupe devient non trivial et constamment (dé) sérialisant ce n'est pas du tout ce que le médecin a ordonné. <br></div></div>  Résumé: Le processeur SQL a recours au tri lorsqu'il ne peut pas estimer le nombre de groupes après GROUP BY.  Cependant, le regroupement par valeurs calculées est (souvent) juste le cas. <br><br>  Par conséquent, vous devez faire quelque chose comme: <br><br><pre> <code class="bash hljs">psql -t -q -c <span class="hljs-string"><span class="hljs-string">'select x, y from samples'</span></span> | gawk -f mk_hist2d.awk</code> </pre> <br>  où mk_hist2d.awk accumule des statistiques dans le tableau associatif et les affiche à la fin du travail <br><br><pre> <code class="cpp hljs"># mk_hist2d.awk { bucket[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>($<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-number"><span class="hljs-number">0.01</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>($<span class="hljs-number"><span class="hljs-number">3</span></span>*<span class="hljs-number"><span class="hljs-number">0.01</span></span>)]+=$<span class="hljs-number"><span class="hljs-number">1</span></span>; } END { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((i, j) in bucket) print i*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>j*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>bucket[i, j]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> print i*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>j*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" 0"</span></span>; } }</code> </pre><br>  Il y a un MAIS - le flux de données complet doit être envoyé du serveur à la machine qui fonctionne, et ce n'est pas si bon marché. <br><br>  Est-il possible de combiner en quelque sorte l'agréable avec l'utile - d'accumuler des statistiques lors de l'exécution de la requête SQL, mais sans recourir au tri?  Oui, par exemple, en utilisant des fonctions d'agrégation personnalisées. <br><br><h4>  Fonctions d'agrégation personnalisées </h4><br>  Subj est présent dans différents systèmes, partout il se fait un peu à sa manière. <br><br><ol><li>  <b>PostgreSQL</b>  La documentation est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Plus de détails <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br>  C'est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">là que le</a> solde maximum du compte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est</a> calculé. <br>  Et ceci est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple</a> qui calcule ce qui est le plus dans la colonne booléenne - vrai ou faux. <br><br>  Cela ressemble à ceci - <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AGGREGATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mode</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">boolean</span></span>) ( SFUNC = mode_bool_state, STYPE = <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>[], FINALFUNC = mode_bool_final, INITCOND = <span class="hljs-string"><span class="hljs-string">'{0,0}'</span></span> );</code> </pre><br>  Ici <b>SFUNC</b> est une fonction qui est appelée pour chaque ligne du flux, <br>  le premier argument est de type <b>STYPE</b> . <br><br>  <b>FINALFUNC</b> est utilisé pour finaliser les calculs et renvoie la valeur de l'agrégat. <br>  <b>INITCOND</b> - initialisation de la valeur initiale de l'état interne ( <b>STYPE</b> ), passée comme premier argument. <br>  Étant donné que les fonctions peuvent être écrites en C (ce qui signifie que pour l'état interne, vous pouvez utiliser la mémoire qui est automatiquement libérée lorsque vous fermez la demande), c'est un outil très puissant.  Hors du cadre de son utilisation, il faut encore pouvoir y aller. </li><li>  <b>MS SQL</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Auparavant</a> (2000), avant la requête, il était nécessaire de créer un objet ActiveX, pour faire une agrégation en utilisant cet objet. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Maintenant</a> (2016+), cela se fait dans l'environnement CLR.  Vous devrez créer une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonction</a> personnalisée, créer et enregistrer un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">assemblage</a> .  Ensuite, vous pouvez créer un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">agrégat</a> . <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un exemple de</a> calcul de la moyenne géométrique, ainsi que de fusion de chaînes: avec des paramètres supplémentaires et un type défini par l'utilisateur pour stocker un état intermédiaire. </li><li>  <b>Oracle</b> <br>  Dans Oracle, cela se fait à l'aide de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cartouche de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">données</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ODCIAggregate</a> (interface). <br>  Pour créer votre propre agrégat, vous devez écrire un type personnalisé qui implémente 4 méthodes <br>  - l'initialisation (ODCIAggregateInitialize), statique, doit créer une instance du type souhaité et retourner via le paramètre <br>  - itérations (ODCIAggregateIterate), appelées sur chaque ligne de données <br>  - merge (ODCIAggregateMerge), utilisé pour fusionner des agrégats exécutés en parallèle <br>  - finition (ODCIAggregateTerminate) - sortie du résultat <br>  Exemples: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4</a> . </li><li>  <b>DB2</b> <br>  Il n'existe aucun moyen explicite d'utiliser des agrégats personnalisés dans DB2. <br>  Mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous pouvez</a> glisser une fonction standard (bien que MAX) dans un type défini par l'utilisateur (en Java) et obliger le système à exécuter des requêtes de la forme <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> Complex <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DOUBLE</span></span>, i <span class="hljs-keyword"><span class="hljs-keyword">DOUBLE</span></span> ) … <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> complexNumbers ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> Complex ) … <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum..real, sum..i <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> GetAggrResult(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(BuildComplexSum(<span class="hljs-built_in"><span class="hljs-built_in">number</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> complexNumbers ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>)</code> </pre></li></ol><br>  Qu'est-ce qui est remarquable dans tous ces systèmes? <br><br><ul><li>  D'une manière ou d'une autre, vous devrez créer des objets dans la base de données.  Que ce soit AGRÉGÉ ou TYPE.  Au minimum, des droits appropriés sont requis.  <i>Et je veux juste ajouter quelques chiffres sur son genou.</i> <br></li><li>  Vous devrez peut-être écrire quelque chose dans un autre langage, que ce soit C, C # ou Java. <br>  Pour intégrer ce qui est écrit dans le système, encore une fois, des droits sont nécessaires.  <i>Mais tout ce que je veux ...</i> <br></li><li>  Difficulté à s'initialiser.  Supposons que vous souhaitiez lire des histogrammes avec différentes tailles de panier.  Il semblerait que ce soit plus facile - nous indiquerons l'INITCOND souhaité lors de la déclaration de l'agrégat (PostgreSQL) et de l'ensemble de l'entreprise.  Mais alors, pour chaque taille du panier, vous aurez besoin de votre propre agrégat, et pour cela, encore une fois, les droits sont nécessaires. <br><br>  Ici, vous pouvez recourir à une sale astuce et faire glisser le processeur d'union de la ligne d'initialisation (vers l'avant) et des données, construire le contexte non pas dans le constructeur, mais lorsque la première ligne est reçue. <br></li><li>  Néanmoins, même avec les limitations décrites, les agrégats personnalisés vous permettent de calculer n'importe quoi. <br></li><li>  Il est important que les <u>agrégats puissent être parallélisés</u> , au moins PostgreSQL et Oracle (Enterprise Edition) peuvent le faire.  Pour cela, la vérité devra apprendre à sérialiser / désérialiser les états intermédiaires et également les figer reçus de différents flux. </li></ul><br><h4>  Fonctions de fenêtre </h4><br>  Les fonctions de fenêtre sont apparues dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">norme SQL: 2003</a> .  À l'heure actuelle, ils sont pris en charge par tous les systèmes ci-dessus.  En substance, les fonctions de fenêtre sont une extension du travail avec les unités.  Et, bien sûr, les fonctions d'agrégation personnalisées fonctionnent également dans un contexte fenêtré. <br><br>  L'extension est la suivante.  Et avant SQL: 2003, les fonctions d'agrégation fonctionnaient dans une certaine fenêtre, qui était soit l'ensemble des résultats, soit sa partie, correspondant à la combinaison des valeurs de champ de l'expression GROUP BY.  L'utilisateur dispose désormais d'une certaine liberté pour manipuler cette fenêtre. <br><br>  La différence est que les valeurs calculées à l'aide des fenêtres sont ajoutées à la sortie dans une colonne distincte et ne nécessitent pas que le flux entier se réduise à l'aide des fonctions d'agrégation.  Ainsi, dans une demande, vous pouvez utiliser plusieurs agrégats de fenêtres chacun dans son propre contexte (fenêtre).  Il pouvait y avoir plusieurs fonctions agrégées auparavant, mais elles fonctionnaient toutes dans une seule fenêtre. <br><br>  Grands coups <br><br><ul><li>  <b>Plus ()</b> <br>  la fenêtre est l'ensemble des résultats.  Supposons que la requête « <i>select count (1) from Samples</i> » renvoie 169. Dans ce cas, en exécutant « <i>select count (1) over () from Samples</i> », nous obtenons une colonne qui est écrite 169 fois 169 fois. </li><li>  <b>OVER (PARTITION BY)</b> <br>  il s'agit d'un analogue de GROUP BY, pour chaque combinaison de valeurs, une fenêtre est créée dans laquelle des fonctions d'agrégation sont exécutées.  Disons que dans la table Samples, une colonne entière est val, les données sont des nombres de 1 à 169. <br>  Ensuite, la requête « <i>sélectionner le nombre (1) sur (partitionner par (12 + val) / 13) à partir des échantillons</i> » renverra une colonne dans laquelle la valeur 13 est écrite 169 fois. <br></li><li>  <b>PLUS (COMMANDER PAR)</b> <br>  peut être combiné avec PARTITION BY, vous permet de modifier dynamiquement la taille de la fenêtre pendant le curseur, dans ce cas, la fenêtre s'étend du début du groupe à la position actuelle du curseur.  Par conséquent, pour le groupe, il s'avère que ce n'est pas la même valeur dans la colonne agrégée, mais la sienne.  Pratique pour calculer les montants cumulés.  Résultat de la requête <br>  <i>'sélectionner la somme (val) sur (ordre par val) des échantillons</i> ' sera une colonne dans laquelle le nième élément contiendra la somme des nombres naturels de 1 à n. </li><li>  <b>PLUS (RANGS)</b> <br>  vous permet de définir les cadres de fenêtre, à partir de la position du curseur ou du début / fin de la plage ORDER BY. <br><br>  Par exemple, ' <i>... ROWS 1 PRECEDING ...</i> ' signifie que la fenêtre se compose de la ligne actuelle et de 1 avant celle-ci.  A ' <i>... RANGS ENTRE 1 SUIVANT ET 2 SUIVANTS ...</i> ' - la fenêtre se compose de deux lignes immédiatement après le curseur. <br><br>  LIGNE ACTUELLE dans ce mode indique la position actuelle du curseur.  Par exemple, « <i>RANGS ENTRE RANGÉE ACTUELLE ET SANS LIMITE SUIVANTE</i> » signifie de la ligne actuelle jusqu'à la fin de la plage. </li><li>  <b>OVER (RANGE)</b> <br>  diffère de ROWS dans la mesure où CURRENT ROW signifie ici comme début de la fenêtre le début de la plage de ORDER BY, et comme fin de la fenêtre - la dernière ligne de la plage ORDER BY. </li></ul><br>  La syntaxe d'utilisation des fonctions de fenêtre sur différents systèmes est légèrement différente. <br><br>  Pour résumer ce qui précède, il reste un sentiment légèrement douloureux que les développeurs, après avoir analysé la construction de divers rapports en SQL, aient mis en évidence les cas les plus courants et les aient concrétisés dans la syntaxe. <br><br><h4>  Fonctions de retour d'enregistrement </h4><br>  Dans la sortie des fonctions d'agrégation / fenêtre, chaque ligne résultante correspond à une certaine plage de lignes du flux de données entrant.  Dans la vie, une telle correspondance n'existe pas toujours. <br><br>  Par exemple, il est nécessaire de construire une matrice de covariance 10X10 (pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cela,</a> il faudrait 672X672).  Cela <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peut être</a> fait en un seul passage, pour cela nous exécutons la fonction d'agrégation écrite par nous avec 10 paramètres numériques.  Le résultat de son travail est un jeu d'enregistrements de 10 lignes de 10 valeurs, chaque élément de matrice se réfère à toutes les lignes du flux d'entrée (peu importe le nombre). <br><br>  Nous pouvons dire - alors quoi, dans PostgreSQl, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous pouvez</a> retourner un tableau à deux dimensions à partir d'une fonction (Ex: 'ARRAY [[1,2], [3,4]').  Ou sérialisez simplement la matrice en ligne. <br><br>  C'est bien, mais il n'est pas toujours possible de maintenir la taille du résultat dans le cadre acceptable pour cette approche. <br><br><div class="spoiler">  <b class="spoiler_title">Digression lyrique</b> <div class="spoiler_text">  Par exemple, notre tâche consiste à généraliser la géométrie. <br><br>  La taille des géométries nous est inconnue, il peut aussi s'agir du littoral de l'Eurasie à partir de dizaines de millions de points.  Ou vice versa, il y a une géométrie très grossière, vous devez la lisser avec des splines.  Je voudrais passer les paramètres à l'agrégat et obtenir le flux de données au lieu d'un vecteur ou d'une chaîne. <br><br>  Vous pouvez, bien sûr, dire que le problème est tiré par les cheveux, que personne ne le fait, les géométries dans le SGBD sont stockées de manière spéciale, il existe des programmes spéciaux pour le traitement des géométries, ... <br><br>  En fait, il est assez pratique de stocker des géométries dans des tables régulières point par point, ne serait-ce que parce qu'en déplaçant un point, il n'est pas nécessaire de réécrire l'intégralité du blob.  Avant que des données spatiales ne soient divulguées partout dans le SGBD, c'était, par exemple, dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ArcSDE</a> . <br><br>  Dès que la taille moyenne du blob de géométrie dépasse la taille de la page, il devient plus rentable de travailler directement avec des points.  S'il y avait une opportunité physique de fonctionner avec un flux de points, peut-être que la roue de l'histoire tournerait à nouveau. <br></div></div><br>  La matrice de covariance n'est pas encore un très bon exemple de désynchronisation entre les flux d'entrée et de sortie, car le résultat global est obtenu simultanément à la fin.  Supposons que vous souhaitiez traiter / compresser un flux de données source.  En même temps <br><br><ul><li>  il y a beaucoup de données, elles sont dans le «tas» sans index, en fait elles ont été simplement «rapidement» écrites sur le disque </li><li>  vous devez les trier en différentes catégories, qui sont relativement peu nombreuses </li><li>  dans les catégories, moyenne sur des intervalles de temps, stocke uniquement la moyenne, le nombre de mesures et la variance </li><li>  tout cela doit être fait rapidement </li></ul><br>  Quelles sont les options? <br><br><ol><li>  Dans SQL, un tri par intervalle de temps / catégorie est requis, ce qui contredit le dernier point. </li><li>  Si les données sont déjà triées par heure (ce qui, en fait, n'est pas garanti), et qu'il sera possible de transmettre ce fait au processeur SQL, vous pouvez le faire avec des fonctions de fenêtre et un passage. </li><li>  Écrivez une application distincte qui fera tout cela.  En PL / SQL ou, plus probablement, étant donné qu'il y a beaucoup de données, en C / C ++. </li><li>  Fonctions qui renvoient des enregistrements.  Ils peuvent peut-être nous aider. </li></ol><br>  Plus de détails sur A.4.  Il existe deux mécanismes pour cela: les tables temporaires et les fonctions de pipeline. <br><br><ol><li>  Fonctions de convoyeur. <br>  Ce mécanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est apparu</a> dans Oracle (à partir du 9i, 2001) et permet à la fonction qui a renvoyé le jeu d'enregistrements de ne pas accumuler de données, mais de les calculer au besoin (par analogie avec la synchronisation de stdout et stdin de deux processus connectés via pipe). <br>  C'est-à-dire  Les résultats des fonctions en pipeline peuvent commencer à être traités avant de quitter cette fonction.  Pour cela, il suffit de dire dans la fonction <br><br><pre> <code class="sql hljs"> FUNCTION f_trans(p refcur_t) RETURN outrecset PIPELINED IS …</code> </pre> <br>  et enregistrer les lignes de résultats dans le corps <br><br><pre> <code class="sql hljs">LOOP … out_rec.var_char1 := in_rec.email; out_rec.var_char2 := in_rec.phone_number; PIPE ROW(out_rec); … <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>;</code> </pre> <br>  En conséquence, nous avons <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>( refcur_pkg.f_trans( <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> department_id = <span class="hljs-number"><span class="hljs-number">60</span></span>)));</code> </pre><br>  Les agrégats personnalisés ne sont tout simplement pas nécessaires lorsqu'il existe des fonctions de pipeline. <br><br>  Bravo, Oracle! <br><br>  Il n'y a pas si longtemps (2014), les fonctions de pipeline sont également <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">apparues</a> dans DB2 (IBM i 7.1 TR9, i 7.2 TR1). </li><li>  Tables temporaires. <br>  Pour commencer, il semble que ni MS SQL ni PostgreSQL ne peuvent retourner un curseur à partir d'une fonction d'agrégation. <br><br>  Eh bien, par analogie avec les fonctions du pipeline, obtenons le curseur en tant que paramètre, le traitons, l'ajoutons à une table temporaire et y retournons le curseur. <br><br>  Cependant, dans MS SQL, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il n'est pas possible</a> de passer le curseur à une procédure stockée par un paramètre, il est uniquement possible de créer un curseur dans la procédure et de renvoyer le paramètre via la sortie.  La même chose peut être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dite pour</a> PostgreSQL. <br><br>  Eh bien, il suffit d'ouvrir le curseur, de le soustraire, de traiter les valeurs, de calculer le résultat, de l'ajouter à la table temporaire et de rendre le curseur. <br><br>  Ou encore plus simple, nous ajoutons les résultats de la requête à une table temporaire, les traitons et renvoyons les résultats via le curseur à une autre table temporaire. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Que</a> puis-je dire.  Tout d'abord et surtout, la lecture des données via le curseur est plus lente que le traitement dans le flux.  Deuxièmement, pourquoi avez-vous besoin d'un processeur SQL, lisons des tables avec des curseurs, créons des tables temporaires avec nos mains, écrivons la logique de jointure en boucles ... C'est comme des insertions d'assembleur en C / C ++, parfois vous pouvez vous faire plaisir, mais il vaut mieux ne pas en abuser. </li></ol><br>  Ainsi, après avoir examiné une question avec des fonctions renvoyant un jeu d'enregistrements, nous arrivons à des conclusions: <br><br><ul><li>  Les agrégats personnalisés ne nous seront pas vraiment utiles ici. </li><li>  Dans tous les cas, vous devrez créer des objets dans la base de données.  Que ce soit des fonctions ou des tables temporaires.  Au minimum, des droits appropriés sont requis.  <i>Et je veux juste traiter quelques chiffres.</i> <br></li><li>  Néanmoins, même avec les limitations décrites, il n'est parfois pas très élégant, mais avec cette méthode, vous pouvez résoudre le problème. </li></ul><br><h4>  Quoi d'autre </h4><br>  En fait, si nous avons déjà la possibilité de résoudre des problèmes, de quoi d'autre l'auteur a-t-il besoin? <br>  En fait, la machine de Turing peut également calculer n'importe quoi, ce n'est pas très rapide et pas trop pratique. <br><br>  Nous formulons les exigences comme suit: <br><br><ol><li>  ce doit être un opérateur relationnel utilisable au même titre que le reste (sélection, projection, ...) </li><li>  ce doit être un opérateur qui transforme un flux de données en un autre </li><li>  il n'y a pas de synchronisation entre les flux d'entrée et de sortie </li><li>  La déclaration de l'opérateur définit la structure du flux de sortie </li><li>  l'opérateur a la capacité d'initialiser dynamiquement (sous la forme d'une fonction, plus précisément son corps, spécifié directement dans la définition de l'opérateur) </li><li>  ainsi qu'un destructeur sous forme de fonction (...) </li><li>  ainsi qu'une fonction (...) qui est appelée à chaque fois qu'une nouvelle ligne est reçue du flux d'entrée </li><li>  l'opérateur a un contexte d'exécution - un ensemble de variables et / ou de collections définies par l'utilisateur qui sont nécessaires pour le travail </li><li>  pour exécuter cette instruction, vous n'avez pas besoin de créer d'objets de base de données, vous n'avez pas besoin de droits supplémentaires </li><li>  tout ce qui est nécessaire au travail est défini en un seul endroit, dans une seule langue </li></ol><br>  Il était une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fois, l'</a> auteur a fait un tel opérateur qui étend le processeur self-made du sous-ensemble implémenté de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TTM / Tutorial D.</a>  Maintenant, la même idée est proposée pour SQL. <br><br>  Cela vaut la peine d'être averti, ici SQL se termine et l'improvisation commence.  La syntaxe est laissée telle qu'elle était dans l'original, au final, le sucre syntaxique peut être n'importe quoi, il ne change pas l'essence. <br><br>  Ainsi, l'opérateur de <b>mastication se</b> compose de <br><br><ol><li>  Un en-tête qui contient une liste des champs de sortie et leurs types. <br>  Chaque champ de sortie (et d'entrée) est une variable locale. <br>  Ex: <i>"chew {" var1 "float," var2 "integer}"</i> signifie qu'il y aura deux colonnes dans le flux de sortie - un point flottant et un entier </li><li>  Corps - une liste de rappels pour les événements, pour le moment - le début du flux, la fin du flux, la ligne.  Par syntaxe, les fonctions sont proches de PL / SQL.  La fonction prédéfinie <i>__interrupt</i> () est un analogue de PIPE, elle prend les valeurs des variables correspondant aux colonnes de sortie et les place dans le flux de sortie.  Si la mémoire tampon du flux de sortie déborde, le travail du gestionnaire s'arrête et le travail du côté récepteur du flux commence. <br>  Ex: "hook" init "{var1: = 0;  var2: = -1;  } " </li></ol><br>  La façon la plus simple de montrer des exemples. <br><br><ul><li>  Un analogue de la fonction d'agrégation SUM. <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val) from samples' -- select * from samples chew {“sum(val)” float} --    hook “init” { “sum(val)” := 0; --      } hook “row” { if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; end if; } hook “finit” { call __interrupt(); --  PIPE }</span></span></code> </pre><br>  Il semble volumineux, mais ce n'est qu'un exemple, <br>  il n'est pas nécessaire d'écrire un programme C pour ajouter quelques chiffres. </li><li>  SUM + AVG <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val), avg(val) from samples' -- select * from samples chew { “sum(val)” float, “avg(val)” float --       } hook “init” { “sum(val)” := 0; “avg(val)” := 0; var num integer; num := 0; --    ,       } hook “row” { if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; num := num + 1; end if; } hook “finit” { if (num &gt; 0) then “avg(val)” := “sum(val)” / num; end if; call __interrupt(); }</span></span></code> </pre><br>  Ici, nous attirons l'attention sur le fait que la sommation ne se produit qu'une seule fois. </li><li>  SUM + GROUP BY <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val) from samples group by type' -- select * from --     ( samples val, type from samples order by type ) chew { “sum(val)” float } hook “init” { “sum(val)” := 0; var gtype integer; gtype := NULL; var num integer; --   num := 0; } hook “row” { if (gtype &lt;&gt; “type”) then __interrupt(); “gtype” := type; "sum(val)" := 0; num := 0; end if; if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; num := num + 1; end if; } hook “finit” { if (num &gt; 0) then call __interrupt(); end if; }</span></span></code> </pre></li><li>  ROW_NUMBER () OVER () <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- select row_number() over() as num, * from samples -- select * from samples chew { “num” integer, * --        --   '* except val1, ...valX',   TTM } hook “init” { num := 0; } hook “row” { num := num + 1; call __interrupt(); }</span></span></code> </pre></li></ul><br>  Est-il possible de proposer un exemple sur lequel cette approche donne des résultats fondamentalement inaccessibles de la manière habituelle?  Nous les avons. <br><br>  Parfois, il arrive que les données soient presque triées.  Ils peuvent même être complètement triés, mais ce n'est pas sûr. <br><br>     (  )             .  C'est-à-dire        T1            T2   T1 &lt; T2. <br><br>    ,    T1  T2     () ,    ( )  . <br><br> ,   ,             ,        ,         . <br><br>     . <br><br>   ,    . <br><br>      . <br><br>       ,       . <br>        ,   . <br><br>    SQL-           . <br><br>   lambda-     SQL-   ,     ,    . <br><br><h4>  Conclusion </h4><br>        . <br><br>       PL/SQL. <br><br>             . <br><br>   ,         , GROUP BY. <br><br> ,      ,    SQL-   . <br><br>   ,  ,                . <br><br> <b>PS:</b>        . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435120/">https://habr.com/ru/post/fr435120/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435106/index.html">Encore une fois à propos de passport.js</a></li>
<li><a href="../fr435108/index.html">Utilisation de Prolog</a></li>
<li><a href="../fr435112/index.html">Entretien d'entreprise</a></li>
<li><a href="../fr435114/index.html">Spring data jpa</a></li>
<li><a href="../fr435118/index.html">Save File Me - un service de sauvegarde gratuit avec chiffrement côté client</a></li>
<li><a href="../fr435122/index.html">Comment la flamme a été implémentée dans Doom sur la Playstation</a></li>
<li><a href="../fr435124/index.html">Chefs-d'œuvre de la construction de colonnes du monde: un moniteur-transformateur de studio avec un nombre variable de bandes</a></li>
<li><a href="../fr435126/index.html">Expérience dans l'organisation et la tenue de conférences d'entreprise pour les analystes</a></li>
<li><a href="../fr435128/index.html">Pi-Sonos: un passe-temps incontrôlable</a></li>
<li><a href="../fr435132/index.html">Nomade: problèmes et solutions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>