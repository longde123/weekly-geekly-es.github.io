<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤ŸğŸ¾ ğŸš£ğŸ¼ ğŸš• Kami menampilkan konten pada gambar yang dikenali berdasarkan aturan tertentu ğŸ§‘ğŸ¿â€ğŸ¤â€ğŸ§‘ğŸ¾ ğŸ‘œ ğŸ”®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terkadang, ketika Anda membaca tugas teknis dan menetapkan tenggat waktu untuk implementasi, meremehkan jumlah waktu dan upaya yang dihabiskan untuk m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menampilkan konten pada gambar yang dikenali berdasarkan aturan tertentu</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454452/"><p>  Terkadang, ketika Anda membaca tugas teknis dan menetapkan tenggat waktu untuk implementasi, meremehkan jumlah waktu dan upaya yang dihabiskan untuk memecahkan masalah tertentu.  Itu terjadi bahwa suatu titik, yang diperkirakan oleh waktu per minggu, dilakukan pada satu jam, dan kadang-kadang sebaliknya.  Tetapi artikel ini bukan tentang itu.  Ini adalah demonstrasi evolusi solusi untuk suatu masalah.  Dari sejak awal hingga implementasi. </p><br><p><img src="https://habrastorage.org/webt/qh/ns/i7/qhnsi7xrjjlbxp7ob1rqgsmpo9o.jpeg"></p><a name="habracut"></a><br><h1 id="ispolzuemye-terminy">  Ketentuan yang Digunakan </h1><br><ul><li><p>  Tandai atau spidol - gambar yang dimuat ke mesin AR, yang dikenali oleh kamera perangkat (tablet atau smartphone) dan dapat diidentifikasi secara unik </p><br></li><li><p>  Ditemukan - status penanda ketika terdeteksi di bidang tampilan kamera </p><br></li><li><p>  Lost - status marker saat hilang dari tampilan kamera </p><br></li><li><p>  Itu dapat ditampilkan - ketika marker ditemukan, kami menampilkan konten yang dilampirkan pada marker </p><br></li><li><p>  Tidak dapat ditampilkan - ketika kami menemukan marker, jangan tampilkan konten - Konten yang melekat pada marker - objek apa pun (model 3D, sprite, sistem partikel, dll.) Yang dapat dilampirkan pada marker dan, yang, karenanya, akan ditampilkan di layar jika marker ditemukan </p><br></li><li><p>  Mark, marker, found, lost - status dasar yang melekat pada semua engine yang menyediakan fungsionalitas pengenalan </p><br></li><li><p>  Itu dapat ditampilkan dan tidak dapat ditampilkan - negara yang digunakan untuk memecahkan masalah ini </p><br><p>  <strong>Contoh:</strong> </p><br><ul><li>  Unduh aplikasi =&gt; semua merek yang diunduh dapat dikenali </li><li>  Kami mencoba mengenali =&gt; keadaan penanda berubah menjadi "ditemukan" </li><li>  Jika marker dapat ditampilkan =&gt; nyatakan marker "ditemukan" dan kami menampilkan model yang terpasang pada marker </li><li>  Jika penanda tidak dapat ditampilkan =&gt; keadaan penanda "ditemukan", tetapi model yang terpasang tidak ditampilkan </li><li>  Merek menghilang dari bidang pandang kamera =&gt; kami mengubah status menjadi "hilang" </li></ul><br></li></ul><br><h1 id="vvedenie">  Pendahuluan </h1><br><p>  Ada satu kartu pos besar ukuran lembar A4.  Ini dibagi menjadi 4 bagian yang sama (format satu bagian A5), pada masing-masing bagian ini ada: </p><br><ul><li>  Satu tanda sudut penuh (1) </li><li>  Setengah dari tanda sisi bawah (5) </li><li>  Setengah dari tanda sisi atas (8) </li><li>  Markus Pusat Quarter (9) </li></ul><br><p><img src="https://habrastorage.org/webt/_k/87/c4/_k87c4c_mahdxfrbsijiidjauro.jpeg" alt="gambar"></p><br><p> Jika Anda bekerja dengan mesin pengenalan, misalnya, Vuforia, maka Anda mungkin tahu bahwa tidak ada yang namanya "kualitas pengenalan".  Tanda itu dikenali atau tidak dikenali.  Dengan demikian, jika mesin "melihat" merek, itu mengubah negara untuk <code>Find</code> dan metode <code>OnSuccess()</code> , jika "hilang" itu, keadaan berubah menjadi <code>Lost</code> dan metode <code>OnLost()</code> .  Dengan demikian, dari kondisi yang ada dan input data, suatu situasi muncul ketika memiliki bagian dari kartu (setengah atau seperempat) adalah mungkin untuk mengenali merek. </p><br><p>  Masalahnya adalah bahwa sesuai dengan tugas teknis, pembukaan karakter secara bertahap direncanakan.  Dalam situasi ini, membuka secara bertahap adalah mungkin, tetapi mengingat bahwa tidak ada orang yang mencoba mengenali seperempat atau setengah dari merek. </p><br><h1 id="formulirovka-zadachi">  Pernyataan tugas </h1><br><p>  Penting untuk menerapkan logika dalam bentuk kode program, yang memastikan pembukaan konten secara bertahap yang dilampirkan pada marker.  Dari lokasi elemen pada kartu diketahui bahwa marker 1, 2, 3, 4 tersedia untuk ditampilkan pada awalnya. </p><br><p><img src="https://habrastorage.org/webt/r_/a4/1-/r_a41-b9ezh2oxrcejsffh-ifus.jpeg" alt="gambar"></p><br><p>  Jika konten telah dibaca dan ditampilkan pada 2 marker, misalnya, 2 dan 3, maka kami mengizinkan menampilkan konten pada marker 6. Jika marker 1 belum dibaca, maka akses ke marker 5 ditutup.  Selanjutnya dengan analogi.  Kami agak memberikan izin untuk menampilkan konten di penanda sisi hanya ketika kami telah membaca penanda sudut yang berdekatan. </p><br><p><img src="https://habrastorage.org/webt/ux/qs/xu/uxqsxuydrxzijfakmcumpguqkg8.jpeg" alt="gambar"></p><br><p>  Jika marker dari 1 hingga 8 tersedia dan ditemukan, maka buka konten pada marker 9 untuk tampilan. Setiap marker memiliki 2 status - konten tersedia dan tidak tersedia untuk tampilan, yang bertanggung jawab pada bidang isian <code>public bool IsActive;</code> </p><br><p>  Segera jelas bahwa ini harus berupa mesin negara dengan transisi antar negara, atau penerapan pola "Negara". </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  Hasilnya bukan satu, bukan yang lain.  Saya tidak bisa mengatakan bahwa ini adalah penopang karena solusi sepenuhnya memenuhi persyaratan di awal artikel.  Tapi Anda bisa berdebat dengan saya. </p></div></div><br><p>  Mengenai hal ini, saya memberi Anda kesempatan untuk berpikir sedikit tentang solusi yang mungkin dan implementasi dari tugas ini.  Butuh sekitar 5 jam untuk menyadari dan memperbaiki di kepala saya gambar keputusan. </p><br><p>  Untuk kejelasan, saya merekam video di mana hasil akhir dari algoritma (jika Anda bisa menyebutnya begitu) sudah ditangkap. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZcXxVQG2Rgk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1 id="podhody-k-resheniyu">  Pendekatan Solusi </h1><br><h2 id="1-ot-uglovyh-markerov-k-centralnomu">  1. Dari penanda sudut ke tengah </h2><br><p>  Hal pertama yang terlintas dalam pikiran adalah untuk menyajikan interaksi antara penanda dari sudut ke tengah.  Dalam bentuk grafis, tampilannya seperti ini: </p><br><p><img src="https://habrastorage.org/webt/0u/0j/re/0u0jrellt_78kezlvsgr7poeex0.jpeg" alt="gambar"></p><br><p>  Masalahnya: </p><br><ol><li>  Bagaimana cara menentukan label sisi yang akan diubah statusnya?  Yang di sebelah kiri atau di kanan?  Kami juga memaksa setiap penanda untuk "tahu" tentang keberadaan yang sentral. </li><li>  Penting untuk menambahkan dependensi yang tidak jelas dari kategori: penanda sisi berlangganan acara penanda sudut IsChangedEventCallback (), tindakan serupa harus dilakukan untuk penanda pusat. </li><li>  Jika kita menganggap setiap jenis penanda sebagai entitas, maka dalam hierarki entitas ini kita akan meneruskan perintah perubahan-negara dari bawah ke atas.  Ini tidak terlalu baik, karena kita mengikat diri kita sendiri dengan angka, dalam hal ini, penanda sudut, kehilangan kemampuan untuk mengukur. </li></ol><br><p>  Tidak dapat menempatkan solusi di atas ke kepala saya karena banyaknya kasus tepi dan kompleksitas persepsi, saya mengubah pendekatan untuk memilih penanda di mana dependensi mulai menyebar. </p><br><h2 id="2-bokovye-znayut-o-centralnom-i-uglovyh">  2. Lateral tahu tentang pusat dan sudut </h2><br><p>  Memikirkan solusi paragraf 3 dari pendekatan sebelumnya, muncul ide untuk mengubah jenis penanda, dari mana keadaan penanda lainnya mulai berubah.  Sebagai penanda sisi utama diambil.  Dalam skenario ini, komunikasi (dependensi) terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/t3/vz/3q/t3vz3qmk-wnhvwdbpgcdgemuciu.jpeg" alt="gambar"></p><br><p>  Dari sini segera menjadi jelas bahwa koneksi dari lateral ke pusat berlebihan, karena penanda lateral tidak perlu tahu apa-apa tentang penanda pusat, oleh karena itu pendekatan ini segera ditransformasikan menjadi yang terakhir. </p><br><h2 id="3-centralnyy-znaet-o-vseh-bokovye-znayut-o-uglovyh">  3. Yang pusat tahu tentang semua orang, yang di samping tahu tentang sudut </h2><br><p><img src="https://habrastorage.org/webt/24/y_/hm/24y_hmm09x-karjrpyddxkh6gqy.jpeg" alt="gambar"></p><br><p>  Solusi terakhir adalah ketika penanda samping tahu tentang sudut-sudut, sudut-sudut "menjalani hidup mereka", dan yang sentral tahu tentang keadaan semua penanda. </p><br><p><img src="https://habrastorage.org/webt/no/ls/fl/nolsflwoafqlnjbnanb9illn2wi.jpeg" alt="gambar"></p><br><p>  Bekerja dengan tampilan kartu pos sangat tidak nyaman.  Hubungan antara entitas tidak terlihat cukup jelas untuk dengan mudah mengubahnya menjadi kode.  Upaya untuk menafsirkan dalam bentuk pohon biner dapat menimbulkan beberapa ambiguitas.  Tapi di sini salah satu properti dari pohon biner dilanggar, sehingga ambiguitasnya segera menghilang.  Dari mana kita dapat menyimpulkan bahwa representasi ini dapat ditafsirkan secara jelas dan digunakan untuk secara grafis mewakili solusi untuk masalah tersebut.  Berdasarkan kesimpulan ini, kami akan menggunakan notasi grafik, yaitu: </p><br><ul><li>  Angle Marker - Angle Node (level 3) </li><li>  Penanda Sisi - Node Samping (level 2) </li><li>  Center Marker - Center Node (level 1) </li></ul><br><p>  Keuntungan: </p><br><ol><li>  Ketergantungan antara penanda jelas dan jelas. </li><li>  Setiap level dapat direpresentasikan dalam bentuk 3 entitas, yang masing-masing terdiri dari bagian-bagian dasar, tetapi dengan tambahannya yang melekat pada masing-masing level </li><li>  Untuk memperluas, Anda hanya perlu menambahkan tipe node baru dengan karakteristiknya sendiri </li><li>  Solusi ini mudah dibayangkan dalam gaya OO (berorientasi objek) </li></ol><br><h1 id="realizaciya">  Implementasi </h1><br><h2 id="bazovye-suschnosti">  Entitas dasar </h2><br><p>  Mari kita membuat antarmuka yang berisi elemen-elemen yang melekat dalam setiap entitas (nama, negara): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p>  Selanjutnya, kami menjelaskan esensi dari setiap node: </p><br><ul><li>  <strong>CornerNode</strong> - simpul sudut.  Cukup terapkan antarmuka <code>INode</code> : </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CornerNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Mengapa <code>IsActive = true</code> ? </p><br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text"><p>  Dari kondisi masalah, konten penanda sudut pada awalnya tersedia untuk pengakuan. </p></div></div><br><ul><li>  <strong>SideNode</strong> - simpul samping.  Kami mengimplementasikan antarmuka <code>LeftCornerNode</code> , tetapi menambahkan bidang <code>LeftCornerNode</code> dan <code>RightCornerNode</code> .  Dengan demikian, node samping mempertahankan keadaannya sendiri dan hanya tahu tentang keberadaan node samping. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SideNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CornerNode LeftCornerNode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CornerNode RightCornerNode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SideNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, CornerNode leftNode, CornerNode rightNode</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; LeftCornerNode = leftNode; RightCornerNode = rightNode; } }</code> </pre> <br><ul><li>  <strong>CenterNode</strong> adalah simpul pusat.  Seperti pada yang sebelumnya, kami menerapkan <code>INode</code> .  Tambahkan bidang tipe <code>List&lt;INode&gt;</code> . </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CentralNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;INode&gt; NodesOnCard; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CentralNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h2 id="klass-opencard">  Kelas pembuka </h2><br><h3 id="privatnye-metody-i-polya">  Metode dan bidang pribadi </h3><br><p>  Sekarang kita telah menciptakan semua elemen kartu yang telah kita buat (semua jenis marker), kita dapat mulai menggambarkan esensi kartu itu sendiri.  Saya tidak terbiasa memulai kelas dengan konstruktor.  Saya selalu mulai dengan metode dasar yang melekat pada entitas tertentu.  Mari kita mulai dengan bidang pribadi dan metode pribadi. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;CornerNode&gt; cornerNodes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;SideNode&gt; sideNodes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CentralNode centralNode;</code> </pre> <br><p>  Dengan bidang, semuanya cukup sederhana.  2 daftar dengan sudut, simpul samping dan satu bidang simpul pusat. </p><br><p>  Selanjutnya Anda perlu mengklarifikasi sedikit.  Faktanya adalah bahwa penanda itu sendiri adalah tipe <code>Trackable</code> dan tidak memiliki gagasan (dan tidak seharusnya) bahwa itu adalah bagian dari beberapa logika lain di sana.  Karena itu, yang bisa kita gunakan untuk mengontrol tampilan adalah namanya.  Dengan demikian, jika marker itu sendiri tidak menyimpan tipe node yang menjadi miliknya, maka kita harus mentransfer tanggung jawab ini ke kelas <code>OpenCard</code> kita.  Berdasarkan ini, pertama-tama kami menggambarkan 3 metode pribadi yang bertanggung jawab untuk menentukan jenis node. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCentralNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name == centralNode.Name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSideNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sideNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sideNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCornerNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cornerNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sideNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Tetapi metode ini tidak masuk akal untuk digunakan secara langsung.  Tidak nyaman untuk beroperasi dengan nilai-nilai Boolean ketika Anda bekerja dengan objek dari level abstraksi lain.  Oleh karena itu, kita akan membuat <code>enum NodeType</code> sederhana dan metode pribadi <code>GetNodeType()</code> , yang merangkum sendiri semua logika yang terkait dengan menentukan jenis node. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> NodeType { CornerNode, SideNode, CentralNode } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NodeType? GetNodeType(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCentralNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.CentralNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsSideNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.SideNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCornerNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.CornerNode; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><h3 id="publichnye-metody">  Metode publik </h3><br><ul><li>  <code>IsExist</code> adalah metode yang mengembalikan nilai boolean yang menunjukkan apakah merek kami milik kartu pos.  Ini adalah metode bantu, yang dilakukan sehingga jika penanda bukan milik kartu apa pun, kami dapat menampilkan konten di dalamnya. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsExist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> centralNode.NodesOnCard) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centralNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><ul><li>  <code>CheckOnActiveAndChangeStatus</code> - metode (seperti namanya) di mana kami memeriksa keadaan saat ini dari simpul dan mengubah statusnya. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckOnActiveAndChangeStatus</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (GetNodeType(name)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.CornerNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cornerNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.SideNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sideNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.LeftCornerNode.IsActive &amp;&amp; node.RightCornerNode.IsActive) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.CentralNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> centralNode.NodesOnCard) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node.IsActive) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> centralNode.IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h3 id="konstruktor">  Konstruktor </h3><br><p>  Ketika semua kartu ada di atas meja, kita akhirnya bisa pergi ke konstruktor.  Mungkin ada beberapa pendekatan untuk inisialisasi.  Tapi saya memutuskan untuk menghilangkan gerakan yang tidak perlu dari kelas <code>OpenCard</code> .  Itu harus menjawab dengan kami apakah konten tersedia untuk ditampilkan atau tidak.  Oleh karena itu, kami hanya meminta daftar input node dari 2 jenis dan node pusat. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenCard</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;CornerNode&gt; listCornerNode, List&lt;SideNode&gt; listSideNode, CentralNode centralNode</span></span></span><span class="hljs-function">)</span></span> { CornerNodes = listCornerNode; SideNodes = listSideNode; CentralNodes = centralNode; CentralNodes.NodesOnCard = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;INode&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CornerNodes) CentralNodes.NodesOnCard.Add(node); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SideNodes) CentralNodes.NodesOnCard.Add(node); }</code> </pre> <br><p>  Perhatikan bahwa karena simpul pusat hanya perlu memeriksa kondisi bahwa semua simpul <code>true</code> lainnya, itu cukup bagi kita untuk secara implisit <code>INode</code> simpul miring dan sentral yang masuk ke konstruktor ke tipe <code>INode</code> . </p><br><h3 id="inicializaciya">  Inisialisasi </h3><br><p>  Apa cara paling nyaman untuk membuat objek yang tidak perlu dilampirkan (seperti komponen <code>MonoBehaviour</code> ) ke GameObject?  - Benar, <code>ScriptableObject</code> .  Juga, untuk kenyamanan, tambahkan atribut <code>MenuItem</code> , yang akan menyederhanakan pembuatan kartu baru. </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CreateAssetMenu(fileName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Open Card"</span></span></span><span class="hljs-meta">, menuName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"New Open Card"</span></span></span><span class="hljs-meta">, order = 51)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OpenCardScriptableObject</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftDownName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightDownName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightUpName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftUpName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> downSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> upSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> centralName; }</code> </pre> <br><p>  Akor terakhir dalam komposisi kami akan menjadi bagian melalui array yang ditambahkan (jika ada) <code>ScriptableObject</code> dan pembuatan kartu pos dari mereka.  Setelah itu, tetap bagi kami dalam metode <code>Update</code> untuk cukup memeriksa apakah kami dapat menampilkan konten atau tidak. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OpenCardScriptableObject[] openCards; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;OpenCard&gt; _cardList; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (openCards.Length != <span class="hljs-number"><span class="hljs-number">0</span></span>) { _cardList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;OpenCard&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> card <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> openCards) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftDown = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.leftDownName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightDown = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.rightDownName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.rightUpName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.leftUpName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.leftSideName, leftUp, leftDown); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> downSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.downSideName, leftDown, rightDown); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.rightSideName, rightDown, rightUp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> upSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.upSideName, rightUp, leftUp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> central = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CentralNode(card.centralName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;CornerNode&gt;() {leftDown, rightDown, rightUp, leftUp}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;SideNode&gt;() {leftSide, downSide, rightSide, upSide}; _cardList.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OpenCard(nodes, sideNodes, central)); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isNotPartCard = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> card <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _cardList) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.IsExist(trackableName)) isNotPartCard = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.CheckOnActiveAndChangeStatus(trackableName)) imageTrackablesMap[trackableName].OnTrackSuccess(trackable); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isNotPartCard) imageTrackablesMap[trackableName].OnTrackSuccess(trackable); } }</code> </pre> <br><h1 id="vyvody">  Kesimpulan </h1><br><p>  Bagi saya pribadi, kesimpulannya adalah sebagai berikut: </p><br><ol><li>  Saat mencoba menyelesaikan masalah, Anda perlu mencoba memecah unsur-unsurnya menjadi bagian-bagian atom.  Lebih lanjut, dengan mempertimbangkan semua opsi yang memungkinkan untuk interaksi antara bagian-bagian atom ini, Anda harus mulai dengan objek, dari mana lebih banyak koneksi akan berpotensi datang.  Dengan cara lain, dapat dirumuskan sebagai: berusaha untuk mulai menyelesaikan masalah dengan elemen yang, berpotensi, akan kurang dapat diandalkan </li><li>  Jika memungkinkan, Anda harus mencoba menyajikan data sumber dalam bentuk yang berbeda.  Dalam kasus saya, representasi grafik sangat membantu saya. </li><li>  Setiap entitas dipisahkan dari yang lain dengan jumlah koneksi yang berpotensi berasal dari itu. </li><li>  Banyak tugas terapan yang lebih biasa diselesaikan dengan menulis suatu algoritma dapat diwakili dalam gaya OO </li><li>  Solusi yang memiliki dependensi dering adalah solusi yang buruk </li><li>  Jika sulit untuk menjaga semua koneksi antara objek di kepala Anda, ini adalah keputusan yang buruk </li><li>  Jika Anda tidak dapat mengingat logika interaksi objek - ini adalah keputusan yang buruk </li><li>  Kruk Anda tidak selalu merupakan keputusan yang buruk </li></ol><br><p>  Apakah Anda tahu solusi lain?  - Tulis di komentar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454452/">https://habr.com/ru/post/id454452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454440/index.html">Petty Little Fun # 2: Starlette</a></li>
<li><a href="../id454442/index.html">Cara memilih jaringan proxy untuk bisnis Anda: 3 tips praktis</a></li>
<li><a href="../id454444/index.html">Kami memuat profil Habr atau bagaimana 189 permintaan pada halaman memberikan pengaruh</a></li>
<li><a href="../id454446/index.html">Apa yang baru di C # 8?</a></li>
<li><a href="../id454450/index.html">Bagaimana Edison menemukan nirkabel dan tidak mengerti apa-apa</a></li>
<li><a href="../id454456/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 7. FAQ</a></li>
<li><a href="../id454458/index.html">Pengujian metamorf: mengapa hampir tidak ada yang tahu tentang teknik yang menjanjikan ini</a></li>
<li><a href="../id454460/index.html">Intisari materi menarik untuk pengembang ponsel # 300 (27 Mei - 2 Juni)</a></li>
<li><a href="../id454462/index.html">Fotogram tanpa kertas foto</a></li>
<li><a href="../id454464/index.html">Pengembangan tes visual berdasarkan Gemini dan Storybook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>