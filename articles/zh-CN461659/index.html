<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏿 👩‍🔬 👩🏽‍💻 神经网络和深度学习，第4章：神经网络可以计算任何函数的视觉证明 ◼️ 👩🏻‍💻 ☺️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本章中，我对普遍性定理进行简单且主要是直观的解释。 要遵循本章中的内容，您不必阅读以前的内容。 它是一篇独立的论文。 如果您对NS有最基本的了解，则应该能够理解其中的解释。 

 目录内容 

- 第1章：使用神经网络识别手写数字 
- 第2章：反向传播算法如何工作 
- 第三章 第1部分：改进训...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>神经网络和深度学习，第4章：神经网络可以计算任何函数的视觉证明</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461659/"> 在本章中，我对普遍性定理进行简单且主要是直观的解释。 要遵循本章中的内容，您不必阅读以前的内容。 它是一篇独立的论文。 如果您对NS有最基本的了解，则应该能够理解其中的解释。 <br><br><div class="spoiler">  <b class="spoiler_title">目录内容</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1章：使用神经网络识别手写数字</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2章：反向传播算法如何工作</a> </li><li> 第三章 <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分：改进训练神经网络的方法</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分：为什么进行正则化有助于减少再培训？</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分：如何选择神经网络超参数？</a> <br></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4章：视觉证明神经网络能够计算任何函数</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5章：为什么深度神经网络这么难训练？</a> </li><li> 第6章 <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分：深度学习</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分：图像识别的最新进展</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">后记：有没有简单的算法可以创造情报？</a> </li></ul></div></div><br> 关于神经网络最令人惊奇的事实之一是，它们可以计算出任何函数。 也就是说，假设有人给您某种复杂的缠绕函数f（x）： <br><br><img src="https://habrastorage.org/webt/yi/ot/sl/yiotslaplbwh6savahfpzfwdyum.png"><br><a name="habracut"></a><br> 并且不管该函数如何，都保证了这样一个神经网络，对于任何输入x，值f（x）（或近似于它的近似值）将是该网络的输出，即： <br><br><img src="https://habrastorage.org/webt/eb/ud/zc/ebudzc72xyiytdvkf4ulx-u7onq.png"><br><br> 即使它是许多变量f = f（x <sub>1</sub> ，...，x <sub>m</sub> ）且具有许多值的函数，也可以使用。 例如，下面是一个网络，该函数使用m = 3个输入和n = 2个输出计算一个函数： <br><br><img src="https://habrastorage.org/webt/1g/01/i7/1g01i7vpnwo-mlm1r2brhd9al9m.png"><br><br> 这个结果表明神经网络具有一定的普遍性。 无论我们要计算什么函数，我们都知道有一个神经网络可以做到这一点。 <br><br> 此外，即使我们将网络限制为传入和传出神经元之间的单个层，也存在普遍性定理-所谓的 在一个隐藏层中。 因此，即使是具有非常简单的体系结构的网络也可以非常强大。 <br><br> 普遍性定理是使用神经网络的人们所熟知的。 但是，尽管是这样，但对这一事实的理解并不那么广泛。 而且大多数对此的解释在技术上都太复杂了。 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最早</a>证明这一结果的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">论文之一是</a>使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hahn-Banach定理</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Riesz表示</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">定理</a>和一些傅立叶分析。 如果您是数学家，那么您很容易理解这一证据，但对于大多数人而言，却并非如此。 遗憾的是，普遍性的基本原因是简单而美丽。 <br><br> 在本章中，我对普遍性定理进行简单且主要是直观的解释。 我们将逐步研究其基础思想。 您将了解为什么神经网络真正可以计算任何函数。 您将了解此结果的某些局限性。 您将了解结果如何与深层NS相关联。 <br><br> 要遵循本章中的内容，您不必阅读以前的内容。 它是一篇独立的论文。 如果您对NS有最基本的了解，则应该能够理解其中的解释。 但是我有时会提供到以前材料的链接，以帮助填补知识空白。 <br><br> 普遍性定理经常出现在计算机科学中，因此有时我们甚至会忘记它们的惊人性。 但是，值得提醒自己的一点是：计算任意函数的能力确实很棒。 您可以想象的几乎所有过程都可以简化为计算函数。 考虑根据简短的段落查找音乐作品名称的任务。 这可以视为函数计算。 或者考虑将中文文本翻译成英文的任务。 这可以被认为是函数计算（实际上，有许多函数，因为有很多可接受的选项可以翻译单个文本）。 或考虑基于mp4文件生成电影情节描述和表演质量的任务。 这也可以视为某个函数的计算（此处有关文本翻译选项的说明也是正确的）。 普遍性意味着，原则上，NS可以执行所有这些任务以及许多其他任务。 <br><br> 当然，仅从我们知道存在能够将中文翻译成英语的NS的事实出发，并不意味着我们拥有创建或识别这种网络的良好技术。 此限制也适用于模型（例如布尔方案）的传统通用性定理。 但是，正如我们在本书中已经看到的那样，NS具有强大的学习功能算法。 学习算法和多功能性的结合是一个有吸引力的组合。 到目前为止，在书中，我们集中于训练算法。 在本章中，我们将重点介绍多功能性及其含义。 <br><br><h2> 两个技巧 </h2><br> 在解释普遍性定理为何成立之前，我想提到非正式陈述“神经网络可以计算任何函数”中包含的两个技巧。 <br><br> 首先，这并不意味着可以使用网络来准确地计算任何功能。 我们只能根据需要获得尽可能好的近似值。 通过增加隐藏神经元的数量，我们提高了近似度。 例如，我之前说明了一个使用三个隐藏神经元计算某个函数f（x）的网络。 对于大多数功能，使用三个神经元只能获得低质量的近似值。 通过增加隐藏神经元的数量（例如最多五个），我们通常可以获得更好的近似值： <br><br><img src="https://habrastorage.org/webt/x2/nt/zw/x2ntzw4ykxb450nexszfsd-qz08.png"><br><br> 并通过进一步增加隐藏神经元的数量来改善这种情况。 <br><br> 为了阐明这一说法，假设我们给了函数f（x），我们希望以一定的精度ε&gt; 0进行计算。 可以保证，当使用足够数量的隐藏神经元时，我们总是可以找到一个NS，其输出g（x）满足方程| g（x）-f（x）| &lt;ε对于任何x。 换句话说，对于任何可能的输入值，将以期望的精度获得近似值。 <br><br> 第二个陷阱是可以通过所描述的方法近似的函数属于连续类。 如果该功能被中断，即突然突然跳动，那么在一般情况下将无法借助NS进行近似。 这并不奇怪，因为我们的NS会计算输入数据的连续函数。 但是，即使我们真正需要计算的函数是不连续的，逼近也经常是连续的。 如果是这样，那么我们可以使用NS。 实际上，此限制通常并不重要。 <br><br> 结果，对通用性定理的更准确的表述是，具有一个隐藏层的NS可以用于以任何期望的精度近似任何连续函数。 在本章中，我们使用两个隐藏层而不是一个隐藏层来证明该定理的严格程度稍差一些。 在任务中，我将简要描述如何通过少量更改将这种解释调整为仅使用一个隐藏层的证明。 <br><br><h2> 一输入一输出值的多功能性 </h2><br> 为了理解普遍性定理为什么成立，我们首先了解如何创建仅具有一个输入和一个输出值的NS近似函数： <br><br><img src="https://habrastorage.org/webt/yi/ot/sl/yiotslaplbwh6savahfpzfwdyum.png"><br><br> 事实证明，这是普遍性任务的本质。 一旦我们了解了这种特殊情况，就很容易将其扩展为具有许多输入和输出值的函数。 <br><br> 为了了解如何构建用于计算f的网络，我们从一个网络开始，该网络包含一个包含两个隐藏神经元的单个隐藏层，以及一个包含一个输出神经元的输出层： <br><br><img src="https://habrastorage.org/webt/b7/cz/ql/b7czqllzyyxbpzeq7gs3h6a2338.png"><br><br> 为了想象网络组件如何工作，我们集中在上部隐藏的神经元上。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始文章</a>的图表中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>您可以通过单击“ w”来用鼠标交互地改变重量，并立即查看由上层隐藏神经元计算出的函数如何变化： <br><br><img src="https://habrastorage.org/webt/mh/r0/dz/mhr0dzpmf_zop4a3bwi2of04qtu.png"><br><br> 正如我们在本书前面所学的那样，一个隐藏的神经元的计数为σ（wx + b），其中σ（z）≡1 /（1 + e <sup>-z</sup> ）是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">S形的</a> 。 到目前为止，我们已经经常使用这种代数形式。 但是，为了证明通用性，如果我们完全忽略该代数，而是操纵并观察图中的形状，则更好。 这不仅可以帮助您更好地了解正在发生的事情，而且还为我们提供了适用于除S形以外的其他激活功能的通用性证明。 <br><br> 严格来说，我选择的视觉方法传统上不被视为证据。 但是我相信，与传统的证明方法相比，视觉方法可以更深入地了解最终结果的真实性。 并且，当然，这种理解是证明的真正目的。 在我提出的证据中，有时会出现差距。 我将提供合理但并非总是严格的视觉证据。 如果这让您感到困扰，那么请考虑填补这些空白是您的任务。 但是，不要忘记主要目标：了解普遍性定理为何成立。 <br><br> 首先，请在原始图中单击偏移量b并向右拖动以将其放大。 您会看到，随着偏移量的增加，图形会向左移动，但不会改变形状。 <br><br> 然后将其向左拖动以减少偏移量。 您会看到图形在不改变形状的情况下向右移动。 <br><br> 减轻体重至2-3。 您会看到，随着重量的减少，曲线会变直。 为了使曲线不会偏离图形，您可能必须校正偏移量。 <br><br> 最后，将权重增加到大于100的值。曲线将变得更陡峭，并最终接近台阶。 尝试调整偏移量，以使其角度位于点x = 0.3的范围内。 以下视频显示了应该发生的情况： <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"> 您的浏览器不支持HTML5视频。 <source src="http://neuralnetworksanddeeplearning.com/movies/create_step_function.mp4" type="video/mp4"></video></div></div></div><br><br> 我们可以通过增加权重来极大地简化我们的分析，以便输出实际上是阶跃函数的良好近似。 在下面，我建立了权重w = 999的上层隐藏神经元的输出。 这是静态图片： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/94c/24e/8a8/94c24e8a8a262c06c102b97bef033e99.jpg"><br><br> 使用阶跃函数要比使用典型的S型曲线容易一些。 原因是来自所有隐藏神经元的贡献被加在输出层中。 一堆阶跃函数的总和很容易分析，但是要谈论以S型曲线形式添加一堆曲线时会发生什么则更困难。 因此，假设我们的隐藏神经元产生逐步功能将更加简单。 更准确地说，我们通过将权重w固定在一个非常大的值，然后通过偏移量指定阶梯的位置来实现。 当然，将输出用作阶跃函数是一个近似值，但这非常好，到目前为止，我们将把该函数视为真实阶跃函数。 稍后，我将再次讨论偏离该近似值的影响。 <br><br>  x的步长是多少？ 换句话说，台阶的位置如何取决于重量和位移？ <br><br> 要回答该问题，请尝试更改交互式图表中的权重和偏移量。 您能理解台阶的位置如何取决于w和b吗？ 通过稍微练习，您可以说服自己其位置与b成正比，与w成反比。 <br><br> 实际上，步骤是在s = -b / w处，如我们将权重和位移调整为以下值所示： <br><br><img src="https://habrastorage.org/webt/ee/d9/zo/eed9zodaxp8ot33ip8y8j-sdcqg.png"><br><br> 如果我们使用单个参数s来描述隐藏的神经元，即步骤的位置s = -b / w，则会大大简化我们的生活。 在下面的交互式图中，您可以简单地更改s： <br><br><img src="https://habrastorage.org/webt/uy/g6/9h/uyg69hokiufnmt7zwwmysjof5uc.png"><br><br> 如上所述，我们专门在输入处将权重w分配给一个非常大的值-足够大，以便阶跃函数成为一个很好的近似值。 通过选择偏差b = -ws，我们可以轻松地以这种方式将参数化的神经元恢复为通常的形式。 <br><br> 到目前为止，我们仅关注上层隐藏神经元的输出。 让我们看一下整个网络的行为。 假设隐藏的神经元计算由步长s <sub>1</sub> （上层神经元）和s <sub>2</sub> （下层神经元）的参数定义的步长函数。 它们各自的输出权重为w <sub>1</sub>和w <sub>2</sub> 。 这是我们的网络： <br><br><img src="https://habrastorage.org/webt/6u/ot/ns/6uotnsmlecwfh8iaqz1eb5p5tjo.png"><br><br> 右边是隐藏层的加权输出w <sub>1</sub> a <sub>1</sub> + w <sub>2</sub> a <sub>2的图</sub> 。 这里的a <sub>1</sub>和a <sub>2</sub>分别是上部和下部隐藏神经元的输出。 它们用“ a”表示，因为它们通常称为神经元激活。 <br><br> 顺便说一下，我们注意到整个网络的输出是σ（w <sub>1</sub> a <sub>1</sub> + w <sub>2</sub> a <sub>2</sub> + b），其中b是输出神经元的偏差。 显然，这与我们正在构建的隐藏层的加权输出不同。 但是现在，我们将专注于隐藏层的平衡输出，并且仅在以后考虑它与整个网络的输出之间的关系。 <br><br> 尝试增加和减少<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始文章中</a>交互式图上隐藏神经元的步长s <sub>1</sub> 。 看看这如何改变隐藏层的加权输出。 了解s <sub>1</sub>超过s <sub>2</sub>会发生什么特别有用。 您会看到，在这些情况下，随着我们从首先激活上层隐藏神经元的情况到首先激活下层隐藏神经元的情况，图形发生了变化。 <br><br> 同样，尝试操纵下部隐藏神经元的第<sub>2</sub>步<sub>，</sub>看看这如何改变隐藏神经元的整体输出。 <br><br> 尝试减少和增加输出重量。 请注意，这如何缩放相应隐藏神经元的贡献。 如果权重之一等于0会怎样？ <br><br> 最后，尝试将w <sub>1</sub>设置为0.8，将w <sub>2设置</sub>为-0.8。 结果是“突出”功能，从s <sub>1</sub>开始，在s <sub>2</sub>结束，并且高度为0.8。 例如，加权输出可能如下所示： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/84d/9be/e75/84d9bee755d8a57bbdb3aed20d07da78.jpg"><br><br> 当然，突起可以缩放到任意高度。 让我们使用一个参数h来表示高度。 另外，为简单起见，我将摆脱符号“ s <sub>1</sub> = ...”和“ w <sub>1</sub> = ...”。 <br><br><img src="https://habrastorage.org/webt/io/by/7l/ioby7lcd1whqowsw0ak9j1td16q.png"><br><br> 尝试增大和减小h值，以查看突起的高度如何变化。 尝试使h为负。 尝试更改台阶的点，以观察这如何改变突起的形状。 <br><br> 您将看到，我们不仅将神经元用作图形原语，而且还将其用作程序员更熟悉的单元-类似于编程中的if-then-else指令： <br><br> 如果输入&gt; =步骤开始： <br> 将1加到加权输出 <br> 否则： <br> 将0加到加权输出 <br><br> 在大多数情况下，我将坚持使用图形符号。 但是，有时切换到“ if-then-else”视图并反思这些术语中发生的情况对于您很有用。 <br><br> 我们可以通过将隐藏神经元的两个部分粘合到同一网络上来使用突出技巧： <br><br><img src="https://habrastorage.org/webt/4w/4p/pz/4w4ppzryydmyz3f3dglgzcwisfm.png"><br><br> 在这里，我通过简单地写下每对隐藏神经元的h值来降低权重。 尝试同时使用两个h值，看看它如何改变图形。 移动选项卡，更改步骤的要点。 <br><br> 在更一般的情况下，该想法可用于获得任何所需数量的任何高度的峰。 特别是，我们可以将间隔[0,1]划分为大量（N）个子间隔，并使用N对隐藏的神经元来获取任何所需高度的峰。 让我们看看在N = 5时这是如何工作的。 这已经是很多神经元了，因此我的演讲范围更窄一些。 抱歉，复杂图-我可以将复杂性隐藏在其他抽象的背后，但在我看来，为了更好地感觉神经网络的工作原理，值得对复杂性进行一点折磨。 <br><br><img src="https://habrastorage.org/webt/do/2t/x-/do2tx-fp-h-w83rnboapp8w-o98.png"><br><br> 你看，我们有五对隐藏的神经元。 相应对的步骤的点位于0.1 / 5，然后是1 / 5.2 / 5，依此类推，直到4 / 5.5 / 5。 这些值是固定的-我们在图形上得到了五个宽度相等的突起。 <br><br> 每对神经元都有一个与之相关的值h。 请记住，输出神经元连接的权重为h和–h。 在图表的原始文章中，您可以单击h值并将其左右移动。 随着高度的变化，图形也会变化。 通过更改输出权重，我们构造了最终函数！ <br><br> 在图上，您仍然可以单击图形，然后向上或向下拖动台阶的高度。 更改其高度时，您会看到相应h的高度如何变化。 输出权重+ h和–h相应地变化。 换句话说，我们直接操作一个函数，该函数的图形显示在右侧，而在h的值中看到这些变化。 您也可以在其中一个突起上按住鼠标按钮，然后向左或向右拖动鼠标，突起将调整为当前高度。 <br><br> 现在是时候完成工作了。 <br><br> 回想一下本章开头所介绍的函数： <br><br><img src="https://habrastorage.org/webt/yi/ot/sl/yiotslaplbwh6savahfpzfwdyum.png"><br><br> 然后我没有提到这个，但实际上看起来像这样： <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>f</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mi>x</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow><mo>=</mo><mn>0.2</mn><mo>+</mo><mn>0.4</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>0.3</mn><mi>x</mi><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>i</mi><mi>n</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mn>15</mn><mi>x</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow><mo>+</mo><mn>0.05</mn><mtext>&amp;#xA0;</mtext><mi>c</mi><mi>o</mi><mi>s</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mn>50</mn><mi>x</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow><mtext mathcolor=&quot;red&quot;>\&amp;#x6807;</mtext><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x7B7E;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>113</mn></mrow></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="66.046ex" height="3.021ex" viewBox="0 -987.6 28436.2 1300.8" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMATHI-66" x="0" y="0"></use><g transform="translate(550,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMATHI-78" x="1380" y="0"></use><g transform="translate(1952,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-3D" x="3060" y="0"></use><g transform="translate(4117,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-2E" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-32" x="779" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-2B" x="5618" y="0"></use><g transform="translate(6619,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-2E" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-34" x="779" y="0"></use></g><g transform="translate(7898,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-32" x="809" y="583"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-2B" x="9147" y="0"></use><g transform="translate(10148,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-2E" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-33" x="779" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMATHI-78" x="11427" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMATHI-73" x="12250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMATHI-69" x="12719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMATHI-6E" x="13065" y="0"></use><g transform="translate(13665,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><g transform="translate(14495,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-35" x="500" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMATHI-78" x="15496" y="0"></use><g transform="translate(16069,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-2B" x="17121" y="0"></use><g transform="translate(18122,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-2E" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-30" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-35" x="1279" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMATHI-63" x="20152" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMATHI-6F" x="20585" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMATHI-73" x="21071" y="0"></use><g transform="translate(21540,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><g transform="translate(22370,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-35"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-30" x="500" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMATHI-78" x="23371" y="0"></use><g transform="translate(23944,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g><g fill="red" stroke="red" transform="translate(24774,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">标</text></g></g><g transform="translate(26104,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">签</text></g><g transform="translate(26934,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-31" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhjhmfw7G7ed_hNf3TcixjIkEoLGiQ#MJMAIN-33" x="1001" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>f</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow><mo>=</mo><mn>0.2</mn><mo>+</mo><mn>0.4</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>0.3</mn><mi>x</mi><mtext>&nbsp;</mtext><mi>s</mi><mi>i</mi><mi>n</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mn>15</mn><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow><mo>+</mo><mn>0.05</mn><mtext>&nbsp;</mtext><mi>c</mi><mi>o</mi><mi>s</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mn>50</mn><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow><mtext mathcolor="red">\标</mtext><mrow class="MJX-TeXAtom-ORD"><mo>签</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mn>113</mn></mrow></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> f（x）= 0.2 + 0.4 x ^ 2 + 0.3x \ sin（15 x）+ 0.05 \ cos（50 x）\标签{113} </script></p><br><br> 它针对x值从0到1构造，沿y轴的值从0到1变化。 <br><br> 显然，此功能很重要。 而且，您必须弄清楚如何使用神经网络进行计算。 <br><br> 在上面的神经网络中，我们分析了隐藏神经元输出的加权组合∑ <sub>j</sub> w <sub>j</sub> a <sub>j</sub> 。 我们知道如何对该值进行重大控制。 但是，正如我前面提到的，该值不等于网络输出。 网络的输出为σ（∑ <sub>j</sub> w <sub>j</sub> a <sub>j</sub> + b），其中b是输出神经元的位移。 我们可以直接控制网络输出吗？ <br><br> 解决方案是开发一种神经网络，其中隐藏层的加权输出由方程σ <sup>-</sup> 1⋅f（x）给出，其中σ <sup>-1</sup>是σ的反函数。 也就是说，我们希望隐藏层的加权输出如下所示： <br><br><img src="https://habrastorage.org/webt/sk/bu/bw/skbubwnwkrrpukeblqe9a1qo8cw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果成功，则整个网络的输出将很好地近似于f（x）（我将输出神经元的偏移量设置为0）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后您的任务是开发一个近似于上面所示目标函数的NS。为了更好地了解正在发生的事情，建议您两次解决此问题。在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原始文章中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一次</font><font style="vertical-align: inherit;">单击该图，然后直接调整不同突起的高度。您将很容易获得目标函数的近似值。近似程度由平均偏差，目标函数与网络计算的函数之间的差估算。您的任务是使平均偏差达到最小值。如果平均偏差不超过0.40，则认为任务已完成。</font></font><br><br><img src="https://habrastorage.org/webt/jb/qh/j8/jbqhj8kul1dtc6o-nyrm0qxhh_0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成功完成后，请按“重置”按钮，这会随机更改选项卡。第二次，请勿触摸图形，而是更改图形左侧的h值，以使平均偏差为0.40或更小。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样，您已经找到了网络近似计算函数f（x）所需的所有元素！近似结果很粗糙，但是我们可以通过简单地增加隐藏神经元对的数量来轻松地改善结果，这将增加突起的数量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特别是，很容易通过用于NS的参数化将找到的所有数据返回到标准视图中。让我快速提醒您这是如何工作的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第一层中，所有权重都具有较大的恒定值，例如w = 1000。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隐藏的神经元的位移通过b = -ws计算。因此，例如，对于第二个隐藏神经元，s = 0.2变成b = -1000×0.2 = -200。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标度的最后一层由h的值确定。因此，例如，您为第一个h选择的值h = -0.2，意味着两个上层隐藏神经元的输出权重分别为-0.2和0.2。对于整个输出权重层，依此类推。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，输出神经元的偏移量为0。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就是这样：我们得到了NS的完整描述，它可以很好地计算初始目标函数。而且我们了解如何通过增加隐藏神经元的数量来提高近似质量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，在我们最初的目标函数中，f（x）= 0.2 + 0.4x </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ 0.3sin（15x）+ 0.05cos（50x）没什么特别的。</font><font style="vertical-align: inherit;">对于从[0,1]到[0,1]的时间间隔，任何连续函数都可以使用类似的过程。</font><font style="vertical-align: inherit;">实际上，我们使用单层NS来构建函数的查找表。</font><font style="vertical-align: inherit;">我们可以以此思想为基础来获得普遍性的通用证明。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 许多参数的功能 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将结果扩展到一组输入变量的情况。听起来很复杂，但是对于只有两个传入变量的情况，我们所需的所有想法已经可以理解。因此，我们考虑带有两个传入变量的情况。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们先来看一下神经元有两个输入时发生的情况：</font></font><br><br><img src="https://habrastorage.org/webt/k5/cm/a9/k5cma9i-bgfwxnp2ao9h1wiwfz0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们有输入x和y，具有相应的权重w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并偏移神经元b。我们将w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的权重设置</font><font style="vertical-align: inherit;">为0并与第一个w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和偏移b一起</font><font style="vertical-align: inherit;">玩，</font><font style="vertical-align: inherit;">以查看它们如何影响神经元的输出：</font></font><br><br><img src="https://habrastorage.org/webt/bl/71/6p/bl716pdfanpkwighwk2dc6m20ey.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如您所见，在w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 0的情况下，输入y不会影响神经元的输出。一切都好像x是唯一的输入一样发生​​。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">鉴于此，当我们将w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的权重</font><font style="vertical-align: inherit;">增加到w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100且w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">离开0 </font><font style="vertical-align: inherit;">时，您认为会发生什么</font><font style="vertical-align: inherit;">？如果您现在还不清楚，请考虑一下此问题。然后观看以下视频，该视频将显示将发生的情况：</font></font><br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"> 您的浏览器不支持HTML5视频。 <source src="http://neuralnetworksanddeeplearning.com/movies/step_3d.mp4" type="video/mp4"></video></div></div></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如前所述，随着输入重量的增加，输出接近台阶的形状。区别在于我们的步进函数现在位于三个维度中。和以前一样，我们可以通过更改偏移量来移动步骤的位置。该角度是在所述点s </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ≡-B / W1。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们重做该图，以便参数是步骤的位置：</font></font><br><br><img src="https://habrastorage.org/webt/aw/qs/59/awqs59ahvnac-1i9piafzg2jbpi.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们假设x的输入权重非常重要-我使用w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1000-权重w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 0。神经元上的数字是台阶的位置，其上方的x提醒我们沿着x轴移动台阶。自然，很可能获得沿y轴的阶跃函数，从而使y的传入权重较大（例如w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= 1000），x的权重为0，w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 0：</font></font><br><br><img src="https://habrastorage.org/webt/xg/zw/y0/xgzwy0jgsj5q1gl3oqgygzqv0nq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">神经元上的数字再次表示台阶的位置，其上方的y提醒我们沿y轴移动台阶。我可以直接指定x和y的权重，但是我没有指定，因为那样会乱丢图表。但是请记住，y标记表示y的权重较大，而x的权重为0。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以使用刚设计的阶跃函数来计算三维突出函数。为此，我们采用两个神经元，每个神经元将沿x轴计算一个阶跃函数。然后，我们将这些阶跃函数与权重h和–h结合起来，其中h是所需的突出高度。所有这些都可以在下图中看到：</font></font><br><br><img src="https://habrastorage.org/webt/5s/qn/wk/5sqnwkfmm7_uzs3jchov90ylyz8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尝试更改h的值。了解它与网络权重的关系。以及她如何更改右侧突出功能的高度。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还要尝试更改步骤的点，该步骤的值在上层隐藏神经元中设置为0.30。看看它如何改变突起的形状。如果将其移动到与较低的隐藏神经元关联的0.70点处会发生什么？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们学习了如何沿x轴构建突出功能。自然地，我们可以使用沿y轴的两个阶跃函数轻松地使突出函数沿y轴。回想一下，我们可以通过在输入y处设置较大的权重，并在输入x处设置权重0来实现此目的。因此，发生了什么：</font></font><br><br><img src="https://habrastorage.org/webt/ic/uu/fq/icuufqisf9gjv8zccnkg0f0bevc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它看起来几乎与以前的网络相同！唯一可见的变化是隐藏神经元上的小y标记。他们提醒我们，它们为y而不是x生成阶跃函数，因此在输入y处权重非常大，在输入x处权重为零，反之亦然。和以前一样，我决定不直接显示它，以免使图片混乱。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们看看如果添加两个突出函数，一个沿x轴，另一个沿y轴，两个高度均为h，会发生什么情况：</font></font><br><br><img src="https://habrastorage.org/webt/7f/u7/fc/7fu7fcn8xnl5r4zffk3tpunuedg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了简化零重量的连接图，我省略了。到目前为止，我在隐藏的神经元上留下了小的x和y标记，以回想起突出功能的计算方向。稍后我们将拒绝它们，因为传入的变量隐含了它们。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尝试更改参数h。</font><font style="vertical-align: inherit;">如您所见，因此，输出权重以及两个突出函数x和y的权重都会改变。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的</font></font><br><br><img src="https://habrastorage.org/webt/ad/le/ww/adlewwyzmc3zhrk-fm9a9yvx6zo.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建</font><font style="vertical-align: inherit;">有点像“塔函数”：</font><font style="vertical-align: inherit;">如果我们可以创建这样的塔函数，则可以通过在不同位置简单地添加不同高度的塔来使用它们来近似任意函数：</font></font><br><br><img src="https://habrastorage.org/webt/u1/lv/xv/u1lvxvdmfi4xxsqgpjabiwofr2k.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，我们尚未达到创建任意塔函数的目的。</font><font style="vertical-align: inherit;">到目前为止，我们已经建造了一个高度为2h的中央塔楼，周围环绕着高度h的高原。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是我们可以使塔功能。</font><font style="vertical-align: inherit;">回想一下，我们之前已经展示了如何使用神经元来实现if-then-else语句：</font></font><br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>  &gt;= :  <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>:  <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br> 它是一输入神经元。 我们需要将类似的想法应用于隐藏神经元的组合输出： <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>     &gt;= :  <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>:  <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br> 如果我们选择正确的阈值-例如3h / 2，将其压缩在高原的高度和中央塔的高度之间-我们可以将高原压低到零，只剩下一座塔。 <br><br> 想象一下该怎么做？ 尝试尝试以下网络。 现在，我们正在绘制整个网络的输出，而不仅仅是绘制隐藏层的加权输出。 这意味着我们将偏移项添加到隐藏层的加权输出中，然后应用S型。 您能找到得到塔的h和b的值吗？ 如果此时您陷入困境，这里有两个提示：（1）为使输出神经元显示if-then-else行为，我们需要输入权重（全部为h或–h）较大；  （2）b的值确定if-then-else阈值的标度。 <br><br><img src="https://habrastorage.org/webt/ys/k-/1u/ysk-1uvu-jo68ikk5rqu274u7wc.png"><br><br> 使用默认参数，输出类似于上图的展平版本，具有塔和平台。 要获得所需的行为，您需要增加h的值。 这将为我们提供if-then-else的阈值行为。 其次，为了正确设置阈值，必须选择b≈-3h / 2。 <br><br> 这是h = 10的样子： <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"> 您的浏览器不支持HTML5视频。 <source src="http://neuralnetworksanddeeplearning.com/movies/tower_construction.mp4" type="video/mp4"></video></div></div></div><br> 即使对于相对较小的h值，我们也会得到很好的塔函数。 而且，当然，我们可以通过进一步增加h并将偏差保持在b = -3h / 2来获得任意美丽的结果。 <br><br> 让我们尝试将两个网络粘合在一起，以计算两个不同的塔函数。 为了使两个子网的作用明确，我将它们放在单独的矩形中：每个矩形都使用上述技术计算塔函数。 右图显示了第二个隐藏层的加权输出，即塔函数的加权组合。 <br><br><img src="https://habrastorage.org/webt/8-/cl/ke/8-clkebo6vphf1-0_jgoaf3exts.png"><br><br> 特别是可以看出，通过更改最后一层的权重，可以更改输出塔的高度。 <br><br> 同样的想法可以让您计算任意数量的塔。 我们可以使它们任意变高。 结果，我们保证第二个隐藏层的加权输出近似于两个变量的任何期望函数： <br><br><img src="https://habrastorage.org/webt/ig/0u/5z/ig0u5zbzifftdfq4ww4y9a4r7du.png"><br><br> 特别是，迫使第二个隐藏层的加权输出近似为σ <sup>-</sup> 1⋅f，我们保证网络的输出将很好地近似于所需函数f。 <br><br> 那么许多变量的功能呢？ <br><br> 让我们尝试采用三个变量x <sub>1</sub> ，x <sub>2</sub> ，x <sub>3</sub> 。 可以使用以下网络在四个维度上计算塔函数吗？ <br><br><img src="https://habrastorage.org/webt/wg/ki/kn/wgkiknicnzeoaept0d-cemw0sd0.png"><br><br>  x <sub>1</sub> ，x <sub>2</sub> ，x <sub>3</sub>表示网络输入。  s <sub>1</sub> ，t <sub>1，</sub>以此类推-神经元的阶跃点-也就是说，第一层中的所有权重都很大，并且分配了偏移，以使阶跃点为s <sub>1</sub> ，t <sub>1</sub> ，s <sub>2</sub> ，... ...第二层中的权重交替h，-h，其中h是一个非常大的数字。 输出失调为−5h / 2。 <br><br> 网络在以下三个条件下计算等于1的函数：x <sub>1</sub>在s <sub>1</sub>和t <sub>1之间</sub> ；  x <sub>2</sub>在s <sub>2</sub>和t <sub>2之间</sub> ；  x <sub>3</sub>在s <sub>3</sub>和t <sub>3之间</sub> 。 在所有其他地方，网络均为0。 这是一座塔，其中1是入口空间的一小部分，0是其他所有空间。 <br><br> 粘合许多这样的网络，我们可以得到尽可能多的塔，并近似地包含三个变量的任意函数。 同样的想法适用于m个维度。 仅更改输出偏移（-m + 1/2）h，以正确压缩所需的值并消除平稳状态。 <br><br> 好了，现在我们知道了如何使用NS来近似许多变量的实函数。 向量函数f（x <sub>1</sub> ，...，x <sub>m</sub> ）∈R <sup>n</sup>呢？ 当然，可以简单地将这样的函数视为n个独立的实函数f1（x <sub>1</sub> ，...，x <sub>m</sub> ），f2（x <sub>1</sub> ，...，x <sub>m</sub> ），依此类推。 然后，我们将所有网络粘合在一起。 因此很容易弄清楚。 <br><br><h3> 挑战赛 </h3><br><ul><li> 我们看到了如何使用具有两个隐藏层的神经网络来近似任意函数。 您能证明只有一个隐藏层才有可能吗？ 提示-尝试仅使用两个输出变量，并表明：（a）不仅可以沿x轴或y轴，而且还可以沿任意方向获得步骤的功能；  （b）将步骤（a）中的许多结构加起来，可以近似为圆形而不是矩形塔的功能；  ©使用圆塔，可以近似任意函数。 使用下面稍稍介绍的本章内容，将更容易执行步骤©。 </li></ul><br><h2> 超越乙状神经元 </h2><br> 我们已经证明了乙状神经元网络可以计算任何功能。 回想一下，在一个S型神经元中，输入x <sub>1</sub> ，x <sub>2</sub> ，...在输出处变成σ（∑ <sub>j</sub> w <sub>j</sub> x <sub>j j</sub> + b），其中w <sub>j</sub>是权重，b是偏差，σ是S型。 <br><br><img src="https://habrastorage.org/webt/0h/ut/93/0hut93wneejtjvxvxiwnfwpmo40.png"><br><br> 如果我们使用另一种激活函数s（z）查看另一种神经元，该怎么办： <br><br><img src="https://habrastorage.org/webt/ua/0-/it/ua0-itpxz-uwkpnptxfsvszqabg.png"><br><br> 也就是说，我们假设如果一个神经元具有x <sub>1</sub> ，x <sub>2</sub> ，...权重w <sub>1</sub> ，w <sub>2</sub> ，...和偏差b，则将输出s（∑ <sub>j</sub> w <sub>j</sub> x <sub>j</sub> + b）。 <br><br> 我们可以使用此激活函数来步进，就像在S型情况下一样。 尝试在该图上（在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始文章中</a> ）将权重提升到例如w = 100： <br><br><img src="https://habrastorage.org/webt/vz/-v/mu/vz-vmulc79w1g7xxom_btmnfyow.png"><br><br><img src="https://habrastorage.org/webt/nf/aq/iz/nfaqiznhl2klhebfc33iiy6htrg.png"><br><br> 因此，如在S形的情况中，激活函数被压缩，并且结果变成阶跃函数的非常好的近似。 尝试更改偏移量，您将看到我们可以将步骤的位置更改为任意位置。 因此，我们可以使用与以前相同的所有技巧来计算任何所需的函数。 <br><br>  s（z）应该具有什么属性才能使其起作用？ 我们需要假设s（z）定义为z→-∞和z→∞。 这些限制是我们的步进函数接​​受的两个值。 我们还需要假设这些限制是不同的。 如果它们没有什么不同，则这些步骤将无效；只是时间表固定！ 但是，如果激活函数s（z）满足这些属性，则基于该函数的神经元将普遍适用于计算。 <br><br><h3> 任务 </h3><br><ul><li> 在本书的前面，我们遇到了另一种类型的神经元-线性神经元或矫正的线性单位ReLU。 解释为什么这样的神经元不满足普遍性的必要条件。 查找通用性证据，表明ReLU普遍适用于计算。 </li><li> 假设我们正在考虑线性神经元，其激活函数为s（z）= z。 解释为什么线性神经元不满足普遍性条件。 表明这种神经元不能用于通用计算。 </li></ul><br><h2> 固定步进功能 </h2><br> 暂时，我们假设我们的神经元产生准确的阶跃功能。 这是一个很好的近似值，但是仅仅是一个近似值。 实际上，如下图所示，故障之间的差距很小，其中的功能根本不像步进功能： <br><br><img src="https://habrastorage.org/webt/mr/0t/ng/mr0tng4l1giob-gsuhyo_oh_vk0.png"><br><br> 在这个失败的时期，我对普遍性的解释不起作用。 <br><br> 失败不是那么可怕。 通过设置足够大的输入权重，我们可以任意缩小这些差距。 我们可以使它们比图表上的小得多，并且肉眼看不见。 因此，也许我们不必担心这个问题。 <br><br> 但是，我想有一些解决方法。 <br><br> 事实证明，这很容易解决。 让我们看一下仅用一个输入和输出来计算NS函数的解决方案。 相同的想法将可以解决大量输入和输出问题。 <br><br> 特别是，假设我们希望网络计算某些函数f。 如前所述，我们尝试通过设计网络来做到这一点，以使神经元隐藏层的加权输出为σ <sup>-</sup> 1⋅f（x）： <br><br><img src="https://habrastorage.org/webt/sk/bu/bw/skbubwnwkrrpukeblqe9a1qo8cw.png"><br><br> 如果使用上述技术执行此操作，则将迫使隐藏的神经元产生一系列突出功能： <br><br><img src="https://habrastorage.org/webt/71/uc/x_/71ucx_26mzx0_isj6dlob9wdacq.png"><br><br> 当然，我夸大了故障间隔的大小，以便于查看。 应该清楚的是，如果我们将突起的所有这些功能加起来，那么除失效间隔外，我们在所有地方都将得到σ <sup>-</sup> 1⋅f（x）的近似值。 <br><br> 但是，假设我们不是使用刚刚描述的近似值，而是使用一组隐藏的神经元来计算原始目标函数一半的近似值，即σ <sup>-</sup> 1⋅f（x）/ 2。 当然，它看起来就像最新图形的缩放版本： <br><br><img src="https://habrastorage.org/webt/8-/0b/fv/8-0bfvrf5njiwum-w6d8edu4dro.png"><br><br> 并假设我们使另外一组隐藏的神经元计算出σ <sup>-</sup> 1⋅f（x）/ 2的近似值，但是，在其底部，突起将偏移其宽度的一半： <br><br><img src="https://habrastorage.org/webt/dj/cz/7n/djcz7nxhhm98yhiq94uluglvm-m.png"><br><br> 现在我们对σ−1⋅f（x）/ 2有两个不同的近似值。 如果将这两个近似值相加，我们将得到σ−1⋅f（x）的一般近似值。 这种一般的近似在小间隔内仍将有误差。 但是问题将比以前少了-因为落入第一近似失败区间的点不会落入第二近似失败区间。 因此，这些间隔中的近似值大约好2倍。 <br><br> 我们可以通过增加大量的函数σ−1⋅f（x）/ M的重叠近似值M来改善这种情况。 如果它们的所有故障间隔都足够窄，则任何电流都将仅流入其中一个。 如果使用足够多的M重叠逼近，则结果将是极好的一般逼近。 <br><br><h2> 结论 </h2><br> 这里讨论的通用性的解释绝对不能称为如何使用神经网络对函数进行计数的实际描述！ 从这个意义上讲，它更像是NAND逻辑门多功能性的证明。 因此，我基本上是在不优化细节的情况下使该设计清晰易懂。 但是，尝试优化此设计可能对您来说是一个有趣而有启发性的练习。 <br><br> 尽管获得的结果不能直接用于创建NS，但它很重要，因为它消除了使用NS的任何特定函数的可计算性问题。 这个问题的答案永远是肯定的。 因此，询问任何函数是否可计算是正确的，但是计算它的正确方法是什么。 <br><br> 我们的通用设计仅使用两个隐藏层来计算任意函数。 正如我们所讨论的，使用单个隐藏层可以获得相同的结果。 鉴于此，您可能想知道为什么我们需要深度网络，即具有大量隐藏层的网络。 我们不能只用具有一个隐藏层的浅层网络替换这些网络吗？ <br><br> 尽管从原则上讲是可行的，但使用深度神经网络有很多实用的理由。 如第1章所述，深层NS具有层次结构，可以使它们很好地适应研究层次知识，这对于解决实际问题很有用。 更具体地说，在解决诸如模式识别之类的问题时，使用一种不仅能够理解单个像素，而且能够理解日益复杂的概念（从边界到简单的几何形状，甚至到涉及多个对象的复杂场景）的系统都是有用的。 在后面的章节中，我们将看到证据支持这样一个事实，即深层NS比浅层NS更能应付这种知识层次的研究。 概括地说：普遍性告诉我们NS可以计算任何函数； 经验证据表明，深层NS更适合于研究对解决许多现实问题有用的功能。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN461659/">https://habr.com/ru/post/zh-CN461659/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN461649/index.html">我将如何拯救世界</a></li>
<li><a href="../zh-CN461651/index.html">前端每周摘要（2019年7月22日至28日）</a></li>
<li><a href="../zh-CN461653/index.html">软件无线电-它如何工作？ 第10部分</a></li>
<li><a href="../zh-CN461655/index.html">上周第373期来自前端世界的新鲜材料摘要（2019年7月22日至28日）</a></li>
<li><a href="../zh-CN461657/index.html">购买Red Hat：它将帮助Blue Giant争取混合云领导力</a></li>
<li><a href="../zh-CN461661/index.html">基于组件的开发指南</a></li>
<li><a href="../zh-CN461663/index.html">Linux如何引入Windows的故事</a></li>
<li><a href="../zh-CN461665/index.html">Zen2。 以Ryzen 7 3700x为例的AM4平台的演变</a></li>
<li><a href="../zh-CN461669/index.html">PHP摘要161号（2019年7月15日至29日）</a></li>
<li><a href="../zh-CN461673/index.html">给新手程序员或我的职业生涯回顾的8个技巧</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>