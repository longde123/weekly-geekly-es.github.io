<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé§ üï¥üèª ‚úåüèº So machen Sie Container noch isolierter: eine √úberpr√ºfung der Container-Sandbox-Technologien üôáüèª üõÉ üà¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Trotz der Tatsache, dass die meisten IT-Unternehmen Infrastrukturl√∂sungen basierend auf Containern und Cloud-L√∂sungen implementieren, ist es notwendig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So machen Sie Container noch isolierter: eine √úberpr√ºfung der Container-Sandbox-Technologien</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/457760/">  Trotz der Tatsache, dass die meisten IT-Unternehmen Infrastrukturl√∂sungen basierend auf Containern und Cloud-L√∂sungen implementieren, ist es notwendig, die Einschr√§nkungen dieser Technologien zu verstehen.  Traditionell sind Docker, Linux Container (LXC) und Rocket (rkt) nicht wirklich isoliert, da sie in ihrer Arbeit den Kern des √ºbergeordneten Betriebssystems gemeinsam nutzen.  Ja, sie sind ressourcenschonend, aber die Gesamtzahl der gesch√§tzten Angriffsmethoden und potenziellen Verluste durch Hacking ist immer noch gro√ü, insbesondere im Fall einer Cloud-Umgebung mit mehreren Mandanten, in der sich Container befinden. <br><br><img src="https://habrastorage.org/webt/ls/er/x_/lserx_gyy2iflakk5liv6en4yty.png"><br><br>  Die Wurzel unseres Problems liegt in der schwachen Abgrenzung von Containern in dem Moment, in dem das Host-Betriebssystem f√ºr jeden einen virtuellen Benutzerbereich erstellt.  Ja, Forschung und Entwicklung wurden durchgef√ºhrt, um echte ‚ÄûContainer‚Äú mit einem vollwertigen Sandkasten zu schaffen.  Die meisten der daraus resultierenden L√∂sungen f√ºhren zu einer Umstrukturierung der Grenzen zwischen Containern, um deren Isolation zu verbessern.  In diesem Artikel werden vier einzigartige Projekte von IBM, Google, Amazon und OpenStack vorgestellt, die unterschiedliche Methoden verwenden, um dasselbe Ziel zu erreichen: die Schaffung einer zuverl√§ssigen Isolation.  IBM Nabla stellt Container auf Unikernel bereit, Google gVisor erstellt einen speziellen Gastkernel, Amazon Firecracker verwendet einen extrem leichten Hypervisor f√ºr Sandbox-Anwendungen und OpenStack platziert Container in einer speziellen virtuellen Maschine, die f√ºr Orchestrierungstools optimiert ist. <br><a name="habracut"></a><br><h3>  √úberblick √ºber die moderne Containertechnologie </h3><br>  Container sind eine moderne Methode zum Packen, Freigeben und Bereitstellen einer Anwendung.  Im Gegensatz zu einer monolithischen Anwendung, bei der alle Funktionen in einem Programm zusammengefasst sind, sind Containeranwendungen oder Mikrodienste f√ºr eine gezielte enge Verwendung vorgesehen und auf nur eine Aufgabe spezialisiert. <br><br>  Ein Container enth√§lt alle Abh√§ngigkeiten (z. B. Pakete, Bibliotheken und Bin√§rdateien), die eine Anwendung ben√∂tigt, um ihre spezifische Aufgabe auszuf√ºhren.  Containerisierte Anwendungen sind daher plattformunabh√§ngig und k√∂nnen auf jedem Betriebssystem ausgef√ºhrt werden, unabh√§ngig von der Version oder den installierten Paketen.  Diese Bequemlichkeit erspart Entwicklern einen enormen Arbeitsaufwand bei der Anpassung verschiedener Softwareversionen f√ºr verschiedene Plattformen oder Clients.  Obwohl konzeptionell nicht ganz genau, denken viele Menschen gerne an Container als ‚Äûleichte virtuelle Maschinen‚Äú. <br><br>  Wenn ein Container auf einem Host bereitgestellt wird, werden die Ressourcen jedes Containers, z. B. das Dateisystem, der Prozess und der Netzwerkstapel, in eine praktisch isolierte Umgebung gestellt, auf die andere Container nicht zugreifen k√∂nnen.  Diese Architektur erm√∂glicht die gleichzeitige Ausf√ºhrung von Hunderten und Tausenden von Containern in einem einzelnen Cluster, und jede Anwendung (oder jeder Microservice) kann dann einfach skaliert werden, indem eine gro√üe Anzahl von Instanzen repliziert wird. <br><br>  In diesem Fall basiert das Containerlayout auf zwei wichtigen ‚ÄûBausteinen‚Äú: dem Linux-Namespace und den Linux-Kontrollgruppen (cgroups). <br><br>  Der Namespace erstellt einen praktisch isolierten Benutzerbereich und stellt der Anwendung dedizierte Systemressourcen wie Dateisystem, Netzwerkstapel, Prozess-ID und Benutzer-ID zur Verf√ºgung.  In diesem isolierten Benutzerbereich steuert die Anwendung das Stammverzeichnis des Dateisystems und kann als Stamm ausgef√ºhrt werden.  Dieser abstrakte Bereich erm√∂glicht es jeder Anwendung, unabh√§ngig zu arbeiten, ohne andere Anwendungen auf demselben Host zu beeintr√§chtigen.  Derzeit sind sechs Namespaces verf√ºgbar: Mount, Interprozesskommunikation (IPC), UNIX-Time-Sharing-System (uts), Prozess-ID (pid), Netzwerk und Benutzer.  Es wird vorgeschlagen, diese Liste durch zwei zus√§tzliche Namespaces zu erg√§nzen: time und syslog, aber die Linux-Community hat sich noch nicht f√ºr die endg√ºltigen Spezifikationen entschieden. <br><br>  Cgroups bieten Begrenzung, Priorisierung, Anwendungs√ºberwachung und -steuerung f√ºr Hardwareressourcen.  Ein Beispiel f√ºr die Hardwareressourcen, die sie steuern k√∂nnen, sind der Prozessor, der Speicher, das Ger√§t und das Netzwerk.  Wenn Sie den Namespace und die cgroups kombinieren, k√∂nnen Sie sicher mehrere Anwendungen auf demselben Host ausf√ºhren, wobei sich jede Anwendung in einer eigenen isolierten Umgebung befindet. Dies ist die grundlegende Eigenschaft des Containers. <br><br>  Der Hauptunterschied zwischen einer virtuellen Maschine (VM) und einem Container besteht darin, dass die virtuelle Maschine eine Virtualisierung auf Hardwareebene und der Container eine Virtualisierung auf Betriebssystemebene ist.  Der VM-Hypervisor emuliert die Hardwareumgebung f√ºr jeden Computer, wobei die Container-Laufzeit bereits das Betriebssystem f√ºr jedes Objekt emuliert.  Virtuelle Maschinen teilen sich die physische Hardware des Hosts, und Container teilen sich sowohl die Hardware als auch den Betriebssystemkern.  Da Container im Allgemeinen mehr Ressourcen mit dem Host teilen, ist ihre Arbeit mit Speicher-, Speicher- und CPU-Zyklen viel effizienter als mit einer virtuellen Maschine.  Der Nachteil dieses gemeinsamen Zugriffs sind jedoch die Probleme auf der Ebene der Informationssicherheit, da zwischen den Containern und dem Host zu viel Vertrauen hergestellt wird.  Abbildung 1 zeigt den architektonischen Unterschied zwischen einem Container und einer virtuellen Maschine. <br><br><img src="https://habrastorage.org/webt/_7/qr/bk/_7qrbkpwq4ee_ep709hxsqzyl8o.png"><br><br>  Im Allgemeinen f√ºhrt die Isolierung virtualisierter Ger√§te zu einem viel st√§rkeren Sicherheitsbereich als nur die Isolierung eines Namespace.  Das Risiko, dass ein Angreifer einen isolierten Prozess erfolgreich verl√§sst, ist viel h√∂her als die Wahrscheinlichkeit, die virtuelle Maschine erfolgreich zu verlassen.  Der Grund f√ºr das h√∂here Risiko, √ºber die begrenzte Containerumgebung hinauszugehen, ist die schlechte Isolation, die durch den Namespace und die cgroups verursacht wird.  Linux implementiert sie, indem jedem Prozess neue Eigenschaftsfelder zugeordnet werden.  Diese Felder im Dateisystem <code>/proc</code> geben dem Host-Betriebssystem an, ob ein Prozess einen anderen sehen kann oder wie viel Prozessor- / Speicherressourcen ein bestimmter Prozess verwenden kann.  Wenn Sie laufende Prozesse und Threads vom √ºbergeordneten Betriebssystem aus anzeigen (z. B. den Befehl top oder ps), sieht der Containerprozess wie jeder andere aus.  In der Regel werden herk√∂mmliche L√∂sungen wie LXC oder Docker nicht als vollst√§ndig isoliert betrachtet, da sie denselben Kern auf demselben Host verwenden.  Daher ist es nicht verwunderlich, dass Container eine ausreichende Anzahl von Sicherheitsl√ºcken aufweisen.  Beispielsweise k√∂nnen CVE-2014-3519, CVE-2016-5195, CVE-2016-9962, CVE-2017-5123 und CVE-2019-5736 dazu f√ºhren, dass ein Angreifer Zugriff auf Daten au√üerhalb des Containers erh√§lt. <br><br>  Die meisten Kernel-Exploits erstellen einen Vektor f√ºr einen erfolgreichen Angriff, da sie normalerweise zu einer Eskalation von Berechtigungen f√ºhren und es einem kompromittierten Prozess erm√∂glichen, die Kontrolle au√üerhalb des beabsichtigten Namespace zu erlangen.  Neben Angriffsvektoren im Zusammenhang mit Software-Schwachstellen kann auch eine falsche Konfiguration eine Rolle spielen.  Beispielsweise kann das Bereitstellen von Images mit √ºberm√§√üigen Berechtigungen (CAP_SYS_ADMIN, privilegierter Zugriff) oder kritischen <code>/var/run/docker.sock</code> ( <code>/var/run/docker.sock</code> ) zu einem Leck f√ºhren.  Angesichts dieser potenziell katastrophalen Folgen sollten Sie das Risiko verstehen, das Sie eingehen, wenn Sie das System in einem mandantenf√§higen Bereich bereitstellen oder Container zum Speichern vertraulicher Daten verwenden. <br><br>  Diese Probleme motivieren Forscher, st√§rkere Sicherheitsbereiche zu schaffen.  Die Idee ist, einen echten Sandbox-Container zu erstellen, der so weit wie m√∂glich vom Hauptbetriebssystem isoliert ist.  Die meisten dieser L√∂sungen umfassen die Entwicklung einer Hybridarchitektur, die eine strikte Unterscheidung zwischen der Anwendung und der virtuellen Maschine verwendet und sich auf die Verbesserung der Effizienz von Containerl√∂sungen konzentriert. <br><br>  Zum Zeitpunkt des Schreibens gab es kein einziges Projekt, das als ausgereift genug bezeichnet werden konnte, um als Standard akzeptiert zu werden, aber in Zukunft werden Entwickler zweifellos einige dieser Konzepte als die wichtigsten akzeptieren. <br><br>  Wir beginnen unsere √úberpr√ºfung mit Unikernel, dem √§ltesten hochspezialisierten System, das eine Anwendung mit einem minimalen Satz von Betriebssystembibliotheken in ein Image packt.  Das Konzept von Unikernel selbst erwies sich als grundlegend f√ºr viele Projekte, deren Ziel es war, sichere, kompakte und optimierte Bilder zu erstellen.  Danach werden wir uns mit IBM Nabla befassen, einem Projekt zum Starten von Unikernel-Anwendungen, einschlie√ülich Containern.  Dar√ºber hinaus haben wir Google gVisor, ein Projekt zum Starten von Containern im User-Kernel-Bereich.  Als n√§chstes werden wir zu Containerl√∂sungen wechseln, die auf virtuellen Maschinen basieren - Amazon Firecracker und OpenStack Kata.  Um diesen Beitrag zusammenzufassen, vergleichen Sie alle oben genannten L√∂sungen. <br><br><h3>  Unikernel </h3><br>  Die Entwicklung von Virtualisierungstechnologien hat es uns erm√∂glicht, auf Cloud Computing umzusteigen.  Hypervisoren wie Xen und KVM haben den Grundstein f√ºr das gelegt, was wir heute als Amazon Web Services (AWS) und Google Cloud Platform (GCP) kennen.  Und obwohl moderne Hypervisoren mit Hunderten von virtuellen Maschinen in einem einzigen Cluster arbeiten k√∂nnen, sind herk√∂mmliche Allzweckbetriebssysteme nicht zu angepasst und optimiert, um in einer solchen Umgebung zu arbeiten.  Das Allzweck-Betriebssystem soll in erster Linie so viele verschiedene Anwendungen wie m√∂glich unterst√ºtzen und damit arbeiten. Daher umfassen ihre Kernel alle Arten von Treibern, Bibliotheken, Protokollen, Schedulern usw.  Die meisten virtuellen Maschinen, die jetzt irgendwo in der Cloud bereitgestellt werden, werden jedoch zum Ausf√ºhren einer einzelnen Anwendung verwendet, z. B. zum Bereitstellen von DNS, eines Proxys oder einer Datenbank.  Da eine solche einzelne Anwendung in ihrer Arbeit nur auf einen bestimmten und kleinen Teil des Betriebssystemkerns angewiesen ist, verschwenden alle anderen ‚ÄûR√∂cke‚Äú einfach Systemressourcen und erh√∂hen aufgrund ihrer Existenz die Anzahl der Vektoren f√ºr einen potenziellen Angriff.  Je gr√∂√üer die Codebasis ist, desto schwieriger ist es, alle M√§ngel zu beseitigen, und desto mehr potenzielle Schwachstellen, Fehler und andere Schwachstellen sind vorhanden.  Dieses Problem ermutigt Spezialisten, hochspezialisierte Betriebssysteme mit einem Mindestma√ü an Kernelfunktionalit√§t zu entwickeln, dh Tools zur Unterst√ºtzung einer bestimmten Anwendung zu erstellen. <br><br>  Zum ersten Mal wurde die Unikernel-Idee in den 90er Jahren geboren.  Dann nahm er Gestalt an als spezielles Bild einer Maschine mit einem einzigen Adressraum, der direkt auf Hypervisoren arbeiten kann.  Es packt die Kern- und Kernel-abh√§ngigen Anwendungen und Funktionen in ein einziges Image.  Nemesis und Exokernel sind die beiden fr√ºhesten Forschungsversionen des Unikernel-Projekts.  Der Verpackungs- und Bereitstellungsprozess ist in Abbildung 2 dargestellt. <br><br><img src="https://habrastorage.org/webt/lv/pl/2q/lvpl2q9eel5loxodhibvhzjc93m.png"><br>  <i>Abbildung 2. Mehrzweckbetriebssysteme, die alle Arten von Anwendungen unterst√ºtzen, sodass viele Bibliotheken und Treiber im Voraus geladen werden.</i>  <i>Unikernels sind hochspezialisierte Betriebssysteme, die eine bestimmte Anwendung unterst√ºtzen.</i> <i><br></i> <br>  Unikernel unterteilt den Kernel in mehrere Bibliotheken und f√ºgt nur die erforderlichen Komponenten in das Image ein.  Wie normale virtuelle Maschinen wird Unikernel auf dem VM-Hypervisor bereitgestellt und ausgef√ºhrt.  Aufgrund seiner geringen Gr√∂√üe kann es schnell geladen und auch schnell skaliert werden.  Die wichtigsten Funktionen von Unikernel sind erh√∂hte Sicherheit, geringer Platzbedarf, ein hohes Ma√ü an Optimierung und schnelles Laden.  Da diese Images nur anwendungsabh√§ngige Bibliotheken enthalten und auf die Betriebssystem-Shell nicht zugegriffen werden kann, wenn sie nicht absichtlich verbunden wurde, ist die Anzahl der Angriffsvektoren, die Angreifer auf ihnen verwenden k√∂nnen, minimal. <br><br>  Das hei√üt, es ist nicht nur f√ºr Angreifer schwierig, in diesen einzigartigen Kernen Fu√ü zu fassen, sondern ihr Einfluss ist auch auf eine Kerninstanz beschr√§nkt.  Da die Gr√∂√üe von Unikernel-Images nur wenige Megabyte betr√§gt, werden sie in zehn Millisekunden heruntergeladen, und buchst√§blich Hunderte von Instanzen k√∂nnen auf einem einzelnen Host ausgef√ºhrt werden.  Bei Verwendung der Speicherzuweisung im selben Adressraum anstelle einer mehrstufigen Seitentabelle, wie dies bei den meisten modernen Betriebssystemen der Fall ist, haben Unikernel-Anwendungen eine geringere Speicherzugriffsverz√∂gerung als dieselbe Anwendung, die auf einer regul√§ren virtuellen Maschine ausgef√ºhrt wird.  Da Anwendungen beim Erstellen des Images mit dem Kernel zusammenkommen, k√∂nnen Compiler einfach eine statische Typpr√ºfung durchf√ºhren, um Bin√§rdateien zu optimieren. <br><br>  Unikernel.org f√ºhrt eine Liste von Unikernel-Projekten.  Mit all seinen Besonderheiten und Eigenschaften ist Unikernel jedoch nicht weit verbreitet.  Als Docker 2016 Unikernel Systems √ºbernahm, entschied die Community, dass das Unternehmen nun Container darin verpacken w√ºrde.  Aber drei Jahre sind vergangen, und es gibt immer noch keine Anzeichen f√ºr eine Integration.  Einer der Hauptgr√ºnde f√ºr diese langsame Implementierung ist, dass es noch kein ausgereiftes Tool zum Erstellen von Unikernel-Anwendungen gibt und die meisten dieser Anwendungen nur auf bestimmten Hypervisoren funktionieren k√∂nnen.  Dar√ºber hinaus erfordert das Portieren einer Anwendung auf Unikernel m√∂glicherweise das manuelle Umschreiben von Code in anderen Sprachen, einschlie√ülich des Umschreibens abh√§ngiger Kernelbibliotheken.  Es ist auch wichtig, dass das √úberwachen oder Debuggen in Unikernels entweder unm√∂glich ist oder einen erheblichen Einfluss auf die Leistung hat. <br><br>  All diese Einschr√§nkungen hindern Entwickler daran, auf diese Technologie umzusteigen.  Es ist zu beachten, dass Unikernel und Container viele √§hnliche Eigenschaften haben.  Sowohl das erste als auch das zweite Bild sind stark fokussierte unver√§nderliche Images. Dies bedeutet, dass die darin enthaltenen Komponenten nicht aktualisiert oder repariert werden k√∂nnen. Das hei√üt, Sie m√ºssen immer ein neues Image f√ºr den Anwendungspatch erstellen.  Heute √§hnelt Unikernel dem Vorfahren von Docker: Damals war die Container-Laufzeit nicht verf√ºgbar, und Entwickler mussten die grundlegenden Tools zum Erstellen einer isolierten Anwendungsumgebung (chroot, unshare und cgroups) verwenden. <br><br><h3>  Ibm nabla </h3><br>  Einmal schlugen Forscher von IBM das Konzept von ‚ÄûUnikernel als Prozess‚Äú vor, dh die Unikernel-Anwendung, die als Prozess auf einem speziellen Hypervisor ausgef√ºhrt werden w√ºrde.  Das IBM-Projekt ‚ÄûNabla-Container‚Äú st√§rkte den Sicherheitsbereich von Unikernel und ersetzte den universellen Hypervisor (z. B. QEMU) durch eine eigene Entwicklung namens Nabla Tender.  Der Grund f√ºr diesen Ansatz ist, dass Aufrufe zwischen Unikernel und dem Hypervisor immer noch die meisten Angriffsvektoren liefern.  Aus diesem Grund kann die Verwendung eines Hypervisors f√ºr Unikernel mit weniger zul√§ssigen Systemaufrufen den Sicherheitsbereich erheblich verbessern.  Nabla Tender f√§ngt Aufrufe ab, die Unikernel an den Hypervisor weiterleitet, und √ºbersetzt sie bereits in Systemanforderungen.  Gleichzeitig blockiert die seccomp Linux-Richtlinie alle anderen Systemaufrufe, die nicht erforderlich sind, damit Tender funktioniert.  Daher wird Unikernel in Verbindung mit Nabla Tender als Prozess im Benutzerbereich des Hosts ausgef√ºhrt.  In Abbildung 3 wird gezeigt, wie Nabla eine d√ºnne Schnittstelle zwischen Unikernel und dem Host erstellt. <br><br><img src="https://habrastorage.org/webt/wy/je/p6/wyjep6mcxwfd8n-ogesrx1rnjyi.png"><br>  <i>Abbildung 3. Um Nabla mit vorhandenen Container-Laufzeitplattformen zu verkn√ºpfen, verwendet Nabla eine OCI-kompatible Umgebung, die wiederum mit Docker oder Kubernetes verbunden werden kann.</i> <br><br>  Die Entwickler behaupten, dass Nabla Tender in seiner Arbeit weniger als sieben Systemaufrufe verwendet, um mit dem Host zu interagieren.  Da Systemaufrufe als eine Art Br√ºcke zwischen Prozessen im Benutzerbereich und dem Kernel des Betriebssystems dienen, ist die Anzahl der verf√ºgbaren Vektoren f√ºr den Angriff auf den Kernel umso geringer, je weniger Systemaufrufe f√ºr uns verf√ºgbar sind.  Ein weiterer Vorteil der Ausf√ºhrung von Unikernel als Prozess besteht darin, dass Sie solche Anwendungen mit einer gro√üen Anzahl von Tools debuggen k√∂nnen, z. B. mit gdb. <br><br>  F√ºr die Arbeit mit Container-Orchestrierungsplattformen bietet Nabla eine dedizierte <code>runnc</code> , die unter Verwendung des OCI-Standards (Open Container Initiative) implementiert wird.  Letzteres definiert eine API zwischen Clients (z. B. Docker, Kubectl) und der Laufzeitumgebung (z. B. runc).  Nabla wird au√üerdem mit einem Image-Konstruktor <code>runnc</code> , den <code>runnc</code> sp√§ter ausf√ºhren kann.  Aufgrund von Unterschieden im Dateisystem zwischen Unikernels und herk√∂mmlichen Containern erf√ºllen Nabla-Images jedoch nicht die OCI-Image-Spezifikationen und daher sind Docker-Images nicht mit <code>runnc</code> kompatibel.  Zum Zeitpunkt des Schreibens befindet sich das Projekt noch in einem fr√ºhen Entwicklungsstadium.  Es gibt andere Einschr√§nkungen, z. B. die mangelnde Unterst√ºtzung f√ºr das Mounten / Zugreifen auf Host-Dateisysteme, das Hinzuf√ºgen mehrerer Netzwerkschnittstellen (f√ºr Kubernetes erforderlich) oder die Verwendung von Images von anderen Unikernel-Images (z. B. MirageOS). <br><br><h3>  Google gVisor </h3><br>  Google gVisor ist eine Sandbox-Technologie, die die Google Cloud Platform Application Engine (GCP), Cloud-Funktionen und CloudML verwendet.  Irgendwann erkannte Google das Risiko, nicht vertrauensw√ºrdige Anwendungen in der √∂ffentlichen Cloud-Infrastruktur auszuf√ºhren, und die Ineffizienz von Sandbox-Anwendungen mit virtuellen Maschinen.  Als Ergebnis wurde ein User-Space-Kernel f√ºr eine isolierte Umgebung solcher unzuverl√§ssigen Anwendungen entwickelt.  gVisor legt diese Anwendungen in der Sandbox ab, f√§ngt alle Systemaufrufe von ihnen an den Host-Kernel ab und verarbeitet sie in der Benutzerumgebung mithilfe des gVisor Sentry-Kernels.  Im Wesentlichen fungiert es als Kombination aus einem Gastkern und einem Hypervisor.  Abbildung 4 zeigt die gVisor-Architektur. <br><br><img src="https://habrastorage.org/webt/rk/xe/eq/rkxeeqqm9qs73q5enqp6zy99rfk.png"><br>  <i>Abbildung 4. Implementierung des gVisor-Kernels // Sentry- und gVisor-Gofer-Dateisysteme verwenden eine kleine Anzahl von Systemaufrufen, um mit dem Host zu interagieren</i> <br><br>  gVisor erstellt einen starken Sicherheitsbereich zwischen der Anwendung und ihrem Host.  Es begrenzt die Systemaufrufe, die Anwendungen im Benutzerbereich verwenden k√∂nnen.  Ohne sich auf Virtualisierung zu verlassen, arbeitet gVisor als Host-Prozess, der zwischen einer eigenst√§ndigen Anwendung und einem Host interagiert.  Sentry unterst√ºtzt die meisten Linux-Systemaufrufe und Kernfunktionen des Kernels wie Signal√ºbertragung, Speicherverwaltung, Netzwerkstapel und Stream-Modell.  Sentry implementiert √ºber 70% der 319 Linux-Systemaufrufe, um Sandbox-Anwendungen zu unterst√ºtzen.  Sentry verwendet jedoch weniger als 20 Linux-Systemaufrufe, um mit dem Host-Kernel zu interagieren.  Es ist erw√§hnenswert, dass gVisor und Nabla eine sehr √§hnliche Strategie verfolgen: Der Schutz des Host-Betriebssystems und beide L√∂sungen verwenden weniger als 10% der Linux-Systemaufrufe, um mit dem Kernel zu interagieren.  Sie m√ºssen jedoch verstehen, dass gVisor einen Mehrzweckkern erstellt, und Nabla beispielsweise auf eindeutige Kernel angewiesen ist.  Gleichzeitig starten beide L√∂sungen einen speziellen Gastkern im Benutzerbereich, um isolierte Anwendungen zu unterst√ºtzen, denen sie vertrauen. <br><br>  Jemand mag sich fragen, warum gVisor einen eigenen Kernel ben√∂tigt, wenn der Linux-Kernel bereits Open Source und leicht zug√§nglich ist.  ,  gVisor,   Golang,  ,   ‚Äã‚ÄãLinux,   C.           Golang.      gVisor ‚Äî    Docker, Kubernetes   OCI.   Docker        gVisor,     gVisor runsc.   Kubernetes  ¬´¬ª       gVisor    ¬´¬ª-. <br><br>  gVisor      ,     .  gVisor     ,    ,   ,       . ( ,   Nabla   ,   unikernel    . Nabla        hypercall).  gVisor     (passthrough),  ,   , ,  GPU,     . ,  gVisor   70%   Linux, ,       ,     gVisor. <br><br><h3> Amazon Firecracker </h3><br> Amazon Firecracker ‚Äî  ,     AWS Lambda  AWS Fargate.  ,   ¬´  ¬ª (MicroVM)   multi-tenant     .   Firecracker  Lambda  Fargate         EC2  ,    .            ,      ,                . Firecracker    ,   ,      .  Firecracker                ,   .       Linux     ext4      . Amazon   Firecracker  2017 ,   2018      . <br><br>   unikernel, Firecracker          .       micro-VM      ,        .  ,  micro-VM  Firecracker   5      ~125        2 CPU + 256  RAM.   5   Firecracker    . <br><br><img src="https://habrastorage.org/webt/_i/rd/qu/_irdqutnwf2v659vbsxz47igzo0.png"><br> <i> 5.  Firecracker         </i> <br><br> Firecracker   KVM,         .   Firecracker   seccomp, cgroups  namespaces,   ,  ,         .    Firecracker   . ,  API         microVM.        virtIO (  ). Firecracker        microVM: virtio-block, virtio-net, serial console  1-button  ,     microVM.               .   ,   ,   microVM  File Block Devices,       .       ,      cgroups.         ,           . <br><br>      Firecracker         Docker  Kubernetes. Firecracker      ,  ,          ,   .               .   ,     ,        OCI     . <br><br><h3> OpenStack Kata </h3><br>     ,  2015   Intel         Clear Containers. Clear Containers      Intel VT     QEMU-KVM <code>qemu-lite</code> .   2017   Clear Containers   Hyper RunV,     OCI,     Kata.    Clear Containers, Kata        . <br><br> Kata    OCI,    (CRI)    (CNI).       (, passthrough, MacVTap, bridge, tc mirroring)    ,        ,       .   6 ,      Kata     . <br><br><img src="https://habrastorage.org/webt/f0/7k/yy/f07kyyzusufaygo32ysb8hjjb-i.png"><br> <i> 6.    Kata  Docker  Kubernetes</i> <br><br>   Kata     .       Kata     Kata Shim,    API   (, docker  kubectl)         VSock.  Kata   . NEMU ‚Äî    QEMU    ~80%   . VM-Templating     Kata VM         .          ,          ,  ,  CVE-2015-2877.   ¬´ ¬ª        (, , ,  virtio),      . <br><br>  Kata  Firecracker ‚Äî   ¬´¬ª    ,    .    ,   . Firecracker ‚Äî   ,        ,      Kata ‚Äî    ,      .      Kata  Firecracker.         ,        . <br><br><h3>  Fazit </h3><br>    ,   ‚Äî        . <br><br> IBM Nabla ‚Äî     unikernel,       . <br><br> Google gVisor ‚Äî        ,         . <br><br> Amazon Firecracker ‚Äî   ,           . <br><br> OpenStack Kata ‚Äî        ,      . <br><br>  ,       ,         .             . Nabla   ,     ,   unikernel-,   MirageOS  IncludeOS. gVisor      Docker  Kubernetes,  -         . Firecracker         ,         .  Kata    OCI      KVM,     Xen.        . <br><br><img src="https://habrastorage.org/webt/50/d1/gr/50d1grnpu0ushkd6pkjl74vbeju.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es kann einige Zeit dauern, bis eine der L√∂sungen zum Standard wird, aber es ist gut, dass die meisten gro√üen Cloud-Anbieter begonnen haben, nach Wegen zu suchen, um bestehende Probleme zu l√∂sen. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457760/">https://habr.com/ru/post/de457760/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457750/index.html">Arbeiten Sie mit JSON RPC in Symfony 4</a></li>
<li><a href="../de457752/index.html">Keine Mondrover und keine Joker. Was wissen wir √ºber Roboter in Fukushima?</a></li>
<li><a href="../de457754/index.html">Staats- und T-Killer</a></li>
<li><a href="../de457756/index.html">Das Buch Kafka Streams in Aktion. Echtzeitanwendungen und Microservices ¬ª</a></li>
<li><a href="../de457758/index.html">Ingenieure retten Menschen, die im Wald verloren gegangen sind, aber der Wald hat sich noch nicht ergeben</a></li>
<li><a href="../de457762/index.html">CCD-Lineal: Womit es gegessen wird</a></li>
<li><a href="../de457764/index.html">10 Fehler der jungen PO (Teil II)</a></li>
<li><a href="../de457766/index.html">Wir generieren Kachelebenen und verstecken Quadrate vor dem Spieler</a></li>
<li><a href="../de457768/index.html">Wie ich verwundbar wurde: Scannen der IT-Infrastruktur mit Qualys</a></li>
<li><a href="../de457770/index.html">Wir schreiben benutzerdefinierte Transformatoren AST auf TypeScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>