<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎤 🕴🏻 ✌🏼 So machen Sie Container noch isolierter: eine Überprüfung der Container-Sandbox-Technologien 🙇🏻 🛃 🈴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Trotz der Tatsache, dass die meisten IT-Unternehmen Infrastrukturlösungen basierend auf Containern und Cloud-Lösungen implementieren, ist es notwendig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So machen Sie Container noch isolierter: eine Überprüfung der Container-Sandbox-Technologien</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/457760/">  Trotz der Tatsache, dass die meisten IT-Unternehmen Infrastrukturlösungen basierend auf Containern und Cloud-Lösungen implementieren, ist es notwendig, die Einschränkungen dieser Technologien zu verstehen.  Traditionell sind Docker, Linux Container (LXC) und Rocket (rkt) nicht wirklich isoliert, da sie in ihrer Arbeit den Kern des übergeordneten Betriebssystems gemeinsam nutzen.  Ja, sie sind ressourcenschonend, aber die Gesamtzahl der geschätzten Angriffsmethoden und potenziellen Verluste durch Hacking ist immer noch groß, insbesondere im Fall einer Cloud-Umgebung mit mehreren Mandanten, in der sich Container befinden. <br><br><img src="https://habrastorage.org/webt/ls/er/x_/lserx_gyy2iflakk5liv6en4yty.png"><br><br>  Die Wurzel unseres Problems liegt in der schwachen Abgrenzung von Containern in dem Moment, in dem das Host-Betriebssystem für jeden einen virtuellen Benutzerbereich erstellt.  Ja, Forschung und Entwicklung wurden durchgeführt, um echte „Container“ mit einem vollwertigen Sandkasten zu schaffen.  Die meisten der daraus resultierenden Lösungen führen zu einer Umstrukturierung der Grenzen zwischen Containern, um deren Isolation zu verbessern.  In diesem Artikel werden vier einzigartige Projekte von IBM, Google, Amazon und OpenStack vorgestellt, die unterschiedliche Methoden verwenden, um dasselbe Ziel zu erreichen: die Schaffung einer zuverlässigen Isolation.  IBM Nabla stellt Container auf Unikernel bereit, Google gVisor erstellt einen speziellen Gastkernel, Amazon Firecracker verwendet einen extrem leichten Hypervisor für Sandbox-Anwendungen und OpenStack platziert Container in einer speziellen virtuellen Maschine, die für Orchestrierungstools optimiert ist. <br><a name="habracut"></a><br><h3>  Überblick über die moderne Containertechnologie </h3><br>  Container sind eine moderne Methode zum Packen, Freigeben und Bereitstellen einer Anwendung.  Im Gegensatz zu einer monolithischen Anwendung, bei der alle Funktionen in einem Programm zusammengefasst sind, sind Containeranwendungen oder Mikrodienste für eine gezielte enge Verwendung vorgesehen und auf nur eine Aufgabe spezialisiert. <br><br>  Ein Container enthält alle Abhängigkeiten (z. B. Pakete, Bibliotheken und Binärdateien), die eine Anwendung benötigt, um ihre spezifische Aufgabe auszuführen.  Containerisierte Anwendungen sind daher plattformunabhängig und können auf jedem Betriebssystem ausgeführt werden, unabhängig von der Version oder den installierten Paketen.  Diese Bequemlichkeit erspart Entwicklern einen enormen Arbeitsaufwand bei der Anpassung verschiedener Softwareversionen für verschiedene Plattformen oder Clients.  Obwohl konzeptionell nicht ganz genau, denken viele Menschen gerne an Container als „leichte virtuelle Maschinen“. <br><br>  Wenn ein Container auf einem Host bereitgestellt wird, werden die Ressourcen jedes Containers, z. B. das Dateisystem, der Prozess und der Netzwerkstapel, in eine praktisch isolierte Umgebung gestellt, auf die andere Container nicht zugreifen können.  Diese Architektur ermöglicht die gleichzeitige Ausführung von Hunderten und Tausenden von Containern in einem einzelnen Cluster, und jede Anwendung (oder jeder Microservice) kann dann einfach skaliert werden, indem eine große Anzahl von Instanzen repliziert wird. <br><br>  In diesem Fall basiert das Containerlayout auf zwei wichtigen „Bausteinen“: dem Linux-Namespace und den Linux-Kontrollgruppen (cgroups). <br><br>  Der Namespace erstellt einen praktisch isolierten Benutzerbereich und stellt der Anwendung dedizierte Systemressourcen wie Dateisystem, Netzwerkstapel, Prozess-ID und Benutzer-ID zur Verfügung.  In diesem isolierten Benutzerbereich steuert die Anwendung das Stammverzeichnis des Dateisystems und kann als Stamm ausgeführt werden.  Dieser abstrakte Bereich ermöglicht es jeder Anwendung, unabhängig zu arbeiten, ohne andere Anwendungen auf demselben Host zu beeinträchtigen.  Derzeit sind sechs Namespaces verfügbar: Mount, Interprozesskommunikation (IPC), UNIX-Time-Sharing-System (uts), Prozess-ID (pid), Netzwerk und Benutzer.  Es wird vorgeschlagen, diese Liste durch zwei zusätzliche Namespaces zu ergänzen: time und syslog, aber die Linux-Community hat sich noch nicht für die endgültigen Spezifikationen entschieden. <br><br>  Cgroups bieten Begrenzung, Priorisierung, Anwendungsüberwachung und -steuerung für Hardwareressourcen.  Ein Beispiel für die Hardwareressourcen, die sie steuern können, sind der Prozessor, der Speicher, das Gerät und das Netzwerk.  Wenn Sie den Namespace und die cgroups kombinieren, können Sie sicher mehrere Anwendungen auf demselben Host ausführen, wobei sich jede Anwendung in einer eigenen isolierten Umgebung befindet. Dies ist die grundlegende Eigenschaft des Containers. <br><br>  Der Hauptunterschied zwischen einer virtuellen Maschine (VM) und einem Container besteht darin, dass die virtuelle Maschine eine Virtualisierung auf Hardwareebene und der Container eine Virtualisierung auf Betriebssystemebene ist.  Der VM-Hypervisor emuliert die Hardwareumgebung für jeden Computer, wobei die Container-Laufzeit bereits das Betriebssystem für jedes Objekt emuliert.  Virtuelle Maschinen teilen sich die physische Hardware des Hosts, und Container teilen sich sowohl die Hardware als auch den Betriebssystemkern.  Da Container im Allgemeinen mehr Ressourcen mit dem Host teilen, ist ihre Arbeit mit Speicher-, Speicher- und CPU-Zyklen viel effizienter als mit einer virtuellen Maschine.  Der Nachteil dieses gemeinsamen Zugriffs sind jedoch die Probleme auf der Ebene der Informationssicherheit, da zwischen den Containern und dem Host zu viel Vertrauen hergestellt wird.  Abbildung 1 zeigt den architektonischen Unterschied zwischen einem Container und einer virtuellen Maschine. <br><br><img src="https://habrastorage.org/webt/_7/qr/bk/_7qrbkpwq4ee_ep709hxsqzyl8o.png"><br><br>  Im Allgemeinen führt die Isolierung virtualisierter Geräte zu einem viel stärkeren Sicherheitsbereich als nur die Isolierung eines Namespace.  Das Risiko, dass ein Angreifer einen isolierten Prozess erfolgreich verlässt, ist viel höher als die Wahrscheinlichkeit, die virtuelle Maschine erfolgreich zu verlassen.  Der Grund für das höhere Risiko, über die begrenzte Containerumgebung hinauszugehen, ist die schlechte Isolation, die durch den Namespace und die cgroups verursacht wird.  Linux implementiert sie, indem jedem Prozess neue Eigenschaftsfelder zugeordnet werden.  Diese Felder im Dateisystem <code>/proc</code> geben dem Host-Betriebssystem an, ob ein Prozess einen anderen sehen kann oder wie viel Prozessor- / Speicherressourcen ein bestimmter Prozess verwenden kann.  Wenn Sie laufende Prozesse und Threads vom übergeordneten Betriebssystem aus anzeigen (z. B. den Befehl top oder ps), sieht der Containerprozess wie jeder andere aus.  In der Regel werden herkömmliche Lösungen wie LXC oder Docker nicht als vollständig isoliert betrachtet, da sie denselben Kern auf demselben Host verwenden.  Daher ist es nicht verwunderlich, dass Container eine ausreichende Anzahl von Sicherheitslücken aufweisen.  Beispielsweise können CVE-2014-3519, CVE-2016-5195, CVE-2016-9962, CVE-2017-5123 und CVE-2019-5736 dazu führen, dass ein Angreifer Zugriff auf Daten außerhalb des Containers erhält. <br><br>  Die meisten Kernel-Exploits erstellen einen Vektor für einen erfolgreichen Angriff, da sie normalerweise zu einer Eskalation von Berechtigungen führen und es einem kompromittierten Prozess ermöglichen, die Kontrolle außerhalb des beabsichtigten Namespace zu erlangen.  Neben Angriffsvektoren im Zusammenhang mit Software-Schwachstellen kann auch eine falsche Konfiguration eine Rolle spielen.  Beispielsweise kann das Bereitstellen von Images mit übermäßigen Berechtigungen (CAP_SYS_ADMIN, privilegierter Zugriff) oder kritischen <code>/var/run/docker.sock</code> ( <code>/var/run/docker.sock</code> ) zu einem Leck führen.  Angesichts dieser potenziell katastrophalen Folgen sollten Sie das Risiko verstehen, das Sie eingehen, wenn Sie das System in einem mandantenfähigen Bereich bereitstellen oder Container zum Speichern vertraulicher Daten verwenden. <br><br>  Diese Probleme motivieren Forscher, stärkere Sicherheitsbereiche zu schaffen.  Die Idee ist, einen echten Sandbox-Container zu erstellen, der so weit wie möglich vom Hauptbetriebssystem isoliert ist.  Die meisten dieser Lösungen umfassen die Entwicklung einer Hybridarchitektur, die eine strikte Unterscheidung zwischen der Anwendung und der virtuellen Maschine verwendet und sich auf die Verbesserung der Effizienz von Containerlösungen konzentriert. <br><br>  Zum Zeitpunkt des Schreibens gab es kein einziges Projekt, das als ausgereift genug bezeichnet werden konnte, um als Standard akzeptiert zu werden, aber in Zukunft werden Entwickler zweifellos einige dieser Konzepte als die wichtigsten akzeptieren. <br><br>  Wir beginnen unsere Überprüfung mit Unikernel, dem ältesten hochspezialisierten System, das eine Anwendung mit einem minimalen Satz von Betriebssystembibliotheken in ein Image packt.  Das Konzept von Unikernel selbst erwies sich als grundlegend für viele Projekte, deren Ziel es war, sichere, kompakte und optimierte Bilder zu erstellen.  Danach werden wir uns mit IBM Nabla befassen, einem Projekt zum Starten von Unikernel-Anwendungen, einschließlich Containern.  Darüber hinaus haben wir Google gVisor, ein Projekt zum Starten von Containern im User-Kernel-Bereich.  Als nächstes werden wir zu Containerlösungen wechseln, die auf virtuellen Maschinen basieren - Amazon Firecracker und OpenStack Kata.  Um diesen Beitrag zusammenzufassen, vergleichen Sie alle oben genannten Lösungen. <br><br><h3>  Unikernel </h3><br>  Die Entwicklung von Virtualisierungstechnologien hat es uns ermöglicht, auf Cloud Computing umzusteigen.  Hypervisoren wie Xen und KVM haben den Grundstein für das gelegt, was wir heute als Amazon Web Services (AWS) und Google Cloud Platform (GCP) kennen.  Und obwohl moderne Hypervisoren mit Hunderten von virtuellen Maschinen in einem einzigen Cluster arbeiten können, sind herkömmliche Allzweckbetriebssysteme nicht zu angepasst und optimiert, um in einer solchen Umgebung zu arbeiten.  Das Allzweck-Betriebssystem soll in erster Linie so viele verschiedene Anwendungen wie möglich unterstützen und damit arbeiten. Daher umfassen ihre Kernel alle Arten von Treibern, Bibliotheken, Protokollen, Schedulern usw.  Die meisten virtuellen Maschinen, die jetzt irgendwo in der Cloud bereitgestellt werden, werden jedoch zum Ausführen einer einzelnen Anwendung verwendet, z. B. zum Bereitstellen von DNS, eines Proxys oder einer Datenbank.  Da eine solche einzelne Anwendung in ihrer Arbeit nur auf einen bestimmten und kleinen Teil des Betriebssystemkerns angewiesen ist, verschwenden alle anderen „Röcke“ einfach Systemressourcen und erhöhen aufgrund ihrer Existenz die Anzahl der Vektoren für einen potenziellen Angriff.  Je größer die Codebasis ist, desto schwieriger ist es, alle Mängel zu beseitigen, und desto mehr potenzielle Schwachstellen, Fehler und andere Schwachstellen sind vorhanden.  Dieses Problem ermutigt Spezialisten, hochspezialisierte Betriebssysteme mit einem Mindestmaß an Kernelfunktionalität zu entwickeln, dh Tools zur Unterstützung einer bestimmten Anwendung zu erstellen. <br><br>  Zum ersten Mal wurde die Unikernel-Idee in den 90er Jahren geboren.  Dann nahm er Gestalt an als spezielles Bild einer Maschine mit einem einzigen Adressraum, der direkt auf Hypervisoren arbeiten kann.  Es packt die Kern- und Kernel-abhängigen Anwendungen und Funktionen in ein einziges Image.  Nemesis und Exokernel sind die beiden frühesten Forschungsversionen des Unikernel-Projekts.  Der Verpackungs- und Bereitstellungsprozess ist in Abbildung 2 dargestellt. <br><br><img src="https://habrastorage.org/webt/lv/pl/2q/lvpl2q9eel5loxodhibvhzjc93m.png"><br>  <i>Abbildung 2. Mehrzweckbetriebssysteme, die alle Arten von Anwendungen unterstützen, sodass viele Bibliotheken und Treiber im Voraus geladen werden.</i>  <i>Unikernels sind hochspezialisierte Betriebssysteme, die eine bestimmte Anwendung unterstützen.</i> <i><br></i> <br>  Unikernel unterteilt den Kernel in mehrere Bibliotheken und fügt nur die erforderlichen Komponenten in das Image ein.  Wie normale virtuelle Maschinen wird Unikernel auf dem VM-Hypervisor bereitgestellt und ausgeführt.  Aufgrund seiner geringen Größe kann es schnell geladen und auch schnell skaliert werden.  Die wichtigsten Funktionen von Unikernel sind erhöhte Sicherheit, geringer Platzbedarf, ein hohes Maß an Optimierung und schnelles Laden.  Da diese Images nur anwendungsabhängige Bibliotheken enthalten und auf die Betriebssystem-Shell nicht zugegriffen werden kann, wenn sie nicht absichtlich verbunden wurde, ist die Anzahl der Angriffsvektoren, die Angreifer auf ihnen verwenden können, minimal. <br><br>  Das heißt, es ist nicht nur für Angreifer schwierig, in diesen einzigartigen Kernen Fuß zu fassen, sondern ihr Einfluss ist auch auf eine Kerninstanz beschränkt.  Da die Größe von Unikernel-Images nur wenige Megabyte beträgt, werden sie in zehn Millisekunden heruntergeladen, und buchstäblich Hunderte von Instanzen können auf einem einzelnen Host ausgeführt werden.  Bei Verwendung der Speicherzuweisung im selben Adressraum anstelle einer mehrstufigen Seitentabelle, wie dies bei den meisten modernen Betriebssystemen der Fall ist, haben Unikernel-Anwendungen eine geringere Speicherzugriffsverzögerung als dieselbe Anwendung, die auf einer regulären virtuellen Maschine ausgeführt wird.  Da Anwendungen beim Erstellen des Images mit dem Kernel zusammenkommen, können Compiler einfach eine statische Typprüfung durchführen, um Binärdateien zu optimieren. <br><br>  Unikernel.org führt eine Liste von Unikernel-Projekten.  Mit all seinen Besonderheiten und Eigenschaften ist Unikernel jedoch nicht weit verbreitet.  Als Docker 2016 Unikernel Systems übernahm, entschied die Community, dass das Unternehmen nun Container darin verpacken würde.  Aber drei Jahre sind vergangen, und es gibt immer noch keine Anzeichen für eine Integration.  Einer der Hauptgründe für diese langsame Implementierung ist, dass es noch kein ausgereiftes Tool zum Erstellen von Unikernel-Anwendungen gibt und die meisten dieser Anwendungen nur auf bestimmten Hypervisoren funktionieren können.  Darüber hinaus erfordert das Portieren einer Anwendung auf Unikernel möglicherweise das manuelle Umschreiben von Code in anderen Sprachen, einschließlich des Umschreibens abhängiger Kernelbibliotheken.  Es ist auch wichtig, dass das Überwachen oder Debuggen in Unikernels entweder unmöglich ist oder einen erheblichen Einfluss auf die Leistung hat. <br><br>  All diese Einschränkungen hindern Entwickler daran, auf diese Technologie umzusteigen.  Es ist zu beachten, dass Unikernel und Container viele ähnliche Eigenschaften haben.  Sowohl das erste als auch das zweite Bild sind stark fokussierte unveränderliche Images. Dies bedeutet, dass die darin enthaltenen Komponenten nicht aktualisiert oder repariert werden können. Das heißt, Sie müssen immer ein neues Image für den Anwendungspatch erstellen.  Heute ähnelt Unikernel dem Vorfahren von Docker: Damals war die Container-Laufzeit nicht verfügbar, und Entwickler mussten die grundlegenden Tools zum Erstellen einer isolierten Anwendungsumgebung (chroot, unshare und cgroups) verwenden. <br><br><h3>  Ibm nabla </h3><br>  Einmal schlugen Forscher von IBM das Konzept von „Unikernel als Prozess“ vor, dh die Unikernel-Anwendung, die als Prozess auf einem speziellen Hypervisor ausgeführt werden würde.  Das IBM-Projekt „Nabla-Container“ stärkte den Sicherheitsbereich von Unikernel und ersetzte den universellen Hypervisor (z. B. QEMU) durch eine eigene Entwicklung namens Nabla Tender.  Der Grund für diesen Ansatz ist, dass Aufrufe zwischen Unikernel und dem Hypervisor immer noch die meisten Angriffsvektoren liefern.  Aus diesem Grund kann die Verwendung eines Hypervisors für Unikernel mit weniger zulässigen Systemaufrufen den Sicherheitsbereich erheblich verbessern.  Nabla Tender fängt Aufrufe ab, die Unikernel an den Hypervisor weiterleitet, und übersetzt sie bereits in Systemanforderungen.  Gleichzeitig blockiert die seccomp Linux-Richtlinie alle anderen Systemaufrufe, die nicht erforderlich sind, damit Tender funktioniert.  Daher wird Unikernel in Verbindung mit Nabla Tender als Prozess im Benutzerbereich des Hosts ausgeführt.  In Abbildung 3 wird gezeigt, wie Nabla eine dünne Schnittstelle zwischen Unikernel und dem Host erstellt. <br><br><img src="https://habrastorage.org/webt/wy/je/p6/wyjep6mcxwfd8n-ogesrx1rnjyi.png"><br>  <i>Abbildung 3. Um Nabla mit vorhandenen Container-Laufzeitplattformen zu verknüpfen, verwendet Nabla eine OCI-kompatible Umgebung, die wiederum mit Docker oder Kubernetes verbunden werden kann.</i> <br><br>  Die Entwickler behaupten, dass Nabla Tender in seiner Arbeit weniger als sieben Systemaufrufe verwendet, um mit dem Host zu interagieren.  Da Systemaufrufe als eine Art Brücke zwischen Prozessen im Benutzerbereich und dem Kernel des Betriebssystems dienen, ist die Anzahl der verfügbaren Vektoren für den Angriff auf den Kernel umso geringer, je weniger Systemaufrufe für uns verfügbar sind.  Ein weiterer Vorteil der Ausführung von Unikernel als Prozess besteht darin, dass Sie solche Anwendungen mit einer großen Anzahl von Tools debuggen können, z. B. mit gdb. <br><br>  Für die Arbeit mit Container-Orchestrierungsplattformen bietet Nabla eine dedizierte <code>runnc</code> , die unter Verwendung des OCI-Standards (Open Container Initiative) implementiert wird.  Letzteres definiert eine API zwischen Clients (z. B. Docker, Kubectl) und der Laufzeitumgebung (z. B. runc).  Nabla wird außerdem mit einem Image-Konstruktor <code>runnc</code> , den <code>runnc</code> später ausführen kann.  Aufgrund von Unterschieden im Dateisystem zwischen Unikernels und herkömmlichen Containern erfüllen Nabla-Images jedoch nicht die OCI-Image-Spezifikationen und daher sind Docker-Images nicht mit <code>runnc</code> kompatibel.  Zum Zeitpunkt des Schreibens befindet sich das Projekt noch in einem frühen Entwicklungsstadium.  Es gibt andere Einschränkungen, z. B. die mangelnde Unterstützung für das Mounten / Zugreifen auf Host-Dateisysteme, das Hinzufügen mehrerer Netzwerkschnittstellen (für Kubernetes erforderlich) oder die Verwendung von Images von anderen Unikernel-Images (z. B. MirageOS). <br><br><h3>  Google gVisor </h3><br>  Google gVisor ist eine Sandbox-Technologie, die die Google Cloud Platform Application Engine (GCP), Cloud-Funktionen und CloudML verwendet.  Irgendwann erkannte Google das Risiko, nicht vertrauenswürdige Anwendungen in der öffentlichen Cloud-Infrastruktur auszuführen, und die Ineffizienz von Sandbox-Anwendungen mit virtuellen Maschinen.  Als Ergebnis wurde ein User-Space-Kernel für eine isolierte Umgebung solcher unzuverlässigen Anwendungen entwickelt.  gVisor legt diese Anwendungen in der Sandbox ab, fängt alle Systemaufrufe von ihnen an den Host-Kernel ab und verarbeitet sie in der Benutzerumgebung mithilfe des gVisor Sentry-Kernels.  Im Wesentlichen fungiert es als Kombination aus einem Gastkern und einem Hypervisor.  Abbildung 4 zeigt die gVisor-Architektur. <br><br><img src="https://habrastorage.org/webt/rk/xe/eq/rkxeeqqm9qs73q5enqp6zy99rfk.png"><br>  <i>Abbildung 4. Implementierung des gVisor-Kernels // Sentry- und gVisor-Gofer-Dateisysteme verwenden eine kleine Anzahl von Systemaufrufen, um mit dem Host zu interagieren</i> <br><br>  gVisor erstellt einen starken Sicherheitsbereich zwischen der Anwendung und ihrem Host.  Es begrenzt die Systemaufrufe, die Anwendungen im Benutzerbereich verwenden können.  Ohne sich auf Virtualisierung zu verlassen, arbeitet gVisor als Host-Prozess, der zwischen einer eigenständigen Anwendung und einem Host interagiert.  Sentry unterstützt die meisten Linux-Systemaufrufe und Kernfunktionen des Kernels wie Signalübertragung, Speicherverwaltung, Netzwerkstapel und Stream-Modell.  Sentry implementiert über 70% der 319 Linux-Systemaufrufe, um Sandbox-Anwendungen zu unterstützen.  Sentry verwendet jedoch weniger als 20 Linux-Systemaufrufe, um mit dem Host-Kernel zu interagieren.  Es ist erwähnenswert, dass gVisor und Nabla eine sehr ähnliche Strategie verfolgen: Der Schutz des Host-Betriebssystems und beide Lösungen verwenden weniger als 10% der Linux-Systemaufrufe, um mit dem Kernel zu interagieren.  Sie müssen jedoch verstehen, dass gVisor einen Mehrzweckkern erstellt, und Nabla beispielsweise auf eindeutige Kernel angewiesen ist.  Gleichzeitig starten beide Lösungen einen speziellen Gastkern im Benutzerbereich, um isolierte Anwendungen zu unterstützen, denen sie vertrauen. <br><br>  Jemand mag sich fragen, warum gVisor einen eigenen Kernel benötigt, wenn der Linux-Kernel bereits Open Source und leicht zugänglich ist.  ,  gVisor,   Golang,  ,   ​​Linux,   C.           Golang.      gVisor —    Docker, Kubernetes   OCI.   Docker        gVisor,     gVisor runsc.   Kubernetes  «»       gVisor    «»-. <br><br>  gVisor      ,     .  gVisor     ,    ,   ,       . ( ,   Nabla   ,   unikernel    . Nabla        hypercall).  gVisor     (passthrough),  ,   , ,  GPU,     . ,  gVisor   70%   Linux, ,       ,     gVisor. <br><br><h3> Amazon Firecracker </h3><br> Amazon Firecracker —  ,     AWS Lambda  AWS Fargate.  ,   «  » (MicroVM)   multi-tenant     .   Firecracker  Lambda  Fargate         EC2  ,    .            ,      ,                . Firecracker    ,   ,      .  Firecracker                ,   .       Linux     ext4      . Amazon   Firecracker  2017 ,   2018      . <br><br>   unikernel, Firecracker          .       micro-VM      ,        .  ,  micro-VM  Firecracker   5      ~125        2 CPU + 256  RAM.   5   Firecracker    . <br><br><img src="https://habrastorage.org/webt/_i/rd/qu/_irdqutnwf2v659vbsxz47igzo0.png"><br> <i> 5.  Firecracker         </i> <br><br> Firecracker   KVM,         .   Firecracker   seccomp, cgroups  namespaces,   ,  ,         .    Firecracker   . ,  API         microVM.        virtIO (  ). Firecracker        microVM: virtio-block, virtio-net, serial console  1-button  ,     microVM.               .   ,   ,   microVM  File Block Devices,       .       ,      cgroups.         ,           . <br><br>      Firecracker         Docker  Kubernetes. Firecracker      ,  ,          ,   .               .   ,     ,        OCI     . <br><br><h3> OpenStack Kata </h3><br>     ,  2015   Intel         Clear Containers. Clear Containers      Intel VT     QEMU-KVM <code>qemu-lite</code> .   2017   Clear Containers   Hyper RunV,     OCI,     Kata.    Clear Containers, Kata        . <br><br> Kata    OCI,    (CRI)    (CNI).       (, passthrough, MacVTap, bridge, tc mirroring)    ,        ,       .   6 ,      Kata     . <br><br><img src="https://habrastorage.org/webt/f0/7k/yy/f07kyyzusufaygo32ysb8hjjb-i.png"><br> <i> 6.    Kata  Docker  Kubernetes</i> <br><br>   Kata     .       Kata     Kata Shim,    API   (, docker  kubectl)         VSock.  Kata   . NEMU —    QEMU    ~80%   . VM-Templating     Kata VM         .          ,          ,  ,  CVE-2015-2877.   « »        (, , ,  virtio),      . <br><br>  Kata  Firecracker —   «»    ,    .    ,   . Firecracker —   ,        ,      Kata —    ,      .      Kata  Firecracker.         ,        . <br><br><h3>  Fazit </h3><br>    ,   —        . <br><br> IBM Nabla —     unikernel,       . <br><br> Google gVisor —        ,         . <br><br> Amazon Firecracker —   ,           . <br><br> OpenStack Kata —        ,      . <br><br>  ,       ,         .             . Nabla   ,     ,   unikernel-,   MirageOS  IncludeOS. gVisor      Docker  Kubernetes,  -         . Firecracker         ,         .  Kata    OCI      KVM,     Xen.        . <br><br><img src="https://habrastorage.org/webt/50/d1/gr/50d1grnpu0ushkd6pkjl74vbeju.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es kann einige Zeit dauern, bis eine der Lösungen zum Standard wird, aber es ist gut, dass die meisten großen Cloud-Anbieter begonnen haben, nach Wegen zu suchen, um bestehende Probleme zu lösen. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457760/">https://habr.com/ru/post/de457760/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457750/index.html">Arbeiten Sie mit JSON RPC in Symfony 4</a></li>
<li><a href="../de457752/index.html">Keine Mondrover und keine Joker. Was wissen wir über Roboter in Fukushima?</a></li>
<li><a href="../de457754/index.html">Staats- und T-Killer</a></li>
<li><a href="../de457756/index.html">Das Buch Kafka Streams in Aktion. Echtzeitanwendungen und Microservices »</a></li>
<li><a href="../de457758/index.html">Ingenieure retten Menschen, die im Wald verloren gegangen sind, aber der Wald hat sich noch nicht ergeben</a></li>
<li><a href="../de457762/index.html">CCD-Lineal: Womit es gegessen wird</a></li>
<li><a href="../de457764/index.html">10 Fehler der jungen PO (Teil II)</a></li>
<li><a href="../de457766/index.html">Wir generieren Kachelebenen und verstecken Quadrate vor dem Spieler</a></li>
<li><a href="../de457768/index.html">Wie ich verwundbar wurde: Scannen der IT-Infrastruktur mit Qualys</a></li>
<li><a href="../de457770/index.html">Wir schreiben benutzerdefinierte Transformatoren AST auf TypeScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>