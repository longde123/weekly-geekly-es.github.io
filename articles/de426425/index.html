<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🎤 💟 🎰 Die ganze Wahrheit über RTOS. Artikel # 14. Speicherbereiche: Einführung und Grundversorgung 👨🏼‍🎨 🛫 ⏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Speicherabschnitte wurden bereits in einem der vorherigen Artikel (Nr. 6) erwähnt, in denen ein Vergleich mit der Standardfunktion der Sprache C mallo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit über RTOS. Artikel # 14. Speicherbereiche: Einführung und Grundversorgung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426425/"><img src="https://habrastorage.org/webt/nh/9i/nk/nh9inkxdyuljdn4wesz0e-lpjhg.jpeg"><br><br>  Speicherabschnitte wurden bereits in einem der vorherigen Artikel (Nr. 6) erwähnt, in denen ein Vergleich mit der Standardfunktion der Sprache C <b>malloc () durchgeführt wurde</b> .  Eine Partition ist ein Speicherbereich, der aus einem Partitionspool (Speicherpool) abgerufen wird.  Die gemeinsame Nutzung von Speicher bietet eine flexible Möglichkeit, Speicher zuverlässig und deterministisch zuzuweisen und freizugeben. <br><a name="habracut"></a><br>  Frühere Artikel in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterstützte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen für die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einführung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einführung.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><h2>  Abschnitte verwenden </h2><br>  In Nucleus SE werden Partitionspools zur Erstellungszeit konfiguriert.  Eine einzelne Anwendung kann bis zu 16 Partitionspools haben.  Wenn sie nicht konfiguriert sind, werden Datenstrukturen und Serviceaufrufe, die sich auf diese Pools beziehen, nicht in die Anwendung aufgenommen. <br><br>  Ein Partitionspool ist ein Speicherbereich, der in eine bestimmte Anzahl von Blöcken fester Größe unterteilt ist.  Der Entwickler kontrolliert die Größe und Anzahl der Partitionen in jedem Pool vollständig.  Aufgaben können zugewiesene Speicherabschnitte anfordern und einen Zeiger auf den Speicherbereich empfangen und sollten keine Daten außerhalb des zugewiesenen Abschnitts schreiben.  Ein Abschnitt kann von jeder Aufgabe freigegeben werden, wenn ein Zeiger auf eine API-Funktion übergeben wird.  Eine Anforderung zum Zuweisen einer Partition, wenn keine freien Partitionen vorhanden sind, kann abhängig von den ausgewählten API-Aufrufparametern und der Nucleus SE-Konfiguration zu einem Fehler oder einer Unterbrechung der Anforderung führen. <br><br><h2>  Speicherpartitionen einrichten </h2><br><h3>  Anzahl der Partitionspools </h3><br>  Wie bei den meisten Nucleus SE-Objekten erfolgt die Konfiguration des Partitionspools hauptsächlich mithilfe der Direktive <b>#define</b> in <b>nuse_config.h</b> .  Der Hauptparameter ist <b>NUSE_PARTITION_POOL_NUMBER</b> , der bestimmt, wie viele Partitionspools in der Anwendung definiert sind.  Der Standardwert ist 0 ( <b>dh</b> Partitionspools werden nicht verwendet). Der Entwickler kann einen beliebigen Wert zwischen 0 und 16 festlegen. Andere Werte führen zu einem Kompilierungsfehler, der bei der Überprüfung in <b>nuse_config_check.h festgestellt wurde</b> (er ist in <b>nuse_config.c</b> und enthalten) wird daher mit diesem Modul kompiliert), was zur Kompilierung der Direktive <b>#error führt</b> . <br><br>  Die Auswahl eines Werts ungleich Null ist eine vorrangige Methode zum Aktivieren von Partitionspools.  Dies führt zur Definition von Datenstrukturen und zur Zuordnung der entsprechenden Größe.  Die Datenstrukturen im ROM müssen mit den entsprechenden Werten initialisiert werden, die jeden Partitionspool beschreiben.  Weitere Details zu Datenstrukturen finden Sie im nächsten Artikel.  Diese Auswahl aktiviert auch die API-Einstellungen. <br><br><h3>  API-Aufrufe aktivieren </h3><br>  Jede API-Funktion (Dienstprogrammaufruf) in Nucleus SE wird durch die Direktive <b>#define</b> in <b>nuse_config.h</b> aktiviert.  Zu Partitionspools gehören: <br><br>  <b>NUSE_PARTITION_ALLOCATE</b> <br>  <b>NUSE_PARTITION_DEALLOCATE</b> <br>  <b>NUSE_PARTITION_POOL_INFORMATION</b> <br>  <b>NUSE_PARTITION_POOL_COUNT</b> <br><br>  Standardmäßig sind alle auf <b>FALSE eingestellt</b> , wodurch jeder Serviceabruf deaktiviert und die Aufnahme eines Implementierungscodes verhindert wird.  Um die Partitionspools in der Anwendung zu konfigurieren, müssen Sie die erforderlichen API-Aufrufe auswählen und die entsprechenden Anweisungen auf <b>TRUE setzen</b> . <br><br>  Das Folgende ist ein Auszug aus der Standarddatei <b>nuse_config.h</b> : <br><br><img src="https://habrastorage.org/webt/gm/ih/_b/gmih_baxfyopw1op4ujx2t2fzue.jpeg"><br><br>  Wenn die API-Funktion Partition Pools aktiviert ist, die Pools jedoch nicht konfiguriert sind, tritt ein Kompilierungsfehler auf (mit Ausnahme von <b>NUSE_Partition_Pool_Count ()</b> , das immer aktiviert ist).  Wenn Ihr Code einen API-Aufruf verwendet, der nicht aktiviert wurde, tritt ein Layoutfehler auf, da der Implementierungscode nicht in der Anwendung enthalten war. <br><br><h2>  Partition Pool Utility-Aufrufe </h2><br>  Nucleus RTOS unterstützt sieben Dienstprogrammaufrufe für Partitionspools, die die folgenden Funktionen bieten: <br><br><table><tbody><tr><th>  <b>Funktionsbeschreibung</b> </th><th>  <b>Nucleus RTOS</b> </th><th>  <b>Nucleus SE</b> </th></tr><tr><td>  Abschnittsauswahl </td><td>  <b>NU_Allocate_Partition ()</b> </td><td>  <b>NUSE_Partition_Allocate ()</b> </td></tr><tr><td>  Abschnittsfreigabe </td><td>  <b>NU_Deallocate_Partition ()</b> </td><td>  <b>NUSE_Partition_Deallocate ()</b> </td></tr><tr><td>  Bereitstellung von Informationen <br>  über einen bestimmten Partitionspool </td><td>  <b>NU_Partition_Pool_Information ()</b> </td><td>  <b>NUSE_Partition_Pool_Information ()</b> </td></tr><tr><td>  Gibt den Wert der (aktuell) konfigurierten Menge zurück <br>  Anwendungspools </td><td>  <b>NU_Established_Partition_Pools ()</b> </td><td>  <b>NUSE_Partition_Pool_Count ()</b> </td></tr><tr><td>  Hinzufügen (Erstellen) eines neuen Partitionspools zur Anwendung </td><td>  <b>NU_Create_Partition_Pool ()</b> </td><td>  Nicht implementiert. </td></tr><tr><td>  Ändern (Löschen) eines Partitionspools aus einer Anwendung </td><td>  <b>NU_Delete_Partition_Pool ()</b> </td><td>  Nicht implementiert. </td></tr><tr><td>  Rückgabe von Zeigern auf alle derzeit in der Anwendung vorhandenen Partitionspools </td><td>  <b>NU_Partition_Pool_Pointers ()</b> </td><td>  Nicht implementiert. </td></tr></tbody></table><br>  Die Implementierung jedes Aufrufs wird ausführlich besprochen. <br><br>  Es ist erwähnenswert, dass weder Nucleus RTOS noch Nucleus SE eine Neustartfunktion haben.  Dies geschieht absichtlich.  Sehr oft weist eine Aufgabe einen Abschnitt zu und übergibt einen Zeiger auf eine andere Aufgabe (die ihn möglicherweise später freigibt).  Wenn Sie den Partitionspool neu laden, werden alle Partitionen als nicht verwendet markiert. Es gibt jedoch keinen Mechanismus zum Überwachen und Benachrichtigen aller Aufgaben, die Partitionen verwenden können. <br><br><h2>  Partitions- und Release-Services </h2><br>  Die grundlegenden Operationen mit Partitionspools sind die Zuweisung von Partitionen im Pool (d. H. Markieren der Partition als verwendet und Zurückgeben ihrer Adresse) und Freigeben der Partition (d. H. Die Partition wird als nicht verwendet markiert).  Nucleus RTOS und Nucleus SE bieten zwei grundlegende API-Aufrufe für diese Vorgänge, die im Folgenden beschrieben werden. <br><br><h3>  Abschnittsauswahl </h3><br>  Das Aufrufen der Nucleus RTOS-API zum Zuweisen einer Partition ist sehr flexibel. Dadurch können Entwickler Aufgaben auf unbestimmte Zeit oder ohne Zeitüberschreitung anhalten, wenn der Vorgang nicht sofort abgeschlossen werden kann, z. B. wenn Sie versuchen, eine Partition aus einem Pool zuzuweisen, in dem alle Partitionen bereits verteilt sind.  Nucleus SE bietet denselben Service, nur das Anhalten von Aufgaben ist optional, und eine Zeitüberschreitung ist nicht implementiert. <br><br><h3>  Aufruf der Nucleus RTOS-API zur Partition </h3><br>  Prototyp aufrufen: <br><br>  <b>STATUS NU_Allocate_Partition (NU_PARTITION_POOL * -Pool, VOID ** return_pointer, UNSIGNED suspend);</b> <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_NO_PARTITION</b> - Es sind keine Abschnitte verfügbar. <br>  <b>NU_INVALID_POOL</b> - ungültiger Partitionspoolzeiger; <br>  <b>NU_INVALID_POINTER</b> - hat einen Nullzeiger auf die zurückgegebenen Daten übergeben ( <b>NULL</b> ); <br>  <b>NU_INVALID_SUSPEND</b> - Es wurde versucht, eine Aufgabe von einem Thread aus <b>anzuhalten</b> , der der Aufgabe nicht zugeordnet ist. <br>  <b>NU_TIMEOUT</b> - Auch nach dem <b>Anhalten</b> für die angegebene Wartezeit sind keine Partitionen verfügbar. <br>  <b>NU_POOL_DELETED</b> - Der Partitionspool wurde gelöscht, als die Aufgabe angehalten wurde. <br><br><h3>  Nucleus SE-API-Aufruf zum Hervorheben einer Partition </h3><br>  Dieser API-Aufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp aufrufen: <br><br>  <b>STATUS NUSE_Partition_Allocate (Pool NUSE_PARTITION_POOL, ADDR * return_pointer, U8 suspend);</b> <br><br>  Parameter: <br><br>  <b>Pool</b> - Index (ID) des verwendeten Partitionspools; <br>  <b>return_pointer</b> - Zeiger auf eine Variable vom Typ <b>ADDR</b> , die die Adresse des ausgewählten Abschnitts übernimmt; <br>  <b>suspend</b> - Parameter zum Anhalten der Aufgabe, der die Werte <b>NUSE_NO_SUSPEND</b> oder <b>NUSE_SUSPEND annehmen kann</b> . <br><br>  Rückgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_NO_PARTITION</b> - Es sind keine Abschnitte verfügbar. <br>  <b>NUSE_INVALID_POOL</b> - ungültiger Partitionspoolindex; <br>  <b>NUSE_INVALID_POINTER</b> - hat einen Nullzeiger auf die zurückgegebenen Daten übergeben ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND - Ein</b> Versuch, eine Aufgabe <b>anzuhalten</b> , wurde von einem Thread aus durchgeführt, der der Aufgabe nicht zugeordnet war oder als die Sperr-APIs deaktiviert waren. <br><br><h3>  Implementierung der Partitionszuweisung in Nucleus SE </h3><br>  Der API-Funktionscode <b>NUSE_Partition_Allocate</b> wird nach Überprüfung der Parameter mithilfe der bedingten Kompilierung ausgewählt, je nachdem, ob der API-Aufruf zum Blockieren (Anhalten von Aufgaben) aktiviert ist oder nicht.  Im Folgenden werden diese beiden Optionen separat betrachtet. <br><br>  Wenn blockierende Aufrufe deaktiviert sind, ist der API-Aufruf ziemlich einfach: <br><br><img src="https://habrastorage.org/webt/se/0i/fx/se0ifxxbybhe2mjp5owlfc2zrr0.jpeg"><br><br>  Zunächst wird die Verfügbarkeit freier Partitionen überprüft.  Wenn keine solchen Partitionen vorhanden sind, wird ein Fehler zurückgegeben ( <b>NUSE_NO_PARTITION</b> ).  Dann gibt es eine Aufzählung von Abschnitten, bei der die ersten Bytes auf Nullwerte überprüft werden (was anzeigt, dass der Abschnitt nicht verwendet wird).  Wenn eine solche Partition gefunden wird, wird ihr das Flag "used" zugewiesen, das den Index des Partitionspools enthält (siehe "Partition freigeben" weiter unten), und es wird ein Zeiger auf das nächste Byte (den Anfang des realen Datenbereichs) zurückgegeben.  Erläuterungen zu den Datenstrukturen der Partitionspools werden im nächsten Artikel im Abschnitt Datenstrukturen vorgestellt. <br><br>  Wenn die Sperre aktiviert ist, wird der Code für diesen API-Aufruf etwas komplizierter: <br><br><img src="https://habrastorage.org/webt/y_/os/bd/y_osbdsgsaqfon1cm0351zzxbxq.jpeg"><br><br>  Der Code ist in einer <b>do ... while-Schleife eingeschlossen</b> , die so lange ausgeführt wird, wie der pause-Parameter <b>NUSE_SUSPEND lautet</b> . <br><br>  Wenn keine Partitionen verfügbar sind und der Parameter pause <b>NUSE_NO_SUSPEND lautet</b> , wird der API-Aufruf <b>gestoppt</b> und <b>NUSE_NO_PARTITION zurückgegeben</b> .  Wenn der Parameter pause auf <b>NUSE_SUSPEND gesetzt wurde</b> , wird die Task <b>angehalten</b> .  Bei der Rückgabe (z. B. wenn eine Aufgabe <b>fortgesetzt wird</b> ) gibt der Rückgabewert von <b>NUSE_SUCCESS</b> an, dass die Aufgabe fortgesetzt wurde, weil der Speicherabschnitt freigegeben wurde und der Code zum Anfang der Schleife zurückkehrt.  Da es keine API-Funktionen zum erneuten Laden von Partitionspools gibt, können Aufgaben aus anderen Gründen nicht fortgesetzt werden. Aus Gründen der Stabilität beim Blockieren anderer <b>Objekttypen bleibt der</b> Validierungsprozess <b>NUSE_Task_Blocking_Return []</b> erhalten. <br><br><h3>  Abschnittsfreigabe </h3><br>  Die Veröffentlichung des Abschnitts in Nucleus RTOS und Nucleus SE macht ihn wieder verfügbar.  Vor der Veröffentlichung wird nicht geprüft, ob dieser Abschnitt von einer Aufgabe verwendet wird oder nicht. Der Anwendungsprogrammierer ist dafür verantwortlich.  Zum Freigeben eines Abschnitts ist nur ein Zeiger auf einen Datenbereich erforderlich. <br><br><h3>  Nucleus RTOS API-Aufruf zur freien Partition </h3><br>  Prototyp aufrufen: <br><br>  <b>STATUS NU_Deallocate_Partition (VOID * -Partition);</b> <br><br>  Parameter: <br><br>  <b>Partition</b> - ein Zeiger auf den Datenbereich (von der Funktion <b>NU_Allocate_Partition () zurückgegeben</b> ) der <b>freizugebenden</b> Partition; <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_POINTER</b> - NULL-Abschnittszeiger oder zeigt keinen gültigen verwendeten Abschnitt an. <br><br><h3>  Nucleus SE API-Aufruf zur freien Partition </h3><br>  Dieser API-Aufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp aufrufen: <br><br>  <b>STATUS NUSE_Partition_Deallocate (ADDR-Partition);</b> <br><br>  Parameter: <br><br>  <b>Partition</b> - Ein Zeiger auf den Datenbereich (von der Funktion <b>NUSE_Partition_Allocate () zurückgegeben</b> ) der <b>freizugebenden</b> Partition <br><br>  Rückgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_POINTER</b> - Der Abschnittszeiger ist null ( <b>NULL</b> ) oder gibt keinen gültigen verwendeten Abschnitt an <br><br><h3>  Implementierung </h3><br>  Anstatt die blockierenden und nicht blockierenden API-Funktionen zu implementieren, enthält die Funktion <b>NUSE_Partition_Deallocate ()</b> einfach einen bedingt kompilierten Abschnitt, der für das Entsperren von Aufgaben verantwortlich ist.  Dieser Code implementiert die Freigabe von Abschnitten: <br><br><img src="https://habrastorage.org/webt/sz/ro/zl/szrozlvg_xc8hbpeqmthmmdbm7a.jpeg"><br><br>  Zunächst wird der Abschnittsindex aus dem Statusbyte abgerufen.  Dann ändert sich der Status der Partition in "nicht verwendet", der Zähler der verwendeten Partitionen nimmt ab und die Funktion meldet den erfolgreichen Abschluss des Vorgangs. <br><br>  Wenn die Sperre aktiviert ist, wird der folgende Code verwendet, um Aufgaben fortzusetzen, die auf den verfügbaren Partitionspool warten: <br><br><img src="https://habrastorage.org/webt/9k/jm/3w/9kjm3wbdcj1lj6ruhimnhm67xva.jpeg"><br><br>  Wenn beim Zuweisen von Partitionen in diesem Pool Aufgaben blockiert wurden, wird die erste Tabelle fortgesetzt. <br><br>  Im nächsten Artikel werden wir über zusätzliche API-Aufrufe in Bezug auf Speicherpartitionen sowie verwandte Datenstrukturen sprechen. <br><br>  <b>Über den Autor:</b> Colin Walls ist seit über dreißig Jahren in der Elektronikindustrie tätig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht häufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier Bücher über Firmware.  Lebt in Großbritannien. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426425/">https://habr.com/ru/post/de426425/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426415/index.html">Fintech-Digest: Digitalisierungskontrolle durch die Zentralbank, Gehalt in Kryptowährung, Mir-Karte in Form von Armbändern und Schlüsselringen</a></li>
<li><a href="../de426417/index.html">Pavel 2.0: Reptilienberater auf JS, node.js mit Sockets und Telefonie</a></li>
<li><a href="../de426419/index.html">Verbotene Überlastungs- oder Bridge-Methoden in Java</a></li>
<li><a href="../de426421/index.html">EHCI menschlich auf Russisch</a></li>
<li><a href="../de426423/index.html">mmWave auf Smartphones: Wie Qualcomm das Unmögliche möglich gemacht hat</a></li>
<li><a href="../de426427/index.html">Nützliches Zeug zum "Zeug": eine kleine Auswahl mit niedrigen Preisen</a></li>
<li><a href="../de426429/index.html">Installation von FreeSWITCH 1.8 unter Debian 9 (Raspbian Stretch, das Grundimage des Smart Home-Systems von MajorDoMo auf Rasbperri Pi)</a></li>
<li><a href="../de426431/index.html">Demontage der Qlie Visual Novel Engine</a></li>
<li><a href="../de426433/index.html">Leckeres SMM für das Restaurant</a></li>
<li><a href="../de426435/index.html">Die besten Spezialisten sind diejenigen, die ich selbst vorbereitet habe: ein Spieletestkurs von Experten der Mail.Ru Group</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>