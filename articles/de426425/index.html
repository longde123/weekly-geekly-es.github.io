<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüé§ üíü üé∞ Die ganze Wahrheit √ºber RTOS. Artikel # 14. Speicherbereiche: Einf√ºhrung und Grundversorgung üë®üèº‚Äçüé® üõ´ ‚è´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Speicherabschnitte wurden bereits in einem der vorherigen Artikel (Nr. 6) erw√§hnt, in denen ein Vergleich mit der Standardfunktion der Sprache C mallo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel # 14. Speicherbereiche: Einf√ºhrung und Grundversorgung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426425/"><img src="https://habrastorage.org/webt/nh/9i/nk/nh9inkxdyuljdn4wesz0e-lpjhg.jpeg"><br><br>  Speicherabschnitte wurden bereits in einem der vorherigen Artikel (Nr. 6) erw√§hnt, in denen ein Vergleich mit der Standardfunktion der Sprache C <b>malloc () durchgef√ºhrt wurde</b> .  Eine Partition ist ein Speicherbereich, der aus einem Partitionspool (Speicherpool) abgerufen wird.  Die gemeinsame Nutzung von Speicher bietet eine flexible M√∂glichkeit, Speicher zuverl√§ssig und deterministisch zuzuweisen und freizugeben. <br><a name="habracut"></a><br>  Fr√ºhere Artikel in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterst√ºtzte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen f√ºr die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einf√ºhrung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><h2>  Abschnitte verwenden </h2><br>  In Nucleus SE werden Partitionspools zur Erstellungszeit konfiguriert.  Eine einzelne Anwendung kann bis zu 16 Partitionspools haben.  Wenn sie nicht konfiguriert sind, werden Datenstrukturen und Serviceaufrufe, die sich auf diese Pools beziehen, nicht in die Anwendung aufgenommen. <br><br>  Ein Partitionspool ist ein Speicherbereich, der in eine bestimmte Anzahl von Bl√∂cken fester Gr√∂√üe unterteilt ist.  Der Entwickler kontrolliert die Gr√∂√üe und Anzahl der Partitionen in jedem Pool vollst√§ndig.  Aufgaben k√∂nnen zugewiesene Speicherabschnitte anfordern und einen Zeiger auf den Speicherbereich empfangen und sollten keine Daten au√üerhalb des zugewiesenen Abschnitts schreiben.  Ein Abschnitt kann von jeder Aufgabe freigegeben werden, wenn ein Zeiger auf eine API-Funktion √ºbergeben wird.  Eine Anforderung zum Zuweisen einer Partition, wenn keine freien Partitionen vorhanden sind, kann abh√§ngig von den ausgew√§hlten API-Aufrufparametern und der Nucleus SE-Konfiguration zu einem Fehler oder einer Unterbrechung der Anforderung f√ºhren. <br><br><h2>  Speicherpartitionen einrichten </h2><br><h3>  Anzahl der Partitionspools </h3><br>  Wie bei den meisten Nucleus SE-Objekten erfolgt die Konfiguration des Partitionspools haupts√§chlich mithilfe der Direktive <b>#define</b> in <b>nuse_config.h</b> .  Der Hauptparameter ist <b>NUSE_PARTITION_POOL_NUMBER</b> , der bestimmt, wie viele Partitionspools in der Anwendung definiert sind.  Der Standardwert ist 0 ( <b>dh</b> Partitionspools werden nicht verwendet). Der Entwickler kann einen beliebigen Wert zwischen 0 und 16 festlegen. Andere Werte f√ºhren zu einem Kompilierungsfehler, der bei der √úberpr√ºfung in <b>nuse_config_check.h festgestellt wurde</b> (er ist in <b>nuse_config.c</b> und enthalten) wird daher mit diesem Modul kompiliert), was zur Kompilierung der Direktive <b>#error f√ºhrt</b> . <br><br>  Die Auswahl eines Werts ungleich Null ist eine vorrangige Methode zum Aktivieren von Partitionspools.  Dies f√ºhrt zur Definition von Datenstrukturen und zur Zuordnung der entsprechenden Gr√∂√üe.  Die Datenstrukturen im ROM m√ºssen mit den entsprechenden Werten initialisiert werden, die jeden Partitionspool beschreiben.  Weitere Details zu Datenstrukturen finden Sie im n√§chsten Artikel.  Diese Auswahl aktiviert auch die API-Einstellungen. <br><br><h3>  API-Aufrufe aktivieren </h3><br>  Jede API-Funktion (Dienstprogrammaufruf) in Nucleus SE wird durch die Direktive <b>#define</b> in <b>nuse_config.h</b> aktiviert.  Zu Partitionspools geh√∂ren: <br><br>  <b>NUSE_PARTITION_ALLOCATE</b> <br>  <b>NUSE_PARTITION_DEALLOCATE</b> <br>  <b>NUSE_PARTITION_POOL_INFORMATION</b> <br>  <b>NUSE_PARTITION_POOL_COUNT</b> <br><br>  Standardm√§√üig sind alle auf <b>FALSE eingestellt</b> , wodurch jeder Serviceabruf deaktiviert und die Aufnahme eines Implementierungscodes verhindert wird.  Um die Partitionspools in der Anwendung zu konfigurieren, m√ºssen Sie die erforderlichen API-Aufrufe ausw√§hlen und die entsprechenden Anweisungen auf <b>TRUE setzen</b> . <br><br>  Das Folgende ist ein Auszug aus der Standarddatei <b>nuse_config.h</b> : <br><br><img src="https://habrastorage.org/webt/gm/ih/_b/gmih_baxfyopw1op4ujx2t2fzue.jpeg"><br><br>  Wenn die API-Funktion Partition Pools aktiviert ist, die Pools jedoch nicht konfiguriert sind, tritt ein Kompilierungsfehler auf (mit Ausnahme von <b>NUSE_Partition_Pool_Count ()</b> , das immer aktiviert ist).  Wenn Ihr Code einen API-Aufruf verwendet, der nicht aktiviert wurde, tritt ein Layoutfehler auf, da der Implementierungscode nicht in der Anwendung enthalten war. <br><br><h2>  Partition Pool Utility-Aufrufe </h2><br>  Nucleus RTOS unterst√ºtzt sieben Dienstprogrammaufrufe f√ºr Partitionspools, die die folgenden Funktionen bieten: <br><br><table><tbody><tr><th>  <b>Funktionsbeschreibung</b> </th><th>  <b>Nucleus RTOS</b> </th><th>  <b>Nucleus SE</b> </th></tr><tr><td>  Abschnittsauswahl </td><td>  <b>NU_Allocate_Partition ()</b> </td><td>  <b>NUSE_Partition_Allocate ()</b> </td></tr><tr><td>  Abschnittsfreigabe </td><td>  <b>NU_Deallocate_Partition ()</b> </td><td>  <b>NUSE_Partition_Deallocate ()</b> </td></tr><tr><td>  Bereitstellung von Informationen <br>  √ºber einen bestimmten Partitionspool </td><td>  <b>NU_Partition_Pool_Information ()</b> </td><td>  <b>NUSE_Partition_Pool_Information ()</b> </td></tr><tr><td>  Gibt den Wert der (aktuell) konfigurierten Menge zur√ºck <br>  Anwendungspools </td><td>  <b>NU_Established_Partition_Pools ()</b> </td><td>  <b>NUSE_Partition_Pool_Count ()</b> </td></tr><tr><td>  Hinzuf√ºgen (Erstellen) eines neuen Partitionspools zur Anwendung </td><td>  <b>NU_Create_Partition_Pool ()</b> </td><td>  Nicht implementiert. </td></tr><tr><td>  √Ñndern (L√∂schen) eines Partitionspools aus einer Anwendung </td><td>  <b>NU_Delete_Partition_Pool ()</b> </td><td>  Nicht implementiert. </td></tr><tr><td>  R√ºckgabe von Zeigern auf alle derzeit in der Anwendung vorhandenen Partitionspools </td><td>  <b>NU_Partition_Pool_Pointers ()</b> </td><td>  Nicht implementiert. </td></tr></tbody></table><br>  Die Implementierung jedes Aufrufs wird ausf√ºhrlich besprochen. <br><br>  Es ist erw√§hnenswert, dass weder Nucleus RTOS noch Nucleus SE eine Neustartfunktion haben.  Dies geschieht absichtlich.  Sehr oft weist eine Aufgabe einen Abschnitt zu und √ºbergibt einen Zeiger auf eine andere Aufgabe (die ihn m√∂glicherweise sp√§ter freigibt).  Wenn Sie den Partitionspool neu laden, werden alle Partitionen als nicht verwendet markiert. Es gibt jedoch keinen Mechanismus zum √úberwachen und Benachrichtigen aller Aufgaben, die Partitionen verwenden k√∂nnen. <br><br><h2>  Partitions- und Release-Services </h2><br>  Die grundlegenden Operationen mit Partitionspools sind die Zuweisung von Partitionen im Pool (d. H. Markieren der Partition als verwendet und Zur√ºckgeben ihrer Adresse) und Freigeben der Partition (d. H. Die Partition wird als nicht verwendet markiert).  Nucleus RTOS und Nucleus SE bieten zwei grundlegende API-Aufrufe f√ºr diese Vorg√§nge, die im Folgenden beschrieben werden. <br><br><h3>  Abschnittsauswahl </h3><br>  Das Aufrufen der Nucleus RTOS-API zum Zuweisen einer Partition ist sehr flexibel. Dadurch k√∂nnen Entwickler Aufgaben auf unbestimmte Zeit oder ohne Zeit√ºberschreitung anhalten, wenn der Vorgang nicht sofort abgeschlossen werden kann, z. B. wenn Sie versuchen, eine Partition aus einem Pool zuzuweisen, in dem alle Partitionen bereits verteilt sind.  Nucleus SE bietet denselben Service, nur das Anhalten von Aufgaben ist optional, und eine Zeit√ºberschreitung ist nicht implementiert. <br><br><h3>  Aufruf der Nucleus RTOS-API zur Partition </h3><br>  Prototyp aufrufen: <br><br>  <b>STATUS NU_Allocate_Partition (NU_PARTITION_POOL * -Pool, VOID ** return_pointer, UNSIGNED suspend);</b> <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_NO_PARTITION</b> - Es sind keine Abschnitte verf√ºgbar. <br>  <b>NU_INVALID_POOL</b> - ung√ºltiger Partitionspoolzeiger; <br>  <b>NU_INVALID_POINTER</b> - hat einen Nullzeiger auf die zur√ºckgegebenen Daten √ºbergeben ( <b>NULL</b> ); <br>  <b>NU_INVALID_SUSPEND</b> - Es wurde versucht, eine Aufgabe von einem Thread aus <b>anzuhalten</b> , der der Aufgabe nicht zugeordnet ist. <br>  <b>NU_TIMEOUT</b> - Auch nach dem <b>Anhalten</b> f√ºr die angegebene Wartezeit sind keine Partitionen verf√ºgbar. <br>  <b>NU_POOL_DELETED</b> - Der Partitionspool wurde gel√∂scht, als die Aufgabe angehalten wurde. <br><br><h3>  Nucleus SE-API-Aufruf zum Hervorheben einer Partition </h3><br>  Dieser API-Aufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp aufrufen: <br><br>  <b>STATUS NUSE_Partition_Allocate (Pool NUSE_PARTITION_POOL, ADDR * return_pointer, U8 suspend);</b> <br><br>  Parameter: <br><br>  <b>Pool</b> - Index (ID) des verwendeten Partitionspools; <br>  <b>return_pointer</b> - Zeiger auf eine Variable vom Typ <b>ADDR</b> , die die Adresse des ausgew√§hlten Abschnitts √ºbernimmt; <br>  <b>suspend</b> - Parameter zum Anhalten der Aufgabe, der die Werte <b>NUSE_NO_SUSPEND</b> oder <b>NUSE_SUSPEND annehmen kann</b> . <br><br>  R√ºckgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_NO_PARTITION</b> - Es sind keine Abschnitte verf√ºgbar. <br>  <b>NUSE_INVALID_POOL</b> - ung√ºltiger Partitionspoolindex; <br>  <b>NUSE_INVALID_POINTER</b> - hat einen Nullzeiger auf die zur√ºckgegebenen Daten √ºbergeben ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND - Ein</b> Versuch, eine Aufgabe <b>anzuhalten</b> , wurde von einem Thread aus durchgef√ºhrt, der der Aufgabe nicht zugeordnet war oder als die Sperr-APIs deaktiviert waren. <br><br><h3>  Implementierung der Partitionszuweisung in Nucleus SE </h3><br>  Der API-Funktionscode <b>NUSE_Partition_Allocate</b> wird nach √úberpr√ºfung der Parameter mithilfe der bedingten Kompilierung ausgew√§hlt, je nachdem, ob der API-Aufruf zum Blockieren (Anhalten von Aufgaben) aktiviert ist oder nicht.  Im Folgenden werden diese beiden Optionen separat betrachtet. <br><br>  Wenn blockierende Aufrufe deaktiviert sind, ist der API-Aufruf ziemlich einfach: <br><br><img src="https://habrastorage.org/webt/se/0i/fx/se0ifxxbybhe2mjp5owlfc2zrr0.jpeg"><br><br>  Zun√§chst wird die Verf√ºgbarkeit freier Partitionen √ºberpr√ºft.  Wenn keine solchen Partitionen vorhanden sind, wird ein Fehler zur√ºckgegeben ( <b>NUSE_NO_PARTITION</b> ).  Dann gibt es eine Aufz√§hlung von Abschnitten, bei der die ersten Bytes auf Nullwerte √ºberpr√ºft werden (was anzeigt, dass der Abschnitt nicht verwendet wird).  Wenn eine solche Partition gefunden wird, wird ihr das Flag "used" zugewiesen, das den Index des Partitionspools enth√§lt (siehe "Partition freigeben" weiter unten), und es wird ein Zeiger auf das n√§chste Byte (den Anfang des realen Datenbereichs) zur√ºckgegeben.  Erl√§uterungen zu den Datenstrukturen der Partitionspools werden im n√§chsten Artikel im Abschnitt Datenstrukturen vorgestellt. <br><br>  Wenn die Sperre aktiviert ist, wird der Code f√ºr diesen API-Aufruf etwas komplizierter: <br><br><img src="https://habrastorage.org/webt/y_/os/bd/y_osbdsgsaqfon1cm0351zzxbxq.jpeg"><br><br>  Der Code ist in einer <b>do ... while-Schleife eingeschlossen</b> , die so lange ausgef√ºhrt wird, wie der pause-Parameter <b>NUSE_SUSPEND lautet</b> . <br><br>  Wenn keine Partitionen verf√ºgbar sind und der Parameter pause <b>NUSE_NO_SUSPEND lautet</b> , wird der API-Aufruf <b>gestoppt</b> und <b>NUSE_NO_PARTITION zur√ºckgegeben</b> .  Wenn der Parameter pause auf <b>NUSE_SUSPEND gesetzt wurde</b> , wird die Task <b>angehalten</b> .  Bei der R√ºckgabe (z. B. wenn eine Aufgabe <b>fortgesetzt wird</b> ) gibt der R√ºckgabewert von <b>NUSE_SUCCESS</b> an, dass die Aufgabe fortgesetzt wurde, weil der Speicherabschnitt freigegeben wurde und der Code zum Anfang der Schleife zur√ºckkehrt.  Da es keine API-Funktionen zum erneuten Laden von Partitionspools gibt, k√∂nnen Aufgaben aus anderen Gr√ºnden nicht fortgesetzt werden. Aus Gr√ºnden der Stabilit√§t beim Blockieren anderer <b>Objekttypen bleibt der</b> Validierungsprozess <b>NUSE_Task_Blocking_Return []</b> erhalten. <br><br><h3>  Abschnittsfreigabe </h3><br>  Die Ver√∂ffentlichung des Abschnitts in Nucleus RTOS und Nucleus SE macht ihn wieder verf√ºgbar.  Vor der Ver√∂ffentlichung wird nicht gepr√ºft, ob dieser Abschnitt von einer Aufgabe verwendet wird oder nicht. Der Anwendungsprogrammierer ist daf√ºr verantwortlich.  Zum Freigeben eines Abschnitts ist nur ein Zeiger auf einen Datenbereich erforderlich. <br><br><h3>  Nucleus RTOS API-Aufruf zur freien Partition </h3><br>  Prototyp aufrufen: <br><br>  <b>STATUS NU_Deallocate_Partition (VOID * -Partition);</b> <br><br>  Parameter: <br><br>  <b>Partition</b> - ein Zeiger auf den Datenbereich (von der Funktion <b>NU_Allocate_Partition () zur√ºckgegeben</b> ) der <b>freizugebenden</b> Partition; <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_POINTER</b> - NULL-Abschnittszeiger oder zeigt keinen g√ºltigen verwendeten Abschnitt an. <br><br><h3>  Nucleus SE API-Aufruf zur freien Partition </h3><br>  Dieser API-Aufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp aufrufen: <br><br>  <b>STATUS NUSE_Partition_Deallocate (ADDR-Partition);</b> <br><br>  Parameter: <br><br>  <b>Partition</b> - Ein Zeiger auf den Datenbereich (von der Funktion <b>NUSE_Partition_Allocate () zur√ºckgegeben</b> ) der <b>freizugebenden</b> Partition <br><br>  R√ºckgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_POINTER</b> - Der Abschnittszeiger ist null ( <b>NULL</b> ) oder gibt keinen g√ºltigen verwendeten Abschnitt an <br><br><h3>  Implementierung </h3><br>  Anstatt die blockierenden und nicht blockierenden API-Funktionen zu implementieren, enth√§lt die Funktion <b>NUSE_Partition_Deallocate ()</b> einfach einen bedingt kompilierten Abschnitt, der f√ºr das Entsperren von Aufgaben verantwortlich ist.  Dieser Code implementiert die Freigabe von Abschnitten: <br><br><img src="https://habrastorage.org/webt/sz/ro/zl/szrozlvg_xc8hbpeqmthmmdbm7a.jpeg"><br><br>  Zun√§chst wird der Abschnittsindex aus dem Statusbyte abgerufen.  Dann √§ndert sich der Status der Partition in "nicht verwendet", der Z√§hler der verwendeten Partitionen nimmt ab und die Funktion meldet den erfolgreichen Abschluss des Vorgangs. <br><br>  Wenn die Sperre aktiviert ist, wird der folgende Code verwendet, um Aufgaben fortzusetzen, die auf den verf√ºgbaren Partitionspool warten: <br><br><img src="https://habrastorage.org/webt/9k/jm/3w/9kjm3wbdcj1lj6ruhimnhm67xva.jpeg"><br><br>  Wenn beim Zuweisen von Partitionen in diesem Pool Aufgaben blockiert wurden, wird die erste Tabelle fortgesetzt. <br><br>  Im n√§chsten Artikel werden wir √ºber zus√§tzliche API-Aufrufe in Bezug auf Speicherpartitionen sowie verwandte Datenstrukturen sprechen. <br><br>  <b>√úber den Autor:</b> Colin Walls ist seit √ºber drei√üig Jahren in der Elektronikindustrie t√§tig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht h√§ufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier B√ºcher √ºber Firmware.  Lebt in Gro√übritannien. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426425/">https://habr.com/ru/post/de426425/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426415/index.html">Fintech-Digest: Digitalisierungskontrolle durch die Zentralbank, Gehalt in Kryptow√§hrung, Mir-Karte in Form von Armb√§ndern und Schl√ºsselringen</a></li>
<li><a href="../de426417/index.html">Pavel 2.0: Reptilienberater auf JS, node.js mit Sockets und Telefonie</a></li>
<li><a href="../de426419/index.html">Verbotene √úberlastungs- oder Bridge-Methoden in Java</a></li>
<li><a href="../de426421/index.html">EHCI menschlich auf Russisch</a></li>
<li><a href="../de426423/index.html">mmWave auf Smartphones: Wie Qualcomm das Unm√∂gliche m√∂glich gemacht hat</a></li>
<li><a href="../de426427/index.html">N√ºtzliches Zeug zum "Zeug": eine kleine Auswahl mit niedrigen Preisen</a></li>
<li><a href="../de426429/index.html">Installation von FreeSWITCH 1.8 unter Debian 9 (Raspbian Stretch, das Grundimage des Smart Home-Systems von MajorDoMo auf Rasbperri Pi)</a></li>
<li><a href="../de426431/index.html">Demontage der Qlie Visual Novel Engine</a></li>
<li><a href="../de426433/index.html">Leckeres SMM f√ºr das Restaurant</a></li>
<li><a href="../de426435/index.html">Die besten Spezialisten sind diejenigen, die ich selbst vorbereitet habe: ein Spieletestkurs von Experten der Mail.Ru Group</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>