<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰🏼 📕 👨🏻‍🏭 Comment faire fonctionner le jeu à 60 images par seconde 🍇 👧 🍇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imaginez le problème: vous avez un jeu et vous en avez besoin pour fonctionner à 60 ips sur un moniteur à 60 Hz. Votre ordinateur est assez rapide pou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment faire fonctionner le jeu à 60 images par seconde</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442528/">  Imaginez le problème: vous avez un jeu et vous en avez besoin pour fonctionner à 60 ips sur un moniteur à 60 Hz.  Votre ordinateur est assez rapide pour le rendu et la mise à jour pour prendre un temps insignifiant, donc vous activez vsync et écrivez cette boucle de jeu: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { update(); render(); display(); }</code> </pre> <br>  Très simple!  Maintenant, le jeu fonctionne à 60 images par seconde et tout se passe comme sur des roulettes.  C'est fait.  Merci d'avoir lu ce post. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ae/57e/bf1/0ae57ebf1f1695e4ecbcafddcb4255bb.jpg"></div><br>  Eh bien, évidemment, tout n'est pas si bon.  Et si quelqu'un a un ordinateur faible qui ne peut pas rendre le jeu à une vitesse suffisante pour fournir 60 images par seconde?  Et si quelqu'un achetait un de ces nouveaux moniteurs 144 hertz sympas?  Et s'il a désactivé vsync dans les paramètres du pilote? <br><a name="habracut"></a><br>  Vous pourriez penser: j'ai besoin de mesurer le temps quelque part et de fournir une mise à jour avec la bonne fréquence.  C'est assez simple - il suffit d'accumuler du temps à chaque cycle et de mettre à jour chaque fois qu'il dépasse le seuil de 1/60 de seconde. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { deltaTime = CurrentTime()-OldTime; oldTime = CurrentTime(); accumulator += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; } render(); display(); }</code> </pre> <br>  Fait, nulle part plus facile.  En fait, il existe un tas de jeux dans lesquels le code ressemble essentiellement à cela.  Mais c'est faux.  Cela convient pour régler les horaires, mais entraîne des problèmes de secousses (bégaiement) et d'autres décalages.  Un tel problème est très courant: les images ne sont pas affichées exactement 1/60 de seconde;  même lorsque vsync est activé, il y a toujours un peu de bruit dans le temps où ils sont affichés (et dans la précision de la minuterie du système d'exploitation).  Par conséquent, il y aura des situations où vous rendrez une image, et le jeu estime que le temps de la mise à jour n'est pas encore arrivé (car la batterie est en retard d'une petite fraction), donc il répète simplement la même image, mais maintenant le jeu est en retard pour l'image, donc il double mise à jour.  Voici les contractions! <br><br>  Sur Google, vous pouvez trouver plusieurs solutions prêtes à l'emploi pour éliminer ces contractions.  Par exemple, un jeu peut utiliser une variable plutôt qu'un pas de temps constant, et simplement abandonner complètement les batteries dans le code temporel.  Ou vous pouvez implémenter un pas de temps constant avec un rendu d'interpolation, décrit dans un article assez célèbre " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Fix Your Timestep</a> " par Glenn Fielder.  Ou vous pouvez refaire le code de la minuterie afin qu'il soit un peu plus flexible, comme décrit dans le post de Slick Entertainment's <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20171206005813/" rel="nofollow noopener">Frame Timing Issues</a> (malheureusement, ce blog n'est plus là). <br><br><hr><br><h3>  Timings flous </h3><br>  La méthode Slick Entertainment avec des «timings flous» dans mon moteur était la plus facile à implémenter, car elle ne nécessitait pas de changements dans la logique du jeu et le rendu.  Donc dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">The End is Nigh,</a> je l'ai utilisé.  Il suffisait juste de l'insérer dans le moteur.  En fait, cela permet simplement de mettre à jour le jeu «un peu plus tôt» pour éviter les problèmes de décalage temporel.  Si le jeu comprend vsync, il vous permet simplement d'utiliser vsync comme minuteur principal du jeu et fournit une image fluide. <br><br>  Voici à quoi ressemble le code de mise à jour (le jeu "peut fonctionner" à 62 images par seconde, mais traite toujours chaque pas de temps comme s'il fonctionnait à 60 images par seconde. Je ne comprends pas très bien pourquoi le limiter afin que les valeurs de la batterie ne tombent pas en dessous de 0, mais sans ce code ne fonctionne pas).  Vous pouvez l'interpréter de cette façon: "le jeu est mis à jour avec un pas fixe, s'il est rendu dans l'intervalle de 60fps à 62fps": <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">62.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Si vsync est activé, il permet essentiellement au jeu de fonctionner avec une hauteur fixe, qui correspond au taux de rafraîchissement du moniteur, et fournit une image fluide.  Le principal problème ici est que lorsque vsync est désactivé, le jeu fonctionnera un <i>peu</i> plus vite, mais la différence est si insignifiante que personne ne le remarquera. <br><br>  Coureurs de vitesse.  Les coureurs de vitesse le remarqueront.  Peu de temps après la sortie du jeu, ils ont remarqué que certaines personnes sur les listes de meilleurs scores de speedran avaient des temps de voyage moins bons, mais cela s'est avéré meilleur que d'autres.  Et la raison immédiate de cela était le timing imprécis et la déconnexion de vsync dans le jeu (ou les moniteurs 144 Hz).  Par conséquent, il est devenu évident que vous devez désactiver ce flou lors de la déconnexion de vsync. <br><br>  Oh, mais nous ne pouvons toujours pas vérifier si vsync est désactivé.  Il n'y a aucun appel à cela dans le système d'exploitation, et bien que nous puissions demander à l'application d'activer ou de désactiver vsync, en fait, cela dépend complètement du système d'exploitation et du pilote graphique.  La seule chose qui peut être faite est de rendre un ensemble d'images, d'essayer de mesurer le temps d'exécution de cette tâche, puis de comparer si elles prennent environ le même temps.  C'est exactement ce que j'ai fait pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">The End is Nigh</a> .  Si le jeu n'inclut pas vsync avec une fréquence de 60 Hz, alors il revient à la temporisation d'image d'origine avec "60 images par seconde strictes".  De plus, j'ai ajouté un paramètre au fichier de configuration qui oblige le jeu à ne pas utiliser de flou (principalement pour les coureurs de vitesse qui ont besoin de temps précis) et j'ai ajouté un gestionnaire de minuterie dans le jeu exact pour eux, ce qui permet d'utiliser l'échantillonneur automatique (c'est un script qui fonctionne avec une minuterie atomique). <br><br>  Certains utilisateurs se plaignaient toujours des secousses occasionnelles de trames individuelles, mais elles semblaient si rares qu'elles pouvaient être expliquées par des événements du système d'exploitation ou d'autres raisons externes.  Pas grave.  Non? <br><br>  En parcourant récemment mon code de minuterie, j'ai remarqué quelque chose d'étrange.  La batterie a été déplacée, chaque image a pris un peu plus de 1/60 seconde, donc de temps en temps le jeu pensait qu'il était tard pour l'image et effectuait une double mise à jour.  Il s'est avéré que mon moniteur fonctionne avec une fréquence de 59,94 Hz et non 60 Hz.  Cela signifiait que tous les 1000 images, il devait effectuer une double mise à jour afin de «rattraper».  Cependant, cela est très simple à corriger - il suffit de changer l'intervalle des fréquences de trame autorisées (pas de 60 à 62, mais de 59 à 61). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">61.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">59.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Le problème décrit ci-dessus avec des moniteurs vsync et haute fréquence déconnectés persiste toujours, et la même solution s'applique à lui (restauration du temporisateur strict si le moniteur n'est <i>pas</i> synchronisé vsync par 60). <br><br>  Mais comment savoir si c'est la bonne solution?  Comment s'assurer qu'il fonctionnera correctement sur toutes les combinaisons d'ordinateurs avec différents types de moniteurs, avec et sans vsync activé, etc.?  Il est très difficile de garder une trace de tous ces problèmes de minuterie dans la tête et de comprendre ce qui cause la désynchronisation, les boucles étranges et autres. <br><br><h3>  Simulateur de moniteur </h3><br>  En essayant de trouver une solution fiable au «problème du moniteur 59,94 hertz», je me suis rendu compte que je ne pouvais pas simplement effectuer des vérifications d’essai et d’erreur, dans l’espoir de trouver une solution fiable.  J'avais besoin d'un moyen pratique pour tester différentes tentatives d'écriture d'une minuterie de haute qualité et d'un moyen facile de vérifier si cela provoque une secousse ou un décalage temporel dans différentes configurations de moniteur. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Monitor Simulator</a> apparaît sur la scène.  C'est le code «sale et rapide» que j'ai écrit, simulant le «fonctionnement du moniteur», et me montrant essentiellement un tas de chiffres qui donnent une idée de la stabilité de chaque minuterie testée. <br><br>  Par exemple, pour le minuteur le plus simple, les valeurs suivantes sont affichées depuis le début de l'article: <br><br> <code>20211012021011202111020211102012012102012[...] <br> TOTAL UPDATES: 10001 <br> TOTAL VSYNCS: 10002 <br> TOTAL DOUBLE UPDATES: 2535 <br> TOTAL SKIPPED RENDERS: 0 <br> GAME TIME: 166.683 <br> SYSTEM TIME: 166.7</code> <br> <br>  Tout d'abord, le code affiche pour chaque vsync émulé le nombre du nombre de "mises à jour" du cycle de jeu après le vsync précédent.  Toute valeur autre que solide 1 conduit à une image instable.  À la fin, le code affiche les statistiques accumulées. <br><br>  Lorsque vous utilisez la «minuterie floue» (avec un intervalle de 60 à 62 ips) sur un moniteur de 59,94 Hertz, le code affiche les éléments suivants: <br><br> <code>111111111111111111111111111111111111111111111[...] <br> TOTAL UPDATES: 10000 <br> TOTAL VSYNCS: 9991 <br> TOTAL DOUBLE UPDATES: 10 <br> TOTAL SKIPPED RENDERS: 0 <br> GAME TIME: 166.667 <br> SYSTEM TIME: 166.683</code> <br> <br>  Les secousses du cadre sont très rares, il peut donc être difficile de le remarquer avec un tel nombre de 1. Mais les statistiques affichées montrent clairement que le jeu a effectué plusieurs doubles mises à jour ici, ce qui conduit à des secousses.  Dans la version fixe (avec un intervalle de 59 à 61 ips), il y a 0 mises à jour ignorées ou doubles. <br><br>  Vous pouvez également désactiver vsync.  Le reste des données statistiques devient sans importance, mais cela me montre clairement l'ampleur du «décalage temporel» (le décalage temporel du système par rapport à l'emplacement du temps de jeu). <br><br> <code>GAME TIME: 166.667 <br> SYSTEM TIME: 169.102</code> <br> <br>  C'est pourquoi lorsque vsync est désactivé, vous devez passer à une minuterie stricte, sinon ces écarts s'accumulent avec le temps. <br><br>  Si je règle le temps de rendu sur .02 (c'est-à-dire que «plus d'un cadre» est nécessaire pour le rendu), j'obtiendrai un contraction.  Idéalement, le modèle de jeu devrait ressembler à 202020202020, mais il est un peu inégal. <br><br>  Dans cette situation, ce minuteur se comporte un peu mieux que le précédent, mais il devient plus déroutant et plus difficile de comprendre comment et pourquoi il fonctionne.  Mais je peux simplement mettre les tests dans ce simulateur et vérifier leur comportement, et vous pourrez en comprendre les raisons plus tard.  Essais et erreurs, bébé! <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">61.0</span></span>){ simulate_update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">59.0</span></span>–<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Vous pouvez télécharger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">un simulateur de moniteur</a> et vérifier indépendamment différentes méthodes de calcul de synchronisation.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Envoyez-moi un e-mail</a> si vous trouvez quelque chose de mieux. <br><br>  Je ne suis pas 100% satisfait de ma décision (cela nécessite toujours un hack avec «reconnaissance vsync» et des secousses occasionnelles peuvent se produire pendant la désynchronisation), mais je pense que c'est presque aussi bon qu'une tentative de mise en œuvre d'un cycle de jeu avec une étape fixe.  Une partie de ce problème se pose car il est très difficile de déterminer les paramètres de ce qui est considéré comme «acceptable» ici.  La principale difficulté réside dans le compromis entre décalage temporel et images doubles / sautées.  Si vous exécutez un jeu à 60 Hz sur un moniteur PAL à 50 Hz ... quelle sera la bonne décision?  Voulez-vous des secousses sauvages ou un jeu sensiblement plus lent?  Les deux options semblent mauvaises. <br><br><h3>  Rendu séparé </h3><br>  Dans les méthodes précédentes, j'ai décrit ce que j'appelle le «rendu lockstep».  Le jeu met à jour son état, puis le rend, et lors du rendu, il affiche toujours l'état le plus récent du jeu.  Le rendu et la mise à jour sont connectés ensemble. <br><br>  Mais vous pouvez les séparer.  C'est exactement ce que fait la méthode décrite dans le message " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Fix Your Timestep</a> ".  Je ne vais pas me répéter, vous devriez certainement lire cet article.  Ceci (si je comprends bien) est le «standard de l'industrie» utilisé dans les jeux et moteurs AAA tels que Unity et Unreal (cependant, dans les jeux actifs 2D intenses, ils préfèrent généralement utiliser une étape fixe (lockstep), car parfois la précision qui vous donne cette méthode). <br><br>  Mais si nous décrivons brièvement le post de Glenn, il décrit simplement la méthode de mise à jour avec une fréquence d'images fixe, mais lors du rendu, l'interpolation est effectuée entre l'état "actuel" et "précédent" du jeu, et la valeur actuelle de la batterie est utilisée comme valeur d'interpolation.  Avec cette méthode, vous pouvez effectuer un rendu à n'importe quelle fréquence d'images et mettre à jour le jeu à n'importe quelle fréquence, et l'image sera toujours fluide.  Pas de secousses, fonctionne universellement. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running){ computeDeltaTimeSomehow(); accumulator += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>){ previous_state = current_state; current_state = update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; } render_interpolated_somehow(previous_state, current_state, accumulator/(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>)); display(); }</code> </pre> <br>  Donc, élémentaire.  Le problème est résolu. <br><br>  Maintenant, vous devez juste vous assurer que le jeu peut rendre les états interpolés ... mais attendez une minute, ce n'est vraiment pas facile du tout.  Dans le post de Glenn, on suppose simplement que cela peut être fait.  Il est assez facile de mettre en cache la position précédente de l'objet de jeu et d'interpoler ses mouvements, mais l'état du jeu est bien plus que cela.  Il faut y prendre en compte l'état d'animation, la création et la destruction d'objets, et un tas de choses. <br><br>  De plus, dans la logique du jeu, vous devez déterminer si l'objet est téléporté ou s'il doit être déplacé en douceur pour que l'interpolateur ne fasse pas de fausses hypothèses sur le chemin parcouru par l'objet de jeu jusqu'à sa position actuelle.  Un vrai chaos peut se produire avec les virages, surtout si dans une image le virage d'un objet peut changer de plus de 180 degrés.  Et comment traiter correctement les objets créés et détruits? <br><br>  Pour le moment, je travaille juste sur cette tâche dans mon moteur.  En fait, je viens d'interpoler les mouvements et de laisser tout le reste tel quel.  Vous ne remarquerez pas de secousses si l'objet ne se déplace pas en douceur, donc ignorer les images d'animation et synchroniser la création / destruction de l'objet sur une image ne deviendra pas un problème si tout le reste est exécuté en douceur. <br><br>  Cependant, il est étrange que, en fait, cette méthode rend le jeu dans un état en retard d'un état du jeu à partir duquel la simulation se trouve maintenant.  Cela est discret, mais peut être connecté à d'autres sources de retards, par exemple, les retards d'entrée et les taux de rafraîchissement du moniteur, de sorte que ceux qui ont besoin du gameplay le plus réactif (je parle de vous, les coureurs de vitesse) préfèreront très probablement utiliser le lockstep dans le jeu. <br><br>  Dans mon moteur, je donne juste un choix.  Si vous avez un moniteur 60 hertz et un ordinateur rapide, il est préférable d'utiliser le verrouillage avec vsync activé.  Si le moniteur a un taux de rafraîchissement non standard ou si votre ordinateur faible ne peut pas restituer constamment 60 images par seconde, activez l’interpolation d’images.  Je veux appeler cette option «déverrouiller la fréquence d'images», mais les gens pourraient penser que cela signifie simplement «activer cette option si vous avez un bon ordinateur».  Cependant, ce problème peut être résolu ultérieurement. <br><br>  En fait, il <i>existe une</i> méthode pour contourner ce problème. <br><br><h3>  Mises à jour à pas de temps variable </h3><br>  Beaucoup de gens m'ont demandé pourquoi ne pas simplement mettre à jour le jeu avec un pas de temps variable, et les programmeurs théoriques disent souvent: "si le jeu est écrit CORRECTEMENT, alors vous pouvez simplement le mettre à jour avec un pas de temps arbitraire". <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { deltaTime = CurrentTime()-OldTime; oldTime = CurrentTime(); update(deltaTime); render(); display(); }</code> </pre> <br>  Pas de bizarreries avec les horaires.  Pas de rendu d'interpolation bizarre.  Tout est simple, tout fonctionne. <br><br>  Donc, élémentaire.  Le problème est résolu.  Et maintenant pour toujours!  Il est impossible d'obtenir un meilleur résultat! <br><br>  Maintenant, c'est assez simple pour faire fonctionner la logique du jeu avec un pas de temps arbitraire.  C'est simple, il suffit de remplacer tout ce code: <br><br><pre> <code class="cpp hljs">position += speed;</code> </pre> <br>  à ce sujet: <br><br><pre> <code class="cpp hljs">position += speed * deltaTime;</code> </pre> <br>  et remplacez le code suivant: <br><br><pre> <code class="cpp hljs">speed += acceleration; position += speed;</code> </pre> <br>  à ce sujet: <br><br><pre> <code class="cpp hljs">speed += acceleration * deltaTime; position += speed * deltaTime;</code> </pre> <br>  et remplacez le code suivant: <br><br><pre> <code class="cpp hljs">speed += acceleration; speed *= friction; position += speed;</code> </pre> <br>  à ce sujet: <br><br><pre> <code class="cpp hljs">Vec3D p0 = position; Vec3D v0 = velocity; Vec3D a = acceleration*(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> f = friction; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> n = dt*<span class="hljs-number"><span class="hljs-number">60</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fN = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(friction, n); position = p0 + ((f*(a*(f*fN-f*(n+<span class="hljs-number"><span class="hljs-number">1</span></span>)+n)+(f<span class="hljs-number"><span class="hljs-number">-1</span></span>)*v0*(fN<span class="hljs-number"><span class="hljs-number">-1</span></span>)))/((f<span class="hljs-number"><span class="hljs-number">-1</span></span>)*(f<span class="hljs-number"><span class="hljs-number">-1</span></span>)))*(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>); velocity = v0*fN+a*(f*(fN<span class="hljs-number"><span class="hljs-number">-1</span></span>)/(f<span class="hljs-number"><span class="hljs-number">-1</span></span>));</code> </pre> <br>  ... alors attendez <br><br>  D'où tout cela vient-il? <br><br>  La dernière partie est littéralement copiée du code auxiliaire de mon moteur, qui effectue "un mouvement indépendant de la fréquence d'images vraiment correct avec une vitesse limitant le frottement".  Il y a un peu d'ordures dedans (ces multiplications et divisions par 60).  Mais c'est la version «correcte» du code avec un pas de temps variable pour le fragment précédent.  Je l'ai compris pendant plus d'une heure avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Wolfram Alpha</a> . <br><br>  Maintenant, ils peuvent me demander pourquoi ne pas le faire comme ceci: <br><br><pre> <code class="cpp hljs">speed += acceleration * deltaTime; speed *= <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(friction, deltaTime); position += speed * deltaTime;</code> </pre> <br>  Et même si cela semble fonctionner, c'est en fait mal de le faire.  Vous pouvez le vérifier vous-même.  Effectuez deux mises à jour avec deltaTime = 1, puis effectuez une mise à jour avec deltaTime = 2, et les résultats seront différents.  Habituellement, nous nous efforçons pour que le jeu fonctionne de concert, de sorte que de telles différences ne sont pas les bienvenues.  C'est probablement une assez bonne solution, si vous savez avec certitude que deltaTime est toujours approximativement égal à une valeur, mais alors vous devez écrire du code pour vous assurer que les mises à jour sont effectuées à une fréquence constante et ... oui.  C'est vrai, maintenant nous essayons de tout faire "CORRECTEMENT". <br><br>  Si un si petit morceau de code se déroule en calculs mathématiques monstrueux, alors imaginez des modèles de mouvement plus complexes auxquels participent de nombreux objets en interaction, etc.  Vous pouvez maintenant voir clairement que la «bonne» solution est irréalisable.  Le maximum que nous pouvons atteindre est une «approximation grossière».  Oublions cela pour l'instant, et supposons que nous ayons en fait une version «vraiment correcte» des fonctions de mouvement.  Super, non? <br><br>  Non, en fait.  Voici un exemple réel du problème que j'ai eu avec ça à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Bombernauts</a> .  Un joueur peut faire rebondir environ 1 tuile, et le jeu se déroule dans une grille de blocs en 1 tuile.  Pour atterrir sur un bloc, les jambes du personnage doivent s'élever au-dessus de la surface supérieure du bloc. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/956/eff/806/956eff806c65598bd694f6bc81713c1c.png"></div><br>  Mais comme la reconnaissance des collisions est effectuée ici avec une étape discrète, alors si le jeu fonctionne avec une faible fréquence d'images, les jambes n'atteindront pas parfois la surface de la tuile, bien qu'elles aient suivi la même courbe de mouvement, et au lieu de soulever, le joueur glissera du mur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ad/ab7/cfc/5adab7cfc0abca780385cb3da53d63e5.png"></div><br>  De toute évidence, ce problème est résoluble.  Mais il illustre les types de problèmes que nous rencontrons en essayant d'implémenter correctement le travail du cycle de jeu avec un pas de temps variable.  Nous perdons de la cohérence et du déterminisme, nous devons donc nous débarrasser des fonctions de relecture du jeu en enregistrant les entrées du joueur, le multijoueur déterministe, etc.  Pour les jeux 2D rapides basés sur les réflexes, la cohérence est extrêmement importante (et bonjour encore aux coureurs de vitesse). <br><br>  Si vous essayez d'ajuster les pas de temps de sorte qu'ils ne soient ni trop grands ni trop petits, vous perdrez le principal avantage obtenu du pas de temps variable et vous pourrez utiliser en toute sécurité les deux autres méthodes décrites ici.  Le jeu ne vaut pas la chandelle.  Trop d'efforts supplémentaires seront mis dans la logique du jeu (la mise en œuvre des mathématiques correctes du mouvement), et trop de victimes seront nécessaires dans le domaine du déterminisme et de la cohérence.  Je n'utiliserais cette méthode que pour un jeu de rythme musical (dans lequel les équations du mouvement sont simples et nécessitent un maximum de réactivité et de fluidité).  Dans tous les autres cas, je choisirai une mise à jour fixe. <br><br><hr><br><h3>  Conclusion </h3><br>  Vous savez maintenant comment faire fonctionner le jeu à une fréquence constante de 60 images par seconde.  C'est trivialement simple, et personne d'autre ne devrait avoir de problème avec ça.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Aucun autre problème ne</a> complique cette tâche. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442528/">https://habr.com/ru/post/fr442528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442518/index.html">Top 10 des techniques de piratage Web 2018</a></li>
<li><a href="../fr442520/index.html">Affaire. Économie de 300 000 p. par mois sur la publicité contextuelle</a></li>
<li><a href="../fr442522/index.html">Intuitive RL (Reinforcement Learning): Introduction à Advantage-Actor-Critic (A2C)</a></li>
<li><a href="../fr442524/index.html">Comment accroître la sécurité des systèmes d'identification personnelle et de contrôle d'accès</a></li>
<li><a href="../fr442526/index.html">L'histoire des cassettes soviétiques (deuxième partie): le boom des Walkmen, un gadget pour le KGB et des magnétophones</a></li>
<li><a href="../fr442530/index.html">Wireshark 3.0.0: revue des innovations</a></li>
<li><a href="../fr442532/index.html">Enregistreurs vidéo pour la vidéosurveillance - gratuitement</a></li>
<li><a href="../fr442534/index.html">Revue de Sprint: Shitty to Great</a></li>
<li><a href="../fr442536/index.html">Connexion de boîtes aux lettres externes à Zimbra</a></li>
<li><a href="../fr442542/index.html">SmartMail Conf: Première conférence Mail Learning Machine Mail.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>