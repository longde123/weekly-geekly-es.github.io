<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèº üìï üë®üèª‚Äçüè≠ Comment faire fonctionner le jeu √† 60 images par seconde üçá üëß üçá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imaginez le probl√®me: vous avez un jeu et vous en avez besoin pour fonctionner √† 60 ips sur un moniteur √† 60 Hz. Votre ordinateur est assez rapide pou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment faire fonctionner le jeu √† 60 images par seconde</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442528/">  Imaginez le probl√®me: vous avez un jeu et vous en avez besoin pour fonctionner √† 60 ips sur un moniteur √† 60 Hz.  Votre ordinateur est assez rapide pour le rendu et la mise √† jour pour prendre un temps insignifiant, donc vous activez vsync et √©crivez cette boucle de jeu: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { update(); render(); display(); }</code> </pre> <br>  Tr√®s simple!  Maintenant, le jeu fonctionne √† 60 images par seconde et tout se passe comme sur des roulettes.  C'est fait.  Merci d'avoir lu ce post. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ae/57e/bf1/0ae57ebf1f1695e4ecbcafddcb4255bb.jpg"></div><br>  Eh bien, √©videmment, tout n'est pas si bon.  Et si quelqu'un a un ordinateur faible qui ne peut pas rendre le jeu √† une vitesse suffisante pour fournir 60 images par seconde?  Et si quelqu'un achetait un de ces nouveaux moniteurs 144 hertz sympas?  Et s'il a d√©sactiv√© vsync dans les param√®tres du pilote? <br><a name="habracut"></a><br>  Vous pourriez penser: j'ai besoin de mesurer le temps quelque part et de fournir une mise √† jour avec la bonne fr√©quence.  C'est assez simple - il suffit d'accumuler du temps √† chaque cycle et de mettre √† jour chaque fois qu'il d√©passe le seuil de 1/60 de seconde. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { deltaTime = CurrentTime()-OldTime; oldTime = CurrentTime(); accumulator += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; } render(); display(); }</code> </pre> <br>  Fait, nulle part plus facile.  En fait, il existe un tas de jeux dans lesquels le code ressemble essentiellement √† cela.  Mais c'est faux.  Cela convient pour r√©gler les horaires, mais entra√Æne des probl√®mes de secousses (b√©gaiement) et d'autres d√©calages.  Un tel probl√®me est tr√®s courant: les images ne sont pas affich√©es exactement 1/60 de seconde;  m√™me lorsque vsync est activ√©, il y a toujours un peu de bruit dans le temps o√π ils sont affich√©s (et dans la pr√©cision de la minuterie du syst√®me d'exploitation).  Par cons√©quent, il y aura des situations o√π vous rendrez une image, et le jeu estime que le temps de la mise √† jour n'est pas encore arriv√© (car la batterie est en retard d'une petite fraction), donc il r√©p√®te simplement la m√™me image, mais maintenant le jeu est en retard pour l'image, donc il double mise √† jour.  Voici les contractions! <br><br>  Sur Google, vous pouvez trouver plusieurs solutions pr√™tes √† l'emploi pour √©liminer ces contractions.  Par exemple, un jeu peut utiliser une variable plut√¥t qu'un pas de temps constant, et simplement abandonner compl√®tement les batteries dans le code temporel.  Ou vous pouvez impl√©menter un pas de temps constant avec un rendu d'interpolation, d√©crit dans un article assez c√©l√®bre " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Fix Your Timestep</a> " par Glenn Fielder.  Ou vous pouvez refaire le code de la minuterie afin qu'il soit un peu plus flexible, comme d√©crit dans le post de Slick Entertainment's <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20171206005813/" rel="nofollow noopener">Frame Timing Issues</a> (malheureusement, ce blog n'est plus l√†). <br><br><hr><br><h3>  Timings flous </h3><br>  La m√©thode Slick Entertainment avec des ¬´timings flous¬ª dans mon moteur √©tait la plus facile √† impl√©menter, car elle ne n√©cessitait pas de changements dans la logique du jeu et le rendu.  Donc dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">The End is Nigh,</a> je l'ai utilis√©.  Il suffisait juste de l'ins√©rer dans le moteur.  En fait, cela permet simplement de mettre √† jour le jeu ¬´un peu plus t√¥t¬ª pour √©viter les probl√®mes de d√©calage temporel.  Si le jeu comprend vsync, il vous permet simplement d'utiliser vsync comme minuteur principal du jeu et fournit une image fluide. <br><br>  Voici √† quoi ressemble le code de mise √† jour (le jeu "peut fonctionner" √† 62 images par seconde, mais traite toujours chaque pas de temps comme s'il fonctionnait √† 60 images par seconde. Je ne comprends pas tr√®s bien pourquoi le limiter afin que les valeurs de la batterie ne tombent pas en dessous de 0, mais sans ce code ne fonctionne pas).  Vous pouvez l'interpr√©ter de cette fa√ßon: "le jeu est mis √† jour avec un pas fixe, s'il est rendu dans l'intervalle de 60fps √† 62fps": <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">62.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Si vsync est activ√©, il permet essentiellement au jeu de fonctionner avec une hauteur fixe, qui correspond au taux de rafra√Æchissement du moniteur, et fournit une image fluide.  Le principal probl√®me ici est que lorsque vsync est d√©sactiv√©, le jeu fonctionnera un <i>peu</i> plus vite, mais la diff√©rence est si insignifiante que personne ne le remarquera. <br><br>  Coureurs de vitesse.  Les coureurs de vitesse le remarqueront.  Peu de temps apr√®s la sortie du jeu, ils ont remarqu√© que certaines personnes sur les listes de meilleurs scores de speedran avaient des temps de voyage moins bons, mais cela s'est av√©r√© meilleur que d'autres.  Et la raison imm√©diate de cela √©tait le timing impr√©cis et la d√©connexion de vsync dans le jeu (ou les moniteurs 144 Hz).  Par cons√©quent, il est devenu √©vident que vous devez d√©sactiver ce flou lors de la d√©connexion de vsync. <br><br>  Oh, mais nous ne pouvons toujours pas v√©rifier si vsync est d√©sactiv√©.  Il n'y a aucun appel √† cela dans le syst√®me d'exploitation, et bien que nous puissions demander √† l'application d'activer ou de d√©sactiver vsync, en fait, cela d√©pend compl√®tement du syst√®me d'exploitation et du pilote graphique.  La seule chose qui peut √™tre faite est de rendre un ensemble d'images, d'essayer de mesurer le temps d'ex√©cution de cette t√¢che, puis de comparer si elles prennent environ le m√™me temps.  C'est exactement ce que j'ai fait pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">The End is Nigh</a> .  Si le jeu n'inclut pas vsync avec une fr√©quence de 60 Hz, alors il revient √† la temporisation d'image d'origine avec "60 images par seconde strictes".  De plus, j'ai ajout√© un param√®tre au fichier de configuration qui oblige le jeu √† ne pas utiliser de flou (principalement pour les coureurs de vitesse qui ont besoin de temps pr√©cis) et j'ai ajout√© un gestionnaire de minuterie dans le jeu exact pour eux, ce qui permet d'utiliser l'√©chantillonneur automatique (c'est un script qui fonctionne avec une minuterie atomique). <br><br>  Certains utilisateurs se plaignaient toujours des secousses occasionnelles de trames individuelles, mais elles semblaient si rares qu'elles pouvaient √™tre expliqu√©es par des √©v√©nements du syst√®me d'exploitation ou d'autres raisons externes.  Pas grave.  Non? <br><br>  En parcourant r√©cemment mon code de minuterie, j'ai remarqu√© quelque chose d'√©trange.  La batterie a √©t√© d√©plac√©e, chaque image a pris un peu plus de 1/60 seconde, donc de temps en temps le jeu pensait qu'il √©tait tard pour l'image et effectuait une double mise √† jour.  Il s'est av√©r√© que mon moniteur fonctionne avec une fr√©quence de 59,94 Hz et non 60 Hz.  Cela signifiait que tous les 1000 images, il devait effectuer une double mise √† jour afin de ¬´rattraper¬ª.  Cependant, cela est tr√®s simple √† corriger - il suffit de changer l'intervalle des fr√©quences de trame autoris√©es (pas de 60 √† 62, mais de 59 √† 61). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">61.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">59.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Le probl√®me d√©crit ci-dessus avec des moniteurs vsync et haute fr√©quence d√©connect√©s persiste toujours, et la m√™me solution s'applique √† lui (restauration du temporisateur strict si le moniteur n'est <i>pas</i> synchronis√© vsync par 60). <br><br>  Mais comment savoir si c'est la bonne solution?  Comment s'assurer qu'il fonctionnera correctement sur toutes les combinaisons d'ordinateurs avec diff√©rents types de moniteurs, avec et sans vsync activ√©, etc.?  Il est tr√®s difficile de garder une trace de tous ces probl√®mes de minuterie dans la t√™te et de comprendre ce qui cause la d√©synchronisation, les boucles √©tranges et autres. <br><br><h3>  Simulateur de moniteur </h3><br>  En essayant de trouver une solution fiable au ¬´probl√®me du moniteur 59,94 hertz¬ª, je me suis rendu compte que je ne pouvais pas simplement effectuer des v√©rifications d‚Äôessai et d‚Äôerreur, dans l‚Äôespoir de trouver une solution fiable.  J'avais besoin d'un moyen pratique pour tester diff√©rentes tentatives d'√©criture d'une minuterie de haute qualit√© et d'un moyen facile de v√©rifier si cela provoque une secousse ou un d√©calage temporel dans diff√©rentes configurations de moniteur. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Monitor Simulator</a> appara√Æt sur la sc√®ne.  C'est le code ¬´sale et rapide¬ª que j'ai √©crit, simulant le ¬´fonctionnement du moniteur¬ª, et me montrant essentiellement un tas de chiffres qui donnent une id√©e de la stabilit√© de chaque minuterie test√©e. <br><br>  Par exemple, pour le minuteur le plus simple, les valeurs suivantes sont affich√©es depuis le d√©but de l'article: <br><br> <code>20211012021011202111020211102012012102012[...] <br> TOTAL UPDATES: 10001 <br> TOTAL VSYNCS: 10002 <br> TOTAL DOUBLE UPDATES: 2535 <br> TOTAL SKIPPED RENDERS: 0 <br> GAME TIME: 166.683 <br> SYSTEM TIME: 166.7</code> <br> <br>  Tout d'abord, le code affiche pour chaque vsync √©mul√© le nombre du nombre de "mises √† jour" du cycle de jeu apr√®s le vsync pr√©c√©dent.  Toute valeur autre que solide 1 conduit √† une image instable.  √Ä la fin, le code affiche les statistiques accumul√©es. <br><br>  Lorsque vous utilisez la ¬´minuterie floue¬ª (avec un intervalle de 60 √† 62 ips) sur un moniteur de 59,94 Hertz, le code affiche les √©l√©ments suivants: <br><br> <code>111111111111111111111111111111111111111111111[...] <br> TOTAL UPDATES: 10000 <br> TOTAL VSYNCS: 9991 <br> TOTAL DOUBLE UPDATES: 10 <br> TOTAL SKIPPED RENDERS: 0 <br> GAME TIME: 166.667 <br> SYSTEM TIME: 166.683</code> <br> <br>  Les secousses du cadre sont tr√®s rares, il peut donc √™tre difficile de le remarquer avec un tel nombre de 1. Mais les statistiques affich√©es montrent clairement que le jeu a effectu√© plusieurs doubles mises √† jour ici, ce qui conduit √† des secousses.  Dans la version fixe (avec un intervalle de 59 √† 61 ips), il y a 0 mises √† jour ignor√©es ou doubles. <br><br>  Vous pouvez √©galement d√©sactiver vsync.  Le reste des donn√©es statistiques devient sans importance, mais cela me montre clairement l'ampleur du ¬´d√©calage temporel¬ª (le d√©calage temporel du syst√®me par rapport √† l'emplacement du temps de jeu). <br><br> <code>GAME TIME: 166.667 <br> SYSTEM TIME: 169.102</code> <br> <br>  C'est pourquoi lorsque vsync est d√©sactiv√©, vous devez passer √† une minuterie stricte, sinon ces √©carts s'accumulent avec le temps. <br><br>  Si je r√®gle le temps de rendu sur .02 (c'est-√†-dire que ¬´plus d'un cadre¬ª est n√©cessaire pour le rendu), j'obtiendrai un contraction.  Id√©alement, le mod√®le de jeu devrait ressembler √† 202020202020, mais il est un peu in√©gal. <br><br>  Dans cette situation, ce minuteur se comporte un peu mieux que le pr√©c√©dent, mais il devient plus d√©routant et plus difficile de comprendre comment et pourquoi il fonctionne.  Mais je peux simplement mettre les tests dans ce simulateur et v√©rifier leur comportement, et vous pourrez en comprendre les raisons plus tard.  Essais et erreurs, b√©b√©! <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">61.0</span></span>){ simulate_update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">59.0</span></span>‚Äì<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Vous pouvez t√©l√©charger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">un simulateur de moniteur</a> et v√©rifier ind√©pendamment diff√©rentes m√©thodes de calcul de synchronisation.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Envoyez-moi un e-mail</a> si vous trouvez quelque chose de mieux. <br><br>  Je ne suis pas 100% satisfait de ma d√©cision (cela n√©cessite toujours un hack avec ¬´reconnaissance vsync¬ª et des secousses occasionnelles peuvent se produire pendant la d√©synchronisation), mais je pense que c'est presque aussi bon qu'une tentative de mise en ≈ìuvre d'un cycle de jeu avec une √©tape fixe.  Une partie de ce probl√®me se pose car il est tr√®s difficile de d√©terminer les param√®tres de ce qui est consid√©r√© comme ¬´acceptable¬ª ici.  La principale difficult√© r√©side dans le compromis entre d√©calage temporel et images doubles / saut√©es.  Si vous ex√©cutez un jeu √† 60 Hz sur un moniteur PAL √† 50 Hz ... quelle sera la bonne d√©cision?  Voulez-vous des secousses sauvages ou un jeu sensiblement plus lent?  Les deux options semblent mauvaises. <br><br><h3>  Rendu s√©par√© </h3><br>  Dans les m√©thodes pr√©c√©dentes, j'ai d√©crit ce que j'appelle le ¬´rendu lockstep¬ª.  Le jeu met √† jour son √©tat, puis le rend, et lors du rendu, il affiche toujours l'√©tat le plus r√©cent du jeu.  Le rendu et la mise √† jour sont connect√©s ensemble. <br><br>  Mais vous pouvez les s√©parer.  C'est exactement ce que fait la m√©thode d√©crite dans le message " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Fix Your Timestep</a> ".  Je ne vais pas me r√©p√©ter, vous devriez certainement lire cet article.  Ceci (si je comprends bien) est le ¬´standard de l'industrie¬ª utilis√© dans les jeux et moteurs AAA tels que Unity et Unreal (cependant, dans les jeux actifs 2D intenses, ils pr√©f√®rent g√©n√©ralement utiliser une √©tape fixe (lockstep), car parfois la pr√©cision qui vous donne cette m√©thode). <br><br>  Mais si nous d√©crivons bri√®vement le post de Glenn, il d√©crit simplement la m√©thode de mise √† jour avec une fr√©quence d'images fixe, mais lors du rendu, l'interpolation est effectu√©e entre l'√©tat "actuel" et "pr√©c√©dent" du jeu, et la valeur actuelle de la batterie est utilis√©e comme valeur d'interpolation.  Avec cette m√©thode, vous pouvez effectuer un rendu √† n'importe quelle fr√©quence d'images et mettre √† jour le jeu √† n'importe quelle fr√©quence, et l'image sera toujours fluide.  Pas de secousses, fonctionne universellement. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running){ computeDeltaTimeSomehow(); accumulator += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>){ previous_state = current_state; current_state = update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; } render_interpolated_somehow(previous_state, current_state, accumulator/(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>)); display(); }</code> </pre> <br>  Donc, √©l√©mentaire.  Le probl√®me est r√©solu. <br><br>  Maintenant, vous devez juste vous assurer que le jeu peut rendre les √©tats interpol√©s ... mais attendez une minute, ce n'est vraiment pas facile du tout.  Dans le post de Glenn, on suppose simplement que cela peut √™tre fait.  Il est assez facile de mettre en cache la position pr√©c√©dente de l'objet de jeu et d'interpoler ses mouvements, mais l'√©tat du jeu est bien plus que cela.  Il faut y prendre en compte l'√©tat d'animation, la cr√©ation et la destruction d'objets, et un tas de choses. <br><br>  De plus, dans la logique du jeu, vous devez d√©terminer si l'objet est t√©l√©port√© ou s'il doit √™tre d√©plac√© en douceur pour que l'interpolateur ne fasse pas de fausses hypoth√®ses sur le chemin parcouru par l'objet de jeu jusqu'√† sa position actuelle.  Un vrai chaos peut se produire avec les virages, surtout si dans une image le virage d'un objet peut changer de plus de 180 degr√©s.  Et comment traiter correctement les objets cr√©√©s et d√©truits? <br><br>  Pour le moment, je travaille juste sur cette t√¢che dans mon moteur.  En fait, je viens d'interpoler les mouvements et de laisser tout le reste tel quel.  Vous ne remarquerez pas de secousses si l'objet ne se d√©place pas en douceur, donc ignorer les images d'animation et synchroniser la cr√©ation / destruction de l'objet sur une image ne deviendra pas un probl√®me si tout le reste est ex√©cut√© en douceur. <br><br>  Cependant, il est √©trange que, en fait, cette m√©thode rend le jeu dans un √©tat en retard d'un √©tat du jeu √† partir duquel la simulation se trouve maintenant.  Cela est discret, mais peut √™tre connect√© √† d'autres sources de retards, par exemple, les retards d'entr√©e et les taux de rafra√Æchissement du moniteur, de sorte que ceux qui ont besoin du gameplay le plus r√©actif (je parle de vous, les coureurs de vitesse) pr√©f√®reront tr√®s probablement utiliser le lockstep dans le jeu. <br><br>  Dans mon moteur, je donne juste un choix.  Si vous avez un moniteur 60 hertz et un ordinateur rapide, il est pr√©f√©rable d'utiliser le verrouillage avec vsync activ√©.  Si le moniteur a un taux de rafra√Æchissement non standard ou si votre ordinateur faible ne peut pas restituer constamment 60 images par seconde, activez l‚Äôinterpolation d‚Äôimages.  Je veux appeler cette option ¬´d√©verrouiller la fr√©quence d'images¬ª, mais les gens pourraient penser que cela signifie simplement ¬´activer cette option si vous avez un bon ordinateur¬ª.  Cependant, ce probl√®me peut √™tre r√©solu ult√©rieurement. <br><br>  En fait, il <i>existe une</i> m√©thode pour contourner ce probl√®me. <br><br><h3>  Mises √† jour √† pas de temps variable </h3><br>  Beaucoup de gens m'ont demand√© pourquoi ne pas simplement mettre √† jour le jeu avec un pas de temps variable, et les programmeurs th√©oriques disent souvent: "si le jeu est √©crit CORRECTEMENT, alors vous pouvez simplement le mettre √† jour avec un pas de temps arbitraire". <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { deltaTime = CurrentTime()-OldTime; oldTime = CurrentTime(); update(deltaTime); render(); display(); }</code> </pre> <br>  Pas de bizarreries avec les horaires.  Pas de rendu d'interpolation bizarre.  Tout est simple, tout fonctionne. <br><br>  Donc, √©l√©mentaire.  Le probl√®me est r√©solu.  Et maintenant pour toujours!  Il est impossible d'obtenir un meilleur r√©sultat! <br><br>  Maintenant, c'est assez simple pour faire fonctionner la logique du jeu avec un pas de temps arbitraire.  C'est simple, il suffit de remplacer tout ce code: <br><br><pre> <code class="cpp hljs">position += speed;</code> </pre> <br>  √† ce sujet: <br><br><pre> <code class="cpp hljs">position += speed * deltaTime;</code> </pre> <br>  et remplacez le code suivant: <br><br><pre> <code class="cpp hljs">speed += acceleration; position += speed;</code> </pre> <br>  √† ce sujet: <br><br><pre> <code class="cpp hljs">speed += acceleration * deltaTime; position += speed * deltaTime;</code> </pre> <br>  et remplacez le code suivant: <br><br><pre> <code class="cpp hljs">speed += acceleration; speed *= friction; position += speed;</code> </pre> <br>  √† ce sujet: <br><br><pre> <code class="cpp hljs">Vec3D p0 = position; Vec3D v0 = velocity; Vec3D a = acceleration*(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> f = friction; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> n = dt*<span class="hljs-number"><span class="hljs-number">60</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fN = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(friction, n); position = p0 + ((f*(a*(f*fN-f*(n+<span class="hljs-number"><span class="hljs-number">1</span></span>)+n)+(f<span class="hljs-number"><span class="hljs-number">-1</span></span>)*v0*(fN<span class="hljs-number"><span class="hljs-number">-1</span></span>)))/((f<span class="hljs-number"><span class="hljs-number">-1</span></span>)*(f<span class="hljs-number"><span class="hljs-number">-1</span></span>)))*(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>); velocity = v0*fN+a*(f*(fN<span class="hljs-number"><span class="hljs-number">-1</span></span>)/(f<span class="hljs-number"><span class="hljs-number">-1</span></span>));</code> </pre> <br>  ... alors attendez <br><br>  D'o√π tout cela vient-il? <br><br>  La derni√®re partie est litt√©ralement copi√©e du code auxiliaire de mon moteur, qui effectue "un mouvement ind√©pendant de la fr√©quence d'images vraiment correct avec une vitesse limitant le frottement".  Il y a un peu d'ordures dedans (ces multiplications et divisions par 60).  Mais c'est la version ¬´correcte¬ª du code avec un pas de temps variable pour le fragment pr√©c√©dent.  Je l'ai compris pendant plus d'une heure avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Wolfram Alpha</a> . <br><br>  Maintenant, ils peuvent me demander pourquoi ne pas le faire comme ceci: <br><br><pre> <code class="cpp hljs">speed += acceleration * deltaTime; speed *= <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(friction, deltaTime); position += speed * deltaTime;</code> </pre> <br>  Et m√™me si cela semble fonctionner, c'est en fait mal de le faire.  Vous pouvez le v√©rifier vous-m√™me.  Effectuez deux mises √† jour avec deltaTime = 1, puis effectuez une mise √† jour avec deltaTime = 2, et les r√©sultats seront diff√©rents.  Habituellement, nous nous effor√ßons pour que le jeu fonctionne de concert, de sorte que de telles diff√©rences ne sont pas les bienvenues.  C'est probablement une assez bonne solution, si vous savez avec certitude que deltaTime est toujours approximativement √©gal √† une valeur, mais alors vous devez √©crire du code pour vous assurer que les mises √† jour sont effectu√©es √† une fr√©quence constante et ... oui.  C'est vrai, maintenant nous essayons de tout faire "CORRECTEMENT". <br><br>  Si un si petit morceau de code se d√©roule en calculs math√©matiques monstrueux, alors imaginez des mod√®les de mouvement plus complexes auxquels participent de nombreux objets en interaction, etc.  Vous pouvez maintenant voir clairement que la ¬´bonne¬ª solution est irr√©alisable.  Le maximum que nous pouvons atteindre est une ¬´approximation grossi√®re¬ª.  Oublions cela pour l'instant, et supposons que nous ayons en fait une version ¬´vraiment correcte¬ª des fonctions de mouvement.  Super, non? <br><br>  Non, en fait.  Voici un exemple r√©el du probl√®me que j'ai eu avec √ßa √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Bombernauts</a> .  Un joueur peut faire rebondir environ 1 tuile, et le jeu se d√©roule dans une grille de blocs en 1 tuile.  Pour atterrir sur un bloc, les jambes du personnage doivent s'√©lever au-dessus de la surface sup√©rieure du bloc. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/956/eff/806/956eff806c65598bd694f6bc81713c1c.png"></div><br>  Mais comme la reconnaissance des collisions est effectu√©e ici avec une √©tape discr√®te, alors si le jeu fonctionne avec une faible fr√©quence d'images, les jambes n'atteindront pas parfois la surface de la tuile, bien qu'elles aient suivi la m√™me courbe de mouvement, et au lieu de soulever, le joueur glissera du mur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ad/ab7/cfc/5adab7cfc0abca780385cb3da53d63e5.png"></div><br>  De toute √©vidence, ce probl√®me est r√©soluble.  Mais il illustre les types de probl√®mes que nous rencontrons en essayant d'impl√©menter correctement le travail du cycle de jeu avec un pas de temps variable.  Nous perdons de la coh√©rence et du d√©terminisme, nous devons donc nous d√©barrasser des fonctions de relecture du jeu en enregistrant les entr√©es du joueur, le multijoueur d√©terministe, etc.  Pour les jeux 2D rapides bas√©s sur les r√©flexes, la coh√©rence est extr√™mement importante (et bonjour encore aux coureurs de vitesse). <br><br>  Si vous essayez d'ajuster les pas de temps de sorte qu'ils ne soient ni trop grands ni trop petits, vous perdrez le principal avantage obtenu du pas de temps variable et vous pourrez utiliser en toute s√©curit√© les deux autres m√©thodes d√©crites ici.  Le jeu ne vaut pas la chandelle.  Trop d'efforts suppl√©mentaires seront mis dans la logique du jeu (la mise en ≈ìuvre des math√©matiques correctes du mouvement), et trop de victimes seront n√©cessaires dans le domaine du d√©terminisme et de la coh√©rence.  Je n'utiliserais cette m√©thode que pour un jeu de rythme musical (dans lequel les √©quations du mouvement sont simples et n√©cessitent un maximum de r√©activit√© et de fluidit√©).  Dans tous les autres cas, je choisirai une mise √† jour fixe. <br><br><hr><br><h3>  Conclusion </h3><br>  Vous savez maintenant comment faire fonctionner le jeu √† une fr√©quence constante de 60 images par seconde.  C'est trivialement simple, et personne d'autre ne devrait avoir de probl√®me avec √ßa.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Aucun autre probl√®me ne</a> complique cette t√¢che. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442528/">https://habr.com/ru/post/fr442528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442518/index.html">Top 10 des techniques de piratage Web 2018</a></li>
<li><a href="../fr442520/index.html">Affaire. √âconomie de 300 000 p. par mois sur la publicit√© contextuelle</a></li>
<li><a href="../fr442522/index.html">Intuitive RL (Reinforcement Learning): Introduction √† Advantage-Actor-Critic (A2C)</a></li>
<li><a href="../fr442524/index.html">Comment accro√Ætre la s√©curit√© des syst√®mes d'identification personnelle et de contr√¥le d'acc√®s</a></li>
<li><a href="../fr442526/index.html">L'histoire des cassettes sovi√©tiques (deuxi√®me partie): le boom des Walkmen, un gadget pour le KGB et des magn√©tophones</a></li>
<li><a href="../fr442530/index.html">Wireshark 3.0.0: revue des innovations</a></li>
<li><a href="../fr442532/index.html">Enregistreurs vid√©o pour la vid√©osurveillance - gratuitement</a></li>
<li><a href="../fr442534/index.html">Revue de Sprint: Shitty to Great</a></li>
<li><a href="../fr442536/index.html">Connexion de bo√Ætes aux lettres externes √† Zimbra</a></li>
<li><a href="../fr442542/index.html">SmartMail Conf: Premi√®re conf√©rence Mail Learning Machine Mail.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>