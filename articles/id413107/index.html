<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÖ üå∏ üèáüèæ Terjemahan dari wiki proyek Svelto.ECS. Kerangka kerja ECS untuk Unity3D üë©üèº‚Äçü§ù‚Äçüë®üèΩ ü§ôüèø üòπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Daftar isi  ISI 


1. Pendahuluan 
2. Akar Komposisi dan Akar Mesin 
3. Entitas 
4. Mesin 
5. Representasi entitas 
6. Komponen 
7. Penjelas entitas 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Terjemahan dari wiki proyek Svelto.ECS. Kerangka kerja ECS untuk Unity3D</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413107/"><div class="spoiler">  <b class="spoiler_title">Daftar isi</b> <div class="spoiler_text"><h2>  ISI </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Akar Komposisi dan Akar Mesin</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Entitas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Representasi entitas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komponen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjelas entitas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peniru</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penciptaan Entitas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komunikasi di Svelto.ECS</a> </li></ol><br></div></div><br>  Halo, Habr!  Saya mempersembahkan terjemahan wiki dari proyek <a href="">Svelto.ECS yang</a> ditulis oleh Sebastiano Mandal√†. <br><br>  Svelto.ECS adalah hasil dari penelitian dan penerapan prinsip SOLID selama bertahun-tahun dalam pengembangan game di Unity.  Ini adalah salah satu dari banyak implementasi pola ECS yang tersedia untuk C # dengan berbagai fitur unik yang diperkenalkan untuk mengatasi kekurangan dari pola itu sendiri. <a name="habracut"></a><br><br><h2>  Penampilan pertama </h2><br>  Cara termudah untuk melihat fitur-fitur dasar Svelto.ECS adalah dengan mengunduh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh Vanilla</a> .  Jika Anda ingin memastikan kemudahan penggunaannya, saya akan menunjukkan kepada Anda sebuah contoh: <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  void ApplicationCompositionRoot() { var simpleSubmissionEntityViewScheduler = new SimpleSubmissionEntityViewScheduler(); _enginesRoot = new EnginesRoot(simpleSubmissionEntityViewScheduler); var entityFactory = _enginesRoot.GenerateEntityFactory(); var entityFunctions = _enginesRoot.GenerateEntityFunctions(); _enginesRoot.AddEngine(new BehaviourForSimpleEntityEngine(entityFunctions)); entityFactory.BuildEntity&lt;SimpleEntityDescriptor&gt;(new EGID(1), new[] { new SimpleImplementor() });` } //  class SimpleEntityDescriptor : GenericEntityDescriptor&lt;BehaviourEntityViewForSimpleEntity&gt; { } public class BehaviourEntityViewForSimpleEntity : EntityView { public ISimpleComponent simpleComponent; } public interface ISimpleComponent { public int counter {get; set;} } class SimpleImplementor : ISimpleComponent { public int counter { get; set; } } //  ()    public class BehaviourForSimpleEntityAsStructEngine : IQueryingEntityViewEngine { public IEntityViewsDB entityViewsDB { private get; set; } public void Ready() { Update().Run(); } //   . //    N ,  N    0  1. IEnumerator Update() { Console.Log("Task Waiting"); while (true) { var entityViews = entityViewsDB .QueryGroupedEntityViews&lt;BehaviourEntityViewForSimpleEntity&gt;(0); if (entityViews.Length&gt; 0) { for (var i = 0; i &lt; entityViews.Length; i++) AddOne(entityViews[i].counter); Console.Log("Task Done"); yield break; } yield return null; } } static void AddOne(int counter) { counter += 1; } }</span></span></code> </pre> <br>  Sayangnya, tidak mungkin untuk dengan cepat memahami teori di balik kode ini, yang mungkin terlihat sederhana tetapi membingungkan pada saat bersamaan.  Untuk memahami hal ini, Anda perlu menghabiskan waktu membaca "dinding teks" dan mencoba contoh-contoh di atas. <br><a name="Introduction"></a><br><h2>  Pendahuluan </h2><br>  Baru-baru ini, saya telah banyak membahas <b>Svelto.ECS</b> dengan beberapa programmer yang kurang lebih berpengalaman.  Saya mengumpulkan banyak umpan balik dan membuat banyak catatan yang akan saya gunakan sebagai titik awal untuk artikel saya berikutnya, di mana saya akan berbicara lebih banyak tentang teori dan praktik yang baik.  Spoiler kecil: Saya menyadari bahwa ketika Anda mulai menggunakan Svelto.ECS, rintangan terbesar adalah <b>mengubah paradigma pemrograman</b> .  Sungguh menakjubkan betapa banyak yang harus saya tulis untuk menjelaskan konsep-konsep baru yang diperkenalkan oleh Svelto.ECS, dibandingkan dengan sejumlah kecil kode yang ditulis untuk mengembangkan kerangka kerja.  Bahkan, sementara kerangka itu sendiri sangat sederhana dan ringan, transisi dari OOP dengan penggunaan pewarisan aktif atau komponen Unity biasa ke desain "baru" modular dan longgar digabungkan bahwa Svelto.ECS menawarkan untuk menggunakan mencegah orang beradaptasi dengan kerangka kerja. <br><br>  Svelto.ECS aktif digunakan dalam <b>Freejam</b> (catatan penerjemah - Penulis adalah direktur teknis di perusahaan ini).  Karena saya selalu dapat menjelaskan kepada teman-teman saya konsep dasar kerangka kerja, mereka membutuhkan waktu lebih sedikit untuk memahami cara bekerja dengannya.  Meskipun Svelto.ECS sekuat mungkin, kebiasaan buruk sulit diatasi, sehingga pengguna cenderung menyalahgunakan beberapa fleksibilitas yang memungkinkan mereka untuk menyesuaikan kerangka kerja dengan paradigma "lama" yang membuat mereka nyaman.  Hal ini dapat menyebabkan bencana karena kesalahpahaman atau distorsi konsep yang mendasari kerangka logika.  Itulah sebabnya saya bermaksud untuk menulis artikel sebanyak mungkin, terutama karena saya yakin bahwa paradigma ECS adalah solusi terbaik saat ini untuk menulis kode yang efektif dan didukung untuk proyek-proyek besar yang berubah dan dikerjakan ulang berkali-kali selama beberapa tahun.  <b>Robocraft</b> dan <b>Cardlife</b> adalah buktinya. <br><br>  Saya tidak akan berbicara banyak tentang teori yang mendasari artikel ini.  Saya hanya akan mengingatkan Anda mengapa saya menolak untuk menggunakan <b>wadah IoC</b> dan mulai menggunakan kerangka ECS secara eksklusif: Kontainer IoC adalah alat yang sangat berbahaya jika digunakan tanpa memahami esensi dari inversi kontrol.  Seperti yang dapat Anda lihat dari artikel saya sebelumnya, saya membedakan antara inversi kontrol penciptaan (Inversion of Creation Control) dan inversi kontrol aliran (Inversion of Flow Control).  Pembalikan kontrol aliran seperti prinsip Hollywood: "Jangan panggil kami, kami akan menghubungi Anda."  Ini berarti bahwa ketergantungan yang disuntikkan tidak boleh digunakan secara langsung melalui metode publik, karena dengan melakukannya Anda cukup menggunakan wadah IoC sebagai pengganti untuk bentuk injeksi global lain, seperti singleton.  Namun, jika wadah IoC digunakan atas dasar Inversion of Management (IoC), maka pada dasarnya semuanya bermula untuk menggunakan kembali pola "Metode Templat" untuk menerapkan manajer yang hanya digunakan untuk mendaftarkan objek yang mereka kelola.  Dalam konteks nyata dari inversi kontrol aliran, manajer selalu bertanggung jawab untuk mengelola entitas.  Apakah ini terlihat seperti pola ECS?  Tentu saja  Berdasarkan alasan ini, saya mengambil pola ECS dan mengembangkan kerangka kerja kaku berdasarkannya, dan penggunaannya sama saja dengan menerapkan paradigma pemrograman baru. <br><a name="Composition_Root"></a><br><h2>  Root Komposisi dan MesinRoot </h2><br>  Kelas utama adalah Komposisi Root aplikasi.  Akar komposisi adalah tempat di mana dependensi dibuat dan diimplementasikan (saya berbicara banyak tentang ini di artikel saya).  Root komposisi berasal dari sebuah konteks, tetapi sebuah konteks dapat memiliki lebih dari satu root komposisi.  Misalnya, Pabrik adalah akar komposisi.  Aplikasi mungkin memiliki lebih dari satu konteks, tetapi ini adalah skenario lanjutan, dan dalam contoh ini kami tidak akan mempertimbangkannya. <br><br>  Sebelum menyelam ke dalam kode, mari kita berkenalan dengan aturan pertama dari bahasa Svelto.ECS.  ECS adalah singkatan Sistem Entitas Komponen.  Infrastruktur ECS telah dianalisis dengan baik dalam artikel oleh banyak penulis, tetapi sementara konsep dasarnya umum, implementasinya sangat bervariasi.  Pertama-tama, tidak ada cara standar untuk menyelesaikan beberapa masalah yang muncul saat menggunakan kode berorientasi ECS.  Sehubungan dengan masalah ini saya melakukan sebagian besar upaya saya, tetapi saya akan membicarakannya nanti atau dalam artikel berikut.  Teori ini didasarkan pada konsep Essence, Components (entitas) dan Systems.  Walaupun saya mengerti mengapa kata System secara historis digunakan, sejak awal saya tidak menemukan itu cukup intuitif untuk tujuan ini, jadi saya menggunakan Engine sebagai sinonim untuk System, dan Anda, tergantung pada preferensi Anda, dapat menggunakan salah satu dari istilah ini. <br><br>  Kelas EnginesRoot adalah inti dari Svelto.ECS.  Dengan bantuannya, Anda dapat mendaftarkan mesin dan merancang semua esensi permainan.  Membuat mesin secara dinamis tidak masuk akal, jadi mereka semua harus ditambahkan ke instance EnginesRoot dari akar yang sama dari komposisi di mana ia dibuat.  Untuk alasan yang serupa, mesin virtual EnginesRoot tidak boleh dipasang, dan mesin tidak boleh dihapus setelah ditambahkan. <br><br>  Untuk membuat dan menerapkan dependensi, kita memerlukan setidaknya satu root komposisi.  Ya, dalam satu aplikasi lebih dari satu EnginesRoot mungkin ada, tetapi kami tidak akan menyinggung ini dalam artikel saat ini, yang saya coba sederhanakan sebanyak mungkin.  Inilah yang terlihat seperti akar komposisi dengan pembuatan mesin dan injeksi ketergantungan: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetupEnginesAndEntities</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Engines Root   Svelto.ECS.      EngineRoot // ,  Composition Root     ,   //   . //UnitySumbmissionEntityViewScheduler -  ,   //EnginesRoot,     EntityViews. //    ,   , //         Unity. _enginesRoot = new EnginesRoot(new UnitySumbmissionEntityViewScheduler()); //Engines root      ,   , //   . //   EntityFactory  EntityFunctions. //EntityFactory      //(    ), //   . _entityFactory = _enginesRoot.GenerateEntityFactory(); // EntityFunctions     //   , //  .        var entityFunctions = _enginesRoot.GenerateEntityFunctions(); //GameObjectFactory   Unity GameObject //   // GameObject.Instantiate.      // ,    ,   //       //(  ,   //         //      -  ) GameObjectFactory factory = new GameObjectFactory(); //    3     Svelto.ECS. //        //  . //         //     . var enemyKilledObservable = new EnemyKilledObservable(); var scoreOnEnemyKilledObserver = new ScoreOnEnemyKilledObserver(enemyKilledObservable); //ISequencer   3     Svelto.ECS // .       : //1)       //(   //,   ,     //  ). //2)   ,     // . ISequencer      //  Sequencer playerDamageSequence = new Sequencer(); Sequencer enemyDamageSequence = new Sequencer(); //    Unity. //     . IRayCaster rayCaster = new RayCaster(); ITime time = new Others.Time(); // .         //  . var playerHealthEngine = new HealthEngine(entityFunctions, playerDamageSequence); var playerShootingEngine = new PlayerGunShootingEngine(enemyKilledObservable, enemyDamageSequence, rayCaster, time); var playerMovementEngine = new PlayerMovementEngine(rayCaster, time); var playerAnimationEngine = new PlayerAnimationEngine(); //  var enemyAnimationEngine = new EnemyAnimationEngine(); var enemyHealthEngine = new HealthEngine(entityFunctions, enemyDamageSequence); var enemyAttackEngine = new EnemyAttackEngine(playerDamageSequence, time); var enemyMovementEngine = new EnemyMovementEngine(); var enemySpawnerEngine = new EnemySpawnerEngine(factory, _entityFactory); //    var hudEngine = new HUDEngine(time); var damageSoundEngine = new DamageSoundEngine(); // Sequencer  ,    // ,     . playerDamageSequence.SetSequence( new Steps // ,  ! { { //  //      Next   enemyAttackEngine, new To //        { //      //   Next playerHealthEngine, } }, { //  playerHealthEngine, //      Next   new To //       { //      Next     //DamageCondition.damage { DamageCondition.damage, new IStep[] { hudEngine, damageSoundEngine } }, //      Next     //DamageCondition.dead { DamageCondition.dead, new IStep[] { hudEngine, damageSoundEngine, playerMovementEngine, playerAnimationEngine, enemyAnimationEngine } }, } } }); enemyDamageSequence.SetSequence( new Steps { { playerShootingEngine, new To { enemyHealthEngine, } }, { enemyHealthEngine, new To { { DamageCondition.damage, new IStep[] { enemyAnimationEngine, damageSoundEngine } }, { DamageCondition.dead, new IStep[] { enemyMovementEngine, enemyAnimationEngine, playerShootingEngine, enemySpawnerEngine, damageSoundEngine } }, } } }); // ,     //  _enginesRoot.AddEngine(playerMovementEngine); _enginesRoot.AddEngine(playerAnimationEngine); _enginesRoot.AddEngine(playerShootingEngine); _enginesRoot.AddEngine(playerHealthEngine); _enginesRoot.AddEngine(new PlayerInputEngine()); _enginesRoot.AddEngine(new PlayerGunShootingFXsEngine()); //  _enginesRoot.AddEngine(enemySpawnerEngine); _enginesRoot.AddEngine(enemyAttackEngine); _enginesRoot.AddEngine(enemyMovementEngine); _enginesRoot.AddEngine(enemyAnimationEngine); _enginesRoot.AddEngine(enemyHealthEngine); //  _enginesRoot.AddEngine(new CameraFollowTargetEngine(time)); _enginesRoot.AddEngine(damageSoundEngine); _enginesRoot.AddEngine(hudEngine); _enginesRoot.AddEngine(new ScoreEngine(scoreOnEnemyKilledObserver));</span></span></code> </pre><br>  Kode ini dari contoh Survival, yang sekarang dikomentari dan mematuhi hampir semua aturan praktik baik yang saya usulkan untuk diterapkan, termasuk penggunaan platform-independen dan logika mesin yang diuji.  Komentar akan membantu Anda memahami sebagian besar dari mereka, tetapi proyek sebesar ini mungkin sulit dipahami jika Anda baru mengenal Svelto. <br><a name="Entities"></a><br><h2>  Entitas </h2><br>  Langkah pertama setelah membuat root kosong komposisi dan turunan dari kelas EnginesRoot adalah mengidentifikasi objek yang ingin Anda kerjakan terlebih dahulu.  Adalah logis untuk memulai dengan Entity Player.  Inti dari Svelto.ECS tidak boleh disamakan dengan Obyek Game Persatuan (GameObject).  Jika Anda membaca artikel lain yang terkait dengan ECS, Anda dapat melihat bahwa di banyak dari mereka, entitas sering digambarkan sebagai indeks.  Ini mungkin cara terburuk untuk memperkenalkan konsep ECS.  Meskipun berlaku untuk Svelto.ECS, ini tersembunyi di dalamnya.  Saya ingin pengguna Svelto.ECS untuk mewakili, menjelaskan, dan mengidentifikasi setiap entitas dalam hal bahasa Domain Desain Game.  Entitas dalam kode harus objek yang dijelaskan dalam dokumen desain game.  Segala bentuk definisi entitas lainnya akan mengarah pada cara yang jauh mengadaptasi pandangan lama Anda dengan prinsip-prinsip Svelto.ECS.  Ikuti aturan mendasar ini dan Anda tidak akan salah.  Kelas entitas itu sendiri tidak ada dalam kode, tetapi Anda tetap tidak harus mendefinisikannya secara abstrak. <br><a name="Engines"></a><br><h2>  Mesin </h2><br>  Langkah selanjutnya adalah berpikir tentang perilaku apa yang diminta Entitas.  Setiap perilaku selalu dimodelkan di dalam Engine, Anda tidak dapat menambahkan logika ke kelas lain di dalam aplikasi Svelto.ECS.  Kita bisa mulai dengan memindahkan karakter pemain dan menentukan kelas <b>PlayerMovementEngine</b> .  Nama mesin harus difokuskan dengan sangat sempit, karena semakin spesifik, semakin besar kemungkinan mesin akan mengikuti Aturan Tanggung Jawab Tunggal.  Penamaan kelas yang tepat di Svelto.ECS sangat mendasar.  Dan tujuannya tidak hanya untuk menunjukkan niat Anda dengan jelas, tetapi juga untuk membantu Anda "melihat" mereka sendiri. <br><br>  Untuk alasan yang sama, penting bahwa mesin Anda berada dalam ruang nama yang sangat khusus.  Jika Anda menentukan ruang nama sesuai dengan struktur folder, beradaptasi dengan konsep Svelto.ECS.  Penggunaan ruang nama tertentu membantu mendeteksi kesalahan desain saat entitas digunakan di dalam ruang nama yang tidak kompatibel.  Misalnya, tidak diasumsikan bahwa objek musuh akan digunakan di dalam ruang nama pemain, kecuali tujuannya adalah untuk melanggar aturan yang terkait dengan modularitas dan kopling objek yang lemah.  Idenya adalah bahwa objek namespace tertentu hanya dapat digunakan di dalamnya atau namespace induk.  Menggunakan Svelto.ECS jauh lebih sulit untuk mengubah kode Anda menjadi spaghetti, di mana dependensi disuntikkan ke kanan dan kiri, dan aturan ini akan membantu Anda meningkatkan standar kualitas kode bahkan lebih tinggi ketika dependensi diabstraksi dengan benar di antara kelas. <br><br>  Dalam Svelto.ECS, abstraksi bergerak maju beberapa baris, tetapi ECS pada dasarnya membantu untuk mengabstraksi data dari logika yang seharusnya memproses data.  Entitas ditentukan oleh data mereka, bukan perilaku mereka.  Dalam hal ini, engine adalah tempat di mana Anda dapat menempatkan perilaku gabungan entitas identik sehingga engine selalu dapat bekerja dengan sekumpulan entitas. <br><br>  Svelto.ECS dan paradigma ECS memungkinkan encoder untuk mencapai salah satu grails suci pemrograman murni, yang merupakan enkapsulasi logika yang ideal.  Mesin tidak boleh memiliki fungsi publik.  Satu-satunya fungsi publik yang harus ada adalah fungsi yang diperlukan untuk mengimplementasikan antarmuka kerangka kerja.  Ini mengarah pada melupakan injeksi dependensi dan membantu menghindari kode buruk yang terjadi ketika menggunakan injeksi dependensi tanpa inversi kontrol.  Mesin harus TIDAK PERNAH tertanam di mesin lain atau jenis kelas apa pun.  Jika Anda berpikir ingin menerapkan mesin, Anda cukup membuat kesalahan mendasar dalam desain kode. <br><br>  Dibandingkan dengan Unity MonoBehaviour, engine sudah menunjukkan keunggulan besar pertama, yaitu kemampuan untuk mengakses semua status entitas jenis ini dari area kode yang sama.  Ini berarti bahwa kode dapat dengan mudah menggunakan keadaan semua objek langsung dari tempat yang sama di mana logika dari objek umum akan dieksekusi.  Selain itu, mesin individual dapat memproses objek yang sama sehingga mesin dapat mengubah keadaan objek, sementara mesin lain dapat membacanya, secara efektif menggunakan dua mesin untuk komunikasi melalui data entitas yang sama.  Contohnya dapat dilihat dengan melihat <b>mesin PlayerGunShootingEngine</b> dan <b>PlayerGunShootingFxsEngine</b> .  Dalam hal ini, dua mesin berada di namespace yang sama, sehingga mereka dapat berbagi data entitas yang sama.  <b>PlayerGunShootingEngine</b> menentukan apakah seorang pemain (musuh) telah rusak, dan menulis nilai <b>lastTargetPosition</b> dari komponen <b>IGunAttributesComponent</b> (yang merupakan komponen <b>PlayerGunEntity</b> ).  <b>PlayerGunShootFxsEngine</b> memproses efek grafis senjata dan membaca posisi target yang dipilih oleh pemain.  Ini adalah contoh interaksi antara mesin melalui polling data.  Nanti dalam artikel ini saya akan menunjukkan bagaimana memungkinkan mekanisme untuk berkomunikasi di antara mereka dengan <i>mendorong data (Data mendorong)</i> atau <i>data mengikat (Data binding)</i> .  Logikanya, mesin tidak boleh menyimpan status. <br><br>  Mesin tidak perlu tahu cara berinteraksi dengan mesin lain.  Komunikasi eksternal terjadi melalui abstraksi, dan Svelto.ECS memecahkan hubungan antara mesin dalam tiga cara resmi yang berbeda, tetapi saya akan membicarakan hal ini nanti.  Mesin terbaik adalah yang tidak memerlukan komunikasi eksternal.  Mesin ini mencerminkan perilaku yang dienkapsulasi dengan baik dan biasanya bekerja melalui loop logis.  Loop selalu dimodelkan menggunakan tugas Svelto.Task di dalam aplikasi Svelto.ECS.  Karena gerakan pemain perlu diperbarui setiap kutu fisik, adalah wajar untuk membuat tugas untuk dilakukan pada setiap kutu fisik.  Svelto.Tasks memungkinkan Anda untuk menjalankan setiap jenis <b>IEnumerator</b> pada beberapa jenis penjadwal.  Dalam hal ini, kami memutuskan untuk membuat tugas di <b>PhysicScheduler</b> , yang memungkinkan Anda untuk memperbarui posisi pemain: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlayerMovementEngine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IRayCaster raycaster, ITime time</span></span></span><span class="hljs-function">)</span></span> { _rayCaster = raycaster; _time = time; _taskRoutine = TaskRunner.Instance.AllocateNewTaskRoutine() .SetEnumerator(PhysicsTick()).SetScheduler(StandardSchedulers.physicScheduler); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PlayerEntityView entityView</span></span></span><span class="hljs-function">)</span></span> { _taskRoutine.Start(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PlayerEntityView entityView</span></span></span><span class="hljs-function">)</span></span> { _taskRoutine.Stop(); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,      //  EnginesRoot    . // ,         . var _playerEntityViews = entityViewsDB.QueryEntityViews&lt;PlayerEntityView&gt;(); var playerEntityView = _playerEntityViews[0]; while (true) { Movement(playerEntityView); Turning(playerEntityView); //   yield,     ! yield return null; } }</span></span></code> </pre><br>  Tugas Svelto.Tasks dapat dilakukan secara langsung atau melalui objek <b>ITaskRoutine</b> .  Saya tidak akan banyak bicara tentang Svelto.Tasks di sini, karena saya menulis artikel lain untuk itu.  Alasan saya memutuskan untuk menggunakan tugas rutin alih-alih meluncurkan implementasi IEnumerator secara langsung adalah sangat diskresioner.  Saya ingin menunjukkan bahwa Anda dapat memulai siklus ketika objek pemain ditambahkan ke mesin dan menghentikannya saat dihapus.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, untuk ini Anda perlu tahu kapan suatu objek ditambahkan dan dihapus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Svelto.ECS memperkenalkan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menambah</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menghapus</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> callback </font><font style="vertical-align: inherit;">untuk mengetahui kapan entitas tertentu ditambahkan atau dihapus. Ini adalah sesuatu yang unik di Svelto.ECS, tetapi pendekatan ini harus digunakan dengan bijak. Saya sering melihat bahwa callback ini disalahgunakan, seperti dalam banyak kasus mereka cukup untuk meminta entitas. Bahkan memiliki referensi entitas sebagai bidang mesin harus dianggap lebih sebagai pengecualian daripada aturan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hanya ketika panggilan balik ini digunakan, mesin harus diwarisi baik dari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SingleEntityViewEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau dari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MultiEntitiesViewEngine &lt;EntityView1, ..., EntityViewN&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sekali lagi, penggunaan data ini harus jarang, dan mereka sama sekali tidak bermaksud melaporkan objek yang akan diproses oleh mesin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesin paling sering mengimplementasikan antarmuka </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IQueryingEntityViewEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini memungkinkan Anda untuk mengakses dan mengekstrak data dari basis data entitas. Ingatlah bahwa Anda selalu dapat meminta objek dari dalam mesin, tetapi saat Anda meminta entitas yang tidak kompatibel dengan namespace di mana mesin berada, Anda harus memahami bahwa Anda sudah melakukan sesuatu yang salah. Mesin tidak boleh berasumsi bahwa entitas dapat diakses, dan harus bekerja pada sekumpulan objek. Seharusnya tidak diasumsikan bahwa akan selalu ada hanya satu pemain dalam permainan, seperti yang saya lakukan dalam contoh kode. Di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EnemyMovementEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ada pendekatan yang sangat umum tentang cara meminta objek: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ready</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Tick().Run(); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> enemyTargetEntityViews = entityViewsDB.QueryEntityViews&lt;EnemyTargetEntityView&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (enemyTargetEntityViews.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targetEntityView = enemyTargetEntityViews[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> enemies = entityViewsDB.QueryEntityViews&lt;EnemyEntityView&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; enemies.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component = enemies[i].movementComponent; component.navMeshDestination = targetEntityView.targetPositionComponent.position; } } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal ini, siklus mesin utama dimulai langsung pada penjadwal yang telah ditentukan. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Centang () .Jalankan ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunjukkan cara terpendek untuk memulai IEnumerator dengan Svelto.Tasks. IEnumerator akan terus menghasilkan ke frame berikutnya sampai setidaknya satu target Musuh ditemukan. Karena kita tahu bahwa akan selalu ada hanya satu tujuan (asumsi buruk lain), saya memilih yang pertama tersedia. Sementara tujuan dari Target Musuh hanya bisa satu (meskipun mungkin ada lebih banyak!), Ada banyak musuh, dan mesin tetap menjaga logika pergerakan untuk semua orang. Dalam hal ini, saya curang, karena saya benar-benar menggunakan Unity Nav Mesh System, jadi yang harus saya lakukan hanyalah mengatur tujuan ke NavMesh. Jujur, saya tidak pernah menggunakan kode Unity NavMesh, jadi saya bahkan tidak yakin cara kerjanya, kode ini hanya diwarisi dari demo Survival asli.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa komponen tidak pernah secara langsung menyediakan dependensi Navmesh Unity. </font><font style="vertical-align: inherit;">Komponen Entity, seperti yang akan saya bahas nanti, harus selalu memaparkan tipe nilai. </font><font style="vertical-align: inherit;">Dalam hal ini, aturan ini juga memungkinkan Anda untuk menjaga kode di bawah kendali, karena tipe nilai bidang </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">navMeshDestination</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dapat diimplementasikan kemudian dengan menggunakan Unity Nav Mesh. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menyelesaikan paragraf di mesin, perhatikan bahwa tidak ada yang namanya mesin terlalu kecil. </font><font style="vertical-align: inherit;">Karena itu, jangan takut untuk menulis mesin yang berisi beberapa baris kode, karena Anda tidak dapat menulis logika di tempat lain, dan Anda perlu mesin Anda untuk mengikuti aturan tanggung jawab yang seragam.</font></font><br><a name="Entity_Views"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Representasi entitas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum itu, kami memperkenalkan konsep Mesin dan definisi abstrak dari Essence, mari sekarang mendefinisikan apa Representasi esensi itu. Saya harus mengakui bahwa dari 5 konsep tempat Svelto.ECS dibangun, Entity Views mungkin adalah yang paling membingungkan. Sebelumnya bernama </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (nama yang diambil dari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kerangka Ash ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), saya menyadari bahwa nama "Node" tidak berarti apa-apa. EntityView mungkin juga menyesatkan karena programmer biasanya terkait dengan representasi konsep yang berasal dari template </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">model view controller</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Model View Controller), bagaimanapun, Svelto.ECS menggunakan View, karena EntityView adalah bagaimana Engine melihat Entity. Saya suka menggambarkannya seperti ini karena tampaknya paling alami, tetapi saya juga bisa menyebutnya EntityMap, karena EntityView menampilkan komponen entitas yang harus diakses oleh mesin. Skema konsep Svelto.ECS ini seharusnya sedikit membantu: </font></font><br><br><img src="https://habrastorage.org/webt/b4/ph/ui/b4phuignfk8myvfpojldjsyxlkq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya sarankan mulai dengan Engine, dan sekarang kita berada di sisi kanan skema ini. Setiap mesin memiliki set sendiri EntityViews. Mesin dapat menggunakan kembali EntityViews yang kompatibel dengan namespace, tetapi paling sering Engine mendefinisikan EntityViews-nya. Mesin tidak peduli apakah entitas Player benar-benar didefinisikan, ia menyatakan fakta bahwa ia membutuhkan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerEntityView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk bekerja. </font><font style="vertical-align: inherit;">Menulis kode tergantung pada kebutuhan Mesin, Anda tidak harus membuat entitas dan bidangnya sebelum Anda memahami cara menggunakannya. </font><font style="vertical-align: inherit;">Dalam skenario yang lebih kompleks, nama EntityView bisa lebih spesifik. </font><font style="vertical-align: inherit;">Sebagai contoh, jika kita harus menulis mesin yang rumit untuk menangani logika pemain dan membuat grafik pemain (atau animasi, dll.), Kita bisa memiliki </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerPhysicEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerPhysicEntityView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , serta </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerGraphicEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerGraphicEntityView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerAnimationEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerAnimationEntityView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nama yang lebih spesifik dapat digunakan, seperti </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerPhysicMovementEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerPhysicJumpEngine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (dll.). </font></font><br><a name="Components"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Komponen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menyadari bahwa mesin memodelkan perilaku untuk sekumpulan data entitas, dan kami memahami bahwa engine tidak menggunakan entitas secara langsung, tetapi menggunakan komponen entitas melalui representasi entitas. Kami menyadari bahwa EntityView adalah kelas yang dapat berisi HANYA komponen publik entitas. Saya juga mengisyaratkan bahwa komponen entitas selalu merupakan antarmuka, jadi mari kita berikan definisi yang lebih baik: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entitas adalah kumpulan data, dan komponen entitas adalah cara untuk mengakses data itu. Jika Anda belum memperhatikan hal ini, mendefinisikan komponen entitas sebagai antarmuka adalah fitur lain yang cukup unik dari Svelto.ECS. Biasanya, komponen dalam kerangka kerja lain adalah objek. Menggunakan antarmuka sebagai gantinya dapat secara signifikan mengurangi kode. Jika Anda mengikuti prinsipnya</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prinsip Segregasi Antarmuka", setelah menulis antarmuka komponen kecil, bahkan dengan masing-masing properti, Anda akan melihat bahwa Anda telah mulai menggunakan kembali antarmuka komponen dalam entitas yang berbeda. Dalam contoh kami, ITransformComponent digunakan kembali dalam banyak representasi entitas. Menggunakan komponen sebagai antarmuka juga memungkinkan mereka untuk mengimplementasikan objek yang sama, yang dalam banyak kasus menyederhanakan hubungan antara entitas yang melihat entitas yang sama menggunakan representasi entitas yang berbeda (atau sama, jika mungkin). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleh karena itu, di Svelto.ECS, komponen entitas selalu merupakan antarmuka, dan antarmuka ini hanya digunakan melalui bidang EntityView di dalam Engine. Antarmuka komponen entitas kemudian diimplementasikan oleh yang disebut</font></font><b>¬´¬ª.      ,       .</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponen harus selalu menyimpan tipe yang bermakna, dan bidang selalu properti. Pengecualian hanya dapat dibuat untuk menulis setter dan getter sebagai metode untuk menggunakan kata kunci ref ketika optimasi diperlukan. Ini tidak berarti bahwa kode tersebut berorientasi data, tetapi akan memungkinkan Anda membuat kode untuk pengujian, karena logika mesin tidak boleh memproses tautan ke dependensi eksternal. Selain itu, ini mencegah coders dari kecurangan pada framework dan menggunakan fungsi publik (yang mungkin termasuk logika!) Objek acak. Satu-satunya alasan Anda bisa merasakan kebutuhan untuk menggunakan tautan di dalam antarmuka komponen entitas adalah untuk berurusan dengan dependensi pihak ketiga, seperti objek Unity. Namun, contoh Kelangsungan Hidup menunjukkan bagaimana menangani ini,meninggalkan kode tes mesin tanpa harus khawatir tentang dependensi Unity.</font></font><br><a name="Entity_Descriptors"></a><br><h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sinilah Penjelas Entitas datang untuk menyelamatkan untuk mengumpulkan semuanya. Kita tahu bahwa engine dapat mengakses data Entity melalui Komponen yang disimpan di Entity Views. Kita tahu bahwa engine adalah kelas, EntityView adalah kelas yang hanya berisi entitas Komponen dan Komponen adalah antarmuka. Meskipun saya memberikan definisi abstrak dari Essence, kami belum melihat satu pun kelas yang benar-benar mewakili Essence. Ini sesuai dengan konsep objek yang merupakan pengidentifikasi dalam sistem ECS modern. Namun, tanpa definisi Entitas yang benar, ini akan memaksa pembuat kode untuk mengidentifikasi Entitas dengan Representasi entitas, yang akan menjadi bencana besar. Representasi entitas adalah cara di mana beberapa Mesin dapat melihat Entitas yang sama,tetapi mereka bukan Entitas. Entitas itu sendiri harus selalu dianggap sebagai set data yang didefinisikan melalui Komponen entitas, tetapi bahkan ini adalah definisi yang lemah. Contoh EntityDescriptor memungkinkan encoder untuk menentukan Entitasnya dengan benar, terlepas dari mesin yang akan memprosesnya. Oleh karena itu, dalam hal Entity Player, kita perlu</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerEntityDescriptor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kelas ini akan digunakan untuk membuat Entitas, dan meskipun apa yang sebenarnya dilakukannya adalah sesuatu yang sama sekali berbeda, fakta bahwa pengguna dapat menulis </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntity &lt;PlayerEntityDescriptor&gt; ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> membantu dengan mudah memvisualisasikan Entitas untuk membangun dan mengomunikasikan niat kepada orang lain. encoders. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, apa yang sebenarnya dilakukan EntityDescriptor adalah membuat daftar EntityViews !!! Pada tahap awal pengembangan kerangka kerja, saya mengizinkan pembuat kode untuk membuat daftar EntityViews ini secara manual, yang menyebabkan kode yang sangat jelek karena tidak bisa lagi memvisualisasikan apa yang sebenarnya terjadi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginilah bentuk </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerEntityDescriptor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Svelto.ECS.Example.Survive.Camera; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Svelto.ECS.Example.Survive.HUD; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Svelto.ECS.Example.Survive.Enemies; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Svelto.ECS.Example.Survive.Sound; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Svelto.ECS.Example.Survive.Player</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlayerEntityDescriptor</span></span> : <span class="hljs-title"><span class="hljs-title">GenericEntityDescriptor</span></span>&lt;<span class="hljs-title"><span class="hljs-title">HUDDamageEntityView</span></span>, <span class="hljs-title"><span class="hljs-title">PlayerEntityView</span></span>, <span class="hljs-title"><span class="hljs-title">EnemyTargetEntityView</span></span>, <span class="hljs-title"><span class="hljs-title">DamageSoundEntityView</span></span>, <span class="hljs-title"><span class="hljs-title">HealthEntityView</span></span>, <span class="hljs-title"><span class="hljs-title">CameraTargetEntityView</span></span>&gt; { } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penjelas entitas (dan Pelaksana) adalah satu-satunya kelas yang dapat menggunakan pengidentifikasi dari beberapa ruang nama. </font><font style="vertical-align: inherit;">Dalam hal ini, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerEntityDescriptor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menentukan daftar EntityViews untuk instantiate dan menyuntikkan ke mesin ketika membuat PlayerEntity.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pemegang EntityDescriptor </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EntityDescriptorHolder adalah ekstensi untuk Unity dan hanya boleh digunakan dalam kasus-kasus tertentu. Yang paling umum adalah penciptaan semacam polimorfisme yang menyimpan informasi tentang Entitas untuk membangun GameObject Persatuan. Dengan demikian, kode yang sama dapat digunakan untuk membuat beberapa jenis Entitas. Sebagai contoh, di Robocraft, kami menggunakan pabrik kubus tunggal yang membangun semua kubus yang membentuk mesin. Jenis kubus untuk rakitan disimpan dalam cetakan kubus itu sendiri. Ini bagus asalkan implementernya sama antara kubus atau ditemukan di GameObject sebagai MonoBehaviour. Membuat Entitas secara langsung lebih disukai, jadi gunakan EntityDescriptorHolders hanya jika Anda benar memahami prinsip-prinsip Svelto.ECS, jika tidak ada risiko penyalahgunaan. Fungsi dari contoh ini menunjukkan cara menggunakan kelas:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildEntitiesFromScene</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">UnityContext contextHolder</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//EntityDescriptorHolder -    Svelto.ECS , //       . //         . //      , //    //     IEntityDescriptorHolder[] entities = contextHolder.GetComponentsInChildren&lt;IEntityDescriptorHolder&gt;(); //     Svelto.ECS, ,   //      . //        . //    EntityDescriptorHolder, //    for (int i = 0; i &lt; entities.Length; i++) { var entityDescriptorHolder = entities[i]; var entityDescriptor = entityDescriptorHolder.RetrieveDescriptor(); _entityFactory.BuildEntity (((MonoBehaviour) entityDescriptorHolder).gameObject.GetInstanceID(), entityDescriptor, (entityDescriptorHolder as MonoBehaviour).GetComponentsInChildren&lt;IImplementor&gt;()); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa dalam contoh ini saya menggunakan fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> non-generik </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Saya akan menjelaskan ini. </font><font style="vertical-align: inherit;">Dalam hal ini, pelaksana adalah kelas MonoBehaviour yang dilampirkan ke GameObject. </font><font style="vertical-align: inherit;">Ini bukan praktik yang baik. </font><font style="vertical-align: inherit;">Saya seharusnya menghapus kode ini dari contoh, tetapi meninggalkan untuk menunjukkan kepada Anda kasus khusus ini. </font><font style="vertical-align: inherit;">Implementer, seperti yang akan kita lihat nanti, harus kelas MonoBehaviour hanya jika diperlukan!</font></font><br><a name="Implementors"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Peniru </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum membuat esensi kami, mari kita mendefinisikan konsep terakhir di Svelto.ECS, yang merupakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Impaler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Seperti yang kita ketahui, Komponen Entitas selalu merupakan antarmuka, dan antarmuka C # harus diimplementasikan. </font><font style="vertical-align: inherit;">Objek yang mengimplementasikan antarmuka ini disebut "implementor". </font><font style="vertical-align: inherit;">Pelaksana memiliki beberapa karakteristik penting:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kemampuan untuk melepaskan jumlah objek yang akan dirakit dari jumlah komponen entitas yang diperlukan untuk menentukan data entitas. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kemampuan untuk bertukar data antara Komponen yang berbeda, karena Komponen memberikan data melalui properti, properti yang berbeda dari suatu Komponen dapat mengembalikan bidang implementasi yang sama. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemampuan untuk membuat rintisan komponen antarmuka untuk komponen entitas. </font><font style="vertical-align: inherit;">Ini penting agar kode mesin tetap diuji.</font></font><br></li><li>      Svelto.ECS   (third party) .     .    Unity,    ,       ,      <b>Monobehaviour</b> .  ,        Unity,   <b>OnTriggerEnter</b> / <b>OnTriggerExit</b> ,         Unity.        ,      .  : <br></li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyTriggerImplementor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span>, <span class="hljs-title"><span class="hljs-title">IImplementor</span></span>, <span class="hljs-title"><span class="hljs-title">IEnemyTriggerComponent</span></span>, <span class="hljs-title"><span class="hljs-title">IEnemyTargetComponent</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; entityInRange; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IEnemyTriggerComponent.targetInRange { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _targetInRange = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IEnemyTargetComponent.targetInRange { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _targetInRange; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTriggerEnter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collider other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInRange != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) entityInRange(other.gameObject.GetInstanceID(), gameObject.GetInstanceID(), <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTriggerExit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collider other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInRange != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) entityInRange(other.gameObject.GetInstanceID(), gameObject.GetInstanceID(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _targetInRange; }</code> </pre><br> <i>,    ,        .    ,     .</i> <br><a name="Build_Entity"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penciptaan Entitas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalkan kita membuat </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami </font><font style="vertical-align: inherit;">, menambahkannya ke </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EnginesRoot</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , menciptakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampilan Entitas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mereka </font><font style="vertical-align: inherit;">, yang membutuhkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebagai antarmuka yang akan diimplementasikan di dalam </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelaksana</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Inilah saatnya untuk menciptakan Essence pertama kami. </font><font style="vertical-align: inherit;">Entitas selalu dibuat melalui turunan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entity Factory yang dibuat oleh EnginesRoot melalui fungsi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GenerateEntityFactory</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tidak seperti instance EnginesRoot, instance IEntityFactory dapat digunakan dan ditransfer. </font><font style="vertical-align: inherit;">Objek dapat dibangun di dalam root komposisi atau secara dinamis di dalam pabrik, jadi untuk kasus yang terakhir, Anda harus melewati IEntityFactory melalui parameter.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IEntityFactory</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hadir dengan beberapa fitur serupa. Dalam artikel ini saya akan melewatkan fungsi penjelasan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PreallocateEntitySlots</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildMetaEntity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , untuk fokus pada fungsi yang paling umum digunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntityInGroup</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang terbaik adalah selalu menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntityInGroup</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi untuk contoh Survival Anda tidak perlu, jadi mari kita lihat bagaimana </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntity yang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> biasa </font><font style="vertical-align: inherit;">digunakan dalam contoh:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntervaledTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  :       //MonoBehaviour    . //       //   . // ,     , //         . //        ,     . //  ,        //   , //  .      , // ,   ,   . var enemiestoSpawn = ReadEnemySpawningDataServiceRequest(); while (true) { //Svelto.Tasks    yield  Unity, //    . //       . // ,  , //    . yield return _waitForSecondsEnumerator; if (enemiestoSpawn != null) { for (int i = enemiestoSpawn.Length - 1; i &gt;= 0 &amp;&amp; _numberOfEnemyToSpawn &gt; 0; --i) { var spawnData = enemiestoSpawn[i]; if (spawnData.timeLeft &lt;= 0.0f) { //          int spawnPointIndex = Random.Range(0, spawnData.spawnPoints.Length); //       . var go = _gameobjectFactory.Build(spawnData.enemyPrefab); //        MonoBehaviour. //      . var data = go.GetComponent&lt;EnemyAttackDataHolder&gt;(); //     MonoBehaviour   // : List&lt;IImplementor&gt; implementors = new List&lt;IImplementor&gt;(); go.GetComponentsInChildren(implementors); implementors.Add(new EnemyAttackImplementor(data.timeBetweenAttacks, data.attackDamage)); //         EntityViews, //     EntityDescriptor. //,       EntityView //  ,     ,  EntityDescriptorHolder //       , //    . _entityFactory.BuildEntity&lt;EnemyEntityDescriptor&gt;( go.GetInstanceID(), implementors.ToArray()); var transform = go.transform; var spawnInfo = spawnData.spawnPoints[spawnPointIndex]; transform.position = spawnInfo.position; transform.rotation = spawnInfo.rotation; spawnData.timeLeft = spawnData.spawnTime; numberOfEnemyToSpawn--; } spawnData.timeLeft -= 1.0f; } } } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingatlah untuk membaca semua komentar dalam contoh ini, mereka akan membantu Anda lebih memahami konsep Svelto.ECS. Karena kesederhanaan contohnya, saya tidak menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BuildEntityInGroup</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang digunakan dalam proyek yang lebih kompleks. Dalam Robocraft, setiap mesin yang memproses logika kubus fungsional memproses logika SEMUA kubus fungsional jenis khusus ini dalam game. Namun, seringkali perlu untuk mengetahui kendaraan milik kubus mana, sehingga menggunakan grup untuk setiap mesin akan membantu memecah kubus dari jenis yang sama menjadi mesin, di mana ID mesin adalah ID grup. Ini memungkinkan kita untuk mengimplementasikan hal-hal keren, seperti menjalankan satu tugas Svelto.Tasks pada mesin di dalam mesin yang sama, yang dapat bekerja secara paralel menggunakan multithreading.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sepotong kode ini menunjukkan satu masalah penting yang dapat saya </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bahas </font><font style="vertical-align: inherit;">lebih detail dalam artikel berikut ... dari komentar (jika Anda belum membacanya): </font><font style="vertical-align: inherit;">Jangan pernah membuat MonoBehaviour Imprementors hanya untuk penyimpanan data. Data harus selalu diambil melalui Lapisan Layanan terlepas dari sumber data. Manfaatnya banyak, termasuk fakta bahwa untuk mengubah sumber data Anda hanya perlu mengubah kode layanan. Dalam contoh sederhana ini, saya tidak menggunakan lapisan Layanan, tetapi secara umum idenya jelas. Perhatikan juga bahwa saya hanya mengunggah data satu kali untuk setiap peluncuran aplikasi, di luar loop utama. Anda selalu dapat menggunakan trik ini jika data yang Anda butuhkan tidak pernah berubah.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awalnya, saya membaca data langsung dari MonoBehaviour, seperti yang dilakukan oleh pembuat kode malas. </font><font style="vertical-align: inherit;">Ini membuat saya membuat implementator serializer baca-saja MonoBehaviore. </font><font style="vertical-align: inherit;">Ini dapat diterima jika kami tidak ingin mengabstraksi sumber data, tetapi jauh lebih baik untuk membuat serialisasi informasi menjadi file json dan membacanya berdasarkan permintaan ke layanan daripada membaca data ini dari Komponen Entitas.</font></font><br><a name="Communication"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Komunikasi di Svelto.ECS </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu masalah yang solusinya belum pernah distandarisasi oleh implementasi ECS adalah komunikasi antar sistem. </font><font style="vertical-align: inherit;">Ini adalah tempat lain di mana saya banyak berpikir, dan Svelto.ECS menyelesaikannya dengan dua cara baru. </font><font style="vertical-align: inherit;">Cara ketiga adalah menggunakan pola Observer / Observed standar, dapat diterima dalam kasus yang sangat spesifik dan spesifik.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DispatchOnSet / DispatchOnChange </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelumnya kami telah melihat cara mengizinkan Mesin untuk bertukar data melalui Komponen Entitas menggunakan Polling Data. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnSet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnChange</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah satu-satunya referensi (tipe tidak signifikan) yang dapat dikembalikan oleh properti Entity Components, tetapi jenis parameter generik T harus merupakan tipe yang bermakna. Nama-nama fungsi terdengar seperti dispatcher acara, tetapi sebaliknya mereka harus dianggap sebagai metode mendorong data, yang bertentangan dengan jajak pendapat data, yang agak mirip dengan pengikatan data. Itu saja, kadang-kadang data polling tidak nyaman, kami tidak ingin polling variabel setiap frame ketika kami tahu bahwa data jarang berubah. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnSet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnChange</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak dapat dimulai tanpa mengubah data, ini memungkinkan kami untuk menganggapnya sebagai mekanisme pengikatan data dan bukan peristiwa biasa. </font><font style="vertical-align: inherit;">Juga tidak ada fungsi peluncuran untuk dipanggil, sebagai gantinya, nilai data yang dimiliki oleh kelas-kelas ini harus diatur atau diubah. </font><font style="vertical-align: inherit;">Tidak ada contoh yang bagus dalam kode Survival, tetapi Anda dapat melihat bagaimana bidang </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">targetHit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boolean </font><font style="vertical-align: inherit;">dari </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IGunHitTargetComponent bekerja</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Perbedaan antara </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnSet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnChange</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah bahwa yang terakhir memecat acara hanya ketika data benar-benar berubah, dan yang sebelumnya selalu.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sequencer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesin Ideal sepenuhnya dienkapsulasi, dan Anda dapat menulis logika mesin ini sebagai urutan instruksi menggunakan Svelto.Tasks dan IEnumerators. Namun, ini tidak selalu memungkinkan, karena dalam beberapa kasus Mesin harus mengirim acara ke Mesin lain. Ini biasanya dilakukan melalui data Entity, terutama menggunakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnSet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DispatchOnChange</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, seperti dalam kasus Entitas ‚Äúrusak‚Äù dalam contoh, serangkaian Mesin independen dan tidak terkait bertindak di atasnya. </font><font style="vertical-align: inherit;">Dalam kasus lain, Anda ingin urutan menjadi ketat dalam urutan mesin yang dipanggil, seperti dalam contoh di mana saya ingin kematian selalu terjadi untuk yang terakhir. </font><font style="vertical-align: inherit;">Dalam hal ini, urutannya tidak hanya sangat mudah digunakan, tetapi juga sangat nyaman! </font><font style="vertical-align: inherit;">Urutan refactoring sangat sederhana. </font><font style="vertical-align: inherit;">Oleh karena itu, gunakan IEnumerator Svelto Tasks untuk mesin "vertikal" dan urutan untuk logika "horizontal" di antara mesin.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengamat / Diamati </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya meninggalkan kesempatan untuk menggunakan pola ini khusus untuk kasus-kasus di mana kode warisan atau kode yang tidak menggunakan Svelto.ECS harus berinteraksi dengan mesin Svelto.ECS. </font><font style="vertical-align: inherit;">Untuk kasus lain, itu harus digunakan dengan sangat hati-hati, karena ada kemungkinan penyalahgunaan pola, karena itu akrab bagi kebanyakan coders yang baru mengenal Svelto.ECS, dan Sequencer biasanya merupakan pilihan terbaik.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413107/">https://habr.com/ru/post/id413107/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413097/index.html">Berdasarkan perangkat lunak tingkat perusahaan, telah diuji jutaan kali: openSUSE Leap 15 dirilis</a></li>
<li><a href="../id413099/index.html">Downclocking ram di macbook</a></li>
<li><a href="../id413101/index.html">STM32F4 Papan Debug dalam Faktor Bentuk Raspberry Pi</a></li>
<li><a href="../id413103/index.html">3CX v15.5 Pembaruan 5 Beta dan integrasi REST dengan AmoCRM dirilis</a></li>
<li><a href="../id413105/index.html">Catatan dari penyedia IoT. Aktivasi dan keamanan di LoraWAN</a></li>
<li><a href="../id413109/index.html">Cara Membangun Platform Integrasi Produk SaaS: Pengalaman Cloud Checkout Poster</a></li>
<li><a href="../id413111/index.html">STM32 + NetBeans =?</a></li>
<li><a href="../id413113/index.html">Dukungan serialisasi JavaScript JavaScript</a></li>
<li><a href="../id413117/index.html">Cara memprogram dengan aman di bash</a></li>
<li><a href="../id413119/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 317 (28 Mei - 3 Juni 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>