<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è´ ‚õ∫Ô∏è üõ°Ô∏è garbage.collect () üë∏üèΩ üßöüèΩ üôÖüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pour ex√©cuter JavaScript, le navigateur a besoin d'un peu de m√©moire, mais quelque part vous devez stocker des objets, des primitives, des fonctions q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>garbage.collect ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433318/"> Pour ex√©cuter JavaScript, le navigateur a besoin d'un peu de m√©moire, mais quelque part vous devez stocker des objets, des primitives, des fonctions qui sont cr√©√©es pour toutes les actions de l'utilisateur.  Par cons√©quent, le navigateur alloue d'abord la quantit√© de RAM requise, et lorsque les objets ne sont pas utilis√©s, il les nettoie ind√©pendamment. <br><br>  En th√©orie, √ßa sonne bien.  En pratique, l'utilisateur ouvre 20 onglets sur YouTube, les r√©seaux sociaux, lit quelque chose, fonctionne, le navigateur mange de la m√©moire, comme Hummer H2 - essence.  Le garbage collector, comme ce monstre avec une vadrouille, parcourt toute la m√©moire et ajoute de la confusion, tout ralentit et se bloque. <br><br><img src="https://habrastorage.org/webt/uc/vx/ke/ucvxke3xzwiqngna7opkqwllmq4.jpeg"><br><br>  Pour √©viter que de telles situations ne se produisent et que les performances de nos sites et applications ne souffrent pas, le d√©veloppeur front-end devrait savoir comment les ordures affectent les applications, comment le navigateur les collecte et optimise le travail avec la m√©moire, et comment tout cela diff√®re de la dure r√©alit√©.  Ce n'est que le rapport d' <strong>Andrei Roenko ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">flapenguin</a> )</strong> √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Frontend Conf 2018</a> . <br><br>  Nous utilisons le ramasse-miettes (pas √† la maison - dans le d√©veloppement frontal), mais nous ne pensons pas vraiment √† ce que c'est, √† ce qu'il nous en co√ªte et √† ses opportunit√©s et limitations. <br><br><blockquote>  Si le garbage collection fonctionnait vraiment en JavaScript, la plupart des modules npm se supprimeraient imm√©diatement apr√®s l'installation. <br></blockquote><br>  Mais bien que ce ne soit pas le cas, et nous parlerons de ce qui est - de l'assemblage d'objets inutiles. <br><br><a name="habracut"></a><iframe width="560" height="315" src="https://www.youtube.com/embed/tDbRVZqwxn4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√Ä propos du conf√©rencier</strong> : <strong>Andrei Roenko a</strong> d√©velopp√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'API Yandex.Map</a> , a √©t√© dans le frontend depuis six ans maintenant, il aime cr√©er ses propres abstractions √©lev√©es et descendre au sol d'√©trangers. <br><br><h2>  Pourquoi avez-vous besoin d'une collecte des ordures? <br></h2><br>  Prenons l'exemple de Yandex.Maps.  Yandex.Maps est un service √©norme et complexe qui utilise beaucoup de JS et presque toutes les API de navigateur existantes, √† l'exception des multim√©dias, et le temps de session moyen est de 5-10 minutes.  L'abondance de JavaScript cr√©e de nombreux objets.  Faire glisser la carte, ajouter des organisations, des r√©sultats de recherche et de nombreux autres √©v√©nements se produisant √† chaque seconde cr√©e une avalanche d'objets.  Ajoutez √† cela React et les objets deviennent encore plus. <br><br>  Cependant, les objets JS n'occupent que 30 √† 40 Mo sur la carte.  Pour les longues sessions Yandex.Maps et l'allocation constante de nouveaux objets, cela ne suffit pas. <br><br><blockquote>  La raison du petit volume d'objets est qu'ils sont correctement collect√©s par le garbage collector et la m√©moire est r√©utilis√©e. <br></blockquote><br>  Aujourd'hui, nous allons parler de la collecte des ordures sur quatre c√¥t√©s: <br><br><ul><li>  <strong>Th√©orie</strong>  Commen√ßons par elle √† parler la m√™me langue et √† se comprendre. </li><li>  <strong>Une dure r√©alit√©.</strong>  En fin de compte, l'ordinateur ex√©cute du code machine dans lequel toutes les abstractions ne nous sont pas famili√®res.  Essayons de comprendre comment fonctionne la collecte des ordures √† un niveau bas. </li><li>  <strong>R√©alit√© du navigateur.</strong>  Voyons comment la r√©cup√©ration de place est impl√©ment√©e dans les moteurs et navigateurs modernes, et quelles conclusions nous pouvons en tirer. </li><li>  <strong>Vie quotidienne</strong> - parlons de l'application pratique des connaissances acquises dans la vie quotidienne. </li></ul><br>  Nous soutenons toutes les d√©clarations avec des exemples de la fa√ßon dont vous pouvez et comment vous n'avez pas besoin de le faire. <br><br><h2>  Pourquoi savoir tout √ßa? </h2><br>  La collecte des ordures est une chose invisible pour nous, cependant, sachant comment elle est organis√©e, vous: <br><br><ul><li>  Ayez une id√©e de l'outil que vous utilisez, qui est utile dans votre travail. </li><li>  Comprendre o√π optimiser les applications d√©j√† publi√©es et comment concevoir les futures pour qu'elles fonctionnent mieux et plus rapidement. </li><li>  Sachez ne pas commettre d'erreurs courantes et ne perdez pas de ressources sur des ¬´optimisations¬ª inutiles et nuisibles. </li></ul><br><h2>  Th√©orie <br></h2><br>  Joel Spolsky a dit un jour: <br><br><blockquote>  Toutes les abstractions non triviales fuient. <br></blockquote><br>  Le garbage collector est une grande abstraction non triviale qui est corrig√©e de tous les c√¥t√©s.  Heureusement, il coule tr√®s rarement. <br><br>  Commen√ßons par une th√©orie, mais sans d√©finitions ennuyeuses.  Analysons le travail du collecteur en utilisant du code simple comme exemple: <br><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.Foo = <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = { <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'y'</span></span> }; } work(name) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = <span class="hljs-string"><span class="hljs-string">'z'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.xy, z); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } };</code> </pre> <br><ul><li>  Il y a une <strong>classe</strong> dans le code. </li><li>  La classe a un <strong>constructeur</strong> . </li><li>  <strong>La m√©thode de travail</strong> renvoie une fonction associ√©e. </li><li>  √Ä l'int√©rieur de la fonction, <strong>cette</strong> variable et quelques variables de la fermeture sont utilis√©es. </li></ul><br>  Voyons comment ce code se comportera si nous l'ex√©cutons de cette fa√ßon: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); <span class="hljs-comment"><span class="hljs-comment">//C   window.worker = foo.work('Brendan Eich'); //     bind,   window.foo = null; //   window.Foo = null; //  ,   -  window.worker(); window.worker = null; //   ,  </span></span></code> </pre><br>  Analysons le code et ses composants plus en d√©tail et commen√ßons par la classe. <br><br><h3>  D√©claration de classe <br></h3><br><img src="https://habrastorage.org/webt/nd/yq/ie/ndyqietonv9ggcg45mvfmwnsyae.png"><br><br>  Nous pouvons supposer que les classes dans ECMAScript 2015 ne sont que du sucre syntaxique pour les fonctions.  Toutes les fonctions ont: <br><br><ul><li>  <strong>Fonction. [[Prototype]]</strong> est le v√©ritable prototype de la fonction. </li><li>  <strong>Foo.prototype</strong> est un prototype pour des objets fra√Æchement cr√©√©s. </li><li>  Foo.prototype a un lien vers le constructeur via le champ constructeur.  Il s'agit d'un objet, il h√©rite donc de <strong>Object.prototype</strong> . </li><li>  <strong>La m√©thode de travail est une</strong> fonction distincte √† laquelle il existe un lien, similaire au constructeur, car ce ne sont que des fonctions.  Il peut √©galement d√©finir un prototype et l'appeler via new, mais personne n'utilise rarement ce comportement. </li></ul><br>  Les prototypes occupent beaucoup d'espace sur le circuit, alors rappelons-le qu'ils le sont, mais les supprimeront pour plus de simplicit√©. <br><br><h3>  Cr√©ation d'un objet de classe <br></h3><br><img src="https://habrastorage.org/webt/f_/ea/5u/f_ea5uuq01wygmqkdfbrj4a8oja.png"><br><br><ul><li>  Nous mettons notre classe en fen√™tre, car les classes n'y arrivent pas par d√©faut. </li><li>  Cr√©ez un objet de classe. </li><li>  La cr√©ation d'un objet expose automatiquement le prototype de l'objet de classe dans Foo.prototype.  Par cons√©quent, lorsque vous essayez d'appeler la m√©thode de travail sur un objet, il saura de quel type de travail il s'agit. </li><li>  Notre constructeur cr√©e le champ <em>x</em> dans l'objet √† partir de l'objet avec la cha√Æne. </li></ul><br>  Voici ce qui s'est pass√©: <br><br><img src="https://habrastorage.org/webt/nb/xx/d1/nbxxd11pg7bmutfnn4bqh3_ooxs.png"><br><br>  La m√©thode retourne une fonction li√©e - il s'agit d'un objet sp√©cial "magique" dans JS, qui se compose d'un ceci li√© et d'une fonction qui doit √™tre appel√©e.  La fonction associ√©e a √©galement un prototype et un autre prototype, mais nous nous int√©ressons √† la fermeture.  Par sp√©cification, la fermeture est stock√©e dans l'environnement.  Vous connaissez probablement le mot Scope, mais <strong>dans les sp√©cifications, le champ est appel√© Environnement</strong> . <br><br><img src="https://habrastorage.org/webt/dv/zu/rn/dvzurne2uerkhr0vqxeahna5cum.png"><br><br>  L'environnement stocke une r√©f√©rence √† LexicalEnvironment.  Il s'agit d'un objet complexe, plus compliqu√© que sur une diapositive; il stocke des liens vers tout ce qui est accessible √† partir d'une fonction.  Par exemple, window, Foo, name et z.  Il stocke √©galement des liens vers ce que vous n'utilisez pas explicitement.  Par exemple, vous pouvez utiliser eval et utiliser accidentellement des objets inutilis√©s, mais JS ne doit pas se casser. <br><br>  Donc, nous avons construit tous les objets et maintenant nous allons tout d√©truire. <br><br><h3>  Supprimer le lien vers l'objet <br></h3><br>  Commen√ßons par supprimer le lien vers l'objet, ce lien dans le diagramme est surlign√© en rouge. <br><br><img src="https://habrastorage.org/webt/zp/g_/mf/zpg_mfnx7pgoc1q46ruedg5oeve.png"><br><br>  Nous supprimons et rien ne se passe, car de la <strong>fen√™tre</strong> √† l'objet, il y a un chemin √† travers la <strong>fonction li√©e</strong> . <br><br><img src="https://habrastorage.org/webt/_w/lv/v6/_wlvv6dpon2qnjgaukobadopmas.png"><br><br>  Cela nous pousse √† une erreur typique. <br><br><h3>  Erreur courante - abonnement oubli√© <br></h3><br><pre> <code class="javascript hljs">externalElement.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shouldDoSomethingOnClick) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomething(); } })</code> </pre><br>  Se produit lorsque vous vous abonnez: en l'utilisant <strong>,</strong> explicitement via les fonctions de liaison ou de fl√®che;  utiliser quelque chose dans la fermeture.  Ensuite, vous oubliez de vous d√©sabonner et la dur√©e de vie de votre objet ou de ce qui se trouve dans le circuit devient la m√™me que la dur√©e de vie d'un abonnement.  Par exemple, s'il s'agit d'un √©l√©ment DOM que vous ne touchez pas, il s'agit tr√®s probablement du d√©lai jusqu'√† la fin de la vie de la page. <br><br>  Pour r√©soudre ces probl√®mes: <br><br><ul><li>  Se d√©sinscrire. </li><li>  R√©fl√©chissez √† la dur√©e de vie de l'abonnement et √† qui en est propri√©taire. </li><li>  Si pour une raison quelconque vous ne pouvez pas vous d√©sinscrire, alors annulez les liens (que ce soit = ‚Äã‚Äãnull), ou nettoyez tous les champs de l'objet.  Si votre objet fuit, il sera petit et ce n'est pas dommage. </li><li>  Utilisez WeakMap, peut-√™tre que cela vous aidera dans certaines situations. </li></ul><br><h3>  Supprimer la r√©f√©rence de classe <br></h3><br>  Allez-y et essayez de supprimer le lien rouge mis en √©vidence par la classe. <br><br><img src="https://habrastorage.org/webt/px/sm/yf/pxsmyfvo0utc5d1wh3rfrqcpmlc.png"><br><br>  Nous supprimons le lien et rien ne change pour nous.  La raison en est que la classe est accessible via BoundThis, dans laquelle il existe un lien vers le prototype, et dans le prototype, il existe un lien vers le constructeur. <br><br><h3>  <s>Erreur</s> typique du travail inutile <br></h3><br>  Pourquoi toutes ces d√©monstrations sont-elles n√©cessaires?  Parce qu'il y a un revers au probl√®me lorsque les gens prennent le conseil d'annuler les liens trop litt√©ralement et d'annuler tout en g√©n√©ral. <br><br><pre> <code class="javascript hljs">destroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._x = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._y = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  10 this._foobar = null }</span></span></code> </pre><br>  C'est un travail assez inutile.  Si l'objet se compose uniquement de r√©f√©rences √† d'autres objets et qu'il n'y a pas de ressources l√†-bas, alors destroy () n'est pas n√©cessaire.  Il suffit de perdre la r√©f√©rence √† l'objet, et il mourra de lui-m√™me. <br><br>  Il n'y a pas de conseil universel.  Lorsque cela est n√©cessaire, annulez et, dans le cas contraire, ne l'annulez pas.  La remise √† z√©ro n'est pas une erreur, mais simplement un travail inutile. <br><br>  Allez-y.  Appelez la m√©thode de la fonction li√©e et elle supprimera le lien entre [object Foo] et [object Object].  Cela entra√Ænera le fait que des objets s√©par√©s dans un rectangle bleu apparaissent dans le diagramme. <br><br><img src="https://habrastorage.org/webt/zl/ep/xc/zlepxcvklqpricdvth4gxnjp2ny.png"><br><br>  Ces objets sont des ordures JS.  Il va tr√®s bien.  Cependant, il y a des d√©chets qui ne peuvent pas √™tre collect√©s. <br><br><h3>  Des ordures qui ne vont pas <br></h3><br>  Dans de nombreuses API de navigateur, vous pouvez cr√©er et d√©truire un objet.  Si l'objet n'est pas d√©truit, aucun collectionneur ne peut l'assembler. <br><br>  Objets avec fonctions de cr√©ation / suppression de paires: <br><br><ul><li>  createObjectURL (), revokeObjectURL (); </li><li>  WebGL: cr√©er / supprimer un programme / shader / tampon / texture / etc; </li><li>  ImageBitmap.close (); </li><li>  indexDb.close (). </li></ul><br>  Par exemple, si vous oubliez de supprimer ObjectURL d'une vid√©o de 200 Mo, ces 200 Mo resteront en m√©moire jusqu'√† la fin de la vie de la page et m√™me plus longtemps, car il y a un √©change de donn√©es entre les onglets.  De m√™me dans WebGL, indexDb et d'autres API de navigateur avec des ressources similaires. <br><br>  Heureusement, dans notre exemple, le rectangle bleu contient uniquement des objets JavaScript, il ne s'agit donc que de d√©chets qui peuvent √™tre supprim√©s. <br><br>  L'√©tape suivante consiste √† effacer le dernier lien de gauche √† droite.  Il s'agit d'une r√©f√©rence √† la m√©thode que nous avons re√ßue, une fonction connexe. <br><br><img src="https://habrastorage.org/webt/5g/k5/h9/5gk5h96gg6zpw4bi64mq1guopom.png"><br><br>  Apr√®s sa suppression, nous n'aurons plus de liens √† gauche et √† droite?  En fait, il y a encore des liens depuis la fermeture. <br><br><img src="https://habrastorage.org/webt/hy/s0/vy/hys0vysevtslyjbht0gjngdaqaq.png"><br><br>  Il est important qu'il n'y ait pas de liens de gauche √† droite, donc tout sauf la fen√™tre est une ordure et elle mourra. <br><br>  <strong>Remarque importante</strong> : il y a des r√©f√©rences circulaires dans la poubelle, c'est-√†-dire des objets qui se r√©f√®rent les uns aux autres.  La pr√©sence de tels liens n'affecte rien, car le garbage collector ne collecte pas les objets individuels, mais l'ensemble des d√©chets. <br><br><img src="https://habrastorage.org/webt/hl/qq/4f/hlqq4fn3nlubl4aefqycqyi4v8u.png"><br><br>  Nous avons regard√© les exemples et maintenant √† un niveau intuitif nous comprenons ce que sont les ordures, mais donnons une d√©finition compl√®te du concept. <br><br><blockquote>  La poubelle est tout ce qui n'est pas un objet vivant. <br></blockquote><br>  Tout est devenu tr√®s clair.  Mais qu'est-ce qu'un objet vivant? <br><br>  <strong>Un objet vivant est un objet qui peut √™tre atteint par des liens depuis l'objet racine.</strong> <br><br>  Deux nouveaux concepts apparaissent: ¬´suivre les liens¬ª et ¬´objet racine¬ª.  Un objet racine que nous connaissons d√©j√† est la fen√™tre, alors commen√ßons par les liens. <br><br><h3>  Que signifie suivre les liens? <br></h3><br>  Il existe de nombreux objets li√©s les uns aux autres et se r√©f√©rant les uns aux autres.  Nous allons les onduler, en commen√ßant par l'objet racine. <br><br>  Nous initialisons la premi√®re √©tape, puis proc√©dons selon l'algorithme suivant: disons que tout sur la cr√™te de la vague est des objets vivants et voyons √† quoi ils se r√©f√®rent. <br><br><img src="https://habrastorage.org/webt/qd/vc/gv/qdvcgvf0tjyk-i85yx9_yzivgs8.png"><br><br>  Nous initialisons la premi√®re √©tape.  Ensuite, nous agirons selon l'algorithme suivant: disons que tout ce qui est jaune sur la cr√™te de la vague est des objets vivants et voyons √† quoi ils se r√©f√®rent. <br><br>  √Ä quoi ils se r√©f√®rent, nous allons faire une nouvelle cr√™te de la vague: <br><br><img src="https://habrastorage.org/webt/k-/5p/bz/k-5pbzevhodbxxsj1ktayvgio34.png"><br><br>  Termin√© et recommencer: <br><br><ul><li>  Nous revivons. </li><li>  Nous regardons √† quoi ils se r√©f√®rent. </li><li>  Cr√©ez une nouvelle cr√™te de vague, animez des objets. </li><li>  Nous regardons √† quoi ils se r√©f√®rent. </li></ul><br><img src="https://habrastorage.org/webt/nd/bb/8d/ndbb8dwnwadhclwfucgkozu42ea.png"><br><br>  Remarquant qu'une fl√®che pointe vers un objet d√©j√† vivant, nous ne faisons tout simplement rien.  Plus loin selon l'algorithme, jusqu'√† √©puisement des objets √† contourner.  Ensuite, nous disons que nous avons trouv√© tous les objets vivants, et tout le reste est des ordures. <br><br><img src="https://habrastorage.org/webt/pw/ms/6z/pwms6zisv2hasovzir04jtjna0k.png"><br><br>  Ce processus est appel√© <strong>marquage</strong> . <br><br><h3>  Que signifie l'objet racine? <br></h3><br><br><ul><li>  Fen√™tre </li><li>  Presque toutes les API de navigateur. </li><li>  Tous promettent. </li><li>  Tout ce qui est mis dans Microtask et Macrotask. </li><li>  Observateurs de mutations, RAF, rappels au ralenti.  Tout ce qui peut √™tre atteint √† partir de ce qui se trouve dans la RAF ne peut pas √™tre supprim√©, car si vous supprimez l'objet utilis√© dans la RAF, quelque chose ira probablement mal. </li></ul><br>  L'assemblage peut avoir lieu √† tout moment.  Chaque fois que des accolades ou une fonction apparaissent, un nouvel objet est cr√©√©.  Il n'y a peut-√™tre pas assez de m√©moire et le collectionneur ira chercher gratuitement: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, z</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = {}; <span class="hljs-comment"><span class="hljs-comment">// nomem, run gc D: // ‚Ä¶ } while (whatever()) bar(); }</span></span></code> </pre><br>  Dans ce cas, les objets racine seront tout sur la pile des appels.  Si, par exemple, vous vous arr√™tez √† la ligne avec X et supprimez ce √† quoi Y fait r√©f√©rence, votre application se bloquera.  JS ne nous autorise pas de telles frivolit√©s, vous ne pouvez donc pas supprimer un objet de Y. <br><br>  Si la partie pr√©c√©dente vous paraissait compliqu√©e, ce sera encore plus difficile. <br><br><h2>  Une dure r√©alit√© <br></h2><br>  Parlons du monde des machines dans lequel nous traitons le fer, les supports physiques. <br><br>  La m√©moire est un grand tableau dans lequel se trouvent uniquement des nombres, par exemple: nouveau Uint32Array (16 * 2 ** 30). <br><br>  Cr√©ons des objets en m√©moire et ajoutons-les de gauche √† droite.  Nous cr√©ons un, deuxi√®me, troisi√®me - ils sont tous de tailles diff√©rentes.  Nous avons mis des liens le long du chemin. <br><img src="https://habrastorage.org/webt/rg/ly/oy/rglyoyk5kjjz0re9ktp1m7r0dtg.png"><br><br>  Au septi√®me objet, la place est termin√©e, car nous avons 2 places libres, mais nous en avons besoin de 5. <br><br>  Que peut-on faire ici?  La premi√®re option consiste √† planter.  Dans la cour en 2018, tout le monde a les derniers MacBooks et 16 Go de RAM.  Il n'y a pas de situations o√π il n'y a pas de m√©moire! <br><br>  Cependant, laisser les choses suivre leur cours est une mauvaise id√©e, car sur le Web, cela conduit √† un √©cran similaire: <br><br><img src="https://habrastorage.org/webt/un/lw/gn/unlwgnwcw1-7p5xunjhvo2hfwzg.png"><br><br>  Ce n'est pas le comportement que nous voulons du programme, mais en g√©n√©ral, il est valide.  Il existe une cat√©gorie de collectionneurs appel√©e <strong>No-op</strong> . <br><br><h3>  Collecteur sans op√©ration <br></h3><br>  Avantages: <br><br><ul><li>  Le collecteur est tr√®s simple. </li><li>  Il n'y a tout simplement pas de collecte des ordures. </li><li>  Pas besoin d'√©crire ou de penser √† la m√©moire. </li></ul><br>  Inconv√©nients: <br><br><ul><li>  Tout tombe pour qu'il ne remonte plus. </li></ul><br>  Pour le frontend, le collecteur no-op n'est pas pertinent, mais est utilis√© sur le backend.  Par exemple, ayant plusieurs serveurs derri√®re les √©quilibreurs, l'application re√ßoit 32 Go de RAM, puis elle est enti√®rement d√©truite.  C'est plus simple et les performances ne sont am√©lior√©es qu'en red√©marrant simplement lorsque la m√©moire devient faible. <br><br>  Sur le Web, c'est impossible et vous devez le nettoyer. <br><br><h3>  Rechercher et supprimer les ordures <br></h3><br>  Nous commen√ßons le nettoyage avec des ordures.  Nous savons d√©j√† comment proc√©der.  Ordures - objets C et F dans le sch√©ma pr√©c√©dent, car vous ne pouvez pas les atteindre le long des fl√®ches depuis l'objet racine. <br><br>  Nous prenons ces ordures, les donnons √† l'amateur d'ordures et vous avez termin√©. <br><br><img src="https://habrastorage.org/webt/g8/1l/s1/g81ls1ji6sco7buvbftj6xgr714.png"><br><br>  Apr√®s le nettoyage, le probl√®me n'est pas r√©solu, car des trous restent dans la m√©moire.  Veuillez noter qu'il y a 7 cases gratuites, mais 5 d'entre elles ne peuvent toujours pas √™tre attribu√©es.  Une fragmentation s'est produite et l'assemblage √©tait termin√©.  Un tel algorithme avec des trous s'appelle <strong>Mark et Sweep</strong> . <br><br><h3>  Marquer et balayer <br></h3><br>  Avantages: <br><br><ul><li>  Un algorithme tr√®s simple.  L'un des premiers que vous d√©couvrirez si vous commencez √† vous renseigner sur Garbage collector. </li><li>  Cela fonctionne proportionnellement √† la quantit√© de d√©chets, mais ne fait face que lorsqu'il y a peu de d√©chets. </li><li>  Si vous n'avez que des objets vivants, alors il ne perd pas de temps et ne fait rien. </li></ul><br>  Inconv√©nients: <br><br><ul><li>  Il faut une logique complexe pour rechercher de l'espace libre, car quand il y a beaucoup de trous dans la m√©moire, vous devez essayer un objet dans chacun pour comprendre s'il convient ou non. </li><li>  Fragment la m√©moire.  Une situation peut se produire avec 200 Mo libres, la m√©moire est divis√©e en petits morceaux et, comme dans l'exemple ci-dessus, il n'y a pas de m√©moire solide pour l'objet. </li></ul><br>  Nous recherchons d'autres id√©es.  Si vous regardez l'image et pensez, la premi√®re pens√©e est de tout d√©placer vers la gauche.  Ensuite, √† droite, il y aura une grande pi√®ce libre dans laquelle notre objet s'ins√©rera calmement. <br><br>  Il existe un tel algorithme et il s'appelle <strong>Mark et Compact</strong> . <br><br><h3>  Marque et compact <br></h3><br>  Avantages: <br><br><ul><li>  M√©moire de d√©fragmentation. </li><li>  Il fonctionne proportionnellement au nombre d'objets vivants, ce qui signifie qu'il peut √™tre utilis√© lorsqu'il n'y a pratiquement pas de d√©bris. </li></ul><br>  Inconv√©nients: <br><br><ul><li>  Difficile dans le travail et la mise en ≈ìuvre. </li><li>  D√©place des objets.  Nous avons d√©plac√© l'objet, copi√©, maintenant il est dans un endroit diff√©rent et toute l'op√©ration est assez ch√®re. </li><li>  Il n√©cessite 2-3 passages dans la m√©moire, selon l'impl√©mentation - l'algorithme est lent. </li></ul><br>  Nous arrivons ici √† une autre id√©e. <br><br><h3>  La collecte des ordures n'est pas gratuite <br></h3><br>  Dans les API hautes performances telles que WebGL, WebAudio et WebGPU, qui est toujours en d√©veloppement, les objets sont cr√©√©s et supprim√©s dans des phases distinctes.  Ces sp√©cifications sont √©crites afin que la r√©cup√©ration de place ne soit pas en cours.  De plus, il n'y a m√™me pas de promesse, mais pull () - vous demandez simplement √† chaque image: "Quelque chose s'est-il pass√© ou non?". <br><br><h3>  Semispace aka Lisp 2 <br></h3><br>  Il y a un autre collectionneur dont je veux parler.  Et si vous ne lib√©rez pas de m√©moire, mais copiez tous les objets vivants quelque part dans un autre endroit. <br><br>  Essayons de copier l'objet racine "tel quel", qui fait r√©f√©rence quelque part. <br><br><img src="https://habrastorage.org/webt/oe/ck/uc/oeckucvn6dpbz9hgbg3ykkzmylm.png"><br><br>  Et puis tout le monde. <br><br><img src="https://habrastorage.org/webt/rf/ds/9x/rfds9xc3v1tp6pvlpokawj8pkn0.png"><br><br>  Il n'y a aucun d√©bris ou trou dans la m√©moire ci-dessus.  Tout semble aller bien, mais deux probl√®mes se posent: <br><br><ul><li>  Objets en double - nous avons deux objets verts et deux bleus.  Lequel utiliser? </li><li>  Les liens √† partir de nouveaux objets m√®nent √† d'anciens objets et non les uns aux autres. </li></ul><br>  Avec les liens, tout est r√©solu √† l'aide d'une ¬´magie¬ª algorithmique sp√©ciale, et nous pouvons faire face √† la duplication d'objets en supprimant tout ci-dessous. <br><img src="https://habrastorage.org/webt/cq/sr/ur/cqsrurkhqp_b01qsxjhzndggryg.png"><br><br>  En cons√©quence, nous avons de l'espace libre et seulement des objets vivants dans l'ordre normal ci-dessus.  Cet algorithme est appel√© <strong>Semispace</strong> , <strong>Lisp 2,</strong> ou simplement le ¬´collecteur de copie¬ª. <br><br>  Avantages: <br><br><ul><li>  M√©moire de d√©fragmentation. </li><li>  C'est simple. </li><li>  Peut √™tre combin√© avec une phase de d√©rivation. </li><li>  Il fonctionne proportionnellement au nombre d'objets vivants dans le temps. </li><li>  Fonctionne bien quand il y a beaucoup de d√©chets.  Si vous avez 2 Go de m√©moire et 3 objets, vous contournerez seulement 3 objets et les 2 Go restants semblent avoir disparu. </li></ul><br>  Inconv√©nients: <br><br><ul><li>  Double consommation de m√©moire.  Vous utilisez la m√©moire 2 fois plus que n√©cessaire. </li><li>  D√©placer des objets n'est pas non plus une op√©ration tr√®s bon march√©. </li></ul><br><blockquote>  Remarque: les ramasse-miettes peuvent d√©placer des objets. <br></blockquote><br>  Sur le Web, cela n'est pas pertinent, mais sur Node.js m√™me beaucoup.  Si vous √©crivez l'extension en C ++, le langage ne sait pas tout cela, il y a donc des liens doubles appel√©s handle et ressemblent √† ceci: v8 :: Local &lt;v8 :: String&gt;. <br><br>  Par cons√©quent, si vous allez √©crire des plugins pour Node.js, les informations vous seront utiles. <br><br>  Nous r√©sumons les diff√©rents algorithmes avec leurs avantages et inconv√©nients dans le tableau.  Il a √©galement un algorithme Eden, mais √† ce sujet plus tard. <br><br><img src="https://habrastorage.org/webt/s9/zm/ec/s9zmecoite95yruxuvtafbzaimy.png"><br><br>  Je veux vraiment un algorithme sans contre, mais ce n'est pas le cas.  Par cons√©quent, nous prenons le meilleur de tous les mondes: nous utilisons plusieurs algorithmes en m√™me temps.  Dans un morceau de m√©moire, nous collectons les ordures avec un algorithme, et dans un autre avec un autre algorithme. <br><br>  Comment comprendre l'efficacit√© de l'algorithme dans une telle situation? <br><br>  Nous pouvons utiliser les connaissances de maris intelligents des ann√©es 60 qui ont examin√© tous les programmes et r√©alis√©: <br><br><blockquote>  Hypoth√®se g√©n√©rationnelle faible: la plupart des objets meurent jeunes. <br></blockquote><br>  Ils voulaient dire que tous les programmes ne font que produire des ordures.  Pour tenter d'utiliser les connaissances, nous arriverons √† ce que l'on appelle ¬´l'assemblage par les g√©n√©rations¬ª. <br><br><h3>  Assemblage g√©n√©rationnel <br></h3><br>  Nous cr√©ons deux morceaux de m√©moire qui ne sont en aucun cas connect√©s: √† gauche, Eden, et √† droite, Mark et Sweep lents.  En Eden, nous cr√©ons des objets.  Beaucoup d'objets. <br><br><img src="https://habrastorage.org/webt/_y/rt/tc/_yrttco6brh1zyz4sqkiuk4wrjo.png"><br><br>  Quand Eden dit qu'il est plein, nous commen√ßons la collecte des ordures.  Nous trouvons des objets vivants et les copions vers un autre collectionneur. <br><br><img src="https://habrastorage.org/webt/38/si/a5/38sia5sg1nhfx6elimcuitdpqok.png"><br><br>  Eden lui-m√™me est compl√®tement nettoy√© et nous pouvons y ajouter des objets. <br><br><img src="https://habrastorage.org/webt/pp/qc/3_/ppqc3_uk1okblort71qjndj7ije.png"><br><br>  En nous basant sur l'hypoth√®se des g√©n√©rations, nous avons d√©cid√© que les objets c, g, i vivraient tr√®s probablement longtemps, et vous pouvez les v√©rifier moins souvent.  Connaissant cette hypoth√®se, vous pouvez √©crire des programmes qui trompent le collectionneur.  Cela peut √™tre fait, mais je ne vous conseille pas, car cela entra√Ænera presque toujours des effets ind√©sirables.  Si vous cr√©ez des d√©chets √† vie longue, le collectionneur commencera √† croire qu'ils n'ont pas besoin d'√™tre collect√©s. <br><br>  Un exemple classique de tricherie est LRU-cache.  Un objet reste longtemps dans le cache, le collectionneur le regarde et pense qu'il ne le collectera pas encore, car l'objet va vivre tr√®s longtemps.  Ensuite, un nouvel objet entre dans le cache, et un grand ancien est pouss√© hors de lui et il n'est plus possible d'assembler imm√©diatement ce grand objet. <br><br>  Comment collecter maintenant nous savons.  Parlez du moment de la collecte. <br><br><h3>  Quand collecter? <br></h3><br>  L'option la plus simple consiste √† <strong>tout arr√™ter</strong> , √† d√©marrer la g√©n√©ration, puis √† recommencer le travail JS. <br><br><img src="https://habrastorage.org/webt/e-/1n/od/e-1nodx10w_v6q7x5w7xi9xdfvk.png"><br><br>  Dans les ordinateurs modernes, plus d'un thread d'ex√©cution.  Sur le Web, cela est connu des Web Workers.  Pourquoi ne pas prendre et <strong>parall√©liser le processus d'assemblage</strong> .  Effectuer plusieurs petites op√©rations en m√™me temps sera plus rapide qu'une grande. <br><br><img src="https://habrastorage.org/webt/y6/yw/jh/y6ywjhxlis6qhu7kk5cumaruayu.png"><br><br>  Une autre id√©e est de faire soigneusement un instantan√© de l'√©tat actuel et de le <strong>construire en parall√®le avec JS</strong> . <br><br><img src="https://habrastorage.org/webt/lm/fd/3w/lmfd3w2kiyhtxlwvp1wtlges6ia.png"><br><br><blockquote>  Si cela vous int√©resse, je vous conseille de lire: <br><br><ul><li>  Le seul et principal livre d'assemblage, le Garbage Collection Handbook. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikip√©dia</a> comme ressource universelle. </li><li>  Site Web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">memorymanagement.org.</a> </li><li>  Rapports et articles d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alexander Shepelev</a> .  Il parle de Java, mais en termes d'ordures, Java et V8 fonctionnent √† peu pr√®s de la m√™me mani√®re. </li></ul></blockquote><br><h2>  R√©alit√© du navigateur <br></h2><br>  Passons √† la fa√ßon dont les navigateurs utilisent tout ce dont nous avons parl√©. <br><br><h3>  Moteurs IoT <br></h3><br>  Commen√ßons pas par les navigateurs, mais par les moteurs de l'Internet des objets: JerryScript et Duktape.  Ils utilisent les algorithmes Mark'n'sweep et Stop the world. <br><br>  Les moteurs IoT fonctionnent sur les microcontr√¥leurs, ce qui signifie: le langage est lent;  deuxi√®me se bloque;  fragmentation  et tout √ßa pour une th√©i√®re avec √©clairage :) <br><br>  Si vous √©crivez Internet des objets en JavaScript, dites-le nous dans les commentaires?  y a-t-il un point <br><br>  Nous laisserons les moteurs IoT tranquilles, nous sommes int√©ress√©s par: <br><br><ul><li>  V8. </li><li>  SpiderMonkey  En fait, il n'a pas de logo.  Logo fait maison :) </li><li>  JavaScriptCore utilis√© par WebKit. </li><li>  ChakraCore utilis√© dans Edge. </li></ul><br><img src="https://habrastorage.org/webt/vw/0q/nj/vw0qnjkmktvnd2z0_dhrvkw4y_u.png"><br><br>  Tous les moteurs sont √† peu pr√®s les m√™mes, nous parlerons donc du V8, le plus c√©l√®bre. <br><br><h3>  V8 <br></h3><br><ul><li>  Presque tout le JavaScript c√¥t√© serveur, car il s'agit de Node.js. </li><li>  Pr√®s de 80% du JavaScript c√¥t√© client. </li><li>  Les d√©veloppeurs les plus sociables, il y a beaucoup d'informations et de bons codes sources qui sont plus faciles √† lire. </li></ul><br>  Le V8 utilise l'assemblage g√©n√©rationnel. <br><img src="https://habrastorage.org/webt/u-/-7/r4/u--7r4ggek0kxgpscwhtzn8grfe.png"><br><br>  La seule diff√©rence est que nous avions auparavant deux collecteurs, et maintenant trois: <br><br><ul><li>  Un objet est cr√©√© dans Eden. </li><li>  √Ä un moment donn√© dans Eden, il y a trop de d√©chets et l'objet est transf√©r√© vers Semispace. </li><li>  L'objet est jeune et lorsque le collectionneur se rend compte qu'il est trop vieux et ennuyeux, il le jette dans Mark and Sweep, dans lequel la collecte des ordures est extr√™mement rare. </li></ul><br>  Vous pouvez clairement voir √† quoi cela ressemble sur la <strong>trace de</strong> la <strong>m√©moire</strong> . <br><br><img src="https://habrastorage.org/webt/c7/s1/av/c7s1avnfboc9c57khyjw5xqjybm.png"><br><br>  Plusieurs grosses vagues avec de petites vagues sont perceptibles.  Les petits sont des assemblages mineurs et les grands sont des assemblages majeurs. <br><br>  Le sens de notre existence, selon l'hypoth√®se g√©n√©rationnelle, est de g√©n√©rer des ordures, donc l'erreur suivante est la peur de cr√©er des ordures. <br><br><blockquote>  La corbeille peut √™tre cr√©√©e lorsqu'elle est vraiment une corbeille.   ,         ,     ,    . <br></blockquote><br><h4>  mark <br></h4><br>    V8     . <br><img src="https://habrastorage.org/webt/40/dg/j5/40dgj5iiquv7dsag0mndget4s30.png"><br><br>     Stop the world,        ,       JS,        . <br><br><h4>     ? <br></h4><br>  1  3%,    . <br><br>  3% = 1/33     GameDev.  GameDev 3%  1 ,    .   GameDev     . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pool = [<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bullet(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bullet(), <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFromPool</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bullet = pool.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> !x.inUse); bullet.isUse = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bullet; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returnToPool</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bullet</span></span></span><span class="hljs-function">) </span></span>{ bullet.inUse = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Frame const bullet = getFromPool(); // ... returnToPool(bullet);</span></span></code> </pre><br>     , , 10 000        . <br><br>    ‚Äî    .          ,         .      ,     . <br><br><h3>   : Chromium <br></h3><br>      , ,  ,   Chromium. <br><br><pre> <code class="javascript hljs">&gt; performance.memory MemoryInfo { <span class="hljs-attr"><span class="hljs-attr">totalJSHeapSize</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span>, <span class="hljs-attr"><span class="hljs-attr">usedJSHeapSize</span></span>: <span class="hljs-number"><span class="hljs-number">10000000</span></span>, <span class="hljs-attr"><span class="hljs-attr">jsHeapSizeLimit</span></span>: <span class="hljs-number"><span class="hljs-number">2330000000</span></span> }</code> </pre><br>  Chromium  <strong>performance.memory</strong>   ,       ,      Chromium  . <br><br> <strong>:</strong> Chromium   2    JavaScript. <br><br>  ,           . <br><br><h3>   : Node <br></h3><br>  Node.js    <strong>process.memoryUsage</strong> ,      . <br><br><pre> <code class="javascript hljs">&gt; process.memoryUsage() { <span class="hljs-attr"><span class="hljs-attr">rss</span></span>: <span class="hljs-number"><span class="hljs-number">22839296</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapTotal</span></span>: <span class="hljs-number"><span class="hljs-number">10207232</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapUsed</span></span>: <span class="hljs-number"><span class="hljs-number">5967968</span></span>, <span class="hljs-attr"><span class="hljs-attr">external</span></span>: <span class="hljs-number"><span class="hljs-number">12829</span></span> }</code> </pre><br> ,  -         ,    .          .     . <br><br><h3>  <br></h3><br> <strong> </strong> ‚Äî    ,         .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">proposal</a> ,      . <br><br>    Node.js,    c <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">node-weak</a>   , ,  . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cached = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeakRef(myJson); <span class="hljs-comment"><span class="hljs-comment">// 2   let json = cached.deref(); if (!json) { json = await fetchAgain(); }</span></span></code> </pre><br>     , ,    -  JS.         ,      ,      ,    . <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  WebAssembly</a> ,    .   ,              ,     ,      . <br><br><blockquote>     :  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">v8.dev</a>    JS. <br></blockquote><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/v8/v8/tree/7.0.237/src/heap</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/servo/mozjs/blob/master/mozjs/js/src/gc/</a> </li><li> <a href="">github.com/WebKit/webkit/.../JavaScriptCore/heap/MarkedSpace.cpp</a> </li><li> <a href="">github.com/Microsoft/ChakraCore/.../HeapAllocator.cpp</a> </li><li> <a href="">github.com/svaarala/duktape/.../duk_heap_markandsweep.c</a> </li><li> <a href="">github.com/jerryscript-project/jerryscript/.../ecma-gc.c</a> </li></ul><br>        ? <br><br><h2>  <br></h2><br>    DevTools    : <strong>Performance</strong>  <strong>Memory</strong> .     Chromium,     ,   Firefox  Safari  . <br><br><h3>  Performance <br></h3><br>   Trace,   ¬´Memory¬ª    Performance,    JS     . <br><br><img src="https://habrastorage.org/webt/vm/8b/hn/vm8bhnnurkvza6cquinxa61ema8.png"><br><br>     JS      V8     ,   .     .  ,  GC    30   1200  JS,   1/40. <br><br><h3>  Memory <br></h3><br>          . <br><br><img src="https://habrastorage.org/webt/1i/cl/br/1iclbrk21tcz3lmj472ukb5jwqc.png"><br><br>    . <br><br><img src="https://habrastorage.org/webt/fy/6i/0v/fy6i0v3tu6yq2onfzuz7ma7moks.png"><br><br>     ,           .    , ,  ,  V8   ,      .     ,     . <br><br> , ,  Q (   compiled code) ‚Äî  React    .   ,   ? <br><br>    ,     ,             ,    . <br><br>     ,    . <br><br><img src="https://habrastorage.org/webt/-3/z_/si/-3z_si-wvtfdlbz87myro38qz1s.png"><br><br>     ,     ,   ,         .   ,    ‚Äî  4     .  ,  . <br><br><img src="https://habrastorage.org/webt/pr/un/bt/prunbtssbfjjsklugfzwp2mv778.png"><br><br>      React,       - :         . ,   JSX. <br><br>  Performance  Memory   ,   : <br><br><ul><li>  Chromium: about:tracing. </li><li>  Firefox: about:memory  about:performance,    . </li><li>   Node ‚Äî trace-gc, ‚Äîexpose-gc, require('trace_events').  trace_events    . </li></ul><br><h2>  R√©sum√© <br></h2><br><ul><li>   ,    ,    ,   . </li><li>                . </li><li>    .   ,      ? </li><li>   ,       -        . </li><li>     SPA,     ,    1       ,   . </li><li>   ,       -   . </li></ul><br>    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">flapenguin.me</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Twitter</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . <br><br><blockquote>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  -</a>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">++</a> .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong></strong></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>YouTube-</strong> <br></a> . <br><br>     ,     2018 ,     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Frontend Conf</a> 2018. <br><br>     ,   :) <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433318/">https://habr.com/ru/post/fr433318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433302/index.html">Premiers pas pour la rouille</a></li>
<li><a href="../fr433304/index.html">Test de charge avec criquet. 3e partie</a></li>
<li><a href="../fr433306/index.html">Visual studio 2019</a></li>
<li><a href="../fr433308/index.html">Transfert de la configuration PBX vers le service 3CX PBX Express</a></li>
<li><a href="../fr433316/index.html">Design digest: int√©gration, feedback, recherche d'id√©es et prise de d√©cision</a></li>
<li><a href="../fr433320/index.html">Disposition de la grille comme base des mises en page modernes</a></li>
<li><a href="../fr433322/index.html">API JSON - nous travaillons selon les sp√©cifications</a></li>
<li><a href="../fr433324/index.html">Collecter le paquet de r√™ves avec Webpack</a></li>
<li><a href="../fr433326/index.html">Qualit√© du code</a></li>
<li><a href="../fr433328/index.html">Mieux vaut perdre un jour</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>