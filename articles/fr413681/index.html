<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍⚕️ 🤴🏾 😒 La technique de développement de serveurs hautement fiables sur Go 🖕🏻 ⛱️ 👩‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De temps en temps, les programmeurs Web font face à des tâches qui peuvent même effrayer les professionnels. Nous parlons de développer des applicatio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La technique de développement de serveurs hautement fiables sur Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/413681/">  De temps en temps, les programmeurs Web font face à des tâches qui peuvent même effrayer les professionnels.  Nous parlons de développer des applications serveur qui n'ont pas le droit de faire des erreurs, de projets dans lesquels le coût de l'échec est extrêmement élevé.  L'auteur du document, dont nous publions la traduction aujourd'hui, expliquera comment aborder ces tâches. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/2r/ma/ty/2rmaty9ihtz7cjzhhvzqgm5e7ia.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">De quel niveau de fiabilité votre projet a-t-il besoin?</font> </h2><br>  Avant de vous plonger dans les détails du développement d'applications serveur hautement fiables, vous devez vous demander si votre projet a vraiment besoin du niveau de fiabilité le plus élevé possible.  Le processus de développement de systèmes conçus pour des scénarios de travail dans lesquels l'erreur s'apparente à une catastrophe universelle peut être excessivement compliqué pour la plupart des projets dans lesquels les conséquences d'erreurs possibles ne sont pas particulièrement effrayantes. <br><br>  Si le coût de l'erreur ne s'avère pas extrêmement élevé, une approche est acceptable, dans la mise en œuvre de laquelle le développeur fait les efforts les plus raisonnables pour assurer l'opérabilité du projet, et si des problèmes surviennent, il les comprend simplement.  Des outils de surveillance modernes et des processus de déploiement logiciel continu vous permettent d'identifier rapidement les problèmes de production et de les résoudre presque instantanément.  Dans de nombreux cas, cela suffit. <br><br>  Dans le projet sur lequel je travaille aujourd'hui, ce n'est pas le cas.  Nous parlons de la mise en œuvre de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blockchain</a> - une infrastructure de serveur distribuée pour l'exécution sûre du code dans un environnement avec un faible niveau de confiance, tout en atteignant un consensus.  L'une des applications de cette technologie est la monnaie numérique.  Il s'agit d'un exemple classique d'un système avec un coût d'erreur extrêmement élevé.  Dans ce cas, les développeurs de projets doivent vraiment le rendre très, très fiable. <br><br>  Cependant, dans certains autres projets, même s'ils ne sont pas liés à la finance, la recherche de la plus haute fiabilité du code est logique.  Le coût de maintenance d'une base de code fréquemment cassée peut atteindre très rapidement des valeurs astronomiques.  La capacité d'identifier les problèmes aux premiers stades du processus de développement, alors que le coût de leur résolution est encore faible, ressemble à une récompense très réelle pour l'investissement en temps et en efforts dans la méthodologie de développement de systèmes hautement fiables. <br><br><h2>  <font color="#3AC1EF">Peut-être que la solution est TDD?</font> </h2><br>  Le développement par le biais de tests ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test Driven Development</a> , TDD) est souvent considéré comme le meilleur remède contre le mauvais code.  TDD est une méthodologie de développement puriste, dans l'application de laquelle les tests sont écrits en premier, et seulement ensuite - du code qui n'est ajouté au projet que lorsque les tests qui le vérifient cessent de générer des erreurs.  Ce processus garantit une couverture à 100% du code avec des tests et donne souvent l'illusion que le code est testé dans toutes les variantes possibles de son utilisation. <br><br>  Mais ce n'est pas le cas.  TDD est une excellente méthodologie qui fonctionne bien dans certains domaines, mais pour développer un code vraiment fiable, mais pas assez.  Pire encore, TDD inspire au développeur une fausse confiance et l'application de cette méthodologie peut conduire au fait qu'il ne fera tout simplement pas, par paresse, des tests pour vérifier les défaillances du système dans des situations dont l'occurrence, du point de vue du bon sens, est presque impossible.  Nous en reparlerons plus tard. <br><br><h2>  <font color="#3AC1EF">Les tests sont la clé de la fiabilité</font> </h2><br>  En fait, peu importe que vous créiez des tests avant d’écrire du code ou après, que vous utilisiez ou non une méthodologie de développement comme TDD.  L'essentiel est le fait d'avoir des tests.  Les tests sont la meilleure fortification défensive qui protège votre code des problèmes de production. <br><br>  Puisque nous allons exécuter nos tests très souvent, idéalement après avoir ajouté chaque nouvelle ligne au code, il est nécessaire que les tests soient automatisés.  Notre confiance dans la qualité du code ne doit en aucun cas reposer sur ses vérifications manuelles.  Le fait est que les gens ont tendance à faire des erreurs.  L'attention portée aux détails par une personne est affaiblie après avoir effectué la même tâche intimidante plusieurs fois de suite. <br><br>  Les tests doivent être rapides.  Très vite. <br><br>  S'il faut plus de quelques secondes pour terminer la suite de tests, les développeurs seront très probablement paresseux et ajouteront du code au projet sans le tester.  La vitesse est l'une des plus grandes forces de Go.  La boîte à outils de développement dans ce langage est l'une des plus rapides parmi celles existantes.  La compilation, la reconstruction et le test des projets se font en quelques secondes. <br><br>  De plus, les tests sont l'un des principaux moteurs des projets open source.  Par exemple, cela s'applique à tout ce qui concerne la technologie blockchain.  L'open source ici est presque une religion.  La base de code afin de gagner la confiance de ceux qui l'utiliseront doit être ouverte.  Cela permet, par exemple, de conduire son audit, cela crée une atmosphère de décentralisation, dans laquelle il n'y a pas certaines entités qui contrôlent le projet. <br><br>  Cela n'a aucun sens d'attendre une contribution significative au projet open source de développeurs externes si ce projet ne comprend pas de tests de qualité.  Les participants externes au projet ont besoin de mécanismes pour vérifier rapidement la compatibilité de ce qu'ils ont écrit avec ce qui est déjà ajouté au projet.  En fait, l'ensemble des tests devrait être effectué automatiquement à la réception de chaque demande pour ajouter un nouveau code au projet.  Si quelque chose qui est censé être ajouté au projet au moyen d'une telle demande casse quelque chose, le test doit le signaler immédiatement. <br><br>  La couverture complète de la base de code avec des tests est une mesure trompeuse mais importante.  L'objectif d'atteindre une couverture de code à 100% avec des tests peut sembler excessif, mais si vous y réfléchissez, il s'avère que si le code n'est pas entièrement couvert par les tests, une partie du code est envoyé en production sans vérification, ce qui n'a jamais été exécuté auparavant. <br><br>  Une couverture complète du code avec des tests ne signifie pas nécessairement qu'il y a suffisamment de tests dans le projet et ne signifie pas que ce sont des tests qui fournissent absolument toutes les options pour utiliser le code.  En toute confiance, nous pouvons seulement dire que si le projet n'est pas couvert à 100% par des tests, le développeur ne peut pas être sûr de la fiabilité absolue du code, car certaines parties du code ne sont jamais testées. <br><br>  Malgré ce qui précède, il existe des situations où il y a trop de tests.  Idéalement, chaque erreur possible devrait entraîner l'échec d'un test.  Si le nombre de tests est excessif, c'est-à-dire que différents tests vérifient les mêmes fragments de code, puis modifier le code existant et changer le comportement du système existant conduira au fait que pour que les tests existants correspondent au nouveau code, cela prendra trop de temps pour les traiter . <br><br><h2>  <font color="#3AC1EF">Pourquoi Go est-il un excellent choix pour des projets hautement fiables?</font> </h2><br>  Go est un langage tapé statique.  Les types sont un contrat entre divers morceaux de code qui sont exécutés ensemble.  Sans vérification de type automatique pendant le processus d'assemblage du projet, si vous devez respecter des règles strictes pour couvrir le code avec des tests, nous devons implémenter des tests qui vérifient nous-mêmes ces «contrats».  Cela se produit, par exemple, dans les projets serveur et client basés sur JavaScript.  L'écriture de tests complexes visant uniquement à vérifier les types signifie beaucoup de travail supplémentaire, qui, dans le cas de Go, peut être évité. <br><br>  Go est un langage simple et dogmatique.  Comme vous le savez, Go inclut de nombreuses idées traditionnelles pour les langages de programmation, comme l'héritage OOP classique.  La complexité est le pire ennemi d'un code fiable.  Les problèmes ont tendance à se cacher au niveau des articulations des structures complexes.  Cela s'exprime dans le fait que bien que les options typiques pour l'utilisation d'une certaine conception soient faciles à tester, il existe des cas limites bizarres auxquels le développeur de test pourrait même ne pas penser.  En fin de compte, le projet n'aboutira qu'à un seul de ces cas.  En ce sens, le dogmatisme est également utile.  Dans Go, il n'y a souvent qu'une seule façon d'effectuer une action.  Cela peut sembler être un facteur qui freine l'esprit libre du programmeur, mais quand quelque chose ne peut être fait que d'une seule manière, il est difficile de faire quelque chose de mal. <br><br>  Go est concis mais expressif.  Le code lisible est plus facile à analyser et à auditer.  Si le code est trop verbeux, son objectif principal peut se noyer dans le «bruit» des constructions auxiliaires.  Si le code est trop concis, les programmes qu'il contient peuvent être difficiles à lire et à comprendre.  Go maintient un équilibre entre concision et expressivité.  Par exemple, il n'y a pas beaucoup de constructions auxiliaires, comme dans des langages tels que Java ou C ++.  Dans le même temps, les constructions Go, relatives par exemple à des domaines tels que la gestion des erreurs, sont très claires et assez détaillées, ce qui simplifie le travail du programmeur, l'aidant à s'assurer, par exemple, qu'il a vérifié tout ce qui est possible. <br><br>  Go a des mécanismes de gestion des erreurs et de récupération clairs après les plantages.  Des mécanismes de gestion des erreurs d'exécution bien réglés sont la pierre angulaire d'un code très fiable.  Go a des règles strictes pour retourner et distribuer les erreurs.  Dans des environnements comme Node.js, mélanger les approches de contrôle du flux d'un programme, telles que les rappels, les promesses et les fonctions asynchrones, conduit souvent à des erreurs non gérées, comme un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rejet non géré d'une promesse</a> .  La restauration du programme après des événements similaires est presque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impossible</a> . <br><br>  Go a une bibliothèque standard étendue.  Les dépendances sont un risque, en particulier lorsque leur source est des projets dans lesquels une attention insuffisante est accordée à la fiabilité du code.  Une application serveur qui entre en production contient toutes les dépendances.  De plus, en cas de problème, le développeur de l'application finie en sera responsable, et non celui qui a créé l'une des bibliothèques utilisées par lui.  Par conséquent, dans des environnements où les projets écrits sont surchargés de petites dépendances, il est plus difficile de créer des applications fiables. <br><br>  Les dépendances sont également un risque pour la sécurité, car le niveau de vulnérabilité d'un projet correspond au niveau de vulnérabilité de sa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dépendance la</a> plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dangereuse</a> .  La vaste bibliothèque standard Go est maintenue par ses développeurs en très bon état, son existence réduit le besoin de dépendances externes. <br><br>  Vitesse de développement élevée.  Une caractéristique clé d'environnements comme Node.js est son cycle de développement extrêmement court.  L'écriture de code prend moins de temps, par conséquent, le programmeur devient plus productif. <br><br>  Go a également une vitesse de développement élevée.  Un ensemble d'outils pour la construction de projets est assez rapide pour pouvoir regarder instantanément le code en action.  Le temps de compilation est extrêmement court; par conséquent, l'exécution de code sur Go est perçue comme si elle n'avait pas été compilée, mais interprétée.  De plus, le langage possède suffisamment d'abstractions, comme un système de collecte des ordures, qui permet aux développeurs de diriger les efforts pour implémenter les fonctionnalités de leur projet, et non de résoudre des tâches auxiliaires. <br><br><h2>  <font color="#3AC1EF">Expérience pratique</font> </h2><br>  Maintenant que nous avons exprimé suffisamment de points généraux, il est temps de jeter un œil au code.  Nous avons besoin d'un exemple assez simple pour que, tout en l'étudiant, nous puissions nous concentrer sur la méthodologie de développement, mais en même temps, il devrait être suffisamment avancé pour que nous, en l'explorant, ayons quelque chose à dire.  J'ai décidé qu'il serait plus facile de prendre quelque chose de ce que je fais quotidiennement.  Par conséquent, je propose d'analyser la création d'un serveur qui traite quelque chose qui ressemble à des transactions financières.  Les utilisateurs de ce serveur pourront vérifier les soldes des comptes associés à leurs comptes.  De plus, ils pourront transférer des fonds d'un compte à un autre. <br><br>  Nous allons essayer de ne pas compliquer cet exemple.  Notre système aura un serveur.  Nous ne contacterons pas les systèmes d'authentification et de cryptographie.  Ce sont des parties intégrantes des projets de travail.  Mais nous devons nous concentrer sur le cœur d'un tel projet, pour montrer comment le rendre aussi fiable que possible. <br><br><h3>  <font color="#3AC1EF">▍Division d'un projet complexe en parties faciles à gérer</font> </h3><br>  La complexité est le pire ennemi de la fiabilité.  L'une des meilleures approches lorsque l'on travaille avec des systèmes complexes consiste à appliquer le principe bien connu de «diviser pour mieux régner».  La tâche doit être divisée en petites sous-tâches et résoudre chacune d'elles séparément.  De quel côté aborder la partition de notre tâche?  Nous suivrons le principe de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la responsabilité partagée</a> .  Chaque partie de notre projet devrait avoir son propre domaine de responsabilité. <br><br>  Cette idée correspond parfaitement à l'architecture de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">microservices</a> populaire.  Notre serveur sera composé de services distincts.  Chaque service aura un domaine de responsabilité clairement défini et une interface clairement décrite pour interagir avec d'autres services. <br><br>  Après avoir structuré le serveur de cette manière, nous serons en mesure de prendre des décisions sur le fonctionnement de chacun des services.  Tous les services peuvent être exécutés ensemble, dans le même processus, à partir de chacun d'eux, vous pouvez créer un serveur distinct et établir leur interaction à l'aide de RPC, vous pouvez séparer les services et exécuter chacun d'eux sur un ordinateur distinct. <br><br>  Nous ne compliquerons pas la tâche, nous choisirons l'option la plus simple.  À savoir, tous les services seront exécutés dans le même processus, ils échangeront directement des informations, comme les bibliothèques.  Si nécessaire, cette solution architecturale pourra à l'avenir être facilement révisée et modifiée. <br><br>  Alors de quels services avons-nous besoin?  Notre serveur est peut-être trop simple pour le diviser en parties, mais, à des fins pédagogiques, nous le diviserons néanmoins.  Nous devons répondre aux demandes HTTP des clients visant à vérifier les soldes et à exécuter les transactions.  L'un des services peut fonctionner avec une interface HTTP pour les clients.  <code>PublicApi</code> cela <code>PublicApi</code> .  Un autre service détiendra des informations sur l'état du système - le bilan.  <code>StateStorage</code> cela <code>StateStorage</code> .  Le troisième service combinera les deux décrits ci-dessus et mettra en œuvre la logique des «contrats» visant à modifier les soldes.  La tâche du troisième service sera l'exécution des contrats.  <code>VirtualMachine</code> cela <code>VirtualMachine</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a2/a04/79b/8a2a0479b551df5fd2a3c46e67bb46a7.png"></div><br>  <i><font color="#999999">Architecture du serveur d'applications</font></i> <br><br>  Placez le code de ces services dans les dossiers de projet <code>/services/publicapi</code> , <code>/services/virtualmachine</code> et <code>/services/statestorage</code> . <br><br><h3>  <font color="#3AC1EF">▍ Définition claire des responsabilités de service</font> </h3><br>  Lors de la mise en place des services, nous souhaitons pouvoir travailler avec chacun d'eux individuellement.  Il est même possible de répartir le développement de ces services entre différents programmeurs.  Étant donné que les services sont interdépendants et que nous voulons paralléliser leur développement, nous devons commencer à travailler avec une définition claire des interfaces qu'ils utilisent pour interagir les uns avec les autres.  À l'aide de ces interfaces, nous pouvons tester les services de manière autonome en préparant des talons pour tout ce qui se trouve en dehors de chacun d'eux. <br><br>  Comment décrire l'interface?  L'une des options est de tout documenter, mais la documentation a la propriété de devenir obsolète, au cours du travail sur un projet, des différences commencent à s'accumuler entre la documentation et le code.  De plus, nous pouvons utiliser des déclarations d'interface Go.  C'est une option intéressante, mais il vaut mieux décrire l'interface pour que cette description ne dépende pas d'un langage de programmation spécifique.  Cela nous sera utile dans une situation très réelle, si au cours du travail sur un projet, il sera décidé de mettre en œuvre certains de ses services dans d'autres langues dont les capacités sont mieux adaptées pour résoudre leurs problèmes. <br><br>  Une option pour décrire les interfaces est d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">protobuf</a> .  Il s'agit d'un langage simple et d'un protocole indépendant du langage pour décrire les messages et les points de terminaison de service. <br><br>  Commençons par l'interface du service <code>StateStorage</code> .  Nous présenterons l'état de l'application sous la forme d'une structure de vue clé-valeur.  Voici le code du fichier <code>statestorage.proto</code> : <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">package</span></span> statestorage; <span class="hljs-attribute"><span class="hljs-attribute">service</span></span> StateStorage { <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> WriteKey (WriteKeyInput) returns (WriteKeyOutput); <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> ReadKey (ReadKeyInput) returns (ReadKeyOutput); } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> WriteKeyInput { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> key = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">int32</span></span> value = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> WriteKeyOutput { } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> ReadKeyInput { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> key = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> ReadKeyOutput { <span class="hljs-attribute"><span class="hljs-attribute">int32</span></span> value = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Bien que les clients utilisent HTTP via le service <code>PublicApi</code> , cela n'interfère pas non plus avec l'interface claire décrite par les mêmes moyens que ci-dessus (le fichier <code>publicapi.proto</code> ): <br><br><pre> <code class="hljs pgsql">syntax = "proto3"; package publicapi; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> "protocol/transactions.proto"; service PublicApi { rpc Transfer (TransferInput) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> (TransferOutput); rpc GetBalance (GetBalanceInput) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> (GetBalanceOutput); } message TransferInput { protocol.<span class="hljs-keyword"><span class="hljs-keyword">Transaction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; } message TransferOutput { string success = <span class="hljs-number"><span class="hljs-number">1</span></span>; int32 result = <span class="hljs-number"><span class="hljs-number">2</span></span>; } message GetBalanceInput { protocol.Address <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; } message GetBalanceOutput { string success = <span class="hljs-number"><span class="hljs-number">1</span></span>; int32 result = <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br>  Maintenant, nous devons décrire les structures de données de <code>Transaction</code> et d' <code>Address</code> (fichier <code>transactions.proto</code> ): <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">package</span></span> protocol; <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> Address { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> username = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> Transaction { <span class="hljs-attribute"><span class="hljs-attribute">Address</span></span> from = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">Address</span></span> to = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">int32</span></span> amount = <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br>  Dans le projet, les proto-descriptions des services sont placées dans le dossier <code>/types/services</code> et les descriptions des structures de données à usage général se trouvent dans le dossier <code>/types/protocol</code> . <br><br>  Une fois que les descriptions d'interface sont prêtes, elles peuvent être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compilées</a> en code Go. <br><br>  Les avantages de cette approche sont que le code qui ne correspond pas à la description de l'interface n'apparaît tout simplement pas dans les résultats de la compilation.  L'utilisation de méthodes alternatives nous obligerait à écrire des tests spéciaux pour vérifier que le code correspond aux descriptions de l'interface. <br><br>  Les définitions complètes, les fichiers Go générés et les instructions de compilation peuvent être trouvés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Ceci est possible grâce à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Square Engineering</a> et à leur développement de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">goprotowrap</a> . <br><br>  Veuillez noter que dans notre projet, la couche de transport RPC n'est pas implémentée et l'échange de données entre les services ressemble à des appels de bibliothèque ordinaires.  Lorsque nous sommes prêts à distribuer des services sur différents serveurs, nous pouvons ajouter une couche de transport telle que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gRPC</a> au système. <br><br><h3>  <font color="#3AC1EF">▍ Types de tests utilisés dans le projet</font> </h3><br>  Étant donné que les tests sont la clé d'un code hautement fiable, je suggère que nous parlions d'abord des tests que nous allons écrire pour notre projet. <br><br><h4>  Tests unitaires </h4><br>  Les tests unitaires sont au cœur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de la pyramide des tests</a> .  Nous testerons chaque module isolément.  Qu'est-ce qu'un module?  Dans Go, nous pouvons percevoir les modules comme des fichiers séparés dans un package.  Par exemple, si nous avons le fichier <code>/services/publicapi/handlers.go</code> , nous <code>/services/publicapi/handlers.go</code> le test unitaire pour celui-ci dans le même package à <code>/services/publicapi/handlers_test.go</code> . <br><br>  Il est préférable de placer les tests unitaires dans le même package que le code de test, ce qui permet aux tests d'avoir accès aux variables et fonctions non exportées. <br><br><h4>  Tests de service </h4><br>  Le type de test suivant est connu sous différents noms.  Il s'agit des tests dits de service, d'intégration ou de composants.  Leur essence est de prendre plusieurs modules et de tester leur travail commun.  Ces tests sont supérieurs d'un niveau aux tests unitaires de la pyramide des tests.  Dans notre cas, nous utiliserons des tests d'intégration pour tester l'ensemble du service.  Ces tests déterminent les spécifications du service.  Par exemple, les tests du service <code>StateStorage</code> seront placés dans le dossier <code>/services/statestorage/spec</code> . <br><br>  Il est préférable de placer ces tests dans un package qui diffère de celui dans lequel se trouve le code testé afin que l'accès aux capacités de ce code se fasse uniquement via des interfaces exportées. <br><br><h4>  Tests de bout en bout </h4><br>  Ces tests sont au sommet de la pyramide des tests, avec leur aide pour vérifier l'ensemble du système et tous ses services sont effectués.  Ces tests décrivent les spécifications e2e de bout en bout du système, nous les <code>/e2e/spec</code> dans le <code>/e2e/spec</code> . <br><br>  Les tests de bout en bout, ainsi que les tests de service, doivent être placés dans un package différent de celui dans lequel se trouve le code testé afin que le système ne puisse fonctionner que via des interfaces exportées. <br><br>  Quels tests doivent être écrits en premier?  Commencer par la fondation de la "pyramide" et remonter?  Ou commencer par le haut et descendre?  Chacune de ces approches a droit à la vie.  Les avantages d'une approche descendante résident dans la création de la spécification d'abord pour l'ensemble du système.  Il est généralement plus facile de discuter au tout début des travaux sur les caractéristiques du système dans son ensemble.  Même si nous divisons le système en services séparés de manière incorrecte, les spécifications du système resteront inchangées.  De plus, cela nous aidera à comprendre que quelque chose, à un niveau inférieur, est mal fait. <br><br>  L'inconvénient de l'approche descendante est que les tests de bout en bout sont les tests qui sont utilisés après tous les autres, lorsque tout le système en cours de développement est créé.  Cela signifie qu'ils généreront des erreurs pendant longtemps.  Lors de la rédaction des tests pour notre projet, nous utiliserons cette approche même. <br><br><h3>  <font color="#3AC1EF">▍Développement des tests</font> </h3><br><h4>  Développement de test de bout en bout </h4><br>  Avant de créer des tests, nous devons décider si nous allons les écrire sans utiliser d'outils auxiliaires ou utiliser une sorte de framework.  S'appuyer sur le framework, l'utiliser comme dépendance de développement, est moins dangereux que de s'appuyer sur le framework dans le code qui entre en production.  Dans notre cas, étant donné que la bibliothèque Go standard n'a pas de prise en charge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BDD</a> décente et que ce format est idéal pour décrire les spécifications, nous choisirons une option de travail qui inclut l'utilisation d'un cadre. <br><br>  Il existe de nombreux cadres formidables qui donnent ce dont nous avons besoin.  Parmi eux, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GoConvey</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ginkgo</a> . <br><br>  Personnellement, j'aime utiliser une combinaison de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ginkgo</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gomega</a> (noms terribles, mais que faire) qui utilisent des constructions syntaxiques comme <code>Describe()</code> et <code>It()</code> . <br><br>  À quoi ressembleront nos tests?  Par exemple, voici un test du mécanisme de vérification du solde utilisateur (fichier <code>sanity.go</code> ): <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> spec <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _ = Describe(<span class="hljs-string"><span class="hljs-string">"Sanity"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( node services.Node ) BeforeEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { node = services.NewNode() node.Start() }) AfterEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { node.Stop() }) It(<span class="hljs-string"><span class="hljs-string">"should show balances with GET /api/balance"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { resp, err := http.Get(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/api/balance?from=user1"</span></span>) Expect(err).ToNot(HaveOccurred()) Expect(resp.StatusCode).To(Equal(http.StatusOK)) Expect(ResponseBodyAsString(resp)).To(Equal(<span class="hljs-string"><span class="hljs-string">"0"</span></span>)) }) })</code> </pre> <br>  Étant donné que le serveur est accessible depuis le monde extérieur via HTTP, nous travaillerons avec son API Web en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://golang.org/pkg/net/">http.Get</a> .  Qu'en est-il des tests transactionnels?  Voici le code du test correspondant: <br><br><pre> <code class="hljs lisp">It(<span class="hljs-string"><span class="hljs-string">"should transfer funds with POST /api/transfer"</span></span>, func() { resp, err <span class="hljs-symbol"><span class="hljs-symbol">:=</span></span> http.Get(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/api/transfer?from=user1&amp;to=user2&amp;amount=17"</span></span>) Expect(<span class="hljs-name"><span class="hljs-name">err</span></span>).ToNot(<span class="hljs-name"><span class="hljs-name">HaveOccurred</span></span>()) Expect(<span class="hljs-name"><span class="hljs-name">resp</span></span>.StatusCode).To(<span class="hljs-name"><span class="hljs-name">Equal</span></span>(<span class="hljs-name"><span class="hljs-name">http</span></span>.StatusOK)) Expect(<span class="hljs-name"><span class="hljs-name">ResponseBodyAsString</span></span>(<span class="hljs-name"><span class="hljs-name">resp</span></span>)).To(<span class="hljs-name"><span class="hljs-name">Equal</span></span>(<span class="hljs-string"><span class="hljs-string">"-17"</span></span>)) resp, err = http.Post(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/api/balance?from=user2"</span></span>, <span class="hljs-string"><span class="hljs-string">"text/plain"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) Expect(<span class="hljs-name"><span class="hljs-name">err</span></span>).ToNot(<span class="hljs-name"><span class="hljs-name">HaveOccurred</span></span>()) Expect(<span class="hljs-name"><span class="hljs-name">resp</span></span>.StatusCode).To(<span class="hljs-name"><span class="hljs-name">Equal</span></span>(<span class="hljs-name"><span class="hljs-name">http</span></span>.StatusOK)) Expect(<span class="hljs-name"><span class="hljs-name">ResponseBodyAsString</span></span>(<span class="hljs-name"><span class="hljs-name">resp</span></span>)).To(<span class="hljs-name"><span class="hljs-name">Equal</span></span>(<span class="hljs-string"><span class="hljs-string">"17"</span></span>)) })</code> </pre><br>  Le code de test décrit parfaitement leur essence, il peut même remplacer la documentation.  Comme vous pouvez le constater, nous admettons la présence de soldes de comptes d'utilisateurs négatifs.  C'est une caractéristique de notre projet.  Si elle était interdite, cette décision serait reflétée dans le test. <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici le</a> code de test complet <br><br><h4>  Développement de tests de service </h4><br>  Maintenant, après avoir développé des tests de bout en bout, nous descendons la pyramide des tests et procédons à la création de tests de service.  Ces tests sont développés pour chaque service individuel.  Nous choisissons un service qui dépend d'un autre service, car ce cas est plus intéressant que de développer des tests pour un service indépendant. <br><br>  Commençons par le service <code>VirtualMachine</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici</a> vous pouvez trouver l'interface avec des proto-descriptions pour ce service.  Étant donné que le service <code>VirtualMachine</code> s'appuie sur le service <code>StateStorage</code> et lui fait des appels, nous devrons créer un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">objet</a> <code>StateStorage</code> pour le service <code>StateStorage</code> afin de tester le service <code>VirtualMachine</code> de manière isolée.  L'objet stub nous permet de contrôler les réponses <code>StateStorage</code> pendant les tests. <br><br>  Comment implémenter un objet stub dans Go?  Cela peut être fait exclusivement au moyen du langage, sans outils auxiliaires, ou vous pouvez recourir à la bibliothèque appropriée, qui, en plus, permettra de travailler avec les instructions dans le processus de test.  À cette fin, je préfère utiliser la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">go-mock</a> . <br><br>  Nous <code>/services/statestorage/mock.go</code> le code de <code>/services/statestorage/mock.go</code> dans le fichier <code>/services/statestorage/mock.go</code> .  Il est préférable de placer les objets stub au même endroit que les entités qu'ils imitent afin de leur donner accès aux variables et fonctions non exportées.  Le stub à ce stade est une implémentation schématique du service, mais, à mesure que le service se développe, nous devrons peut-être développer l'implémentation du stub.  Voici le code de l'objet stub (fichier <code>mock.go</code> ): <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> statestorage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MockService <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { mock.Mock } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *MockService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { s.Called() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *MockService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { s.Called() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *MockService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsStarted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.Called().Bool(<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *MockService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input *statestorage.WriteKeyInput)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*statestorage.WriteKeyOutput, error)</span></span></span></span> { ret := s.Called(input) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret.Get(<span class="hljs-number"><span class="hljs-number">0</span></span>).(*statestorage.WriteKeyOutput), ret.Error(<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *MockService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input *statestorage.ReadKeyInput)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*statestorage.ReadKeyOutput, error)</span></span></span></span> { ret := s.Called(input) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret.Get(<span class="hljs-number"><span class="hljs-number">0</span></span>).(*statestorage.ReadKeyOutput), ret.Error(<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br>  Si vous donnez le développement de services individuels à différents programmeurs, il est logique de créer d'abord des talons et de les transmettre à l'équipe. <br><br>  Revenons au développement d'un test de service pour <code>VirtualMachine</code> .  Quel scénario dois-je vérifier ici?  Il est préférable de se concentrer sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'interface de</a> service et les tests de conception pour chaque point de terminaison.  Nous implémentons un test pour le point de terminaison <code>CallContract()</code> avec un argument représentant la méthode <code>"GetBalance"</code> .  Voici le code correspondant (fichier <code>contracts.go</code> ): <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> spec <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _ = Describe(<span class="hljs-string"><span class="hljs-string">"Contracts"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( service uut.Service stateStorage *_statestorage.MockService ) BeforeEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { service = uut.NewService() stateStorage = &amp;_statestorage.MockService{} service.Start(stateStorage) }) AfterEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { service.Stop() }) It(<span class="hljs-string"><span class="hljs-string">"should support 'GetBalance' contract method"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { stateStorage.When(<span class="hljs-string"><span class="hljs-string">"ReadKey"</span></span>, &amp;statestorage.ReadKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>}).Return(&amp;statestorage.ReadKeyOutput{Value: <span class="hljs-number"><span class="hljs-number">100</span></span>}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).Times(<span class="hljs-number"><span class="hljs-number">1</span></span>) addr := protocol.Address{Username: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>} out, err := service.CallContract(&amp;virtualmachine.CallContractInput{Method: <span class="hljs-string"><span class="hljs-string">"GetBalance"</span></span>, Arg: &amp;addr}) Expect(err).ToNot(HaveOccurred()) Expect(out.Result).To(BeEquivalentTo(<span class="hljs-number"><span class="hljs-number">100</span></span>)) Expect(stateStorage).To(ExecuteAsPlanned()) }) })</code> </pre><br>  Veuillez noter que le service que nous testons, <code>VirtualMachine</code> , obtient un pointeur sur sa dépendance, <code>StateStorage</code> , dans la méthode <code>Start()</code> via un mécanisme d'injection de dépendance simple.  C'est là que nous passons l'instance de l'objet stub.  <code>stateStorage.When("ReadKey", &amp;statestorage.ReadKeyInput{Key…</code> également attention à la ligne <code>stateStorage.When("ReadKey", &amp;statestorage.ReadKeyInput{Key…</code> , où nous indiquons à l'objet stub comment il doit se comporter lorsqu'il y accède. Lorsque la méthode <code>ReadKey</code> est <code>ReadKey</code> , elle doit renvoyer une valeur 100. Ensuite, dans la ligne <code>Expect(stateStorage).To(ExecuteAsPlanned())</code> , nous vérifions que cette commande est appelée exactement une fois. <br><br>  Des tests similaires deviennent des spécifications pour le service.  L'ensemble complet de tests pour le service <code>VirtualMachine</code> peut être trouvé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Des suites de tests pour d'autres services de notre projet peuvent être trouvées <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h4>  Développement de tests unitaires </h4><br>  Peut-être que l'implémentation du contrat pour la méthode <code>"GetBalance"</code> est trop simple, alors parlons de l'implémentation d'une méthode de <code>"Transfer"</code> légèrement plus complexe.  Le contrat de transfert de fonds d'un compte à un autre représenté par cette méthode doit lire les données sur les soldes de l'expéditeur et du destinataire des fonds, calculer les nouveaux soldes et enregistrer ce qui s'est passé dans l'état d'application.  Le test de service pour tout cela est très similaire à celui que nous venons de mettre en place (fichier <code>transactions.go</code> ): <br><br><pre> <code class="hljs lisp">It(<span class="hljs-string"><span class="hljs-string">"should support 'Transfer' transaction method"</span></span>, func() { stateStorage.When(<span class="hljs-string"><span class="hljs-string">"ReadKey"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">&amp;statestorage</span></span>.ReadKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>}).Return(<span class="hljs-name"><span class="hljs-name">&amp;statestorage</span></span>.ReadKeyOutput{Value: <span class="hljs-number"><span class="hljs-number">100</span></span>}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).Times(<span class="hljs-number"><span class="hljs-number">1</span></span>) stateStorage.When(<span class="hljs-string"><span class="hljs-string">"ReadKey"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">&amp;statestorage</span></span>.ReadKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user2"</span></span>}).Return(<span class="hljs-name"><span class="hljs-name">&amp;statestorage</span></span>.ReadKeyOutput{Value: <span class="hljs-number"><span class="hljs-number">50</span></span>}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).Times(<span class="hljs-number"><span class="hljs-number">1</span></span>) stateStorage.When(<span class="hljs-string"><span class="hljs-string">"WriteKey"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">&amp;statestorage</span></span>.WriteKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>, Value: <span class="hljs-number"><span class="hljs-number">90</span></span>}).Return(<span class="hljs-name"><span class="hljs-name">&amp;statestorage</span></span>.WriteKeyOutput{}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).Times(<span class="hljs-number"><span class="hljs-number">1</span></span>) stateStorage.When(<span class="hljs-string"><span class="hljs-string">"WriteKey"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">&amp;statestorage</span></span>.WriteKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user2"</span></span>, Value: <span class="hljs-number"><span class="hljs-number">60</span></span>}).Return(<span class="hljs-name"><span class="hljs-name">&amp;statestorage</span></span>.WriteKeyOutput{}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).Times(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-literal"><span class="hljs-literal">t</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:=</span></span> protocol.Transaction{From: <span class="hljs-symbol"><span class="hljs-symbol">&amp;protocol</span></span>.Address{Username: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>}, To: <span class="hljs-symbol"><span class="hljs-symbol">&amp;protocol</span></span>.Address{Username: <span class="hljs-string"><span class="hljs-string">"user2"</span></span>}, Amount: <span class="hljs-number"><span class="hljs-number">10</span></span>} out, err <span class="hljs-symbol"><span class="hljs-symbol">:=</span></span> service.ProcessTransaction(<span class="hljs-name"><span class="hljs-name">&amp;virtualmachine</span></span>.ProcessTransactionInput{Method: <span class="hljs-string"><span class="hljs-string">"Transfer"</span></span>, Arg: <span class="hljs-symbol"><span class="hljs-symbol">&amp;t</span></span>}) Expect(<span class="hljs-name"><span class="hljs-name">err</span></span>).ToNot(<span class="hljs-name"><span class="hljs-name">HaveOccurred</span></span>()) Expect(<span class="hljs-name"><span class="hljs-name">out</span></span>.Result).To(<span class="hljs-name"><span class="hljs-name">BeEquivalentTo</span></span>(<span class="hljs-number"><span class="hljs-number">90</span></span>)) Expect(<span class="hljs-name"><span class="hljs-name">stateStorage</span></span>).To(<span class="hljs-name"><span class="hljs-name">ExecuteAsPlanned</span></span>()) })</code> </pre> <br>  Dans le processus de travail sur le projet, nous arrivons enfin à créer ses mécanismes internes et à créer un module situé dans le fichier <code>processor.go</code> , qui contient la mise en œuvre du contrat.  Voici la version originale (fichier <code>processor.go</code> ): <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> virtualmachine <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processTransfer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fromUsername </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, toUsername </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, amount </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { fromBalance, err := s.stateStorage.ReadKey(&amp;statestorage.ReadKeyInput{Key: fromUsername}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } toBalance, err := s.stateStorage.ReadKey(&amp;statestorage.ReadKeyInput{Key: toUsername}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } _, err = s.stateStorage.WriteKey(&amp;statestorage.WriteKeyInput{Key: fromUsername, Value: fromBalance.Value - amount}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } _, err = s.stateStorage.WriteKey(&amp;statestorage.WriteKeyInput{Key: toUsername, Value: toBalance.Value + amount}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fromBalance.Value - amount, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br>  Cette conception satisfait le test de service, mais dans notre cas, le test d'intégration ne contient qu'un test du scénario de base.  Qu'en est-il des cas limites et des échecs potentiels?  Comme vous pouvez le voir, l'un des appels que nous faisons à <code>StateStorage</code> peut échouer.  Si une couverture à 100% du code avec des tests est requise, nous devons vérifier toutes ces situations.  Le test unitaire est idéal pour implémenter de tels tests. <br><br>  Comme nous allons appeler la fonction plusieurs fois avec différentes données d'entrée et simuler les paramètres pour atteindre toutes les branches du code, afin de rendre ce processus plus efficace, nous pouvons recourir à des tests basés sur des tables.  Go a tendance à éviter les cadres de tests unitaires exotiques.  Nous pouvons refuser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ginkgo</a> , mais nous devrions probablement quitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gomega</a> .  Par conséquent, les contrôles effectués ici seront similaires à ceux que nous avons effectués lors des tests précédents.  Voici le code de test (fichier <code>processor_test.go</code> ): <br><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> virtualmachine import ... var transferTable = []struct{ to <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //  ,    read1Err <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> //       read2Err <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> //       write1Err <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> //       write2Err <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> //       <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> int32 //   errs bool //        }{ {<span class="hljs-string"><span class="hljs-string">"user2"</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {<span class="hljs-string"><span class="hljs-string">"user2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {<span class="hljs-string"><span class="hljs-string">"user2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {<span class="hljs-string"><span class="hljs-string">"user2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {<span class="hljs-string"><span class="hljs-string">"user2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>}, } func TestTransfer(t *testing.T) { Ω := NewGomegaWithT(t) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, tt := range transferTable { s := NewService() ss := &amp;_statestorage.MockService{} s.Start(ss) ss.When(<span class="hljs-string"><span class="hljs-string">"ReadKey"</span></span>, &amp;statestorage.ReadKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>}).Return(&amp;statestorage.ReadKeyOutput{Value: <span class="hljs-number"><span class="hljs-number">100</span></span>}, tt.read1Err) ss.When(<span class="hljs-string"><span class="hljs-string">"ReadKey"</span></span>, &amp;statestorage.ReadKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user2"</span></span>}).Return(&amp;statestorage.ReadKeyOutput{Value: <span class="hljs-number"><span class="hljs-number">50</span></span>}, tt.read2Err) ss.When(<span class="hljs-string"><span class="hljs-string">"WriteKey"</span></span>, &amp;statestorage.WriteKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>, Value: <span class="hljs-number"><span class="hljs-number">90</span></span>}).Return(&amp;statestorage.WriteKeyOutput{}, tt.write1Err) ss.When(<span class="hljs-string"><span class="hljs-string">"WriteKey"</span></span>, &amp;statestorage.WriteKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user2"</span></span>, Value: <span class="hljs-number"><span class="hljs-number">60</span></span>}).Return(&amp;statestorage.WriteKeyOutput{}, tt.write2Err) <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>, err := s.(*service).processTransfer(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>, tt.to, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tt.errs { Ω.Expect(err).To(HaveOccurred()) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Ω.Expect(err).ToNot(HaveOccurred()) Ω.Expect(<span class="hljs-built_in"><span class="hljs-built_in">output</span></span>).To(BeEquivalentTo(tt.<span class="hljs-built_in"><span class="hljs-built_in">output</span></span>)) } } }</code> </pre> <br>     «Ω» —  ,    —    (     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gomega</a> ).          . <br><br>        ,        TDD,          ,     ,     .       <code>processTransfer()</code>         . <br><br>       <code>VirtualMachine</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br>    100%   .    ,    .             . <br><br>   ,        ?   .        , ,    ,     . <br><br><h3> <font color="#3AC1EF">▍  -</font> </h3><br>              .         ?  HTTP-  Go     (goroutine).     ,  —        ,     . ,      ,  ,   . <br><br>           -               . ,   ,   ,          ,        .  -     <code>/e2e/stress</code> .   - ( <code>stress.go</code> ): <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> stress import ... const NUM_TRANSACTIONS = <span class="hljs-number"><span class="hljs-number">20000</span></span> const NUM_USERS = <span class="hljs-number"><span class="hljs-number">100</span></span> const TRANSACTIONS_PER_BATCH = <span class="hljs-number"><span class="hljs-number">200</span></span> const BATCHES_PER_SEC = <span class="hljs-number"><span class="hljs-number">40</span></span> var <span class="hljs-number"><span class="hljs-number">_</span></span> = Describe(<span class="hljs-string"><span class="hljs-string">"Transaction Stress Test"</span></span>, func() { var ( node services.Node ) BeforeEach(func() { node = services.NewNode() node.Start() }) AfterEach(func() { node.Stop() }) It(<span class="hljs-string"><span class="hljs-string">"should handle lots and lots of transactions"</span></span>, func() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  HTTP-     transport := http.Transport{ IdleConnTimeout: time.Second*<span class="hljs-number"><span class="hljs-number">20</span></span>, MaxIdleConns: TRANSACTIONS_PER_BATCH*<span class="hljs-number"><span class="hljs-number">10</span></span>, MaxIdleConnsPerHost: TRANSACTIONS_PER_BATCH*<span class="hljs-number"><span class="hljs-number">10</span></span>, } client := &amp;http.Client{Transport: &amp;transport} //      ledger := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[string]int32{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUM_USERS; i++ { ledger[fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"user%d"</span></span>, i+<span class="hljs-number"><span class="hljs-number">1</span></span>)] = <span class="hljs-number"><span class="hljs-number">0</span></span> } //     HTTP   rand.Seed(<span class="hljs-number"><span class="hljs-number">42</span></span>) done := make(chan error, TRANSACTIONS_PER_BATCH) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUM_TRANSACTIONS / TRANSACTIONS_PER_BATCH; i++ { log.Printf(<span class="hljs-string"><span class="hljs-string">"Sending %d transactions... (batch %d out of %d)"</span></span>, TRANSACTIONS_PER_BATCH, i+<span class="hljs-number"><span class="hljs-number">1</span></span>, NUM_TRANSACTIONS / TRANSACTIONS_PER_BATCH) time.Sleep(time.Second / BATCHES_PER_SEC) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j := <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; TRANSACTIONS_PER_BATCH; j++ { from := randomizeUser() to := randomizeUser() amount := randomizeAmount() ledger[from] -= amount ledger[to] += amount go sendTransaction(client, from, to, amount, &amp;done) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j := <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; TRANSACTIONS_PER_BATCH; j++ { err := &lt;- done Expect(err).ToNot(HaveOccurred()) } } //   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUM_USERS; i++ { user := fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"user%d"</span></span>, i+<span class="hljs-number"><span class="hljs-number">1</span></span>) resp, err := client.Get(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/api/balance?from=%s"</span></span>, user)) Expect(err).ToNot(HaveOccurred()) Expect(resp.StatusCode).To(Equal(http.StatusOK)) Expect(ResponseBodyAsString(resp)).To(Equal(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, ledger[user]))) } }) }) func randomizeUser() string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"user%d"</span></span>, rand.Intn(NUM_USERS)+<span class="hljs-number"><span class="hljs-number">1</span></span>) } func randomizeAmount() int32 { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rand.Int31n(<span class="hljs-number"><span class="hljs-number">1000</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span> } func sendTransaction(client *http.Client, from string, to string, amount int32, done *chan error) { url := fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/api/transfer?from=%s&amp;to=%s&amp;amount=%d"</span></span>, from, to, amount) resp, err := client.Post(url, <span class="hljs-string"><span class="hljs-string">"text/plain"</span></span>, nil) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == nil { ioutil.ReadAll(resp.Body) resp.Body.Close() } *done &lt;- err }</code> </pre> <br>    ,  -   .           (       <code>rand.Seed(42)</code> )  ,    .         .     ,            ,  — ,     . <br><br>    -  HTTP   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>          TCP- (     ,     ,           ).  ,  ,              200     <code>IdleConnection</code>    TCP-   .       ,      100. <br><br>  …   : <br><br><pre> <code class="hljs go">fatal error: concurrent <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> writes goroutine <span class="hljs-number"><span class="hljs-number">539</span></span> [running]: runtime.throw(<span class="hljs-number"><span class="hljs-number">0x147bf</span></span>60, <span class="hljs-number"><span class="hljs-number">0x15</span></span>) /usr/local/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>/src/runtime/<span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">616</span></span> +<span class="hljs-number"><span class="hljs-number">0x81</span></span> fp=<span class="hljs-number"><span class="hljs-number">0xc4207159d</span></span>8 sp=<span class="hljs-number"><span class="hljs-number">0xc4207159b8</span></span> pc=<span class="hljs-number"><span class="hljs-number">0x102ca01</span></span> runtime.mapassign_faststr(<span class="hljs-number"><span class="hljs-number">0x13f</span></span>5140, <span class="hljs-number"><span class="hljs-number">0xc4201ca0c0</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4203a8097</span></span>, <span class="hljs-number"><span class="hljs-number">0x6</span></span>, <span class="hljs-number"><span class="hljs-number">0x1012001</span></span>) /usr/local/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>/src/runtime/hashmap_fast.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">703</span></span> +<span class="hljs-number"><span class="hljs-number">0x3e9</span></span> fp=<span class="hljs-number"><span class="hljs-number">0xc420715a48</span></span> sp=<span class="hljs-number"><span class="hljs-number">0xc4207159d</span></span>8 pc=<span class="hljs-number"><span class="hljs-number">0x100d</span></span>879 services/statestorage.(*service).WriteKey(<span class="hljs-number"><span class="hljs-number">0xc42000c060</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4209e6800</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4206491a0</span></span>, <span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-number"><span class="hljs-number">0x0</span></span>) services/statestorage/methods.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span> +<span class="hljs-number"><span class="hljs-number">0x10c</span></span> fp=<span class="hljs-number"><span class="hljs-number">0xc420715a88</span></span> sp=<span class="hljs-number"><span class="hljs-number">0xc420715a48</span></span> pc=<span class="hljs-number"><span class="hljs-number">0x138339c</span></span> services/virtualmachine.(*service).processTransfer(<span class="hljs-number"><span class="hljs-number">0xc4201ca090</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4203a8097</span></span>, <span class="hljs-number"><span class="hljs-number">0x6</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4203a80a1</span></span>, <span class="hljs-number"><span class="hljs-number">0x6</span></span>, <span class="hljs-number"><span class="hljs-number">0x2a4</span></span>, <span class="hljs-number"><span class="hljs-number">0xc420715b30</span></span>, <span class="hljs-number"><span class="hljs-number">0x1012928</span></span>, <span class="hljs-number"><span class="hljs-number">0x40</span></span>) services/virtualmachine/processor.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span> +<span class="hljs-number"><span class="hljs-number">0x16e</span></span> fp=<span class="hljs-number"><span class="hljs-number">0xc420715ad</span></span>0 sp=<span class="hljs-number"><span class="hljs-number">0xc420715a88</span></span> pc=<span class="hljs-number"><span class="hljs-number">0x13840ee</span></span> services/virtualmachine.(*service).ProcessTransaction(<span class="hljs-number"><span class="hljs-number">0xc4201ca090</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4209e67c0</span></span>, <span class="hljs-number"><span class="hljs-number">0x30</span></span>, <span class="hljs-number"><span class="hljs-number">0x1433660</span></span>, <span class="hljs-number"><span class="hljs-number">0x12a1d</span></span>01) Ginkgo ran <span class="hljs-number"><span class="hljs-number">1</span></span> suite in <span class="hljs-number"><span class="hljs-number">1.288879763s</span></span> Test Suite Failed</code> </pre> <br>  ?   <code>StateStorage</code>       ( <code>map</code> ),   . ,     ,            .     ,           <code>map</code>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sync.map</a> .     . <br><br>     <a href="">processTransfer()</a> .         ,   —      .         , ,         ,        ,     .     ,          <code>processTransfer()</code> . <a href=""></a>  . <br><br>    ,   . ,    ,     . <br><br><pre> <code class="hljs go">e2e/stress/transactions.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">44</span></span> Expected &lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;: <span class="hljs-number"><span class="hljs-number">-7498</span></span> to equal &lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;: <span class="hljs-number"><span class="hljs-number">-7551</span></span> e2e/stress/transactions.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">82</span></span> ------------------------------ Ginkgo ran <span class="hljs-number"><span class="hljs-number">1</span></span> suite in <span class="hljs-number"><span class="hljs-number">5.251593179s</span></span> Test Suite Failed</code> </pre> <br>       ,    . ,   ,          ( ,           ).    ,   <a href=""></a> ,    . <br><br>  —  .    TDD         .   ?           ,       100%?!   ,    —      .    <code>processTransfer()</code>      ,       ,    . <br><br>             .  ,       <a href=""></a>   ,   . <a href=""></a>    . <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br> , ,  ,     -,      ,      ,  ?     ?   — . <br><br>       ,     -.  ,  «»  <code>processTransfer()</code>      .  ,  ,    <a href=""></a> .         ,   — .    ,      -       .     ,        ,        . <br><br>     . ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> .  ,     <code>StateStorage</code>   <code>WriteKey</code> ,     , , ,     <code>WriteKeys</code>    ,         ,       . <br><br>   ,        :          .            « ».       -,        ,  ,     ,    ,      .   —     .     ,   ,    —      . <br><br>       ,       —   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  GitHub.          .  ,   ,    , , ,     ,      . <br><br>  <b>Chers lecteurs!</b>        ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413681/">https://habr.com/ru/post/fr413681/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413669/index.html">Samsung IT School: enseigner aux étudiants comment développer des applications mobiles</a></li>
<li><a href="../fr413673/index.html">Sur la question des performances des anciennes et nouvelles versions d'un nœud</a></li>
<li><a href="../fr413675/index.html">Joker 2018: Club des développeurs Java anonymes</a></li>
<li><a href="../fr413677/index.html">Lancement de ROS sur le robot auto-équilibrant EduMIP</a></li>
<li><a href="../fr413679/index.html">Angulaire 6. PWA. Modules de chargement paresseux. Déploiement automatique dans Firebase</a></li>
<li><a href="../fr413683/index.html">ILV a débloqué 7 millions d'adresses IP. Rester verrouillé 4 millions</a></li>
<li><a href="../fr413689/index.html">Debian + Postfix + Dovecot + Multidomain + SSL + IPv6 + OpenVPN + Multi-interfaces + SpamAssassin-learn + Bind</a></li>
<li><a href="../fr413691/index.html">Commencer</a></li>
<li><a href="../fr413693/index.html">Fait à la main: clavier programmable pour le commerce en ligne à faire soi-même</a></li>
<li><a href="../fr413695/index.html">Sécurité de Messenger: pourquoi le stockage de messages sur la blockchain pourrait être une bonne idée</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>