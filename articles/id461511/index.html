<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìë üê© ‚úåüèº Manajemen Ketergantungan Python: Perbandingan Pendekatan üçÆ üöá üë©üèΩ‚Äçü§ù‚Äçüë®üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya telah menulis dengan python selama lima tahun, dimana tiga tahun terakhir telah mengembangkan proyek saya sendiri. Sebagian besar cara tim saya m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manajemen Ketergantungan Python: Perbandingan Pendekatan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461511/"><img src="http://ftcdn.pw/cd64d5e9-af9a-46cc-868b-c8873c98adb6.png" alt="gambar"><br><br>  Saya telah menulis dengan python selama lima tahun, dimana tiga tahun terakhir telah mengembangkan proyek saya sendiri.  Sebagian besar cara tim saya membantu saya dengan ini.  Dan dengan setiap rilis, dengan setiap fitur baru, kami semakin berusaha untuk memastikan bahwa proyek tidak berubah menjadi berantakan dari kode yang tidak didukung;  kami berjuang dengan impor siklik, saling ketergantungan, mengalokasikan modul yang dapat digunakan kembali, membangun kembali struktur. <br><br>  Sayangnya, dalam komunitas Python tidak ada konsep universal "arsitektur yang baik", hanya ada konsep "pythonicity", jadi kita harus membuat sendiri arsitekturnya.  Di bawah cut - Longrid dengan refleksi pada arsitektur, dan pertama - tama - pada manajemen dependensi berlaku untuk Python. <br><a name="habracut"></a><br><h1>  django.setup () </h1><br>  Saya akan mulai dengan pertanyaan kepada para dzhangis.  Apakah Anda sering menulis dua baris ini? <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> django django.setup()</code> </pre> <br>  Anda perlu memulai file dari ini jika Anda ingin bekerja dengan objek Django tanpa memulai server web Django itu sendiri.  Ini berlaku untuk model, dan alat untuk bekerja dengan waktu ( <code><b>django.utils.timezone</b></code> ), dan <code><b>django.urls.reverse</b></code> ( <code><b>django.urls.reverse</b></code> ), dan banyak lagi.  Jika ini tidak dilakukan, maka Anda akan mendapatkan kesalahan: <br><br><pre> <code class="plaintext hljs">django.core.exceptions.AppRegistryNotReady: Apps aren't loaded yet.</code> </pre><br>  Saya terus menulis dua baris ini.  Saya penggemar berat kode ejeksi;  Saya suka membuat file <code><b>.py</b></code> terpisah, memutar hal-hal di dalamnya, mencari tahu - dan kemudian menanamkannya dalam proyek. <br><br>  Dan <code><b>django.setup()</b></code> konstan ini <code><b>django.setup()</b></code> mengganggu saya.  Pertama, Anda bosan mengulanginya di mana-mana;  dan, kedua, inisialisasi Django membutuhkan waktu beberapa detik (kami memiliki monolith besar), dan ketika Anda me-restart file yang sama 10, 20, 100 kali - itu hanya memperlambat pengembangan. <br><br>  Bagaimana cara menyingkirkan <code><b>django.setup()</b></code> ?  Anda perlu menulis kode yang minimal tergantung pada Django. <br><br>  Sebagai contoh, jika kita menulis klien dari API eksternal, maka kita dapat membuatnya bergantung pada Django: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.conf <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> settings <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">APIClient</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.api_key = settings.SOME_API_KEY <span class="hljs-comment"><span class="hljs-comment"># : client = APIClient()</span></span></code> </pre><br>  atau itu bisa independen dari Django: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">APIClient</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, api_key)</span></span></span><span class="hljs-function">:</span></span> self.api_key = api_key <span class="hljs-comment"><span class="hljs-comment"># : client = APIClient(api_key='abc')</span></span></code> </pre><br>  Dalam kasus kedua, konstruktor lebih rumit, tetapi setiap manipulasi dengan kelas ini dapat dilakukan tanpa memuat seluruh mesin dzhangovskoy. <br><br>  Tes juga semakin mudah.  Bagaimana cara menguji komponen yang tergantung pada pengaturan <code><b>django.conf.settings</b></code> ?  Cukup kunci mereka dengan dekorator <code><b>@override_settings</b></code> .  Dan jika komponen tidak bergantung pada apa pun, maka tidak akan ada yang menjadi basah: ia melewati parameter ke konstruktor - dan mengendarainya. <br><br><h1>  Manajemen ketergantungan </h1><br>  Kisah dependensi <code><b>django</b></code> adalah contoh paling mencolok dari masalah yang saya temui setiap hari: masalah manajemen dependensi dalam python - dan arsitektur keseluruhan aplikasi python. <br><br>  Hubungan dengan manajemen ketergantungan dalam komunitas Python beragam.  Tiga kamp utama dapat dibedakan: <br><br><ul><li>  Python adalah bahasa yang fleksibel.  Kami menulis seperti yang kami inginkan, tergantung pada apa yang kami inginkan.  Kami tidak malu tentang dependensi siklik, substitusi atribut untuk kelas dalam runtime, dll. <br><br></li><li>  Python adalah bahasa khusus.  Ada cara-cara idiomatis untuk membangun arsitektur dan dependensi.  Transfer data naik dan turun dari tumpukan panggilan dilakukan oleh iterator, coroutine, dan manajer konteks. <br><br><div class="spoiler">  <b class="spoiler_title">Laporan kelas tentang subjek dan contoh ini</b> <div class="spoiler_text">  Brandon Rhodes, Dropbox: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hoist IO Anda</a> . <br><br>  Contoh dari laporan: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""          """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"/etc/hosts"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> file: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parse_hosts(file): print(line) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_hosts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lines)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    -   """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lines: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> line.startswith(<span class="hljs-string"><span class="hljs-string">"#"</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> line</code> </pre><br></div></div><br></li><li>  Fleksibilitas Python adalah cara ekstra untuk menembak diri sendiri di kaki.  Anda memerlukan seperangkat aturan kaku untuk mengelola dependensi.  Contoh yang baik adalah orang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">-</a> orang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">python kering</a> Rusia.  Masih ada pendekatan yang kurang hardcore - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">struktur Django untuk skala dan umur panjang</a> , Tapi idenya sama. <br></li></ul><br>  Ada beberapa artikel tentang manajemen dependensi dalam python ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh 2</a> ), tetapi mereka semua turun untuk mengiklankan kerangka Ketergantungan Injeksi seseorang.  Artikel ini adalah entri baru pada topik yang sama, tetapi kali ini merupakan eksperimen pemikiran murni tanpa iklan.  Ini adalah upaya untuk menemukan keseimbangan antara tiga pendekatan di atas, lakukan tanpa kerangka kerja tambahan dan menjadikannya "pythonic". <br><br>  Saya baru-baru ini membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur Bersih</a> - dan saya tampaknya mengerti apa nilai ketergantungan injeksi dalam python dan bagaimana itu dapat diimplementasikan.  Saya melihat ini pada contoh proyek saya sendiri.  Singkatnya, ini <b>melindungi kode dari kerusakan ketika kode lain berubah</b> . <br><br><h1>  Sumber data </h1><br>  Ada klien API yang mengeksekusi permintaan HTTP untuk penyingkat layanan: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># shortener_client.py import requests class ShortenerClient: def __init__(self, api_key): self.api_key = api_key def shorten_link(self, url): response = requests.post( url='https://fstrk.cc/short', headers={'Authorization': self.api_key}, json={'url': url} ) return response.json()['url']</span></span></code> </pre><br>  Dan ada modul yang mempersingkat semua tautan dalam teks.  Untuk melakukan ini, ia menggunakan klien API shortener: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># text_processor.py import re from shortener_client import ShortenerClient class TextProcessor: def __init__(self, text): self.text = text def process(self): changed_text = self.text links = re.findall( r'https?://[^\r\n\t") ]*', self.text, flags=re.MULTILINE ) api_client = ShortenerClient('abc') for link in links: shortened = api_client.shorten_link(link) changed_text = changed_text.replace(link, shortened) return changed_text</span></span></code> </pre><br>  Logika eksekusi kode hidup dalam file kontrol yang terpisah (sebut saja itu pengontrol): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># controller.py from text_processor import TextProcessor processor = TextProcessor("""  1: https://ya.ru  2: https://google.com """) print(processor.process())</span></span></code> </pre><br>  Semuanya berfungsi.  Prosesor mem-parsing teks, memperpendek tautan menggunakan penyingkat, mengembalikan hasilnya.  Ketergantungan terlihat seperti ini: <br><br><img src="http://ftcdn.pw/58d8aa1d-0024-42c6-918e-05b2d41f126d.png" alt="gambar"><br><br><h1>  Masalah </h1><br>  Inilah masalahnya: kelas <code><b>TextProcessor</b></code> tergantung pada kelas <code><b>ShortenerClient</b></code> - dan <b>rusak ketika antarmuka</b> <code><b>ShortenerClient</b></code> <b>berubah</b> . <br><br>  Bagaimana ini bisa terjadi? <br><br>  Misalkan dalam proyek kami, kami memutuskan untuk melacak <code><b>shorten_link</b></code> dan menambahkan argumen <code><b>callback_url</b></code> ke metode <code><b>shorten_link</b></code> .  Argumen ini berarti alamat yang pemberitahuannya harus datang saat mengklik tautan. <br><br>  Metode <code><b>ShortenerClient.shorten_link</b></code> mulai terlihat seperti ini: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shorten_link</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, url, callback_url)</span></span></span><span class="hljs-function">:</span></span> response = requests.post( url=<span class="hljs-string"><span class="hljs-string">'https://fstrk.cc/short'</span></span>, headers={<span class="hljs-string"><span class="hljs-string">'Authorization'</span></span>: self.api_key}, json={<span class="hljs-string"><span class="hljs-string">'url'</span></span>: url, <span class="hljs-string"><span class="hljs-string">'callback_on_click'</span></span>: callback_url} ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json()[<span class="hljs-string"><span class="hljs-string">'url'</span></span>]</code> </pre><br>  Dan apa yang terjadi?  Dan ternyata ketika kami mencoba memulai, kami mendapat kesalahan: <br><br><pre> <code class="python hljs">TypeError: shorten_link() missing <span class="hljs-number"><span class="hljs-number">1</span></span> required positional argument: <span class="hljs-string"><span class="hljs-string">'callback_url'</span></span></code> </pre><br>  Yaitu, kami mengganti shortener, tetapi bukan dia yang bangkrut, tetapi kliennya: <br><br><img src="http://ftcdn.pw/13e9dcd5-7866-4c82-b1d0-e56134650b62.png" alt="gambar"><br><br>  Jadi apa  Nah, file panggilan terputus, kami pergi dan memperbaikinya.  Apa masalahnya? <br><br>  Jika ini diselesaikan dalam satu menit - mereka pergi dan diperbaiki - maka ini, tentu saja, tidak masalah sama sekali.  Jika ada sedikit kode di kelas dan jika Anda mendukungnya sendiri (ini adalah proyek sampingan Anda, ini adalah dua kelas kecil dari subsistem yang sama, dll.), Maka Anda bisa berhenti di sana. <br><br>  Masalah mulai ketika: <br><br><ul><li>  modul pemanggil dan dipanggil memiliki banyak kode; </li><li>  modul yang berbeda didukung oleh orang / tim yang berbeda. </li></ul><br>  Jika Anda menulis kelas <code><b>ShortenerClient</b></code> , dan kolega Anda menulis <code><b>TextProcessor</b></code> , Anda mendapatkan situasi ofensif: <b>Anda mengubah kode, tetapi itu rusak.</b>  Dan itu pecah di tempat yang belum pernah Anda lihat dalam hidup, dan sekarang Anda perlu duduk dan memahami kode orang lain. <br><br>  Yang lebih menarik adalah ketika modul Anda digunakan di beberapa tempat, dan bukan di satu;  dan hasil edit Anda akan memecah kode pada tumpukan file. <br><br>  Oleh karena itu, masalahnya dapat dirumuskan sebagai berikut: bagaimana mengatur kode sehingga ketika antarmuka <code><b>ShortenerClient</b></code> diubah, <code><b>ShortenerClient</b></code> <b>sendiri <code><b>ShortenerClient</b></code> , dan bukan penggunanya</b> (yang jumlahnya bisa banyak)? <br><br>  Solusinya di sini adalah: <br><br><ul><li>  Konsumen kelas dan kelas itu sendiri harus menyetujui antarmuka umum.  Antarmuka ini harus menjadi hukum. </li><li>  Jika kelas berhenti sesuai dengan antarmuka, ini akan menjadi masalahnya, dan bukan masalah konsumen. </li></ul><br><img src="http://ftcdn.pw/dbb4d320-2683-4f2e-821e-dea621b54b53.png" alt="gambar"><br><br><h1>  Bekukan antarmuka </h1><br>  Seperti apa cara memperbaiki tampilan antarmuka dengan python?  Ini adalah kelas abstrak: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> abc <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ABC, abstractmethod <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ABC)</span></span></span><span class="hljs-class">:</span></span> @abstractmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, api_key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> @abstractmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shorten_link</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, link)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  Jika sekarang kita mewarisi dari kelas ini dan lupa mengimplementasikan beberapa metode, kita akan mendapatkan kesalahan: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShortenerClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(AbstractClient)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__ini__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, api_key)</span></span></span><span class="hljs-function">:</span></span> self.api_key = api_key client = ShortenerClient(<span class="hljs-string"><span class="hljs-string">'123'</span></span>) &gt;&gt;&gt; TypeError: Can<span class="hljs-string"><span class="hljs-string">'t instantiate abstract class ShortenerClient with abstract methods __init__, shorten_link</span></span></code> </pre><br>  Tetapi ini tidak cukup.  Kelas abstrak hanya menangkap nama-nama metode, tetapi tidak tanda tangan mereka. <br><br>  Butuh alat verifikasi tanda tangan kedua Alat kedua ini <code><b>mypy</b></code> .  Ini akan membantu memverifikasi tanda tangan dari metode yang diwariskan.  Untuk melakukan ini, kita harus menambahkan anotasi ke antarmuka: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># shortener_client.py from abc import ABC, abstractmethod class AbstractClient(ABC): @abstractmethod def __init__(self, api_key: str) -&gt; None: pass @abstractmethod def shorten_link(self, link: str) -&gt; str: pass class ShortenerClient(AbstractClient): def __init__(self, api_key: str) -&gt; None: self.api_key = api_key def shorten_link(self, link: str, callback_url: str) -&gt; str: return 'xxx'</span></span></code> </pre><br>  Jika sekarang kami memeriksa kode ini dengan <code><b>mypy</b></code> , kami mendapatkan kesalahan karena argumen <code><b>callback_url</b></code> tambahan: <br><br><pre> <code class="plaintext hljs">mypy shortener_client.py &gt;&gt;&gt; error: Signature of "shorten_link" incompatible with supertype "AbstractClient"</code> </pre><br>  Sekarang kita memiliki cara yang dapat diandalkan untuk melakukan antarmuka kelas. <br><br><h1>  Ketergantungan inversi </h1><br>  Setelah mendebug antarmuka, kita harus memindahkannya ke tempat lain untuk sepenuhnya menghilangkan ketergantungan konsumen pada file <code><b>shortener_client.py</b></code> .  Misalnya, Anda dapat menyeret antarmuka langsung ke konsumen - ke file dengan prosesor <code><b>TextProcessor</b></code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># text_processor.py import re from abc import ABC, abstractmethod class AbstractClient(ABC): @abstractmethod def __init__(self, api_key: str) -&gt; None: pass @abstractmethod def shorten_link(self, link: str) -&gt; str: pass class TextProcessor: def __init__(self, text, shortener_client: AbstractClient) -&gt; None: self.text = text self.shortener_client = shortener_client def process(self) -&gt; str: changed_text = self.text links = re.findall( r'https?://[^\r\n\t") ]*', self.text, flags=re.MULTILINE ) for link in links: shortened = self.shortener_client.shorten_link(link) changed_text = changed_text.replace(link, shortened) return changed_text</span></span></code> </pre><br>  Dan itu akan mengubah arah kecanduan!  Sekarang <code><b>TextProcessor</b></code> memiliki antarmuka interaksi, dan sebagai hasilnya, <code><b>ShortenerClient</b></code> bergantung padanya, dan bukan sebaliknya. <br><br><img src="http://ftcdn.pw/33f3c619-63bf-420d-99d0-67bed0dfa628.png" alt="gambar"><br><br>  Dengan kata-kata sederhana, kita dapat menggambarkan esensi dari transformasi kita sebagai berikut: <br><br><ul><li>  <code><b>TextProcessor</b></code> mengatakan: Saya seorang prosesor, dan saya terlibat dalam konversi teks.  Saya tidak ingin tahu apa-apa tentang mekanisme pemendekan: ini bukan urusan saya.  Saya ingin menarik metode <code><b>shorten_link</b></code> sehingga <code><b>shorten_link</b></code> segalanya untuk saya.  Jadi tolong, beri saya objek yang bermain sesuai dengan aturan saya.  Keputusan tentang bagaimana saya berinteraksi dibuat oleh saya, bukan dia. </li><li>  <code><b>ShortenerClient</b></code> mengatakan: sepertinya saya tidak bisa hidup dalam ruang hampa, dan mereka membutuhkan perilaku tertentu dari saya.  Saya akan bertanya pada <code><b>TextProcessor</b></code> apa yang harus saya cocokkan agar tidak rusak. </li></ul><br><h1>  Banyak konsumen </h1><br>  Jika beberapa modul menggunakan tautan pemendekan, maka antarmuka harus diletakkan bukan di salah satu dari mereka, tetapi di beberapa file terpisah, yang terletak di atas file lain, lebih tinggi dalam hierarki: <br><br><img src="http://ftcdn.pw/a81ef19a-45aa-4b23-b93a-e9a6b9094670.png" alt="gambar"><br><br><h1>  Komponen kontrol </h1><br>  Jika konsumen tidak mengimpor <code><b>ShortenerClient</b></code> , lalu siapa yang akan mengimpor dan membuat objek kelas?  Itu harus menjadi komponen kontrol - dalam kasus kami itu adalah <code><b>controller.py</b></code> . <br><br>  Pendekatan paling sederhana adalah injeksi ketergantungan langsung, Injeksi Ketergantungan "di dahi".  Kami membuat objek dalam kode panggilan, mentransfer satu objek ke objek lainnya.  Untung <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># controller.py import TextProcessor import ShortenerClient processor = TextProcessor( text=' 1: https://ya.ru  2: https://google.com', shortener_client=ShortenerClient(api_key='123') ) print(processor.process())</span></span></code> </pre><br><h1>  Pendekatan python </h1><br>  Pendekatan yang lebih "pythonic" diyakini sebagai Injeksi Ketergantungan melalui warisan. <br><br><div class="spoiler">  <b class="spoiler_title">Raymond Hettinger membicarakan hal ini dengan sangat terperinci dalam laporan Super yang dianggapnya Super.</b> <div class="spoiler_text"><div class="oembed">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.youtube.com/watch?v=EiOglTERPEo</a> </div><br></div></div><br>  Untuk menyesuaikan kode dengan gaya ini, Anda perlu sedikit mengubah <code><b>TextProcessor</b></code> , membuatnya dapat diwarisi: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># text_processor.py class TextProcessor: def __init__(self, text: str) -&gt; None: self.text = text self.shortener_client: AbstractClient = self.get_shortener_client() def get_shortener_client(self) -&gt; AbstractClient: """      """ raise NotImplementedError</span></span></code> </pre><br>  Dan kemudian, dalam kode panggilan, mewarisinya: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># controller.py import TextProcessor import ShortenerClient class ProcessorWithClient(TextProcessor): """   ,    """ def get_shortener_client(self) -&gt; ShortenerClient: return ShortenerClient(api_key='abc') processor = ProcessorWithClient( text=' 1: https://ya.ru  2: https://google.com' ) print(processor.process())</span></span></code> </pre><br>  Contoh kedua ada di mana-mana dalam kerangka kerja populer: <br><br><ul><li>  Di Django, kami terus diwariskan.  Kami mendefinisikan kembali metode tampilan, model, formulir berbasis kelas;  dengan kata lain, suntikkan dependensi kami ke dalam kerangka kerja yang sudah didebitkan. </li><li>  Di DRF, hal yang sama.  Kami memperluas pandangan, serialisator, izin. </li><li>  Dan sebagainya.  Ada banyak contoh. </li></ul><br>  Contoh kedua terlihat lebih cantik dan lebih akrab, bukan?  Mari kita kembangkan dan lihat apakah kecantikan ini terjaga. <br><br><h1>  Pengembangan python </h1><br>  Dalam logika bisnis, biasanya ada lebih dari dua komponen.  Misalkan <code><b>TextProcessor</b></code> kami bukan kelas independen, tetapi hanya salah satu elemen <code><b>TextPipeline</b></code> yang memproses teks dan mengirimkannya ke surat: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextPipeline</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, text, email)</span></span></span><span class="hljs-function">:</span></span> self.text_processor = TextProcessor(text) self.mailer = Mailer(email) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_and_mail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> processed_text = self.text_processor.process() self.mailer.send_text(text=processed_text)</code> </pre><br>  Jika kita ingin mengisolasi <code><b>TextPipeline</b></code> dari kelas yang digunakan, kita harus mengikuti prosedur yang sama seperti sebelumnya: <br><br><ul><li>  kelas <code><b>TextPipeline</b></code> akan mendeklarasikan antarmuka untuk komponen yang digunakan; </li><li>  komponen yang digunakan akan dipaksa untuk menyesuaikan diri dengan antarmuka ini; </li><li>  beberapa kode eksternal akan menyatukan dan menjalankan semuanya. </li></ul><br>  Diagram dependensi akan terlihat seperti ini: <br><br><img src="http://ftcdn.pw/35f207fa-3ad7-4779-92c3-ae8f63401b8e.png" alt="gambar"><br><br>  Tapi seperti apa kode assembly dari dependensi ini sekarang? <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TextProcessor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ShortenerClient <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Mailer <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TextPipeline <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProcessorWithClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(TextProcessor)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_shortener_client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; ShortenerClient:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ShortenerClient(api_key=<span class="hljs-string"><span class="hljs-string">'123'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PipelineWithDependencies</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(TextPipeline)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_text_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, text: str)</span></span></span><span class="hljs-function"> -&gt; ProcessorWithClient:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProcessorWithClient(text) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_mailer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, email: str)</span></span></span><span class="hljs-function"> -&gt; Mailer:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Mailer(email) pipeline = PipelineWithDependencies( email=<span class="hljs-string"><span class="hljs-string">'abc@def.com'</span></span>, text=<span class="hljs-string"><span class="hljs-string">' 1: https://ya.ru  2: https://google.com'</span></span> ) pipeline.process_and_mail()</code> </pre><br>  Pernahkah Anda memperhatikan?  Kami pertama kali mewarisi kelas <code><b>TextProcessor</b></code> untuk menyisipkan <code><b>ShortenerClient</b></code> ke dalamnya, dan kemudian mewarisi <code><b>TextPipeline</b></code> untuk memasukkan <code><b>TextProcessor</b></code> kami yang telah didefinisikan ulang (serta <code><b>Mailer</b></code> ) ke dalamnya.  Kami memiliki beberapa tingkat redefinisi berurutan.  Sudah rumit. <br><br>  Mengapa semua kerangka kerja diatur dengan cara ini?  <b>Ya, karena hanya cocok untuk kerangka kerja.</b> <br><br><ul><li>  Semua tingkatan kerangka kerja didefinisikan dengan jelas, dan jumlahnya terbatas.  Misalnya, di Django, Anda bisa mengesampingkan <code><b>FormField</b></code> untuk menyisipkannya ke override <code><b>Form</b></code> , untuk menyisipkan formulir ke override tampilan.  Itu saja.  Tiga level. </li><li>  Setiap kerangka kerja melayani satu tujuan.  Tugas ini didefinisikan dengan jelas. </li><li>  Setiap kerangka kerja memiliki dokumentasi terperinci yang menjelaskan bagaimana dan apa yang akan diwarisi;  apa dan dengan apa yang harus digabungkan. </li></ul><br>  Dapatkah Anda dengan jelas dan jelas mengidentifikasi dan mendokumentasikan logika bisnis Anda?  Terutama arsitektur tingkat di mana ia bekerja?  Saya tidak.  Sayangnya, pendekatan Raymond Hettinger tidak mempengaruhi logika bisnis. <br><br><h1>  Kembali ke pendekatan dahi </h1><br>  Pada beberapa tingkat kesulitan, pendekatan sederhana menang.  Itu terlihat lebih sederhana - dan lebih mudah untuk berubah ketika logika berubah. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TextProcessor <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ShortenerClient <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Mailer <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TextPipeline pipeline = TextPipeline( text_processor=TextProcessor( text=<span class="hljs-string"><span class="hljs-string">' 1: https://ya.ru  2: https://google.com'</span></span>, shortener_client=ShortenerClient(api_key=<span class="hljs-string"><span class="hljs-string">'abc'</span></span>) ), mailer=Mailer(<span class="hljs-string"><span class="hljs-string">'abc@def.com'</span></span>) ) pipeline.process_and_mail()</code> </pre><br>  Tetapi, ketika jumlah level logika meningkat, bahkan pendekatan ini menjadi tidak nyaman.  Kita harus secara agresif memulai banyak kelas, melewati mereka satu sama lain.  Saya ingin menghindari banyak level sarang. <br><br>  Mari kita coba satu panggilan lagi. <br><br><h1>  Penyimpanan Instance Global </h1><br>  Mari kita coba membuat kamus global di mana instance dari komponen yang kita butuhkan berada.  Dan biarkan komponen-komponen ini saling terhubung melalui akses ke kamus ini. <br><br>  Sebut saja <code><b>INSTANCE_DICT</b></code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># text_processor.py import INSTANCE_DICT class TextProcessor(AbstractTextProcessor): def __init__(self, text) -&gt; None: self.text = text def process(self) -&gt; str: shortener_client: AbstractClient = INSTANCE_DICT['Shortener'] # ...  </span></span></code> </pre><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># text_pipeline.py import INSTANCE_DICT class TextPipeline: def __init__(self) -&gt; None: self.text_processor: AbstractTextProcessor = INSTANCE_DICT[ 'TextProcessor'] self.mailer: AbstractMailer = INSTANCE_DICT['Mailer'] def process_and_mail(self) -&gt; None: processed_text = self.text_processor.process() self.mailer.send_text(text=processed_text)</span></span></code> </pre><br>  Caranya adalah dengan <b>meletakkan objek kami di kamus ini sebelum diakses</b> .  Inilah yang akan kita lakukan di <code><b>controller.py</b></code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># controller.py import INSTANCE_DICT import TextProcessor import ShortenerClient import Mailer import TextPipeline INSTANCE_DICT['Shortener'] = ShortenerClient('123') INSTANCE_DICT['Mailer'] = Mailer('abc@def.com') INSTANCE_DICT['TextProcessor'] = TextProcessor(text=' : https://ya.ru') pipeline = TextPipeline() pipeline.process_and_mail()</span></span></code> </pre><br>  Keuntungan bekerja melalui kamus global: <br><br><ul><li>  tidak ada keajaiban kap mesin dan kerangka DI tambahan; </li><li>  daftar datar dependensi di mana Anda tidak perlu mengelola bersarang; </li><li>  semua bonus DI: pengujian sederhana, independensi, perlindungan komponen dari kerusakan saat komponen lain berubah. </li></ul><br>  Tentu saja, alih-alih membuat <code><b>INSTANCE_DICT</b></code> , Anda dapat menggunakan semacam kerangka DI;  tetapi esensi dari ini tidak akan berubah.  Kerangka kerja ini akan memberikan manajemen instance yang lebih fleksibel;  dia akan memungkinkan Anda untuk membuatnya dalam bentuk singletone atau bundel, seperti pabrik;  tetapi idenya akan tetap sama. <br><br>  Mungkin pada titik tertentu ini tidak akan cukup bagi saya, dan saya masih memilih semacam kerangka kerja. <br><br>  Dan, mungkin, semua ini tidak perlu, dan lebih mudah untuk melakukannya tanpa itu: tulis impor langsung dan tidak membuat antarmuka abstrak yang tidak perlu. <br><br>  Apa pengalaman Anda dengan manajemen ketergantungan di python?  Dan secara umum - apakah perlu, atau saya menemukan masalah dari udara? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461511/">https://habr.com/ru/post/id461511/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461501/index.html">Mengapa di AS mereka sedang menyelidiki pekerjaan perusahaan IT besar</a></li>
<li><a href="../id461503/index.html">Membuat database tersedia untuk koneksi jarak jauh</a></li>
<li><a href="../id461505/index.html">8 bug dari pengembang JavaScript pemula yang mencegah Anda menjadi profesional</a></li>
<li><a href="../id461507/index.html">Mengapa kami memutuskan untuk meluncurkan StartupDrive akselerator perusahaan Gazprom Neft, dan siapa yang sudah melewatinya</a></li>
<li><a href="../id461509/index.html">Asisten Perjalanan: Pilihan gadget dan aksesori</a></li>
<li><a href="../id461517/index.html">Algoritma Copy-Paste Terbaik untuk C dan C ++. Haiku OS Cookbook</a></li>
<li><a href="../id461519/index.html">Algoritma Copy-Paste Terbaik untuk C dan C ++. Koleksi Resep OS Haiku</a></li>
<li><a href="../id461523/index.html">WAL di PostgreSQL: 4. Pengaturan log</a></li>
<li><a href="../id461525/index.html">Bagaimana saya melakukan slider yang benar-benar adaptif (carousel)</a></li>
<li><a href="../id461527/index.html">Pengangkatan akustik DIY</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>