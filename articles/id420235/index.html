<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏱️ 👨🏻‍🚀 🐟 Zenject: Bagaimana Kontainer IoC Dapat Membunuh Injeksi Ketergantungan pada Proyek Anda 🙌🏾 👩🏼‍💻 ✝️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di mana bahaya dimulai? Misalkan Anda sangat yakin bahwa Anda akan mengembangkan suatu proyek, mengikuti konsep atau pendekatan tertentu. Dalam situas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zenject: Bagaimana Kontainer IoC Dapat Membunuh Injeksi Ketergantungan pada Proyek Anda</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420235/">  Di mana bahaya dimulai?  Misalkan Anda sangat yakin bahwa Anda akan mengembangkan suatu proyek, mengikuti konsep atau pendekatan tertentu.  Dalam situasi kami, ini adalah DI, meskipun Pemrograman Reaktif, misalnya, mungkin juga ada di tempatnya.  Adalah logis bahwa untuk mencapai tujuan Anda, Anda akan beralih ke solusi yang sudah jadi (dalam contoh kami, wadah DI Zenject).  Anda akan membiasakan diri dengan dokumentasi dan mulai membangun kerangka kerja aplikasi menggunakan fungsi utama.  Jika pada tahap pertama menggunakan solusi Anda tidak memiliki sensasi yang tidak menyenangkan, maka kemungkinan besar itu akan bertahan pada proyek Anda selama seumur hidup.  Saat Anda bekerja dengan fungsi dasar solusi (wadah), Anda mungkin memiliki pertanyaan atau keinginan untuk membuat beberapa fungsi lebih indah atau efektif.  Tentunya, pertama-tama Anda akan beralih ke "fitur" yang lebih maju dari solusi (wadah) untuk ini.  Dan pada tahap ini, situasi berikut mungkin timbul: Anda sudah tahu dengan baik dan percaya pada solusi yang dipilih, karena yang banyak mungkin tidak berpikir tentang bagaimana ideologis mengoreksi penggunaan fungsional satu atau lainnya dalam solusi mungkin, atau transisi ke solusi lain sudah cukup mahal dan tidak pantas ( mis. tenggat waktu semakin dekat).  Pada tahap inilah situasi paling berbahaya mungkin muncul - fungsionalitas solusi digunakan dengan sedikit perhatian, atau dalam kasus yang jarang terjadi, hanya pada mesin (tanpa pertimbangan). <br><a name="habracut"></a><br><h3>  Siapa yang bisa tertarik dengan ini? </h3><br>  Artikel ini akan bermanfaat bagi mereka yang terbiasa dengan DI dan para pemula DI.  Untuk memahami pengetahuan dasar yang cukup tentang pola apa yang digunakan oleh DI, tujuan DI dan fungsi yang dilakukan wadah IoC.  Ini bukan tentang seluk-beluk implementasi Zenject, tetapi tentang penerapan bagian dari fungsinya.  Artikel ini hanya bergantung pada dokumentasi resmi Zenject dan contoh kode dari itu, serta pada buku Mark Siman "Dependency Injection in .NET," yang merupakan karya lengkap klasik tentang topik teori DI.  Semua kutipan dalam artikel ini adalah kutipan dari buku Mark Siman.  Terlepas dari kenyataan bahwa kita akan berbicara tentang wadah tertentu, artikel ini mungkin bermanfaat bagi mereka yang menggunakan wadah lain. <br><br>  Tujuan artikel ini adalah untuk menunjukkan bagaimana alat yang tujuannya adalah untuk membantu Anda menerapkan DI pada proyek Anda dapat membawa Anda ke arah yang sama sekali berbeda, mendorong Anda untuk membuat kesalahan yang mengikat kode Anda, mengurangi testability kode, dan umumnya menghalangi Anda dari semua keuntungan yang dapat memberikan kamu DI. <br><br>  <i><b>Penafian</b></i> : Tujuan artikel ini bukan untuk mengkritik Zenject atau penulisnya.  Zenject dapat digunakan untuk tujuan yang dimaksudkan dan berfungsi sebagai alat yang sangat baik untuk menerapkan DI, asalkan Anda tidak akan menggunakan set lengkap fungsinya, setelah menetapkan beberapa batasan untuk Anda sendiri. <br><br><h3>  Pendahuluan </h3><br>  <i>Zenject</i> adalah wadah injeksi ketergantungan sumber terbuka yang ditujukan untuk menggunakan mesin permainan Unity3D, yang berfungsi pada sebagian besar platform yang didukung oleh Unity3D.  Perlu dicatat bahwa Zenject juga dapat digunakan untuk aplikasi C # yang dikembangkan tanpa Unity3D.  Wadah ini cukup populer di kalangan pengembang Unity, didukung dan dikembangkan secara aktif.  Selain itu, Zenject memiliki semua fungsi wadah DI yang diperlukan. <br><br>  Saya menggunakan Zenject di 3 proyek Unity besar, dan juga berkomunikasi dengan sejumlah besar pengembang yang menggunakannya.  Alasan penulisan artikel ini adalah pertanyaan yang sering diajukan: <br><br><ul><li>  Apakah menggunakan Zenject merupakan solusi yang baik? </li><li>  Apa yang salah dengan Zenject? </li><li>  Kesulitan apa yang muncul saat menggunakan Zenject? </li></ul><br>  Dan juga beberapa proyek di mana penggunaan Zenject tidak mengarah pada solusi masalah konektivitas kode yang kuat dan arsitektur yang gagal, tetapi sebaliknya memperburuk situasi. <br><br>  Mari kita lihat mengapa pengembang memiliki pertanyaan dan masalah seperti itu.  Anda dapat menjawab sebagai berikut: <br><blockquote>  Ironisnya, wadah DI sendiri cenderung dependensi yang stabil.  ... Ketika Anda memutuskan untuk mengembangkan aplikasi Anda berdasarkan wadah DI tertentu, Anda berisiko dibatasi pada pilihan ini untuk seluruh siklus hidup aplikasi. </blockquote>  Perlu dicatat bahwa dengan penggunaan wadah yang tepat dan terbatas, beralih ke menggunakan wadah lain dalam aplikasi (atau menolak untuk menggunakan wadah demi “ <i>implementasi untuk kaum miskin</i> ”) sangat mungkin dan tidak akan memakan banyak waktu.  Benar, dalam situasi seperti itu, kecil kemungkinan Anda akan membutuhkannya. <br><br>  Sebelum Anda mulai membongkar fungsionalitas Zenject yang berpotensi berbahaya, masuk akal untuk menyegarkan kembali beberapa aspek dasar DI secara dangkal. <br><br>  Aspek pertama adalah <i>tujuan wadah DI.</i>  Mark Siman menulis yang berikut dalam bukunya tentang hal ini: <br><blockquote>  Wadah DI adalah pustaka perangkat lunak yang dapat mengotomatisasi banyak tugas yang dilakukan saat merakit objek dan mengelola siklus hidupnya. </blockquote><blockquote>  Jangan berharap wadah DI secara ajaib mengubah kode yang digabungkan menjadi kode yang longgar.  Wadah dapat meningkatkan efisiensi penggunaan DI, tetapi penekanan dalam aplikasi harus ditempatkan terutama pada penggunaan pola dan bekerja dengan DI. </blockquote>  Aspek kedua adalah <i>pola DI</i> .  Mark Siman mengidentifikasi empat pola utama, diurutkan berdasarkan frekuensi dan kebutuhan penggunaannya: <br><br><ol><li>  Implementasi konstruktor - Bagaimana kita dapat menjamin bahwa ketergantungan yang diperlukan akan selalu tersedia untuk kelas yang sedang dikembangkan? </li><li>  Implementasi properti - Bagaimana saya bisa mengaktifkan DI sebagai opsi di kelas jika ada default lokal yang sesuai? </li><li>  Implementasi metode - Bagaimana saya bisa menyuntikkan dependensi ke dalam kelas jika mereka berbeda untuk setiap operasi? </li><li>  Konteks sekitar - Bagaimana kita bisa membuat ketergantungan tersedia di setiap modul tanpa menyertakan aspek lintas aplikasi dalam setiap komponen API? </li></ol><br>  Pertanyaan-pertanyaan yang ditunjukkan di sebelah nama pola sepenuhnya menggambarkan ruang lingkup mereka.  Pada saat yang sama, artikel tidak akan membahas Implementasi Konstruktor (karena praktis tidak ada keluhan tentang implementasinya di Zenject) dan Konteks Ambient (implementasinya tidak di dalam wadah, tetapi Anda dapat dengan mudah mengimplementasikannya berdasarkan fungsionalitas yang ada). <br>  Sekarang Anda dapat langsung menuju fungsionalitas Zenject yang berpotensi berbahaya. <br><br><h3>  Fungsionalitas berbahaya. </h3><br><h4>  Implementasikan Properties </h4><br>  Ini adalah pola DI paling umum kedua, setelah implementasi konstruktor, tetapi lebih jarang digunakan.  Diimplementasikan dalam Zenject sebagai berikut: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { [Inject] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBar Bar { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  Selain itu, Zenject juga memiliki konsep seperti "Injeksi Lapangan".  Mari kita lihat mengapa dalam Zenject semua fungsi ini adalah yang paling berbahaya. <br><br><ul><li>  Atribut digunakan untuk menunjukkan wadah bidang mana yang akan disematkan.  Ini adalah solusi yang sepenuhnya dapat dipahami, dari sudut pandang kesederhanaan dan logika implementasi wadah itu sendiri.  Namun, kami melihat atribut (dan juga namespace) dalam kode kelas.  Itu, setidaknya secara tidak langsung, tetapi kelas mulai tahu dari mana ia mendapat ketergantungan.  Plus, kami mulai mengencangkan kode kelas ke wadah.  Dengan kata lain, kita tidak bisa lagi menolak untuk menggunakan Zenject tanpa memanipulasi kode kelas. </li><li>  Pola itu sendiri digunakan dalam situasi di mana ketergantungan memiliki standar lokal.  Artinya, ini adalah ketergantungan opsional, dan jika wadah tidak dapat menyediakannya, maka tidak akan ada kesalahan dalam proyek, dan semuanya akan berfungsi.  Namun, menggunakan Zenject, Anda selalu mendapatkan dependensi ini - dependensi menjadi tidak opsional. </li><li>  Karena dependensi dalam hal ini bukan opsional, ia mulai merusak seluruh logika implementasi konstruktor, karena hanya dependensi yang diperlukan yang harus diperkenalkan di sana.  Dengan menerapkan dependensi non-opsional melalui properti, Anda mendapatkan kesempatan untuk membuat dependensi melingkar dalam kode.  Mereka tidak akan begitu jelas, karena di Zenject, implementasi konstruktor pertama kali terpenuhi, dan kemudian implementasi properti, dan Anda tidak akan menerima peringatan dari wadah. </li><li>  Menggunakan wadah DI menyiratkan penerapan pola Akar Komposisi, namun, menggunakan atribut untuk mengkonfigurasi implementasi properti mengarah pada fakta bahwa Anda mengonfigurasi kode tidak hanya dalam Komposisi Root, tetapi juga sesuai kebutuhan di setiap kelas. </li></ul><br><h4>  Pabrik (dan MemoryPool) </h4><br>  Dokumentasi Zenject memiliki seluruh <a href="">bagian</a> tentang pabrik.  Fungsi ini diimplementasikan pada tingkat wadah itu sendiri, dan dimungkinkan juga untuk membuat pabrik kustom Anda sendiri.  Mari kita lihat contoh pertama dari dokumentasi: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Enemy</span></span> { DiContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enemy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DiContainer container</span></span></span><span class="hljs-function">)</span></span> { Container = container; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = Container.Resolve&lt;Player&gt;(); WalkTowards(player.Position); ... etc. } }</code> </pre> <br>  Sudah dalam contoh ini ada pelanggaran berat DI.  Tapi ini lebih merupakan contoh bagaimana membuat pabrik yang sepenuhnya custom.  Apa masalah utama di sini? <br><blockquote>  Wadah DI secara keliru dapat dianggap sebagai pencari lokasi layanan, tetapi itu hanya dapat digunakan sebagai mekanisme untuk menghubungkan grafik objek.  Jika kita mempertimbangkan wadah dari sudut pandang ini, masuk akal untuk membatasi penggunaannya hanya ke akar tata letak.  Pendekatan ini memiliki keuntungan penting yang menghilangkan ikatan antara wadah dan sisa kode aplikasi. </blockquote>  Mari kita lihat bagaimana pabrik “built-in” dari Zenject bekerja.  Ada antarmuka IFactory untuk ini, implementasi yang membawa kita ke kelas PlaceholderFactory: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlaceholderFactory</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TValue</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IPlaceholderFactory</span></span> { [Inject] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Construct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IProvider provider, InjectContext injectContext</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  Di dalamnya kita melihat parameter InjectContext yang memiliki banyak konstruktor, dari bentuk: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InjectContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DiContainer container, Type memberType</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = container; MemberType = memberType; }</code> </pre> <br>  Dan lagi, kita mendapatkan transfer wadah itu sendiri sebagai ketergantungan ke kelas.  Pendekatan ini merupakan pelanggaran berat terhadap DI dan sebagian transformasi wadah menjadi Pencari Layanan. <br>  Selain itu, kelemahan dari solusi ini adalah bahwa wadah digunakan untuk membuat dependensi jangka pendek, dan seharusnya hanya membuat dependensi jangka panjang. <br><br>  Untuk menghindari pelanggaran seperti itu, penulis wadah dapat sepenuhnya mengecualikan kemungkinan melewati wadah sebagai ketergantungan pada semua kelas terdaftar.  Tidak akan sulit untuk menerapkan ini, mengingat bahwa seluruh wadah bekerja dengan cara refleksi dan analisis parameter metode dan konstruktor untuk membuat dan tata letak grafik objek aplikasi. <br><br><h4>  Implementasi Metode </h4><br>  Logika implementasi Metode di Zenject adalah sebagai berikut: pertama, di semua kelas, konstruktor diimplementasikan, kemudian properti diimplementasikan, dan akhirnya metode diimplementasikan.  Pertimbangkan contoh implementasi yang disediakan dalam dokumentasi: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { [Inject] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBar bar, Qux qux</span></span></span><span class="hljs-function">)</span></span> { _bar = bar; _qux = qux; } }</code> </pre> <br>  Apa kerugiannya di sini: <br><br><ul><li>  Anda dapat menulis sejumlah metode yang akan diimplementasikan dalam kerangka kerja satu kelas.  Jadi, seperti halnya dengan implementasi properti, kami mendapatkan kesempatan untuk membuat sebanyak mungkin dependensi siklik. </li><li>  Seperti implementasi properti, implementasi metode diimplementasikan melalui atribut, yang mengaitkan kode Anda dengan kode wadah itu sendiri. </li><li>  Implementasi metode dalam Zenject hanya digunakan sebagai alternatif untuk konstruktor, yang nyaman dalam kasus kelas MonoBehavior, tetapi itu benar-benar bertentangan dengan teori yang dijelaskan oleh Mark Siman.  Contoh klasik dari penerapan metode kanonik dapat dianggap sebagai penggunaan pabrik (metode pabrik). </li><li>  Jika ada beberapa metode yang diperkenalkan di kelas, atau selain metode ada juga konstruktor, ternyata dependensi yang diperlukan untuk kelas akan tersebar di tempat yang berbeda, yang akan mengganggu gambar secara keseluruhan.  Yaitu, jika kelas 1 memiliki konstruktor, maka jumlah parameternya dapat dengan jelas menunjukkan apakah ada kesalahan desain di kelas dan apakah prinsip tanggung jawab tunggal dilanggar, dan jika dependensi tersebar dengan beberapa metode, oleh konstruktor, atau mungkin oleh beberapa properti, maka gambar tidak akan sejelas mungkin. </li></ul><br>  Oleh karena itu, keberadaan implementasi dari implementasi metode dalam wadah, yang bertentangan dengan teori DI, tidak memiliki nilai tambah tunggal.  Dengan peringatan besar, nilai tambah hanya dapat dianggap sebagai kemungkinan menggunakan metode yang diterapkan, sebagai konstruktor untuk MonoBehaviour.  Tapi ini adalah momen yang agak kontroversial, karena dari sudut pandang logika wadah, pola DI dan perangkat memori internal Unity3D, semua objek MonoBehaviour dalam aplikasi Anda dapat dianggap dikelola oleh sumber daya, dan dalam hal ini, akan jauh lebih efisien untuk mendelegasikan manajemen siklus hidup objek tersebut. bukan wadah DI, tetapi kelas pembantu (baik itu Pembungkus, ViewModel, Fasade, atau yang lainnya). <br><br><h4>  Binding global </h4><br>  Ini adalah fungsi tambahan yang cukup nyaman yang memungkinkan Anda untuk mengatur binder global yang dapat hidup terlepas dari transisi antar adegan.  Anda dapat membaca lebih lanjut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di dokumentasi</a> .  Fungsi ini sangat nyaman dan sangat berguna.  Perlu dicatat bahwa itu tidak melanggar pola dan prinsip DI, namun memiliki implementasi yang tidak jelas dan jelek.  Intinya adalah bahwa Anda membuat jenis cetakan khusus, melampirkan skrip dengan konfigurasi wadah (Pemasang) ke dalamnya dan menyimpannya dalam folder proyek yang ditentukan secara ketat, tanpa kemampuan untuk bergerak ke suatu tempat dan tanpa tautan ke sana.  Kerugian dari alat ini hanya terletak pada kesaksiannya.  Ketika datang ke installer biasa, semuanya cukup sederhana: Anda memiliki objek di atas panggung, skrip installer menggantung di atasnya.  Jika pengembang baru datang ke proyek, penginstal menjadi titik yang sangat baik untuk pencelupan dalam proyek.  Berdasarkan satu penginstal, pengembang dapat membuat ide tentang modul apa proyek terdiri dan bagaimana grafik objek dibangun.  Tetapi dengan penggunaan pengikat global, penginstal di atas panggung tidak lagi menjadi sumber informasi yang memadai.  Tidak ada satu pun tautan ke pengikatan global dalam kode penginstal lain (ada di layar) dan oleh karena itu, Anda tidak melihat grafik penuh objek.  Dan hanya selama analisis kelas Anda mengerti bahwa beberapa pengikat tidak cukup di installer di atas panggung.  Sekali lagi saya akan membuat reservasi bahwa kelemahan ini murni kosmetik. <br><br><h4>  Pengidentifikasi </h4><br>  Kemampuan untuk mengatur ikatan spesifik untuk pengidentifikasi untuk mendapatkan dependensi tertentu dari serangkaian dependensi serupa di kelas.  Contoh: <br><br><pre> <code class="cs hljs">Container.Bind&lt;IFoo&gt;().WithId(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>).To&lt;Foo1&gt;().AsSingle(); Container.Bind&lt;IFoo&gt;().To&lt;Foo2&gt;().AsSingle(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bar1</span></span> { [Inject(Id = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>)] IFoo _foo; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bar2</span></span> { [Inject] IFoo _foo; }</code> </pre> <br>  Fungsionalitas ini benar-benar bermanfaat secara situasi, dan menjadi opsi tambahan untuk implementasi properti.  Namun, seiring dengan kenyamanan, ia mewarisi semua masalah yang diidentifikasi di bagian "Menerapkan Properti", menambahkan lebih banyak koherensi pada kode dengan memperkenalkan konstanta tertentu yang perlu Anda ingat ketika mengkonfigurasi kode Anda.  Jika Anda secara tidak sengaja menghapus pengidentifikasi ini, Anda dapat dengan mudah mendapatkan yang tidak berfungsi dari aplikasi yang berfungsi. <br><br><h4>  Sinyal dan ITickable </h4><br>  Sinyal adalah analog dari mekanisme Agregator Acara yang dibangun di dalam wadah.  Gagasan menerapkan fungsi ini tidak diragukan lagi mulia, karena ditujukan untuk mengurangi jumlah koneksi antara objek yang berkomunikasi melalui mekanisme acara-berlangganan.  Contoh yang cukup banyak dapat ditemukan dalam <a href="">dokumentasi</a> , namun, itu tidak akan ada dalam artikel, karena implementasi spesifik tidak masalah. <br><br>  Dukungan untuk antarmuka ITickable - mengganti metode standar Perbarui, LateUpdate, dan FixedUpdate di Unity dengan mendelegasikan panggilan ke metode memperbarui objek dengan antarmuka ITickable ke wadah.  Contohnya juga dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> , dan implementasinya dalam konteks artikel juga tidak masalah. <br><br>  Masalah Sinyal dan ITickable tidak menyangkut aspek implementasi mereka, akarnya terletak pada penggunaan efek samping wadah.  Pada intinya, wadah tahu hampir semua kelas dan instans mereka dalam proyek, tetapi tanggung jawabnya adalah membuat grafik objek dan mengelola siklus hidup mereka.  Menambahkan mekanisme seperti Sinyal, ITickable, dan sebagainya, kami menambahkan lebih banyak tanggung jawab ke wadah, dan semakin banyak kami melampirkan kode aplikasi ke dalamnya, menjadikannya bagian eksklusif dan tak tergantikan dari kode, praktis "objek ilahi". <br><br><h3>  Alih-alih output </h3><br><blockquote>  Hal terpenting tentang wadah adalah untuk memahami bahwa penggunaan DI tidak tergantung pada penggunaan wadah DI.  Sebuah aplikasi dapat dibangun dari banyak kelas dan modul yang digabungkan secara longgar, dan tidak satu pun dari modul ini yang tahu apa-apa tentang wadah. </blockquote>  Hati-hati saat menggunakan solusi out-of-the-box (kotak) atau plugin kecil.  Gunakan dengan serius.  Memang, hal-hal yang lebih muluk yang Anda andalkan (misalnya, mesin game dari skala Unity3D itu sendiri) dapat berdosa dengan kesalahan dan noda teoretis seperti itu.  Dan ini, pada akhirnya, tidak akan memengaruhi pekerjaan solusi yang Anda gunakan, tetapi keberlanjutan, pekerjaan, dan kualitas produk akhir Anda.  Saya harap semua orang yang telah membaca sampai akhir, artikel ini akan bermanfaat atau, setidaknya, tidak akan menyesal atas waktu yang dihabiskan untuk membacanya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420235/">https://habr.com/ru/post/id420235/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420223/index.html">Beberapa tips sederhana: bagaimana mencegah kerusakan pada drone</a></li>
<li><a href="../id420225/index.html">Melodi Algoritmik Tak Terbatas Berdasarkan Bilangan Prima</a></li>
<li><a href="../id420227/index.html">Presiden Turki Mengumumkan Larangan Impor Elektronik AS</a></li>
<li><a href="../id420229/index.html">Dapatkah anak-anak di desa menjadi pemrogram jika di dekat mereka hanya mengajar pekerja kereta api. Percakapan dengan "Lingkaran"</a></li>
<li><a href="../id420233/index.html">UE4 | Peralatan untuk Multiplayer # 5 | Transfer informasi antara Server dan Klien</a></li>
<li><a href="../id420237/index.html">Qt wrapper di sekitar kerangka gRPC di C ++</a></li>
<li><a href="../id420239/index.html">Pengembangan ponsel. Swift: misteri protokol</a></li>
<li><a href="../id420243/index.html">Filantropi Terobosan: Proyek Terobosan Kemanusiaan</a></li>
<li><a href="../id420245/index.html">Bagaimana mencegah overrun memori saat menggunakan koleksi Java</a></li>
<li><a href="../id420251/index.html">Apple mengklaim kompleks kantor pusat perusahaan harganya hanya $ 200</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>