<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☑️ 🦅 🌗 Dentang-format memperlambat program 🙎🏽 🚱 🙋🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kita akan mengukur kinerja berbagai implementasi fungsi toupper, karena ini adalah apa yang mereka lakukan pada hari Selasa. 

 Sebenarnya, s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dentang-format memperlambat program</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/480012/">  Hari ini kita akan mengukur kinerja berbagai implementasi fungsi toupper, karena ini adalah apa yang mereka lakukan pada hari Selasa. <br><br>  Sebenarnya, saya tidak peduli dengan fungsi <a href="http://man7.org/linux/man-pages/man3/toupper.3.html"><i>toupper</i></a> , saya baru saja menulis posting lain baru-baru ini dan saya membutuhkan semacam inti plot yang umum, dan <i>toupper</i> tampaknya menjadi kandidat benchmark yang cukup menarik dan tidak berbahaya.  Saya mencoba untuk memilih sesuatu yang sesederhana mungkin yang tidak akan membuat saya kesamping, tetapi kebetulan dalam tes ini saya mengalami masalah yang aneh. <br><a name="habracut"></a><br>  Posting ini akan menjadi kecil - artikel yang lebih komprehensif tentang aslinya, mungkin topik yang lebih menarik segera diharapkan.  Jika Anda ingin mereproduksi hasil dengan saya, Anda <a href="https://github.com/travisdowns/toupper-bench">dapat mengambil</a> kode sumber <a href="https://github.com/travisdowns/toupper-bench">di github</a> . <br><br>  Jadi, kita akan mempertimbangkan tiga implementasi fungsi <i>toupper</i> , yang mengubah karakter array yang terdiri dari elemen tipe <i>char</i> ke huruf besar - yaitu, mengambil array sebagai argumen dan langsung mengubah elemen-elemennya sehingga semua huruf kecil dikapitalisasi. <br><br>  Dalam implementasi pertama, kita cukup memanggil <a href="https://linux.die.net/man/3/toupper">fungsi toupper</a> [1] <a href="https://linux.die.net/man/3/toupper">dari</a> pustaka standar C dan menjalankan loop gaya-C: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_rawloop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { buf[i] = <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>(buf[i]); } }</code> </pre> <br>  Dalam implementasi kedua, kami menggunakan pendekatan yang <a href="https://www.youtube.com/watch%3Fv%3D2olsGf6JIkU">lebih modern</a> dengan mengganti siklus mentah dengan <i>std :: transform</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(buf, buf + size, buf, ::<span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>); }</code> </pre> <br>  Akhirnya, dalam implementasi ketiga, kami menggunakan algoritma khusus yang berfungsi dengan karakter ASCII.  Ia memeriksa apakah karakter berada dalam kisaran <i>a - z</i> , dan jika berhasil, mengganti huruf yang sama dalam huruf besar, mengurangi angka 32 dari kode karakter [2]: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_branch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = buf[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt;= <span class="hljs-string"><span class="hljs-string">'a'</span></span> &amp;&amp; c &lt;= <span class="hljs-string"><span class="hljs-string">'z'</span></span>) { buf[i] = c - <span class="hljs-number"><span class="hljs-number">32</span></span>; } } }</code> </pre> <br>  Terlihat mudah, bukan? <br><br>  Sekarang kita akan mengukur kecepatan implementasi ini di laptop saya dengan prosesor Skylake i7-6700HQ pada kompiler gcc 5.5 dengan pengaturan default.  Hasilnya diberikan dalam bentuk grafik pencar [3]: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/ps/uf/ecpsuf8lfb6dcp2empyh6vqbkco.png"></div><br>  Kami akan segera menangani tiga pertanyaan yang tidak relevan dengan tugas kami. <br><br>  Pertama, lihat grafik algoritma percabangan (ditunjukkan dalam warna hijau).  Ini bervariasi secara signifikan tergantung pada ukuran data input - dua grafik lainnya tetap hampir datar.  Ini sebenarnya hanya artefak pengujian.  Input karakter ASCII dipilih secara acak [4], oleh karena itu, faktor penentu dalam kasus implementasi ketiga adalah pengoperasian algoritma prediksi cabang.  Dengan sejumlah kecil data, itu benar-benar menghafal urutan elemen saat iterasi dilakukan, sehingga jumlah kesalahan kecil dan kecepatan tinggi, <a href="https://lemire.me/blog/2019/10/16/benchmarking-is-hard-processors-learn-to-predict-branches/">seperti yang ditunjukkan dalam catatan ini</a> .  Ketika ukuran urutan data bertambah, algoritma prediksi mengingat semakin sedikit sampai akhirnya mulai hilang dengan setiap huruf kapital (0,27 meleset per karakter), dan kemudian grafik diratakan. <br><br>  Kedua, perhatikan kelompok bintik-bintik hijau di kiri atas, yang sesuai dengan kecepatan varian yang jauh lebih rendah dengan percabangan <i>toupper_branch</i> : <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/b6/kj/by/b6kjbygj9inzadobigp0txj3vxu.png"></div><br>  Ini bukan artefak yang terisolasi: bintik-bintik seperti itu muncul selama beberapa peluncuran.  Pada saat yang sama, mereka tidak dapat direproduksi jika Anda menguji algoritma hanya secara khusus pada ukuran data ini - mereka muncul hanya ketika tes dijalankan di semua ukuran.  Tetapi dalam kasus ini, mereka tidak selalu muncul.  Saya tidak secara khusus menyelidiki hal itu, tetapi saya dapat berasumsi bahwa ini adalah karena beberapa konflik nama atau alias dalam algoritma prediksi cabang atau ketika memetakan halaman fisik dari memori 4 KB ke virtual (meskipun pengacakan ruang alamat virtual dimatikan). <br><br>  Ketiga, implementasi <i>toupper_rawloop</i> (diperlihatkan dengan warna biru) pada grafik terlihat seperti dua baris terpisah: satu sedikit di atas tanda 2 langkah per karakter, dan yang lain pada tingkat 1,5 langkah per karakter.  Dua baris ini muncul di semua penguji.  Opsi yang lebih cepat, dengan kecepatan 1,57 karakter per siklus, sebenarnya melambat pada port unduhan: membaca data pada port 2 dan 3 terjadi pada kecepatan 1,54 operasi mikro per siklus, sehingga mereka akan sibuk 98%.  Saya tidak bisa menetapkan alasan untuk “rezim” yang lebih lambat. <br><br>  Ketika saya sedang berurusan dengan masalah ini, "rezim" yang cepat tiba-tiba menghilang dan hanya lambat yang tersisa.  Mungkin prosesor menyadari apa yang saya coba lakukan dan diam-diam mengunduh pembaruan untuk kode mikro untuk menghapus kontradiksi, tetapi saya (masih) punya bukti - gambar vektor dengan grafik. <br><br>  Lalu apa yang menarik bagi kita dalam contoh ini? <br><br>  Tetapi yang menarik bagi kami adalah bahwa versi dengan siklus mentah adalah 3-4 kali lebih cepat daripada versi dengan <i>std :: transform</i> : 1,5-2 siklus per karakter dibandingkan 7 dengan beberapa siklus per karakter. <br><br>  Ada apa di sini?  Apakah algoritma standar gagal saya?  Apakah <i>std :: transform</i> memiliki kekurangan? <br><br>  Tidak juga.  Lebih tepatnya, tidak sama sekali. <br><br>  Ternyata hasil tersebut muncul ketika fungsi dikompilasi dalam <a href="">file yang berbeda</a> .  Jika Anda meletakkannya di file yang sama, maka kinerjanya menjadi sama rendahnya. <br><br>  Dan tidak, keberpihakan tidak ada hubungannya dengan itu. <br><br>  Tapi itu tidak semua: versi cepat dengan siklus mentah, ketika dikompilasi dalam file terpisah, melambat jika Anda cukup melampirkan file header <i>&lt;algorithm&gt;</i> ke dalamnya.  Ya, itu benar: cukup sambungkan file ini, yang tidak pernah digunakan dan tidak menghasilkan kode apa pun dalam file objek akhir, dan kecepatan siklus "mentah" akan turun 3-4 kali.  Sebaliknya, versi dengan <i>std :: transform</i> dipercepat hingga batasnya jika Anda menyalin dan menempel implementasi <i>std :: transform</i> dari file <i>&lt;algorithm&gt;</i> , tetapi tidak menyertakan file ini. <br><br>  Keanehan tidak berakhir di sana (tidak akan ada lagi, saya janji): termasuk file <i>&lt;algorithm&gt;</i> tidak selalu mengarah ke efek yang dijelaskan.  Penurunan kecepatan terjadi jika <i>&lt;algorithm&gt;</i> terhubung lebih awal dari <i>&lt;ctype.h&gt;</i> , tetapi jika Anda menukar mereka, maka tidak ada: <br><br>  <b>Kode lambat:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;algorithm&gt; #include &lt;ctype.h&gt;</span></span></span></span></code> </pre> <br>  <b>Kode cepat:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ctype.h&gt; #include &lt;algorithm&gt;</span></span></span></span></code> </pre> <br>  Sebenarnya, anomali ini muncul dalam diri saya (dalam proyek lain) ketika dentang-format secara otomatis mengurutkan file header yang disertakan dan menempatkan <i>&lt;algorithm&gt;</i> di bagian paling awal daftar, di mana ia berada (maka header clickbait artikel). <br><br>  Tentu, cepat atau lambat kita harus masuk ke daftar assembler.  Kami tidak akan menunda momen tidak menyenangkan ini. <br><br>  Versi fungsi <a href="https://godbolt.org/z/DwZBJM">cepat dan lambat</a> [5] ditunjukkan di bawah ini, loop kecil disediakan dengan anotasi: <br><br>  <b>&lt;algorithm&gt; terhubung terlebih dahulu:</b> <br><br><pre> <code class="cpp hljs">toupper_rawloop(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): push rbp push rbx lea rbp, [rdi+rsi] sub rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> test rsi, rsi je .L1 mov rbx, rdi .L5: movsx edi, BYTE PTR [rbx] ;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>-  *buf add rbx, <span class="hljs-number"><span class="hljs-number">1</span></span> ; buf++ call <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> ;  <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>(c) mov BYTE PTR [rbx<span class="hljs-number"><span class="hljs-number">-1</span></span>], al ;    buf[<span class="hljs-number"><span class="hljs-number">-1</span></span>] cmp rbp, rbx ;  buf == buf_end jne .L5 ; .L1: add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> pop rbx pop rbp ret</code> </pre> <br>  <b>&lt;algorithm&gt; terhubung kedua:</b> <br><br><pre> <code class="cpp hljs">toupper_rawloop(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): test rsi, rsi je .L7 push rbp push rbx mov rbp, rsi mov rbx, rdi sub rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> call __ctype_toupper_loc lea rsi, [rbx+rbp] mov rdi, rbx .L4: ;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>-  buf movsx rcx, BYTE PTR [rdi] ;      <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> ; (   __ctype_toupper_loc) mov rdx, QWORD PTR [rax] ; buf++ add rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>  , ;       mov edx, DWORD PTR [rdx+rcx*<span class="hljs-number"><span class="hljs-number">4</span></span>] mov BYTE PTR [rdi<span class="hljs-number"><span class="hljs-number">-1</span></span>], dl ;   cmp rsi, rdi ;  buf == end_buf jne .L4 ; add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> pop rbx pop rbp .L7: rep ret</code> </pre> <br>  Perbedaan utama adalah bahwa dalam versi lambat fungsi toupper hanya dipanggil dalam satu lingkaran, sedangkan dalam versi cepat tidak ada panggilan fungsi sama sekali, dan hanya ada pencarian di tabel korespondensi [6], yaitu  tubuh fungsi <i>std :: toupper</i> diganti di tempat panggilan. <br><br>  Jika Anda melihat <a href="https://sourceware.org/git/%3Fp%3Dglibc.git%3Ba%3Dblob%3Bf%3Dctype/ctype.h%3Bh%3Dd17f727cf0dc2a0f6c62fa50aff799b175dcb426%3Bhb%3D2a764c6ee848dfe92cb2921ed3b14085f15d9e79">kode sumber</a> pustaka glibc, kami menemukan implementasi fungsi <i>toupper di</i> sana: <br><br><pre> <code class="cpp hljs">__extern_inline <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// __NTH –  , ,      __NTH (toupper (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_toupper_loc ())[__c] : __c; }</span></span></code> </pre> <br>  Seperti yang dapat kita lihat, <i>toupper</i> didefinisikan sebagai fungsi <i>inline eksternal</i> yang pertama kali memeriksa bahwa ukuran karakter char cocok dalam satu byte [7], dan kemudian mencari karakter dalam tabel korespondensi yang dikembalikan oleh fungsi <i>__ctype_toupper_loc ()</i> .  Fungsi ini mengembalikan pointer aliran lokal (dari tipe <i>const int **</i> ), yang, pada gilirannya, menunjuk ke tabel korespondensi, dari mana, sebagai tanggapan atas permintaan simbol kami, versi huruf besarnya dikembalikan [8]. <br><br>  Sekarang jelas apa yang terjadi dalam daftar.  Dalam versi cepat dari algoritma, kompiler menggantikan tubuh fungsi <i>toupper</i> , tetapi tidak dapat menggantikan panggilan ke fungsi <i>__ctype_toupper_loc ()</i> [9].  Panggilan ini, bagaimanapun, dinyatakan sebagai <i>__attribute __ ((const))</i> , yang berarti bahwa nilai kembali hanya bergantung pada argumen (yang tidak ada di sini).  Kompiler tahu bahwa fungsi ini mengembalikan nilai yang sama setiap kali, dan karenanya mengambil panggilannya di luar loop, dan dalam loop itu sendiri hanya ada beberapa operasi baca yang terkait dengan mengakses tabel korespondensi, menulis nilai baru ke buffer, dan kontrol loop. <br><br>  Dalam versi lambat, panggilan ke <i>toupper ()</i> tetap di tubuh loop.  Loop itu sendiri lebih pendek dengan satu perintah, tetapi, tentu saja, sekarang Anda masih harus menjalankan semua kode di dalam fungsi <i>toupper</i> .  Di sistem saya, tampilannya seperti ini: <br><br><pre> <code class="cpp hljs"> lea edx,[rdi+<span class="hljs-number"><span class="hljs-number">0x80</span></span>] ; edx = rdi + <span class="hljs-number"><span class="hljs-number">0x80</span></span> movsxd rax,edi ;    c cmp edx,<span class="hljs-number"><span class="hljs-number">0x17f</span></span> ; ,  c     <span class="hljs-number"><span class="hljs-number">-128</span></span>  <span class="hljs-number"><span class="hljs-number">255</span></span> ja <span class="hljs-number"><span class="hljs-number">2</span></span>a ;  ,   mov rdx,QWORD PTR [rip+<span class="hljs-number"><span class="hljs-number">0x395f30</span></span>] ;    ;   mov rdx,QWORD PTR fs:[rdx] ;     ;     mov rdx,QWORD PTR [rdx] ;    ;    mov rdx,QWORD PTR [rdx+<span class="hljs-number"><span class="hljs-number">0x48</span></span>] ;     <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> mov eax,DWORD PTR [rdx+rax*<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">0x200</span></span>] ;  c   <span class="hljs-number"><span class="hljs-number">2</span></span>a: ret</code> </pre> <br>  Karena ini adalah panggilan yang tidak tertanam, program ini bekerja lebih banyak.  Setidaknya ada lima operasi berturut-turut mengakses memori (yang disebut pengejaran pointer, <i>pengejaran pointer</i> ).  Dalam versi cepat, hanya dua yang tersisa, karena yang lainnya dikeluarkan dari loop.  Penundaan antara memanggil suatu fungsi dan keluar darinya seharusnya sekitar 25 siklus, dan kami memiliki sekitar 7 siklus yang keluar - ini berarti bahwa prosesor mampu memaralelkan panggilan, yang cukup baik, mengingat keadaan. <br><br>  Kenapa begitu? <br><br>  Dalam rantai panjang file sertakan, file header C ++, seperti <i>&lt;algorithm&gt;</i> , termasuk, pada gilirannya, file <i>&lt;bits / os_defines.h&gt;</i> , yang berisi baris berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      isanum  .  //   . #define __NO_CTYPE 1</span></span></code> </pre> <br>  Ketika file <i>&lt;ctype.h&gt;</i> akhirnya terhubung, karena arahan ini, kode di mana <i>toupper</i> didefinisikan sebagai <i>extern inline</i> tidak dapat dimasukkan: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined __NO_CTYPE # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __isctype_f __isctype_f (alnum) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  ..  .. __isctype_f (xdigit) # elif defined __isctype # define isalnum(c) __isctype((c), _ISalnum) # define isalpha(c) __isctype((c), _ISalpha) //  ..  .. # endif //      # ifdef __USE_EXTERN_INLINES __extern_inline int __NTH (tolower (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_tolower_loc ())[__c] : __c; } __extern_inline int __NTH (toupper (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_toupper_loc ())[__c] : __c; } # endif //   tolower     # if __GNUC__ &gt;= 2 &amp;&amp; defined __OPTIMIZE__ &amp;&amp; !defined __cplusplus # define tolower(c) __tobody (c, tolower, *__ctype_tolower_loc (), (c)) # define toupper(c) __tobody (c, toupper, *__ctype_toupper_loc (), (c)) # endif /* Optimizing gcc */ #endif /* Not __NO_CTYPE. */</span></span></span></span></code> </pre> <br>  Harap perhatikan bahwa ketika menghubungkan <i>&lt;ctype.h&gt; versi</i> C ++ dari <i>toupper</i> tidak pernah didefinisikan sebagai makro - maksimum sebagai <i>extern</i> <i>inline</i> - karena definisi makro dilindungi oleh pemeriksaan <i>! Defined __cplusplus</i> dan karenanya tidak akan pernah berlaku. <br><br>  Secara umum, saya tidak tahu pasti apakah <i>__NO_CTYPE</i> dalam kasus ini harus mengecualikan tubuh fungsi <i>tolower</i> dan <i>toupper yang</i> dinyatakan sebagai <i>eksternal inline</i> , tetapi inilah yang sebenarnya terjadi - dan karenanya merupakan penurunan signifikan dalam kecepatan siklus kami.  Sebagai kesimpulan, saya dapat mengatakan bahwa jika Anda memasukkan <i>&lt;cctype&gt;</i> alih-alih <i>&lt;ctype.h&gt;</i> (mis., C ++ adalah versi file header C yang menempatkan fungsi di <i>std :: namespace</i> ), maka dalam hal ini kode akan bekerja lambat karena <i>&lt;cctype&gt;</i> akhirnya termasuk <i>&lt;bits / os_defines.h&gt;</i> . <br><br>  Apakah semua itu penting?  Tidak, tidak <br><br>  Fungsi <i>toupper</i> tidak cocok untuk pekerjaan serius dengan karakter bahasa yang berbeda, jadi jika Anda hanya perlu memproses karakter ASCII, Anda dapat menulis implementasi yang lebih cepat.  Jika Anda memerlukan pekerjaan serius dengan teks, maka kemungkinan besar Anda akan menggunakan UTF-8 dan harus menggunakan semacam ICU untuk mendukung pengaturan regional, atau menunggu hingga dukungan Unicode muncul di C ++ (mungkin perlu waktu lama untuk menunggu) .  Jadi pernyataan "format dentang dapat menyebabkan penurunan kinerja 4x" hanya cocok sebagai header clickbait. <br><br>  Apakah efek ini diamati di semua versi libc?  Ya, di hampir semua, tetapi bahkan di sini tidak sesederhana itu. <br><br>  Hasil yang ditunjukkan di atas berlaku untuk gcc 5.5 dan glibc 2.23, karena saya menggunakan versi ini, tetapi sesuatu yang baru terjadi di versi baru (mulai dari tentang glibc 2.27).  Di sana, menyalakan <i>&lt;algorithm&gt;</i> sebelum <i>&lt;ctype.h&gt;</i> masih memberikan efek yang sama, tetapi sekarang <i>&lt;stdlib.h&gt;</i> [10] juga menciptakan masalah: jika Anda menyalakannya sebelum <i>&lt;ctype.h&gt;</i> , kinerja juga akan turun, yang tidak diamati pada versi sebelumnya.  Jelas, dalam versi yang lebih baru, file <i>&lt;stdlib.h&gt;</i> juga mengandung definisi <i>__NO_CTYPE</i> .  Setidaknya, sekarang tidak mungkin menyalahkan format dentang untuk penyortiran - ini hanya dapat membantu menyelesaikan masalah (jika tidak ada file masalah lain dalam daftar file yang terhubung). <br><br>  Saya memposting <a href="https://sourceware.org/bugzilla/show_bug.cgi%3Fid%3D25214">laporan bug di libc</a> , sehingga kemungkinan bug ini akan diperbaiki, tetapi tidak ada keraguan bahwa kesalahan terkait dengan urutan di mana file header terhubung akan mengganggu kita lebih lanjut. <br><br><h2>  Komentar </h2><br>  Saya tidak memiliki sistem komentar di situs saya, tetapi saya sedang mengusahakannya (yaitu, secara berkala mengeluh bahwa sulit untuk membuat komentar di situs statis). <br><br>  Sementara itu, Anda dapat mendiskusikan artikel ini di situs web <a href="https://news.ycombinator.com/item%3Fid%3D21579333">Hacker News</a> atau <a href="https://lobste.rs/s/tjxzck/clang_format_tanks_performance">lobste.rs</a> . <br><br><h2>  Ucapan Terima Kasih </h2><br>  Terima kasih kepada pengguna ufo dengan Hacker News, yang <a href="https://news.ycombinator.com/item%3Fid%3D21579483">menunjukkan</a> bahwa tidak perlu menggunakan fungsi lambda untuk mengadaptasi <i>std :: toupper</i> untuk digunakan dalam <i>std :: transform</i> , dan juga kepada Jonathan Muller yang <a href="https://twitter.com/foonathan/status/1197051249822195712">menjelaskan</a> bahwa fungsi lambda masih diperlukan. <br><br><ol><li>  Ya, fungsi <i>toupper (3)</i> dari file header <i>&lt;ctype.h&gt;</i> tidak cocok untuk bekerja dengan sebagian besar karakter non-ASCII, karena  tidak dapat menangani karakter yang lebih besar dari satu byte, tetapi cocok untuk tugas kami, karena kami hanya akan meneruskan string karakter ASCII ke dalamnya. </li><li>  Dalam tabel ASCII, karakter huruf kecil dan huruf besar sangat mudah ditemukan - pada jarak 32 posisi dari satu sama lain, yang berarti bahwa Anda dapat mentransfer karakter dari satu kasus ke yang lain hanya dengan mengurangi atau menambahkan 32. Secara umum, jika kita tahu pasti bahwa semua input datanya adalah huruf ASCII, kita dapat mereset bit ke-5 tanpa pemeriksaan (misalnya, <i>c &amp; 0b11011111</i> ) untuk mengubah huruf besar menjadi huruf kecil, sementara ini tidak akan tercermin dalam huruf kecil.  Tapi kami mungkin tidak tahu, jadi kami harus memeriksa apakah karakternya adalah huruf, agar tidak secara tidak sengaja memecah karakter non-huruf seperti <i>char</i> . </li><li>  Itu harus disebut sebaran plot dengan penambahan "noise" ke lokasi poin.  Sebenarnya, ini adalah diagram sebar biasa di mana parameter yang menarik bagi kami (ukuran data input) diplot pada sumbu x, dan kecepatan kerja pada sumbu y (mengukur per simbol - <i>semakin rendah nilainya, semakin tinggi kecepatan</i> ).  Fitur utama diagram ini adalah bahwa untuk setiap nilai parameter pada sumbu x, pengambilan sampel dilakukan beberapa kali: dalam kasus ini, pengujian diulang 10 kali untuk setiap ukuran array. </li><li>  Yaitu, karakter dipilih secara acak dan seragam dari kisaran [32, 127], sehingga kondisi dalam fungsi akan benar di sekitar 27% kasus. </li><li>  Kedua daftar merujuk pada implementasi siklus mentah dan hanya berbeda dalam urutan di mana file <i>&lt;algorithm&gt;</i> dan <i>&lt;ctype.h&gt; dimasukkan</i> .  Kode sumber yang dihasilkan sama untuk semua implementasi - baik dalam versi cepat dan lambat.  Misalnya, implementasi dengan <i>std :: transform</i> akan menghasilkan kode assembler lambat yang sama jika Anda menyertakan file <i>&lt;algorithm&gt;</i> , dan kode cepat yang sama jika Anda hanya menyalin definisi fungsi dan tidak menyertakan file. </li><li>  Namun, loop cepat ini lebih lambat daripada yang bisa karena pointer ke tabel korespondensi dibaca terlalu banyak ( <i>mov rdx, QWORD PTR [rax]</i> ) di dalam loop.  Pointer ini mungkin berbeda tergantung pada pengaturan regional, tetapi tidak diperbarui selama pelaksanaan siklus dan oleh karena itu dapat dipindahkan di luar siklus.  Pasti kompiler percaya bahwa tidak ada alasan yang cukup untuk ini, karena kita menulis ke array elemen tipe <i>char</i> , dan mereka pada prinsipnya dapat digunakan sebagai alias untuk <i>[rax]</i> yaitu  arahkan ke tabel.  Bagaimanapun, bahkan <i>__restrict__</i> tidak akan membantu di sini.  Tetapi dalam versi lain dari loop, di mana nilai <i>toupper</i> hanya ditambahkan dan tidak ada yang ditulis ke array, <a href="https://godbolt.org/z/Kb6pc8">optimasi ini diterapkan</a> - pointer dibaca di luar loop. </li><li>  Pemeriksaan ini tidak tercermin dalam kode assembler yang dapat disubstitusikan, karena kompiler sudah tahu bahwa nilai-nilai <i>char</i> selalu dalam kisaran <i>[-128, 255]</i> .  Pemeriksaan ini diperlukan hanya karena API fungsi <i>toupper ©</i> menerima nilai dari tipe <i>int</i> , bukan <i>char</i> , sehingga pengguna dapat memberikan jumlah tipe <i>int yang</i> dikenalinya, sementara tabel korespondensi dirancang hanya untuk nilai-nilai tipe <i>char</i> , jadi memeriksa membantu menghindari pembacaan di luar buffer . </li><li>  Ngomong-ngomong, ini menjelaskan mengapa prosedur <i>std :: toupper</i> tidak tergantung pada ukuran data input: mereka tidak menggunakan cabang (kecuali untuk pemeriksaan jangkauan, yang sangat diprediksi), tetapi menggunakan tabel korespondensi independen cabang.  <a href="https://habr.com/ru/company/pvs-studio/blog/480012/">↵</a> </li><li>  Mengganti panggilan ini tidak akan berfungsi bahkan dengan keinginan yang sangat kuat: isi fungsi tidak tersedia di file header. </li><li>  Saya sama sekali tidak menemukan kesalahan dengan <i>stdlib.h</i> (atau <i>&lt;algorithm&gt;</i> , dalam hal ini) - sangat mungkin bahwa banyak file header C lainnya dan semua file header C ++ juga menyebabkan perilaku ini, saya hanya tidak mengujinya.  Saya menghubungkan <i>stdlib.h</i> hanya untuk menentukan <i>size_t</i> . </li></ol><br>  <b>Catatan</b>  Artikel ini pertama kali dipublikasikan di situs web <a href="https://travisdowns.github.io/blog/2019/11/19/toupper.html">Performance Matters</a> .  Artikel yang diterjemahkan diposting di sini dengan izin dari penulis. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480012/">https://habr.com/ru/post/id480012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480000/index.html">Indikator kualitas saluran Server WebRTC melalui TCP</a></li>
<li><a href="../id480002/index.html">Tinjau DevOpsDays Moscow: wawasan dari 6 laporan</a></li>
<li><a href="../id480006/index.html">Indikator kualitas saluran untuk server WebRTC melalui TCP</a></li>
<li><a href="../id480008/index.html">Yuri Rogachev: "Saya datang untuk melakukan M-1, tidak tahu teknologi komputer"</a></li>
<li><a href="../id480010/index.html">3 Elemen HTML Teratas yang Kami Lupa</a></li>
<li><a href="../id480016/index.html">39% dari perusahaan SMB Rusia menghadapi serangan cyber yang ditargetkan</a></li>
<li><a href="../id480018/index.html">Pengembangan aplikasi seluler dengan Python. Perpustakaan KivyMD</a></li>
<li><a href="../id480022/index.html">Instansiasi python</a></li>
<li><a href="../id480024/index.html">Periwinkle: prosesor instruksi tunggal</a></li>
<li><a href="../id480026/index.html">Mengumumkan pratinjau Mesin Virtual Azure Spot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>