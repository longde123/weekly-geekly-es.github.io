<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèø ‚òùüèª üìø Comment acc√©l√©rer le travail avec l'API R-language en utilisant le calcul parall√®le, en utilisant l'exemple d'API Yandex.Direct (Partie 2) üòø üôèüèΩ üíÖüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans le dernier article, j'ai parl√© de ce qu'est le multithreading et donn√© des exemples de son impl√©mentation dans le langage R lors de l'utilisation...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment acc√©l√©rer le travail avec l'API R-language en utilisant le calcul parall√®le, en utilisant l'exemple d'API Yandex.Direct (Partie 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448404/"><p> Dans le dernier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article,</a> j'ai parl√© de ce qu'est le multithreading et donn√© des exemples de son impl√©mentation dans le langage R lors de l'utilisation de l'API Yandex.Direct en utilisant les <code>doSNOW</code> , <code>doParallel</code> et la construction <code>foreach</code> . </p><br><p>  Cet article est une continuation, mais peut √™tre consid√©r√© comme un guide hors ligne du multithreading dans R. J'ai √©t√© invit√© √† l'√©crire par les commentaires re√ßus dans la premi√®re partie (ici un merci sp√©cial √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Alexey_mosc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">SatCat</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Ananiev_Genrih</a> ), dans lequel on m'a donn√© un certain nombre de packages qui repr√©sentent une approche plus moderne de les impl√©mentations du multithreading dans R, nous en parlerons plus tard. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/302/1a1/570/3021a15709dae984b328e3af5364d1de.png" alt="Multithreading"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Table des mati√®res </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©fi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La pr√©paration</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemple de solution de traitement en s√©rie, fonction sapply et package purrr</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonction Sapply</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Forfait Purrr</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Options multithread pour r√©soudre la t√¢che de collecte de mots cl√©s √† partir de Yandex.Direct</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Paquet parall√®le</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Forfait futur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wrappers sur l'avenir</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Package Future.apply</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Forfait Furrr</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test de vitesse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusion</a> </li><li>  Sondage </li></ul><br><h1 id="zadacha">  D√©fi </h1><br><p>  √Ä titre d'exemple, nous prenons le probl√®me consid√©r√© dans une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publication pr√©c√©dente</a> , √† savoir  en mode multi-thread, collectez une liste de mots cl√©s √† partir de 4 comptes publicitaires Yandex.Direct. </p><br><p>  Pour travailler avec l'API Yandex.Direct, nous utiliserons le package <code>ryandexdirect</code> .  La documentation officielle pour cela est sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> , mais pour la mise en ≈ìuvre de la t√¢che d√©crite, nous n'avons besoin que de 2 fonctions: </p><br><ul><li>  <code>yadirAuth</code> - autorisation dans l'API Yandex.Direct; </li><li>  <code>yadirGetKeyWords</code> - T√©l√©chargez une liste de mots cl√©s √† partir des comptes publicitaires. </li></ul><br><p>  Ce n'est pas seulement que j'ai choisi le processus de t√©l√©chargement des mots-cl√©s, le fait est que c'est l'une des op√©rations les plus longues de l'API Yandex.Direct.  Deuxi√®mement, dans tous les comptes, le nombre de mots-cl√©s est diff√©rent, par cons√©quent, le temps pour terminer cette op√©ration pour chaque compte sera tr√®s diff√©rent, dans notre cas de 1 √† 20 secondes. </p><br><h1 id="podgotovka">  La pr√©paration </h1><br><p>  Au d√©part, vous devez installer tous les packages d√©crits dans cet article, pour cela, vous pouvez utiliser le code ci-dessous. </p><br><div class="spoiler">  <b class="spoiler_title">Code 1: installation de packages</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#    install.packages("ryandexdirect") install.packages("tictoc") install.packages("rbenchmark") install.packages("dplyr") install.packages("purrr") install.packages("future") install.packages("promises") install.packages("furrr") install.packages("future.apply")</code> </pre> </div></div><br><p>  Pour que les fonctions du package soient disponibles, vous devez le connecter √† l'aide de la commande de <code>library</code> .  Pour plus de commodit√©, je connecterai s√©par√©ment tous les packages n√©cessaires dans chaque exemple de code donn√©. </p><br><p>  Nous cr√©ons un vecteur compos√© de connexions Yandex.Direct, √† partir desquelles nous demanderons plus tard des mots cl√©s: </p><br><div class="spoiler">  <b class="spoiler_title">Code 2: cr√©ation d'un vecteur de connexion</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">logins &lt;- c("login1", "login2", "login3", "login4")</code> </pre> </div></div><br><p>  Pour travailler avec l'API Yandex.Direct, vous devez d'abord passer par une autorisation sous chaque compte, pour cela, vous pouvez utiliser la conception suivante: </p><br><div class="spoiler">  <b class="spoiler_title">Code 3: autorisation dans l'API Yandex.Direct</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">lapply(logins, function(l) { yadirAuth(Login = l)})</code> </pre> </div></div><br><p>  Apr√®s avoir ex√©cut√© le code ci-dessus, un navigateur s'ouvrira pour autorisation sous chaque compte.  Vous confirmez l'autorisation pour <code>ryandexdirect</code> d'acc√©der √† votre mat√©riel publicitaire.  Vous serez redirig√© vers la page o√π vous devez copier le code de v√©rification.  En l'entrant dans la console R, terminez le processus d'autorisation.  Cette op√©ration est r√©p√©t√©e pour chaque connexion que vous avez sp√©cifi√©e lors de la cr√©ation des connexions vectorielles. </p><br><p>  Certains utilisateurs, au cours du processus d'autorisation, peuvent √™tre d√©rout√©s par le fait d'une redirection vers une ressource tierce, mais il n'y a aucun danger pour votre compte √† ce sujet, j'ai d√©crit ce sujet plus en d√©tail dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"√Ä quel point il est s√ªr d'utiliser des packages R pour travailler avec des API de syst√®mes publicitaires"</a> . </p><br><p>  Ensuite, nous consid√©rerons plusieurs exemples de mise en ≈ìuvre de la t√¢che d√©crite.  Chacun commencera par un exemple de code et son explication suppl√©mentaire.  Je pense que cette option sera la plus pratique pour la perception. </p><br><h1 id="primer-resheniya-v-posledovatelnom-rezhime-obrabotki-funkciya-sapply-i-paket-purrr">  Exemple de solution de traitement en s√©rie, fonction sapply et package purrr </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/369/72e/9d8/36972e9d8707c1c508d2e43b8721778c.jpg"><br>  Dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dernier article</a> , j'ai donn√© un exemple en utilisant une boucle <code>for</code> comme exemple.  Puisque nous avons envisag√© le multithreading en utilisant le package <code>foreach</code> , dont la syntaxe ressemble √† des boucles, cet exemple √©tait appropri√© ici, bien que l'utilisation de boucles ne soit pas bien accueillie par les utilisateurs de R. </p><br><p>  Les packages que nous consid√©rerons dans cet article rappellent davantage les fonctions de la famille apply dans la syntaxe; je vais donc donner un exemple de solution en mode s√©rie en les utilisant. </p><br><h3 id="funkciya-sapply">  Fonction <code>sapply</code> </h3><br><blockquote>  Pour estimer le temps d'ex√©cution des commandes, dans chacune des approches consid√©r√©es, nous utiliserons le package <code>tictoc</code> . </blockquote><br><div class="spoiler">  <b class="spoiler_title">Code 4: Exemple de solution en mode s√©quentiel utilisant la fonction sapply</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(tictoc) library(dplyr) tic() #   kw.sapply &lt;- sapply( logins, #  ,     function(x) #        #     { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE #     ) toc() #   #       result.sapply &lt;- do.call("rbind", kw.sapply)</code> </pre> </div></div><br><p>  <code>39.36 sec elapsed</code> : <code>39.36 sec elapsed</code> </p><br><p>  Au d√©but, la syntaxe des fonctions de la famille <code>apply</code> n'est pas aussi facile √† lire que la syntaxe des boucles, mais en fait tout est assez simple. </p><br><p> <code>sapply(X, FUN)</code> </p> <br><p>  O√π: </p><br><ul><li>  <em>X</em> - Un objet dont nous allons parcourir les √©l√©ments et les utiliser tour √† tour √† chaque it√©ration, dans une boucle <code>for</code> il ressemblait √† ceci: <code>for(i in X)</code> ; </li><li>  <em>FUN</em> - Une fonction dans laquelle nous substituerons chaque √©l√©ment de l'objet <em>X</em> √† son tour, si nous faisons une analogie avec <code>for</code> , c'est le corps de la boucle. </li></ul><br><p>  Dans l'exemple de <strong>code 4</strong> , le vecteur de <em>connexion</em> cr√©√© pr√©c√©demment est pass√© √† l'argument <em>X.</em>  Chaque √©l√©ment du vecteur de <em>connexion</em> est transmis √† son tour comme seul argument √† la fonction de <code>function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }</code> anonyme <code>function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }</code> qui a √©t√© transmise √† l'argument <em>FUN</em> . </p><br><p>  C'est-√†-dire  <code>sapply</code> ex√©cutera la fonction sp√©cifi√©e dans <em>FUN</em> 4 fois, en y substituant les connexions une par une, et renverra le r√©sultat sous la forme d'une liste (objet de <em>liste</em> de classe) compos√©e de 4 √©l√©ments.  Chaque √©l√©ment est un tableau avec une liste de mots cl√©s re√ßus du compte √† chaque it√©ration. </p><br><ol><li> <code>yadirGetKeyWords(Login = "login1") %&gt;% mutate(login = "login1")</code> </li> <li> <code>yadirGetKeyWords(Login = "login2") %&gt;% mutate(login = "login2")</code> </li> <li> <code>yadirGetKeyWords(Login = "login3") %&gt;% mutate(login = "login3")</code> </li> <li> <code>yadirGetKeyWords(Login = "login4") %&gt;% mutate(login = "login4")</code> </li> </ol><br><p>  L'objet obtenu √† l'aide de <code>sapply</code> a la structure suivante: </p><br><pre> <code class="plaintext hljs">summary(kw.sapply)</code> </pre> <br><pre> <code class="plaintext hljs"> Length Class Mode login1 19 data.frame list login2 19 data.frame list login3 19 data.frame list login4 19 data.frame list</code> </pre> <br><p>  √Ä la fin de cet exemple, la commande <code>result.sapply &lt;- do.call("rbind", kw.sapply)</code> combine les 4 √©l√©ments de la liste <em>kw.sapply</em> en un <em>seul</em> cadre <em>result.sapply</em> . </p><br><pre> <code class="plaintext hljs"># A tibble: 6,804 x 1 result.sapply$Id $Keyword $AdGroupId $CampaignId $ServingStatus $State &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; 1 15164230566 ~ 3597453985 39351725 ELIGIBLE ON 2 15164230567  ~ 3597453985 39351725 ELIGIBLE ON 3 15164230568  ~ 3597453985 39351725 ELIGIBLE ON 4 15164230569 ~ 3597453985 39351725 ELIGIBLE ON 5 15164230570 ~ 3597453985 39351725 ELIGIBLE ON 6 15164230571  ~ 3597453985 39351725 ELIGIBLE ON 7 15164230572 ~ 3597453985 39351725 ELIGIBLE ON 8 15164230573  ~ 3597453985 39351725 ELIGIBLE ON 9 15164230574 ~ 3597453985 39351725 ELIGIBLE ON 10 15164230575 ~ 3597453985 39351725 ELIGIBLE ON # ... with 6,794 more rows, and 13 more variables: $Status &lt;fct&gt;, # $StrategyPriority &lt;fct&gt;, $StatisticsSearchImpressions &lt;int&gt;, # $StatisticsSearchClicks &lt;int&gt;, $StatisticsNetworkImpressions &lt;int&gt;, # $StatisticsNetworkClicks &lt;lgl&gt;, $UserParam1 &lt;chr&gt;, $UserParam2 &lt;chr&gt;, # $ProductivityValue &lt;lgl&gt;, $ProductivityReferences &lt;lgl&gt;, $Bid &lt;dbl&gt;, # $ContextBid &lt;dbl&gt;, $login &lt;chr&gt;</code> </pre> <br><p>  En plus de <code>sapply</code> , la famille de fonctions <code>*apply</code> comprend: <code>apply</code> , <code>lapply</code> , <code>vapply</code> , <code>mapply</code> et autres. </p><br><h3 id="paket-purrr">  Forfait <code>purrr</code> </h3><br><div class="spoiler">  <b class="spoiler_title">Code 5: Exemple de solution utilisant les fonctions du package purrr</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) library(dplyr) library(tictoc) tic() #   result.purrr &lt;- map_df( logins, #  ,     ~ #   function(.x) { yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x) } ) toc() #  </code> </pre> </div></div><br><p>  <code>35.46 sec elapsed</code> : <code>35.46 sec elapsed</code> </p><br><p>  Le paquet <code>purrr</code> fait partie du noyau de la biblioth√®que <code>tidyverse</code> , cr√©√©e par Headley Wickham. </p><br><p>  En termes de sens et de syntaxe, les principales fonctions du package sont tr√®s similaires √† <code>sapply</code> , son principal avantage est le suivant: </p><br><ul><li>  Les fonctions sont divis√©es en familles <code>map</code> , <code>map2</code> , <code>pmap</code> , <code>walk</code> etc., des fonctions distinctes incluses dans la m√™me famille renvoient le r√©sultat dans diff√©rents formats: <em>chr</em> , <em>dbl</em> , <em>int</em> , <em>df</em> , etc.; </li><li>  Les fonctions de la famille <code>map2</code> vous <code>map2</code> d' <code>map2</code> sur des √©l√©ments (it√©rer) simultan√©ment de deux objets; </li><li>  Les fonctions de la famille <code>pmap</code> vous <code>pmap</code> d' <code>pmap</code> simultan√©ment sur des √©l√©ments d'un nombre quelconque d'objets.  Vous pouvez passer une table √† l'entr√©e de l'argument <em>.l</em> <em>(un analogue de l'argument X dans sapply)</em> , dont chaque colonne contiendra les valeurs par lesquelles vous it√©rerez, et qui seront √† leur tour substitu√©es dans les arguments de la m√™me fonction pass√©e en <em>.f</em> <em>(l'analogue FUN de s√©v√®rement)</em> . </li></ul><br><p>  Dans quelle situation devons-nous parcourir les √©l√©ments de plusieurs objets.  Par exemple, vous travaillez avec plusieurs comptes d'agent et les comptes publicitaires √† partir desquels vous souhaitez obtenir une liste de mots cl√©s sont dispers√©s entre eux.  Dans ce cas, vous pouvez cr√©er un vecteur √† partir des noms des comptes d'agent et le parcourir, en parall√®le avec la fa√ßon dont vous triez les connexions des comptes publicitaires. </p><br><div class="spoiler">  <b class="spoiler_title">Code 6: Exemple de travail avec plusieurs comptes d'agent</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) #      agencies &lt;- c("agency1", NA, "agency2", "agency1") #      #         result.pmap2 &lt;- map2_df(.x = logins, .y = agencies, ~ { yadirGetKeyWords(Login = .x, AgencyAccount = .y) %&gt;% mutate(login = .x) })</code> </pre> </div></div><br><p>  Imaginez maintenant la situation o√π lorsque vous vous √™tes connect√© sous diff√©rents comptes, vous avez enregistr√© le fichier avec les informations d'identification dans diff√©rents dossiers, puis vous devez it√©rer imm√©diatement sur trois objets: les connexions des comptes publicitaires, les connexions des comptes d'agent, le chemin dans lequel le fichier avec les informations d'identification est stock√©.  Cela peut √™tre fait avec de l'aide.  <code>pmap</code> famille <code>pmap</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Code 7: exemple de fonction pmap</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) #  ,       #      TokenPath &lt;- c("C:\\proj1\\tokens", "C:\\yandex\\token", "C:\\yandex\\token", "C:\\my_yandex_acoount") #   pmap.result &lt;- pmap_df(list(Login = logins, AgencyAccount = agencies, TokenPath = TokenPath), yadirGetKeyWords)</code> </pre> </div></div><br><p>  Par cons√©quent, le r√©sultat de l'ex√©cution des fonctions <code>map_df</code> , <code>map2_df</code> et <code>pmap_df</code> est le cadre de date, et lors de leur utilisation, la derni√®re √©tape de l'exemple avec <code>sapply</code> ( <code>do.call("rbind", kw.sapply)</code> ) n'est pas requise. </p><br><p>  Le code est devenu plus compact et ex√©cut√© un peu plus rapidement, mais n√©anmoins, les deux approches d√©crites, <code>sapply</code> et <code>purrr</code> , collectent s√©quentiellement les mots cl√©s de chaque compte.  Par cons√©quent, le temps d'ex√©cution total de cette op√©ration est √©gal √† la somme des dur√©es de collecte des donn√©es des quatre comptes. </p><br><p>  <strong>Heure [total]</strong> = <em>Heure [connexion1] + Heure [connexion2] + Heure [connexion3] + Heure [connexion4]</em> </p><br><h1 id="mnogopotochnye-varianty-resheniya-zadachi-po-sboru-klyuchevyh-slov-iz-yandeksdirekt">  Options multithread pour r√©soudre la t√¢che de collecte de mots cl√©s √† partir de Yandex.Direct </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/53c/cf5/ab353ccf566421eaaa6ec3d6445399a1.jpg"></p><br><p>  Donc, si vous avez d√©j√† lu le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier article</a> , vous savez que le mode de fonctionnement multithread poss√®de plusieurs fonctionnalit√©s: </p><br><ul><li>  Chaque thread d√©marre dans une session R distincte avec un environnement de travail propre. </li><li>  Pour la m√™me raison, dans un processus en cours d'ex√©cution s√©par√©, les paquets pr√©c√©demment connect√©s ne sont pas transmis par d√©faut. </li></ul><br><p>  L'exportation d'objets cr√©√©s dans un environnement de travail et la connexion de packages dans chaque approche sont impl√©ment√©es diff√©remment, nous les examinerons plus en d√©tail. </p><br><h3 id="paket-parallel">  Paquet <code>parallel</code> </h3><br><p>  Ce package a d'abord √©t√© inclus dans le package R dans la version 2.14.0 et est √† ce jour livr√© avec R lui-m√™me. </p><br><div class="spoiler">  <b class="spoiler_title">Code 8: Exemple de solution au probl√®me via le package parall√®le</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(parallel) library(tictoc) #   cl &lt;- makeCluster(4) #      clusterExport(cl = cl, varlist = "logins") #  ,      #  ,       ryandexdirect clusterEvalQ(cl = cl, { library(ryandexdirect) library(dplyr) } ) tic() #   parallel.kw &lt;- parSapplyLB(cl = cl, #   X = logins, # ,     FUN = function(x) { #      #      X yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = F) #    toc() #     #   stopCluster(cl) #      result.parallel &lt;- dplyr::bind_rows(parallel.kw)</code> </pre> </div></div><br><p>  <code>16.75 sec elapsed</code> : <code>16.75 sec elapsed</code> </p><br><p>  Essayons d'analyser le <strong>code 8</strong> .  La fonction <code>makeCluster</code> cr√©e un cluster de 4 processus.  Nous pouvons exporter des objets de notre environnement de travail principal vers le cluster cr√©√© en utilisant la fonction <code>clusterExport</code> , pour cela nous devons utiliser ses arguments: </p><br><ul><li>  <em>cl</em> - Cluster dans lequel nous allons exporter des objets </li><li>  <em>varlist</em> - Un vecteur de texte contenant les noms des objets √† exporter vers chaque processus de cluster. </li></ul><br><p>  Une fa√ßon de connecter les bons packages sur chaque n≈ìud de cluster consiste √† utiliser la fonction <code>clusterEvalQ</code> .  Dans notre exemple, nous l'utilisons pour connecter des packages, mais vous pouvez √©crire n'importe quel code R dans <code>clusterEvalQ</code> , et il sera lanc√© au d√©but de chaque n≈ìud de cluster.  Les arguments pour cette fonction sont assez √©vidents, vous devez sp√©cifier le cluster et les commandes qui y seront ex√©cut√©es. </p><br><p>  <code>parSapplyLB</code> est une version parall√®le de la fonction <code>sapply</code> avec √©quilibrage de charge entre les n≈ìuds de cluster, ils l'utilisent √©galement, mais vous devez sp√©cifier le cluster avec l'argument <em>cl</em> . </p><br><p>  √âgalement en <code>parallel</code> il existe d'autres versions parall√©lis√©es des fonctions de la famille <code>*apply</code> : <code>parLapply</code> , <code>parSapply</code> , <code>parApply</code> , etc. </p><br><p>  <code>parSapply</code> diff√®re de <code>parSapplyLB</code> uniquement en ce qu'il n'a pas d'√©quilibrage de charge sur les n≈ìuds de cluster. </p><br><p>  La fonction <code>stopCluster</code> est utilis√©e pour arr√™ter le cluster cr√©√©. </p><br><p>  La derni√®re commande, <code>dplyr::bind_rows(parallel.kw)</code> nous combinons l'objet <em>parallel.kw</em> obtenu en utilisant <code>parSapplyLB</code> dans une table. </p><br><p>  Pour Linux, le <code>parallel</code> a des fonctions distinctes: <code>mclapply</code> , <code>mcmapply</code> , <code>mcMap</code> .  Souvent, dans ce syst√®me d'exploitation, les commandes sont ex√©cut√©es plus rapidement et le code devient plus compact. </p><br><div class="spoiler">  <b class="spoiler_title">Code 9: solution utilisant mclapply pour Linux</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(parallel) library(tictic) library(dplyr) library(ryandexdirect) tic() mclapply.kw &lt;- mclapply(logins, FUN = function(x) { #      #      X yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, mc.cores = 4) toc()</code> </pre> </div></div><br><p>  Lorsque vous utilisez ces fonctions, il n'est pas n√©cessaire de d√©marrer le cluster √† l'aide de la <code>makeCluster</code> .  le nombre de n≈ìuds que vous <em>sp√©cifiez</em> √† l'aide de l'argument <em>mc.cores</em> .  Il n'est pas non plus n√©cessaire de connecter des packages et d'exporter des objets; ces op√©rations sont effectu√©es automatiquement. </p><br><h3 id="paket-future">  Forfait <code>future</code> </h3><br><p>  L'une des approches les plus modernes de la programmation asynchrone en R. </p><br><p>  Un code qui, en parall√®le, r√©soudra notre probl√®me avec l'aide du <code>future</code> est suffisamment compliqu√© √† comprendre.  Par cons√©quent, analysons son travail sur un exemple plus simple, nous demanderons une liste de mots cl√©s √† partir d'un compte. </p><br><div class="spoiler">  <b class="spoiler_title">Code 10: l'exemple le plus simple d'utilisation du futur package</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) #    plan(multiprocess) #      #    future.kw &lt;- future({yadirGetKeyWords(Login = logins[4])}, packages = "ryandexdirect", globals = "logins") #     resolved(future.kw) #     future.result.1 &lt;- value(future.kw)</code> </pre> </div></div><br><p>  Essayons de comprendre l'exemple du <strong>Code 10</strong> .  La fonction <code>plan</code> vous permet de d√©finir et de modifier le mode d'ex√©cution des expressions donn√©es, en voici les principales: </p><br><ul><li>  <em>s√©quentiel</em> - Il s'agit du mode de fonctionnement R habituel; les commandes sont ex√©cut√©es s√©quentiellement dans la session en cours; </li><li>  <em>multisession</em> - Mode parall√®le, les commandes seront ex√©cut√©es dans les sessions en cours en arri√®re-plan sur la machine actuelle, tandis que votre session de travail ne sera pas bloqu√©e; </li><li>  <em>cluster</em> - Mode parall√®le, les commandes seront ex√©cut√©es sur la machine actuelle ou distante, similaire √† la fa√ßon dont elle est impl√©ment√©e dans le package <code>parallel</code> . </li></ul><br><p>  L'ensemble du <code>future</code> package est bas√© sur l'ex√©cution de commandes dans des processus en arri√®re-plan sans bloquer la session en cours.  L'ex√©cution de commandes suit la fonction du m√™me nom <code>future</code> , donc lorsque nous ex√©cutons la commande: </p><br><pre> <code class="plaintext hljs">future({yadirGetKeyWords(Login = logins[4])}, packages = "ryandexdirect", globals = "logins")</code> </pre> <br><p>  Notre session actuelle dans R n'est pas bloqu√©e et la commande est ex√©cut√©e en arri√®re-plan, en ex√©cutant une autre session R. </p><br><p>  Vous pouvez v√©rifier l'√©tat actuel du processus d'ex√©cution d'une expression donn√©e √† l'aide de la fonction <code>resolved</code> .  Enfin, la fonction de <code>value</code> est utilis√©e pour obtenir le r√©sultat d'une <code>future</code> ex√©cution.  Si vous ex√©cutez la fonction de <code>value</code> plus t√¥t que votre <code>future</code> ex√©cution dans une session d'ex√©cution parall√®le, la session de travail en cours sera bloqu√©e jusqu'√† la fin de l'expression de session parall√®le. </p><br><p>  L'exemple de travail le plus avanc√© est l'utilisation du <code>future</code> conjointement avec les <code>promises</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Code 11: Exemple de partage de packages de ¬´futures¬ª et de ¬´promesses¬ª</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) library(promises) #    plan(multiprocess) #      #    future.kw &lt;- future({suppressMessages( yadirGetKeyWords(Login = logins[4]))}, packages = "ryandexdirect", globals = "logins") %...&gt;% #     future, #      nrow() %...&gt;% paste("words loaded") %...&gt;% print()</code> </pre> </div></div><br><p>  Le package <code>promises</code> fournit un ensemble d'op√©rateurs de pipelines qui compl√®tent parfaitement les fonctionnalit√©s <code>future</code> . </p><br><p>  Dans l'exemple <strong>Code 11</strong> , en arri√®re-plan, nous commen√ßons le processus de t√©l√©chargement de mots cl√©s √† partir d'un compte publicitaire.  De plus, l'op√©rateur de pipeline <code>%...&gt;%</code> sans bloquer la session de travail attend la fin du <code>future</code> et effectue les op√©rations restantes.  √Ä la suite de l'ex√©cution du code, √† la fin des travaux <code>future</code> , le nombre de mots-cl√©s du compte sp√©cifi√© sera affich√© dans la console: </p><br><pre> <code class="plaintext hljs">[1] "1855 words loaded"</code> </pre> <br><blockquote>  √Ä la fin de l'article, un exemple plus illustratif d'un tas d' <code>future</code> et de <code>promises</code> sera d√©montr√©. </blockquote><p>  Par d√©faut, le <code>future</code> package exporte lui-m√™me l'int√©gralit√© de l'espace de travail vers chaque session parall√®le, mais vous pouvez vous-m√™me sp√©cifier une liste d'objets √† exporter √† l'aide de l'argument <em>global</em> . </p><br><p>  Pour connecter les packages √† l' <code>future</code> passer un vecteur contenant leurs noms √† l'argument <em>packages</em> . </p><br><p>  Revenons maintenant √† notre t√¢che, l'exemple de code suivant en mode parall√®le chargera une liste de mots cl√©s √† partir de 4 comptes: </p><br><div class="spoiler">  <b class="spoiler_title">Code 12: un exemple de r√©solution d'un probl√®me √† l'aide du futur package</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) library(tictoc) #   plan("multisession", workers = 4) tic() #   futs &lt;- lapply(logins, #      function(i) #        #   future({ yadirGetKeyWords(Login = i) %&gt;% mutate(login = i) }, packages = c("ryandexdirect", "dplyr"))) completed &lt;- sapply(futs, resolved) #    kw &lt;- lapply(futs, value) #    toc() #    #     result.future &lt;- dplyr::bind_rows(kw)</code> </pre> </div></div><br><p>  D√©lai: <code>14.83 sec elapsed</code> </p><br><p>  Pour t√©l√©charger une liste de mots cl√©s en mode multithread √† partir de tous les comptes publicitaires r√©pertori√©s dans les <em>connexions</em> vectorielles <em>,</em> vous devez ex√©cuter un <code>future</code> distinct en arri√®re-plan.  Dans l'exemple de <strong>code 12,</strong> nous impl√©mentons cela en utilisant la fonction <code>lapply</code> . </p><br><p>  Le r√©sultat de travailler <code>lapply</code> est une liste de <code>future</code> lanc√©s.  Vous pouvez v√©rifier le statut de chacun en utilisant la commande <code>sapply(futs, resolved)</code> , qui renverra un vecteur logique o√π <em>TRUE</em> signifiera que le <code>future</code> rempli et <em>FALSE</em> que le <code>future</code> est actuellement en cours. </p><br><p>  Pour obtenir des r√©sultats de chaque <code>future</code> , une fois leur travail termin√©, nous utilisons la commande <code>lapply(futs, value)</code> . </p><br><p>          : <code>result.future &lt;- dplyr::bind_rows(kw)</code> . </p><br><h3 id="obyortki-nad-future">   <code>future</code> </h3><br><p>      ,      (   <br> <code>future</code> ),      . </p><br><h6 id="paket-futureapply">  <code>future.apply</code> </h6><br><p> <code>future.apply</code>     <code>future</code> ,  . </p><br><div class="spoiler"> <b class="spoiler_title"> 13:       future.apply</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future.apply) library(tictoc) #    plan("multisession", workers = 4) tic() #   kw.future.apply &lt;- future_sapply(logins, #    ,   function(x) { #     yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE, #    #   future.packages = c("ryandexdirect", "dplyr"), future.globals = TRUE ) toc() #   </code> </pre> </div></div><br><p>  : <code>17.28 sec elapsed</code> </p><br><p>   <strong> 13</strong> ,  <code>future.apply</code>         <code>future</code> ,         . </p><br><p>         4 : <code>plan("multisession", workers = 4)</code> . </p><br><p> <code>future_sapply</code>      <em>logins</em>    .  C'est-√†-dire   ,  ,        <code>sapply</code> ,    . </p><br><p>      <code>future_sapply</code>    <em>future.packages</em> .             <em>future.globals</em> .       ,              . </p><br><h4 id="paket-furrr">  <code>furrr</code> </h4><br><p>     <code>future</code> .          <code>purrr</code> ,   <code>furrr</code>     . </p><br><div class="spoiler"> <b class="spoiler_title"> 14:      furrr</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(furrr) library(tictoc) #   cl &lt;- parallel::makeCluster(4) plan(cluster, workers = cl) tic() #   furrr.kw &lt;- future_map(logins, ~ #   function(.x) yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x), .options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())) toc() #    #      result.furrr &lt;-dplyr::bind_rows(furrr.kw)</code> </pre> </div></div><br><p>  : <code>15.45 sec elapsed</code> </p><br><p> <code>furrr</code>          <code>purrr</code> .     <code>purrr</code>  ,          . </p><br><p>           <em>.options</em> .     <em>.options</em>  <code>future_options</code>     ,         . </p><br><p>   <strong> 14</strong>    <em>packages</em>  <em>globals</em>    : </p><br><pre> <code class="plaintext hljs">.options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())</code> </pre> <br><h1 id="test-skorosti">   </h1><br><p>           <code>rbenchmark</code> . </p><br><p>    ,          <code>future</code>  <code>promises</code> .                . </p><br><p>   ,     20       4     () . </p><br><p>    = (T[1] * 20) + (T[2] * 20) + (T[N] * 20) </p><br><div class="spoiler"> <b class="spoiler_title"> 15:        future  promises</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(furrr) library(parallel) library(dplyr) library(future) library(ryandexdirect) library(tictoc) library(rbenchmark) #   logins &lt;- c("login1", "login2", "login3", "login4") #        #        par par.furrr &lt;- function(logins) { cl &lt;- parallel::makeCluster(4) plan(cluster, workers = cl) furrr.kw &lt;- future_map(logins, ~ yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x), .options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())) result.furrr &lt;-dplyr::bind_rows(furrr.kw) } par.future &lt;- function(logins) { plan("multisession", workers = 4) futs &lt;- lapply(logins, function(i) future({ yadirGetKeyWords(Login = i) %&gt;% mutate(login = i) }, packages = c("ryandexdirect", "dplyr"))) completed &lt;- sapply(futs, resolved) kw &lt;- lapply(futs, value) result.future &lt;- dplyr::bind_rows(kw) } par.future.apply &lt;- function(logins) { plan("multisession", workers = 4) kw.future.apply &lt;- future_sapply(logins, function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE, future.packages = c("ryandexdirect", "dplyr"), future.globals = TRUE ) result.future.apply &lt;- dplyr::bind_rows(kw.future.apply) } par.parallel &lt;- function(logins) { cl &lt;- parallel::makeCluster(4) clusterExport(cl = cl, varlist = "logins") clusterEvalQ(cl = cl, { library(ryandexdirect) library(dplyr) } ) parallel.kw &lt;- parSapplyLB(cl = cl, X = logins, FUN = function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = F) stopCluster(cl) result.parallel &lt;- dplyr::bind_rows(parallel.kw) } #          seq seq.apply &lt;- function(logins) { kw.sapply &lt;- sapply( logins, function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE ) result.sapply &lt;- do.call("rbind", kw.sapply) } seq.purrr &lt;- function(logins) { kw.purrr &lt;- map_df( logins, ~ { yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x) } ) result.purrr &lt;- do.call("rbind", kw.purrr) } #       rbenchmark #   future + promises #  ,       #          plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 4))) tic() speed.test &lt;- future({ #          within(benchmark(furrr = par.furrr(logins), future = par.future(logins), future.apply = par.future.apply(logins), parallel = par.parallel(logins), apply = seq.apply(logins), purrr = seq.purrr(logins), replications = c(20), columns = c('test', 'replications', 'elapsed'), order = c('elapsed', 'test')), { average = round(elapsed/replications, 2) }) }, packages = c("dplyr", "ryandexdirect", "rbenchmark", "parallel", "purrr", "future", "promises", "furrr", "future.apply"), globals = c("logins", "par.furrr", "par.future", "par.future.apply", "par.parallel", "seq.apply", "seq.purrr")) %...&gt;% print() %...T&gt;% toc() message("My Session is not blocked")</code> </pre> </div></div><br><p>       3370 , ..   . </p><br><p>           .  ,               <code>future</code>   ,       <code>promises</code>    ,                  . </p><br><p>        ,       .         "My Session is not blocked",       ,       , ..      . </p><br><p>  <code>promises</code>   : </p><br><ul><li> <code>%...&gt;%</code> ‚Äî     <code>%&gt;%</code> ,     .  C'est-√†-dire   ,       <code>resolved</code> ,     <code>future</code> ,          <code>value</code>          .       ,         <code>print</code> . </li><li> <code>%...T&gt;%</code> ‚Äî  <code>%T&gt;%</code> ,  ,          .    ,          ,     , ..    ..  <code>print</code>       ,   ,    . </li><li> %...T!% ‚Äî      . </li></ul><br><p>  <strong> 15</strong>  <code>plan</code>    <code>tweak</code> ( <code>plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 4)))</code> ),      ,    2 ,   <code>future</code>       4 . </p><br><p>       : </p><br><pre> <code class="plaintext hljs">My Session is not blocked test replications elapsed average 4 parallel 20 393.02 19.65 1 furrr 20 402.09 20.10 2 future 20 431.19 21.56 3 future.apply 20 432.29 21.61 5 apply 20 847.77 42.39 6 purrr 20 864.19 43.21 3370.55 sec elapsed</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/16e/906/831/16e90683145df442ca830a6758734cbe.png" alt="image"></p><br><p>   ,        <code>parallel</code> ,        .    <code>furrr</code> ,     <code>future</code>  <code>future.apply</code> . </p><br><p>     1 ,           ,   .         ,      API .     . </p><br><p>   ,     4        ,          . </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>               R,             API. </p><br><p>   ,     API    .              <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">" R    ,  1"</a> . </p><br><p>          : </p><br><ul><li> doSNOW / doParallel + foreach </li><li> future + promises </li><li> future.apply / furrr </li><li> parallel </li></ul><br><p>         ,   ,        . </p><br><p>         ,          R  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448404/">https://habr.com/ru/post/fr448404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448392/index.html">Deux approches pour structurer un graphique d'activit√©</a></li>
<li><a href="../fr448394/index.html">La version 12 est lanc√©e aujourd'hui! (Et c'est un grand saut pour Wolfram Language et Mathematica)</a></li>
<li><a href="../fr448396/index.html">Se pr√©parer pour le Runtime renforc√© et le service notarial sur macOS Mojave</a></li>
<li><a href="../fr448400/index.html">Netplan et comment le cuisiner correctement</a></li>
<li><a href="../fr448402/index.html">√âchec de la migration de l'autorit√© de certification (CA) de Windows 2008R vers Windows 2012 R2</a></li>
<li><a href="../fr448408/index.html">DCIM - La cl√© de la gestion des centres de donn√©es</a></li>
<li><a href="../fr448410/index.html">Les trackers de Google sont int√©gr√©s √† un certain nombre de ressources √©lectroniques russes officielles</a></li>
<li><a href="../fr448414/index.html">Laboratoire √† domicile pour la ma√Ætrise de soi ou quoi acheter dans un kit geek</a></li>
<li><a href="../fr448416/index.html">Le moyen le plus simple de faire du chat dans une application iOS</a></li>
<li><a href="../fr448420/index.html">De la vie avec Kubernetes: comment le serveur HTTP espagnol ne s'est pas plaint</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>