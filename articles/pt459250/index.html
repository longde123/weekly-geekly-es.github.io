<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôèüèª üïµüèø ‚õπÔ∏è WAL no PostgreSQL: 2. Log de pr√©-registro üò∫ ü§≤üèª üë©‚Äçüëß‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na √∫ltima vez, nos encontramos com o dispositivo de um dos objetos importantes da mem√≥ria compartilhada, o cache do buffer. A possibilidade de perda d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL no PostgreSQL: 2. Log de pr√©-registro</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/459250/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Na √∫ltima vez,</a> nos encontramos com o dispositivo de um dos objetos importantes da mem√≥ria compartilhada, o cache do buffer.  A possibilidade de perda de informa√ß√µes da RAM √© o principal motivo da necessidade de recupera√ß√£o de uma falha.  Hoje falaremos sobre essas ferramentas. <br><br><h1>  Magazine </h1><br>  Infelizmente, milagres n√£o acontecem: para sobreviver √† perda de informa√ß√µes na RAM, tudo o que √© necess√°rio deve ser gravado em um disco (ou outro dispositivo n√£o vol√°til) em tempo h√°bil. <br><br>  Portanto, √© isso que foi feito.  Juntamente com as altera√ß√µes de dados, tamb√©m √© mantido um <em>di√°rio</em> dessas altera√ß√µes.  Quando alteramos algo em uma p√°gina no cache do buffer, criamos um registro no log sobre essa altera√ß√£o.  O registro cont√©m as informa√ß√µes m√≠nimas suficientes para que, se necess√°rio, a altera√ß√£o possa ser repetida. <br><br>  Para que isso funcione, a entrada do di√°rio deve necessariamente ir para o disco <em>antes que a</em> p√°gina modificada chegue l√°.  Da√≠ o nome: log write-ahead. <br><br>  Se ocorrer uma falha, os dados no disco estar√£o em um estado inconsistente: algumas p√°ginas foram gravadas anteriormente, outras mais tarde.  Por√©m, resta um di√°rio que pode ser lido e reexecutado pelas opera√ß√µes que j√° foram conclu√≠das antes da falha, mas cujo resultado n√£o atingiu o disco. <br><a name="habracut"></a><br><blockquote>  Por que n√£o for√ßar as pr√≥prias p√°ginas de dados a serem gravadas em disco, por que duplicar os trabalhos?  Acontece t√£o eficaz. <br>  Primeiro de tudo, um log √© um fluxo seq√ºencial de dados para grava√ß√£o.  At√© os HDDs se d√£o muito bem com a grava√ß√£o seq√ºencial.  Mas o registro dos dados em si √© aleat√≥rio, porque as p√°ginas est√£o espalhadas pelo disco mais ou menos aleatoriamente. <br>  Em segundo lugar, uma entrada no di√°rio pode ser muito menor que uma p√°gina. <br>  Em terceiro lugar, ao gravar, voc√™ n√£o precisa se preocupar em garantir que os dados no disco permane√ßam consistentes em qualquer momento arbitr√°rio (esse requisito complica muito a vida). <br>  E quarto, como veremos mais adiante, o di√°rio (como existe) pode ser usado n√£o apenas para recupera√ß√£o, mas tamb√©m para backup e replica√ß√£o. <br></blockquote><br>  Voc√™ precisa registrar todas as opera√ß√µes, durante as quais h√° risco de inconsist√™ncia no disco no caso de uma falha.  Em particular, as seguintes a√ß√µes s√£o registradas: <br><br><ul><li>  alterar p√°ginas no cache do buffer (como regra, s√£o tabelas e p√°ginas de √≠ndice) - j√° que a p√°gina alterada n√£o entra imediatamente no disco; </li><li>  confirmar e cancelar transa√ß√µes - a altera√ß√£o de status ocorre nos buffers XACT e tamb√©m n√£o atinge imediatamente o disco; </li><li>  opera√ß√µes de arquivo (cria√ß√£o e exclus√£o de arquivos e diret√≥rios, por exemplo, cria√ß√£o de arquivos ao criar uma tabela) - j√° que essas opera√ß√µes devem ocorrer simultaneamente com as altera√ß√µes de dados. </li></ul><br>  N√£o registrado: <br><br><ul><li>  opera√ß√µes com tabelas n√£o registradas no di√°rio (n√£o registradas) - seu nome fala por si; </li><li>  opera√ß√µes com tabelas tempor√°rias - n√£o faz sentido, pois o tempo de vida dessas tabelas n√£o excede o tempo de vida da sess√£o que as criou. </li></ul><br>  Antes do PostgreSQL 10, os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√≠ndices de hash</a> n√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">eram</a> registrados (eles serviam apenas para mapear fun√ß√µes de hash para diferentes tipos de dados), mas agora isso foi corrigido. <br><br><h1>  Dispositivo l√≥gico </h1><br><img src="https://habrastorage.org/webt/vx/vj/67/vxvj673dzyqmhumlxby7i8wt5q0.png"><br><br>  Logicamente, um di√°rio pode ser pensado como uma sequ√™ncia de registros de v√°rios comprimentos.  Cada registro cont√©m <em>dados</em> sobre uma determinada opera√ß√£o, precedida por um <em>cabe√ßalho</em> padr√£o.  O t√≠tulo, entre outras coisas, indica: <br><br><ul><li>  O n√∫mero da transa√ß√£o √† qual o registro pertence. </li><li>  gerenciador de recursos - o componente do sistema respons√°vel pela grava√ß√£o; </li><li>  soma de verifica√ß√£o (CRC) - permite determinar a corrup√ß√£o de dados; </li><li>  comprimento do registro e link para o registro anterior. </li></ul><br>  Os dados em si t√™m um formato e significado diferentes.  Por exemplo, eles podem representar algum fragmento de uma p√°gina que precisa ser gravada sobre seu conte√∫do com um determinado deslocamento.  O gerenciador de recursos especificado "entende" como interpretar os dados em seu registro.  Existem gerenciadores separados para tabelas, para cada tipo de √≠ndice, para status de transa√ß√£o, etc. Uma lista completa deles pode ser obtida se desejado pelo comando <br><br><pre><code class="plaintext hljs">pg_waldump -r list</code> </pre> <br><h1>  Dispositivo f√≠sico </h1><br>  No disco, o log √© armazenado como arquivos no diret√≥rio $ PGDATA / pg_wal.  Cada arquivo padr√£o √© 16 MB.  O tamanho pode ser aumentado para evitar um grande n√∫mero de arquivos em um diret√≥rio.  Antes do PostgreSQL 11, isso s√≥ podia ser feito ao compilar o c√≥digo-fonte, mas agora voc√™ pode especificar o tamanho ao inicializar o cluster (a <code>--wal-segsize</code> ). <br><br>  As entradas de log caem no arquivo atual em uso;  quando termina, o pr√≥ximo come√ßa a ser usado. <br><br>  Buffers especiais s√£o alocados para o log na mem√≥ria compartilhada do servidor.  O tamanho do cache do di√°rio √© definido pelo par√¢metro <em>wal_buffers</em> (o valor padr√£o implica na configura√ß√£o autom√°tica: 1/32 do cache do buffer √© alocado). <br><br>  O cache do di√°rio √© organizado como um cache de buffer, mas funciona principalmente no modo de buffer de anel: as entradas s√£o adicionadas √† "cabe√ßa" e gravadas no disco a partir da "cauda". <br><br>  As posi√ß√µes de grava√ß√£o ("cauda") e inser√ß√£o ("cabe√ßa") mostram as fun√ß√µes pg_current_wal_lsn e pg_current_wal_insert lsn, respectivamente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_lsn | pg_current_wal_insert_lsn --------------------+--------------------------- 0/331E4E64 | 0/331E4EA0 (1 row)</code> </pre><br>  Para se referir a um registro espec√≠fico, √© usado o tipo de dados pg_lsn (LSN = n√∫mero de sequ√™ncia do log) - este √© um n√∫mero de 64 bits que representa o deslocamento de bytes antes do registro em rela√ß√£o ao in√≠cio do log.  O LSN √© emitido como dois n√∫meros de 32 bits na nota√ß√£o hexadecimal. <br><br>  Voc√™ pode descobrir em qual arquivo vamos encontrar a posi√ß√£o desejada e com qual deslocamento desde o in√≠cio do arquivo: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> file_name, upper(to_hex(file_offset)) file_offset <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_walfile_name_offset(<span class="hljs-string"><span class="hljs-string">'0/331E4E64'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> file_name | file_offset --------------------------+------------- 000000010000000000000033 | 1E4E64 \ /\ /  0/331E4E64 </code> </pre><br>  O nome do arquivo consiste em duas partes.  Os 8 d√≠gitos hexadecimais superiores mostram o n√∫mero da ramifica√ß√£o de tempo (√© usado ao restaurar a partir do backup), o restante corresponde aos d√≠gitos LSN mais altos (e os d√≠gitos LSN inferiores restantes indicam o deslocamento). <br><br>  Os arquivos de log podem ser visualizados no sistema de arquivos no diret√≥rio $ PGDATA / pg_wal /, mas a partir do PostgreSQL 10, eles tamb√©m podem ser vistos com uma fun√ß√£o especial: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_ls_waldir() <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'000000010000000000000033'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> name | size | modification --------------------------+----------+------------------------ 000000010000000000000033 | 16777216 | 2019-07-08 20:24:13+03 (1 row)</code> </pre><br><h1>  Grava√ß√£o para frente </h1><br>  Vamos ver como ocorre o registro no di√°rio e como a grava√ß√£o proativa √© fornecida.  Crie uma tabela: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wal(id <span class="hljs-type"><span class="hljs-type">integer</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> wal <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Veremos o cabe√ßalho da p√°gina da tabela.  Para fazer isso, precisamos de uma extens√£o j√° familiar: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect;</code> </pre><br>  Vamos iniciar a transa√ß√£o e lembrar a posi√ß√£o de inser√ß√£o no log: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F377C (1 row)</code> </pre><br>  Agora vamos fazer alguma opera√ß√£o, por exemplo, atualizar a linha: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> wal <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> id = id + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Essa altera√ß√£o foi registrada no log, a posi√ß√£o de inser√ß√£o foi alterada: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F37C4 (1 row)</code> </pre><br>  Para garantir que a p√°gina de dados modificada n√£o seja enviada para o disco antes do lan√ßamento no di√°rio, o LSN da √∫ltima entrada no di√°rio relacionado a esta p√°gina ser√° armazenado no cabe√ßalho da p√°gina: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lsn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'wal'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lsn ------------ 0/331F37C4 (1 row)</code> </pre><br>  Lembre-se de que o di√°rio √© comum a todo o cluster, e novas entradas entram nele o tempo todo.  Portanto, o LSN na p√°gina pode ser menor que o valor que a fun√ß√£o pg_current_wal_insert_lsn acabou de retornar.  Mas nada acontece no nosso sistema, ent√£o os n√∫meros s√£o os mesmos. <br><br>  Agora complete a transa√ß√£o. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  O registro de confirma√ß√£o tamb√©m vai para o log e a posi√ß√£o muda novamente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F37E8 (1 row)</code> </pre><br>  A confirma√ß√£o altera o status de uma transa√ß√£o em uma estrutura chamada XACT ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">j√° falamos sobre isso</a> ).  Os status s√£o armazenados em arquivos, mas eles tamb√©m usam seu pr√≥prio cache, que ocupa 128 p√°ginas na mem√≥ria compartilhada.  Portanto, para p√°ginas XACT, o LSN da √∫ltima entrada no di√°rio deve ser rastreado.  Mas essas informa√ß√µes n√£o s√£o armazenadas na pr√≥pria p√°gina, mas na RAM. <br><br>  Em algum momento, as entradas do di√°rio criadas ser√£o gravadas no disco.  Em qual - falaremos outra vez, mas no nosso caso isso j√° aconteceu: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_lsn | pg_current_wal_insert_lsn --------------------+--------------------------- 0/331F37E8 | 0/331F37E8 (1 row)</code> </pre><br>  Ap√≥s esse ponto, as p√°ginas de dados e XACT podem ser enviadas para fora do cache.  Mas, se fosse necess√°rio for√ß√°-los a sair mais cedo, seria detectado e os lan√ßamentos no di√°rio seriam for√ßados a serem registrados primeiro. <br><br>  Conhecendo as duas posi√ß√µes do LSN, √© poss√≠vel obter o tamanho dos lan√ßamentos cont√°beis manuais entre eles (em bytes), subtraindo uma posi√ß√£o da outra.  Voc√™ s√≥ precisa converter as posi√ß√µes para o tipo pg_lsn: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'0/331F37E8'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/331F377C'</span></span>::pg_lsn;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 108 (1 row)</code> </pre><br>  Nesse caso, a atualiza√ß√£o e confirma√ß√£o da linha exigiam 108 bytes no log. <br><br>  Da mesma forma, voc√™ pode estimar quanto os lan√ßamentos cont√°beis manuais s√£o gerados pelo servidor por unidade de tempo em uma determinada carga.  Esta √© uma informa√ß√£o importante que ser√° necess√°ria durante a instala√ß√£o (sobre a qual falaremos na pr√≥xima vez). <br><br>  Agora usaremos o utilit√°rio pg_waldump para examinar as entradas de log criadas. <br><br>  O utilit√°rio pode trabalhar com o intervalo LSN (como neste exemplo) e selecionar registros para a transa√ß√£o especificada.  Ele deve ser executado em nome do usu√°rio do SO do postgres, pois ele precisa acessar os arquivos de log no disco. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/331F377C -e 0/331F37E8 000000010000000000000033</code> </pre><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 69/ 69, tx: 101085, lsn: 0/331F377C, prev 0/331F3014, desc: HOT_UPDATE off 1 xmax 101085 ; new off 2 xmax 0, blkref #0: rel 1663/16386/33081 blk 0</code> </pre><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 34/ 34, tx: 101085, lsn: 0/331F37C4, prev 0/331F377C, desc: COMMIT 2019-07-08 20:24:13.945435 MSK</code> </pre><br>  Aqui vemos os cabe√ßalhos das duas entradas. <br><br>  A primeira √© a opera√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HOT_UPDATE</a> , relacionada ao gerenciador de recursos Heap.  O nome do arquivo e o n√∫mero da p√°gina s√£o indicados no campo blkref e correspondem √† p√°gina da tabela atualizada: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'wal'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/16386/33081 (1 row)</code> </pre><br>  A segunda entrada √© COMMIT, relacionada ao Transaction Resource Manager. <br><br>  N√£o √© o formato mais leg√≠vel, mas voc√™ pode descobrir se necess√°rio. <br><br><h1>  Recupera√ß√£o </h1><br>  Quando iniciamos o servidor, o processo do postmaster inicia primeiro e, por sua vez, inicia o processo de inicializa√ß√£o, cuja tarefa √© garantir a recupera√ß√£o se ocorrer uma falha. <br><br>  Para determinar se a recupera√ß√£o √© necess√°ria, a inicializa√ß√£o examina o arquivo de controle especial $ PGDATA / global / pg_control e o status do cluster.  Podemos verificar o status usando o utilit√°rio pg_controldata: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: in production</code> </pre><br>  Um servidor perfeitamente parado ter√° o status "desligado".  Se o servidor n√£o funcionar e o status permanecer "em produ√ß√£o", isso significa que o DBMS caiu e a recupera√ß√£o ser√° executada automaticamente. <br><br>  Para recupera√ß√£o, o processo de inicializa√ß√£o ler√° sequencialmente o log e aplicar√° entradas nas p√°ginas, se necess√°rio.  Voc√™ pode verificar a necessidade comparando o LSN da p√°gina no disco com o LSN da entrada do di√°rio.  Se o LSN da p√°gina for maior, o registro n√£o ser√° necess√°rio.  Mas, na verdade, isso nem √© poss√≠vel, porque os registros foram projetados para aplicativos estritamente consistentes. <br><br><blockquote>  H√° exce√ß√µes.  Alguns registros s√£o formados como uma imagem de p√°gina inteira (FPI, imagem de p√°gina inteira), e √© claro que essa imagem pode ser aplicada a uma p√°gina em qualquer estado - ela ainda apagar√° tudo o que estava l√°.  Outra altera√ß√£o no status da transa√ß√£o pode ser aplicada a qualquer vers√£o da p√°gina XACT - portanto, nessas p√°ginas, n√£o h√° necessidade de armazenar LSN. <br></blockquote><br>  A altera√ß√£o de p√°ginas durante a recupera√ß√£o ocorre no cache do buffer, como durante o trabalho normal - pois este postmaster inicia os processos em segundo plano necess√°rios. <br><br>  Da mesma forma, as entradas do di√°rio se aplicam aos arquivos: por exemplo, se um registro diz que o arquivo deve existir, mas n√£o existe, o arquivo √© criado. <br><br>  Bem, no final do processo de recupera√ß√£o, todas as tabelas n√£o registradas em di√°rio s√£o substitu√≠das por "manequins" de suas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">camadas init</a> . <br><br>  Esta √© uma apresenta√ß√£o muito simplificada do algoritmo.  Em particular, n√£o dissemos nada sobre por onde come√ßar a ler os lan√ßamentos no di√°rio (essa conversa dever√° ser adiada at√© que o ponto de verifica√ß√£o seja considerado). <br><br>  E o √∫ltimo esclarecimento.  O processo de recupera√ß√£o "cl√°ssico" consiste em duas fases.  Na primeira fase (roll forward), as entradas do di√°rio s√£o roladas e o servidor repete todo o trabalho perdido durante a falha.  No segundo (revers√£o), as transa√ß√µes que n√£o foram confirmadas no momento da falha s√£o revertidas.  Mas o PostgreSQL n√£o precisa de uma segunda fase.  Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">consideramos anteriormente</a> , devido √†s peculiaridades da implementa√ß√£o de transa√ß√µes com v√°rias vers√µes, n√£o √© necess√°rio reverter fisicamente;  basta que o bit de corre√ß√£o n√£o seja definido no XACT. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para ser continuado</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459250/">https://habr.com/ru/post/pt459250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459240/index.html">10 anos em TI diagnosticada com esquizofrenia, dicas de sobreviv√™ncia</a></li>
<li><a href="../pt459242/index.html">Ap√≥s a confer√™ncia T + Conf 2019</a></li>
<li><a href="../pt459244/index.html">Gerente de produto do Notes: comportamento do usu√°rio nas p√°ginas dos jogos na loja de aplicativos. Quanto tempo leva para baixar um jogo</a></li>
<li><a href="../pt459246/index.html">Por que a convers√£o do site est√° diminuindo? Exemplos de 60 erros de design e usabilidade</a></li>
<li><a href="../pt459248/index.html">Eventos digitais em Moscou, de 9 a 14 de julho</a></li>
<li><a href="../pt459252/index.html">Semana 28 de Seguran√ßa: invadindo uma casa inteligente</a></li>
<li><a href="../pt459254/index.html">Bomba zip ainda melhor</a></li>
<li><a href="../pt459256/index.html">Como otimizamos nosso Hospital Tem√°tico para diferentes plataformas</a></li>
<li><a href="../pt459258/index.html">14.000 milhas n√£o gancho</a></li>
<li><a href="../pt459262/index.html">Aposentado aos 22</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>