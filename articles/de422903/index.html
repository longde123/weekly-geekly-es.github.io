<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¥üèΩ ‚ò£Ô∏è üï¢ Wie und warum haben wir einen hoch geladenen skalierbaren Dienst f√ºr 1C geschrieben: Enterprise: Java, PostgreSQL, Hazelcast üíÑ üìë üë©üèø‚Äçü§ù‚Äçüë©üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir dar√ºber sprechen, wie und warum wir das Interaktionssystem entwickelt haben - einen Mechanismus, der Informationen zwisch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie und warum haben wir einen hoch geladenen skalierbaren Dienst f√ºr 1C geschrieben: Enterprise: Java, PostgreSQL, Hazelcast</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/1c/blog/422903/">  In diesem Artikel werden wir dar√ºber sprechen, wie und warum wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Interaktionssystem</a> entwickelt haben - einen Mechanismus, der Informationen zwischen Clientanwendungen und 1C: Enterprise-Servern √ºbertr√§gt - von der Einstellung der Aufgabe bis zum Durchdenken der Architektur- und Implementierungsdetails. <br><br>  Das Interaktionssystem (im Folgenden als CB bezeichnet) ist ein verteiltes fehlertolerantes Nachrichtensystem mit garantierter Zustellung.  SV ist als hoch ausgelasteter Dienst mit hoher Skalierbarkeit konzipiert und sowohl als Onlinedienst (von 1C bereitgestellt) als auch als Verbreitungsprodukt verf√ºgbar, das auf seinen Serverkapazit√§ten bereitgestellt werden kann. <br><br>  CB verwendet verteilten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hazelcast-</a> Speicher und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elasticsearch-</a> Suchmaschine.  Wir werden auch √ºber Java sprechen und wie wir PostgreSQL horizontal skalieren. <br><img src="https://habrastorage.org/webt/gh/nq/sq/ghnqsqdgkb0i4ze_7ig8blrfilk.png" alt="Bild"><br><a name="habracut"></a><br><br><h2>  Erkl√§rung des Problems </h2><br>  Um zu verdeutlichen, warum wir das Interaktionssystem entwickelt haben, m√∂chte ich Ihnen ein wenig dar√ºber erz√§hlen, wie die Entwicklung von Gesch√§ftsanwendungen in 1C funktioniert. <br><br>  Zun√§chst ein wenig √ºber uns f√ºr diejenigen, die noch nicht wissen, was wir tun :) Wir erstellen die 1C: Enterprise-Technologieplattform.  Die Plattform enth√§lt ein Tool zum Entwickeln von Gesch√§ftsanwendungen sowie zur Laufzeit, mit dem Gesch√§ftsanwendungen in einer plattform√ºbergreifenden Umgebung arbeiten k√∂nnen. <br><br><h3>  Client-Server-Entwicklungsparadigma </h3><br>  Auf ‚Äû1C: Enterprise‚Äú erstellte Gesch√§ftsanwendungen arbeiten in der dreistufigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Client-Server-</a> Architektur ‚ÄûDBMS - Anwendungsserver - Client‚Äú.  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingebetteten Sprache 1C</a> geschriebener Anwendungscode kann auf dem Anwendungsserver oder auf dem Client ausgef√ºhrt werden.  Alle Arbeiten mit Anwendungsobjekten (Verzeichnisse, Dokumente usw.) sowie das Lesen und Schreiben in die Datenbank werden nur auf dem Server ausgef√ºhrt.  Die Funktionalit√§t der Formular- und Befehlsschnittstelle ist auch auf dem Server implementiert.  Der Kunde empf√§ngt, √∂ffnet und zeigt Formulare an, ‚Äûkommuniziert‚Äú mit dem Benutzer (Warnungen, Fragen ...), kleine Berechnungen in Formularen, die eine schnelle Reaktion erfordern (z. B. Multiplizieren des Preises mit dem Betrag), Arbeiten mit lokalen Dateien, Arbeiten mit Ger√§ten. <br><br>  Im Anwendungscode m√ºssen die Header der Prozeduren und Funktionen explizit angeben, wo der Code ausgef√ºhrt wird - unter Verwendung der Anweisungen &amp; Auf dem Client / &amp; Auf dem Server (&amp; AtClient / &amp; AtServer in der englischen Sprachversion).  Entwickler auf 1C werden mich jetzt korrigieren und sagen, dass es tats√§chlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehr</a> Richtlinien gibt, aber f√ºr uns ist dies jetzt nicht wesentlich. <br><br>  Servercode kann vom Clientcode aufgerufen werden, Clientcode kann jedoch nicht vom Servercode aufgerufen werden.  Dies ist eine grundlegende Einschr√§nkung, die wir aus mehreren Gr√ºnden vorgenommen haben.  Insbesondere, weil der Servercode so geschrieben werden muss, dass er gleicherma√üen ausgef√ºhrt wird, unabh√§ngig davon, wo er aufgerufen wird - vom Client oder vom Server.  Und wenn der Servercode von einem anderen Servercode aufgerufen wird, fehlt der Client als solcher.  Und weil w√§hrend der Ausf√ºhrung des Servercodes der Client, der ihn verursacht hat, geschlossen werden konnte, die Anwendung beenden konnte und der Server niemanden zum Aufrufen hatte. <br><br><img src="https://habrastorage.org/webt/3e/pb/eh/3epbeh_fc7t4yipr5halnamtbmg.png" alt="Bild"><br>  <b>Der Code, der den Klick auf die Schaltfl√§che verarbeitet: Der Serverprozeduraufruf vom Client funktioniert, der Clientprozeduraufruf vom Server nicht</b> <br><br>  Dies bedeutet, dass wir keine solche Methode haben, wenn wir beispielsweise vom Server eine Nachricht an die Clientanwendung √ºbertragen m√∂chten, dass die Erstellung eines Berichts mit langer Wiedergabe beendet wurde und der Bericht angezeigt werden kann.  Wir m√ºssen zum Beispiel Tricks aus dem Client-Code anwenden, um den Server regelm√§√üig abzufragen.  Dieser Ansatz belastet das System jedoch mit unn√∂tigen Anrufen und sieht in der Tat nicht sehr elegant aus. <br><br>  Wenn beispielsweise ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SIP-</a> Telefonanruf eingeht, m√ºssen Sie die Clientanwendung dar√ºber informieren, damit sie ihn anhand der Nummer des Anrufers in der Kontrahentendatenbank findet und die Benutzerinformationen √ºber den anrufenden Kontrahenten anzeigt.  Oder benachrichtigen Sie beispielsweise nach Eingang der Bestellung im Lager die Kundenanwendung des Kunden dar√ºber.  Im Allgemeinen gibt es viele F√§lle, in denen ein solcher Mechanismus n√ºtzlich w√§re. <br><br><h3>  Eigentlich inszenieren </h3><br>  Erstellen Sie eine Messaging-Engine.  Schnell, zuverl√§ssig, mit garantierter Zustellung und flexibler Suche nach Nachrichten.  Implementieren Sie basierend auf dem Mechanismus einen Messenger (Nachrichten, Videoanrufe), der in 1C-Anwendungen funktioniert. <br><br>  Entwerfen Sie ein horizontal skalierbares System.  Eine zunehmende Last sollte durch Erh√∂hen der Anzahl der Knoten geschlossen werden. <br><br><h2>  Implementierung </h2><br>  Wir haben uns entschieden, den Serverteil von SV nicht direkt in die 1C: Enterprise-Plattform einzubetten, sondern ihn als separates Produkt zu implementieren, dessen API aus dem 1C-Anwendungscode aufgerufen werden kann.  Dies geschah aus einer Reihe von Gr√ºnden, von denen der Hauptgrund darin bestand, dass ich den Austausch von Nachrichten zwischen verschiedenen 1C-Anwendungen (z. B. zwischen dem Amt f√ºr Handel und Rechnungswesen) erm√∂glichen wollte.  Verschiedene 1C-Anwendungen k√∂nnen auf verschiedenen Versionen der 1C: Enterprise-Plattform ausgef√ºhrt werden, auf verschiedenen Servern usw.  Unter solchen Bedingungen ist die Implementierung von CB als separates Produkt ‚Äûauf der Seite‚Äú von 1C-Installationen die optimale L√∂sung. <br><br>  Deshalb haben wir uns entschlossen, CB als separates Produkt herzustellen.  F√ºr kleine Unternehmen empfehlen wir die Verwendung des CB-Servers, den wir in unserer Cloud installiert haben (wss: //1cdialog.com), um den mit der lokalen Installation und Konfiguration des Servers verbundenen Overhead zu vermeiden.  Gro√ükunden k√∂nnen es jedoch f√ºr angebracht halten, ihren eigenen CB-Server in ihren Einrichtungen zu installieren.  Einen √§hnlichen Ansatz haben wir in unserem Cloud-basierten SaaS-Produkt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1cFresh verwendet</a> - es wird als Umlaufprodukt f√ºr die Installation durch Kunden freigegeben und auch in unserer Cloud <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://1cfresh.com/</a> bereitgestellt. <br><br><h3>  App </h3><br>  F√ºr den Lastenausgleich und die Fehlertoleranz stellen wir nicht eine Java-Anwendung bereit, sondern mehrere. Wir stellen ihnen einen Lastenausgleich vor.  Wenn Sie eine Nachricht von Knoten zu Knoten √ºbertragen m√ºssen, verwenden Sie Publish / Subscribe in Hazelcast. <br><br>  Kommunikation des Clients mit dem Server - per Websocket.  Es ist gut f√ºr Echtzeitsysteme geeignet. <br><br><h3>  Verteilter Cache </h3><br>  W√§hlen Sie zwischen Redis, Hazelcast und Ehcache.  Auf dem Hof ‚Äã‚Äã2015.  Redis hat gerade einen neuen Cluster gestartet (zu neu, be√§ngstigend), es gibt einen Sentinel mit einer Reihe von Einschr√§nkungen.  Ehcache wei√ü nicht, wie man sich zu einem Cluster zusammensetzt (diese Funktionalit√§t wurde sp√§ter angezeigt).  Wir haben uns f√ºr Hazelcast 3.4 entschieden. <br>  Hazelcast geht sofort zum Cluster.  Im Einzelknotenmodus ist es nicht sehr n√ºtzlich und kann nur als Cache passen - es wei√ü nicht, wie Daten auf die Festplatte ausgegeben werden sollen, es hat einen einzelnen Knoten verloren - es hat Daten verloren.  Wir stellen mehrere Hazelcasts bereit, zwischen denen wir wichtige Daten sichern.  Der Cache ist kein Backup - es ist nicht schade. <br><br>  F√ºr uns ist Hazelcast: <br><br><ul><li>  Repository von Benutzersitzungen.  Das Aufrufen einer Sitzung in der Datenbank ist jedes Mal sehr lang. Daher werden alle Sitzungen in Hazelcast gespeichert. </li><li>  Cache.  Suchen Sie nach einem Benutzerprofil - checken Sie den Cache ein.  Schrieb eine neue Nachricht - legte sie in den Cache. </li><li>  Themen zur Kommunikation von Anwendungsinstanzen.  Noda generiert ein Ereignis und f√ºgt es in das Hazelcast-Thema ein.  Andere Anwendungsknoten, die dieses Thema abonniert haben, empfangen und verarbeiten das Ereignis. </li><li>  Clustersperren.  Zum Beispiel erstellen wir eine Diskussion √ºber einen eindeutigen Schl√ºssel (Diskussions-Singleton im Rahmen der 1C-Datenbank): </li></ul><br><pre><code class="java hljs">conversationKeyChecker.check(<span class="hljs-string"><span class="hljs-string">""</span></span>); doInClusterLock(<span class="hljs-string"><span class="hljs-string">""</span></span>, () -&gt; { conversationKeyChecker.check(<span class="hljs-string"><span class="hljs-string">""</span></span>); createChannel(<span class="hljs-string"><span class="hljs-string">""</span></span>); });</code> </pre> <br>  √úberpr√ºft, ob kein Kanal vorhanden ist.  Sie nahmen das Schloss, √ºberpr√ºften es erneut und erstellten es.  Wenn Sie die Sperre nach dem Aufnehmen nicht √ºberpr√ºfen, besteht die M√∂glichkeit, dass in diesem Moment auch ein anderer Thread diese Sperre aktiviert hat und nun versucht, dieselbe Diskussion zu erstellen - diese ist jedoch bereits vorhanden.  Es ist unm√∂glich, eine Sperre durch synchronisierte oder √ºbliche Java-Sperre durchzuf√ºhren.  Durch die Basis - langsam und die Basis ist schade, durch Hazelcast - was Sie brauchen. <br><br><h3>  DBMS ausw√§hlen </h3><br>  Wir haben umfangreiche und erfolgreiche Erfahrungen in der Arbeit mit PostgreSQL und in der Zusammenarbeit mit den Entwicklern dieses DBMS. <br><br>  PostgreSQL ist mit einem Cluster nicht einfach - es verf√ºgt √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XC</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Citus</a> , aber im Allgemeinen handelt es sich nicht um noSQL, die sofort skalierbar sind.  NoSQL wurde nicht als Haupt-Repository angesehen, es war genug, dass wir Hazelcast genommen haben, mit dem wir vorher nicht gearbeitet hatten. <br><br>  Da Sie eine relationale Datenbank skalieren m√ºssen, bedeutet dies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sharding</a> .  Wie Sie wissen, teilen wir beim Sharding die Datenbank in separate Teile auf, sodass jeder von ihnen auf einen separaten Server verschoben werden kann. <br><br>  Die erste Version unseres Shardings implizierte die M√∂glichkeit, jede der Tabellen unserer Anwendung in unterschiedlichen Anteilen auf verschiedene Server zu verteilen.  Es gibt viele Nachrichten auf Server A - bitte √ºbertragen wir einen Teil dieser Tabelle auf Server B. Bei einer solchen L√∂sung ging es nur um vorzeitige Optimierung. Deshalb haben wir uns entschlossen, uns auf einen mandantenf√§higen Ansatz zu beschr√§nken. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu</a> Mandantenf√§higkeit finden Sie beispielsweise auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Citus Data-</a> Website. <br><br>  In SV gibt es Konzepte f√ºr Anwendung und Teilnehmer.  Eine Anwendung ist eine spezifische Installation einer Gesch√§ftsanwendung wie ERP oder Buchhaltung mit ihren Benutzern und Gesch√§ftsdaten.  Ein Abonnent ist eine Organisation oder eine Person, in deren Namen die Anwendung auf dem CB-Server registriert ist.  Ein Teilnehmer kann mehrere Anwendungen registrieren und diese Anwendungen k√∂nnen Nachrichten miteinander austauschen.  Der Abonnent wurde auch der Mieter in unserem System.  Nachrichten von mehreren Teilnehmern k√∂nnen sich in einer physischen Basis befinden.  Wenn wir feststellen, dass ein Abonnent viel Datenverkehr generiert, leiten wir ihn zu einer separaten physischen Basis (oder sogar zu einem separaten Datenbankserver). <br><br>  Wir haben eine Hauptdatenbank, in der eine Routing-Tabelle mit Informationen zum Speicherort aller Teilnehmerdatenbanken gespeichert ist. <br><br><img src="https://habrastorage.org/webt/yf/3k/bo/yf3kboqvabg3ljf791sdlpn0zay.png" alt="Bild"><br><br>  Damit die Hauptdatenbank keinen Engpass darstellt, behalten wir die Routing-Tabelle (und andere h√§ufig angeforderte Daten) im Cache. <br><br>  Wenn die Abonnentendatenbank langsamer wird, werden wir sie in Partitionen aufteilen.  In anderen Projekten verwenden wir pg_pathman, um gro√üe Tabellen zu partitionieren. <br><br>  Da der Verlust von Benutzernachrichten schlecht ist, unterst√ºtzen wir unsere Datenbanken mit Replikaten.  Durch die Kombination von synchronen und asynchronen Replikaten k√∂nnen Sie bei Verlust der Hauptdatenbank sicher sein.  Ein Nachrichtenverlust tritt nur bei gleichzeitigem Ausfall der Hauptdatenbank und ihrer synchronen Replik auf. <br><br>  Wenn das synchrone Replikat verloren geht, wird das asynchrone Replikat synchron. <br>  Wenn die Hauptdatenbank verloren geht, wird das synchrone Replikat zur Hauptdatenbank, das asynchrone Replikat zum synchronen Replikat. <br><br><h3>  Elasticsearch f√ºr die Suche </h3><br>  Da CB unter anderem auch ein Messenger ist, ben√∂tigen Sie hier eine schnelle, bequeme und flexible Suche unter Ber√ºcksichtigung der Morphologie nach ungenauen √úbereinstimmungen.  Wir haben beschlossen, das Rad nicht neu zu erfinden und die kostenlose Elasticsearch-Suchmaschine zu verwenden, die auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lucene-</a> Bibliothek basiert.  Wir stellen Elasticsearch auch in einem Cluster (Stammdaten - Daten) bereit, um Probleme bei Ausfall von Anwendungsknoten zu beseitigen. <br><br>  Auf Github haben wir ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugin der russischen Morphologie</a> f√ºr Elasticsearch gefunden und verwenden es.  Im Elasticsearch-Index speichern wir die Wurzeln von W√∂rtern (die das Plugin definiert) und N-Gramm.  W√§hrend der Benutzer den zu suchenden Text eingibt, suchen wir den eingegebenen Text unter den N-Gramm.  Bei der Speicherung im Index wird das Wort "Texte" in folgende N-Gramm unterteilt: <br><br>  [diese, tech, tex, text, texte, ek, eks, ekst, eksts, ks, kst, kst, kst, st, st, du], <br><br>  Und auch die Wurzel des Wortes "Text" wird gespeichert.  Mit diesem Ansatz k√∂nnen Sie sowohl am Anfang, in der Mitte als auch am Ende des Wortes suchen. <br><br><h2>  Gesamtbild </h2><br><img src="https://habrastorage.org/webt/wo/w3/ke/wow3ke8dq1cqrb_ujsjm4uhevfm.png" alt="Bild"><br>  Wiederholen Sie das Bild vom Anfang des Artikels, aber mit Erkl√§rungen: <br><br><ul><li>  Internet Balancer;  Wir haben Nginx, es kann jeder sein. </li><li>  Instanzen von Java-Anwendungen kommunizieren √ºber Hazelcast miteinander. </li><li>  F√ºr die Arbeit mit einem Web-Socket verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netty</a> . </li><li>  In Java 8 geschriebene Java-Anwendung besteht aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OSGi-</a> Bundles.  Die Pl√§ne - Migration auf Java 10 und √úbergang zu Modulen. </li></ul><br><h2>  Entwicklung und Erprobung </h2><br>  Bei der Entwicklung und Erprobung von CB sind wir auf eine Reihe interessanter Merkmale der von uns verwendeten Produkte gesto√üen. <br><br><h3>  Lasttests und Speicherlecks </h3><br>  Die Freisetzung jeder CB-Freisetzung ist ein Stresstest.  Es war erfolgreich, als: <br><br><ul><li>  Der Test dauerte mehrere Tage und es gab keinen Denial-of-Service </li><li>  Die Reaktionszeit f√ºr Schl√ºsseloperationen hat einen angenehmen Schwellenwert nicht √ºberschritten </li><li>  Der Leistungsabfall gegen√ºber der Vorg√§ngerversion betr√§gt nicht mehr als 10% </li></ul><br>  Wir f√ºllen die Testbasis mit Daten - daf√ºr erhalten wir Informationen √ºber den aktivsten Abonnenten vom Produktionsserver, multiplizieren seine Zahlen mit 5 (Anzahl der Nachrichten, Diskussionen, Benutzer) und testen. <br><br>  Wir f√ºhren Lasttests des Interaktionssystems in drei Konfigurationen durch: <br><br><ol><li>  Stresstest </li><li>  Nur Verbindungen </li><li>  Abonnentenregistrierung </li></ol><br>  W√§hrend des Stresstests starten wir mehrere hundert Threads, die das System ohne Unterbrechung laden: Nachrichten schreiben, Diskussionen erstellen, eine Liste mit Nachrichten abrufen.  Wir simulieren die Aktionen normaler Benutzer (eine Liste meiner ungelesenen Nachrichten abrufen, an jemanden schreiben) und Softwarel√∂sungen (ein Paket mit einer anderen Konfiguration √ºbertragen, die Benachrichtigung verarbeiten). <br><br>  Dies ist beispielsweise Teil des Stresstests: <br><br><ul><li>  Der Benutzer meldet sich an. <br><ul><li>  Fordert ungelesene Diskussionen an </li><li>  50% Chance, Nachrichten zu lesen </li><li>  Mit 50% Wahrscheinlichkeit schreibt Nachrichten </li><li>  N√§chster Benutzer: <br><ul><li>  Mit 20% Wahrscheinlichkeit entsteht eine neue Diskussion. </li><li>  W√§hlt zuf√§llig eine seiner Diskussionen aus </li><li>  Geht hinein </li><li>  Fordert Nachrichten und Benutzerprofile an </li><li>  Erstellt aus dieser Diskussion f√ºnf Nachrichten, die an zuf√§llige Benutzer gerichtet sind. </li><li>  Aus der Diskussion </li><li>  Wiederholt 20 mal </li><li>  Meldet sich ab und kehrt zum Anfang des Skripts zur√ºck </li></ul><br></li><li>  Der Chat-Bot betritt das System (emuliert den Austausch von Nachrichten aus dem Code der angewendeten L√∂sungen). <br><br><ul><li>  Mit 50% Wahrscheinlichkeit entsteht ein neuer Kanal f√ºr den Datenaustausch (Sonderdiskussion) </li><li>  Mit einer Wahrscheinlichkeit von 50% wird eine Nachricht in einen der vorhandenen Kan√§le geschrieben </li></ul><br></li></ul><br></li></ul><br>  Das Szenario "Nur Verbindungen" wurde aus einem bestimmten Grund angezeigt.  Es gibt eine Situation: Benutzer haben das System angeschlossen, sind aber noch nicht involviert.  Jeder Benutzer schaltet morgens um 09:00 Uhr den Computer ein, stellt eine Verbindung zum Server her und ist stumm.  Diese Typen sind gef√§hrlich, es gibt viele von ihnen - von den Paketen haben sie nur PING / PONG, aber sie behalten die Verbindung zum Server (sie k√∂nnen sie nicht behalten - und pl√∂tzlich eine neue Nachricht).  Der Test gibt die Situation wieder, in der innerhalb einer halben Stunde eine gro√üe Anzahl solcher Benutzer versucht, sich beim System anzumelden.  Es sieht aus wie ein Stresstest, konzentriert sich aber genau auf diesen ersten Eingang - damit es keine Fehler gibt (eine Person benutzt das System nicht, aber es f√§llt bereits ab - es ist schwierig, sich etwas Schlimmeres auszudenken). <br><br>  Das Abonnentenregistrierungsszenario stammt aus dem ersten Start.  Wir haben einen Stresstest durchgef√ºhrt und waren uns sicher, dass das System in der Korrespondenz nicht langsamer wird.  Aber die Benutzer gingen und die Registrierung begann in einer Zeit√ºberschreitung abzufallen.  Bei der Registrierung haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">/ dev / random verwendet</a> , was an die Entropie des Systems gebunden ist.  Der Server konnte nicht gen√ºgend Entropie ansammeln und erstarrte zehn Sekunden lang, als er ein neues SecureRandom anforderte.  Es gibt viele M√∂glichkeiten, aus dieser Situation herauszukommen, zum Beispiel: Wechseln Sie zu weniger sicher / dev / urandom, setzen Sie eine spezielle Karte, die Entropie erzeugt, generieren Sie Zufallszahlen im Voraus und speichern Sie sie im Pool.  Wir haben das Problem vor√ºbergehend mit einem Pool geschlossen, aber seitdem f√ºhren wir einen separaten Test zur Registrierung neuer Abonnenten durch. <br><br>  Als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lastgenerator verwenden</a> wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JMeter</a> .  Er wei√ü nicht, wie man mit einem Web-Socket arbeitet, ein Plug-In wird ben√∂tigt.  Die ersten Suchergebnisse f√ºr "jmeter websocket" sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel mit BlazeMeter</a> , die ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugin von Maciej Zaleski</a> empfehlen. <br><br>  Mit ihm beschlossen wir zu beginnen. <br><br>  Fast unmittelbar nach Beginn der ernsthaften Tests stellten wir fest, dass in JMeter Speicherlecks auftraten. <br><br>  Das Plugin ist eine separate gro√üe Geschichte, mit 176 Sternen hat es 132 Gabeln auf Github.  Der Autor selbst hat sich seit 2015 nicht mehr dazu verpflichtet (wir haben es 2015 aufgenommen, dann gab dies keinen Verdacht), mehrere Github-Probleme mit Speicherlecks, 7 nicht geschlossene Pull-Anfragen. <br>  Wenn Sie sich entscheiden, Lasttests mit diesem Plugin durchzuf√ºhren, beachten Sie die folgenden Diskussionen: <br><br><ol><li>  In einer Multithread-Umgebung wurde die √ºbliche LinkedList verwendet, sodass sie zur Laufzeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NPE</a> erhielten.  Es wird entweder durch Umschalten auf ConcurrentLinkedDeque oder durch synchronisierte Bl√∂cke gel√∂st.  Sie haben die erste Option f√ºr sich selbst ausgew√§hlt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/maciejzaleski/JMeter-WebSocketSampler/issues/43</a> ). </li><li>  Speicherverlust, Verbindung trennen l√∂scht keine Verbindungsinformationen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/maciejzaleski/JMeter-WebSocketSampler/issues/44</a> ). </li><li>  Im Streaming-Modus (wenn der Web-Socket am Ende des Beispiels nicht geschlossen wird, aber im Plan weiter verwendet wird) funktionieren die Antwortmuster ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/maciejzaleski/JMeter-WebSocketSampler/issues/19</a> ) nicht. </li></ol><br>  Dies ist einer von denen auf Github.  Was haben wir getan: <br><br><ol><li>  Sie nahmen die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gabel Elyran Kogan</a> (@elyrank) - die Probleme 1 und 3 wurden darin behoben </li><li>  Problem 2 gel√∂st </li><li>  Der Steg wurde vom 9.2.14 auf den 9.3.12 aktualisiert </li><li>  Wrapped SimpleDateFormat in ThreadLocal;  SimpleDateFormat ist nicht threadsicher, was zu Laufzeit-NPE f√ºhrte </li><li>  Ein weiterer Speicherverlust wurde behoben (die Verbindung wurde beim Trennen falsch geschlossen). </li></ol><br>  Und doch flie√üt es! <br><br>  Die Erinnerung endete nicht an einem Tag, sondern an zwei.  Es blieb absolut keine Zeit mehr, sie beschlossen, weniger Threads auszuf√ºhren, aber auf vier Agenten.  Das h√§tte f√ºr mindestens eine Woche reichen sollen. <br><br>  Zwei Tage sind vergangen ... <br><br>  Jetzt ging Hazelcast die Erinnerung aus.  In den Protokollen wurde deutlich, dass sich Hazelcast nach einigen Testtagen √ºber einen Speichermangel beschwert. Nach einer Weile f√§llt der Cluster auseinander und die Knoten sterben weiterhin einzeln ab.  Wir haben JVisualVM mit Hazelcast verbunden und eine ‚Äûaufsteigende S√§ge‚Äú gesehen - er rief regelm√§√üig GC an, konnte aber sein Ged√§chtnis nicht l√∂schen. <br><br><img src="https://habrastorage.org/webt/ha/uc/5y/hauc5ydqebpmxtfirqalulaandi.png" alt="Bild"><br><br>  Es stellte sich heraus, dass in Hazelcast 3.4 beim Entfernen von map / multiMap (map.destroy ()) der Speicher nicht vollst√§ndig freigegeben wird: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/hazelcast/hazelcast/issues/6317</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/hazelcast/hazelcast/issues/4888</a> <br><br>  Jetzt ist der Fehler in 3.5 behoben, aber dann war es ein Problem.  Wir haben eine neue MultiMap mit dynamischen Namen erstellt und gem√§√ü unserer Logik gel√∂scht.  Der Code sah ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authentication auth, String sub)</span></span></span><span class="hljs-function"> </span></span>{ MultiMap&lt;UUID, Authentication&gt; sessions = instance.getMultiMap(sub); sessions.put(auth.getUserId(), auth); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leave</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authentication auth, String sub)</span></span></span><span class="hljs-function"> </span></span>{ MultiMap&lt;UUID, Authentication&gt; sessions = instance.getMultiMap(sub); sessions.remove(auth.getUserId(), auth); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sessions.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { sessions.destroy(); } }</code> </pre> <br>  Rufen Sie an: <br><br><pre> <code class="java hljs">service.join(auth1, <span class="hljs-string"><span class="hljs-string">"____UUID1"</span></span>); service.join(auth2, <span class="hljs-string"><span class="hljs-string">"____UUID1"</span></span>);</code> </pre> <br>  multiMap wurde f√ºr jedes Abonnement erstellt und gel√∂scht, wenn es nicht ben√∂tigt wurde.  Wir haben beschlossen, Map &lt;String, Set&gt; zu starten. Der Schl√ºssel ist der Name des Abonnements und die Werte sind die Kennungen der Sitzungen (von denen Sie bei Bedarf die Benutzer-IDs erhalten k√∂nnen). <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authentication auth, String sub)</span></span></span><span class="hljs-function"> </span></span>{ addValueToMap(sub, auth.getSessionId()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leave</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authentication auth, String sub)</span></span></span><span class="hljs-function"> </span></span>{ removeValueFromMap(sub, auth.getSessionId()); }</code> </pre> <br>  Die Diagramme wurden gerade ausgerichtet. <br><br><img src="https://habrastorage.org/webt/li/_z/ai/li_zaiochcpbgvviybycfvzslz4.png" alt="Bild"><br><br><h4>  Was haben wir noch √ºber Stresstests gelernt? </h4><br><ol><li>  JSR223 muss in einen groovigen und aktivierten Kompilierungscache geschrieben werden - dies ist viel schneller.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> </li><li>  Jmeter-Plugins-Diagramme sind leichter zu verstehen als Standard.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> </li></ol><br><br><h3>  √úber unsere Erfahrungen mit Hazelcast </h3><br>  Hazelcast war ein neues Produkt f√ºr uns. Wir haben ab Version 3.4.1 damit begonnen. Jetzt hat unser Produktionsserver Version 3.9.2 (zum Zeitpunkt des Schreibens ist die neueste Version von Hazelcast 3.10). <br><br><h4>  ID-Generierung </h4><br>  Wir haben mit ganzzahligen Bezeichnern begonnen.  Stellen wir uns vor, wir brauchen ein weiteres Long f√ºr eine neue Entit√§t.  Die Sequenz passt nicht in die Datenbank, Tabellen sind am Sharding beteiligt. Es stellt sich heraus, dass in DB1 eine Nachrichten-ID = 1 und in DB2 eine Nachrichten-ID = 1 vorhanden ist. Sie k√∂nnen eine solche ID auch in Haastcast nicht in Elasticsearch einf√ºgen. Das Schlimmste ist jedoch, wenn Sie die Daten reduzieren m√∂chten von zwei Datenbanken in eine (z. B. die Entscheidung, dass eine Datenbank f√ºr diese Abonnenten ausreicht).  Sie k√∂nnen mehrere AtomicLongs in Hazelcast erstellen und den Z√§hler dort belassen. Die Leistung beim Abrufen einer neuen ID betr√§gt incrementAndGet plus die Zeit f√ºr eine Anforderung in Hazelcast.  Aber Hazelcast hat etwas Optimaleres - FlakeIdGenerator.  Jeder Kunde erh√§lt bei Kontakt einen ID-Bereich, z. B. den ersten von 1 bis 10.000, den zweiten von 10.001 bis 20.000 usw.  Jetzt kann der Client neue Kennungen unabh√§ngig voneinander ausgeben, bis der an ihn ausgegebene Bereich endet.  Es funktioniert schnell, aber wenn Sie die Anwendung (und den Hazelcast-Client) neu starten, beginnt eine neue Sequenz - daher die L√ºcken usw.  Dar√ºber hinaus ist den Entwicklern nicht klar, warum IDs ganzzahlig sind, aber sie gehen so unterschiedlich vor.  Wir haben alle gewogen und auf UUIDs umgestellt. <br><br>  √úbrigens, f√ºr diejenigen, die wie Twitter sein wollen, gibt es eine solche Snowcast-Bibliothek - dies ist eine Snowflake-Implementierung zus√§tzlich zu Hazelcast.  Sie k√∂nnen es hier sehen: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/noctarius/snowcast</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/twitter/snowflake</a> <br><br>  Aber wir haben ihre H√§nde nicht erreicht. <br><br><h4>  TransactionalMap.replace </h4><br>  Eine weitere √úberraschung: TransactionalMap.replace funktioniert nicht.  Hier ist ein Test: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceInMap_putsAndGetsInsideTransaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ hazelcastInstance.executeTransaction(context -&gt; { HazelcastTransactionContextHolder.setContext(context); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { context.getMap(<span class="hljs-string"><span class="hljs-string">"map"</span></span>).put(<span class="hljs-string"><span class="hljs-string">"key"</span></span>, <span class="hljs-string"><span class="hljs-string">"oldValue"</span></span>); context.getMap(<span class="hljs-string"><span class="hljs-string">"map"</span></span>).replace(<span class="hljs-string"><span class="hljs-string">"key"</span></span>, <span class="hljs-string"><span class="hljs-string">"oldValue"</span></span>, <span class="hljs-string"><span class="hljs-string">"newValue"</span></span>); String value = (String) context.getMap(<span class="hljs-string"><span class="hljs-string">"map"</span></span>).get(<span class="hljs-string"><span class="hljs-string">"key"</span></span>); assertEquals(<span class="hljs-string"><span class="hljs-string">"newValue"</span></span>, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { HazelcastTransactionContextHolder.clearContext(); } }); } Expected : newValue Actual : oldValue</code> </pre> <br>  Ich musste meinen Ersatz mit getForUpdate schreiben: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceInMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String mapName, K key, V oldValue, V newValue)</span></span></span><span class="hljs-function"> </span></span>{ TransactionalTaskContext context = HazelcastTransactionContextHolder.getContext(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { log.trace(<span class="hljs-string"><span class="hljs-string">"[CACHE] Replacing value in a transactional map"</span></span>); TransactionalMap&lt;K, V&gt; map = context.getMap(mapName); V value = map.getForUpdate(key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldValue.equals(value)) { map.put(key, newValue); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } log.trace(<span class="hljs-string"><span class="hljs-string">"[CACHE] Replacing value in a not transactional map"</span></span>); IMap&lt;K, V&gt; map = hazelcastInstance.getMap(mapName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map.replace(key, oldValue, newValue); }</code> </pre> <br>  Testen Sie nicht nur regul√§re Datenstrukturen, sondern auch deren Transaktionsversionen.  Es kommt vor, dass IMap funktioniert, aber TransactionalMap ist weg. <br><br><h4>  Bringen Sie eine neue JAR ohne Ausfallzeiten an </h4><br>  Zuerst haben wir beschlossen, Objekte unserer Klassen in Hazelcast aufzunehmen.  Zum Beispiel haben wir eine Klassenanwendung, die wir speichern und lesen m√∂chten.  Speichern: <br><br><pre> <code class="java hljs">IMap&lt;UUID, Application&gt; map = hazelcastInstance.getMap(<span class="hljs-string"><span class="hljs-string">"application"</span></span>); map.set(id, application);</code> </pre> <br>  Wir lesen: <br><br><pre> <code class="java hljs">IMap&lt;UUID, Application&gt; map = hazelcastInstance.getMap(<span class="hljs-string"><span class="hljs-string">"application"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map.get(id);</code> </pre> <br>  Alles arbeitet.  Dann haben wir beschlossen, einen Index in Hazelcast zu erstellen, um danach zu suchen: <br><br><pre> <code class="java hljs">map.addIndex(<span class="hljs-string"><span class="hljs-string">"subscriberId"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>);</code> </pre> <br>  Beim Schreiben einer neuen Entit√§t erhielten sie eine ClassNotFoundException.  Hazelcast versuchte den Index zu erg√§nzen, wusste aber nichts √ºber unsere Klasse und wollte, dass sie eine JAR mit dieser Klasse hat.  Wir haben das getan, alles hat funktioniert, aber ein neues Problem ist aufgetreten: Wie kann man die JAR aktualisieren, ohne den Cluster vollst√§ndig zu stoppen?  Hazelcast holt die neue JAR w√§hrend eines podweisen Upgrades nicht ab.  In diesem Moment haben wir beschlossen, dass wir sehr gut leben k√∂nnen, ohne nach Index zu suchen.  Wenn Sie Hazelcast als Schl√ºsselwertspeicher verwenden, funktioniert dann alles?  Nicht wirklich.  Auch hier das unterschiedliche Verhalten von IMap und TransactionalMap.  Wo IMap keine Rolle spielt, gibt TransactionalMap einen Fehler aus. <br><br>  IMap  Wir schreiben 5000 Objekte, lesen es.  Alles wird erwartet. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get5000</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ IMap&lt;UUID, Application&gt; map = hazelcastInstance.getMap(<span class="hljs-string"><span class="hljs-string">"application"</span></span>); UUID subscriberId = UUID.randomUUID(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5000</span></span>; i++) { UUID id = UUID.randomUUID(); String title = RandomStringUtils.random(<span class="hljs-number"><span class="hljs-number">5</span></span>); Application application = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Application(id, title, subscriberId); map.set(id, application); Application retrieved = map.get(id); assertEquals(id, retrieved.getId()); } }</code> </pre> <br>  Und es funktioniert nicht in der Transaktion, wir erhalten eine ClassNotFoundException: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_transaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ IMap&lt;UUID, Application&gt; map = hazelcastInstance.getMap(<span class="hljs-string"><span class="hljs-string">"application_t"</span></span>); UUID subscriberId = UUID.randomUUID(); UUID id = UUID.randomUUID(); Application application = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Application(id, <span class="hljs-string"><span class="hljs-string">"qwer"</span></span>, subscriberId); map.set(id, application); Application retrievedOutside = map.get(id); assertEquals(id, retrievedOutside.getId()); hazelcastInstance.executeTransaction(context -&gt; { HazelcastTransactionContextHolder.setContext(context); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { TransactionalMap&lt;UUID, Application&gt; transactionalMap = context.getMap(<span class="hljs-string"><span class="hljs-string">"application_t"</span></span>); Application retrievedInside = transactionalMap.get(id); assertEquals(id, retrievedInside.getId()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { HazelcastTransactionContextHolder.clearContext(); } }); }</code> </pre> <br>  In 3.8 wurde der Mechanismus zur Bereitstellung von Benutzerklassen angezeigt.  Sie k√∂nnen einen Hauptknoten zuweisen und die JAR-Datei darauf aktualisieren. <br><br>  Jetzt haben wir den Ansatz komplett ge√§ndert: Wir serialisieren ihn in JSON und speichern ihn in Hazelcast.  Hazelcast muss die Struktur unserer Klassen nicht kennen, aber wir k√∂nnen ohne Ausfallzeiten aktualisieren.  Die Versionierung von Dom√§nenobjekten wird von der Anwendung gesteuert.  Verschiedene Versionen der Anwendung k√∂nnen gleichzeitig gestartet werden, und es ist m√∂glich, dass eine neue Anwendung Objekte mit neuen Feldern schreibt, die alte jedoch nichts √ºber diese Felder wei√ü.  Gleichzeitig liest die neue Anwendung Objekte aus, die von der alten Anwendung aufgezeichnet wurden und in denen keine neuen Felder vorhanden sind.  Wir behandeln solche Situationen innerhalb der Anwendung, aber der Einfachheit halber √§ndern oder l√∂schen wir keine Felder, sondern erweitern Klassen nur durch Hinzuf√ºgen neuer Felder. <br><br><h3>  Wie wir hohe Leistung bieten </h3><br><h4>  Vier Reisen nach Hazelcast - gut, zwei in die Datenbank - schlecht </h4><br>  Das Aufrufen von Daten im Cache ist immer besser als in der Datenbank, Sie m√∂chten jedoch keine nicht beanspruchten Datens√§tze speichern.  Die Entscheidung dar√ºber, was zwischengespeichert werden soll, verschieben wir auf die letzte Entwicklungsstufe.  Wenn die neue Funktionalit√§t codiert ist, aktivieren wir PostgreSQL, um alle Abfragen zu protokollieren (log_min_duration_statement auf 0) und 20 Minuten lang Lasttests durchzuf√ºhren. Mithilfe gesammelter Protokolle k√∂nnen Dienstprogramme wie pgFouine und pgBadger Analyseberichte erstellen.  In Berichten suchen wir haupts√§chlich nach langsamen und h√§ufigen Abfragen.  F√ºr langsame Abfragen erstellen wir einen Ausf√ºhrungsplan (EXPLAIN) und bewerten, ob eine solche Abfrage beschleunigt werden kann.  H√§ufige Anforderungen f√ºr dieselben Eingabedaten werden gut zwischengespeichert.  Wir versuchen, Anfragen "flach" zu halten, eine Tabelle pro Anfrage. <br><br><h2>  Bedienung </h2><br>  SV als Onlinedienst wurde im Fr√ºhjahr 2017 gestartet, als im November 2017 ein separates SV-Produkt ver√∂ffentlicht wurde (zu diesem Zeitpunkt im Beta-Status). <br><br>  √úber einen Zeitraum von mehr als einem Jahr traten keine ernsthaften Probleme beim Betrieb des Onlinedienstes von CB auf.  Wir √ºberwachen den Onlinedienst √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zabbix</a> , sammeln und stellen ihn bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bamboo bereit</a> . <br><br>  Das CB-Server-Distributionskit wird in Form von nativen Paketen geliefert: RPM, DEB, MSI.  Au√üerdem bieten wir f√ºr Windows ein einziges Installationsprogramm in Form einer EXE-Datei an, mit der der Server, Hazelcast und Elasticsearch auf einem Computer installiert werden.  Zuerst haben wir diese Version der Installation "Demo" genannt, aber jetzt wurde klar, dass dies die beliebteste Bereitstellungsoption ist. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422903/">https://habr.com/ru/post/de422903/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422893/index.html">Node.js-Handbuch, Teil 1: Allgemeine Informationen und erste Schritte</a></li>
<li><a href="../de422895/index.html">Google m√∂chte URLs t√∂ten</a></li>
<li><a href="../de422897/index.html">Schlecht, aber meins: wie man wirklich schreckliches CSS schreibt</a></li>
<li><a href="../de422899/index.html">Unter wachsamer Aufsicht: So √ºberwachen Sie Hoster-Tarife und halten den VPS-Katalog auf dem neuesten Stand</a></li>
<li><a href="../de422901/index.html">Ein Herzfrequenzmesser f√ºr Putin oder was ist ein Ritmer?</a></li>
<li><a href="../de422905/index.html">Aber du sagst Ceph ... ist er so gut?</a></li>
<li><a href="../de422907/index.html">Kurzreferenz f√ºr Roboterstaubsauger 2018</a></li>
<li><a href="../de422909/index.html">10 beliebtesten 404 Festival Retro Talk Videos</a></li>
<li><a href="../de422915/index.html">Ich suche einen Senior ohne B√ºro und Cookies: Wie haben wir eine Suche nach Mitarbeitern organisiert, die zu 100% entfernt sind?</a></li>
<li><a href="../de422917/index.html">Ich habe keinen Mund, aber ich muss schreien. √úberlegungen zu KI und Ethik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>