<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏽 ☣️ 🕢 Wie und warum haben wir einen hoch geladenen skalierbaren Dienst für 1C geschrieben: Enterprise: Java, PostgreSQL, Hazelcast 💄 📑 👩🏿‍🤝‍👩🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir darüber sprechen, wie und warum wir das Interaktionssystem entwickelt haben - einen Mechanismus, der Informationen zwisch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie und warum haben wir einen hoch geladenen skalierbaren Dienst für 1C geschrieben: Enterprise: Java, PostgreSQL, Hazelcast</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/1c/blog/422903/">  In diesem Artikel werden wir darüber sprechen, wie und warum wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Interaktionssystem</a> entwickelt haben - einen Mechanismus, der Informationen zwischen Clientanwendungen und 1C: Enterprise-Servern überträgt - von der Einstellung der Aufgabe bis zum Durchdenken der Architektur- und Implementierungsdetails. <br><br>  Das Interaktionssystem (im Folgenden als CB bezeichnet) ist ein verteiltes fehlertolerantes Nachrichtensystem mit garantierter Zustellung.  SV ist als hoch ausgelasteter Dienst mit hoher Skalierbarkeit konzipiert und sowohl als Onlinedienst (von 1C bereitgestellt) als auch als Verbreitungsprodukt verfügbar, das auf seinen Serverkapazitäten bereitgestellt werden kann. <br><br>  CB verwendet verteilten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hazelcast-</a> Speicher und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elasticsearch-</a> Suchmaschine.  Wir werden auch über Java sprechen und wie wir PostgreSQL horizontal skalieren. <br><img src="https://habrastorage.org/webt/gh/nq/sq/ghnqsqdgkb0i4ze_7ig8blrfilk.png" alt="Bild"><br><a name="habracut"></a><br><br><h2>  Erklärung des Problems </h2><br>  Um zu verdeutlichen, warum wir das Interaktionssystem entwickelt haben, möchte ich Ihnen ein wenig darüber erzählen, wie die Entwicklung von Geschäftsanwendungen in 1C funktioniert. <br><br>  Zunächst ein wenig über uns für diejenigen, die noch nicht wissen, was wir tun :) Wir erstellen die 1C: Enterprise-Technologieplattform.  Die Plattform enthält ein Tool zum Entwickeln von Geschäftsanwendungen sowie zur Laufzeit, mit dem Geschäftsanwendungen in einer plattformübergreifenden Umgebung arbeiten können. <br><br><h3>  Client-Server-Entwicklungsparadigma </h3><br>  Auf „1C: Enterprise“ erstellte Geschäftsanwendungen arbeiten in der dreistufigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Client-Server-</a> Architektur „DBMS - Anwendungsserver - Client“.  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingebetteten Sprache 1C</a> geschriebener Anwendungscode kann auf dem Anwendungsserver oder auf dem Client ausgeführt werden.  Alle Arbeiten mit Anwendungsobjekten (Verzeichnisse, Dokumente usw.) sowie das Lesen und Schreiben in die Datenbank werden nur auf dem Server ausgeführt.  Die Funktionalität der Formular- und Befehlsschnittstelle ist auch auf dem Server implementiert.  Der Kunde empfängt, öffnet und zeigt Formulare an, „kommuniziert“ mit dem Benutzer (Warnungen, Fragen ...), kleine Berechnungen in Formularen, die eine schnelle Reaktion erfordern (z. B. Multiplizieren des Preises mit dem Betrag), Arbeiten mit lokalen Dateien, Arbeiten mit Geräten. <br><br>  Im Anwendungscode müssen die Header der Prozeduren und Funktionen explizit angeben, wo der Code ausgeführt wird - unter Verwendung der Anweisungen &amp; Auf dem Client / &amp; Auf dem Server (&amp; AtClient / &amp; AtServer in der englischen Sprachversion).  Entwickler auf 1C werden mich jetzt korrigieren und sagen, dass es tatsächlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehr</a> Richtlinien gibt, aber für uns ist dies jetzt nicht wesentlich. <br><br>  Servercode kann vom Clientcode aufgerufen werden, Clientcode kann jedoch nicht vom Servercode aufgerufen werden.  Dies ist eine grundlegende Einschränkung, die wir aus mehreren Gründen vorgenommen haben.  Insbesondere, weil der Servercode so geschrieben werden muss, dass er gleichermaßen ausgeführt wird, unabhängig davon, wo er aufgerufen wird - vom Client oder vom Server.  Und wenn der Servercode von einem anderen Servercode aufgerufen wird, fehlt der Client als solcher.  Und weil während der Ausführung des Servercodes der Client, der ihn verursacht hat, geschlossen werden konnte, die Anwendung beenden konnte und der Server niemanden zum Aufrufen hatte. <br><br><img src="https://habrastorage.org/webt/3e/pb/eh/3epbeh_fc7t4yipr5halnamtbmg.png" alt="Bild"><br>  <b>Der Code, der den Klick auf die Schaltfläche verarbeitet: Der Serverprozeduraufruf vom Client funktioniert, der Clientprozeduraufruf vom Server nicht</b> <br><br>  Dies bedeutet, dass wir keine solche Methode haben, wenn wir beispielsweise vom Server eine Nachricht an die Clientanwendung übertragen möchten, dass die Erstellung eines Berichts mit langer Wiedergabe beendet wurde und der Bericht angezeigt werden kann.  Wir müssen zum Beispiel Tricks aus dem Client-Code anwenden, um den Server regelmäßig abzufragen.  Dieser Ansatz belastet das System jedoch mit unnötigen Anrufen und sieht in der Tat nicht sehr elegant aus. <br><br>  Wenn beispielsweise ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SIP-</a> Telefonanruf eingeht, müssen Sie die Clientanwendung darüber informieren, damit sie ihn anhand der Nummer des Anrufers in der Kontrahentendatenbank findet und die Benutzerinformationen über den anrufenden Kontrahenten anzeigt.  Oder benachrichtigen Sie beispielsweise nach Eingang der Bestellung im Lager die Kundenanwendung des Kunden darüber.  Im Allgemeinen gibt es viele Fälle, in denen ein solcher Mechanismus nützlich wäre. <br><br><h3>  Eigentlich inszenieren </h3><br>  Erstellen Sie eine Messaging-Engine.  Schnell, zuverlässig, mit garantierter Zustellung und flexibler Suche nach Nachrichten.  Implementieren Sie basierend auf dem Mechanismus einen Messenger (Nachrichten, Videoanrufe), der in 1C-Anwendungen funktioniert. <br><br>  Entwerfen Sie ein horizontal skalierbares System.  Eine zunehmende Last sollte durch Erhöhen der Anzahl der Knoten geschlossen werden. <br><br><h2>  Implementierung </h2><br>  Wir haben uns entschieden, den Serverteil von SV nicht direkt in die 1C: Enterprise-Plattform einzubetten, sondern ihn als separates Produkt zu implementieren, dessen API aus dem 1C-Anwendungscode aufgerufen werden kann.  Dies geschah aus einer Reihe von Gründen, von denen der Hauptgrund darin bestand, dass ich den Austausch von Nachrichten zwischen verschiedenen 1C-Anwendungen (z. B. zwischen dem Amt für Handel und Rechnungswesen) ermöglichen wollte.  Verschiedene 1C-Anwendungen können auf verschiedenen Versionen der 1C: Enterprise-Plattform ausgeführt werden, auf verschiedenen Servern usw.  Unter solchen Bedingungen ist die Implementierung von CB als separates Produkt „auf der Seite“ von 1C-Installationen die optimale Lösung. <br><br>  Deshalb haben wir uns entschlossen, CB als separates Produkt herzustellen.  Für kleine Unternehmen empfehlen wir die Verwendung des CB-Servers, den wir in unserer Cloud installiert haben (wss: //1cdialog.com), um den mit der lokalen Installation und Konfiguration des Servers verbundenen Overhead zu vermeiden.  Großkunden können es jedoch für angebracht halten, ihren eigenen CB-Server in ihren Einrichtungen zu installieren.  Einen ähnlichen Ansatz haben wir in unserem Cloud-basierten SaaS-Produkt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1cFresh verwendet</a> - es wird als Umlaufprodukt für die Installation durch Kunden freigegeben und auch in unserer Cloud <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://1cfresh.com/</a> bereitgestellt. <br><br><h3>  App </h3><br>  Für den Lastenausgleich und die Fehlertoleranz stellen wir nicht eine Java-Anwendung bereit, sondern mehrere. Wir stellen ihnen einen Lastenausgleich vor.  Wenn Sie eine Nachricht von Knoten zu Knoten übertragen müssen, verwenden Sie Publish / Subscribe in Hazelcast. <br><br>  Kommunikation des Clients mit dem Server - per Websocket.  Es ist gut für Echtzeitsysteme geeignet. <br><br><h3>  Verteilter Cache </h3><br>  Wählen Sie zwischen Redis, Hazelcast und Ehcache.  Auf dem Hof ​​2015.  Redis hat gerade einen neuen Cluster gestartet (zu neu, beängstigend), es gibt einen Sentinel mit einer Reihe von Einschränkungen.  Ehcache weiß nicht, wie man sich zu einem Cluster zusammensetzt (diese Funktionalität wurde später angezeigt).  Wir haben uns für Hazelcast 3.4 entschieden. <br>  Hazelcast geht sofort zum Cluster.  Im Einzelknotenmodus ist es nicht sehr nützlich und kann nur als Cache passen - es weiß nicht, wie Daten auf die Festplatte ausgegeben werden sollen, es hat einen einzelnen Knoten verloren - es hat Daten verloren.  Wir stellen mehrere Hazelcasts bereit, zwischen denen wir wichtige Daten sichern.  Der Cache ist kein Backup - es ist nicht schade. <br><br>  Für uns ist Hazelcast: <br><br><ul><li>  Repository von Benutzersitzungen.  Das Aufrufen einer Sitzung in der Datenbank ist jedes Mal sehr lang. Daher werden alle Sitzungen in Hazelcast gespeichert. </li><li>  Cache.  Suchen Sie nach einem Benutzerprofil - checken Sie den Cache ein.  Schrieb eine neue Nachricht - legte sie in den Cache. </li><li>  Themen zur Kommunikation von Anwendungsinstanzen.  Noda generiert ein Ereignis und fügt es in das Hazelcast-Thema ein.  Andere Anwendungsknoten, die dieses Thema abonniert haben, empfangen und verarbeiten das Ereignis. </li><li>  Clustersperren.  Zum Beispiel erstellen wir eine Diskussion über einen eindeutigen Schlüssel (Diskussions-Singleton im Rahmen der 1C-Datenbank): </li></ul><br><pre><code class="java hljs">conversationKeyChecker.check(<span class="hljs-string"><span class="hljs-string">""</span></span>); doInClusterLock(<span class="hljs-string"><span class="hljs-string">""</span></span>, () -&gt; { conversationKeyChecker.check(<span class="hljs-string"><span class="hljs-string">""</span></span>); createChannel(<span class="hljs-string"><span class="hljs-string">""</span></span>); });</code> </pre> <br>  Überprüft, ob kein Kanal vorhanden ist.  Sie nahmen das Schloss, überprüften es erneut und erstellten es.  Wenn Sie die Sperre nach dem Aufnehmen nicht überprüfen, besteht die Möglichkeit, dass in diesem Moment auch ein anderer Thread diese Sperre aktiviert hat und nun versucht, dieselbe Diskussion zu erstellen - diese ist jedoch bereits vorhanden.  Es ist unmöglich, eine Sperre durch synchronisierte oder übliche Java-Sperre durchzuführen.  Durch die Basis - langsam und die Basis ist schade, durch Hazelcast - was Sie brauchen. <br><br><h3>  DBMS auswählen </h3><br>  Wir haben umfangreiche und erfolgreiche Erfahrungen in der Arbeit mit PostgreSQL und in der Zusammenarbeit mit den Entwicklern dieses DBMS. <br><br>  PostgreSQL ist mit einem Cluster nicht einfach - es verfügt über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XC</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Citus</a> , aber im Allgemeinen handelt es sich nicht um noSQL, die sofort skalierbar sind.  NoSQL wurde nicht als Haupt-Repository angesehen, es war genug, dass wir Hazelcast genommen haben, mit dem wir vorher nicht gearbeitet hatten. <br><br>  Da Sie eine relationale Datenbank skalieren müssen, bedeutet dies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sharding</a> .  Wie Sie wissen, teilen wir beim Sharding die Datenbank in separate Teile auf, sodass jeder von ihnen auf einen separaten Server verschoben werden kann. <br><br>  Die erste Version unseres Shardings implizierte die Möglichkeit, jede der Tabellen unserer Anwendung in unterschiedlichen Anteilen auf verschiedene Server zu verteilen.  Es gibt viele Nachrichten auf Server A - bitte übertragen wir einen Teil dieser Tabelle auf Server B. Bei einer solchen Lösung ging es nur um vorzeitige Optimierung. Deshalb haben wir uns entschlossen, uns auf einen mandantenfähigen Ansatz zu beschränken. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu</a> Mandantenfähigkeit finden Sie beispielsweise auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Citus Data-</a> Website. <br><br>  In SV gibt es Konzepte für Anwendung und Teilnehmer.  Eine Anwendung ist eine spezifische Installation einer Geschäftsanwendung wie ERP oder Buchhaltung mit ihren Benutzern und Geschäftsdaten.  Ein Abonnent ist eine Organisation oder eine Person, in deren Namen die Anwendung auf dem CB-Server registriert ist.  Ein Teilnehmer kann mehrere Anwendungen registrieren und diese Anwendungen können Nachrichten miteinander austauschen.  Der Abonnent wurde auch der Mieter in unserem System.  Nachrichten von mehreren Teilnehmern können sich in einer physischen Basis befinden.  Wenn wir feststellen, dass ein Abonnent viel Datenverkehr generiert, leiten wir ihn zu einer separaten physischen Basis (oder sogar zu einem separaten Datenbankserver). <br><br>  Wir haben eine Hauptdatenbank, in der eine Routing-Tabelle mit Informationen zum Speicherort aller Teilnehmerdatenbanken gespeichert ist. <br><br><img src="https://habrastorage.org/webt/yf/3k/bo/yf3kboqvabg3ljf791sdlpn0zay.png" alt="Bild"><br><br>  Damit die Hauptdatenbank keinen Engpass darstellt, behalten wir die Routing-Tabelle (und andere häufig angeforderte Daten) im Cache. <br><br>  Wenn die Abonnentendatenbank langsamer wird, werden wir sie in Partitionen aufteilen.  In anderen Projekten verwenden wir pg_pathman, um große Tabellen zu partitionieren. <br><br>  Da der Verlust von Benutzernachrichten schlecht ist, unterstützen wir unsere Datenbanken mit Replikaten.  Durch die Kombination von synchronen und asynchronen Replikaten können Sie bei Verlust der Hauptdatenbank sicher sein.  Ein Nachrichtenverlust tritt nur bei gleichzeitigem Ausfall der Hauptdatenbank und ihrer synchronen Replik auf. <br><br>  Wenn das synchrone Replikat verloren geht, wird das asynchrone Replikat synchron. <br>  Wenn die Hauptdatenbank verloren geht, wird das synchrone Replikat zur Hauptdatenbank, das asynchrone Replikat zum synchronen Replikat. <br><br><h3>  Elasticsearch für die Suche </h3><br>  Da CB unter anderem auch ein Messenger ist, benötigen Sie hier eine schnelle, bequeme und flexible Suche unter Berücksichtigung der Morphologie nach ungenauen Übereinstimmungen.  Wir haben beschlossen, das Rad nicht neu zu erfinden und die kostenlose Elasticsearch-Suchmaschine zu verwenden, die auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lucene-</a> Bibliothek basiert.  Wir stellen Elasticsearch auch in einem Cluster (Stammdaten - Daten) bereit, um Probleme bei Ausfall von Anwendungsknoten zu beseitigen. <br><br>  Auf Github haben wir ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugin der russischen Morphologie</a> für Elasticsearch gefunden und verwenden es.  Im Elasticsearch-Index speichern wir die Wurzeln von Wörtern (die das Plugin definiert) und N-Gramm.  Während der Benutzer den zu suchenden Text eingibt, suchen wir den eingegebenen Text unter den N-Gramm.  Bei der Speicherung im Index wird das Wort "Texte" in folgende N-Gramm unterteilt: <br><br>  [diese, tech, tex, text, texte, ek, eks, ekst, eksts, ks, kst, kst, kst, st, st, du], <br><br>  Und auch die Wurzel des Wortes "Text" wird gespeichert.  Mit diesem Ansatz können Sie sowohl am Anfang, in der Mitte als auch am Ende des Wortes suchen. <br><br><h2>  Gesamtbild </h2><br><img src="https://habrastorage.org/webt/wo/w3/ke/wow3ke8dq1cqrb_ujsjm4uhevfm.png" alt="Bild"><br>  Wiederholen Sie das Bild vom Anfang des Artikels, aber mit Erklärungen: <br><br><ul><li>  Internet Balancer;  Wir haben Nginx, es kann jeder sein. </li><li>  Instanzen von Java-Anwendungen kommunizieren über Hazelcast miteinander. </li><li>  Für die Arbeit mit einem Web-Socket verwenden wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netty</a> . </li><li>  In Java 8 geschriebene Java-Anwendung besteht aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OSGi-</a> Bundles.  Die Pläne - Migration auf Java 10 und Übergang zu Modulen. </li></ul><br><h2>  Entwicklung und Erprobung </h2><br>  Bei der Entwicklung und Erprobung von CB sind wir auf eine Reihe interessanter Merkmale der von uns verwendeten Produkte gestoßen. <br><br><h3>  Lasttests und Speicherlecks </h3><br>  Die Freisetzung jeder CB-Freisetzung ist ein Stresstest.  Es war erfolgreich, als: <br><br><ul><li>  Der Test dauerte mehrere Tage und es gab keinen Denial-of-Service </li><li>  Die Reaktionszeit für Schlüsseloperationen hat einen angenehmen Schwellenwert nicht überschritten </li><li>  Der Leistungsabfall gegenüber der Vorgängerversion beträgt nicht mehr als 10% </li></ul><br>  Wir füllen die Testbasis mit Daten - dafür erhalten wir Informationen über den aktivsten Abonnenten vom Produktionsserver, multiplizieren seine Zahlen mit 5 (Anzahl der Nachrichten, Diskussionen, Benutzer) und testen. <br><br>  Wir führen Lasttests des Interaktionssystems in drei Konfigurationen durch: <br><br><ol><li>  Stresstest </li><li>  Nur Verbindungen </li><li>  Abonnentenregistrierung </li></ol><br>  Während des Stresstests starten wir mehrere hundert Threads, die das System ohne Unterbrechung laden: Nachrichten schreiben, Diskussionen erstellen, eine Liste mit Nachrichten abrufen.  Wir simulieren die Aktionen normaler Benutzer (eine Liste meiner ungelesenen Nachrichten abrufen, an jemanden schreiben) und Softwarelösungen (ein Paket mit einer anderen Konfiguration übertragen, die Benachrichtigung verarbeiten). <br><br>  Dies ist beispielsweise Teil des Stresstests: <br><br><ul><li>  Der Benutzer meldet sich an. <br><ul><li>  Fordert ungelesene Diskussionen an </li><li>  50% Chance, Nachrichten zu lesen </li><li>  Mit 50% Wahrscheinlichkeit schreibt Nachrichten </li><li>  Nächster Benutzer: <br><ul><li>  Mit 20% Wahrscheinlichkeit entsteht eine neue Diskussion. </li><li>  Wählt zufällig eine seiner Diskussionen aus </li><li>  Geht hinein </li><li>  Fordert Nachrichten und Benutzerprofile an </li><li>  Erstellt aus dieser Diskussion fünf Nachrichten, die an zufällige Benutzer gerichtet sind. </li><li>  Aus der Diskussion </li><li>  Wiederholt 20 mal </li><li>  Meldet sich ab und kehrt zum Anfang des Skripts zurück </li></ul><br></li><li>  Der Chat-Bot betritt das System (emuliert den Austausch von Nachrichten aus dem Code der angewendeten Lösungen). <br><br><ul><li>  Mit 50% Wahrscheinlichkeit entsteht ein neuer Kanal für den Datenaustausch (Sonderdiskussion) </li><li>  Mit einer Wahrscheinlichkeit von 50% wird eine Nachricht in einen der vorhandenen Kanäle geschrieben </li></ul><br></li></ul><br></li></ul><br>  Das Szenario "Nur Verbindungen" wurde aus einem bestimmten Grund angezeigt.  Es gibt eine Situation: Benutzer haben das System angeschlossen, sind aber noch nicht involviert.  Jeder Benutzer schaltet morgens um 09:00 Uhr den Computer ein, stellt eine Verbindung zum Server her und ist stumm.  Diese Typen sind gefährlich, es gibt viele von ihnen - von den Paketen haben sie nur PING / PONG, aber sie behalten die Verbindung zum Server (sie können sie nicht behalten - und plötzlich eine neue Nachricht).  Der Test gibt die Situation wieder, in der innerhalb einer halben Stunde eine große Anzahl solcher Benutzer versucht, sich beim System anzumelden.  Es sieht aus wie ein Stresstest, konzentriert sich aber genau auf diesen ersten Eingang - damit es keine Fehler gibt (eine Person benutzt das System nicht, aber es fällt bereits ab - es ist schwierig, sich etwas Schlimmeres auszudenken). <br><br>  Das Abonnentenregistrierungsszenario stammt aus dem ersten Start.  Wir haben einen Stresstest durchgeführt und waren uns sicher, dass das System in der Korrespondenz nicht langsamer wird.  Aber die Benutzer gingen und die Registrierung begann in einer Zeitüberschreitung abzufallen.  Bei der Registrierung haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">/ dev / random verwendet</a> , was an die Entropie des Systems gebunden ist.  Der Server konnte nicht genügend Entropie ansammeln und erstarrte zehn Sekunden lang, als er ein neues SecureRandom anforderte.  Es gibt viele Möglichkeiten, aus dieser Situation herauszukommen, zum Beispiel: Wechseln Sie zu weniger sicher / dev / urandom, setzen Sie eine spezielle Karte, die Entropie erzeugt, generieren Sie Zufallszahlen im Voraus und speichern Sie sie im Pool.  Wir haben das Problem vorübergehend mit einem Pool geschlossen, aber seitdem führen wir einen separaten Test zur Registrierung neuer Abonnenten durch. <br><br>  Als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lastgenerator verwenden</a> wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JMeter</a> .  Er weiß nicht, wie man mit einem Web-Socket arbeitet, ein Plug-In wird benötigt.  Die ersten Suchergebnisse für "jmeter websocket" sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel mit BlazeMeter</a> , die ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugin von Maciej Zaleski</a> empfehlen. <br><br>  Mit ihm beschlossen wir zu beginnen. <br><br>  Fast unmittelbar nach Beginn der ernsthaften Tests stellten wir fest, dass in JMeter Speicherlecks auftraten. <br><br>  Das Plugin ist eine separate große Geschichte, mit 176 Sternen hat es 132 Gabeln auf Github.  Der Autor selbst hat sich seit 2015 nicht mehr dazu verpflichtet (wir haben es 2015 aufgenommen, dann gab dies keinen Verdacht), mehrere Github-Probleme mit Speicherlecks, 7 nicht geschlossene Pull-Anfragen. <br>  Wenn Sie sich entscheiden, Lasttests mit diesem Plugin durchzuführen, beachten Sie die folgenden Diskussionen: <br><br><ol><li>  In einer Multithread-Umgebung wurde die übliche LinkedList verwendet, sodass sie zur Laufzeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NPE</a> erhielten.  Es wird entweder durch Umschalten auf ConcurrentLinkedDeque oder durch synchronisierte Blöcke gelöst.  Sie haben die erste Option für sich selbst ausgewählt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/maciejzaleski/JMeter-WebSocketSampler/issues/43</a> ). </li><li>  Speicherverlust, Verbindung trennen löscht keine Verbindungsinformationen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/maciejzaleski/JMeter-WebSocketSampler/issues/44</a> ). </li><li>  Im Streaming-Modus (wenn der Web-Socket am Ende des Beispiels nicht geschlossen wird, aber im Plan weiter verwendet wird) funktionieren die Antwortmuster ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/maciejzaleski/JMeter-WebSocketSampler/issues/19</a> ) nicht. </li></ol><br>  Dies ist einer von denen auf Github.  Was haben wir getan: <br><br><ol><li>  Sie nahmen die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gabel Elyran Kogan</a> (@elyrank) - die Probleme 1 und 3 wurden darin behoben </li><li>  Problem 2 gelöst </li><li>  Der Steg wurde vom 9.2.14 auf den 9.3.12 aktualisiert </li><li>  Wrapped SimpleDateFormat in ThreadLocal;  SimpleDateFormat ist nicht threadsicher, was zu Laufzeit-NPE führte </li><li>  Ein weiterer Speicherverlust wurde behoben (die Verbindung wurde beim Trennen falsch geschlossen). </li></ol><br>  Und doch fließt es! <br><br>  Die Erinnerung endete nicht an einem Tag, sondern an zwei.  Es blieb absolut keine Zeit mehr, sie beschlossen, weniger Threads auszuführen, aber auf vier Agenten.  Das hätte für mindestens eine Woche reichen sollen. <br><br>  Zwei Tage sind vergangen ... <br><br>  Jetzt ging Hazelcast die Erinnerung aus.  In den Protokollen wurde deutlich, dass sich Hazelcast nach einigen Testtagen über einen Speichermangel beschwert. Nach einer Weile fällt der Cluster auseinander und die Knoten sterben weiterhin einzeln ab.  Wir haben JVisualVM mit Hazelcast verbunden und eine „aufsteigende Säge“ gesehen - er rief regelmäßig GC an, konnte aber sein Gedächtnis nicht löschen. <br><br><img src="https://habrastorage.org/webt/ha/uc/5y/hauc5ydqebpmxtfirqalulaandi.png" alt="Bild"><br><br>  Es stellte sich heraus, dass in Hazelcast 3.4 beim Entfernen von map / multiMap (map.destroy ()) der Speicher nicht vollständig freigegeben wird: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/hazelcast/hazelcast/issues/6317</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/hazelcast/hazelcast/issues/4888</a> <br><br>  Jetzt ist der Fehler in 3.5 behoben, aber dann war es ein Problem.  Wir haben eine neue MultiMap mit dynamischen Namen erstellt und gemäß unserer Logik gelöscht.  Der Code sah ungefähr so ​​aus: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authentication auth, String sub)</span></span></span><span class="hljs-function"> </span></span>{ MultiMap&lt;UUID, Authentication&gt; sessions = instance.getMultiMap(sub); sessions.put(auth.getUserId(), auth); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leave</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authentication auth, String sub)</span></span></span><span class="hljs-function"> </span></span>{ MultiMap&lt;UUID, Authentication&gt; sessions = instance.getMultiMap(sub); sessions.remove(auth.getUserId(), auth); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sessions.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { sessions.destroy(); } }</code> </pre> <br>  Rufen Sie an: <br><br><pre> <code class="java hljs">service.join(auth1, <span class="hljs-string"><span class="hljs-string">"____UUID1"</span></span>); service.join(auth2, <span class="hljs-string"><span class="hljs-string">"____UUID1"</span></span>);</code> </pre> <br>  multiMap wurde für jedes Abonnement erstellt und gelöscht, wenn es nicht benötigt wurde.  Wir haben beschlossen, Map &lt;String, Set&gt; zu starten. Der Schlüssel ist der Name des Abonnements und die Werte sind die Kennungen der Sitzungen (von denen Sie bei Bedarf die Benutzer-IDs erhalten können). <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authentication auth, String sub)</span></span></span><span class="hljs-function"> </span></span>{ addValueToMap(sub, auth.getSessionId()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leave</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authentication auth, String sub)</span></span></span><span class="hljs-function"> </span></span>{ removeValueFromMap(sub, auth.getSessionId()); }</code> </pre> <br>  Die Diagramme wurden gerade ausgerichtet. <br><br><img src="https://habrastorage.org/webt/li/_z/ai/li_zaiochcpbgvviybycfvzslz4.png" alt="Bild"><br><br><h4>  Was haben wir noch über Stresstests gelernt? </h4><br><ol><li>  JSR223 muss in einen groovigen und aktivierten Kompilierungscache geschrieben werden - dies ist viel schneller.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> </li><li>  Jmeter-Plugins-Diagramme sind leichter zu verstehen als Standard.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> </li></ol><br><br><h3>  Über unsere Erfahrungen mit Hazelcast </h3><br>  Hazelcast war ein neues Produkt für uns. Wir haben ab Version 3.4.1 damit begonnen. Jetzt hat unser Produktionsserver Version 3.9.2 (zum Zeitpunkt des Schreibens ist die neueste Version von Hazelcast 3.10). <br><br><h4>  ID-Generierung </h4><br>  Wir haben mit ganzzahligen Bezeichnern begonnen.  Stellen wir uns vor, wir brauchen ein weiteres Long für eine neue Entität.  Die Sequenz passt nicht in die Datenbank, Tabellen sind am Sharding beteiligt. Es stellt sich heraus, dass in DB1 eine Nachrichten-ID = 1 und in DB2 eine Nachrichten-ID = 1 vorhanden ist. Sie können eine solche ID auch in Haastcast nicht in Elasticsearch einfügen. Das Schlimmste ist jedoch, wenn Sie die Daten reduzieren möchten von zwei Datenbanken in eine (z. B. die Entscheidung, dass eine Datenbank für diese Abonnenten ausreicht).  Sie können mehrere AtomicLongs in Hazelcast erstellen und den Zähler dort belassen. Die Leistung beim Abrufen einer neuen ID beträgt incrementAndGet plus die Zeit für eine Anforderung in Hazelcast.  Aber Hazelcast hat etwas Optimaleres - FlakeIdGenerator.  Jeder Kunde erhält bei Kontakt einen ID-Bereich, z. B. den ersten von 1 bis 10.000, den zweiten von 10.001 bis 20.000 usw.  Jetzt kann der Client neue Kennungen unabhängig voneinander ausgeben, bis der an ihn ausgegebene Bereich endet.  Es funktioniert schnell, aber wenn Sie die Anwendung (und den Hazelcast-Client) neu starten, beginnt eine neue Sequenz - daher die Lücken usw.  Darüber hinaus ist den Entwicklern nicht klar, warum IDs ganzzahlig sind, aber sie gehen so unterschiedlich vor.  Wir haben alle gewogen und auf UUIDs umgestellt. <br><br>  Übrigens, für diejenigen, die wie Twitter sein wollen, gibt es eine solche Snowcast-Bibliothek - dies ist eine Snowflake-Implementierung zusätzlich zu Hazelcast.  Sie können es hier sehen: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/noctarius/snowcast</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/twitter/snowflake</a> <br><br>  Aber wir haben ihre Hände nicht erreicht. <br><br><h4>  TransactionalMap.replace </h4><br>  Eine weitere Überraschung: TransactionalMap.replace funktioniert nicht.  Hier ist ein Test: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceInMap_putsAndGetsInsideTransaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ hazelcastInstance.executeTransaction(context -&gt; { HazelcastTransactionContextHolder.setContext(context); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { context.getMap(<span class="hljs-string"><span class="hljs-string">"map"</span></span>).put(<span class="hljs-string"><span class="hljs-string">"key"</span></span>, <span class="hljs-string"><span class="hljs-string">"oldValue"</span></span>); context.getMap(<span class="hljs-string"><span class="hljs-string">"map"</span></span>).replace(<span class="hljs-string"><span class="hljs-string">"key"</span></span>, <span class="hljs-string"><span class="hljs-string">"oldValue"</span></span>, <span class="hljs-string"><span class="hljs-string">"newValue"</span></span>); String value = (String) context.getMap(<span class="hljs-string"><span class="hljs-string">"map"</span></span>).get(<span class="hljs-string"><span class="hljs-string">"key"</span></span>); assertEquals(<span class="hljs-string"><span class="hljs-string">"newValue"</span></span>, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { HazelcastTransactionContextHolder.clearContext(); } }); } Expected : newValue Actual : oldValue</code> </pre> <br>  Ich musste meinen Ersatz mit getForUpdate schreiben: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceInMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String mapName, K key, V oldValue, V newValue)</span></span></span><span class="hljs-function"> </span></span>{ TransactionalTaskContext context = HazelcastTransactionContextHolder.getContext(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { log.trace(<span class="hljs-string"><span class="hljs-string">"[CACHE] Replacing value in a transactional map"</span></span>); TransactionalMap&lt;K, V&gt; map = context.getMap(mapName); V value = map.getForUpdate(key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldValue.equals(value)) { map.put(key, newValue); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } log.trace(<span class="hljs-string"><span class="hljs-string">"[CACHE] Replacing value in a not transactional map"</span></span>); IMap&lt;K, V&gt; map = hazelcastInstance.getMap(mapName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map.replace(key, oldValue, newValue); }</code> </pre> <br>  Testen Sie nicht nur reguläre Datenstrukturen, sondern auch deren Transaktionsversionen.  Es kommt vor, dass IMap funktioniert, aber TransactionalMap ist weg. <br><br><h4>  Bringen Sie eine neue JAR ohne Ausfallzeiten an </h4><br>  Zuerst haben wir beschlossen, Objekte unserer Klassen in Hazelcast aufzunehmen.  Zum Beispiel haben wir eine Klassenanwendung, die wir speichern und lesen möchten.  Speichern: <br><br><pre> <code class="java hljs">IMap&lt;UUID, Application&gt; map = hazelcastInstance.getMap(<span class="hljs-string"><span class="hljs-string">"application"</span></span>); map.set(id, application);</code> </pre> <br>  Wir lesen: <br><br><pre> <code class="java hljs">IMap&lt;UUID, Application&gt; map = hazelcastInstance.getMap(<span class="hljs-string"><span class="hljs-string">"application"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map.get(id);</code> </pre> <br>  Alles arbeitet.  Dann haben wir beschlossen, einen Index in Hazelcast zu erstellen, um danach zu suchen: <br><br><pre> <code class="java hljs">map.addIndex(<span class="hljs-string"><span class="hljs-string">"subscriberId"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>);</code> </pre> <br>  Beim Schreiben einer neuen Entität erhielten sie eine ClassNotFoundException.  Hazelcast versuchte den Index zu ergänzen, wusste aber nichts über unsere Klasse und wollte, dass sie eine JAR mit dieser Klasse hat.  Wir haben das getan, alles hat funktioniert, aber ein neues Problem ist aufgetreten: Wie kann man die JAR aktualisieren, ohne den Cluster vollständig zu stoppen?  Hazelcast holt die neue JAR während eines podweisen Upgrades nicht ab.  In diesem Moment haben wir beschlossen, dass wir sehr gut leben können, ohne nach Index zu suchen.  Wenn Sie Hazelcast als Schlüsselwertspeicher verwenden, funktioniert dann alles?  Nicht wirklich.  Auch hier das unterschiedliche Verhalten von IMap und TransactionalMap.  Wo IMap keine Rolle spielt, gibt TransactionalMap einen Fehler aus. <br><br>  IMap  Wir schreiben 5000 Objekte, lesen es.  Alles wird erwartet. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get5000</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ IMap&lt;UUID, Application&gt; map = hazelcastInstance.getMap(<span class="hljs-string"><span class="hljs-string">"application"</span></span>); UUID subscriberId = UUID.randomUUID(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5000</span></span>; i++) { UUID id = UUID.randomUUID(); String title = RandomStringUtils.random(<span class="hljs-number"><span class="hljs-number">5</span></span>); Application application = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Application(id, title, subscriberId); map.set(id, application); Application retrieved = map.get(id); assertEquals(id, retrieved.getId()); } }</code> </pre> <br>  Und es funktioniert nicht in der Transaktion, wir erhalten eine ClassNotFoundException: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_transaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ IMap&lt;UUID, Application&gt; map = hazelcastInstance.getMap(<span class="hljs-string"><span class="hljs-string">"application_t"</span></span>); UUID subscriberId = UUID.randomUUID(); UUID id = UUID.randomUUID(); Application application = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Application(id, <span class="hljs-string"><span class="hljs-string">"qwer"</span></span>, subscriberId); map.set(id, application); Application retrievedOutside = map.get(id); assertEquals(id, retrievedOutside.getId()); hazelcastInstance.executeTransaction(context -&gt; { HazelcastTransactionContextHolder.setContext(context); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { TransactionalMap&lt;UUID, Application&gt; transactionalMap = context.getMap(<span class="hljs-string"><span class="hljs-string">"application_t"</span></span>); Application retrievedInside = transactionalMap.get(id); assertEquals(id, retrievedInside.getId()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { HazelcastTransactionContextHolder.clearContext(); } }); }</code> </pre> <br>  In 3.8 wurde der Mechanismus zur Bereitstellung von Benutzerklassen angezeigt.  Sie können einen Hauptknoten zuweisen und die JAR-Datei darauf aktualisieren. <br><br>  Jetzt haben wir den Ansatz komplett geändert: Wir serialisieren ihn in JSON und speichern ihn in Hazelcast.  Hazelcast muss die Struktur unserer Klassen nicht kennen, aber wir können ohne Ausfallzeiten aktualisieren.  Die Versionierung von Domänenobjekten wird von der Anwendung gesteuert.  Verschiedene Versionen der Anwendung können gleichzeitig gestartet werden, und es ist möglich, dass eine neue Anwendung Objekte mit neuen Feldern schreibt, die alte jedoch nichts über diese Felder weiß.  Gleichzeitig liest die neue Anwendung Objekte aus, die von der alten Anwendung aufgezeichnet wurden und in denen keine neuen Felder vorhanden sind.  Wir behandeln solche Situationen innerhalb der Anwendung, aber der Einfachheit halber ändern oder löschen wir keine Felder, sondern erweitern Klassen nur durch Hinzufügen neuer Felder. <br><br><h3>  Wie wir hohe Leistung bieten </h3><br><h4>  Vier Reisen nach Hazelcast - gut, zwei in die Datenbank - schlecht </h4><br>  Das Aufrufen von Daten im Cache ist immer besser als in der Datenbank, Sie möchten jedoch keine nicht beanspruchten Datensätze speichern.  Die Entscheidung darüber, was zwischengespeichert werden soll, verschieben wir auf die letzte Entwicklungsstufe.  Wenn die neue Funktionalität codiert ist, aktivieren wir PostgreSQL, um alle Abfragen zu protokollieren (log_min_duration_statement auf 0) und 20 Minuten lang Lasttests durchzuführen. Mithilfe gesammelter Protokolle können Dienstprogramme wie pgFouine und pgBadger Analyseberichte erstellen.  In Berichten suchen wir hauptsächlich nach langsamen und häufigen Abfragen.  Für langsame Abfragen erstellen wir einen Ausführungsplan (EXPLAIN) und bewerten, ob eine solche Abfrage beschleunigt werden kann.  Häufige Anforderungen für dieselben Eingabedaten werden gut zwischengespeichert.  Wir versuchen, Anfragen "flach" zu halten, eine Tabelle pro Anfrage. <br><br><h2>  Bedienung </h2><br>  SV als Onlinedienst wurde im Frühjahr 2017 gestartet, als im November 2017 ein separates SV-Produkt veröffentlicht wurde (zu diesem Zeitpunkt im Beta-Status). <br><br>  Über einen Zeitraum von mehr als einem Jahr traten keine ernsthaften Probleme beim Betrieb des Onlinedienstes von CB auf.  Wir überwachen den Onlinedienst über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zabbix</a> , sammeln und stellen ihn bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bamboo bereit</a> . <br><br>  Das CB-Server-Distributionskit wird in Form von nativen Paketen geliefert: RPM, DEB, MSI.  Außerdem bieten wir für Windows ein einziges Installationsprogramm in Form einer EXE-Datei an, mit der der Server, Hazelcast und Elasticsearch auf einem Computer installiert werden.  Zuerst haben wir diese Version der Installation "Demo" genannt, aber jetzt wurde klar, dass dies die beliebteste Bereitstellungsoption ist. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422903/">https://habr.com/ru/post/de422903/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422893/index.html">Node.js-Handbuch, Teil 1: Allgemeine Informationen und erste Schritte</a></li>
<li><a href="../de422895/index.html">Google möchte URLs töten</a></li>
<li><a href="../de422897/index.html">Schlecht, aber meins: wie man wirklich schreckliches CSS schreibt</a></li>
<li><a href="../de422899/index.html">Unter wachsamer Aufsicht: So überwachen Sie Hoster-Tarife und halten den VPS-Katalog auf dem neuesten Stand</a></li>
<li><a href="../de422901/index.html">Ein Herzfrequenzmesser für Putin oder was ist ein Ritmer?</a></li>
<li><a href="../de422905/index.html">Aber du sagst Ceph ... ist er so gut?</a></li>
<li><a href="../de422907/index.html">Kurzreferenz für Roboterstaubsauger 2018</a></li>
<li><a href="../de422909/index.html">10 beliebtesten 404 Festival Retro Talk Videos</a></li>
<li><a href="../de422915/index.html">Ich suche einen Senior ohne Büro und Cookies: Wie haben wir eine Suche nach Mitarbeitern organisiert, die zu 100% entfernt sind?</a></li>
<li><a href="../de422917/index.html">Ich habe keinen Mund, aber ich muss schreien. Überlegungen zu KI und Ethik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>