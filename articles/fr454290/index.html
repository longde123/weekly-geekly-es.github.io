<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏻 👨‍🚀 ◼️ Principe de responsabilité unique. Pas aussi simple qu'il y paraît 👥 🏴󠁧󠁢󠁳󠁣󠁴󠁿 🙋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Principe de responsabilité unique, il est le principe de responsabilité unique, 
 il est le principe de la variabilité uniforme - un gars extrêmement ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Principe de responsabilité unique. Pas aussi simple qu'il y paraît</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454290/"><p><img width="500" src="https://habrastorage.org/getpro/habr/post_images/dad/c41/3d4/dadc413d4439871ac1632997daa6416c.png" alt="image" align="left">  Principe de responsabilité unique, il est le principe de responsabilité unique, <br>  il est le principe de la variabilité uniforme - un gars extrêmement glissant à comprendre et une telle question nerveuse lors d'une interview d'un programmeur. </p><br><p>  La première connaissance sérieuse de ce principe a eu lieu pour moi au début de la première année, lorsque les jeunes et les verts ont été emmenés dans la forêt pour faire de vrais élèves des larves. </p><br><p> Dans la forêt, nous avons été divisés en groupes de 8 à 9 personnes chacun et avons organisé un concours - quel groupe va boire une bouteille de vodka plus rapidement, à condition que la première personne du groupe verse de la vodka dans un verre, les deuxièmes boissons et les troisièmes bouchées.  Après avoir terminé son opération, l'unité se trouve à la fin de la file d'attente de groupe. </p><br><p>  Le cas où la taille de la file d'attente était un multiple de trois et constituait une bonne implémentation de SRP. </p><a name="habracut"></a><br><h2 id="opredelenie-1-edinaya-otvetstvennost">  Définition 1. Responsabilité unique. </h2><br><p>  La définition officielle du principe de responsabilité unique (PRS) suggère que chaque objet a sa propre responsabilité et raison d'être, et cette responsabilité n'en a qu'une. </p><br><p>  Considérez l'objet Tippler. <br>  Pour respecter le principe du PÉR, nous divisons les responsabilités en trois: </p><br><ul><li>  On verse ( <strong>PourOperation</strong> ) </li><li>  Une <strong>boisson</strong> ( <strong>DrinkUpOperation</strong> ) </li><li>  Une collation ( <strong>TakeBiteOperation</strong> ) </li></ul><br><p>  Chacun des participants au processus est responsable d'une composante du processus, c'est-à-dire qu'il a une responsabilité atomique - boire, verser ou mordre. </p><br><p>  L'alcool, à son tour, est la façade de ces opérations: </p><br><pre><code class="plaintext hljs">lass Tippler { //... void Act(){ _pourOperation.Do() //  _drinkUpOperation.Do() //  _takeBiteOperation.Do() //  } }</code> </pre> <br><div style="text-align:center;"><img width="600" src="https://habrastorage.org/getpro/habr/post_images/07b/979/ed5/07b979ed5db74fcec05254aadb60220d.png" alt="image"></div><br><h4 id="zachem">  Pourquoi? </h4><br><p>  Le programmeur humain écrit le code pour l'homme singe, et l'homme singe est inattentif, stupide et toujours pressé quelque part.  Il peut tenir et comprendre environ 3 à 7 termes à la fois. <br>  Dans le cas de l'alcool, ces termes sont trois.  Cependant, si nous écrivons le code sur une seule feuille, des mains, des lunettes, des massacres et des débats sans fin sur la politique y apparaîtront.  Et tout cela sera dans le corps d'une méthode.  Je suis sûr que vous avez vu un tel code dans votre pratique.  Pas le test le plus humain pour la psyché. </p><br><p>  D'un autre côté, l'homme singe est emprisonné pour avoir modelé des objets du monde réel dans sa tête.  Dans son imagination, il peut les rapprocher, en collecter de nouveaux objets et les démonter de la même manière.  Imaginez un vieux modèle de voiture.  Vous pouvez ouvrir la porte dans votre imagination, dévisser la garniture de porte et voir les mécanismes de lève-vitre, à l'intérieur desquels il y aura des engrenages.  Mais vous ne pouvez pas voir tous les composants de la machine en même temps, dans une seule "liste".  Au moins, "l'homme singe" ne peut pas. </p><br><p>  Par conséquent, les programmeurs humains décomposent les mécanismes complexes en un ensemble d'éléments moins complexes et fonctionnels.  Cependant, la décomposition peut se faire de différentes manières: dans de nombreuses voitures anciennes - le conduit sort par la porte et dans les voitures modernes - la défaillance de l'électronique de verrouillage empêche le moteur de démarrer, qui délivre pendant la réparation. </p><br><p>  Ainsi, <strong>SRP est un principe qui explique COMMENT décomposer, c'est-à-dire où tracer la ligne de séparation</strong> . </p><br><p>  Il dit que la décomposition devrait être basée sur le principe de séparation de la "responsabilité", c'est-à-dire selon les tâches des différents objets. </p><br><div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/b89/d0f/3c6/b89d0f3c6434ae77a2b858e2af6374b0.png" alt="image"></div><br><p>  Revenons à l'alcool et aux avantages qu'une personne singe obtient lors de la décomposition: </p><br><ul><li>  Le code est devenu extrêmement clair à tous les niveaux. </li><li>  Plusieurs programmeurs peuvent écrire du code à la fois (chacun écrit un élément distinct) </li><li>  Les tests automatisés sont simplifiés - plus l'élément est simple, plus il est facile de tester </li><li>  À partir de ces trois opérations, à l'avenir, vous pouvez additionner le glouton (en utilisant uniquement <strong>TakeBitOperation</strong> ), l'alcoolique (en utilisant uniquement <strong>DrinkUpOperation</strong> directement à partir de la bouteille) et satisfaire de nombreuses autres exigences commerciales. </li></ul><br><p>  Et, bien sûr, les inconvénients: </p><br><ul><li>  Devra créer plus de types. </li><li>  Un buveur va boire pour la première fois quelques heures plus tard qu'il ne le pouvait </li></ul><br><h2 id="opredelenie-2-edinaya-izmenchivost">  Définition 2. Variabilité unifiée. </h2><br><p>  Permettez à messieurs!  Le cours de boisson remplit également une seule responsabilité - il boit!  Et en général, le mot «responsabilité» est un concept extrêmement vague.  Quelqu'un est responsable du sort de l'humanité, et quelqu'un est responsable d'élever les pingouins renversés au poteau. </p><br><p>  Considérez deux implémentations de bingo.  Le premier, mentionné ci-dessus, contient trois classes - verser, boire et manger un morceau. </p><br><p>  La seconde est écrite à travers la méthodologie Forward et Only Forward et contient toute la logique de la méthode <strong>Act</strong> : </p><br><pre> <code class="plaintext hljs">//      .    lass BrutTippler { //... void Act(){ //  if(!_hand.TryDischarge(from:_bottle, to:_glass, size:_glass.Capacity)) throw new OverdrunkException(); //  if(!_hand.TryDrink(from: _glass, size: _glass.Capacity)) throw new OverdrunkException(); // for(int i = 0; i&lt; 3; i++){ var food = _foodStore.TakeOrDefault(); if(food==null) throw new FoodIsOverException(); _hand.TryEat(food); } } }</code> </pre> <br><p>  Du point de vue d'un observateur extérieur, ces deux classes se ressemblent exactement et remplissent la seule responsabilité de «boire». </p><br><p>  Embarras! </p><br><p>  Ensuite, nous surfons sur Internet et découvrons une autre définition de la SRP - le principe de la variabilité uniforme. </p><br><p>  Cette définition stipule que « <strong>le module a une et une seule raison de changement</strong> ».  Autrement dit, «la responsabilité est une occasion de changement». </p><br><p>  Maintenant, tout se met en place.  Séparément, vous pouvez modifier les procédures de coulée, de boisson et de morsure, et dans l'alcool lui-même, nous ne pouvons changer que la séquence et la composition des opérations, par exemple, déplacer la collation avant de boire ou ajouter une lecture de pain grillé. </p><br><p>  Dans l'approche Forward et Only Forward, tout ce qui peut être changé est changé uniquement dans la méthode <strong>Act</strong> .  Il peut être lisible et efficace dans le cas où il y a peu de logique et il change rarement, mais il se termine souvent par des méthodes terribles de 500 lignes chacune, avec plus de si-nombres que requis pour l'entrée de la Russie dans l'OTAN. </p><br><h2 id="opredelenie-3-lokalizaciya-izmeneniy">  Définition 3. Localisation des changements. </h2><br><p>  Les buveurs ne comprennent souvent pas pourquoi ils se sont réveillés dans l'appartement de quelqu'un d'autre, ni où se trouve leur téléphone portable.  Il est temps d'ajouter une journalisation détaillée. </p><br><p>  Commençons la journalisation avec le processus de coulée: </p><br><pre> <code class="plaintext hljs">class PourOperation: IOperation{ PourOperation(ILogger log /*....*/){/*...*/} //... void Do(){ _log.Log($"Before pour with {_hand} and {_bottle}"); //Pour business logic ... _log.Log($"After pour with {_hand} and {_bottle}"); } }</code> </pre> <br><p>  En l'encapsulant dans <strong>PourOperation</strong> , nous avons agi sagement en termes de responsabilité et d'encapsulation, mais maintenant avec le principe de variabilité, nous sommes maintenant gênés.  En plus de l'opération elle-même, qui peut changer, la journalisation elle-même devient variable.  Nous devrons séparer et créer un enregistreur spécial pour l'opération de coulée: </p><br><pre> <code class="plaintext hljs">interface IPourLogger{ void LogBefore(IHand, IBottle){} void LogAfter(IHand, IBottle){} void OnError(IHand, IBottle, Exception){} } class PourOperation: IOperation{ PourOperation(IPourLogger log /*....*/){/*...*/} //... void Do(){ _log.LogBefore(_hand, _bottle); try{ //... business logic _log.LogAfter(_hand, _bottle"); } catch(exception e){ _log.OnError(_hand, _bottle, e) } } }</code> </pre> <br><p>  Un lecteur méticuleux remarquera que <strong>LogAfter</strong> , <strong>LogBefore</strong> et <strong>OnError</strong> peuvent également être modifiés individuellement, et par analogie avec les étapes précédentes, il créera trois classes: <strong>PourLoggerBefore</strong> , <strong>PourLoggerAfter</strong> et <strong>PourErrorLogger</strong> . </p><br><p>  Et en se souvenant qu'il y a trois opérations pour une frénésie - nous obtenons neuf classes de journalisation.  En conséquence, l'alcool entier se compose de 14 (!!!) classes. </p><br><p>  Hyperbole?  À peine!  Un homme singe avec une grenade de décomposition écrasera le «verseur» dans une carafe, un verre, des opérateurs de versage, un service d'approvisionnement en eau, un modèle physique d'une collision de molécules, et le prochain trimestre tentera de démêler les dépendances sans variables globales.  Et croyez-moi, il ne s'arrêtera pas. </p><br><p>  C'est à ce stade que beaucoup en arrivent à la conclusion que les PÉR sont des contes des royaumes roses, et partent tordre les nouilles ... </p><br><p>  ... sans jamais connaître l'existence de la troisième définition de Srp: </p><br><p>  " <strong>Les choses qui sont similaires au changement doivent être stockées en un seul endroit</strong> ."  ou " <strong>Ce qui change ensemble doit être conservé au même endroit</strong> " </p><br><p>  Autrement dit, si nous modifions la journalisation des opérations, nous devons la modifier au <strong>même</strong> endroit. </p><br><p>  C'est un point très important - puisque toutes les explications SRP ci-dessus ont dit que les types devraient être séparés pendant qu'ils sont séparés, c'est-à-dire imposer une "restriction supérieure" à la taille de l'objet, et maintenant nous parlons d'une "limite inférieure" .  En d'autres termes, la <strong>SRP nécessite non seulement "l'écrasement pendant l'écrasement", mais aussi de ne pas en faire trop - "n'écrasez pas les choses liées"</strong> .  Ne vous compliquez pas inutilement.  C'est la grande bataille du rasoir d'Occam avec l'homme singe! </p><br><div style="text-align:center;"><img width="400" src="https://habrastorage.org/getpro/habr/post_images/778/0d3/aa2/7780d3aa2ce9b489696c55ea792adb3a.jpg" alt="image"></div><br><p>  Maintenant, l'alcool devrait être plus facile.  En plus de ne pas diviser l'enregistreur IPourLogger en trois classes, nous pouvons également combiner tous les enregistreurs en un seul type: </p><br><pre> <code class="plaintext hljs">class OperationLogger{ public OperationLogger(string operationName){/*..*/} public void LogBefore(object[] args){/*...*/} public void LogAfter(object[] args){/*..*/} public void LogError(object[] args, exception e){/*..*/} }</code> </pre> <br><p>  Et si le quatrième type d'opération nous est ajouté, la journalisation est prête pour cela.  Et le code des opérations elles-mêmes est propre et exempt de bruit d'infrastructure. </p><br><p>  En conséquence, nous avons 5 classes pour résoudre le problème d'alcool: </p><br><ul><li>  Opération de coulée </li><li>  Opération de boisson </li><li>  Opération de bourrage </li><li>  Enregistreur </li><li>  Façade des Boolers </li></ul><br><p>  Chacun d'eux est strictement responsable d'une fonctionnalité, a une raison de changement.  Toutes les règles similaires aux modifications se trouvent à proximité. </p><br><h2 id="primery-iz-realnoy-zhizni">  Exemples concrets </h2><br><div class="spoiler">  <b class="spoiler_title">Sérialisation et désérialisation</b> <div class="spoiler_text"><p>  Dans le cadre du développement du protocole de transfert de données, il est nécessaire de sérialiser et de désérialiser un certain type d '"utilisateur" en une chaîne. </p><br><pre> <code class="plaintext hljs">User{ String Name; Int Age; }</code> </pre> <br><p>  Vous pourriez penser que la sérialisation et la désérialisation doivent être effectuées dans des classes distinctes: </p><br><pre> <code class="plaintext hljs">UserDeserializer{ String deserialize(User){...} } UserSerializer{ User serialize(String){...} }</code> </pre> <br><p>  Puisque chacun d'eux a sa propre responsabilité et une raison de changement. </p><br><p>  Mais ils ont une raison commune de changement - «changer le format de sérialisation des données». <br>  Et lorsque vous changez ce format, la sérialisation et la désérialisation changeront toujours. </p><br><p>  Selon le principe de localisation des changements, nous devons les combiner en une seule classe: </p><br><pre> <code class="plaintext hljs">UserSerializer{ String deserialize(User){...} User serialize(String){...} }</code> </pre> <br><p>  Cela nous évite une complexité inutile et la nécessité de se rappeler que chaque fois que vous changez le sérialiseur, vous devez vous souvenir du désérialiseur. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Comptez et économisez</b> <div class="spoiler_text"><p>  Vous devez calculer le revenu annuel de l'entreprise et l'enregistrer dans le fichier C: \ results.txt. </p><br><p>  Nous résolvons rapidement cela avec une seule méthode: </p><br><pre> <code class="plaintext hljs">void SaveGain(Company company){ //     //   }</code> </pre> <br><p>  Dès la définition de la tâche, il est clair qu'il existe deux sous-tâches - "Calculer les revenus" et "Enregistrer les revenus".  Chacun d'eux a une raison de changement - «un changement dans la méthodologie de calcul» et «un changement dans le format d'épargne».  Ces modifications ne se chevauchent pas.  De plus, nous ne pouvons pas répondre de manière monosyllabique à la question - «que fait la méthode SaveGain?».  Cette méthode <strong>ET</strong> calcule les revenus <strong>ET</strong> enregistre les résultats. </p><br><p>  Par conséquent, vous devez diviser cette méthode en deux: </p><br><pre> <code class="plaintext hljs">Gain CalcGain(Company company){..} void SaveGain(Gain gain){..}</code> </pre> <br><p>  Avantages: </p><br><ul><li>  peut être testé séparément CalcGain </li><li>  localiser plus facilement les bugs et apporter des modifications </li><li>  lisibilité du code augmentée </li><li>  le risque d'erreur dans chacune des méthodes est réduit du fait de leur simplification </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Logique métier sophistiquée</b> <div class="spoiler_text"><p>  Une fois que nous avons écrit un service d'enregistrement automatique d'un client b2b.  Et il y avait une méthode DIEU avec 200 lignes de contenu similaire: </p><br><ul><li>  Accédez à 1C et créez un compte </li><li>  Avec ce compte, accédez au module de paiement et accédez-y </li><li>  Vérifier qu'un compte avec un tel compte n'a pas été créé sur le serveur principal </li><li>  Créez un nouveau compte </li><li>  Résultat de l'inscription dans le module de paiement et numéro 1c ajouter au service de résultats d'inscription </li><li>  Ajouter des informations de compte à ce tableau </li><li>  Créez un numéro de point pour ce client dans le service de points.  Donnez ce numéro de compte de service 1s. </li></ul><br><p>  Il y avait environ 10 autres opérations commerciales avec une connectivité terrible sur cette liste.  L'objet de compte était nécessaire à presque tout le monde.  L'identifiant du point et le nom du client étaient nécessaires dans la moitié des appels. </p><br><p>  Après une heure de refactoring, nous avons pu séparer le code d'infrastructure et certaines nuances de travail avec le compte en méthodes / classes distinctes.  La méthode de Dieu est devenue plus facile, mais il restait 100 lignes de code qui ne voulaient pas être démêlées. </p><br><p>  Quelques jours plus tard, il est apparu que l'essence de cette méthode "allégée" était l'algorithme commercial.  Et que la description initiale des savoirs traditionnels était plutôt compliquée.  Et c'est une tentative de briser cette méthode en morceaux qui constitueront une violation de la SRP, et non l'inverse. </p></div></div><br><h2 id="formalizm">  Formalisme. </h2><br><p>  Il est temps de laisser notre alcool tranquille.  Essuyez les larmes - nous y reviendrons certainement d'une manière ou d'une autre.  Maintenant, nous formalisons les connaissances de cet article. </p><br><h4 id="formalizm-1-opredelenie-srp">  Formalisme 1. Définition de SRP </h4><br><ol><li>  Séparez les éléments afin que chacun d'eux soit responsable d'une chose. </li><li>  La responsabilité signifie «cause de changement».  Autrement dit, chaque élément n'a qu'une seule raison de changement, en termes de logique métier. </li><li>  Changements potentiels de la logique métier.  doit être localisé.  Les objets mutables doivent être proches. </li></ol><br><h4 id="formalizm-2-neobhodimye-kriterii-samoproverki">  Formalisme 2. Critères nécessaires à l'auto-examen. </h4><br><p>  Je n'ai pas satisfait aux critères suffisants pour la mise en œuvre du SRP.  Mais il y a des conditions nécessaires: </p><br><p>  1) Posez-vous une question - que fait cette classe / méthode / module / service.  vous devez y répondre avec une définition simple.  (merci à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Brightori</a> ) </p><br><div class="spoiler">  <b class="spoiler_title">explications</b> <div class="spoiler_text"><p>  Cependant, il est parfois très difficile de trouver une définition simple </p></div></div><br><p>  2) La correction d'un bug ou l'ajout d'une nouvelle fonctionnalité affecte le nombre minimum de fichiers / classes.  Idéalement, un. </p><br><div class="spoiler">  <b class="spoiler_title">explications</b> <div class="spoiler_text"><p>  Étant donné que la responsabilité (pour une fonctionnalité ou un bogue) est encapsulée dans un seul fichier / classe, vous savez exactement où chercher et quoi modifier.  Par exemple: pour modifier la sortie de la journalisation des opérations, il suffit de modifier uniquement l'enregistreur.  Il n'est pas nécessaire de parcourir le reste du code. </p><br><p>  Un autre exemple est l'ajout d'un nouveau contrôle d'interface utilisateur similaire aux précédents.  Si cela vous oblige à ajouter 10 entités différentes et 15 convertisseurs différents - il semble que vous ayez «cassé». </p></div></div><br><p>  3) Si plusieurs développeurs travaillent sur différentes fonctionnalités de votre projet, la probabilité d'un conflit de fusion, c'est-à-dire la probabilité que plusieurs développeurs changent le même fichier / classe en même temps, est minime. </p><br><div class="spoiler">  <b class="spoiler_title">explications</b> <div class="spoiler_text"><p>  Si lors de l'ajout d'une nouvelle opération "Verser de la vodka sous la table", vous devez toucher l'enregistreur, l'opération de boire et de verser - alors il semble que les responsabilités soient divisées de manière tordue.  Bien sûr, ce n'est pas toujours possible, mais vous devez essayer de réduire ce chiffre. </p></div></div><br><p>  4) Lorsque vous clarifiez une question sur la logique métier (d'un développeur ou d'un gestionnaire), vous montez strictement dans une classe / fichier et ne recevez des informations que de là. </p><br><div class="spoiler">  <b class="spoiler_title">explications</b> <div class="spoiler_text"><p>  Les fonctionnalités, les règles ou les algorithmes sont écrits de manière compacte en un seul endroit, et ne sont pas dispersés par des drapeaux dans l'espace de code. </p></div></div><br><p>  5) La dénomination est claire. </p><br><div class="spoiler">  <b class="spoiler_title">explications</b> <div class="spoiler_text"><p>  Notre classe ou méthode est responsable d'une chose, et la responsabilité se reflète dans son nom. </p><br><p>  AllManagersManagerService - très probablement, Dieu-classe <br>  Paiement local - probablement pas </p></div></div><br><h4 id="formalizm-3-metodika-razrabotki-okkama-first">  Formalisme 3. La méthode de développement d'Occam-first. </h4><br><p>  Au début de la conception, l'homme singe ne connaît pas et ne sent pas toutes les subtilités du problème résolu et peut donner une gaffe.  Vous pouvez faire des erreurs de différentes manières: </p><br><ul><li>  Faire des objets trop grands en collant différentes responsabilités </li><li>  Fractionner, diviser une seule responsabilité en plusieurs types différents </li><li>  Limites de responsabilité mal définies </li></ul><br><p>  Il est important de se souvenir de la règle: "il vaut mieux faire une grosse erreur" ou "pas sûr - ne pas se séparer".  Si, par exemple, votre classe recueille deux responsabilités, cela reste compréhensible et peut être divisé en deux avec un changement minimal du code client.  La collecte d'un verre à partir de fragments de verre est généralement plus difficile en raison du contexte réparti sur plusieurs fichiers et du manque de dépendances nécessaires dans le code client. </p><br><h2 id="pora-zakruglyatsya">  Il est temps d'arrondir </h2><br><p>  La portée de SRP n'est pas limitée à OOP et SOLID.  Elle s'applique aux méthodes, fonctions, classes, modules, microservices et services.  Il s'applique à la fois au développement «figax-figax-and-in-prod» et «rocket-sainz», rendant le monde un peu meilleur partout.  Si vous y réfléchissez, c'est presque le principe fondamental de toute ingénierie.  L'ingénierie mécanique, les systèmes de contrôle et, en fait, tous les systèmes complexes sont construits à partir de composants, et la «fragmentation incomplète» prive les concepteurs de flexibilité, de «fragmentation» - d'efficacité et de limites incorrectes - de raison et de tranquillité d'esprit. </p><br><div style="text-align:center;"><img width="450" src="https://habrastorage.org/getpro/habr/post_images/5a4/13a/5ec/5a413a5ec8447752d1de83982a0fadea.jpg" alt="image"></div><br><p>  Le SRP n'est pas inventé par la nature et ne fait pas partie de la science exacte.  Il sort de nos limites biologiques et psychologiques, ce n'est qu'un moyen de contrôler et de développer des systèmes complexes en utilisant le cerveau d'un singe humain.  Il nous explique comment décomposer le système.  Le libellé original nécessitait une bonne dose de télépathie, mais j'espère que cet article a légèrement dissipé l'écran de fumée. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454290/">https://habr.com/ru/post/fr454290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454272/index.html">Toute la vérité sur RTOS. Article # 27. Heure système</a></li>
<li><a href="../fr454274/index.html">Lumière, caméra ... nuage: comment les nuages ​​changent l'industrie du cinéma</a></li>
<li><a href="../fr454278/index.html">La cyberassurance sur le marché russe</a></li>
<li><a href="../fr454280/index.html">Développement à distance dans VS Code: votre vie ne sera plus jamais la même</a></li>
<li><a href="../fr454284/index.html">Désolé, je ne viendrai pas travailler parce que c'est l'hiver</a></li>
<li><a href="../fr454292/index.html">JS. Proxy. Écueil à connaître</a></li>
<li><a href="../fr454294/index.html">«Sans expériences inutiles», ou comment nous avons lancé un accélérateur de banque</a></li>
<li><a href="../fr454296/index.html">Comment une école de Porto Rico donne vie à la chimie avec Minecraft: Éducation</a></li>
<li><a href="../fr454298/index.html">The Standoff: comment c'était</a></li>
<li><a href="../fr454300/index.html">Comment les CTT diffèrent des caloducs conventionnels et comment les appliquer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>