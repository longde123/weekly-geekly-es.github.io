<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤾 👩‍👧 ➡️ Kesalahpahaman umum tentang OOP 🔧 🥥 👸🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Hari ini, publikasi yang diterjemahkan menunggu Anda, hingga taraf tertentu mencerminkan pencarian kami terkait dengan buku-buku baru t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kesalahpahaman umum tentang OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/469135/">  Halo, Habr! <br><br>  Hari ini, publikasi yang diterjemahkan menunggu Anda, hingga taraf tertentu mencerminkan pencarian kami terkait dengan buku-buku baru tentang OOP dan FI.  Silakan berpartisipasi dalam pemungutan suara. <br><br><img src="https://habrastorage.org/webt/ff/z7/eo/ffz7eoep66368-qqjrzqjqwrdd8.jpeg"><br><a name="habracut"></a><br>  Apakah paradigma OOP mati?  Dapatkah dikatakan bahwa pemrograman fungsional adalah masa depan?  Tampaknya banyak artikel menulis tentang ini.  Saya cenderung tidak setuju dengan sudut pandang ini.  Ayo bicara! <br><br>  Setiap beberapa bulan saya menemukan posting di beberapa blog di mana penulis membuat klaim yang tampaknya beralasan untuk pemrograman berorientasi objek, setelah itu dia menyatakan OOP sebagai peninggalan masa lalu, dan kita semua harus beralih ke pemrograman fungsional. <br><br>  Sebelumnya, saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis</a> bahwa OOP dan FI tidak saling bertentangan.  Selain itu, saya dapat menggabungkan mereka dengan sangat sukses. <br><br>  Mengapa penulis artikel ini memiliki begitu banyak masalah dengan OOP, dan mengapa AF bagi mereka merupakan alternatif yang jelas? <br><br><h4>  Cara mengajar OOP </h4><br>  Ketika kita diajari OOP, mereka biasanya menekankan bahwa itu didasarkan pada empat prinsip: <i>enkapsulasi</i> , <i>pewarisan</i> , <i>abstraksi</i> , <i>polimorfisme</i> .  Empat prinsip inilah yang biasanya dikritik dalam artikel di mana penulis beralasan tentang penurunan PLO. <br><br>  Namun, OOP, seperti FI, adalah alat.  Untuk memecahkan masalah.  Itu bisa dikonsumsi, juga bisa disalahgunakan.  Misalnya, dengan membuat abstraksi yang salah, Anda menyalahgunakan OOP. <br>  Jadi, kelas <code>Square</code> tidak boleh mewarisi kelas <code>Rectangle</code> .  Dalam pengertian matematika, mereka tentu saja terhubung.  Namun, dari sudut pandang pemrograman, mereka tidak berada dalam hubungan pewarisan.  Faktanya adalah bahwa persyaratan untuk persegi lebih ketat daripada persegi panjang.  Sedangkan dalam sebuah persegi panjang ada dua pasang sisi yang sama, sebuah persegi harus memiliki semua sisi yang sama. <br><br><h4>  Warisan </h4><br>  Mari kita bahas warisan secara lebih rinci.  Anda mungkin mengingat contoh-contoh buku teks dengan hierarki yang indah dari kelas-kelas yang diwarisi, dan semua struktur ini berfungsi untuk menyelesaikan masalah.  Namun, dalam praktiknya, pewarisan tidak digunakan sesering komposisi. <br>  Pertimbangkan sebuah contoh.  Katakanlah kita memiliki kelas yang sangat sederhana, pengontrol dalam aplikasi web.  Sebagian besar kerangka kerja modern mengasumsikan bahwa Anda akan bekerja dengannya seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlogController</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FrameworkAbstractController</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Diasumsikan bahwa dengan cara ini akan lebih mudah bagi Anda untuk melakukan panggilan seperti <code>this.renderTemplate(...)</code> , karena metode seperti ini diwarisi dari kelas <code>FrameworkAbstractController</code> . <br><br>  Seperti yang ditunjukkan dalam banyak artikel tentang hal ini, sejumlah masalah nyata muncul di sini.  Setiap fungsi internal di kelas dasar sebenarnya berubah menjadi API.  Dia tidak bisa lagi berubah.  Variabel apa pun yang dilindungi dari pengontrol dasar sekarang akan lebih atau kurang terkait dengan API. <br><br>  Tidak ada yang membingungkan.  Dan jika kita memilih pendekatan dengan komposisi dan injeksi ketergantungan, itu akan menjadi seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlogController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BlogController</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TemplateRenderer templateRenderer )</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre> <br>  Anda lihat, Anda tidak lagi bergantung pada beberapa <code>FrameworkAbstractController</code> berkabut, tetapi bergantung pada hal yang sangat jelas dan sempit, <code>TemplateRenderer</code> .  Bahkan, <code>BlogController</code> tidak mewarisi dari pengontrol lain, karena tidak mewarisi perilaku apa pun. <br><br><h4>  Enkapsulasi </h4><br>  Fitur OOP kedua yang sering dikritik adalah enkapsulasi.  Dalam bahasa sastra, makna enkapsulasi dirumuskan sebagai berikut: data dan fungsionalitas disampaikan bersama-sama, dan keadaan internal kelas disembunyikan dari dunia luar. <br><br>  Peluang ini, sekali lagi, memungkinkan untuk digunakan dan disalahgunakan.  Contoh utama penyalahgunaan dalam kasus ini adalah keadaan bocor. <br><br>  Secara relatif, anggaplah bahwa kelas <code>List&lt;&gt;</code> berisi daftar elemen, dan daftar ini dapat diubah.  Mari kita buat kelas untuk memproses keranjang pesanan sebagai berikut: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingCart</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;ShoppingCartItem&gt; items; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;ShoppingCartItem&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.items; } }</code> </pre> <br>  Di sini, di sebagian besar bahasa berorientasi OOP, hal berikut akan terjadi: variabel item akan dikembalikan dengan referensi.  Karena itu, selanjutnya kita dapat melakukan ini: <br><br><pre> <code class="plaintext hljs">shoppingCart.getItems().clear();</code> </pre> <br>  Dengan demikian, kita benar-benar akan menghapus daftar barang di keranjang, dan ShoppingCart bahkan tidak akan mengetahuinya.  Namun, jika Anda perhatikan dengan teliti contoh ini, menjadi jelas bahwa masalahnya bukan pada prinsip enkapsulasi.  Prinsip ini dilanggar di sini, karena negara bagian bocor dari kelas <code>ShoppingCart</code> . <br><br>  Dalam contoh khusus ini, penulis kelas <code>ShoppingCart</code> dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">immutability</a> untuk menghindari masalah dan memastikan bahwa prinsip enkapsulasi tidak dilanggar. <br><br>  Pemrogram berpengalaman sering melanggar prinsip enkapsulasi dengan cara lain: mereka memperkenalkan negara di mana itu tidak diperlukan.  Programmer yang tidak berpengalaman seperti itu sering menggunakan variabel kelas privat untuk mentransfer data dari satu fungsi ke fungsi lain dalam kelas yang sama, sementara itu akan lebih tepat untuk menggunakan Obyek Transfer Data untuk mentransfer struktur kompleks ke fungsi lain.  Sebagai hasil dari kesalahan tersebut, kode tidak perlu rumit, yang dapat menyebabkan bug. <br><br>  Secara umum, alangkah baiknya untuk membuang negara sama sekali - simpan data yang bisa berubah di kelas kapan pun memungkinkan.  Dengan melakukannya, Anda perlu <i>memastikan enkapsulasi yang andal</i> dan memastikan tidak ada kebocoran di mana pun. <br><br><h4>  Abstraksi </h4><br>  Abstraksi, sekali lagi, dipahami dalam banyak hal secara tidak benar.  Dalam kasus apa pun Anda harus memasukkan kode dengan kelas abstrak dan membuat hierarki yang mendalam di dalamnya. <br><br>  Jika Anda melakukan ini tanpa alasan yang baik, maka Anda hanya mencari masalah di kepala Anda sendiri.  Tidak masalah bagaimana abstraksi dilakukan - sebagai kelas abstrak atau sebagai antarmuka;  dalam hal apa pun, kompleksitas tambahan akan muncul dalam kode.  Kompleksitas ini harus dibenarkan. <br>  Sederhananya, antarmuka hanya dapat dibuat jika Anda bersedia menghabiskan waktu dan mendokumentasikan perilaku yang diharapkan dari kelas yang mengimplementasikannya.  Ya, Anda membaca saya dengan benar.  Tidak cukup hanya membuat daftar fungsi yang perlu Anda terapkan - juga menggambarkan bagaimana (idealnya) mereka harus bekerja. <br><br><h4>  Polimorfisme </h4><br>  Akhirnya, mari kita bicara tentang polimorfisme.  Dia menyarankan bahwa satu kelas dapat menerapkan banyak perilaku.  Contoh buku teks yang buruk adalah menulis bahwa <code>Square</code> with polymorphism dapat berupa <code>Rectangle</code> atau <code>Parallelogram</code> .  Seperti yang telah saya tunjukkan di atas, ini dalam OOP jelas mustahil, karena perilaku entitas ini berbeda. <br><br>  Berbicara tentang polimorfisme, seseorang harus mengingat <i>perilaku</i> , bukan <i>kode</i> .  Contoh yang baik adalah kelas <code>Soldier</code> di game komputer.  Itu dapat menerapkan perilaku <code>Movable</code> (situasi: dapat bergerak) dan perilaku <code>Enemy</code> (situasi: menembak Anda).  Sebaliknya, kelas <code>GunEmplacement</code> hanya dapat menerapkan perilaku <code>Enemy</code> . <br><br>  Jadi, jika Anda menulis <code>Square implements Rectangle, Parallelogram</code> , pernyataan ini tidak menjadi kenyataan.  Abstraksi Anda harus bekerja sesuai dengan logika bisnis.  Anda harus lebih memikirkan perilaku daripada tentang kode. <br><br><h4>  Mengapa FP bukan peluru perak </h4><br>  Jadi, ketika kita mengulangi empat prinsip dasar OOP, mari kita pikirkan tentang apa fitur pemrograman fungsional, dan mengapa tidak menggunakannya untuk menyelesaikan semua masalah dalam kode Anda? <br><br>  Dari sudut pandang banyak penganut FP, kelas adalah <i>penistaan</i> , dan kode harus disajikan dalam bentuk <i>fungsi</i> .  Bergantung pada bahasa, data dapat ditransfer dari satu fungsi ke fungsi lainnya menggunakan tipe primitif, atau dalam bentuk satu atau set data terstruktur lainnya (array, kamus, dll.). <br><br>  Selain itu, sebagian besar fungsi seharusnya tidak memiliki efek samping.  Dengan kata lain, mereka tidak boleh mengubah data di tempat tak terduga di latar belakang, tetapi hanya bekerja dengan parameter input dan menghasilkan output. <br><br>  Pendekatan ini memisahkan <i>data</i> dari <i>fungsional</i> - pada pandangan pertama, FP ini secara radikal berbeda dari OOP.  FP menekankan bahwa dengan cara ini kode tetap sederhana.  Anda ingin melakukan sesuatu, menulis fungsi untuk tujuan ini - itu saja. <br><br>  Masalah dimulai ketika beberapa fungsi harus bergantung pada yang lain.  Ketika fungsi A memanggil fungsi B, dan fungsi B memanggil lima hingga enam fungsi lainnya, dan pada akhirnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi pengisian nol</a> ditemukan yang dapat merusak - ini adalah di mana Anda tidak akan iri. <br><br>  Kebanyakan programmer yang menganggap diri mereka pendukung FP suka FP karena kesederhanaannya dan tidak menganggap masalah seperti itu serius.  Ini cukup jujur ​​jika tugas Anda adalah hanya lulus kode dan tidak pernah memikirkannya lagi.  Jika Anda ingin membangun basis kode yang nyaman dalam dukungan, lebih baik mematuhi prinsip-prinsip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode murni</a> , khususnya, menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inversi ketergantungan</a> , di mana FI dalam praktiknya juga menjadi jauh lebih rumit. <br><br><h4>  OOP atau FP? </h4><br>  OOP dan FI adalah <i>alat</i> .  Pada akhirnya, tidak masalah paradigma pemrograman mana yang Anda gunakan.  Masalah yang dijelaskan dalam sebagian besar artikel tentang topik ini berkaitan dengan organisasi kode. <br><br>  Menurut pendapat saya, struktur makro aplikasi jauh lebih penting.  Apa saja modul di dalamnya?  Bagaimana mereka saling bertukar informasi?  Struktur data apa yang paling umum dengan Anda?  Bagaimana mereka didokumentasikan?  Objek mana yang paling penting dalam hal logika bisnis? <br><br>  Semua masalah ini sama sekali tidak terhubung dengan paradigma pemrograman yang digunakan, pada tingkat paradigma seperti itu mereka bahkan tidak dapat diselesaikan.  Seorang programmer yang baik mempelajari paradigma untuk menguasai alat yang ditawarkannya, dan kemudian memilih mana yang paling cocok untuk menyelesaikan tugas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469135/">https://habr.com/ru/post/id469135/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469125/index.html">Tema gelap Thunderbird sebagai alasan untuk menjalankan penganalisis kode</a></li>
<li><a href="../id469127/index.html">Optimasi atau cara tidak menembak diri sendiri di kaki</a></li>
<li><a href="../id469129/index.html">Karena tema yang gelap, Thunderbird harus menjalankan penganalisa kode</a></li>
<li><a href="../id469131/index.html">Jin</a></li>
<li><a href="../id469133/index.html">Gadget apa yang diperkenalkan Amazon di Peranti Kerasnya 2019</a></li>
<li><a href="../id469137/index.html">Otak adalah batas terakhir privasi</a></li>
<li><a href="../id469139/index.html">Pelajari SEO sendiri: banyak pilihan materi</a></li>
<li><a href="../id469143/index.html">Bagaimana MAMR bekerja di HDD</a></li>
<li><a href="../id469147/index.html">Zimbra Edisi Sumber Terbuka dan tanda tangan otomatis dalam surat</a></li>
<li><a href="../id469151/index.html">Tidak ada kata terlambat untuk memulai cara baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>