<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴 📎 👩🏾‍⚖️ 在Unity上实时操纵网格 ✈️ 🧑🏾‍🤝‍🧑🏾 💃🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unity作为游戏开发平台的优势之一是其强大的3D引擎。 在本教程中，您将了解3D对象和网格处理的世界。 

 由于虚拟和增强现实（VR / AR）技术的发展，大多数开发人员都面临着复杂的3D图形概念。 让本教程成为他们的起点。 不用担心，不会有复杂的3D数学-只有心，绘图，箭头和许多有趣的东西！ ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Unity上实时操纵网格</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428796/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/532/c83/ce5532c83ff152100775d62091370bf2.gif" alt="图片"></div><br>  Unity作为游戏开发平台的优势之一是其强大的3D引擎。 在本教程中，您将了解3D对象和网格处理的世界。 <br><br> 由于虚拟和增强现实（VR / AR）技术的发展，大多数开发人员都面临着复杂的3D图形概念。 让本教程成为他们的起点。 不用担心，不会有复杂的3D数学-只有心，绘图，箭头和许多有趣的东西！ <br><a name="habracut"></a><br><blockquote>  <em>注意：</em>本教程适用于熟悉Unity IDE并且具有C＃编程经验的用户。 如果您不了解这些知识，请首先学习教程<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">“ Unity UI</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">简介”</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">“ Unity脚本编制简介”</a> 。 <br><br> 您将需要一个不低于2017.3.1的Unity版本。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">此处</a>下载Unity的最新版本。 本教程使用自定义编辑器，您可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">扩展Unity编辑器</a>教程中了解有关它们的更多信息。 </blockquote><br><h2> 开始工作 </h2><br> 首先，请熟悉3D图形的基本术语，这将使您更好地理解本教程。 <br><br>  3D图形的基本技术术语： <br><br><ul><li>  <em>顶点</em> ：每个顶点是3D空间中的一个点。 </li><li>  <em>网格</em> ：包含模型的所有顶点，边，三角形，法线和UV数据。 </li><li>  <em>网格过滤器</em> ：存储模型网格数据。 </li><li>  <em>网格渲染器</em> ：渲染场景中的网格数据。 </li><li>  <em>法线</em> ：顶点或曲面的向量。 它指向外部，垂直于网格表面。 </li><li>  <em>线/边</em> ：连接顶点的不可见线。 </li><li>  <em>三角形</em> ：通过连接三个峰形成。 </li><li>  <em>UV贴图</em> ：将材质附加到对象上，为其创建纹理和颜色。 </li></ul><br>  3D对象的解剖始于其网格。 该网格的创建始于其顶部。 连接这些顶点的不可见线形成定义对象基本形状的三角形。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/83a/4c2/5a783a4c2ed2c144ccd0d7eb97369370.gif"></div><br> 然后，法线和UV数据设置阴影，颜色和纹理。 网格数据存储在网格过滤器中，并且网格渲染器使用此数据在场景中绘制对象。 <br><br> 也就是说，用于创建3D模型的伪代码如下所示： <br><br><ul><li> 创建一个名为“ myMesh”的新网格。 </li><li> 将数据添加到顶点和三角形myMesh的属性。 </li><li> 创建一个名为“ myMeshFilter”的新网格过滤器。 </li><li> 将网格属性myMeshFilter设置为myMesh。 </li></ul><br> 掌握了基础知识之后，请下载<a href="">项目</a> ，解压缩文件，然后在Unity中运行项目的工件。 在“ <em>项目”</em>窗口中查看文件夹结构： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/690/2d6/c2e/6902d6c2e14a98284c8af39055242bc7.png"></div><br> 文件夹说明： <br><br><ul><li>  <em>预制件</em> ：包含Sphere预制件，将用于在应用程序执行期间保存3D网格。 </li><li>  <em>场景</em> ：包含本教程中使用的三个场景。 </li><li>  <em>编辑器</em> ：此文件夹中的脚本为我们提供了我们在开发中使用的编辑器的超级功能。 </li><li>  <em>脚本</em> ：这是附加到GameObject并在您单击<em>Play</em>时执行的运行时脚本。 </li><li>  <em>材料</em> ：此文件夹包含网格的材料。 </li></ul><br> 在下一部分中，我们将创建一个自定义编辑器，以可视化3D网格的创建。 <br><br><h2> 使用自定义编辑器更改网格 </h2><br> 打开位于<em>Scenes</em>文件夹中的<em>01 Mesh Study Demo</em> 。 在“ <em>场景”</em>窗口中，您将看到一个3D立方体： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/ed2/812/6d5ed28123a0c65bb083c67efab702c7.gif"></div><br> 在进入网格之前，让我们看一下自定义编辑器脚本。 <br><br><h3> 编辑编辑器脚本 </h3><br> 在“ <em>项目”</em>窗口中选择“ <em>编辑器”</em>文件夹。 此文件夹中的脚本在开发过程中向编辑器（Editor）添加功能，并且在Build模式下不可用。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/442/653/b41/442653b41ca755b67d3a1ce42ae1ec5a.png"></div><br> 打开<em>MeshInspector.cs</em>并查看源代码。 所有的Editor脚本都必须实现<code>Editor</code>类，其<code>CustomEditor</code>属性告诉<code>Editor</code>类适用于什么类型的对象。  <code>OnSceneGUI()</code>是一种事件方法，允许在“场景”窗口中渲染；  <code>OnInspectorGUI()</code>允许您将其他GUI元素添加到Inspector。 <br><br> 在<em>MeshInspector.cs中，</em>在启动<code>MeshInspector</code>类之前<code>MeshInspector</code>添加以下内容： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CustomEditor(typeof(MeshStudy))</span></span>]</code> </pre> <br> 代码说明： <code>CustomEditor</code>属性告诉Unity自定义编辑器类可以修改的对象类型。 <br><br> 在<code>OnSceneGUI()</code>在<code>EditMesh()</code>之前<code>EditMesh()</code>添加以下内容： <br><br><pre> <code class="cs hljs">mesh = target <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MeshStudy; Debug.Log(<span class="hljs-string"><span class="hljs-string">"Custom editor is running"</span></span>);</code> </pre> <br> 代码说明： <code>Editor</code>类具有一个标准<code>target</code>变量。 在这里， <code>target</code>是对<code>MeshStudy</code>的转换。 现在，自定义编辑器将在“场景”窗口中绘制所有<em>GameObject</em> ，并将它们附加到<em>MeshStudy.cs</em> 。 添加调试消息使您可以在控制台中验证自定义编辑器是否正在实际运行。 <br><br> 保存文件并返回到Unity。 转到<em>Scripts</em>文件夹，然后将<em>MeshStudy.cs</em>拖到<em>层次结构</em>中的<em>GameObject</em> <em>Cube</em>上以将其附加。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa6/b8a/ee4/aa6b8aee48eacb8421eff3c4e1ef4be3.png"></div><br> 现在，消息“自定义编辑器正在运行”应该显示在控制台中，这意味着我们做对了所有事情！ 您可以删除调试消息，以便它不会在控制台中困扰我们。 <br><br><h3> 克隆和转储网格 </h3><br> 使用自定义编辑器在“编辑”模式下使用3D网格时，请注意不要覆盖默认的Unity网格。 如果发生这种情况，则必须重新启动Unity。 <br><br> 若要安全地克隆网格而不覆盖原始表单，请从<code>MeshFilter.sharedmesh</code>属性创建网格的副本，然后将其再次分配给网格过滤器。 <br><br> 为此，在<em>Scripts</em>文件夹中双击<em>MeshStudy.cs</em> ，以在代码编辑器中打开文件。 该脚本继承自<code>MonoBehaviour</code>类，并且其<code>Start()</code>函数不在编辑模式下执行。 <br><br> 在<em>MeshStudy.cs中，</em>在启动<code>MeshStudy</code>类之前<code>MeshStudy</code>添加以下内容： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ExecuteInEditMode</span></span>]</code> </pre> <br> 代码说明：添加此属性后，将在播放模式和编辑模式下执行<code>Start()</code>函数。 现在，我们可以首先实例化网格对象并将其克隆。 <br><br> 在<code>InitMesh()</code>添加以下代码： <br><br><pre> <code class="cs hljs">oMeshFilter = GetComponent&lt;MeshFilter&gt;(); oMesh = oMeshFilter.sharedMesh; <span class="hljs-comment"><span class="hljs-comment">//1 cMesh = new Mesh(); //2 cMesh.name = "clone"; cMesh.vertices = oMesh.vertices; cMesh.triangles = oMesh.triangles; cMesh.normals = oMesh.normals; cMesh.uv = oMesh.uv; oMeshFilter.mesh = cMesh; //3 vertices = cMesh.vertices; //4 triangles = cMesh.triangles; isCloned = true; Debug.Log("Init &amp; Cloned");</span></span></code> </pre> <br> 代码说明： <br><br><ol><li> 从<code>MeshFilter</code>组件获取原始的<code>oMesh</code>网格。 </li><li> 将<code>cMesh</code>复制到新的Mesh <code>cMesh</code> 。 </li><li> 再次分配复制的网格网格过滤器。 </li><li> 更新局部变量。 </li></ol><br> 保存文件并返回到Unity。 消息“ Init＆Cloned”应显示在调试控制台中。 在<em>层次结构中</em>选择GameObject <code>Cube</code> ，然后在<em>检查器中</em>检查其属性。  <em>网格过滤器</em>应显示一个称为<em>clone</em>的网格资产。 太好了！ 这意味着我们已经成功克隆了网格。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6c/2da/3e0/c6c2da3e0e29703888bad5e50bb608a6.png"></div><br> 在编辑器文件夹中，导航到<em>MeshInspector.cs</em> 。 在<code>OnInspectorGUI()</code> ，在第二行代码之后，添加以下内容： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button(<span class="hljs-string"><span class="hljs-string">"Reset"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//1 { mesh.Reset(); //2 }</span></span></code> </pre> <br> 代码说明： <br><br><ol><li> 该代码在<em>Inspector中</em>绘制了一个Reset按钮。 </li><li> 按下时，它将调用<em>MeshStudy.cs中</em>的<code>Reset()</code>函数。 </li></ol><br> 保存文件，打开<em>MeshStudy.cs</em>并将以下代码添加到<code>Reset()</code>函数： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cMesh != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; oMesh != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-comment"><span class="hljs-comment">//1 { cMesh.vertices = oMesh.vertices; //2 cMesh.triangles = oMesh.triangles; cMesh.normals = oMesh.normals; cMesh.uv = oMesh.uv; oMeshFilter.mesh = cMesh; //3 vertices = cMesh.vertices; //4 triangles = cMesh.triangles; }</span></span></code> </pre> <br> 代码说明： <br><br><ol><li> 验证源和克隆网格的存在。 </li><li> 将<code>cMesh</code>重置为原始网格。 </li><li> 分配给<code>cMesh</code> <code>oMeshFilter</code> 。 </li><li> 更新局部变量。 </li></ol><br> 保存文件并返回到Unity。 在<em>检查器中，</em>单击“ <em>测试编辑”</em>按钮以扭曲立方体网格。 接下来，单击“ <em>重置”</em>按钮； 多维数据集应返回其原始形式。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c3/a8a/e22/0c3a8ae22c8f8382dd46ee652b4b6eea.gif"></div><br><h3>  Unity中的顶点和三角形的说明 </h3><br> 网格由通过三角形的边连接的顶点组成。 三角形定义了对象的基本形状。 <br><br><blockquote>  <em>网格类别：</em> <br><br><ul><li> 顶点存储为<code>Vector3</code>值的数组。 </li><li> 三角形被存储为对应于顶点数组索引的整数数组。 </li></ul><br> 也就是说，在一个简单的四边形网格中，该网格由四个顶点和两个三角形组成，网格数据将如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56c/56d/794/56c56d794628ff20592f801340308790.gif"></div></blockquote><br><h3> 顶点映射 </h3><br> 在这里，我们希望将立方体的顶点显示为蓝点。 <br><br> 在<em>MeshInspector.cs中，</em>我们<em>将</em>进入<code>EditMesh()</code>函数并添加以下内容： <br><br><pre> <code class="cs hljs">handleTransform = mesh.transform; <span class="hljs-comment"><span class="hljs-comment">//1 handleRotation = Tools.pivotRotation == PivotRotation.Local ? handleTransform.rotation : Quaternion.identity; //2 for (int i = 0; i &lt; mesh.vertices.Length; i++) //3 { ShowPoint(i); }</span></span></code> </pre> <br> 代码说明： <br><br><ol><li>  <code>handleTransform</code>从<code>mesh</code>获取Transform值。 </li><li>  <code>handleRotation</code>获取当前关节的“旋转”模式。 </li><li> 遍历网格的顶点并使用<code>ShowPoint()</code>绘制点。 </li></ol><br> 在<code>ShowPoint()</code>函数中， <code>//draw dot</code>注释之后，添加以下内容： <br><br><pre> <code class="cs hljs">Vector3 point = handleTransform.TransformPoint(mesh.vertices[index]);</code> </pre> <br> 代码说明：这条线将顶点的局部位置转换为世界空间中的坐标。 <br><br> 在同一函数的<code>if</code>块中，在刚添加的代码行之后，立即添加以下内容： <br><br><pre> <code class="cs hljs">Handles.color = Color.blue; point = Handles.FreeMoveHandle(point, handleRotation, mesh.handleSize, Vector3.zero, Handles.DotHandleCap);</code> </pre> <br> 代码说明： <br><br><ol><li> 使用<code>Handles</code>帮助器类设置点的颜色，大小和位置。 </li><li>  <code>Handles.FreeMoveHandle()</code>创建一个无限运动操纵器，简化了拖放操作，这在下一节中对我们很有用。 </li></ol><br> 保存文件并返回到Unity。 在检查器中检查多维数据集属性，并确保启用了“ <em>移动顶点”</em>选项。 现在，您应该看到屏幕上的网格已标记有多个蓝点。 在这里-立方体网格的顶部！ 尝试对其他3D对象执行此操作，然后观察结果。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d78/3aa/205/d783aa2054dd9ca81ee7a6c948c7c00a.gif"></div><br><h3> 移动单个顶点 </h3><br> 让我们从操作网格的最简单步骤开始-移动单个顶点。 <br><br> 转到<em>MeshInspector.cs</em> 。 在<code>ShowPoint()</code>函数内部， <code>//drag</code>注释之后<code>//drag</code> <code>if</code>块的右括号之前，添加以下内容： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUI.changed) <span class="hljs-comment"><span class="hljs-comment">//1 { mesh.DoAction(index, handleTransform.InverseTransformPoint(point)); //2 }</span></span></code> </pre> <br> 代码说明： <br><br><ol><li>  <code>GUI.changed</code>跟踪所有随点发生的变化，并与<code>Handles.FreeMoveHandle()</code>一起很好地工作，以识别拖放操作。 </li><li> 对于可拖动的顶点， <code>mesh.DoAction()</code>函数接收其索引和Transform值作为参数。 由于顶点的Transform值位于世界空间中，因此我们可以使用<code>InverseTransformPoint()</code>将其转换为局部空间。 </li></ol><br> 保存脚本文件并转到<em>MeshStudy.cs</em> 。 在<code>DoAction()</code> ，在方括号后面添加以下内容： <br><br><pre> <code class="cs hljs">PullOneVertex(index, localPos);</code> </pre> <br> 然后将以下内容添加到<code>PullOneVertex()</code>函数中： <br><br><pre> <code class="cs hljs">vertices[index] = newPos; <span class="hljs-comment"><span class="hljs-comment">//1 cMesh.vertices = vertices; //2 cMesh.RecalculateNormals(); //3</span></span></code> </pre> <br> 代码说明： <br><br><ol><li> 我们使用值<code>newPos</code>更新目标顶点。 </li><li>  <code>cMesh.vertices</code>更新的顶点值<code>cMesh.vertices</code>回<code>cMesh.vertices</code> 。 </li><li> 在<code>RecalculateNormals()</code>重新计算并重画网格，使其与更改匹配。 </li></ol><br> 保存文件并返回到Unity。 尝试在立方体上拖动点； 你看到破碎的网格了吗？ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fca/ccf/c86/fcaccfc865e30b3c922e6cabcf9f79d7.gif"></div><br> 似乎某些顶点具有相同的位置，因此，当我们仅拖动一个顶点时，其余顶点仍保留在其后面，并且网格中断。 在下一节中，我们将解决此问题。 <br><br><h3> 查找所有相似的顶点 </h3><br> 在外观上，一个立方体网格由八个顶点，六个边和12个三角形组成。 让我们检查是否是这样。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/253/a30/b3f/253a30b3fcca7b0d9028d92b4c4149c2.gif"></div><br> 打开<em>MeshStudy.cs</em> ，在<code>Start()</code>函数前面看一下，找到<code>vertices</code>变量。 我们将看到以下内容： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">HideInInspector</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3[] vertices;</code> </pre> <br> 代码说明： <code>[HideInInspector]</code>从“ <em>检查器”</em>窗口隐藏共享变量。 <br><br> 注释掉此属性： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//[HideInInspector] public Vector3[] vertices;</span></span></code> </pre> <br><blockquote>  <em>注意：</em>隐藏顶点值有助于<code>[HideInInspector]</code>处理更复杂的3D网格。 由于顶点数组的大小可以达到数千个元素，因此在尝试在Inspector中查看数组值时，这可能导致Unity无法使用。 </blockquote><br> 保存文件并返回到Unity。 转到<em>检查器</em> 。 现在，在“ <em>网格研究”</em>脚本组件下，显示了<em>vertices</em>属性。 单击它旁边的箭头图标； 因此您可以<code>Vector3</code>元素<code>Vector3</code>数组。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/feb/f83/fd0/febf83fd02d469734b73910b1769d670.gif"></div><br> 您会看到数组的大小为24，也就是说，存在具有相同位置的顶点！ 在继续之前，请确保取消注释<code>[HideInInspector]</code> 。 <br><br><div class="spoiler">  <b class="spoiler_title">为什么有24个顶点？</b> <div class="spoiler_text"> 关于这个主题有很多理论。 但是，最简单的答案是：立方体有六个边，每个边由形成一个平面的四个顶点组成。 <br><br> 因此，计算如下：6 x 4 = 24个顶点。 <br><br> 您可以搜索其他答案。 但就目前而言，知道某些网格物体的顶点位置相同是很简单的。 </div></div><br> 在<em>MeshStudy.cs中，</em>将<code>DoAction()</code>函数中的<em>所有</em>代码替换为以下内容： <br><br><pre> <code class="cs hljs">PullSimilarVertices(index, localPos);</code> </pre> <br> 让我们进入<code>PullSimilarVertices()</code>函数并添加以下内容： <br><br><pre> <code class="cs hljs">Vector3 targetVertexPos = vertices[index]; <span class="hljs-comment"><span class="hljs-comment">//1 List&lt;int&gt; relatedVertices = FindRelatedVertices(targetVertexPos, false); //2 foreach (int i in relatedVertices) //3 { vertices[i] = newPos; } cMesh.vertices = vertices; //4 cMesh.RecalculateNormals();</span></span></code> </pre> <br> 代码说明： <br><br><ol><li> 我们获得目标顶点的位置，该位置将用作<code>FindRelatedVertices()</code>方法的参数。 </li><li> 此方法返回与目标顶点位置相同的索引列表（对应于顶点）。 </li><li> 循环遍历整个列表，并将相应的顶点设置为<code>newPos</code> 。 </li><li>  <code>cMesh.vertices</code>更新的<code>vertices</code> <code>cMesh.vertices</code>回<code>cMesh.vertices</code> 。 然后，我们调用<code>RecalculateNormals()</code>重新绘制具有新值的网格。 </li></ol><br> 保存文件并返回到Unity。 拖动任何一个顶点； 现在，网格应保持其形状而不塌陷。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/66d/bcc/b1b66dbccb73ac3a8ad8c56594611919.gif"></div><br> 现在，我们已经完成了操作网格的第一步，请保存场景并继续进行下一部分。 <br><br><h2> 网格处理 </h2><br> 在本节中，您将学习有关实时操纵网格的知识。 有很多方法，但是在本教程中，我们将介绍最简单的网格处理类型，即移动先前创建的网格顶点。 <br><br><h3> 收集选定的索引 </h3><br> 让我们从选择实时移动的顶点开始。 <br><br> 打开“场景<em>02”，</em>从“ <em>场景”</em>文件夹中<em>创建“心脏网格</em> ”。 在“场景”窗口中，您将看到一个红色的球体。 在“ <em>层次结构”中</em>选择“ <em>球形”</em> ，然后转到“ <em>检查器”</em> 。 您将看到<em>Heart Mesh</em>脚本组件已附加到该对象。 <br><br> 现在，我们需要此对象的编辑器脚本，以在“场景”窗口中显示网格的顶点。 转到“ <em>编辑器”</em>文件夹，然后双击<em>HeartMeshInspector.cs</em> 。 <br><br> 在<code>ShowHandle()</code>函数的<code>if</code>块内，添加以下内容： <br><br><pre> <code class="cs hljs">Handles.color = Color.blue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Handles.Button(point, handleRotation, mesh.pickSize, mesh.pickSize, Handles.DotHandleCap)) <span class="hljs-comment"><span class="hljs-comment">//1 { mesh.selectedIndices.Add(index); //2 }</span></span></code> </pre> <br> 代码说明： <br><br><ol><li> 设置并显示网格的顶点，类型为<code>Handles.Button</code> 。 </li><li> 单击后，会将选定的索引添加到按下的<code>mesh.selectedIndices</code> 。 </li></ol><br> 在<code>OnInspectorGUI()</code> ，在<code>OnInspectorGUI()</code>括号之前，添加以下内容： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button(<span class="hljs-string"><span class="hljs-string">"Clear Selected Vertices"</span></span>)) { mesh.ClearAllData(); }</code> </pre> <br> 代码说明：这是我们向“ <em>检查器”中</em>添加“重置”按钮以调用<code>mesh.ClearAllData()</code> 。 <br><br> 保存文件， <em>然后</em>从“ <em>脚本”</em>文件夹中打开<em>HeartMesh.cs</em> 。 在<code>ClearAllData()</code>函数中，添加以下内容： <br><br><pre> <code class="cs hljs">selectedIndices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); targetIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; targetVertex = Vector3.zero;</code> </pre> <br> 代码说明：代码清除<code>selectedIndices</code>和<code>targetIndex</code>的值。 它还会重置<code>targetVertex</code> 。 <br><br> 保存文件并返回到Unity。 选择<em>Sphere</em>并转到“ <em>检查器”</em>中的<em>HeartMesh</em>脚本<em>组件</em> 。 通过单击旁边的箭头图标来展开<em>选定的索引</em> 。 这将使我们能够跟踪添加到列表中的每个顶点。 <br><br> 使用旁边的复选框启用“ <em>是编辑模式</em> ”。 因此，将在“场景”窗口中绘制网格的顶点。 单击“ <em>选定指数”中</em>的蓝点应相应地更改值。 还要测试“ <em>清除选定的顶点”</em>按钮，以确保它清除了所有值。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17a/271/dea/17a271dea970e9c3ade451773b87eb65.gif"></div><br>  <em>注意：</em>在经过修改的自定义<em>Inspector中</em> ，我们可以选择使用<em>Show Transform Handle</em>显示/隐藏转换操纵器。 因此，如果在其他场景中找不到“变形”操纵器，请不要惊慌！ 退出前将其打开。 <br><br><h3> 把球变成一颗心 </h3><br> 实时更改网格顶点基本上包括三个步骤： <br><br><ol><li> 将当前网格顶点（在动画之前）复制到<code>mVertices</code> 。 </li><li>  <code>mVertices</code>计算并更改<code>mVertices</code>的值。 </li><li> 在每一步更改时，使用<code>mVertices</code>更新当前的网格顶点，并让Unity自动计算法线。 </li></ol><br> 在<code>Start()</code>函数之前打开<em>HeartMesh.cs</em>和以下变量： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radiusofeffect = <span class="hljs-number"><span class="hljs-number">0.3f</span></span>; <span class="hljs-comment"><span class="hljs-comment">//1 public float pullvalue = 0.3f; //2 public float duration = 1.2f; //3 int currentIndex = 0; //4 bool isAnimate = false; float starttime = 0f; float runtime = 0f;</span></span></code> </pre> <br> 代码说明： <br><br><ol><li> 受目标顶点影响的区域的半径。 </li><li> 拖动力。 </li><li> 动画的持续时间。 </li><li>  <code>selectedIndices</code>列表的当前索引。 </li></ol><br> 在<code>Init()</code>函数的<code>if</code>块之前，添加以下内容： <br><br><pre> <code class="cs hljs">currentIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br> 代码说明：在游戏开始时， <code>currentIndex</code>为0，即<code>selectedIndices</code>列表的第一个索引。 <br><br> 在同一个<code>Init()</code>函数中， <code>else</code>块的右括号之前，添加以下内容： <br><br><pre> <code class="cs hljs">StartDisplacement();</code> </pre> <br> 代码说明：如果<code>isEditMode</code>为false，请运行<code>StartDisplacement()</code>函数。 <br><br> 在<code>StartDisplacement()</code>函数内，添加以下内容： <br><br><pre> <code class="cs hljs">targetVertex = oVertices[selectedIndices[currentIndex]]; <span class="hljs-comment"><span class="hljs-comment">//1 starttime = Time.time; //2 isAnimate = true;</span></span></code> </pre> <br> 代码说明： <br><br><ol><li> 选择<code>targetVertex</code>以开始动画。 </li><li> 设置开始时间并将<code>isAnimate</code>的值<code>isAnimate</code>为true。 </li></ol><br> 在<code>StartDisplacement()</code>函数之后，使用以下代码创建<code>FixedUpdate()</code>函数： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//1 { if (!isAnimate) //2 { return; } runtime = Time.time - starttime; //3 if (runtime &lt; duration) //4 { Vector3 targetVertexPos = oFilter.transform.InverseTransformPoint(targetVertex); DisplaceVertices(targetVertexPos, pullvalue, radiusofeffect); } else //5 { currentIndex++; if (currentIndex &lt; selectedIndices.Count) //6 { StartDisplacement(); } else //7 { oMesh = GetComponent&lt;MeshFilter&gt;().mesh; isAnimate = false; isMeshReady = true; } } }</span></span></span></span></code> </pre> <br> 代码说明： <br><br><ol><li>  <code>FixedUpdate()</code>函数在固定的FPS循环中执行。 </li><li> 如果<code>isAnimate</code>为false，则跳过以下代码。 </li><li> 更改<code>runtime</code>动画。 </li><li> 如果<code>runtime</code>在<code>duration</code>内以内，那么我们将获得<code>targetVertex</code>和<code>DisplaceVertices()</code>的世界坐标，并使用<code>pullvalue</code>和<code>radiusofeffect</code>覆盖目标顶点。 </li><li> 否则，时间到了。 将一个添加到<code>currentIndex</code> 。 </li><li> 检查<code>currentIndex</code>在<code>selectedIndices</code> 。 使用<code>StartDisplacement()</code>转到列表中的下一个顶点。 </li><li> 否则，在列表的末尾，将<code>oMesh</code>数据更改为当前网格， <code>isAnimate</code>为false以停止动画。 </li></ol><br> 在<code>DisplaceVertices()</code>添加以下内容： <br><br><pre> <code class="cs hljs">Vector3 currentVertexPos = Vector3.zero; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sqrRadius = radius * radius; <span class="hljs-comment"><span class="hljs-comment">//1 for (int i = 0; i &lt; mVertices.Length; i++) //2 { currentVertexPos = mVertices[i]; float sqrMagnitute = (currentVertexPos - targetVertexPos).sqrMagnitude; //3 if (sqrMagnitute &gt; sqrRadius) { continue; //4 } float distance = Mathf.Sqrt(sqrMagnitute); //5 float falloff = GaussFalloff(distance, radius); Vector3 translate = (currentVertexPos * force) * falloff; //6 translate.z = 0f; Quaternion rotation = Quaternion.Euler(translate); Matrix4x4 m = Matrix4x4.TRS(translate, rotation, Vector3.one); mVertices[i] = m.MultiplyPoint3x4(currentVertexPos); } oMesh.vertices = mVertices; //7 oMesh.RecalculateNormals();</span></span></code> </pre> <br> 代码说明： <br><br><ol><li> 半径的平方。 </li><li> 我们遍历网格的每个顶点。 </li><li>  <code>sqrMagnitude</code> <code>currentVertexPos</code>和<code>targetVertexPos</code>之间的<code>targetVertexPos</code> 。 </li><li> 如果<code>sqrMagnitude</code>超过<code>sqrRadius</code> ，则转到下一个顶点。 </li><li> 否则，请继续定义<code>falloff</code>值，该值取决于当前顶点到示波器中心点的<code>distance</code> 。 </li><li>  <code>Vector3</code>新的<code>Vector3</code>位置，并将其“变换”应用于当前顶点。 </li><li> 当您退出循环时，我们会将更改的<code>mVertices</code>值分配给<code>mVertices</code> ，并强制Unity重新计算法线。 </li></ol><br><blockquote>  <em>衰减技术的来源</em> <br> 原始公式来自“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">过程示例”</a>资产软件包文件，该文件可从Unity Asset Store免费下载。 </blockquote><br> 保存文件并返回到Unity。 选择<em>Sphere</em> ，转到<em>HeartMesh</em>组件，然后尝试将一些顶点添加到<em>Selected Indices</em>属性中。 禁用“ <em>是编辑”模式</em> ，然后单击“ <em>播放”</em>以查看工作结果。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1e/527/23b/e1e52723b08453591da6d10a28dbe13d.gif"></div><br> 使用<em>Radiusofeffect</em> ， <em>Pullvalue</em>和<em>Duration</em>值进行实验以获得不同的结果。 准备就绪后，请根据以下屏幕截图更改设置。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a63/c44/082/a63c44082183529e737f287cb746dfd6.png"></div><br> 点击<em>播放</em> 。 您的领域变成了一颗心吗？ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/532/c83/ce5532c83ff152100775d62091370bf2.gif"></div><br> 恭喜你！ 在下一部分中，我们将网格保存为预制件，以备将来使用。 <br><br><h3> 实时保存网格 </h3><br> 要在“播放”模式下保存心形程序网格，您需要准备一个预制件，其子代将是3D对象，然后使用脚本将其网格资源替换为新的预制资产。 <br><br> 在“ <em>项目”</em>窗口中<em>，</em>在<em>Prefabs</em>文件夹中找到<em>CustomHeart</em> 。 单击箭头图标以展开其内容，然后选择“ <em>子级”</em> 。 现在，您将在“ <em>检查器”</em>预览窗口中看到一个Sphere对象。 这是预制件，将存储新网格的数据。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a3/f07/048/9a3f070486f3a66ee56304dae5bd2b12.png"></div><br> 打开<em>HeartMeshInspector.cs</em> 。 在<code>OnInspectorGUI()</code>函数内，在<code>OnInspectorGUI()</code>括号之前，添加以下内容： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mesh.isEditMode &amp;&amp; mesh.isMeshReady) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = <span class="hljs-string"><span class="hljs-string">"Assets/Prefabs/CustomHeart.prefab"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//1 if (GUILayout.Button("Save Mesh")) { mesh.isMeshReady = false; Object pfObj = AssetDatabase.LoadAssetAtPath(path, typeof(GameObject)); //2 Object pfRef = AssetDatabase.LoadAssetAtPath (path, typeof(GameObject)); GameObject gameObj = (GameObject)PrefabUtility.InstantiatePrefab(pfObj); Mesh pfMesh = (Mesh)AssetDatabase.LoadAssetAtPath(path, typeof(Mesh)); //3 if (!pfMesh) { pfMesh = new Mesh(); } else { pfMesh.Clear(); } pfMesh = mesh.SaveMesh(); //4 AssetDatabase.AddObjectToAsset(pfMesh, path); gameObj.GetComponentInChildren&lt;MeshFilter&gt;().mesh = pfMesh; //5 PrefabUtility.ReplacePrefab(gameObj, pfRef, ReplacePrefabOptions.Default); //6 Object.DestroyImmediate(gameObj); //7 } }</span></span></code> </pre> <br> 代码说明： <br><br><ol><li> 将路径设置为CustomHeart <em>预制</em>对象的路径。 </li><li> 从CustomHeart <em>预制中</em>创建两个对象，一个用于创建实例作为<code>pfObj</code> （ <code>pfObj</code> ），第二个用于创建链接（ <code>pfRef</code> ）。 </li><li>  <code>pfMesh</code>创建pfMesh网格物体<code>pfMesh</code> <em>的</em>实例。 如果找不到，则创建一个新的网格，否则将清理现有数据。 </li><li> 用新的网格数据<code>pfMesh</code> ，然后将其作为资产添加到<em>CustomHeart</em> 。 <br></li><li>  <code>gameObj</code>值<code>pfMesh</code>填充<code>gameObj</code>的网格<code>gameObj</code>资产。 </li><li>  <code>gameObj</code>匹配预先存在的连接，用<code>gameObj</code>替换<em>CustomHeart</em> 。 </li><li> 立即销毁<code>gameObj</code> 。 </li></ol><br> 保存文件并转到<em>HeartMesh.cs</em> 。 在常规的<code>SaveMesh()</code>方法中，创建<code>nMesh</code>实例后<code>nMesh</code>添加以下内容： <br><br><pre> <code class="cs hljs">nMesh.name = <span class="hljs-string"><span class="hljs-string">"HeartMesh"</span></span>; nMesh.vertices = oMesh.vertices; nMesh.triangles = oMesh.triangles; nMesh.normals = oMesh.normals;</code> </pre> <br> 代码说明：返回带有心形网格物体值的网格物体资产。 <br><br> 保存文件并返回到Unity。 点击<em>播放</em> 。 动画完成后，“ <em>保存网格”</em>按钮将出现在“ <em>检查器”中</em> 。 单击按钮保存新的网格，然后停止播放器。 <br><br> 转到<em>Prefabs</em>文件夹，然后查看CustomHeart <em>预制件</em> 。 您应该看到，现在CustomHeart <em>预制</em>对象中有了一个全新的心形网格。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/126/dee/103/126dee103ce798611d2dc2e94013c23c.png"></div><br>  <i>干得好！</i> <br><br><h2> 全部放在一起 </h2><br> 在上一个场景中， <code>DisplaceVertices()</code>函数使用Falloff公式来确定在给定半径内应用于每个顶点的拖动力。 阻力开始减小的“下降”点取决于所使用的衰减类型：线性，高斯或针。 每种类型在网格中产生不同的结果。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/284/9c0/9ff2849c0d0fe5f9d496d641c07e35d8.png"></div><br> 在本节中，我们将介绍另一种操作顶点的方法：使用给定曲线。 根据速度等于距离除以时间（d =（v / t））的规则，我们可以参考向量的距离除以时间来确定向量的位置。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/2d6/13c/3b82d613cedaf85e12db66beb6349201.gif"></div><br><h3> 使用曲线法 </h3><br> 保存当前场景，然后从“ <em>场景”</em>文件夹中打开<em>03“自定义心脏网格</em> ”。 您将看到CustomHeart <em>预制件</em>的<em>Hierarchy</em>实例。 单击其旁边的箭头图标以展开其内容，然后选择<em>Child</em> 。 <br><br> 在<em>检查器中</em>查看其属性。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您将看到</font><font style="vertical-align: inherit;">带有“ </font><em><font style="vertical-align: inherit;">心脏网格</font></em><font style="vertical-align: inherit;">资源” </font><font style="vertical-align: inherit;">的“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网格过滤器”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组件</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">将“ </font><em><font style="vertical-align: inherit;">自定义心脏”</font></em><font style="vertical-align: inherit;">脚本作为组件</font><font style="vertical-align: inherit;">附加到</font><em><font style="vertical-align: inherit;">Child</font></em><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在，资产应从</font><em><font style="vertical-align: inherit;">HeartMesh</font></em><font style="vertical-align: inherit;">更改</font><font style="vertical-align: inherit;">为</font><em><font style="vertical-align: inherit;">克隆</font></em><font style="vertical-align: inherit;">。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/954/27f/89d/95427f89d17410e26893a0ec27dff51d.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，</font><font style="vertical-align: inherit;">从</font><em><font style="vertical-align: inherit;">Scripts</font></em><font style="vertical-align: inherit;">文件夹中</font><font style="vertical-align: inherit;">打开</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomHeart.cs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在功能之前，</font><font style="vertical-align: inherit;">添加以下内容：</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><code>Start()</code><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CurveType { Curve1, Curve2 } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CurveType curveType; Curve curve;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码说明：在此名称下创建了一个通用枚举</font></font><code>CurveType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，之后可从</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inspector中使用它</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转到</font></font><code>CurveType1()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并添加以下内容：</font></font><br><br><pre> <code class="cs hljs">Vector3[] curvepoints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//1 curvepoints[0] = new Vector3(0, 1, 0); curvepoints[1] = new Vector3(0.5f, 0.5f, 0); curvepoints[2] = new Vector3(1, 0, 0); curve = new Curve(curvepoints[0], curvepoints[1], curvepoints[2], false); //2</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 代码说明： </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个简单的曲线由三个点组成。</font><font style="vertical-align: inherit;">设置第一条曲线的点。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们借助帮助生成第一条曲线</font></font><code>Curve()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并指定其值</font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果将true指定为最后一个参数，则可以在预览中显示绘制的曲线。</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转到</font></font><code>CurveType2()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并添加以下内容：</font></font><br><br><pre> <code class="cs hljs">Vector3[] curvepoints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//1 curvepoints[0] = new Vector3(0, 0, 0); curvepoints[1] = new Vector3(0.5f, 1, 0); curvepoints[2] = new Vector3(1, 0, 0); curve = new Curve(curvepoints[0], curvepoints[1], curvepoints[2], false); //2</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 代码说明： </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 设置第二条曲线的点。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们用生成第二条曲线</font></font><code>Curve()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并指定其值</font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果将true指定为最后一个参数，则可以在预览中显示绘制的曲线。</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><code>StartDisplacement()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在右括号之前，添加以下内容：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curveType == CurveType.Curve1) { CurveType1(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curveType == CurveType.Curve2) { CurveType2(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码说明：在这里，我们检查用户选择的选项</font></font><code>curveType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并相应地生成它</font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B </font></font><code>DisplaceVertices()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在循环语句</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的右括号之前，添加以下内容：</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> increment = curve.GetPoint(distance).y * force; <span class="hljs-comment"><span class="hljs-comment">//1 Vector3 translate = (vert * increment) * Time.deltaTime; //2 Quaternion rotation = Quaternion.Euler(translate); Matrix4x4 m = Matrix4x4.TRS(translate, rotation, Vector3.one); mVertices[i] = m.MultiplyPoint3x4(mVertices[i]);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 代码说明： </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们得到了一个给定曲线上的位置</font></font><code>distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并乘其价值</font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上</font></font><code>force</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获得</font></font><code>increment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建一个新的数据类型</font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来存储当前顶点的新位置，并相应地应用其“变换”。</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存文件并返回到Unity。</font><font style="vertical-align: inherit;">检查组件的属性</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomHeart</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏对象</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">儿童</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您将看到一个下拉列表，您可以在其中选择“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲线类型”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">从“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编辑类型”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下拉列表中，</font><font style="vertical-align: inherit;">选择“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加索引”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">删除索引”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以更新顶点列表并尝试不同的设置。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/792/1a7/3b6/7921a73b676b205bd33ec1db076cd4a6.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 要查看不同类型曲线的详细结果，请根据屏幕截图输入值： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e06/ab3/e5d/e06ab3e5d0bfc950be0c6dbc82d36f6e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲线类型”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列表，</font><font style="vertical-align: inherit;">选择“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curve1”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，确保</font><em><font style="vertical-align: inherit;">未</font></em><font style="vertical-align: inherit;">选择</font><font style="vertical-align: inherit;">“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编辑类型”，</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后单击“ </font><em><font style="vertical-align: inherit;">播放”</font></em><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">您应该看到网格分散到图案中。</font><font style="vertical-align: inherit;">滚动模型以在侧视图中查看它，并比较两种曲线的结果。</font><font style="vertical-align: inherit;">在这里，您将看到所选</font><em><font style="vertical-align: inherit;">曲线类型</font></em><font style="vertical-align: inherit;">如何影响网格偏移。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/f90/4d5/8e1f904d50987247014011ac32261134.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da0/e1a/df4/da0e1adf49f8503188f47826c4079cf1.png"></div><br> 仅此而已！<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以单击“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清除选定的顶点”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以重置“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选定的索引”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并尝试使用自己的样式。</font><font style="vertical-align: inherit;">但是不要忘记，还有其他因素会影响网格的最终结果，即：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 半径值。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 顶点在该区域中的分布。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 选定顶点的图案位置。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为偏移量选择的方法。 </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 接下来要去哪里？ </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成项目的</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件位于</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">教程</font><a href=""><font style="vertical-align: inherit;">项目</font></a><font style="vertical-align: inherit;">的</font><a href=""><font style="vertical-align: inherit;">存档中</font></a><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不要在这里停下来！</font><font style="vertical-align: inherit;">尝试使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity Procedural Maze Generation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">教程中使用的更复杂的技术</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我希望您喜欢本教程并发现信息有帮助。</font><font style="vertical-align: inherit;">特别感谢我表达</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">碧玉弗里克</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">猫爪编码</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为他的优秀教程，帮我组装我的项目演示。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/190/e37/362/190e3736241796c39eac74bbe3ddc86e.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN428796/">https://habr.com/ru/post/zh-CN428796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN428786/index.html">基于自旋共振和单线三重态系统操纵的量子处理器</a></li>
<li><a href="../zh-CN428788/index.html">在Bitfury Clarke的幕后-我们的新采矿芯片如何工作</a></li>
<li><a href="../zh-CN428790/index.html">我们正在使用longpoll在python中为VKontakte编写机器人聊天。 第二部分 双循环，异常和其他异端</a></li>
<li><a href="../zh-CN428792/index.html">新的Apple T2芯片使笔记本电脑的内置麦克风难以收听</a></li>
<li><a href="../zh-CN428794/index.html">约束问题数学优化的基本方法概述</a></li>
<li><a href="../zh-CN428798/index.html">如何在独立开发人员中生存。 第二部分</a></li>
<li><a href="../zh-CN428800/index.html">烹饪完美的CSS</a></li>
<li><a href="../zh-CN428806/index.html">消费者支票分析：他们在亚马逊购买的商品</a></li>
<li><a href="../zh-CN428808/index.html">学生生活中的不便</a></li>
<li><a href="../zh-CN428810/index.html">18种音频数字技术材料</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>