<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚼 👨‍👨‍👧‍👦 👩🏻‍🍳 C ++ Rusia: bagaimana itu 🕡 👨🏽‍🏭 🕺🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika pada awal permainan Anda mengatakan bahwa kode C ++ tergantung di dinding, maka pada akhirnya pasti akan menembak Anda di kaki. 

 Bjarne Stroust...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ Rusia: bagaimana itu</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/481358/">  <i>Jika pada awal permainan Anda mengatakan bahwa kode C ++ tergantung di dinding, maka pada akhirnya pasti akan menembak Anda di kaki.</i> <i><br><br></i>  <i>Bjarne Stroustrup</i> <i><br></i> <br>  Dari 31 Oktober hingga 1 November, St. Petersburg menjadi tuan rumah Konferensi Piter Rusia C ++ Rusia, salah satu konferensi pemrograman terbesar di Rusia yang diselenggarakan oleh Grup JUG Ru.  Di antara pembicara yang diundang adalah anggota komite standardisasi C ++, pembicara dengan CppCon, penulis buku oleh O'Reilly, serta pemelihara proyek seperti LLVM, libc ++ dan Boost.  Konferensi ini ditujukan untuk pengembang C ++ berpengalaman yang ingin memperdalam keahlian mereka dan bertukar pengalaman dalam komunikasi langsung.  Mahasiswa, mahasiswa pascasarjana dan profesor universitas ditawari diskon yang sangat menyenangkan. <br><br>  Edisi konferensi Moskow sudah dapat dikunjungi pada bulan April tahun depan, tetapi untuk saat ini siswa kami akan memberi tahu Anda hal-hal menarik apa yang mereka pelajari di acara terakhir. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a73/7bf/78f/a737bf78fa7a626dc60d87aae2d2ce88.png"><br><a name="habracut"></a><br>  <i>Foto dari <a href="https://vk.com/album-77278886_270140987">album konferensi</a></i> <br><br><h2>  Tentang kami </h2><br>  Dua siswa dari Sekolah Tinggi Ekonomi - St. Petersburg, mengerjakan pos ini: <br><br><ul><li>  Lisa Vasilenko adalah mahasiswa sarjana tahun ke-4 yang mempelajari arah "Bahasa Pemrograman" sebagai bagian dari program "Matematika Terapan dan Ilmu Komputer".  Berkenalan dengan bahasa C ++ di tahun pertama universitas, kemudian memperoleh pengalaman bekerja dengan itu di magang di industri.  Semangat untuk bahasa pemrograman pada pemrograman umum dan fungsional khususnya meninggalkan jejak pada pilihan laporan di konferensi. <br></li><li>  Danya Smirnov adalah siswa tahun pertama dari program master "Pemrograman Data dan Analisis".  Ketika masih di sekolah, ia menulis masalah Olimpiade di C ++, dan kemudian entah bagaimana bahasa itu terus muncul dalam kegiatan pendidikan dan sebagai hasilnya menjadi yang bekerja utama.  Saya memutuskan untuk berpartisipasi dalam konferensi untuk meningkatkan pengetahuan saya, serta belajar tentang peluang baru. <br></li></ul><br>  Dalam buletin, para pemimpin fakultas sering berbagi informasi tentang acara-acara pendidikan yang berkaitan dengan spesialisasi kami.  Pada bulan September, kami melihat informasi tentang C ++ Rusia dan memutuskan untuk mendaftar sebagai pendengar.  Ini adalah pengalaman pertama kami berpartisipasi dalam konferensi semacam itu. <br><br><h2>  Struktur Konferensi </h2><br><ul><li><h3>  Laporan </h3></li></ul><br>  Selama dua hari, para ahli membaca 30 laporan yang menyoroti banyak topik hangat: aplikasi cerdas fitur bahasa untuk menyelesaikan masalah yang diterapkan, pembaruan bahasa mendatang karena standar baru, kompromi dalam desain C ++ dan tindakan pencegahan ketika bekerja dengan konsekuensinya, contoh arsitektur proyek yang menarik, serta beberapa bagian mesin dari infrastruktur bahasa.  Pada saat yang sama, 3 pertunjukan berlangsung, paling sering dua dalam bahasa Rusia dan satu dalam bahasa Inggris. <br><br><ul><li><h3>  Zona diskusi </h3></li></ul><br>  Setelah pidato tersebut, semua pertanyaan yang tidak terjawab dan diskusi tidak lengkap dipindahkan ke area komunikasi yang dirancang khusus dengan pembicara yang dilengkapi dengan papan penanda.  Cara yang baik untuk melewati jeda antara pertunjukan untuk percakapan yang menyenangkan. <br><br><ul><li><h3>  Pembicaraan Petir dan diskusi informal </h3></li></ul><br>  Jika Anda ingin membuat laporan singkat, Anda dapat mendaftar untuk Petir Talk malam di papan penanda dan mendapatkan lima menit waktu untuk berbicara tentang apa pun tentang topik konferensi.  Misalnya, pengantar cepat pembersih untuk C ++ (yang ternyata baru bagi sebagian orang) atau cerita tentang bug pada generasi sinusoid yang hanya bisa Anda dengar tetapi tidak dilihat. <br><br>  Format lain adalah diskusi panel “With the Soul Committee”.  Di atas panggung ada beberapa anggota komite standardisasi, di proyektor ada perapian (secara resmi - untuk menciptakan suasana yang penuh perasaan, tetapi alasan "karena SEMUANYA KEBAKARAN" tampaknya lebih lucu), pertanyaannya adalah tentang visi standar dan umum dari C ++, tanpa diskusi teknis dan holivar yang dipanaskan.  Ternyata orang yang masih hidup juga duduk di komite, yang mungkin tidak sepenuhnya yakin akan sesuatu atau mungkin tidak tahu sesuatu. <br><br>  Untuk penggemar holivar, acara ketiga tetap - sesi BOF "Go menentang C ++".  Kami mengambil kekasih Go, kekasih C ++, sebelum memulai sesi, mereka menyiapkan 100500 slide pada topik bersama-sama (seperti masalah dengan paket dalam C ++ atau kurangnya obat generik di Go), dan kemudian mereka dengan bersemangat membahas antara mereka sendiri dan audiens, dan audiens mencoba memahami dua sudut pandang sekaligus. .  Jika holivar tidak memulai bisnis, moderator mengintervensi dan merekonsiliasi para pihak.  Format ini membuat ketagihan: beberapa jam setelah dimulainya, hanya setengah dari slide yang selesai.  Akhirnya harus dipercepat. <br><br><ul><li><h3>  Mitra Berdiri </h3></li></ul><br>  Mitra konferensi diwakili di aula - mereka berbicara tentang proyek saat ini di stan, menawarkan magang dan pekerjaan, mengadakan kuis dan kompetisi kecil, dan juga memainkan hadiah bagus.  Namun, beberapa perusahaan bahkan menawarkan untuk melalui tahap awal wawancara, yang mungkin berguna bagi mereka yang datang tidak hanya untuk mendengarkan laporan. <br><br><h2>  Detail teknis dari laporan </h2><br>  Kami mendengarkan laporan dua hari.  Terkadang sulit untuk memilih satu laporan dari yang berjalan secara paralel - kami sepakat untuk berbagi dan bertukar pengetahuan yang diperoleh selama istirahat.  Meski begitu, tampaknya banyak yang hilang.  Di sini kami ingin berbicara tentang konten beberapa laporan yang menurut kami paling menarik <br><br><h3>  Pengecualian dalam C ++ melalui prisma optimasi kompiler, Roman Rusyaev </h3><br><br><img src="https://habrastorage.org/webt/dc/0q/rl/dc0qrlgt1peqimzact93fvh8zb0.png"><br>  <i>Slide <a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">presentasi</a></i> <br><br>  Seperti namanya, Roman melihat bekerja dengan pengecualian menggunakan LLVM sebagai contoh.  Pada saat yang sama, bagi mereka yang tidak menggunakan dentang dalam pekerjaan mereka, laporan tersebut masih dapat memberikan beberapa gagasan tentang bagaimana kode berpotensi dioptimalkan.  Ini karena pengembang kompiler dan pustaka standar yang sesuai berkomunikasi satu sama lain dan banyak solusi yang berhasil mungkin bersamaan. <br><br>  Jadi, untuk menangani pengecualian, Anda perlu melakukan banyak tindakan: hubungi kode pemrosesan (jika ada) atau membebaskan sumber daya di level saat ini dan melepas tumpukan lebih tinggi.  Semua ini mengarah pada fakta bahwa kompiler menambahkan instruksi tambahan untuk berpotensi melakukan panggilan.  Oleh karena itu, jika pengecualian pada kenyataannya tidak disebabkan, program masih akan mulai melakukan tindakan yang tidak perlu.  Untuk mengurangi biaya overhead, LLVM memiliki beberapa heuristik untuk menentukan situasi di mana Anda tidak perlu menambahkan kode penanganan pengecualian atau Anda dapat mengurangi jumlah instruksi "yang tidak perlu". <br><br>  Pembicara mempertimbangkan sekitar selusin dari mereka dan menunjukkan kedua situasi di mana mereka membantu mempercepat pelaksanaan program, dan situasi di mana metode ini tidak berlaku. <br><br>  Dengan demikian, Roman Rusyaev mengarahkan audiens ke kesimpulan bahwa kode yang berisi pekerjaan dengan pengecualian tidak dapat selalu dieksekusi dengan overhead nol, dan memberikan tips berikut: <br><br><ul><li>  saat mengembangkan perpustakaan, Anda harus meninggalkan pengecualian pada prinsipnya; </li><li>  jika Anda masih membutuhkan pengecualian, maka sedapat mungkin ada baiknya menambahkan pengubah noexcept (dan const) sehingga kompiler dapat mengoptimalkan sebanyak mungkin. </li></ul><br>  Secara umum, pembicara menegaskan kembali pandangan bahwa pengecualian paling baik digunakan untuk minimum, atau bahkan meninggalkannya. <br><br>  Slide laporan tersedia di: <a href="https://assets.ctfassets.net/oxjq45e8ilak/6Q09SPvX2Rsveiayc1VkcC/ce9e2b8eb22d6693eb4c3b06968bedc0/100693_477384438_Roman_Rusyayev_Isklyucheniya_C_cherez_prizmu_kompilyatornykh_optimizatsiy.pdf">[“C ++ Pengecualian Melalui Prisma Optimalisasi Kompiler LLVM”]</a> <br><br><h3>  Generator, coroutine, dan rasa manis tak terkendali lainnya di otak, Adi Shavit </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d20/0c4/4a6/d200c44a65058c3b50a29d0b551a9cc0.png"><br>  <i>Slide <a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">presentasi</a></i> <br><br>  Salah satu dari banyak laporan konferensi ini yang ditujukan untuk inovasi C ++ 20 diingat tidak hanya oleh presentasi yang disajikan dengan penuh warna, tetapi juga oleh penunjukan yang jelas dari masalah yang ada dengan logika pemrosesan koleksi (untuk, loop panggilan balik). <br><br>  Adi Shavit menyoroti hal-hal berikut: metode yang saat ini tersedia melewati seluruh koleksi dan tidak memberikan akses ke beberapa kondisi perantara internal (atau memberi dalam hal panggilan balik, tetapi dengan banyak efek samping yang tidak menyenangkan, seperti Neraka Panggilan Balik yang sama).  Tampaknya ada iterator, tetapi semuanya tidak begitu mulus dengan mereka: tidak ada titik masuk dan keluar yang umum (mulai → akhir versus rbegin → rend dan seterusnya), tidak jelas berapa banyak yang akan kita ulangi sama sekali?  Dimulai dengan C ++ 20, masalah ini terpecahkan! <br><br>  Opsi pertama: rentang.  Karena pembungkus di atas iterator, kami mendapatkan antarmuka umum untuk awal dan akhir iterasi, serta kemungkinan komposisi.  Semua ini membuatnya mudah untuk membangun jaringan pipa pemrosesan data yang lengkap.  Tetapi tidak semuanya begitu lancar: bagian dari logika perhitungan ada di dalam implementasi iterator tertentu, yang dapat menyulitkan kode untuk persepsi dan debugging. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f41/a7d/09d/f41a7d09d24a823a3397aa27a552f254.png"><br>  <i>Slide <a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">presentasi</a></i> <br><br>  Nah, untuk kasus ini, coroutine ditambahkan dalam C ++ 20 (fungsi yang perilakunya mirip dengan generator di Python): eksekusi dapat ditunda dengan mengembalikan beberapa nilai saat ini sambil mempertahankan keadaan menengah.  Dengan demikian, kami mencapai tidak hanya bekerja dengan data saat mereka muncul, tetapi juga merangkum semua logika di dalam coroutine tertentu. <br><br>  Tetapi ada lalat di salep: saat ini mereka hanya didukung sebagian oleh kompiler yang ada, dan mereka juga tidak diimplementasikan seakurat yang kita inginkan: misalnya, tautan dan benda sementara tidak boleh digunakan di coroutine.  Plus, ada beberapa batasan pada apa yang bisa menjadi coroutine, dan fungsi constexpr, konstruktor / destruktor, dan juga utama tidak termasuk dalam daftar ini. <br><br>  Dengan demikian, coroutine memecahkan sebagian besar masalah dengan kesederhanaan logika pemrosesan data, tetapi implementasinya saat ini membutuhkan perbaikan. <br><br>  Bahan: <br><br><ul><li>  Slide dengan C ++ Russia - <a href="https://assets.ctfassets.net/oxjq45e8ilak/3zTOtMpTyFdmP3vxsQ9xoc/40e5a0892609b16f822120813f5f0823/100554_1921552449_Adi_Shavit_Generators_coroutines_and_other_brain-unrolling_sweetness.pdf">["Generator, coroutine, dan rasa manis yang tidak bisa dikendalikan oleh otak lainnya"]</a> </li><li>  <a href="https://youtu.be/qYHDERleSL8">Laporan Video Dari CppCon 2019</a> </li></ul><br><h3>  Trik C ++ dari Yandex.Taxi, Anton Polukhin </h3><br>  Dalam aktivitas profesionalnya, kadang-kadang Anda harus menerapkan hal-hal tambahan murni: pembungkus antara antarmuka internal dan API dari beberapa perpustakaan, masuk atau parsing.  Namun, biasanya tidak perlu untuk optimasi tambahan.  Tetapi bagaimana jika komponen-komponen ini digunakan di beberapa layanan paling populer di Runet?  Dalam situasi seperti itu, Anda harus memproses terabyte per jam dari log saja!  Kemudian setiap milidetik berarti dan karena itu Anda harus menggunakan berbagai trik - Anton Polukhin berbicara tentang mereka. <br><br>  Mungkin contoh yang paling menarik adalah penerapan pola pointer-to-implementasi (pimpl). <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;third_party/json.hpp&gt; //PROBLEMS! struct Value { Value() = default; Value(Value&amp;&amp; other) = default; Value&amp; operator=(Value&amp;&amp; other) = default; ~Value() = default; std::size_t Size() const { return data_.size(); } private: third_party::Json data_; };</span></span></span></span></code> </pre> <br>  Dalam contoh ini, pertama Anda ingin menyingkirkan file header perpustakaan eksternal - itu akan mengkompilasi lebih cepat, dan Anda dapat melindungi diri dari kemungkinan konflik nama dan kesalahan serupa lainnya. <br><br>  Oke, pindahkan #sertakan ke file .cpp: Anda memerlukan deklarasi maju dari API yang dibungkus, serta std :: unique_ptr.  Sekarang kami memiliki alokasi dinamis dan hal-hal tidak menyenangkan lainnya, seperti data yang tersebar di tumpukan dan mengurangi jaminan.  Dengan semua ini, std :: aligned_storage dapat membantu. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... private: using JsonNative = third_party::Json; const JsonNative* Ptr() const noexcept; JsonNative* Ptr() noexcept; constexpr std::size_t kImplSize = 32; constexpr std::size_t kImplAlign = 8; std::aligned_storage_t&lt;kImplSize, kImplAlign&gt; data_; };</span></span></code> </pre> <br>  Satu-satunya masalah: Anda perlu menentukan ukuran dan perataan untuk setiap bungkus - kami akan membuat template jerawat kami dengan parameter &lt;T, SizeT, AlignmentT&gt;, menggunakan beberapa nilai arbitrer dan menambahkan ke destructor tanda centang yang kami tebak semuanya: <br><br><pre> <code class="cpp hljs">~FastPimpl() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { validate&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(T)&gt;(); Ptr()-&gt;~T(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ActualSize, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ActualAlignment&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( Size == ActualSize, <span class="hljs-string"><span class="hljs-string">"Size and sizeof(T) mismatch"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( Alignment == ActualAlignment, <span class="hljs-string"><span class="hljs-string">"Alignment and alignof(T) mismatch"</span></span> ); }</code> </pre> <br>  Karena T sudah didefinisikan selama pemrosesan destruktor, kode ini akan diuraikan dengan benar dan pada tahap kompilasi, kode ini akan menampilkan ukuran dan nilai perataan yang diperlukan yang perlu dimasukkan dalam bentuk kesalahan.  Jadi, dengan mengorbankan satu awal tambahan kompilasi, kami menyingkirkan alokasi dinamis dari kelas yang dibungkus, menyembunyikan API dalam file .cpp dengan implementasinya, dan juga mendapatkan desain yang lebih cocok untuk caching oleh prosesor. <br><br>  Penebangan dan penguraian tampak kurang mengesankan, dan karenanya tidak akan disebutkan dalam ulasan ini. <br><br>  Slide laporan tersedia di tautan: <a href="https://assets.ctfassets.net/oxjq45e8ilak/4rkoaQV6ancsfvzYx1fOCF/087dda7d63101cc225d706d03d7c5075/100566_2093066332_Anton_Polukhin_C_tryuki_iz_Taksi.pdf">[“Trik Taksi C ++”]</a> <br><br><h3>  Teknik modern untuk menjaga kode Anda KERING, Björn Fahller </h3><br>  Dalam ceramah ini, Björn Fahller menunjukkan beberapa cara berbeda untuk menangani kekurangan gaya bahasa seperti pemeriksaan bersyarat berulang: <br><br><pre> <code class="cpp hljs">assert(a == IDLE || a == CONNECTED || a == DISCONNECTED);</code> </pre> <br>  Apakah itu familier?  Menggunakan beberapa teknik C ++ yang kuat yang telah muncul dalam standar terbaru, Anda dapat mengimplementasikan fungsi yang sama dengan anggun tanpa kehilangan kinerja sedikit pun.  Bandingkan: <br><br><pre> <code class="cpp hljs">assert(a == any_of(IDLE, CONNECTED, DISCONNECTED));</code> </pre> <br>  Untuk memproses jumlah cek yang tidak terbatas, Anda segera diminta untuk menggunakan templat variadic dan melipat ekspresi.  Misalkan kita ingin memeriksa kesetaraan beberapa variabel ke elemen enum'a state_type.  Hal pertama yang terlintas dalam pikiran adalah untuk menulis fungsi pembantu is_any_of: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> state_type { IDLE, CONNECTED, DISCONNECTED }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state_type s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ts&amp; ... ts)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((s == ts) || ...); }</code> </pre><br>  Hasil antara seperti itu mengecewakan.  Sejauh ini, kode tidak dapat dibaca: <br><br><pre> <code class="cpp hljs">assert(is_any_of(state, IDLE, DISCONNECTING, DISCONNECTED));</code> </pre> <br>  Parameter template non-tipe akan membantu sedikit memperbaiki situasi.  Dengan bantuan mereka, kami mentransfer elemen enum enumerasi ke daftar parameter template: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;state_type ... states&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state_type t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((t == states) | ...); } assert(is_any_of&lt;IDLE, DISCONNECTING, DISCONNECTED&gt;(state));</code> </pre> <br>  Menggunakan otomatis dalam parameter template non-tipikal (C ++ 17), pendekatan ini hanya digeneralisasikan untuk perbandingan tidak hanya dengan elemen state_type, tetapi juga dengan tipe primitif yang dapat digunakan sebagai parameter template non-tipe: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ... alternatives, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((t == alternatives) | ...); }</code> </pre> <br>  Melalui peningkatan bertahap ini, sintaksis sepintas yang diinginkan untuk pemeriksaan tercapai: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any_of</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts ...&gt; { <span class="hljs-comment"><span class="hljs-comment">//      tuple        using std::tuple&lt;Ts ...&gt;::tuple;        template &lt;typename T&gt;        bool operator ==(const T&amp; t) const {                return std::apply(                        [&amp;t](const auto&amp; ... ts) {                                return ((ts == t) || ...);                        },                        static_cast&lt;const std::tuple&lt;Ts ...&gt;&amp;&gt;(*this));        } }; template &lt;class ... Ts&gt; any_of(Ts ...) -&gt; any_of&lt;Ts ... &gt;; assert(any_of(IDLE, DISCONNECTING, DISCONNECTED) == state);</span></span></code> </pre><br>  Dalam contoh ini, panduan deduksi berfungsi untuk meminta parameter struktur template yang diinginkan ke kompiler yang mengetahui tipe argumen konstruktor. <br><br>  Lebih menarik.  Bjorn mengajarkan untuk menggeneralisasi kode yang dihasilkan untuk operator perbandingan selain ==, dan kemudian untuk operasi sewenang-wenang.  Seiring dengan use case, fitur-fitur seperti atribut no_unique_address (C ++ 20) dan parameter template dalam fungsi lambda (C ++ 20) dijelaskan.  (Ya, sekarang sintaks lambda bahkan lebih mudah diingat - ini adalah empat pasang kurung berturut-turut dari semua jenis.) Solusi terakhir menggunakan fungsi sebagai bagian konstruktor benar-benar menghangatkan jiwa saya, belum lagi ekspresi tuple dalam tradisi terbaik kalkulus lambda. <br><br>  Pada akhirnya, jangan lupa untuk membuat gloss: <br><br><ul><li>  Ingat bahwa lambda adalah constexpr gratis; </li><li>  Tambahkan penerusan sempurna dan lihat sintaks jeleknya sebagaimana diterapkan pada paket parameter pada penutupan lambda; </li><li>  Mari kita beri kompiler lebih banyak opsi untuk optimisasi dengan conditional noexcept; </li><li>  Kami akan menangani output kesalahan yang lebih jelas dalam templat karena nilai pengembalian lambda yang eksplisit.  Ini akan memaksa kompiler untuk melakukan lebih banyak pemeriksaan sebelum benar-benar memanggil fungsi template - pada tahap pengecekan tipe. </li></ul><br>  Untuk perincian, lihat materi kuliah: <br><br><ul><li>  Laporan Slide: <a href="https://assets.ctfassets.net/oxjq45e8ilak/7lP3ueTFEJnmdVjGGjrgHI/e30dfcbff0630fb63389f3f3e734a1a3/100644_2039674689_Bjrn_Fahller_Modern_techniques_for_keeping_your_code_dry.pdf">[Teknik Modern untuk Menjaga Kode Anda KERING]</a> </li><li>  <a href="https://github.com/rollbear/dry-comparisons">Kode sumber Github</a> </li><li>  <a href="https://playfulprogramming.blogspot.com/2018/07/dry-multicomparisons.html">Artikel blog penulis</a> </li></ul><br><h2>  Tayangan kami </h2><br>  Partisipasi pertama kami di C ++ Rusia dikenang karena kekayaannya.  Ada kesan C ++ Rusia sebagai peristiwa emosional, di mana garis antara belajar dan komunikasi langsung hampir tidak terlihat.  Semuanya, mulai dari suasana hati para pembicara hingga kompetisi dari para mitra acara, kondusif untuk diskusi yang memanas.  Isi konferensi, yang terdiri dari laporan, mencakup berbagai topik yang cukup luas, termasuk inovasi C ++, contoh-contoh dari praktik proyek besar, dan pertimbangan arsitektur ideologis.  Tetapi akan tidak adil untuk menghilangkan perhatian dari komponen sosial dari acara tersebut, yang membantu untuk mengatasi hambatan bahasa sehubungan dengan tidak hanya C ++. <br><br>  Kami berterima kasih kepada penyelenggara konferensi atas kesempatan untuk berpartisipasi dalam acara semacam itu! <br>  Anda bisa melihat posting penyelenggara tentang masa lalu, sekarang, dan masa depan C ++ Rusia <a href="https://habr.com/ru/company/jugru/blog/480584/">di blog JUG Ru</a> . <br><br>  Terima kasih telah membaca, dan kami berharap menceritakan kembali acara kami ternyata bermanfaat! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481358/">https://habr.com/ru/post/id481358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481348/index.html">Direktori Aktif Pentest. Bagian 1</a></li>
<li><a href="../id481350/index.html">Siapa yang bekerja di kosmodrom Plesetsk</a></li>
<li><a href="../id481352/index.html">DBA: membersihkan catatan klon dari tabel tanpa PK</a></li>
<li><a href="../id481354/index.html">TelegramBot. Fungsionalitas dasar. Terbang secara terpisah, irisan daging secara terpisah. (Bagian 2)</a></li>
<li><a href="../id481356/index.html">Terima kasih, 2019</a></li>
<li><a href="../id481360/index.html">Hasil minggu ini: Rambler dan Twitch setuju, tenaga kerja elektronik akan diperkenalkan di Federasi Rusia, dan Facebook akan membuat OS sendiri</a></li>
<li><a href="../id481362/index.html">Sertifikat SSL untuk aplikasi web Docker</a></li>
<li><a href="../id481364/index.html">Rumah sensitif menggantikan rumah pintar</a></li>
<li><a href="../id481366/index.html">BERAS: Prioritas Mudah untuk Manajer Produk</a></li>
<li><a href="../id481368/index.html">Tes buta kamera: iPhone, Pixel, Samsung dan Huawei</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>