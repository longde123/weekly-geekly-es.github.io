<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõå üéø üé≤ HTTP / 3: Grundsteinlegung und eine sch√∂ne neue Welt üë©üèΩ‚ÄçüöÄ üòÖ üß¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seit mehr als 20 Jahren betrachten wir Webseiten mit dem HTTP-Protokoll. Die meisten Benutzer denken √ºberhaupt nicht dar√ºber nach, was es ist und wie ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>HTTP / 3: Grundsteinlegung und eine sch√∂ne neue Welt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/473930/">  Seit mehr als 20 Jahren betrachten wir Webseiten mit dem HTTP-Protokoll.  Die meisten Benutzer denken √ºberhaupt nicht dar√ºber nach, was es ist und wie es funktioniert.  Andere wissen, dass es irgendwo unter HTTP TLS gibt und darunter TCP, unter welcher IP und so weiter.  Und die dritten - Ketzer - glauben, dass TCP das letzte Jahrhundert ist, sie wollen etwas schnelleres, zuverl√§ssigeres und sichereres.  Bei ihren Versuchen, ein neues ideales Protokoll zu erfinden, kehrten sie jedoch zu den Technologien der 80er Jahre zur√ºck und versuchen, darauf ihre sch√∂ne neue Welt aufzubauen. <br><img src="https://habrastorage.org/webt/fg/dx/5l/fgdx5lvjrdjflaapjav9z0xwpyk.jpeg"><br><a name="habracut"></a><br><h2>  Ein bisschen Geschichte: HTTP / 1.1 </h2><br>  1997 erhielt das Textaustauschprotokoll der HTTP-Version 1.1 seinen RFC.  Zu dieser Zeit wurde das Protokoll mehrere Jahre lang von Browsern verwendet, und der neue Standard dauerte weitere f√ºnfzehn Jahre.  Das Protokoll arbeitete nur auf Anfrage-Antwort-Basis und war haupts√§chlich f√ºr die √úbertragung von Textinformationen gedacht. <br><br>  HTTP wurde entwickelt, um auf dem TCP-Protokoll aufzubauen, das eine zuverl√§ssige Zustellung von Paketen an das Ziel garantiert.  TCP basiert auf dem Aufbau und der Aufrechterhaltung einer zuverl√§ssigen Verbindung zwischen Endpunkten und der Segmentierung des Datenverkehrs.  Segmente haben ihre eigene Sequenznummer und Pr√ºfsumme.  Wenn pl√∂tzlich eines der Segmente nicht kommt oder mit der falschen Pr√ºfsumme kommt, stoppt die √úbertragung, bis das verlorene Segment wiederhergestellt ist. <br><br>  In HTTP / 1.0 wurde die TCP-Verbindung nach jeder Anforderung geschlossen.  Es war seitdem extrem verschwenderisch  Das Herstellen einer TCP-Verbindung (3-Wege-Handshake) ist kein schneller Vorgang.  HTTP / 1.1 hat den Keep-Alive-Mechanismus eingef√ºhrt, mit dem Sie eine einzelne Verbindung f√ºr mehrere Anforderungen wiederverwenden k√∂nnen.  Da dies jedoch leicht zu einem Engpass werden kann, sind in verschiedenen HTTP / 1.1-Implementierungen mehrere TCP / IP-Verbindungen zum selben Host zul√§ssig.  In Chrome und in neueren Versionen von Firefox sind beispielsweise bis zu sechs Verbindungen zul√§ssig. <br><img src="https://habrastorage.org/webt/jg/89/qj/jg89qjf71ebwzitjnv4uwke3oua.png"><br>  Die Verschl√ºsselung sollte auch anderen Protokollen √ºberlassen werden. Zu diesem Zweck wurde das TLS-Protokoll √ºber TCP verwendet, wodurch Daten zuverl√§ssig gesch√ºtzt wurden, die zum Herstellen einer Verbindung erforderliche Zeit jedoch weiter verl√§ngert wurde.  Infolgedessen sah der Handshake-Prozess folgenderma√üen aus: <br><img src="https://habrastorage.org/webt/2b/nb/qw/2bnbqw9jz94njlrds7e6l-omzmw.png"><br>  <i>Cloudflare-Illustration</i> <br><br>  Daher hatte HTTP / 1.1 eine Reihe von Problemen: <br><br><ul><li>  Langsamer Verbindungsaufbau. </li><li>  Eine TCP-Verbindung wird f√ºr eine Anforderung verwendet. Dies bedeutet, dass der Rest der Anforderungen entweder eine andere Verbindung finden oder warten muss, bis die aktuelle Anforderung sie freigibt. </li><li>  Es wird nur das Pull-Modell unterst√ºtzt.  Es gibt nichts im Standard √ºber Server-Push. </li><li>  √úberschriften werden im Text √ºbertragen. </li></ul><br>  Wenn Server-Push irgendwie mithilfe des WebSocket-Protokolls implementiert wird, mussten die restlichen Probleme radikaler behandelt werden. <br><br><h2>  Ein bisschen Modernit√§t: HTTP / 2 </h2><br>  Im Jahr 2012 begannen die Arbeiten am SPDY-Protokoll (ausgesprochen ‚ÄûGeschwindigkeit‚Äú) im Darm von Google.  Das Protokoll wurde entwickelt, um die grundlegenden Probleme von HTTP / 1.1 zu l√∂sen und gleichzeitig die Abw√§rtskompatibilit√§t aufrechtzuerhalten.  2015 f√ºhrte die IETF-Arbeitsgruppe die HTTP / 2-Spezifikation ein, die auf dem SPDY-Protokoll basiert.  Hier sind die Unterschiede in HTTP / 2: <br><br><ul><li>  Bin√§re Serialisierung. </li><li>  Multiplexen mehrerer HTTP-Anforderungen in eine einzige TCP-Verbindung. </li><li>  Server-Push out of the Box (ohne WebSocket). </li></ul><br>  Das Protokoll war ein gro√üer Schritt vorw√§rts.  Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://">√ºbertrifft die erste Version</a> erheblich und erfordert nicht die Erstellung mehrerer TCP-Verbindungen: Alle Anforderungen an einen Host werden zu einem gemultiplext.  Das hei√üt, in einer Verbindung gibt es mehrere sogenannte Streams, von denen jeder seine eigene ID hat.  Der Bonus ist ein Boxed Server-Push. <br><br>  Die Multiplikation f√ºhrt jedoch zu einem weiteren Eckpfeilerproblem.  Stellen Sie sich vor, wir f√ºhren asynchron 5 Anforderungen an einen Server aus.  Bei Verwendung von HTTP / 2 werden alle diese Anforderungen innerhalb derselben TCP-Verbindung ausgef√ºhrt. Wenn also eines der Segmente einer Anforderung verloren geht oder falsch ankommt, wird die √úbertragung aller Anforderungen und Antworten gestoppt, bis das verlorene Segment wiederhergestellt ist.  Je schlechter die Verbindungsqualit√§t ist, desto langsamer funktioniert HTTP / 2.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://">Laut Daniel Stenberg</a> ist HTTP / 1.1 in einem Browser in einer Situation, in der 2% aller verloren gegangenen Pakete ausmachen, besser als HTTP / 2, da 6 Verbindungen ge√∂ffnet werden und nicht eine. <br><br>  Dieses Problem wird als "Head-of-Line-Blocking" bezeichnet und kann leider nicht mit TCP gel√∂st werden. <br><img src="https://habrastorage.org/webt/nu/zn/ry/nuznryxm_rxuyjadhx2kjyhbluc.png"><br>  <i>Illustration von Daniel Steinberg</i> <br><br>  Infolgedessen haben die Entwickler des HTTP / 2-Standards hervorragende Arbeit geleistet und fast alles getan, was auf Anwendungsebene des OSI-Modells m√∂glich war.  Es ist Zeit, auf die Transportebene zu gehen und ein neues Transportprotokoll zu erfinden. <br><br><h2>  Wir brauchen ein neues Protokoll: UDP vs TCP </h2><br>  Ziemlich schnell wurde klar, dass die Einf√ºhrung eines v√∂llig neuen Transportschichtprotokolls in der heutigen Realit√§t eine unl√∂sbare Aufgabe ist.  Tatsache ist, dass die Dr√ºsen oder Middleboxen (Router, Firewalls, NAT-Server ...) √ºber die Transportebene Bescheid wissen und es etwas √§u√üerst Schwieriges ist, ihnen etwas Neues beizubringen.  Dar√ºber hinaus ist die Unterst√ºtzung f√ºr Transportprotokolle mit dem Kernel von Betriebssystemen verbunden, und auch die Kernel √§ndern sich nicht so bereitwillig. <br><br>  Und hier k√∂nnte man aufgeben und sagen: "Wir werden nat√ºrlich ein neues HTTP / 3 mit Pr√§ferenz und Kurtisanen erfinden, aber es wird in 10-15 Jahren implementiert (nach ungef√§hr dieser Zeit werden die meisten Dr√ºsen ersetzt)", aber es gibt noch eines, nicht das meiste offensichtliche Option: Verwenden Sie das UDP-Protokoll.  Ja, ja, dasselbe Protokoll, nach dem wir Ende der neunziger Jahre und Anfang Null Dateien in ein LAN geworfen haben.  Fast alle heutigen Eisenst√ºcke wissen, wie man damit arbeitet. <br><br>  Was sind die Vorteile von UDP gegen√ºber TCP?  Erstens haben wir keine Transport-Level-Sitzung, von der Iron wei√ü.  Auf diese Weise k√∂nnen wir die Sitzung auf den Endpunkten selbst bestimmen und dort auftretende Konflikte l√∂sen.  Das hei√üt, wir sind nicht auf eine oder mehrere Sitzungen beschr√§nkt (wie in TCP), sondern k√∂nnen sie so oft erstellen, wie wir ben√∂tigen.  Zweitens ist die Daten√ºbertragung √ºber UDP schneller als √ºber TCP.  Theoretisch k√∂nnen wir also die heutige Geschwindigkeitsobergrenze von HTTP / 2 durchbrechen. <br><br>  UDP garantiert jedoch keine zuverl√§ssige Daten√ºbertragung.  Tats√§chlich senden wir einfach Pakete in der Hoffnung, dass sie am anderen Ende empfangen werden.  Nicht erhalten?  Nun, kein Gl√ºck ... Dies war genug, um Videos f√ºr Erwachsene zu √ºbertragen, aber f√ºr ernstere Dinge ben√∂tigen Sie Zuverl√§ssigkeit, was bedeutet, dass Sie etwas anderes √ºber UDP wickeln m√ºssen. <br><br>  Wie bei HTTP / 2 begannen die Arbeiten zur Erstellung eines neuen Protokolls 2012 bei Google, dh ungef√§hr zur gleichen Zeit wie der Beginn der Arbeiten an SPDY.  2013 stellte Jim Roskind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der</a> √ñffentlichkeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das QUIC-Protokoll (Quick UDP Internet Connections) vor</a> , und bereits 2015 wurde Internet Draft eingef√ºhrt, um die IETF zu standardisieren.  Bereits zu diesem Zeitpunkt unterschied sich das von Roskind bei Google entwickelte Protokoll stark vom Standardprotokoll, sodass die Google-Version gQUIC hie√ü. <br><br><h4>  Was ist QUIC? </h4><br>  Erstens ist dies, wie bereits erw√§hnt, ein Wrapper √ºber UDP.  Die QUIC-Verbindung steigt √ºber UDP an, in dem analog zu HTTP / 2 mehrere Streams existieren k√∂nnen.  Diese Streams existieren nur an Endpunkten und werden unabh√§ngig voneinander bereitgestellt.  Wenn der Paketverlust in einem Stream aufgetreten ist, hat dies keine Auswirkungen auf die anderen. <br><img src="https://habrastorage.org/webt/91/ml/el/91mlel1x2cca1jpzdkmqgyhenog.png"><br>  <i>Illustration von Daniel Steinberg</i> <br><br>  Zweitens wird die Verschl√ºsselung jetzt nicht mehr auf einer separaten Ebene implementiert, sondern im Protokoll enthalten.  Auf diese Weise k√∂nnen Sie in einem einzigen Handshake eine Verbindung herstellen und √∂ffentliche Schl√ºssel austauschen. Au√üerdem k√∂nnen Sie den kniffligen 0-RTT-Handshake-Mechanismus verwenden und im Allgemeinen Verz√∂gerungen beim H√§ndesch√ºtteln vermeiden.  Zus√§tzlich k√∂nnen jetzt einzelne Datenpakete verschl√ºsselt werden.  Auf diese Weise k√∂nnen Sie nicht auf den Abschluss des Empfangs von Daten aus dem Stream warten, sondern die empfangenen Pakete unabh√§ngig voneinander entschl√ºsseln.  Diese Betriebsart war in TCP √ºberhaupt nicht m√∂glich, weil  TLS und TCP arbeiteten unabh√§ngig voneinander, und TLS konnte nicht wissen, in welche Teile TCP-Daten zerhacken w√ºrden.  Daher konnte ich meine Segmente nicht so vorbereiten, dass sie eins zu eins in die TCP-Segmente passen und unabh√§ngig voneinander entschl√ºsselt werden k√∂nnen.  All diese Verbesserungen erm√∂glichen es QUIC, die Latenz im Vergleich zu TCP zu reduzieren. <br><img src="https://habrastorage.org/webt/cf/nn/m3/cfnnm3uoherao-9oczolm2h7vxk.png"><br>  Drittens k√∂nnen Sie mit dem Konzept der einfachen Streams die Verbindung von der IP-Adresse des Clients trennen.  Dies ist beispielsweise wichtig, wenn ein Client von einem Wi-Fi-Zugangspunkt zu einem anderen wechselt und seine IP-Adresse √§ndert.  In diesem Fall tritt bei Verwendung von TCP ein langwieriger Prozess auf, bei dem vorhandene TCP-Verbindungen im Zeitlimit abfallen und neue Verbindungen aus der neuen IP erstellt werden.  Im Fall von QUIC sendet der Client einfach weiterhin Pakete von der neuen IP mit der alten Stream-ID an den Server.  Weil  Die Stream-ID ist jetzt eindeutig und wird nicht wiederverwendet. Der Server versteht, dass der Client die IP ge√§ndert hat, sendet die verlorenen Pakete und setzt die Kommunikation an die neue Adresse fort. <br><br>  Viertens wird QUIC auf Anwendungsebene implementiert, nicht auf dem Betriebssystem.  Dies erm√∂glicht zum einen schnellere √Ñnderungen des Protokolls als  Um ein Update zu erhalten, aktualisieren Sie einfach die Bibliothek, anstatt auf eine neue Version des Betriebssystems zu warten.  Dies f√ºhrt andererseits zu einem starken Anstieg des Prozessorverbrauchs. <br><br>  Und schlie√ülich die Schlagzeilen.  Die Header-Komprimierung bezieht sich nur auf Punkte, die sich in QUIC und gQUIC unterscheiden.  Ich sehe keinen Grund, viel Zeit daf√ºr aufzuwenden. Ich kann nur sagen, dass in der zur Standardisierung eingereichten Version die Header-Komprimierung der Header-Komprimierung in HTTP / 2 so √§hnlich wie m√∂glich gemacht wurde.  Weitere Details finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h4>  Wie viel schneller ist es? </h4><br>  Dies ist eine schwierige Frage.  Tatsache ist, dass wir zwar keinen Standard haben, aber nichts Besonderes zu messen ist.  M√∂glicherweise sind die einzigen Statistiken, die wir haben, die Statistiken von Google, die seit 2013 gQUIC verwenden und 2016 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der IETF gemeldet haben,</a> dass etwa 90% des Datenverkehrs, der vom Chrome-Browser zu ihren Servern geleitet wird, jetzt QUIC verwendet.  In derselben Pr√§sentation berichten sie, dass Seiten durch gQUIC etwa 5% schneller geladen werden und Streaming-Videos 30% weniger Einfrierungen aufweisen als TCP. <br><br>  Im Jahr 2017 ver√∂ffentlichte eine Gruppe von Forschern unter der Leitung von Arash Molavi Kakhki eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umfangreiche Arbeit</a> zur Untersuchung der gQUIC-Leistung im Vergleich zu TCP. <br>  Die Studie ergab mehrere gQUIC-Schwachstellen, wie z. B. Instabilit√§t beim Mischen von Netzwerkpaketen, ungerechte Kanalkapazit√§t und langsamere √úbertragung kleiner (bis zu 10 kb) Objekte.  Letzteres kann jedoch mit der 0-RTT kompensiert werden.  In allen anderen untersuchten F√§llen zeigte gQUIC eine Geschwindigkeitssteigerung im Vergleich zu TCP.  Es ist schwer, √ºber bestimmte Zahlen zu sprechen.  Es ist besser, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Studie selbst</a> oder einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kurzen Beitrag</a> zu lesen. <br><br>  Hier muss gesagt werden, dass es sich bei diesen Daten speziell um gQUIC handelt und sie f√ºr den zu entwickelnden Standard irrelevant sind.  Was f√ºr QUIC passieren wird: Bisher steckt das Geheimnis hinter sieben Siegeln, aber es besteht die Hoffnung, dass die von gQUIC identifizierten Schw√§chen ber√ºcksichtigt und korrigiert werden. <br><br><h2>  Eine kleine Zukunft: Was ist mit HTTP / 3? </h2><br>  Und hier ist alles glasklar: Die API wird sich in keiner Weise √§ndern.  Alles bleibt genau so wie in HTTP / 2.  Wenn die API unver√§ndert bleibt, muss der √úbergang zu HTTP / 3 mithilfe der neuesten Version der Bibliothek entschieden werden, die den Transport √ºber QUIC im Backend unterst√ºtzt.  Es stimmt, Sie m√ºssen noch lange auf √§ltere Versionen von HTTP zur√ºckgreifen, weil  Das Internet ist jetzt nicht bereit f√ºr einen vollst√§ndigen Wechsel zu UDP. <br><br><h4>  Wer unterst√ºtzt schon </h4><br>  Hier ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste der</a> vorhandenen QUIC-Implementierungen.  Trotz des Fehlens eines Standards ist die Liste nicht schlecht. <br><br>  Derzeit unterst√ºtzt kein Browser QUIC in der Version.  K√ºrzlich gab es Informationen, dass Chrome HTTP / 3-Unterst√ºtzung enthielt, bisher jedoch nur auf Kanarienvogel. <br><br>  Von den Backends unterst√ºtzt HTTP / 3 nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Caddy</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://blog.cloudflare.com/">Cloudflare</a> , bisher jedoch experimentell.  NGINX <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gab</a> im sp√§ten Fr√ºhjahr 2019 bekannt, dass sie mit der Arbeit an der HTTP / 3-Unterst√ºtzung begonnen, diese jedoch noch nicht abgeschlossen haben. <br><br><h4>  Was sind die Probleme </h4><br>  Wir leben in der realen Welt, in der keine einzige gro√üe Technologie in die Massen gelangen kann, ohne auf Widerstand zu sto√üen, und QUIC ist keine Ausnahme. <br><br>  Am wichtigsten ist, dass Sie dem Browser irgendwie erkl√§ren m√ºssen, dass ‚Äûhttps: //‚Äú keine Tatsache mehr ist, die zum 443. TCP-Port f√ºhrt.  M√∂glicherweise ist √ºberhaupt kein TCP vorhanden.  Verwenden Sie dazu den Alt-Svc-Header.  Dadurch kann der Browser dar√ºber informiert werden, dass diese Website auch unter diesem und jenem Protokoll unter dieser oder jener Adresse verf√ºgbar ist.  Theoretisch sollte dies wie eine Uhr funktionieren, in der Praxis sto√üen wir jedoch auf die Tatsache, dass UDP beispielsweise in der Firewall deaktiviert werden kann, um DDoS-Angriffe zu vermeiden. <br><br>  Aber selbst wenn UDP nicht verboten ist, befindet sich der Client m√∂glicherweise hinter einem NAT-Router, der so konfiguriert ist, dass er eine TCP-Sitzung nach IP-Adresse als h√§lt  Wir verwenden UDP, in dem keine Hardwaresitzung vorhanden ist, NAT die Verbindung nicht h√§lt und die QUIC-Sitzung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">immer beendet wird</a> . <br><br>  All diese Probleme h√§ngen mit der Tatsache zusammen, dass UDP zuvor nicht zur √úbertragung von Internetinhalten verwendet wurde und die Hardwarehersteller nicht vorhersehen konnten, dass dies jemals passieren w√ºrde.  Auf die gleiche Weise verstehen Administratoren noch nicht, wie sie ihre Netzwerke f√ºr QUIC richtig konfigurieren k√∂nnen.  Diese Situation wird sich langsam √§ndern, und in jedem Fall werden solche √Ñnderungen weniger Zeit in Anspruch nehmen als die Einf√ºhrung eines neuen Transportschichtprotokolls. <br><br>  Dar√ºber hinaus erh√∂ht QUIC, wie bereits beschrieben, die Prozessorauslastung erheblich.  Daniel Stenberg <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bewertete das</a> Wachstum des Prozessors bis zu dreimal. <br><br><h4>  Wenn HTTP / 3 kommt </h4><br>  Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wollen den</a> Standard bis Mai 2020 √ºbernehmen, aber da die f√ºr Juli 2019 geplanten Dokumente noch nicht fertig sind, k√∂nnen wir sagen, dass der Termin h√∂chstwahrscheinlich verschoben wird. <br><br>  Nun, Google verwendet seit 2013 die Implementierung von gQUIC.  Wenn Sie sich die HTTP-Anfrage ansehen, die an die Google-Suchmaschine gesendet wird, sehen Sie Folgendes: <br><img src="https://habrastorage.org/webt/51/ck/e2/51cke2t4uepw6hbasyq9oqhvjtc.png"><br><br><h2>  Schlussfolgerungen </h2><br>  QUIC sieht jetzt wie eine ziemlich grobe, aber sehr vielversprechende Technologie aus.  In Anbetracht dessen, dass in den letzten 20 Jahren alle Optimierungen der Transportschichtprotokolle, die sich haupts√§chlich auf TCP, QUIC beziehen und in den meisten F√§llen an Leistung gewinnen, jetzt √§u√üerst gut aussehen. <br><br>  Es gibt jedoch noch ungel√∂ste Probleme, die in den n√§chsten Jahren gel√∂st werden m√ºssen.  Der Prozess kann sich aufgrund der Tatsache verz√∂gern, dass Hardware beteiligt ist, die niemand gerne aktualisiert, aber dennoch sehen alle Probleme ziemlich l√∂sbar aus, und fr√ºher oder sp√§ter werden wir alle HTTP / 3 haben. <br><br>  Die Zukunft ist nicht mehr fern! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473930/">https://habr.com/ru/post/de473930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473916/index.html">Geschichten aus dem Rechenzentrum: Halloween-Horrorgeschichten √ºber Diesel, Diplomatie und selbstschneidende Schrauben in der Heizung</a></li>
<li><a href="../de473918/index.html">Internetreisen in Russland: Geschwindigkeit und Chance</a></li>
<li><a href="../de473922/index.html">Selectel Networking Academy Konferenz</a></li>
<li><a href="../de473924/index.html">Nicht nur SMS und Token: Multi-Faktor-Authentifizierung basierend auf SafeNet Authentication Service</a></li>
<li><a href="../de473928/index.html">Aussterben von Computerdateien</a></li>
<li><a href="../de473932/index.html">Wie funktioniert eine Hybrid-Gaming-KI und welche Vorteile hat sie?</a></li>
<li><a href="../de473936/index.html">Interaktive Audio-Performance - Eine neue √Ñra der Voice Assistant-Spiele</a></li>
<li><a href="../de473938/index.html">Speichern Sie Anwendungseinstellungen universell √ºber IConfiguration</a></li>
<li><a href="../de473940/index.html">Festigkeitspr√ºfung: Nanomechanik der edlen Ohrmuschel der Perlmuttschale</a></li>
<li><a href="../de473944/index.html">Ratschl√§ge des Entwicklers von RimWorld: kognitive Verzerrungen bei der Vorhersage eines Fans des Spiels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>