<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛑️ 👩🏽‍🚒 🚼 XML wird fast immer falsch angewendet 🌵 ㊗️ 🚕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die XML-Sprache wurde 1996 erfunden. Er war kaum erschienen, bevor die Möglichkeiten seiner Anwendung bereits missverstanden worden waren, und für die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>XML wird fast immer falsch angewendet</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/475474/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/m7/os/0h/m7os0het6sqwqvxira3t8qaqzjq.jpeg"></div><br>  Die XML-Sprache wurde 1996 erfunden.  Er war kaum erschienen, bevor die Möglichkeiten seiner Anwendung bereits missverstanden worden waren, und für die Zwecke, für die sie versuchten, ihn anzupassen, war er nicht die beste Wahl. <br><br>  Es wäre nicht übertrieben zu sagen, dass die überwiegende Mehrheit der XML-Schemata, die ich gesehen habe, unangemessen oder missbräuchlich für XML ist.  Darüber hinaus zeugt diese Verwendung von XML von einem fundamentalen Missverständnis dessen, worum es in erster Linie bei XML geht. <br><br>  XML ist eine Auszeichnungssprache.  <b>Dies ist kein Datenformat</b> .  In den meisten XML-Schemata wurde diese Unterscheidung nicht explizit berücksichtigt, wodurch XML mit dem Datenformat verwechselt wurde, was letztendlich einen Fehler bei der Auswahl von XML bedeutete, da tatsächlich das Datenformat benötigt wurde. <br><a name="habracut"></a><br>  XML eignet sich am besten zum Kommentieren von Textblöcken mit Struktur und Metadaten, ohne auf Details einzugehen.  Wenn Ihre Hauptaufgabe nicht darin besteht, mit einem Textblock zu arbeiten, ist die Auswahl von XML wahrscheinlich nicht gerechtfertigt. <br><br>  Unter diesem Gesichtspunkt kann auf einfache Weise überprüft werden, wie gut das XML-Schema erstellt wurde.  Nehmen Sie zum Beispiel das Dokument im vorgeschlagenen Schema und entfernen Sie alle Tags und Attribute daraus.  Wenn es keinen Sinn mehr gibt, was übrig bleibt (oder wenn eine leere Zeichenfolge übrig bleibt), ist Ihr Schema entweder nicht richtig erstellt, oder Sie hätten XML einfach nicht verwenden sollen. <br><br>  Im Folgenden werde ich einige der häufigsten Beispiele für falsch aufgebaute Schaltungen geben. <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">item</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"John"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">item</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"city"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"London"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rot</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Hier sehen wir ein Beispiel für einen unvernünftigen und merkwürdigen (wenn auch weit verbreiteten) Versuch, ein einfaches Schlüsselwert-Wörterbuch in XML auszudrücken.  Wenn Sie alle Tags und Attribute löschen, bleibt eine leere Zeile übrig.  Im Grunde ist dieses Dokument, egal wie absurd es auch klingen mag, die semantische Annotation einer leeren Zeile. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">root</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"John"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">city</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"London"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Erschwerend kommt hinzu, dass es sich hier nicht nur um eine semantische Annotation eines leeren Strings als extravagante Ausdrucksform eines Wörterbuchs handelt - diesmal wird das „Wörterbuch“ direkt als Attribute des Root-Elements codiert.  Aus diesem Grund wird eine bestimmte Menge von Attributnamen für ein Element undefiniert und dynamisch.  Darüber hinaus wird hier deutlich, dass der Autor nur eine einfache Schlüsselwertsyntax zum Ausdruck bringen wollte. Stattdessen traf er eine absolut seltsame Entscheidung, XML zu verwenden, und erzwang die Verwendung eines einzelnen leeren Elements lediglich als Präfix Attributsyntax.  Und solche Pläne kommen mir sehr oft vor. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">item</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag">&gt;</span></span>John<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">item</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">item</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"city"</span></span></span><span class="hljs-tag">&gt;</span></span>London<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">item</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rot</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Dies ist bereits etwas besseres, aber jetzt sind die Schlüssel aus irgendeinem Grund Metadaten, die Werte jedoch nicht.  Ein sehr seltsamer Blick auf Wörterbücher.  Wenn Sie alle Tags und Attribute löschen, geht die Hälfte der Informationen verloren. <br><br>  Der korrekte Wörterbuchausdruck in XML sieht ungefähr so ​​aus: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">item</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>Name<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>John<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">item</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">item</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>City<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>London<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">item</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">rot</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Wenn die Leute jedoch die seltsame Entscheidung getroffen haben, XML als Datenformat zu verwenden und dann das Wörterbuch zu organisieren, sollten sie verstehen, dass das, was sie tun, unangemessen und unpraktisch ist.  Noch immer entscheiden sich Designer fälschlicherweise für XML, um ihre Anwendungen zu erstellen.  Aber noch häufiger verschärfen sie die Situation durch den sinnlosen Einsatz von XML in einer der oben beschriebenen Formen und ignorieren die Tatsache, dass XML dafür einfach nicht geeignet ist. <br><br>  <b>Schlechtestes XML-Schema?</b>  Übrigens: Der Preis für <i>das schlechteste XML-Schema, das ich je gesehen habe,</i> erhält das Format der Konfigurationsdatei für die automatische Ressourcenzuweisung für IP-Telefone von Polycom.  Für solche Dateien müssen XML-Anforderungsdateien über TFTP geladen werden. Dies ist im Allgemeinen ein Auszug aus einer solchen Datei: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">softkey</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">softkey.feature.directories</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">softkey.feature.buddies</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">softkey.feature.forward</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">softkey.feature.meetnow</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">softkey.feature.redial</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">softkey.feature.search</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">softkey.1.enable</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">softkey.1.use.idle</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">softkey.1.label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Foo"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">softkey.1.insert</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">softkey.1.action</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"..."</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">softkey.2.enable</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">softkey.2.use.idle</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">softkey.2.label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Bar"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">softkey.2.insert</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">softkey.2.action</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"..."</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Das ist kein schlechter Witz.  Und das ist nicht meine Erfindung: <br><br><ul><li>  Elemente werden einfach als Präfix zum Anhängen von Attributen verwendet, die selbst hierarchische Namen haben. <br></li><li>  Wenn Sie mehreren Instanzen eines Datensatzes eines bestimmten Typs Werte zuweisen möchten, müssen Sie die Namen der Attribute verwenden, <i>in denen sich Indizes befinden</i> . <br></li><li>  Zusätzlich Attribute beginnend mit <code>softkey.</code>  müssen Sie auf den <code>&lt;softkey/&gt;</code> -Elementen Attribute platzieren, die mit <code>feature.</code>  , sollte auf die <code>&lt;feature/&gt;</code> -Elemente usw. platziert werden, obwohl es vollständig redundant und auf den ersten Blick sinnlos aussieht. <br></li><li>  Und schließlich, wenn Sie gehofft haben, dass die erste Komponente des Attributnamens immer mit dem Elementnamen übereinstimmt - nichts dergleichen!  Zum Beispiel die Attribute <code>up.</code>  muss an <code>&lt;userpreferences/&gt;</code> angehängt werden.  Die Reihenfolge, in der Attributnamen an Elemente angehängt werden, ist willkürlich und fast vollständig. <br></li></ul><br>  <b>Dokumente oder Daten</b> .  Von Zeit zu Zeit unternimmt jemand absolut seltsame Dinge, um XML und JSON zu vergleichen - und dabei zu zeigen, dass er weder den einen noch den anderen versteht.  XML ist eine Dokumentauszeichnungssprache.  JSON ist ein strukturiertes Datenformat. Wenn Sie es also miteinander vergleichen, wird versucht, warm mit weich zu vergleichen. <br><br>  Um dies zu verstehen, hilft das Konzept des Unterschieds zwischen <i>Dokumenten und Daten</i> .  Als Analogon zu XML können Sie ein maschinenlesbares Dokument beliebig verwenden.  Obwohl es von einer Maschine gelesen werden soll, bezieht es sich metaphorisch auf Dokumente und ist aus dieser Sicht tatsächlich mit PDF-Dokumenten vergleichbar, die meist nicht maschinenlesbar sind. <br><br>  In XML ist beispielsweise die Reihenfolge der Elemente von Bedeutung.  In JSON ist die Reihenfolge der Schlüssel-Wert-Paare in den Objekten nicht sinnvoll und nicht definiert.  Wenn Sie ein ungeordnetes Wörterbuch aus Schlüssel-Wert-Paaren erhalten möchten, spielt die tatsächliche Reihenfolge der Elemente in dieser Datei keine Rolle.  Sie können jedoch aus diesen Daten viele verschiedene <i>Dokumente</i> erstellen, da das Dokument eine bestimmte Reihenfolge hat.  Metaphorisch ist dies eine Entsprechung eines Dokuments auf Papier, obwohl es im Gegensatz zu einem Ausdruck oder einer PDF-Datei keine physischen Abmessungen hat. <br><br>  In meinem Beispiel für die korrekte Darstellung des Wörterbuchs in XML wird im Gegensatz zur Darstellung in der JSON-Sprache die Reihenfolge der Elemente im Wörterbuch angezeigt.  Ich kann diese Reihenfolge nicht ignorieren: Eine solche Linearität ist dem Dokumentmodell und dem XML-Format eigen.  Bei der Interpretation dieses XML-Dokuments kann sich jemand dazu entschließen, die Reihenfolge zu ignorieren, aber es ist sinnlos, darüber zu streiten, da dieses Problem über die Erörterung des Formats selbst hinausgeht.  Wenn Sie ein Dokument in einem Browser anzeigen, indem Sie ihm ein Cascading Style Sheet anhängen, können Sie außerdem sehen, dass die Dictionary-Elemente in einer bestimmten Reihenfolge und auf keine andere Weise folgen. <br><br>  Mit anderen Worten, ein Wörterbuch (ein Fragment strukturierter Daten) kann in <i>n</i> verschiedene mögliche Dokumente (in XML, PDF, auf Papier usw.) konvertiert werden, wobei <i>n</i> die Anzahl der möglichen Kombinationen von Elementen im Wörterbuch ist und die anderen noch nicht berücksichtigt wurden mögliche Variablen. <br><br>  Daraus folgt jedoch auch, dass die Verwendung eines maschinenlesbaren Dokuments, wenn Sie Daten allein übertragen möchten, nicht effektiv ist.  Es wird ein Modell verwendet, das in diesem Fall überflüssig ist, es wird nur stören.  Außerdem muss ein Programm geschrieben werden, um die Quelldaten zu extrahieren.  Es ist kaum sinnvoll, XML für etwas zu verwenden, das zu einem bestimmten Zeitpunkt nicht als Dokument formatiert wird (z. B. mit CSS oder XSLT oder beidem), da dies der Hauptgrund (wenn nicht der einzige) dafür ist am Dokumentenmodell festhalten. <br><br>  Da XML nicht über das Konzept von Zahlen (oder Booleschen Ausdrücken oder anderen Datentypen) verfügt, werden alle in diesem Format dargestellten Zahlen nur als zusätzlicher Text betrachtet.  Um die Daten zu extrahieren, müssen das Schema und seine Beziehung zu den entsprechenden ausgedrückten Daten bekannt sein.  Es ist auch notwendig zu wissen, wann, basierend auf dem Kontext, das eine oder andere Element des Textes eine Zahl ist, und es sollte in eine Zahl usw. umgewandelt werden. <br><br>  Daher unterscheidet sich der Vorgang des Extrahierens von Daten aus XML-Dokumenten nicht so sehr vom Vorgang des Erkennens gescannter Dokumente, die beispielsweise Tabellen enthalten, die viele Seiten numerischer Daten bilden.  Ja, im Prinzip ist dies möglich, aber dies ist nicht der optimalste Weg, es sei denn, es gibt im Extremfall überhaupt keine anderen Optionen.  Eine kluge Entscheidung wäre, einfach eine digitale Kopie der Originaldaten zu finden, die nicht in das Dokumentenmodell eingebettet ist, in der die Daten mit ihrer spezifischen Textdarstellung kombiniert werden. <br><br>  Es überrascht mich jedoch überhaupt nicht, dass XML in der Wirtschaft beliebt ist.  Der Grund dafür liegt gerade darin, dass das Format von Dokumenten (auf Papier) für Unternehmen verständlich und vertraut ist und sie das bekannte und verständliche Modell dort weiterhin verwenden möchten.  Aus dem gleichen Grund werden in Unternehmen zu oft Dokumente im PDF-Format verwendet, anstatt sie für maschinelle Verarbeitungsformate bequemer zu machen - da sie immer noch an das Konzept einer gedruckten Seite mit einer bestimmten physischen Größe gebunden sind.  Dies gilt auch für Dokumente, deren Ausdruck unwahrscheinlich ist (z. B. eine PDF-Datei mit einer Registrierungsdokumentation von 8.000 Seiten).  Aus dieser Sicht ist die Verwendung von XML im Geschäftsleben im Wesentlichen eine Manifestation des Skeuomorphismus.  Die Menschen verstehen die metaphorische Idee einer gedruckten Seite mit einer begrenzten Größe und sie verstehen, wie Geschäftsprozesse auf der Grundlage gedruckter Dokumente erstellt werden.  Wenn dies Ihre Richtlinie ist, sind Dokumente ohne begrenzte physische Größe, die maschinenlesbar sind (XML-Dokumente), eine Innovation und gleichzeitig eine vertraute und komfortable Entsprechung eines Dokuments.  Das hindert sie nicht daran, eine falsche und übermäßig skeuomorphe Art der Datenpräsentation zu bleiben. <br><br>  Bisher sind die einzigen XML-Schemata, von denen ich weiß, dass sie wirklich die richtige Verwendung dieses Formats bezeichnen können, XHTML und DocBook. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475474/">https://habr.com/ru/post/de475474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475462/index.html">So lokalisieren Sie ein Handyspiel für den asiatischen Markt</a></li>
<li><a href="../de475464/index.html">Der Weg des Architekten: Zertifizierung und Eintauchen in Produkte</a></li>
<li><a href="../de475466/index.html">Intel Xeon E-2200. Serverkerne, Budget</a></li>
<li><a href="../de475468/index.html">Was ist los mit dem Microsoft-Experiment über eine 4-Tage-Woche oder verlieren Sie nicht den Kopf angesichts einer Effizienz von 40%?</a></li>
<li><a href="../de475472/index.html">Warum ist Eis rutschig: eine wissenschaftliche Antwort auf eine Kinderfrage</a></li>
<li><a href="../de475476/index.html">Datennetz: So arbeiten Sie mit Daten ohne Monolithen</a></li>
<li><a href="../de475478/index.html">Netflix Experience: Netflix Inside</a></li>
<li><a href="../de475480/index.html">Was bist du Wie wir Parodie von Mensch unterschieden - und sogar gewonnen haben</a></li>
<li><a href="../de475482/index.html">Wie wurde aus der Testaufgabe eine Produktionsbibliothek?</a></li>
<li><a href="../de475486/index.html">AR-Macher: die Entstehung eines neuen Berufes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>