<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔢 🉑 🧦 JavaScript箭头功能：为什么需要它们，如何处理它们，何时使用它们以及何时不使用它们 🚫 🤚🏼 👩🏼‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="现代JavaScript最著名的创新之一就是箭头功能的出现，有时也称为“胖”箭头功能。 声明此类功能时，它们使用特殊的字符组合- => 。 

 箭头功能比传统功能有两个主要优点。 第一个是非常方便且紧凑的语法。 第二个问题是，与普通功能相比，使用箭头功能处理this方法看起来更加直观。 

  
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript箭头功能：为什么需要它们，如何处理它们，何时使用它们以及何时不使用它们</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/428566/">现代JavaScript最著名的创新之一就是箭头功能的出现，有时也称为“胖”箭头功能。 声明此类功能时，它们使用特殊的字符组合- <code>=&gt;</code> 。 <br><br> 箭头功能比传统功能有两个主要优点。 第一个是非常方便且紧凑的语法。 第二个问题是，与普通功能相比，使用箭头功能处理<code>this</code>方法看起来更加直观。 <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/b1a/09a/721/b1a09a721fe985d3700f4f74305e68d6.jpg" alt="图片"></a> </div><br> 有时，这些优点和其他优点导致以下事实：与其他声明函数的方式相比，无条件地赋予了箭头语法。 例如，Airbnb流行的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">eslint配置</a>强制每当创建匿名函数时，此类函数就会像箭头一样。 <br><br> 但是，与编程中使用的其他概念和机制一样，箭头功能也各有利弊。 它们的使用会导致负面的副作用。 为了正确使用箭头功能，您需要了解与它们相关的可能问题。 <br><br> 我们今天发布的翻译材料将集中于箭头功能的工作方式。 在这里，我们将考虑使用它们可以改善代码的情况以及不应该使用它们的情况。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">在JavaScript中具有箭头功能</font> </h2><br>  JavaScript中的箭头函数类似于Python中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">lambda函数</a>和Ruby中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">块</a> 。 <br><br> 这些是具有特殊语法的匿名函数，它们带有固定数量的参数，并在包含它们的作用域的上下文中起作用，即在声明它们的函数或其他代码的上下文中起作用。 <br><br> 让我们详细讨论一下。 <br><br><h3>  <font color="#3AC1EF">▍语法箭头功能</font> </h3><br> 箭头功能是根据单个方案构建的，而在特殊情况下，可以简化功能的结构。 箭头函数的基本结构如下所示： <br><br><pre> <code class="hljs php">(argument1, argument2, ... argumentN) =&gt; { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br> 函数参数的列表在括号中，后跟由<code>=</code>和<code>&gt;</code>字符组成的箭头，然后以大括号形式出现在函数的主体中。 <br><br> 这与普通函数的工作原理非常相似，主要区别在于此处省略了<code>function</code>关键字，并在参数列表后添加了一个箭头。 <br><br> 但是，在某些情况下，可以使用更紧凑的结构声明简单的箭头函数。 <br><br> 如果函数的主体由单个表达式表示，请考虑使用的语法。 它使您无需使用大括号括住函数的主体，并且无需显式返回对表达式求值的结果，因为此结果将自动返回。 例如，它可能看起来像这样： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b;</code> </pre> <br> 这是该函数的缩写符号的另一种变体，当该函数仅具有一个参数时使用。 <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFirst = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> <br> 如您所见，此处省略了参数列表的括号。 此外，在此示例中由单个命令表示的函数主体也编写为不带方括号的形式。 稍后我们将更多地讨论这种设计的好处。 <br><br><h3>  <font color="#3AC1EF">objects返回对象和短记录箭头功能</font> </h3><br> 使用箭头函数时，还会使用一些更复杂的语法构造，这对于您很有用。 <br><br> 例如，尝试使用单行表达式从对象文字函数返回。 鉴于我们对箭头函数的了解，似乎函数声明看起来像这样： <br><br><pre> <code class="hljs pgsql">(<span class="hljs-type"><span class="hljs-type">name</span></span>, description) =&gt; {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>, description: description};</code> </pre> <br> 这段代码的问题在于其含糊不清。 即，我们想要用来描述对象文字的花括号看起来像是我们试图将函数主体包含在其中。 <br><br> 为了向系统表明我们的意思是对象文字，我们需要将其括在括号中： <br><br><pre> <code class="hljs pgsql">(<span class="hljs-type"><span class="hljs-type">name</span></span>, description) =&gt; ({<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>, description: description});</code> </pre> <br><h3>  <font color="#3AC1EF">▍箭头函数及其执行上下文</font> </h3><br> 与其他函数不同，箭头函数没有自己的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">执行上下文</a> 。 <br><br> 实际上，这意味着它们从父函数继承了<code>this</code>和<code>arguments</code>实体。 <br><br> 例如，比较以下代码中提供的两个功能。 其中之一是普通的，第二是箭头。 <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'test object'</span></span>, <span class="hljs-attr"><span class="hljs-attr">createAnonFunction</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name);     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>);   }; }, <span class="hljs-attr"><span class="hljs-attr">createArrowFunction</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name);     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>);   }; } };</code> </pre> <br> 有两种方法的<code>test</code>对象。 它们每个都是创建并返回匿名函数的函数。 这些方法之间的区别仅在于，在第一种方法中，使用了传统的函数表达式，而在第二种方法中，即使用了箭头函数。 <br><br> 如果我们在控制台中尝试此代码，并将相同的参数传递给对象的方法，则尽管方法看起来非常相似，但我们将获得不同的结果： <br><br><pre> <code class="hljs cs">&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anon = test.createAnonFunction(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'world'</span></span>); &gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrow = test.createArrowFunction(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'world'</span></span>); &gt; anon(); undefined {} &gt; arrow(); test <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-string"><span class="hljs-string">'0'</span></span>: <span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>: <span class="hljs-string"><span class="hljs-string">'world'</span></span> }</code> </pre> <br> 匿名函数具有其自己的上下文，因此在调用匿名函数时，当您调用<code>test.name</code> ，将不<code>test.name</code>对象的<code>name</code>属性值，并且在调用<code>arguments</code> ，将不显示用于创建和返回所调查函数的函数的参数列表。 <br><br> 对于箭头函数，事实证明其上下文与创建它的函数的上下文一致，这使它可以访问此函数传递的参数列表以及该函数作为方法的对象的<code>name</code>属性。 <br><br><h2>  <font color="#3AC1EF">箭头功能可改善代码的情况</font> </h2><br><h3>  <font color="#3AC1EF">▍处理值列表</font> </h3><br> 传统的lambda函数以及箭头函数在JavaScript中出现后，通常用于将特定函数应用于特定列表的每个元素的情况。 <br><br> 例如，如果存在需要使用<code>map</code> arrays方法转换的值数组，则箭头函数非常适合描述这种转换： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> words = [<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'WORLD'</span></span>, <span class="hljs-string"><span class="hljs-string">'Whatever'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> downcasedWords = words.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">word</span></span></span><span class="hljs-function"> =&gt;</span></span> word.toLowerCase());</code> </pre> <br> 这是箭头功能类似用法的一个极其常见的示例，其中包括使用对象的属性： <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> names = objects.map(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>);</code> </pre> <br> 类似地，如果不是使用传统的<code>for</code>循环，而是使用基于迭代器的现代<code>forEach</code>循环，那么该箭头函数将使用父实体的循环，从而使使用直观： <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.examples.forEach(example =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.runExample(example); });</code> </pre> <br><h3>  <font color="#3AC1EF">▍承诺和承诺链</font> </h3><br> 箭头功能允许您编写更简洁，更易理解的代码的另一种情况是异步软件结构。 <br><br> 因此， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">promise</a>大大简化了异步代码的工作。 同时，即使您更喜欢使用async / await <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">构造，</a>您也不能不<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">理解promise</a> ，因为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">promise</a>是基于它们的。 <br><br> 但是，在使用Promise时，您需要声明在异步代码完成或对特定API的异步调用完成之后调用的函数。 <br><br> 这是使用箭头函数的理想位置，尤其是在结果函数具有特定状态的情况下，它指向对象中的某物。 例如，它可能看起来像这样： <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomethingAsync().<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storeResult(result); });</code> </pre> <br><h3>  <font color="#3AC1EF">▍对象转换</font> </h3><br> 箭头函数的另一个常见用例是封装对象转换。 <br><br> 例如，在Vue.js中，存在一种通用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模式，可</a>使用<code>mapState</code> Vuex存储片段直接包括在Vue组件中。 <br><br> 该操作包括一组“转换器”的声明，这些转换器从初始完全状态中准确选择特定组件所需的内容。 <br><br> 这些简单的转换是使用箭头功能的理想场所。 例如： <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">export</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">computed</span></span>: {   ...<span class="hljs-built_in"><span class="hljs-built_in">mapState</span></span>({     results: state =&gt; state.results,     users: state =&gt; state.users,   }); } }</code> </pre> <br><h2>  <font color="#3AC1EF">不应使用箭头功能的情况</font> </h2><br><h3>  <font color="#3AC1EF">▍对象方法</font> </h3><br> 在许多情况下，使用箭头功能不是一个好主意。 箭头功能如果使用得很少，不仅不会帮助程序员，还会成为问题的根源。 <br><br> 第一种情况是将箭头函数用作对象方法。 执行上下文和<code>this</code> （特定于传统功能）在这里很重要。 <br><br> 一次，使用类属性和箭头函数的组合来创建具有“自动绑定”的方法是很流行的，也就是说，那些可以被事件处理程序使用但仍绑定到该类的方法。 它看起来像这样： <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span></span>{ counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter++; } }</code> </pre> <br> 使用类似的构造，即使事件处理程序调用了<code>handleClick</code>函数，而不是在<code>Counter</code>类的实例的上下文中，该函数也可以访问该实例的数据。 <br><br> 但是，这种方法在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此材料</a>上有很多缺点。 <br><br> 尽管这里使用箭头函数固然是绑定函数的便捷方法，但该函数在许多方面的行为都远非直观，会干扰测试并在例如试图将相应对象用作原型的情况下产生问题。 <br><br> 在这种情况下，请使用普通函数代替箭头函数，并在必要时将其绑定到构造函数中的对象实例： <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Counter <span class="hljs-comment"><span class="hljs-comment">{ counter = 0; handleClick() {   this.counter++; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{   this.handleClick = this.handleClick.bind(this); }</span></span></span><span class="hljs-function"> }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">call长通话链</font> </h3><br> 如果计划将箭头功能用于许多不同的组合中，尤其是在长函数调用链中使用，则箭头功能可能会成为问题的根源。 <br><br> 出现此类问题的主要原因（例如使用匿名函数时）是，它们给出了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调用堆栈</a>跟踪的极其无用的结果。 <br><br> 例如，如果仅存在一层嵌套的函数调用（例如，如果我们谈论的是迭代器中使用的函数），这并不太糟糕。 但是，如果所有使用的函数都声明为箭头函数，并且这些函数相互调用，那么如果发生错误，将很难弄清楚正在发生的情况。 错误消息将如下所示： <br><br><pre> <code class="hljs">{anonymous}() {anonymous}() {anonymous}() {anonymous}() {anonymous}()</code> </pre> <br><h3>  <font color="#3AC1EF">with具有动态上下文的功能</font> </h3><br> 我们讨论的最后一种情况（箭头功能可能会引起麻烦）是在需要动态<code>this</code>绑定的地方使用它们。 <br><br> 如果在这种情况下使用了箭头功能，则动态绑定将无法工作。 这种令人不愉快的惊奇可能使人们困惑那些不得不使用箭头功能使用不正确的代码的人会发生什么情况的原因。 <br><br> 考虑使用箭头功能时，请记住以下几点： <br><br><ul><li> 与<code>this</code>绑定到<code>currentTarget</code>事件属性的事件处理程序将被调用。 </li><li> 如果仍在使用jQuery，请考虑大多数jQuery方法<code>this</code>绑定到选定的DOM元素。 </li><li> 如果使用Vue.js，则方法和计算函数通常会将其绑定到Vue组件。 </li></ul><br> 当然，可以有意使用箭头功能，以更改软件机制的标准行为。 但是，尤其是在使用jQuery和Vue的情况下，这通常与系统的正常功能相冲突，这导致程序员无法理解为什么某些看上去完全正常的代码突然无法工作的事实。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 箭头功能是一个很棒的JavaScript新功能。 在许多情况下，它们允许编写比以前更方便的代码。 但是，与其他功能一样，它们既有优点也有缺点。 因此，您需要在可能有用的地方使用箭头功能，而不必将其视为普通功能的完全替代。 <br><br>  <b>亲爱的读者们！</b> 您是否遇到过使用箭头功能导致程序错误，不便或意外行为的情况？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN428566/">https://habr.com/ru/post/zh-CN428566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN428556/index.html">“生产环境超出您的控制范围”：Rian Lewis测试区块链项目</a></li>
<li><a href="../zh-CN428558/index.html">我是如何从懒惰中为WordPress创建向导的</a></li>
<li><a href="../zh-CN428560/index.html">计划外的周五公告</a></li>
<li><a href="../zh-CN428562/index.html">Droidcon伦敦。 怎么样了</a></li>
<li><a href="../zh-CN428564/index.html">MapKit搜索：提示和技巧</a></li>
<li><a href="../zh-CN428568/index.html">React Native Web应用程序开发指南</a></li>
<li><a href="../zh-CN428570/index.html">JavaScript中的高阶函数</a></li>
<li><a href="../zh-CN428572/index.html">React中的高阶组件</a></li>
<li><a href="../zh-CN428574/index.html">通过Zextras Chat将公司沟通提升到一个新的水平</a></li>
<li><a href="../zh-CN428576/index.html">[书签] Node.js教程的PDF版本和新的JavaScript指南</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>