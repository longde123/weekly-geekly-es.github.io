<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∂üèª üë®üèø‚Äçü§ù‚Äçüë®üèæ üßìüèª Pantalla de texto de Android üíÜüèª üë∫ üéÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mostrar informaci√≥n textual es probablemente la parte m√°s b√°sica e importante de muchas aplicaciones de Android. Este art√≠culo hablar√° sobre TextView....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pantalla de texto de Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/461787/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mc/2_/_o/mc2__o7rq1m6ex9alol6ivz5vey.png"></div><br><p>  Mostrar informaci√≥n textual es probablemente la parte m√°s b√°sica e importante de muchas aplicaciones de Android.  Este art√≠culo hablar√° sobre TextView.  Todos los desarrolladores, comenzando con "Hello World", se enfrentan constantemente con este elemento de interfaz de usuario.  De vez en cuando, al trabajar con texto, debe pensar en implementar varias soluciones de dise√±o o mejorar el rendimiento al renderizar la pantalla. </p><br><p>  Hablar√© sobre el dispositivo TextView y algunas sutilezas de trabajar con √©l.  Se tomaron consejos clave de informes de E / S de Google anteriores. </p><a name="habracut"></a><br><h1 id="textview-pod-kapotom">  TextView debajo del cap√≥ </h1><br><p>  Para renderizar texto en Android, se utiliza una pila completa de bibliotecas diferentes debajo del cap√≥.  Se pueden dividir en dos partes principales: c√≥digo java y c√≥digo nativo: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hb/p0/gg/hbp0ggycnpeisn8v8hwyqkkmvfq.png" width="800"></div><br><p>  El c√≥digo Java es esencialmente parte del SDK de Android disponible para los desarrolladores de aplicaciones, y las nuevas caracter√≠sticas de este se pueden portar a la biblioteca de soporte. </p><br><p>  El n√∫cleo de TextView en s√≠ est√° escrito en C ++, lo que limita la transferencia a la biblioteca de soporte de nuevas caracter√≠sticas implementadas all√≠ desde nuevas versiones del sistema operativo.  El n√∫cleo son las siguientes bibliotecas: </p><br><ul><li>  Minikin se usa para medir la longitud del texto, los saltos de l√≠nea y las palabras por s√≠labas. </li><li>  ICU proporciona soporte Unicode. </li><li>  HarfBuzz encuentra para los caracteres Unicode los elementos gr√°ficos correspondientes (glifos) en las fuentes. </li><li>  FreeType crea mapas de bits de glifos. </li><li>  Skia es un motor para dibujar gr√°ficos 2D. </li></ul><br><h2 id="izmerenie-dliny-teksta-i-perenos-strok">  Medici√≥n de longitud de texto y saltos de l√≠nea </h2><br><p>  Si pasa la l√≠nea a la biblioteca Minikin, que se usa dentro de TextView, lo primero que determina es en qu√© glifos est√° compuesta la l√≠nea: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qt/1o/uk/qt1ouktu4gn9x0wncbgiy2a7qkg.png" width="800"></div><br><p> Como puede ver en este ejemplo, la coincidencia de caracteres Unicode con glifos no siempre ser√° uno a uno: aqu√≠ 3 caracteres a la vez corresponder√°n a un glifo ffi.  Adem√°s, vale la pena prestar atenci√≥n a que los glifos necesarios se pueden encontrar en varias fuentes del sistema. </p><br><p>  Encontrar glifos solo en las fuentes del sistema puede generar dificultades, especialmente si los iconos o emojis se muestran a trav√©s de los caracteres, y se supone que combina caracteres de diferentes fuentes en una l√≠nea.  Por lo tanto, comenzando con <strong>Android Q (29)</strong> , fue posible crear su propia lista de fuentes que vienen con la aplicaci√≥n.  Esta lista se usar√° para buscar glifos: </p><br><pre> <code class="kotlin hljs">textView.typeface = TypeFace.CustomFallbackBuilder( FontFamily.Builder( Font.Builder(assets, ‚Äúlato.ttf‚Äù).build() ).build() ).addCustomFallback( FontFamily.Builder( Font.Builder(assets, ‚Äúkosugi.ttf‚Äù).build() ).build() ).build()</code> </pre> <br><p>  Ahora, con <code>CustomFallbackBuilder</code> al hacer coincidir caracteres con glifos, el SDK <code>CustomFallbackBuilder</code> sobre la familia de fuentes especificada en orden, y si no se puede encontrar, la b√∫squeda continuar√° en las fuentes del sistema (y a trav√©s del m√©todo <code>setSystemFallback()</code> puede especificar la familia de fuentes del sistema preferida).  <code>CustomFallbackBuilder</code> tiene un l√≠mite en el n√∫mero de familias de fuentes: no puede agregar m√°s de 64 fuentes. </p><br><p>  La biblioteca Minikin divide cadenas en palabras y mide palabras individuales.  Para acelerar el trabajo, comenzando con <strong>Lollipop (21)</strong> , se utiliza un sistema de cach√© de palabras <abbr title="menos utilizado recientemente">LRU</abbr> .  Tal cach√© proporciona una gran ganancia de rendimiento: una llamada a <code>Paint.measureText()</code> para una palabra en cach√© tomar√° un promedio del 3% del tiempo que calcula por primera vez su tama√±o. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d2/f1/om/d2f1omfjlqmmfqalip3whmes-1o.png" width="800"></div><br><p>  Si el texto no se ajusta al ancho especificado, Minikin organiza saltos de l√≠nea y palabras en el texto.  Comenzando con <strong>Marshmallow (23),</strong> puede controlar su comportamiento especificando los atributos especiales <code>breakStrategy</code> e HyphenationFrequency para TextView. </p><br><p>  Con el valor <code>breakStrategy=simple</code> biblioteca simplemente organizar√° guiones secuencialmente, pasando por el texto: tan pronto como la l√≠nea deje de encajar, la separaci√≥n se colocar√° antes de la √∫ltima palabra. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/im/lc/cr/imlccruuhjr59qzrtpwjmrf6hhk.png" width="600"></div><br><p>  En el valor <code>balanced</code> biblioteca intentar√° hacer saltos de l√≠nea para que las l√≠neas est√©n alineadas en ancho. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v5/ys/kc/v5yskcuiwypdyponmrdqep7zaq8.png" width="600"></div><br><p>  <code>high_quality</code> tiene casi el mismo comportamiento que el <code>balanced</code> , con la excepci√≥n de algunas diferencias (una de ellas: en la pen√∫ltima l√≠nea, la separaci√≥n sil√°bica puede ser no solo palabras separadas, sino tambi√©n palabras por s√≠labas). </p><br><p>  El atributo <code>hyphenationFrequency</code> permite controlar la estrategia para el ajuste de palabras por s√≠labas.  Un valor de <code>none</code> no har√° la separaci√≥n sil√°bica autom√°tica, <code>normal</code> har√° una peque√±a frecuencia de separaci√≥n sil√°bica y <code>full</code> , en consecuencia, utilizar√° el n√∫mero m√°ximo de palabras. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ng/cr/hs/ngcrhsphklaxxe842klpnx8mhnw.png" width="600"></div><br><p>  Rendimiento de representaci√≥n de texto seg√∫n los indicadores seleccionados (medidos en <strong>Android P (28)</strong> ): </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/5r/33/tx5r339s93s1nq6go8hieqhv6fq.png" width="600"></div><br><p>  Dado un √©xito bastante fuerte en el rendimiento, los desarrolladores de Google, comenzando con la versi√≥n <strong>Q (29)</strong> y <strong>AppCompat 1.1.0</strong> , decidieron desactivar la separaci√≥n sil√°bica por defecto.  Si el ajuste de palabras es importante en la aplicaci√≥n, ahora debe habilitarlo expl√≠citamente. </p><br><p>  Cuando se utiliza el ajuste de palabras, se debe tener en cuenta que el idioma seleccionado actualmente en el sistema operativo afectar√° el funcionamiento de la biblioteca.  Dependiendo del idioma, el sistema seleccionar√° diccionarios especiales con reglas de transferencia. </p><br><h1 id="stili-teksta">  Estilos de texto </h1><br><p>  Hay varias formas de dise√±ar texto en Android: </p><br><ul><li>  <strong>Un estilo √∫nico</strong> que se aplica a todo el elemento TextView. </li><li>  <strong>Estilo m√∫ltiple (estilo m√∫ltiple)</strong> : varios estilos a la vez, que se pueden aplicar al texto, a nivel de p√°rrafo o caracteres individuales.  Hay varias formas de hacer esto: <br><ul><li>  dibujar texto sobre lienzo </li><li>  etiquetas html </li><li>  elementos de marcado especiales - tramos </li></ul></li></ul><br><p>  Un estilo √∫nico implica el uso de estilos XML o atributos XML en el marcado TextView.  En este caso, el sistema aplicar√° los valores de los recursos en el siguiente orden: Apariencia de texto, tema (Tema), estilo predeterminado (Estilo predeterminado), estilo de la aplicaci√≥n y la prioridad m√°s alta son los valores de los atributos de Vista. </p><br><p>  El uso de recursos es una soluci√≥n bastante simple, pero, desafortunadamente, no le permite aplicar estilo a partes del texto. </p><br><p>  Las etiquetas HTML son otra soluci√≥n simple que proporciona caracter√≠sticas tales como poner palabras en negrita, cursiva o incluso resaltar listas con puntos en el texto.  Todo lo que el desarrollador necesita es hacer una llamada al m√©todo <code>Html.fromHtml()</code> , que convertir√° el texto etiquetado en texto marcado por tramos.  Pero esta soluci√≥n tiene capacidades limitadas, ya que reconoce solo una parte de las etiquetas html y no admite estilos CSS. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> text = <span class="hljs-string"><span class="hljs-string">"My text &lt;ul&gt;&lt;li&gt;bullet one&lt;/li&gt;&lt;li&gt;bullet two&lt;/li&gt;&lt;/ul&gt;"</span></span> myTextView.text = Html.fromHtml(text)</code> </pre> <br><p>  Se pueden combinar varios m√©todos de dise√±o de TextView, pero vale la pena recordar la prioridad de un m√©todo en particular, que afectar√° el resultado final: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/hr/hl/zmhrhluqvvcv77s1b85gkxbtcww.png" width="400"></div><br><p>  Otra forma, dibujar texto en el lienzo, le da al desarrollador control total sobre la salida de texto: por ejemplo, puede dibujar texto a lo largo de una l√≠nea curva.  Pero tal soluci√≥n, dependiendo de los requisitos, puede ser bastante dif√≠cil de implementar y est√° m√°s all√° del alcance de este art√≠culo. </p><br><h1 id="spans">  Se extiende </h1><br><p>  TextView utiliza tramos para ajustar estilos.  Usando tramos, puede cambiar el color de un rango de caracteres, hacer parte del texto como enlaces, cambiar el tama√±o del texto, dibujar un punto delante de un p√°rrafo, etc. </p><br><p>  Se pueden distinguir las siguientes categor√≠as de tramos: </p><br><ul><li>  <strong>Tramos de caracteres</strong> : aplicados al nivel de caracteres de una cadena. <br><ul><li>  <strong>Apariencia que afecta</strong> : no cambie el tama√±o del texto. </li><li>  <strong>Afectaci√≥n m√©trica</strong> : cambia el tama√±o del texto. </li></ul></li><li>  <strong>Tramo de p√°rrafo</strong> : aplicado a nivel de p√°rrafo. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zy/os/x2/zyosx2ovroe15y3bd94qridaaou.png"></div><br><p>  El marco de Android tiene interfaces y clases abstractas con m√©todos que se <code>onMeasure()</code> durante <code>onMeasure()</code> y la representaci√≥n de TextView, estos m√©todos brindan acceso a objetos de nivel inferior como <code>TextPaint</code> y <code>Canvas</code> .  Usando el span, el marco de Android verifica qu√© interfaces implementa este objeto para invocar los m√©todos necesarios. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fv/do/er/fvdoerpx8zxykjxvt9ru4kigica.png" width="600"></div><br><p>  El marco de Android define aproximadamente m√°s de 20 tramos, por lo que antes de hacer el suyo, es mejor verificar si el SDK es adecuado. </p><br><h3 id="appearance-vs-metric-affecting-spans">  Apariencia vs m√©trica que afecta a los tramos </h3><br><p>  La primera categor√≠a de tramos afecta el aspecto de los caracteres de la cadena: color de caracteres, color de fondo, caracteres subrayados o tachados, etc.  Estos tramos implementan la interfaz <code>UpdateAppearance</code> y heredan de la clase <code>CharacterStyle</code> , que proporciona acceso al objeto <code>TextPaint</code> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/or/8f/zl/or8fzltp5mvoyhvdey8tz1uoqhg.png"></div><br><p>  El intervalo que afecta la m√©trica afecta el tama√±o del texto y el dise√±o, por lo tanto, el uso de dicho intervalo requiere no solo volver a dibujar TextView, sino tambi√©n la llamada <code>onMeasure()</code> / <code>onLayout()</code> .  Estos tramos generalmente se heredan de la clase <code>MetricAffectingSpan</code> , que hereda del <code>CharacterStyle</code> mencionado anteriormente. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_h/hs/hd/_hhshd0pcadvdievngojmtsqzlu.png"></div><br><h2 id="character-vs-paragraph-affecting-spans">  Car√°cter vs p√°rrafo que afecta a los tramos </h2><br><p>  La extensi√≥n del p√°rrafo afecta a un bloque completo de texto: puede cambiar la alineaci√≥n, la sangr√≠a o incluso insertar un punto al comienzo de un p√°rrafo.  Dichos tramos deben heredarse de la clase <code>ParagraphStyle</code> e insertarse en el texto exactamente desde el principio del p√°rrafo hasta su final.  Si el rango es incorrecto, el intervalo no funcionar√°. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/76/_n/uj/76_nujhr8rrwz-mne8bgq8p2pfu.png"></div><br><p>  En Android, los p√°rrafos se consideran la parte del texto separada por nuevas l√≠neas ( <code>\n</code> ). </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s1/p1/kq/s1p1kq9esdaakdpwh_rkxdvdygw.png"></div><br><h2 id="napisanie-svoih-spanov">  Escribiendo tus tramos </h2><br><p>  Al escribir sus propios tramos, debe decidir qu√© afectar√° el lapso para elegir de qu√© clase heredar: </p><br><ul><li>  Afecta el texto a nivel de caracteres -&gt; <code>CharacterStyle</code> </li><li>  Afecta el texto a nivel de p√°rrafo -&gt; <code>ParagraphStyle</code> </li><li>  Afecta la vista de texto ‚Üí <code>UpdateAppearance</code> </li><li>  Afecta el tama√±o del texto - <code>UpdateLayout</code> </li></ul><br><p>  Aqu√≠ hay un ejemplo de un lapso para cambiar la fuente: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomTypefaceSpan</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> font: Typeface?) : MetricAffectingSpan() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateMeasureState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = update(textPaint) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateDrawState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = update(textPaint) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { textPaint.apply { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> old = typeface <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> oldStyle = old?.style ?: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> font = Typeface.create(font, oldStyle) typeface = font <span class="hljs-comment"><span class="hljs-comment">//    } } }</span></span></code> </pre> <br><p>  Imagine que queremos crear nuestro propio espacio para resaltar bloques de c√≥digo, para esto editaremos nuestro espacio anterior; despu√©s de agregar la fuente, tambi√©n agregaremos un cambio en el color de fondo del texto: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodeBlockSpan</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> font: Typeface?) : MetricAffectingSpan() { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { textPaint.apply { <span class="hljs-comment"><span class="hljs-comment">//    ‚Ä¶ bgColor = lightGray //    } } }</span></span></code> </pre> <br><p>  Aplicar span al texto: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//    span spannable.setSpan(CodeBlockSpan(typeface), ...)</span></span></code> </pre> <br><p>  Pero puede obtener exactamente el mismo resultado combinando dos tramos: tome nuestro <code>CustomTypefaceSpan</code> y <code>BackgroundColorSpan</code> anteriores del marco de Android: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//    spannable.setSpan(BackgroundColorSpan(lightGray), ...) //   spannable.setSpan(CustomTypefaceSpan(typeface), ...)</span></span></code> </pre> <br><p>  Estas dos soluciones tendr√°n una diferencia.  El hecho es que los tramos <code>Parcelable</code> no pueden implementar la interfaz <code>Parcelable</code> , a diferencia de los sistemas. </p><br><p>  Al transmitir una l√≠nea estilizada a trav√©s de Intent o el portapapeles en caso de un lapso de marcado autoescrito, no se guardar√°.  Al usar tramos desde el marco, el marcado permanecer√°. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/is/nw/uu/isnwuux9cosllp6h0kgawifcepo.png" width="600"></div><br><h2 id="ispolzovanie-spanov-v-tekste">  Usar tramos en el texto </h2><br><p>  Hay dos interfaces para texto estilizado en el marco: <code>Spanned</code> y <code>Spannable</code> (con marcado sin cambios y mutable, respectivamente) y tres implementaciones: <code>SpannedString</code> (texto sin cambios), <code>SpannableString</code> (texto sin cambios) y <code>SpannableStringBuilder</code> (texto mutable). </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Texto mutable </th><th>  Marcado variable </th></tr></thead><tbody><tr><td>  Cadena <strong>extendida</strong> </td><td>  no </td><td>  no </td></tr><tr><td>  <strong>Cuerda spannable</strong> </td><td>  no </td><td>  si </td></tr><tr><td>  Constructor de <strong>cadenas de spannables</strong> </td><td>  si </td><td>  si </td></tr></tbody></table></div><br><p>  <code>SpannableStringBuilder</code> , por ejemplo, se usa dentro de un <code>EditText</code> que necesita cambiar el texto. </p><br><p>  Puede agregar un nuevo tramo a una l√≠nea utilizando el m√©todo: </p><br><p> <code>setSpan(Object what, int start, int end, int flags)</code> </p> <br><p>  El intervalo se pasa a trav√©s del primer par√°metro, luego se indica el rango de √≠ndices en el texto.  Y se puede controlar el √∫ltimo par√°metro, cu√°l ser√° el comportamiento del intervalo al insertar texto nuevo: si el intervalo se extender√° al texto insertado en el punto inicial o final (si inserta texto nuevo en el medio, el intervalo se aplicar√° autom√°ticamente, independientemente de los valores del indicador) . </p><br><p>  Las clases enumeradas anteriormente difieren no solo sem√°nticamente, sino tambi√©n en c√≥mo est√°n organizadas internamente: <code>SpannedString</code> y <code>SpannableString</code> usan matrices para almacenar tramos, y <code>SpannableStringBuilder</code> usa un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rbol de intervalos</a> . </p><br><p>  Si realiza pruebas para la velocidad de representaci√≥n del texto en funci√≥n del n√∫mero de tramos, obtendr√° los siguientes resultados: al usar hasta ~ 250 tramos seguidos, <code>SpannableString</code> y <code>SpannableStringBuilder</code> funcionan aproximadamente a la misma velocidad, pero si los elementos de marcado llegan a m√°s de 250, entonces comienza <code>SpannableString</code> a perder  Por lo tanto, si la tarea es aplicar un estilo a alg√∫n texto, al elegir una clase, uno debe guiarse por los requisitos sem√°nticos: si la l√≠nea y los estilos ser√°n mutables.  Pero si el marcado requiere m√°s de 250 tramos, siempre debe dar <code>SpannableStringBuilder</code> a <code>SpannableStringBuilder</code> . </p><br><h2 id="proverka-na-nalichie-spana-v-tekste">  Verifique el espacio en el texto </h2><br><p>  La tarea surge peri√≥dicamente para verificar si una l√≠nea extendida tiene un alcance espec√≠fico.  Y en Stackoverflow puedes encontrar este c√≥digo: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasSpan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(spanned: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Spanned</span></span></span></span><span class="hljs-function"><span class="hljs-params">, clazz: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Class</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> spans: Array&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> T&gt; = spanned.getSpans(<span class="hljs-number"><span class="hljs-number">0</span></span>, spanned.length, clazz) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> spans.isNotEmpty() }</code> </pre> <br><p>  Tal soluci√≥n funcionar√°, pero es ineficiente: debe pasar por todos los tramos, verificar si cada uno pertenece al tipo pasado, recopilar el resultado en una matriz y, al final, simplemente verificar que la matriz no est√© vac√≠a. </p><br><p>  Una soluci√≥n m√°s efectiva ser√≠a usar el m√©todo <code>nextSpanTransition()</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasSpan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(spanned: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Spanned</span></span></span></span><span class="hljs-function"><span class="hljs-params">, clazz: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Class</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> limit = spanned.length <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> spanned.nextSpanTransition(<span class="hljs-number"><span class="hljs-number">0</span></span>, limit, clazz) &lt; limit }</code> </pre> <br><h2 id="razmetka-teksta-v-razlichnyh-yazykovyh-resursah">  Marcado de texto en varios recursos ling√º√≠sticos. </h2><br><p>  Tal tarea puede surgir cuando se requiere resaltar una palabra espec√≠fica usando marcado en varios recursos de cadena.  Por ejemplo, debemos resaltar la palabra <em>"texto"</em> en la versi√≥n en ingl√©s y <em>"texto"</em> en espa√±ol: </p><br><pre> <code class="xml hljs"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-en/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"title"</span></span></span><span class="hljs-tag">&gt;</span></span>Best practices for text in Android<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-es/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äùtitle‚Äù</span></span></span><span class="hljs-tag">&gt;</span></span>Texto en Android: mejores pr√°cticas<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Si necesita algo simple, por ejemplo, para resaltar la palabra en negrita, puede usar las etiquetas html habituales ( <code>&lt;b&gt;</code> ).  En la interfaz de usuario, solo necesita establecer el recurso de cadena en TextView: </p><br><pre> <code class="kotlin hljs">textView.setText(R.string.title)</code> </pre> <br><p>  Pero si necesita algo m√°s complejo, por ejemplo, cambiar la fuente, html ya no se puede usar.  La soluci√≥n es usar la <code>&lt;annotation&gt;</code> especial <code>&lt;annotation&gt;</code> .  Esta etiqueta le permite definir cualquier par clave-valor en un archivo xml.  Cuando extraemos una cadena de recursos, estas etiquetas se convierten autom√°ticamente en <code>Annotation</code> de <code>Annotation</code> , organizados en el texto con las claves y valores correspondientes.  Despu√©s de eso, puede analizar la lista de anotaciones en el texto y aplicar los intervalos necesarios. </p><br><p>  Supongamos que necesitamos cambiar la fuente usando <code>CustomTypefaceSpan</code> . </p><br><p>  Agregue una etiqueta y defina una clave de <em>"fuente"</em> y un valor; el tipo de fuente que queremos usar es <em>"title_emphasis"</em> : <br></p><pre> <code class="xml hljs"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-en/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"title"</span></span></span><span class="hljs-tag">&gt;</span></span>Best practices for <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">font</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äùtitle_emphasis‚Äù</span></span></span><span class="hljs-tag">&gt;</span></span>text<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag">&gt;</span></span> in Android<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-es/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äùtitle‚Äù</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">font</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äùtitle_emphasis‚Äù</span></span></span><span class="hljs-tag">&gt;</span></span>Texto<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag">&gt;</span></span> en Android: mejores pr√°cticas<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Extraiga la cadena de los recursos, encuentre las anotaciones con la tecla <em>"fuente"</em> y organice los tramos: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//      SpannedString,     span' val titleText = getText(R.string.title) as SpannedString //    val annotations = titleText.getSpans(0, titleText.length, Annotation::class.java) //     SpannableString //      val spannableString = SpannableString(titleText) //     for (annotation in annotations) { //     "font" if (annotation.key == "font") { val fontName = annotation.value //   ,     if (fontName == "title_emphasis") { val typeface = getFontCompat(R.font.permanent_marker) //  span    ,    spannableString.setSpan( CustomTypefaceSpan(typeface), titleText.getSpanStart(annotation), titleText.getSpanEnd(annotation), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE ) } } } styledText.text = spannableString</span></span></code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/62/mm/yq62mmgvajffkxkzk3qntsnxhw4.png" width="600"></div><br><p>  Se mencion√≥ anteriormente que los tramos desde fuera del marco de Android no pueden implementar <code>Parcelable</code> y se transmiten a trav√©s de Intent.  Pero esto no se aplica a las anotaciones que implementan <code>Parcelable</code> .  Por lo tanto, puede pasar la cadena anotada a trav√©s de Intent y analizar exactamente de la misma manera organizando sus tramos. </p><br><h1 id="kak-tekst-raspolagaetsya-v-textview">  C√≥mo se coloca el texto en un TextView </h1><br><p>  TextView puede mostrar no solo texto, sino tambi√©n im√°genes.  Tambi√©n puede establecer varias sangr√≠as delante del texto.  Debajo del cap√≥, esto funciona para que TextView cree una clase secundaria, Layout, que es responsable directamente de mostrar el texto.  Esta es una clase abstracta que tiene tres implementaciones; por lo general, no tiene que trabajar directamente con ellas a menos que escriba su propio control: </p><br><ul><li>  <strong>BoringLayout se</strong> usa para textos simples, no admite <strong>saltos de</strong> l√≠nea, RTL y otras cosas, pero es el m√°s liviano.  TextView lo usa si el texto cumple con todas las restricciones. </li><li>  <strong>StaticLayout se</strong> usa en TextView para otros casos. </li><li>  <strong>DynamicLayout se</strong> usa para texto mutable en un EditText. </li></ul><br><p>  El dise√±o tiene muchos m√©todos que le permiten conocer los diversos par√°metros del texto que se muestra: las coordenadas de las l√≠neas, la l√≠nea base, las coordenadas del principio y el final del texto en la l√≠nea, etc.  (se pueden encontrar m√°s detalles en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> ) </p><br><p>  Tales m√©todos pueden ser muy √∫tiles.  Por ejemplo, algunos desarrolladores se enfrentan a la tarea de extraer parte del texto en rect√°ngulos redondeados, y est√°n tratando de encontrar su soluci√≥n a trav√©s de tramos que no son aplicables para resolver este problema. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8b/-2/df/8b-2df4-wo4ghk8tkwss6l48bfy.png" width="300"></div><br><p>  Pero los m√©todos de la clase Layout pueden venir al rescate.  Aqu√≠ hay una soluci√≥n de muestra: </p><br><p>  Usando anotaciones, seleccionamos las palabras que deben estar encerradas en rect√°ngulos. </p><br><p>  Luego, cree 4 recursos dibujables para todos los casos de ajuste de texto, que deben encerrarse en rect√°ngulos: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q4/ry/oj/q4ryojq_lsj3sdyyehvprallpl8.png" width="600"></div><br><p>  A continuaci√≥n, encontramos las anotaciones que necesitamos en el texto, como se describi√≥ anteriormente.  Ahora tenemos los √≠ndices del principio y el final de dicha anotaci√≥n.  A trav√©s de los m√©todos de dise√±o, puede averiguar el n√∫mero de la l√≠nea en la que comienza el texto anotado y en el que termina: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startLine = layout.getLineForOffset(spanStartIndex) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> endLine = layout.getLineForOffset(spanEndIndex)</code> </pre> <br><p>  Luego, debes dibujar uno o m√°s rect√°ngulos.  Considere el caso simple cuando la parte anotada del texto apareci√≥ en una l√≠nea, entonces solo necesitamos un rect√°ngulo con cuatro esquinas redondeadas.  Defina sus coordenadas y dibuje: </p><br><pre> <code class="kotlin hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startLine == endLine) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lineTop = layout.getLineTop(startLine) <span class="hljs-comment"><span class="hljs-comment">//    val lineBottom = layout.getLineBottom(startLine) //    val startCoor = layout.getPrimaryHorizontal(spanStartIndex).toInt() //    val endCoor = layout.getPrimaryHorizontal(spanEndIndex).toInt() //    //   drawable.setBounds(startCoor, lineTop, endCoor, lineBottom) drawable.draw(canvas) ...</span></span></code> </pre><br><p>  Como puede ver en este ejemplo, Layout almacena mucha informaci√≥n √∫til sobre el texto que se muestra, lo que puede ayudar en la implementaci√≥n de varias tareas no est√°ndar. </p><br><h1 id="proizvoditelnost-textview">  TextView Performance </h1><br><p>  TextView, como cualquier vista, pasa por tres fases cuando se muestra: <code>onMeasure()</code> , <code>onLayout()</code> y <code>onDraw()</code> .  Al mismo tiempo, <code>onMeasure()</code> lleva la mayor parte del tiempo, a diferencia de los otros dos m√©todos: en este momento, se recrea la clase Layout y se calcula el tama√±o del texto.  Por lo tanto, cambiar el tama√±o del texto (por ejemplo, cambiar la fuente) implica mucho trabajo.  Cambiar el color del texto ser√° m√°s liviano porque solo requiere invocar <code>onDraw()</code> .  Como se mencion√≥ anteriormente, el sistema tiene una memoria cach√© global de palabras con tama√±os calculados.  Si la palabra ya est√° en el cach√©, volver a llamar a <code>onMeasure()</code> para que <code>onMeasure()</code> 11 y el 16% del tiempo que habr√≠a sido necesario para un c√°lculo completo. </p><br><h2 id="uskorenie-pokaza-teksta">  Aceleraci√≥n de texto </h2><br><p>  En 2015, los desarrolladores de Instagram aceleraron la visualizaci√≥n de comentarios en fotos usando el cach√© global.  La idea era dibujar virtualmente el texto antes de mostrarlo en la pantalla, "calentando" la memoria cach√© del sistema.  Cuando lleg√≥ el momento de mostrar el texto, el usuario lo vio mucho m√°s r√°pido, ya que el texto ya estaba medido y estaba en el cach√©. </p><br><p>  A partir de <strong>Android P (28)</strong> , los desarrolladores de Google han agregado a la API la capacidad de realizar la fase de medici√≥n del tama√±o del texto por adelantado en el hilo de fondo - <code>PrecomputedText</code> (y el backport para la API que comienza con <strong>Android I (14)</strong> - <code>PrecomputedTextCompat</code> ).  Usando la nueva API, el 90% del trabajo se realizar√° en el hilo de fondo. </p><br><p>  Un ejemplo: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// UI thread val params: PrecomputedText.Params = textView.getTextMetricsParams() val ref = WeakReference(textView) executor.execute { // background thread val text = PrecomputedText.create("Hello", params) val textView = ref.get() textView?.post { // UI thread val textView = ref.get() textView?.text = text } }</span></span></code> </pre> <br><h2 id="pokaz-bolshogo-teksta">  Mostrar texto grande </h2><br><p>  Si necesita mostrar texto grande, no lo transfiera inmediatamente a TextView.  De lo contrario, la aplicaci√≥n puede dejar de funcionar sin problemas o congelarse por completo, ya que har√° mucho trabajo en el hilo principal para mostrar un texto enorme que el usuario ni siquiera puede desplazarse hasta el final.  La soluci√≥n es dividir el texto en partes (por ejemplo, p√°rrafos) y mostrar las partes individuales en RecyclerView.  Para una aceleraci√≥n a√∫n mayor, puede calcular previamente el tama√±o de los bloques de texto usando PrecomputedText. </p><br><p>  Para facilitar la incorporaci√≥n de PrecomputedText en RecyclerView, los desarrolladores de Google <code>PrecomputedTextCompat.getTextFuture()</code> m√©todos especiales <code>PrecomputedTextCompat.getTextFuture()</code> y <code>AppCompatTextView.setTextFuture()</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vh: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewHolder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = getData(position) vh.textView.setTextSize(...) vh.textView.setFontVariationSettings(...) <span class="hljs-comment"><span class="hljs-comment">//    val future = PrecomputedTextCompat.getTextFuture( data.text, vh.textView.getTextMetricsParamsCompat(), myExecutor ) //  future  TextView,      onMeasure() vh.textView.setTextFuture(future) }</span></span></code> </pre> <br><p>   RecyclerView      ,     ,              ,     . </p><br><p>  ,     <code>getTextFuture()</code>     (,   ),     ,   ,    <code>getTextFuture()</code> ,     ,    TextView. </p><br><h2 id="chto-nuzhno-znat-kogda-ustanavlivaesh-tekst-v-textview">   ,     TextView </h2><br><p>    <code>TextView.setText()</code>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == SPANNABLE || movementMethod != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { text = spannableFactory.newSpannable(spannable) <span class="hljs-comment"><span class="hljs-comment">//  } else { text = new SpannedString(spannable) //  }</span></span></code> </pre> <br><p>       span'  TextView,       <code>setText()</code> ,      . </p><br><p>    ,      .  TextView    ,  -,   .    ,      .    ,    ,     TextView   <code>spannableFactory</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MySpannableFactory</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Spannable.Factory</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newSpannable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(source: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharSequence</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Spannable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? Spannable ?: <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.newSpannable(source) } } textView.spannableFactory = MySpannableFactory()</code> </pre> <br><p>         <code>textView.setText(spannable, BufferType.SPANNABLE)</code> ,      . </p><br><p>  Google         span'  RecyclerView,      . </p><br><p>      TextView,     span,        <code>setText()</code> .      TextView      span. TextView   spannable-    span',  : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> spannable = textView.getText() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Spannable <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> span = CustomTypefaceSpan(span) spannable.setSpan(span, ...)</code> </pre> <br><p>      span,      TextView,         TextView .       ,   <code>invalidate()</code> ,    ‚Äì <code>requestLayout()</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> spannable = textView.getText() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Spannable <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> span = CustomTypefaceSpan(span) spannable.setSpan(span, ...) span.setTypeface(anotherTypeface) textView.requestLayout() <span class="hljs-comment"><span class="hljs-comment">// re-measure and re-draw // or textView.invalidate() // re-draw</span></span></code> </pre> <br><h2 id="ispolzovanie-autolink">  autoLink </h2><br><p>  TextView     .         <code>autoLink</code> .   <code>autoLink=‚Äùweb‚Äù</code> TextView          URL          <code>URLSpan</code> .   ,     SDK   <code>setText()</code> : </p><br><pre> <code class="java hljs">spannable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpannableString(string); Matcher m = pattern.matcher(text); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (...) { <span class="hljs-comment"><span class="hljs-comment">//      String utl = ‚Ä¶ URLSpan span = new URLSpan(url); spannable.setSpan(span, ...); }</span></span></code> </pre> <br><p>      UI ,     <code>autoLink=‚Äùweb‚Äù</code>   RecyclerView.          .        <code>LinkifyCompat</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,       background thread val spannable = SpannableString(string) LinkifyCompat.addLinks(spannable, Linkify.WEB_URLS) //   RecyclerView override fun onBindViewHolder(holder: ViewHolder, position: Int) { holder.textView.setText(spannable, BufferType.SPANNABLE) // ... }</span></span></code> </pre> <br><p>  <code>autoLink</code>      <code>map</code> ‚Äì    (      <code>all</code> ).       .   ,        WebView,      !    SDK   <code>Linkify.gatherMapLinks()</code>    ,      : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((address = WebView.findAddress(string)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { ... }</code> </pre> <br><p>   WebView  TODO   SDK: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Rewrite this in Java so it is not needed to start up chromium // Could also be deprecated return getFactory().getStatics().findAddress(addr); }</span></span></code> </pre> <br><p>     ?     Smart Linkify,       <strong>Android P (28)</strong> ,          ,      .    : </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// UI thread val text: Spannable = ‚Ä¶ val request = TextLinks.Request.Builder(text) val ref = WeakReference(textView) executor.execute { // background thread TextClassifier.generateLinks(request).apply(text) val textView = ref.get() textView?.post { // UI thread val textView = ref.get() textView?.text = text } }</span></span></code> </pre> <br><p>    Linkify,      .        toolbar   ,     Google . </p><br><p>  Smart Linkify    :  ,    . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9t/nc/qb/9tncqbkanp8avsnmisd-ax0z7ae.gif" width="300"></div><br><h1 id="magnifier"> Magnifier </h1><br><p>   <strong>Android P (28)</strong> ,     ‚Äì Magnifier,       .           . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fi/nn/or/finnor2svtuttfn1v-lxwkblgwm.gif" width="400"></div><br><p>      TextView, EditText  WebView,            :  API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . </p><br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><p>          Android   ,   , : </p><br><ul><li>         </li><li>    </li><li>   ,   TextView (, EditText) </li></ul><br><p>  -     ,      Google I/O'19 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">‚ÄúBest Practices for Using Text in Android‚Äù</a> . </p><br><a name="links"></a><br><h1 id="poleznye-ssylki">  Enlaces utiles </h1><br><h2 id="stati">  Art√≠culos </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Florina Muntenescu. "Spantastic text styling with Spans"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Florina Muntenescu. "Underspanding spans"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Florina Muntenescu. "Styling internationalized text in Android"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instagram Engineering. "Improving Comment Rendering on Android"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Daniel Lee. "Text rendering on Android"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mariusz DƒÖbrowski. "What is new in Android P ‚Äî PrecomputedText"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Chet Haase. "RecyclerView Prefetch"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Chris Craik. "Prefetch Text Layout in RecyclerView"</a> </li></ul><br><h2 id="doklady">  Informes </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Best practices for text on Android (Google I/O '18)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Use Android Text Like a Pro (Android Dev Summit '18)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Best Practices for Using Text in Android (Google I/O'19)</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461787/">https://habr.com/ru/post/461787/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461773/index.html">Airtest IDE: ¬øuna nueva forma de probar la automatizaci√≥n de los juegos m√≥viles?</a></li>
<li><a href="../461775/index.html">3 casos para usar Celery en una aplicaci√≥n Django</a></li>
<li><a href="../461779/index.html">El 80% de los datos de su empresa no est√° disponible para usted. ¬øQu√© hacer al respecto?</a></li>
<li><a href="../461781/index.html">"Ycombinator Startup School 2019." Video de las primeras tres semanas</a></li>
<li><a href="../461785/index.html">Desventajas de RISC-V</a></li>
<li><a href="../461793/index.html">Ivan Ponomarev sobre Kafka Streams API en la reuni√≥n jug.msk.ru</a></li>
<li><a href="../461797/index.html">Cuentos de servicio. Una publicaci√≥n fr√≠vola sobre trabajo serio</a></li>
<li><a href="../461801/index.html">DisplayPort-LVDS</a></li>
<li><a href="../461803/index.html">Data Version Control (DVC): control de versiones de datos y reproducibilidad de experimentos</a></li>
<li><a href="../461805/index.html">Aplicaci√≥n de integraci√≥n Monte Carlo en renderizado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>