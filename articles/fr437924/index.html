<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥üèΩ üêú üì≤ Blockchain Sharding üî™ üî¨ ü§¥üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous, je suis l'un des d√©veloppeurs de Near Protocol, qui, entre autres, impl√©mente le partage, et dans cet article, je veux dire en d√©tail ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blockchain Sharding</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437924/"><p>  Bonjour √† tous, je suis l'un des d√©veloppeurs de Near Protocol, qui, entre autres, impl√©mente le partage, et dans cet article, je veux dire en d√©tail ce qu'est le partage dans la blockchain, comment cela fonctionne, et aborder un certain nombre de probl√®mes qui surviennent lorsque vous essayez de le construire. </p><br><p>  Il est bien connu qu'Ethereum, la plate-forme dApps la plus populaire, traite moins de 20 transactions par seconde.  En raison de cette restriction, le prix des transactions et le temps pour les confirmer sont tr√®s √©lev√©s: malgr√© le fait qu'un bloc soit publi√© dans Ethereum une fois toutes les 10 √† 12 secondes, selon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ETH Gas Station, le</a> temps entre l'envoi d'une transaction et la fa√ßon dont elle tombe r√©ellement dans le bloc est en moyenne de 1,2 minutes.  La faible bande passante, les prix √©lev√©s et la longue confirmation de transaction ne permettent pas de lancer des services haute performance sur Ethereum. </p><br><p>  La principale raison pour laquelle Ethereum ne peut pas traiter plus de 20 transactions par seconde est que chaque n≈ìud dans Ethereum doit v√©rifier chaque transaction.  Au cours des cinq ann√©es qui ont suivi la sortie d'Ethereum, de nombreuses id√©es ont √©t√© propos√©es pour r√©soudre ce probl√®me.  Ces solutions peuvent √™tre grossi√®rement divis√©es en deux groupes: celles qui proposent de d√©l√©guer des transactions √† un petit groupe de n≈ìuds avec un tr√®s bon mat√©riel, et celles qui proposent √† chaque n≈ìud de ne traiter qu'un sous-ensemble de toutes les transactions.  Un exemple de la premi√®re approche est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Thunder</a> , dans lequel les blocs sont cr√©√©s par un seul n≈ìud, ce qui permet, selon les d√©veloppeurs, de recevoir 1200 transactions par seconde, soit 100 fois plus qu'Ethereum.  D'autres exemples de la premi√®re cat√©gorie sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Algorand</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SpaceMesh</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Solana</a> .  Tous ces protocoles am√©liorent divers aspects du protocole et vous permettent d'effectuer plus de transactions que dans Ethereum, mais tous sont limit√©s par la vitesse d'une machine (bien que tr√®s puissante). </p><a name="habracut"></a><br><p>  La deuxi√®me approche, dans laquelle chaque n≈ìud ne traite qu'un sous-ensemble de transactions, est appel√©e Sharding.  C'est ainsi que la Fondation Ethereum pr√©voit d'augmenter la bande passante Ethereum. </p><br><p>  Dans cet article, je vais vous expliquer comment fonctionne Sharding dans Blockchain en utilisant l'exemple de plusieurs protocoles en cours de d√©veloppement. </p><br><div class="spoiler">  <b class="spoiler_title">Terminologie</b> <div class="spoiler_text"><p>  √âtant donn√© que la terminologie n'est pas normalis√©e, j'utiliserai les termes russes suivants dans l'article: </p><br><p>  <strong>Une blockchain</strong> est soit une technologie en g√©n√©ral, soit une structure de donn√©es contenant tous les blocs, y compris les fourches. </p><br><p>  <strong>Une cha√Æne</strong> est une cha√Æne particuli√®re dans la cha√Æne de blocs, c'est-√†-dire tous les blocs accessibles √† partir d'un bloc en utilisant des liens vers le bloc pr√©c√©dent. </p><br><p>  <strong>La cha√Æne canonique</strong> est une cha√Æne de la blockchain que le participant qui regarde la blockchain consid√®re la cha√Æne actuelle.  Par exemple, dans la blockchain Proof of Work, ce sera la cha√Æne la plus complexe. </p><br><p>  <strong>Un r√©seau,</strong> c'est beaucoup de participants qui construisent et utilisent la blockchain. </p><br><p>  <strong>Un n≈ìud</strong> est un serveur qui prend en charge ou utilise un r√©seau. </p></div></div><br><h2 id="samyy-prostoy-sharding">  Le partage le plus simple </h2><br><p>  Dans la mise en ≈ìuvre la plus simple, au lieu de prendre en charge une cha√Æne de blocs, nous en prendrons en charge plusieurs, et nous appellerons chacune de ces cha√Ænes de blocs un ¬´fragment¬ª.  Chaque fragment est pris en charge par un ensemble ind√©pendant de n≈ìuds qui v√©rifient les transactions et cr√©ent des blocs.  Ci-apr√®s, j'appellerai de tels validateurs de n≈ìuds. </p><br><p>  Chaque fragment est responsable d'un sous-ensemble de contrats et de comptes.  Supposons pour l'instant que les transactions ne fonctionnent toujours qu'avec des contrats et des comptes au sein du m√™me fragment.  Une telle conception simplifi√©e est suffisante pour montrer certains probl√®mes et caract√©ristiques int√©ressants du partage. </p><br><h2 id="naznachenie-validatorov-i-centralnyy-blokcheyn">  Nomination des validateurs et Blockchain centrale </h2><br><p>  Le premier probl√®me avec le fait que chaque fragment a ses propres validateurs est que si nous avons 10 shadras, chaque fragment est maintenant 10 fois moins fiable qu'une cha√Æne de blocs.  Donc, si une blockchain avec X validateurs d√©cide de faire un hard fork dans un syst√®me de fragments avec 10 fragments, et casse les X validateurs entre 10 fragments, maintenant il n'y a plus que X / 10 validateurs dans chaque fragment, et gagner le contr√¥le sur le fragment n√©cessite de contr√¥ler 5,1% (51 % / 10) validateurs. </p><br><p>  Ce qui conduit √† la premi√®re question int√©ressante: qui attribue les validateurs aux fragments?  Le contr√¥le de 5,1% des validateurs n'est un probl√®me que si tous les 5,1% des validateurs sont dans le m√™me fragment.  Si les validateurs eux-m√™mes ne peuvent pas choisir le fragment auquel ils sont affect√©s, le contr√¥le de 5,1% des validateurs avant leur affectation ne leur permettra pas de contr√¥ler les fragments. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6c8/bd1/f09/6c8bd1f0949baeb207f4d7e6c6c81d8f.png" alt="image"></p><br><p>  Presque toutes les conceptions de partage propos√©es proposent une source de nombres al√©atoires pour attribuer des validateurs aux fragments.  L'obtention de nombres al√©atoires dans un syst√®me distribu√© dans lequel les participants ne se font pas confiance n'est pas un probl√®me compl√®tement r√©solu aujourd'hui, que nous n'aborderons pas dans cet article, et supposons simplement que nous avons une telle source de nombres al√©atoires. </p><br><p>  La r√©ception de nombres al√©atoires et la nomination de validateurs sont des calculs √† l'√©chelle du syst√®me qui ne sont sp√©cifiques √† aucun fragment particulier.  Pour de tels calculs, les conceptions modernes de blockchain de fragments ont une blockchain suppl√©mentaire d√©di√©e qui existe uniquement pour effectuer des calculs √† l'√©chelle du syst√®me.  En plus des nombres al√©atoires et de la nomination de validateurs, ces calculs peuvent inclure l'obtention de hachages des derniers blocs √† partir d'√©clats et leur stockage;  le traitement des garanties dans les syst√®mes de preuve de participation et l'√©tude des preuves d'un comportement inappropri√© avec la s√©lection associ√©e de telles garanties;  r√©√©quilibrer les fragments, si une telle fonction est fournie.  Une telle blockchain est appel√©e la cha√Æne Beacon dans Ethereum 2.0 et Near Protocol, la cha√Æne Relay dans PolkaDot et le Cosmos Hub dans Cosmos. </p><br><p>  Dans ce post, nous appellerons une telle blockchain la ¬´blockchain centrale¬ª.  L'existence d'une blockchain centrale nous am√®ne au prochain sujet int√©ressant - le partage quadratique. </p><br><h2 id="kvadratichnoe-shardirovanie">  Partage quadratique </h2><br><p>  Le sharding est souvent pr√©sent√© comme une solution qui √©volue √† l'infini avec le nombre croissant de n≈ìuds.  Probablement, vous pouvez vraiment cr√©er un syst√®me avec cette propri√©t√©, mais les syst√®mes avec une blockchain centrale ont une limite sup√©rieure sur le nombre de fragments, et par cons√©quent n'ont pas une √©volutivit√© infinie.  Il est facile de comprendre pourquoi: la blockchain centrale effectue certains calculs, tels que l'attribution de validateurs et la pr√©servation des derniers √©tats de fragments, dont la complexit√© est proportionnelle au nombre de fragments.  √âtant donn√© que la blockchain centrale elle-m√™me n'est pas fragment√©e et que son d√©bit est limit√© par le d√©bit de chaque n≈ìud, le nombre de fragments qu'elle peut prendre en charge est limit√©. </p><br><p>  Voyons comment le d√©bit de l'ensemble du syst√®me change si la puissance des n≈ìuds qui le supportent augmente k fois.  Chaque fragment pourra traiter k fois plus de transactions, et la blockchain centrale pourra supporter k fois plus de fragments.  Ainsi, le d√©bit de l'ensemble du syst√®me augmentera k ^ 2 fois.  D'o√π le nom de ¬´sharding quadratique¬ª. </p><br><p>  Il est difficile de pr√©dire combien de fragments peuvent prendre en charge la blockchain centrale aujourd'hui, mais tr√®s probablement dans un proche avenir, nous ne nous rapprocherons pas de la limite de transaction pour une blockchain fragment√©e avec un partage quadratique.  Tr√®s probablement, nous allons bient√¥t nous heurter √† la limite du nombre de n≈ìuds n√©cessaires pour prendre en charge un tel nombre de fragments. </p><br><h2 id="shardirovanie-sostoyaniya">  Partage d'√©tat </h2><br><p>  Le statut est toutes les informations sur tous les comptes et contrats.  Jusqu'√† pr√©sent, nous avons parl√© du sharding en g√©n√©ral, sans pr√©ciser ce qu'est exactement le sharding.  Les n≈ìuds de la blockchain effectuent les trois t√¢ches suivantes: 1) effectuer des transactions 2) transmettre des transactions et des blocs √† d'autres n≈ìuds et 3) stocker l'√©tat et l'historique de la blockchain.  Chacune de ces trois t√¢ches est associ√©e √† une charge sans cesse croissante sur les n≈ìuds: </p><br><ol><li>  La n√©cessit√© d'effectuer des transactions n√©cessite plus de puissance de calcul avec une augmentation du nombre de transactions; </li><li>  La n√©cessit√© de transf√©rer les transactions n√©cessite plus de bande passante r√©seau √† mesure que les transactions augmentent; </li><li>  La n√©cessit√© de maintenir l'√©tat et l'historique n√©cessite plus d'espace disque √† mesure que la taille de l'√©tat et / ou de l'historique augmente.  Il est important de noter que, contrairement aux deux premiers points, la quantit√© d'espace disque requis augmente m√™me si le nombre de transactions par unit√© de temps ne change pas. </li></ol><br><p>  D'apr√®s la liste ci-dessus, il peut sembler que l'espace disque est le plus gros probl√®me, car seul l'espace disque augmente m√™me si le nombre de transactions n'augmente pas, mais en pratique ce n'est pas le cas.  Aujourd'hui, l'√©tat d'Ethereum occupe environ 100 Go, ce qui peut facilement √™tre enregistr√© sur n'importe quelle machine moderne, mais le nombre de transactions qu'Ethereum peut traiter est limit√© √† plusieurs dizaines par seconde, reposant sur la puissance de calcul et le r√©seau. </p><br><p>  Zilliqa est le projet le plus c√©l√®bre qui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©partit l'informatique et le r√©seau</a> mais pas l'√âtat.  Le calcul du partage est plus simple que le partage, car tous les n≈ìuds ont tous un √©tat et peuvent toujours ex√©cuter facilement des contrats qui provoquent d'autres contrats ou affectent les comptes sur diff√©rents fragments.  Sous ces aspects, le design de Zilliqa est trop simplifi√©, la critique du design en anglais peut √™tre lue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Bien que le partage d'√©tat sans calculs d'ombrage ait √©t√© propos√©, je ne connais aucun projet qui le fasse vraiment, nous supposerons donc que le partage d'√©tat implique des calculs de partage. </p><br><p>  En pratique, le fait que l'√©tat soit fragment√© isole en quelque sorte les fragments, ce qui leur permet d'√™tre des cha√Ænes de blocs ind√©pendantes, comme nous l'avons d√©fini ci-dessus.  Les validateurs dans les fragments stockent uniquement un √©tat sp√©cifique √† leur fragment, et seules les transactions qui affectent cet √©tat sont ex√©cut√©es et transmises.  Cela r√©duit la charge sur le processeur, le disque et le r√©seau de mani√®re lin√©aire avec le nombre de fragments, mais pose de nouveaux probl√®mes, tels que les transactions entre les fragments. </p><br><h2 id="mezhdu-shardovye-tranzakcii">  Transactions inter-fragments </h2><br><p>  Jusqu'√† pr√©sent, nous avons vu les fragments comme des cha√Ænes de blocs ind√©pendantes en termes de la fa√ßon dont ils ex√©cutent les transactions.  Avec cette conception, par exemple, il est impossible de r√©aliser une transaction qui transf√®re de l'argent entre deux comptes sur deux fragments diff√©rents, ou de provoquer le contact sur un fragment d'un contrat √† l'autre.  Je voudrais soutenir les deux sc√©narios. </p><br><p>  Par souci de simplicit√©, nous ne consid√©rerons que les transactions qui transf√®rent de l'argent, et nous supposerons que chaque participant poss√®de un compte sur exactement un fragment.  Si un participant sur un fragment souhaite transf√©rer de l'argent √† un participant sur le m√™me fragment, les validateurs de ce fragment peuvent traiter cette transaction et l'appliquer √† l'√âtat.  Mais si, par exemple, Alice a un compte sur le fragment # 1 et qu'elle veut envoyer de l'argent √† Bob avec un compte sur le fragment # 2, ni les validateurs de partition # 1 (qui ne peut pas ajouter d'argent √† Bob) ni les validateurs de partition # 2 (qui ne peuvent pas obtenir l'argent d'Alice ) ne peut pas terminer la transaction et mettre √† jour l'√©tat. </p><br><p>  Il existe deux grands groupes d'approches pour r√©soudre ce probl√®me: </p><br><ol><li><p>  <strong>Synchrone</strong> : pour toute transaction impliquant plusieurs fragments, les blocs des fragments contenant des mises √† jour d'√©tat pour cette transaction sont produits simultan√©ment et les valideurs de ces fragments travaillent ensemble pour cr√©er de tels blocs.  La conception la plus √©labor√©e de cette approche, √† ma connaissance, est Merge Blocks, d√©crite (en anglais) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br></li><li><p>  <strong>Asynchrone</strong> : une transaction inter-fragments est ex√©cut√©e en fragments qu'elle affecte, de mani√®re asynchrone: la partie de la transaction qui ajoute de l'argent √† Bob est ex√©cut√©e dans le fragment # 2 lorsque les validateurs du fragment ont des preuves que la partie de la transaction qui soustrait l'argent d'Alice a √©t√© ex√©cut√©e dans tesson # 1.  Cette approche est plus populaire dans les syst√®mes d√©velopp√©s aujourd'hui car elle ne n√©cessite pas de synchronisation suppl√©mentaire entre les fragments pour la production de blocs.  De tels syst√®mes sont propos√©s aujourd'hui dans Cosmos, Ethereum Serenity, Near Protocol, Kadena et autres.  Le probl√®me avec cette approche est que si les blocs sont produits ind√©pendamment, il est probable que l'un des blocs contenant la mise √† jour d'√©tat de la transaction ne soit pas dans la cha√Æne canonique dans son fragment, et donc la transaction ne sera que partiellement termin√©e.  Par exemple, consid√©rez la figure ci-dessous.  Il montre deux fragments dans lesquels les fourches se sont produites et une transaction inter-fragments, dont la mise √† jour d'√©tat est refl√©t√©e dans les blocs A et X ', respectivement.  Si les cha√Ænes AB et V'-X'-Y'-Z 's'av√®rent √™tre canoniques dans leurs fragments, alors la transaction est enti√®rement finalis√©e.  Si les cha√Ænes A'-B'-C'-D 'et VX sont canoniques, alors la transaction est compl√®tement annul√©e, ce qui est acceptable.  Mais si, par exemple, AB et VX deviennent canoniques, une partie de la transaction est finalis√©e, l'autre est annul√©e et la transaction est partiellement termin√©e. </p><br></li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/640/162/e6c/640162e6c138290296c5186fab24e5d1.png" alt="image"></p><br><p>  Le sc√©nario d√©crit ci-dessus est l'un des gros probl√®mes de partage, dans lequel toutes les solutions propos√©es ne sont pas optimales.  Nous y reviendrons un peu plus loin. </p><br><h2 id="plohoe-povedenie">  Mauvais comportement </h2><br><p>  Maintenant que nous avons compris comment fonctionnent les cha√Ænes de blocs de fragments et √©tudi√© les concepts de la blockchain centrale, la nomination de validateurs et les transactions entre fragments, √† la fin de cet article, nous allons examiner un autre sujet int√©ressant: que peut faire un participant essayant d'attaquer le syst√®me s'il parvient √† obtenir contr√¥le sur un nombre suffisamment important de validateurs dans un seul fragment. </p><br><h3 id="celenapravlennye-forki">  Fourches cibl√©es </h3><br><p>  Si le participant a un contr√¥le suffisant sur le fragment, il peut d√©lib√©r√©ment cr√©er des fourches.  Pour cr√©er des fourches, peu importe le consensus utilis√© dans les fragments, en particulier, peu importe qu'il s'agisse de BFT ou non, si un nombre suffisant de validateurs sont contr√¥l√©s par l'attaquant, il peut cr√©er un fork.  Par exemple, l'objectif du fork pourrait √™tre d'annuler une transaction qui a pay√© quelque chose en dehors de la blockchain. </p><br><p>  On pr√©tend que gagner le contr√¥le de 50% du fragment est plus facile que 50% de l'ensemble du r√©seau (par exemple, parce qu'un participant peut essayer de pirater ou de corrompre les validateurs apr√®s qu'ils ont √©t√© affect√©s au fragment).  Par d√©finition, les transactions entre fragments changent d'√©tat dans plusieurs fragments.  De tels changements tomberont dans certains blocs dans les cha√Ænes de blocs des fragments correspondants.  Il est n√©cessaire que tous ces blocs soient finalis√©s (c'est-√†-dire qu'ils appartiennent √† la cha√Æne canonique dans leurs fragments respectifs) ou qu'ils ne soient pas tous finalis√©s (c'est-√†-dire qu'ils n'appartiennent pas √† la cha√Æne canonique dans leurs fragments).  √âtant donn√© que nous supposons que certains participants avec de mauvaises intentions peuvent, en principe, prendre le contr√¥le du fragment, nous ne pouvons pas supposer que les fourches ne se produiront pas m√™me si le consensus byzantin a √©t√© atteint, ou qu'un grand nombre de blocs ont √©t√© construits au-dessus du bloc avec la transaction. </p><br><p>  Ce probl√®me a de nombreuses solutions, dont la plus simple consiste parfois √† enregistrer le hachage du dernier bloc du fragment dans la blockchain centrale.  L'algorithme de s√©lection de cha√Æne canonique dans les fragments est ensuite modifi√© de sorte qu'aucune cible contenant le dernier bloc stock√© sur la cha√Æne de blocs centrale canonique.  Ensuite, afin d'√©viter compl√®tement les situations o√π la transaction a √©t√© partiellement termin√©e en raison du fait que certains des blocs contenant sa mise √† jour d'√©tat se sont r√©v√©l√©s √™tre en dehors des cha√Ænes canoniques, vous pouvez modifier l'algorithme pour ex√©cuter les transactions entre les fragments de sorte que le fragment A n'accepte pas la preuve de la transaction dans le fragment B jusqu'au bloc. contenant la mise √† jour de l'√©tat de la transaction dans le fragment B n'a pas √©t√© enregistr√© dans la blockchain centrale. </p><br><h3 id="sozdanie-nevalidnyh-blokov">  Cr√©ation de blocs invalides </h3><br><p>  Si le participant a pu prendre le contr√¥le d'un nombre suffisamment important de validateurs dans le fragment, il peut essayer de cr√©er un bloc compl√®tement invalide.  Par exemple, supposons qu'avant le bloc, l'√©tat √©tait tel qu'Alice avait 10 jetons, et dans Bob - 0, le bloc ne contient qu'une seule transaction, qui envoie 10 jetons du compte d'Alice au compte de Bob, mais dans le nouvel √©tat, il refl√®te 0 jetons d'Alice et 1000 avec Bob. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e68/edd/049/e68edd049344263dd671209a10be0890.png" alt="image"></p><br><p>  Dans une blockchain classique sans partition, la cr√©ation d'un tel bloc est impossible, car tous les participants, comme ceux qui cr√©ent des blocs et ceux qui utilisent simplement la blockchain, v√©rifient tous les blocs et √©liminent imm√©diatement tout bloc contenant de telles erreurs.  M√™me si les validateurs contr√¥l√©s par l'attaquant peuvent construire la cha√Æne plus rapidement, cela ne leur permettra pas de passer la cha√Æne plus longue contenant le bloc invalide comme canonique, car tous les participants au r√©seau rejetteront imm√©diatement le bloc invalide et tout bloc qui a √©t√© construit par-dessus.  Les validateurs honn√™tes continueront de s'appuyer sur le dernier bloc valide, et tous les participants au r√©seau verront leur cha√Æne comme canonique. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1c5/0a8/b45/1c50a8b45dfda77a14262225dc3351ca.png" alt="image"></p><br><p>  La figure ci-dessus montre cinq validateurs, dont trois sont sous le contr√¥le de l'attaquant.  Ils ont cr√©√© le bloc invalide A ', puis ont continu√© √† construire la cha√Æne sur le dessus.  Deux validateurs priv√©s ont imm√©diatement rejet√© le bloc A 'comme non valide et ont continu√© √† construire au-dessus du dernier bloc valide qu'ils connaissaient, cr√©ant ainsi une fourchette.  Puisqu'il y a moins de validateurs dans une cha√Æne honn√™te que dans une cha√Æne malhonn√™te, leur cha√Æne est plus courte.  Cependant, dans la blockchain classique non fragment√©e, tous les participants au syst√®me valident tous les blocs qu'ils voient.  Ainsi, tout participant utilisant la blockchain verra que A 'est invalide, la rejetera, et donc supprimera B', C 'et D' comme construit au-dessus du bloc invalide, et donc tous les participants verront AB comme une cha√Æne canonique. </p><br><p>  Dans une conception de fragment, aucun participant ne peut valider tous les blocs dans toutes les cha√Ænes de blocs.   - ,        ,                ,     - . </p><br><p>     ,        ,              .         ,   ,   (      ). </p><br><p>     ,       : </p><br><ol><li>  -           .    ,         2/3       .         ,         ,              ,   .           ,  ,     ,           -           ,   .     ,    . </li><li>  -  ,  ,    ,  ,     , .   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">zk-SNARKs</a> (   zk,  zero-knowledge,     ,       non-zk SNARKs).  ,  zk-SNARKs  ,          . </li></ol><br><p>  ,   ,   ,      ,          .     ‚Äî   . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'√©cris beaucoup sur la blockchain et le sharding en anglais. </font><font style="vertical-align: inherit;">Nous interrogeons √©galement p√©riodiquement les auteurs d'autres protocoles tels que Cosmos et Solana, approfondissant les d√©tails techniques. </font><font style="vertical-align: inherit;">Si vous √™tes int√©ress√© par le sujet, vous pouvez suivre les nouveaux messages et vid√©os en vous abonnant √† mon Twitter </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@AlexSkidanov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437924/">https://habr.com/ru/post/fr437924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437912/index.html">Un petit ordinateur portable pour un administrateur syst√®me</a></li>
<li><a href="../fr437914/index.html">Jaxb (XJC) g√©n√©rant des classes √† partir d'un sch√©ma XML (XSD) avec des descriptions de classe et de champ sous forme d'annotations. Plugin XJC</a></li>
<li><a href="../fr437916/index.html">Donnez le lecteur de livre √©lectronique dans chaque poche! Retour sur les derni√®res innovations d'ONYX BOOX</a></li>
<li><a href="../fr437918/index.html">Enregistrement vid√©o avec √©jection automatique de pause par logiciel gratuit avec construction de v√©los</a></li>
<li><a href="../fr437922/index.html">Mod√®le d'attaque: o√π il est principalement utilis√© abusivement dans les achats √©lectroniques et comment y faire face</a></li>
<li><a href="../fr437926/index.html">Le guide faisant autorit√© pour le partage de blockchain</a></li>
<li><a href="../fr437928/index.html">Comment apprendre l'anglais</a></li>
<li><a href="../fr437930/index.html">Combo luminaire</a></li>
<li><a href="../fr437932/index.html">Intel Optane Memory H10: Cache Optane + QLC 3D NAND</a></li>
<li><a href="../fr437934/index.html">La gestion du temps dans la vraie vie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>