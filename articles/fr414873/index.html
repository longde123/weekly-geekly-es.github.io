<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üà¥ üç¥ üïØÔ∏è IDisposable - que votre maman n'a pas parl√© de lib√©rer des ressources. Partie 1 ‚ô£Ô∏è üë®‚Äçüë®‚Äçüëß‚Äçüë¶ üßöüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ceci est une traduction de la premi√®re partie de l'article. L'article a √©t√© √©crit en 2008. Apr√®s 10 ans, presque perdu sa pertinence. 
 Lib√©ration d√©t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IDisposable - que votre maman n'a pas parl√© de lib√©rer des ressources. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414873/"><p>  Ceci est une traduction de la premi√®re partie de l'article.  L'article a √©t√© √©crit en 2008.  Apr√®s 10 ans, presque perdu sa pertinence. </p><br><h2 id="determinirovannoe-osvobozhdenie-resursov---neobhodimost">  Lib√©ration d√©terministe des ressources - Un besoin </h2><br><p>  Au cours de plus de 20 ans d'exp√©rience en codage, j'ai parfois d√©velopp√© mes propres langages pour r√©soudre des probl√®mes.  Ils allaient de langages simples et imp√©ratifs √† des expressions r√©guli√®res sp√©cialis√©es pour les arbres.  Lors de la cr√©ation de langues, il existe de nombreuses recommandations et certaines r√®gles simples ne doivent pas √™tre viol√©es.  L'un d'eux: </p><br><blockquote>  Ne cr√©ez jamais un langage d'exception dans lequel il n'y a pas de lib√©ration d√©terministe des ressources. </blockquote><p>  Devinez quelles recommandations le runtime .NET ne suit pas, et par cons√©quent, toutes les langues bas√©es sur lui? </p><a name="habracut"></a><br><p> La raison pour laquelle cette r√®gle existe est que la <strong>lib√©ration d√©terministe des ressources est n√©cessaire pour cr√©er des programmes pris en charge</strong> .  La lib√©ration d√©termin√©e des ressources fournit un certain point auquel le programmeur est s√ªr que la ressource est lib√©r√©e.  Il existe deux fa√ßons d'√©crire des programmes fiables: l'approche traditionnelle consiste √† lib√©rer les ressources le plus t√¥t possible et l'approche moderne consiste √† lib√©rer les ressources pour une dur√©e ind√©termin√©e.  L'avantage de l'approche moderne est que le programmeur n'a pas besoin de lib√©rer explicitement des ressources.  L'inconv√©nient est qu'il est beaucoup plus difficile d'√©crire une application fiable, il y a beaucoup d'erreurs subtiles.  Malheureusement, le runtime .NET a √©t√© cr√©√© en utilisant une approche moderne. </p><br><p> .NET prend en charge la lib√©ration non d√©terministe des ressources √† l'aide de la m√©thode <code>Finalize</code> , qui a une signification particuli√®re.  Pour la lib√©ration d√©terministe des ressources, Microsoft a √©galement ajout√© l'interface <code>IDisposable</code> (et d'autres classes, dont nous discuterons plus tard).  N√©anmoins, pour l'ex√©cution, <code>IDisposable</code> est une interface normale, comme tout le monde.  Ce statut de "second ordre" cr√©e certaines difficult√©s. </p><br><p>  En C #, la "lib√©ration d√©terministe pour les pauvres" peut √™tre impl√©ment√©e en utilisant les <code>try</code> et <code>finally</code> ou en <code>using</code> (ce qui est presque la m√™me chose).  Microsoft discute depuis longtemps de la n√©cessit√© ou non de compter les liens, et il me semble que la mauvaise d√©cision a √©t√© prise.  Par cons√©quent, pour une lib√©ration d√©terministe des ressources, vous devez utiliser les constructions maladroites <code>finally</code> \ <code>using</code> ou un appel direct √† <code>IDisposable.Dispose</code> , qui est lourd d'erreurs.  Pour un programmeur C ++ habitu√© √† utiliser <code>shared_ptr&lt;T&gt;</code> deux options ne sont pas attrayantes.  (La derni√®re phrase indique clairement o√π l'auteur a une telle relation - <em>env.</em> </p><br><h2 id="idisposable">  IDisposable </h2><br><p>  <code>IDisposable</code> est une solution de lib√©ration d√©terministe des ressources offerte par Misoftro.  L'un concerne les cas suivants: </p><br><ul><li>  Tout type <em>poss√©dant des</em> ressources g√©r√©es ( <code>IDisposable</code> ).  Un type doit n√©cessairement <strong>poss√©der</strong> , c'est-√†-dire g√©rer le temps de vie, les ressources, et pas seulement s'y r√©f√©rer. </li><li>  Tout type poss√©dant des ressources non g√©r√©es. </li><li>  Tout type poss√©dant √† la fois des ressources g√©r√©es et non g√©r√©es. </li><li>  Tout type h√©rit√© d'une classe qui impl√©mente <code>IDisposable</code> .  Je ne recommande pas d'h√©riter des classes qui poss√®dent des ressources non manag√©es.  Mieux vaut utiliser une pi√®ce jointe. </li></ul><br><p>  <code>IDisposable</code> aide √† lib√©rer des ressources de fa√ßon d√©terministe, mais a ses propres probl√®mes. </p><br><h2 id="slozhnosti-idisposable---udobstvo-ispolzovaniya">  Difficult√©s IDisposable - Facilit√© d'utilisation </h2><br><p>  <code>IDisposable</code> objets <code>IDisposable</code> sont <code>IDisposable</code> utiliser assez encombrants.  L'utilisation d'un objet doit √™tre encapsul√©e dans une construction <code>using</code> .  La mauvaise nouvelle est que C # ne permet pas d'utiliser <code>using</code> avec un type qui <code>IDisposable</code> pas <code>IDisposable</code> .  Par cons√©quent, le programmeur doit se r√©f√©rer √† la documentation √† chaque fois pour comprendre s'il est n√©cessaire d'√©crire en <code>using</code> , ou simplement d'√©crire en <code>using</code> partout, puis d'effacer o√π le compilateur jure. </p><br><p>  Le C ++ manag√© est bien meilleur √† cet √©gard.  Il prend en charge la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√©mantique de pile pour les types de r√©f√©rence</a> , qui fonctionne comme <code>using</code> que les types lorsque cela est n√©cessaire.  C # pourrait b√©n√©ficier de la possibilit√© d'√©crire en <code>using</code> n'importe quel type. </p><br><p>  Ce probl√®me peut √™tre r√©solu avec.  outils d'analyse de code.  Pour aggraver les choses, si vous oubliez d'utiliser, le programme peut passer les tests, mais planter en travaillant "dans les champs". </p><br><p>  Au lieu de compter les liens, <code>IDisposable</code> a un autre probl√®me - d√©terminer le propri√©taire.  Quand en C ++ la derni√®re copie de <code>shared_ptr&lt;T&gt;</code> sort du domaine d'application, les ressources sont lib√©r√©es imm√©diatement, pas besoin de penser √† qui doit √™tre lib√©r√©.  <code>IDisposable</code> au contraire, oblige le programmeur √† d√©terminer qui "poss√®de" l'objet et qui est responsable de sa lib√©ration.  Parfois, la propri√©t√© est √©vidente: lorsqu'un objet en encapsule un autre et impl√©mente lui-m√™me <code>IDisposable</code> , il est donc responsable de la lib√©ration des objets enfants.  Parfois, la dur√©e de vie d'un objet est d√©termin√©e par un bloc de code, et le programmeur utilise simplement l'utilisation autour de ce bloc.  N√©anmoins, il existe de nombreux cas o√π un objet peut √™tre utilis√© √† plusieurs endroits et sa dur√©e de vie est difficile √† d√©terminer (bien que dans ce cas, le d√©compte de r√©f√©rence ferait tr√®s bien l'affaire). </p><br><h2 id="slozhnosti-idisposable---obratnaya-sovmestimost">  Difficult√©s IDisposable - Compatibilit√© descendante </h2><br><p>  L'ajout d' <code>IDisposable</code> √† la classe et la suppression d' <code>IDisposable</code> de la liste des interfaces impl√©ment√©es est un changement de rupture.  Le code client qui n'attend pas <code>IDisposable</code> ne lib√©rera pas de ressources si vous ajoutez <code>IDisposable</code> √† l'une de vos classes transmises par r√©f√©rence √† une interface ou une classe de base. </p><br><p>  Microsoft lui-m√™me a rencontr√© ce probl√®me.  <code>IEnumerator</code> pas h√©rit√© d' <code>IDisposable</code> et <code>IEnumerator&lt;T&gt;</code> h√©rit√©.  Si vous passez <code>IEnumerator&lt;T&gt;</code> code qui re√ßoit <code>IEnumerator</code> , <code>Dispose</code> ne sera pas appel√©. </p><br><p>  Ce n'est pas la fin du monde, mais cela donne une essence secondaire d' <code>IDisposable</code> . </p><br><h2 id="slozhnosti-idisposable---proektirovanie-ierarhii-klassov">  Difficult√©s IDisposable - Conception d'une hi√©rarchie de classes </h2><br><p>  Le plus gros inconv√©nient caus√© par <code>IDisposable</code> dans le domaine de la conception de hi√©rarchie est que chaque classe et interface doit pr√©dire si <code>IDisposable</code> sera n√©cessaire √† ses descendants. </p><br><p>  Si l'interface n'h√©rite pas d' <code>IDisposable</code> , mais que les classes impl√©mentant l'interface impl√©mentent √©galement <code>IDisposable</code> , le code final ignorera la version d√©terministe ou devra v√©rifier si l'objet impl√©mente l'interface <code>IDisposable</code> .  Mais pour cela, il ne sera pas possible d'utiliser la construction using et vous devrez √©crire un <code>try</code> laid et <code>finally</code> . </p><br><p>  Bref, <code>IDisposable</code> complique le d√©veloppement de logiciels r√©utilisables.  La raison principale est la violation de l'un des principes de la conception orient√©e objet - s√©paration de l'interface et de la mise en ≈ìuvre.  La lib√©ration des ressources devrait √™tre un d√©tail de mise en ≈ìuvre.  Microsoft a d√©cid√© de faire de la lib√©ration d√©terministe des ressources une interface de deuxi√®me classe. </p><br><p>  L'une des solutions les moins belles est de faire en sorte que toutes les classes impl√©mentent <code>IDisposable</code> , mais dans la grande majorit√© des classes, <code>IDisposable.Dispose</code> ne fera rien.  Mais ce n'est pas trop beau. </p><br><p>  Une autre difficult√© avec <code>IDisposable</code> est les collections.  Certaines collections y ¬´poss√®dent¬ª des objets, d'autres non.  Cependant, les collections elles-m√™mes <code>IDisposable</code> pas <code>IDisposable</code> .  Le programmeur doit se rappeler d'appeler <code>IDisposable.Dispose</code> sur les objets de la collection ou de cr√©er ses propres descendants de classes de collection qui impl√©mentent <code>IDisposable</code> pour signifier la propri√©t√©. </p><br><h2 id="slozhnosti-idisposable---dopolnitelnoe-oshibochnoe-sostoyanie">  Difficult√©s IDisposable - √©tat "erron√©" suppl√©mentaire </h2><br><p>  <code>IDisposable</code> peut √™tre appel√© explicitement √† tout moment, quelle que soit la dur√©e de vie de l'objet.  Autrement dit, un √©tat ¬´lib√©r√©¬ª est ajout√© √† chaque objet, dans lequel il est recommand√© de <code>ObjectDisposedException</code> une <code>ObjectDisposedException</code> .  V√©rifier l'√©tat et lever les exceptions est une d√©pense suppl√©mentaire. </p><br><p>  Au lieu de v√©rifier chaque √©ternuement, il est pr√©f√©rable d'envisager d'acc√©der √† l'objet √† l'√©tat ¬´lib√©r√©¬ª comme un ¬´comportement non d√©fini¬ª comme un appel √† la m√©moire lib√©r√©e. </p><br><h2 id="slozhnosti-idisposable---net-garantiy">  Difficult√©s IDisposable - aucune garantie </h2><br><p>  <code>IDisposable</code> n'est qu'une interface.  Une classe qui impl√©mente <code>IDisposable</code> <strong>prend en charge la</strong> version d√©terministe, mais ne la <strong>garantit</strong> pas.  Pour le code client, il est pr√©f√©rable de ne pas appeler <code>Dispose</code> .  Par cons√©quent, une classe qui impl√©mente <code>IDisposable</code> doit prendre en charge la version d√©terministe et non d√©terministe. </p><br><h2 id="slozhnosti-idisposable---slozhnaya-realizaciya">  Complexit√©s IDisposable - Complex Implementation </h2><br><p>  Microsoft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">propose un mod√®le</a> pour impl√©menter <code>IDisposable</code> .  (Auparavant, il y avait un sch√©ma g√©n√©ralement terrible, mais relativement r√©cemment, apr√®s l'apparition de .NET 4, la documentation a √©t√© corrig√©e, y compris sous l'influence de cet article. Dans les anciennes √©ditions de livres .NET, vous pouvez trouver l'ancienne version. - <em>environ.</em> ) </p><br><ul><li>  <code>IDisposable.Dispose</code> ne peut pas √™tre appel√© du tout, donc la classe doit inclure un finaliseur pour lib√©rer des ressources. </li><li>  <code>IDisposable.Dispose</code> peut √™tre appel√© plusieurs fois et devrait fonctionner sans effets secondaires visibles.  Par cons√©quent, il est n√©cessaire d'ajouter une v√©rification si la m√©thode a d√©j√† √©t√© appel√©e ou non. </li><li>  Les finaliseurs sont appel√©s dans un thread s√©par√© et peuvent √™tre appel√©s avant la <code>IDisposable.Dispose</code> .  L'utilisation de <code>GC.SuppressFinalize</code> pour √©viter de telles "races". </li></ul><br><p>  De plus: </p><br><ul><li>  Les finaliseurs sont appel√©s, y compris pour les objets qui l√®vent une exception dans le constructeur.  Par cons√©quent, le code de version doit fonctionner avec des objets partiellement initialis√©s. </li><li>  L'impl√©mentation d'un <code>IDisposable</code> dans une classe h√©rit√©e de <code>CriticalFinalizerObject</code> n√©cessite des constructions non triviales.  <code>void Dispose(bool disposing)</code> est une m√©thode virale et doit √™tre ex√©cut√©e dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©gion d'ex√©cution contrainte</a> , ce qui n√©cessite un appel √† <code>RuntimeHelpers.PrepareMethod</code> . </li></ul><br><h2 id="slozhnosti-idisposable---ne-podhodit-dlya-logiki-zaversheniya">  Difficult√©s IDisposable - Ne convient pas pour la logique d'ach√®vement </h2><br><p>  Arr√™ter un objet - se produit souvent dans des programmes en threads parall√®les ou asynchrones.  Par exemple, une classe utilise un thread distinct et souhaite le terminer √† l'aide de <code>ManualResetEvent</code> .  Cela peut √™tre fait dans <code>IDisposable.Dispose</code> , mais cela peut entra√Æner une erreur si le code est appel√© dans le finaliseur. </p><br><p>  Pour comprendre les limitations du finaliseur, vous devez comprendre le fonctionnement du garbage collector.  Vous trouverez ci-dessous un diagramme simplifi√© dans lequel de nombreux d√©tails li√©s aux g√©n√©rations, aux maillons faibles, √† la renaissance des objets, au ramasse-miettes, etc. sont omis. </p><br><p>  Le garbage collector .NET utilise l'algorithme de marquage et de balayage.  En g√©n√©ral, la logique ressemble √† ceci: </p><br><ol><li>  Mettez en pause tous les threads. </li><li>  Prenez tous les objets racine: variables sur la pile, champs statiques, objets <code>GCHandle</code> , file d'attente de finalisation.  Dans le cas du d√©chargement du domaine d'application (arr√™t du programme), on consid√®re que les variables dans la pile et les champs statiques ne sont pas des racines. </li><li>  Parcourez r√©cursivement tous les liens des objets et marquez-les comme ¬´accessibles¬ª. </li><li>  Parcourez tous les autres objets qui ont des destructeurs (finaliseurs), d√©clarez-les accessibles et placez-les dans la file d'attente de finalisation ( <code>GC.SuppressFinalize</code> indique au GC de ne pas le faire).  Les objets sont mis en file d'attente dans un ordre impr√©visible. </li></ol><br><p>  En arri√®re plan, un flux (ou plusieurs) de finalisation fonctionne: </p><br><ol><li>  Prend un objet de la file d'attente et d√©marre son finaliseur.  Il est possible d'ex√©cuter plusieurs finaliseurs d'objets diff√©rents en m√™me temps. </li><li>  L'objet est supprim√© de la file d'attente et si personne d'autre n'y fait r√©f√©rence, il sera effac√© lors de la prochaine r√©cup√©ration de place. </li></ol><br><p>  Maintenant, il devrait √™tre clair pourquoi il est impossible d'acc√©der aux ressources g√©r√©es depuis le finaliseur - vous ne savez pas dans quel ordre les finaliseurs sont appel√©s.  M√™me appeler <code>IDisposable.Dispose</code> un autre objet √† partir du finaliseur peut entra√Æner une erreur, car le code de lib√©ration des ressources peut fonctionner dans un autre thread. </p><br><p>  Il existe quelques exceptions lorsque vous pouvez acc√©der aux ressources g√©r√©es √† partir d'un finaliseur: </p><br><ol><li>  La finalisation des objets h√©rit√©s de <code>CriticalFinalizerObject</code> est effectu√©e <strong>apr√®s la</strong> finalisation des objets non h√©rit√©s de cette classe.  Cela signifie que vous pouvez appeler <code>ManualResetEvent</code> depuis le finaliseur jusqu'√† ce que la classe soit h√©rit√©e de <code>CriticalFinalizerObject</code> </li><li>  Certains objets et m√©thodes sont sp√©ciaux, comme la console et certaines m√©thodes de thread.  Ils peuvent √™tre appel√©s depuis les finaliseurs m√™me si le programme se termine. </li></ol><br><p>  Dans le cas g√©n√©ral, il est pr√©f√©rable de ne pas acc√©der aux ressources g√©r√©es depuis les finaliseurs.  N√©anmoins, la logique de compl√©tion est n√©cessaire pour les logiciels non triviaux.  Sur <code>Windows.Forms</code> contient la logique de compl√©tion dans la m√©thode <code>Application.Exit</code> .  Lorsque vous d√©veloppez votre biblioth√®que de composants, la meilleure chose √† faire est de compl√©ter la logique de compl√©tion avec <code>IDisposable</code> .  Terminaison normale en cas d'appel d' <code>IDisposable.Dispose</code> et urgence sinon. </p><br><p>  Microsoft a √©galement rencontr√© ce probl√®me.  La classe <code>StreamWriter</code> poss√®de un objet <code>Stream</code> (en fonction des param√®tres du constructeur dans la derni√®re version - <em>environ Per.</em> ).  <code>StreamWriter.Close</code> vide le tampon et appelle <code>Stream.Close</code> (se produit √©galement s'il est <code>Stream.Close</code> en <code>using</code> - <em>environ Per.</em> ).  Si <code>StreamWriter</code> pas ferm√©, le tampon n'est pas vid√© et la conversation de donn√©es est perdue.  Microsoft n'a tout simplement pas red√©fini le finaliseur, ¬´r√©solvant¬ª ainsi le probl√®me d'ach√®vement.  Un excellent exemple de la n√©cessit√© d'une logique d'ach√®vement. </p><br><h2 id="rekomenduyu-pochitat">  Je recommande la lecture </h2><br><p>  De nombreuses informations sur les composants internes .NET dans cet article proviennent du CLR de Jeffrey Richter via C #.  Si vous ne l'avez pas encore, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">achetez-le</a> .  S√©rieusement.  C'est la connaissance n√©cessaire pour tout programmeur C #. </p><br><h2 id="zaklyuchenie-ot-perevodchika">  Conclusion du traducteur </h2><br><p>  La plupart des programmeurs .NET ne rencontreront jamais les probl√®mes d√©crits dans cet article.  .NET √©voluera pour augmenter le niveau d'abstraction et r√©duire le besoin de "jongler" avec les ressources non g√©r√©es.  N√©anmoins, cet article est utile en ce qu'il d√©crit les d√©tails profonds de choses simples et leur impact sur la conception du code. </p><br><p>  La prochaine partie sera une discussion d√©taill√©e sur la fa√ßon de travailler avec des ressources g√©r√©es et non g√©r√©es dans .NET avec un tas d'exemples. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414873/">https://habr.com/ru/post/fr414873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414861/index.html">Mod√©lisation de tunnel - Version 1.0</a></li>
<li><a href="../fr414865/index.html">iMaterialist Furniture Challenge ou 50 nuances de chaises</a></li>
<li><a href="../fr414867/index.html">ThinkingHome.Migrator - migration versionn√©e du sch√©ma de base de donn√©es sur la plate-forme .NET Core</a></li>
<li><a href="../fr414869/index.html">Cadres en voie de disparition</a></li>
<li><a href="../fr414871/index.html">La temp√™te de poussi√®re sur Mars a atteint l'√©chelle plan√©taire, m√™me la curiosit√© est affect√©e</a></li>
<li><a href="../fr414875/index.html">L'int√©gration Kubernetes Container remplace Docker pr√™t pour la production</a></li>
<li><a href="../fr414877/index.html">Un objectif inhabituel pour un appareil photo ordinaire ou comment arr√™ter de penser √† la mise au point</a></li>
<li><a href="../fr414879/index.html">Pourquoi 2 extrudeuses dans une imprimante 3D?</a></li>
<li><a href="../fr414881/index.html">Un peu de VK dans les coulisses</a></li>
<li><a href="../fr414883/index.html">Les souvenirs r√©sonnaient d'une mani√®re nouvelle: la BBC a mis √† jour les archives sonores du projet RemArc</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>