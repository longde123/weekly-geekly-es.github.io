<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕝 👇🏻 🛀🏼 Panduan Kubernetes, Bagian 2: Membuat dan Bekerja dengan Cluster 👨🏾‍💼 🤜🏿 🕴️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terakhir kali, kami memeriksa dua pendekatan untuk bekerja dengan layanan microser. Secara khusus, salah satunya melibatkan penggunaan wadah Docker, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan Kubernetes, Bagian 2: Membuat dan Bekerja dengan Cluster</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/438984/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terakhir</a> kali, kami memeriksa dua pendekatan untuk bekerja dengan layanan microser.  Secara khusus, salah satunya melibatkan penggunaan wadah Docker, di mana Anda dapat mengeksekusi kode layanan microservice dan tambahan.  Hari ini, menggunakan gambar kontainer kami yang ada, kami akan bekerja dengan Kubernetes. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/13/lv/dr/13lvdrwhhap-ouchegvweul0fg0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Memperkenalkan Kubernet</font> </h2><br>  Saya berjanji, dan saya tidak membesar-besarkan sama sekali bahwa ketika Anda membaca artikel ini, tanyakan pada diri sendiri: "Mengapa Kubernet tidak disebut Supernetes?" <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d76/9f9/e76/d769f9e7670a725759dd7415949177a0.png"></div><br>  <i><font color="#999999">Supernetes</font></i> <br><br>  Jika Anda membaca bagian sebelumnya dari materi ini, maka Anda tahu bahwa di sana kami melihat banyak hal yang berkaitan dengan mempersiapkan aplikasi untuk kontainerisasi dan bekerja dengan wadah Docker.  Tampaknya bagi Anda bahwa hal yang paling sulit menanti Anda sekarang, tetapi, pada kenyataannya, apa yang akan kita bicarakan di sini jauh lebih sederhana daripada apa yang sudah kita ketahui.  Satu-satunya alasan mengapa mempelajari Kubernetes mungkin tampak seperti tugas yang menakutkan bagi seseorang adalah jumlah informasi tambahan yang Anda butuhkan untuk memahami Kubernetes dan menggunakannya secara efektif.  Kami telah membahas semua "informasi tambahan" yang diperlukan untuk keberhasilan pengembangan Kubernetes. <br><br><h3>  <font color="#3AC1EF">▍Apa itu Kubernet?</font> </h3><br>  Di bagian pertama artikel ini, setelah meluncurkan layanan microser dalam wadah, Anda diminta untuk memikirkan masalah penskalaan aplikasi yang dikemas dalam wadah. <br>  Saya sarankan merenungkannya bersama-sama, dalam format pertanyaan dan jawaban: <br><br>  <b>Pertanyaan:</b> Bagaimana skala aplikasi kemas? <br>  <b>Jawab:</b> Luncurkan wadah tambahan. <br><br>  <b>Pertanyaan:</b> Dan bagaimana beban didistribusikan di antara mereka?  Bagaimana jika server tertentu sudah digunakan secara maksimal, dan kontainer perlu digunakan di server lain?  Bagaimana menemukan cara paling efisien untuk menggunakan perangkat keras? <br>  <b>Jawab:</b> Jadi ... Saya akan melihat di Internet ... <br><br>  <b>Pertanyaan:</b> Bagaimana cara memperbarui program tanpa mengganggu sistem?  Dan, jika pembaruan mengandung kesalahan, bagaimana cara kembali ke versi aplikasi yang berfungsi? <br><br>  Bahkan, itu adalah teknologi Kubernetes yang memberikan jawaban yang layak untuk ini dan banyak pertanyaan lainnya.  Saya akan mencoba mempersempit definisi Kubernetes menjadi satu kalimat: "Kubernetes adalah sistem manajemen wadah yang mengabstraksi infrastruktur yang mendasarinya (lingkungan di mana wadah beroperasi)." <br><br>  Saya percaya bahwa sekarang Anda tidak terlalu jelas tentang konsep "manajemen kontainer", meskipun kami telah menyebutkan ini.  Di bawah ini kami akan mempertimbangkan teknologi ini dalam praktiknya.  Namun, konsep "abstrak infrastruktur dasar" pertama kali ditemukan.  Karena itu, sekarang kita akan mempertimbangkannya. <br><br><h3>  <font color="#3AC1EF">▍Perbaikan infrastruktur dasar</font> </h3><br>  Kubernet memungkinkan aplikasi untuk abstrak dari infrastruktur, memberi kami API sederhana yang dapat Anda kirim permintaan.  Kubernetes mencoba memenuhi permintaan ini menggunakan semua kemampuannya.  Misalnya, dalam bahasa reguler, permintaan serupa dapat dijelaskan sebagai berikut: "Kubernetes, perluas 4 wadah gambar X".  Setelah menerima perintah, Kubernetes akan menemukan node yang tidak terlalu sibuk (mereka juga disebut "node" - dari bahasa Inggris "node"), di mana Anda dapat menggunakan kontainer baru. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/735/b88/a2a/735b88a2a717e9c01bfc197f3c1b20fd.png"></div><br>  <i><font color="#999999">Permintaan server API</font></i> <br><br>  Apa artinya ini bagi pengembang?  Ini berarti bahwa dia tidak perlu khawatir tentang jumlah node, tentang di mana tepatnya wadah diluncurkan, atau bagaimana mereka berinteraksi.  Dia tidak harus berurusan dengan optimasi perangkat keras atau khawatir tentang node yang mungkin tidak berfungsi (dan sesuatu yang serupa, menurut hukum Murphy, pasti akan terjadi), karena, jika perlu, node baru dapat ditambahkan ke cluster Kubernetes.  Jika ada sesuatu yang salah dengan beberapa node yang ada, Kubernetes akan menyebarkan kontainer ke node yang masih dalam keadaan sehat. <br><br>  Banyak dari apa yang ditunjukkan pada gambar sebelumnya sudah tidak asing lagi bagi Anda.  Tetapi ada juga sesuatu yang baru: <br><br><ul><li>  Server API  Melakukan panggilan ke server ini adalah satu-satunya cara untuk berinteraksi dengan cluster yang kita miliki, apakah kita berbicara tentang memulai atau menghentikan wadah, memeriksa status sistem, bekerja dengan log, atau melakukan tindakan lain. </li><li>  Kubelet.  Ini adalah agen yang memantau wadah di dalam simpul dan berinteraksi dengan simpul utama. </li></ul><br>  Harap dicatat bahwa dalam beberapa kalimat sebelumnya kami menggunakan istilah "wadah", tetapi di sini akan lebih tepat untuk menggunakan istilah "pod".  Entitas-entitas ini sering disebut "pod" dalam publikasi berbahasa Rusia, dan kadang-kadang - "pod", dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> , mengklarifikasi konsep "pod", mereka berbicara tentang "kawanan paus" (pod of whales) atau "pod kacang" tetapi tidak ada yang menyebutnya "kawanan" atau "buah".  Berbicara tentang mereka, kita akan menggunakan kata "di bawah".  Sekarang Anda dapat mempertimbangkannya sebagai wadah, kami akan berbicara lebih banyak tentang polong di bawah ini. <br><br>  Kita akan berhenti pada ini untuk saat ini, karena kita dapat membicarakan semua ini lebih lanjut, dan, di samping itu, ada banyak materi bagus mengenai teori Kubernet.  Misalnya, ini adalah dokumentasi resmi, meskipun tidak mudah dibaca, atau buku seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> . <br><br><h3>  <font color="#3AC1EF">▍ Standarisasi pekerjaan dengan penyedia layanan cloud</font> </h3><br>  Kekuatan lain Kubernetes terletak pada kenyataan bahwa teknologi ini berkontribusi pada standardisasi kerja dengan penyedia layanan cloud (Cloud Service Provider, CSP).  Ini adalah pernyataan yang berani.  Perhatikan contoh berikut.  Seorang spesialis yang mengenal Azure atau Google Cloud Platform dengan baik harus mengerjakan proyek yang dirancang untuk lingkungan cloud yang benar-benar baru baginya, yang dengannya ia tidak terbiasa.  Dalam situasi ini, banyak yang bisa salah.  Misalnya, tenggat waktu untuk pengiriman proyek mungkin tertunda, perusahaan klien proyek mungkin perlu menyewa lebih banyak sumber daya cloud dari yang direncanakan, dan sebagainya. <br><br>  Saat menggunakan Kubernetes, masalah seperti itu tidak dapat muncul, karena, terlepas dari penyedia layanan cloud mana yang sedang kita bicarakan, bekerja dengan Kubernetes selalu terlihat sama.  Pengembang, dalam gaya deklaratif, memberi tahu server API apa yang ia butuhkan, dan Kubernetes bekerja dengan sumber daya sistem, yang memungkinkan pengembang mengabaikan detail implementasi sistem ini. <br><br>  Tetap bertahan sedikit pada gagasan ini, karena ini adalah peluang Kubernet yang sangat kuat.  Bagi perusahaan, ini berarti bahwa keputusan mereka tidak terikat dengan CSP tertentu.  Jika sebuah perusahaan menemukan penawaran yang lebih baik di pasar layanan cloud, ia dapat dengan bebas mengambil keuntungan dari penawaran ini dengan pindah ke penyedia baru.  Apalagi pengalaman yang diperoleh spesialis perusahaan tidak hilang di mana pun. <br><br>  Sekarang mari kita bicara tentang penggunaan praktis Kubernet <br><br><h2>  <font color="#3AC1EF">Praktik Kubernetes: Pod</font> </h2><br>  Kami mengkonfigurasi peluncuran layanan microser dalam wadah, proses pengaturannya cukup membosankan, tetapi kami berhasil mendapatkan sistem yang berfungsi.  Selain itu, seperti yang telah disebutkan, solusi kami tidak memiliki skala yang baik dan tidak tahan terhadap kegagalan.  Kami akan memecahkan masalah ini dengan Kubernetes.  Selanjutnya, kami akan membawa sistem kami ke formulir yang sesuai dengan skema berikut.  Yaitu, kontainer akan dikelola oleh Kubernetes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53d/19c/3ba/53d19c3bac2f8cdd66213c9b34e7b05b.png"></div><br>  <i><font color="#999999">Microservices bekerja di sebuah cluster yang dikelola oleh Kubernetes</font></i> <br><br>  Di sini, kita akan menggunakan Minikube untuk penyebaran lokal cluster dan untuk menguji kemampuan Kubernetes, meskipun semua yang akan kita lakukan di sini dapat dilakukan menggunakan platform cloud seperti Azure atau Google Cloud Platform. <br><br><h3>  <font color="#3AC1EF">▍Instalasi dan mulai Minikube</font> </h3><br>  Untuk menginstal Minikube, ikuti instruksi yang ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> .  Selama instalasi Minikube, Anda juga akan menginstal Kubectl.  Ini adalah klien yang memungkinkan permintaan untuk dibuat ke server API Kubernetes. <br><br>  Untuk memulai Minikube, jalankan perintah <code>minikube start</code> , dan setelah itu selesai, jalankan perintah <code>kubectl get nodes</code> .  Akibatnya, Anda akan melihat sesuatu seperti berikut: <br><br><pre> <code class="plaintext hljs">kubectl get nodes NAME       STATUS ROLES     AGE VERSION minikube   Ready &lt;none&gt;    11m v1.9.0</code> </pre> <br>  Minikube menempatkan kami pada sebuah cluster yang hanya terdiri dari satu simpul.  Benar, ini cocok untuk kita.  Mereka yang bekerja dengan Kubernetes tidak perlu khawatir tentang persis berapa banyak node dalam cluster, karena Kubernetes memungkinkan Anda untuk abstrak dari detail seperti itu. <br><br>  Sekarang mari kita bicara tentang polong. <br><br><h3>  <font color="#3AC1EF">▍Pods</font> </h3><br>  Saya sangat suka wadah, dan Anda mungkin juga menyukainya sekarang.  Mengapa Kubernetes menawarkan kami untuk menggunakan pod, entitas yang merupakan unit komputasi minimum yang dapat digunakan dalam sistem ini?  Apa fungsinya di bawah?  Faktanya adalah bahwa perapian dapat mencakup satu atau lebih kontainer yang berbagi runtime yang sama. <br><br>  Tetapi apakah perlu untuk melakukan, misalnya, dua wadah dalam satu perapian?  Bagaimana mengatakannya ... Biasanya hanya ada satu wadah per wadah, dan itulah yang akan kita lakukan.  Tetapi untuk kasus-kasus ketika, misalnya, dua kontainer memerlukan akses bersama ke gudang data yang sama, atau jika mereka terhubung menggunakan teknik komunikasi antarproses, atau jika mereka terhubung erat untuk beberapa alasan lain, semua ini dapat direalisasikan dengan menjalankannya dalam satu perapian.  Kemungkinan lain yang membedakan pod adalah mereka tidak harus menggunakan wadah Docker.  Jika perlu, di sini Anda dapat menerapkan teknologi lain untuk kontainerisasi aplikasi, misalnya - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rkt</a> . <br><br>  Diagram berikut menunjukkan properti perapian bernomor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f6/2a4/bb1/4f62a4bb18bddccc49a9d224a4aa919d.png"></div><br>  <i><font color="#999999">Properti Perapian</font></i> <br><br>  Pertimbangkan sifat-sifat ini. <br><br><ol><li>  Setiap pod di kluster Kubernetes memiliki alamat IP yang unik. </li><li>  Perapian dapat berisi banyak wadah.  Mereka berbagi nomor port yang tersedia, yaitu, misalnya, mereka dapat saling bertukar informasi melalui <code>localhost</code> (secara alami, mereka tidak dapat menggunakan port yang sama).  Interaksi dengan wadah yang terletak di pod lain diatur menggunakan alamat IP pod ini. </li><li>  Wadah dalam pod berbagi volume penyimpanan data, alamat IP, nomor port, ruang nama IPC. </li></ol><br>  Perlu dicatat bahwa kontainer memiliki sistem file tersendiri, tetapi mereka dapat berbagi data menggunakan sumber daya Kubernet yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Volume</a> . <br><br>  Bagi kami, apa yang telah dikatakan tentang perapian sudah cukup untuk terus menguasai Kubernet.  Baca lebih lanjut tentang mereka di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h3>  <font color="#3AC1EF">▍ Deskripsi perapian</font> </h3><br>  Berikut ini adalah file manifes untuk aplikasi <code>sa-frontend</code> . <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Pod                                            # 1 metadata: name: sa-frontend                                  # 2 spec:                                                # 3 containers:   - image: rinormaloku/sentiment-analysis-frontend # 4     name: sa-frontend                              # 5     ports:       - containerPort: 80</code> </pre> <br>  Mari kita jelaskan beberapa parameter yang ditentukan di dalamnya. <br><br><ol><li>  <code>Kind</code> : Menentukan jenis sumber daya Kubernet yang ingin kita buat.  Dalam kasus kami, ini adalah <code>Pod</code> . </li><li>  <code>Name</code> : nama sumber daya.  Kami menyebutnya <code>sa-frontend</code> . </li><li>  <code>Spec</code> : objek yang menggambarkan kondisi sumber daya yang diinginkan.  Properti paling penting di sini adalah susunan wadah. </li><li>  <code>Image</code> : gambar wadah yang ingin kami jalankan di pod ini. </li><li>  <code>Name</code> : nama unik untuk wadah di bawahnya. </li><li>  <code>ContainerPort</code> : port tempat wadah itu mendengarkan.  Parameter ini dapat dianggap sebagai indikasi bagi siapa yang membaca file ini (jika Anda mengabaikan parameter ini, ini tidak akan membatasi akses ke port). </li></ol><br><h3>  <font color="#3AC1EF">▍Membuat SA-Frontend perapian</font> </h3><br>  File deskripsi pod yang kita bicarakan dapat ditemukan di <code>resource-manifests/sa-frontend-pod.yaml</code> .  Anda harus pergi ke folder ini menggunakan alat terminal, atau, ketika Anda memanggil perintah yang sesuai, tentukan path lengkap ke file.  Ini adalah perintah ini dan contoh reaksi sistem terhadapnya: <br><br><pre> <code class="plaintext hljs">kubectl create -f sa-frontend-pod.yaml pod "sa-frontend" created</code> </pre> <br>  Untuk mengetahui apakah itu berfungsi di bawah, jalankan perintah berikut: <br><br><pre> <code class="plaintext hljs">kubectl get pods NAME                          READY STATUS RESTARTS AGE sa-frontend                   1/1 Running 0 7s</code> </pre> <br>  Jika status perapian selama eksekusi perintah ini adalah <code>ContainerCreating</code> , maka Anda dapat menjalankan perintah yang sama dengan <code>--watch</code> .  Karena itu, ketika perapian berada dalam status <code>Running</code> , informasi tentang ini akan ditampilkan secara otomatis. <br><br><h3>  <font color="#3AC1EF">▍Akses ke aplikasi dari luar</font> </h3><br>  Untuk mengatur akses ke aplikasi dari luar, akan benar untuk membuat sumber daya Kubernet dari jenis Layanan, yang akan kita bicarakan di bawah ini, tetapi di sini, untuk singkatnya, kami akan menggunakan port forwarding sederhana: <br><br><pre> <code class="plaintext hljs">kubectl port-forward sa-frontend 88:80 Forwarding from 127.0.0.1:88 -&gt; 80</code> </pre> <br>  Jika sekarang Anda pergi melalui browser di <code>127.0.0.1:88</code> , Anda dapat melihat halaman Bereaksi aplikasi. <br><br><h3>  <font color="#3AC1EF">▍ Pendekatan penskalaan yang salah</font> </h3><br>  Kami telah mengatakan bahwa salah satu kemampuan Kubernetes adalah penskalaan aplikasi.  Untuk mengalami kesempatan ini, kami akan menjalankan yang lain di bawah.  Buat deskripsi sumber daya <code>Pod</code> lainnya dengan menempatkan kode berikut di file <code>sa-frontend-pod2.yaml</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Pod                                           metadata: name: sa-frontend2      #   spec:                                                containers:   - image: rinormaloku/sentiment-analysis-frontend     name: sa-frontend                                  ports:       - containerPort: 80</code> </pre> <br>  Seperti yang Anda lihat, jika Anda membandingkan deskripsi ini dengan apa yang kami periksa di atas, satu-satunya perubahan di dalamnya adalah nilai properti <code>Name</code> . <br><br>  Buat yang baru di bawah: <br><br><pre> <code class="plaintext hljs">kubectl create -f sa-frontend-pod2.yaml pod "sa-frontend2" created</code> </pre> <br>  Pastikan itu berjalan: <br><br><pre> <code class="plaintext hljs">kubectl get pods NAME                          READY STATUS RESTARTS AGE sa-frontend                   1/1 Running 0 7s sa-frontend2                  1/1 Running 0 7s</code> </pre> <br>  Sekarang kami memiliki dua perapian!  Benar, tidak ada yang istimewa untuk dinikmati di sini.  Harap dicatat bahwa solusi untuk masalah penskalaan aplikasi yang ditampilkan di sini memiliki banyak kelemahan.  Kita akan berbicara tentang bagaimana melakukannya dengan benar di bagian sumber daya Kubernetes lain yang disebut Deployment. <br><br>  Sekarang pertimbangkan apa yang kita dapatkan setelah meluncurkan dua perapian identik.  Yaitu, server web Nginx sekarang berjalan di dua pod yang berbeda.  Dalam hal ini, kita dapat mengajukan dua pertanyaan: <br><br><ol><li>  Bagaimana cara memberikan akses ke server-server ini dari luar, dengan URL? </li><li>  Bagaimana cara mengatur keseimbangan beban di antara mereka? </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ff/3a9/6f4/1ff3a96f4b930fe55727d1063b3c117b.png"></div><br>  <i><font color="#999999">Pendekatan penskalaan salah</font></i> <br><br>  Di antara alat Kubernetes ada sumber daya dari layanan Formulir.  Mari kita bicarakan mereka. <br><br><h2>  <font color="#3AC1EF">Praktik Kubernetes: Layanan</font> </h2><br>  Layanan Kubernetes bertindak sebagai titik akses ke set perapian yang menyediakan fungsi yang sama dengan perapian ini.  Layanan melakukan solusi dari tugas-tugas sulit bekerja dengan perapian dan menyeimbangkan beban di antara mereka. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/95f/bd8/bbd95fbd8562bed4a09ab4930a20f98d.png"></div><br>  <i><font color="#999999">Layanan Kubernetes Melayani Alamat IP</font></i> <br><br>  Di kluster Kubernet kami akan ada pod yang mengimplementasikan fungsi yang berbeda.  Ini adalah aplikasi front-end, aplikasi web Spring, dan aplikasi Flask yang ditulis dengan Python.  Hal ini menimbulkan pertanyaan tentang bagaimana layanan perlu memahami pod mana yang perlu dikerjakan, yaitu, bagaimana mencari tahu berdasarkan informasi apa yang harus dihasilkan sistem dari daftar titik akhir untuk pod. <br><br>  Ini dilakukan dengan abstraksi Kubernetes lain yang disebut Label.  Bekerja dengan tag terdiri dari dua tahap: <br><br><ol><li>  Penugasan label akan memberikan layanan untuk bekerja dengan. </li><li>  Menerapkan "pemilih" ke layanan, yang menentukan pod mana yang diberi label, layanan akan bekerja. </li></ol><br>  Mungkin ini lebih mudah dibayangkan sebagai ilustrasi daripada menggambarkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb9/fcf/f0c/bb9fcff0cded591f1a5ab8a0b825245a.png"></div><br>  <i><font color="#999999">Pod berlabel dan file manifesnya</font></i> <br><br>  Kita lihat di sini dua perapian yang, menggunakan <code>app: sa-frontend</code> construct, diberi label yang sama.  Layanan ini tertarik pada polong dengan tanda tersebut. <br><br><h3>  <font color="#3AC1EF">Tag</font> </h3><br>  Label memberi pengembang cara sederhana untuk mengatur sumber daya Kubernetes.  Mereka adalah pasangan nilai kunci, Anda dapat menugaskan mereka ke sumber daya apa pun.  Ubah file deskripsi hearth aplikasi frontend dan bawa ke tampilan yang ditunjukkan pada gambar sebelumnya.  Setelah itu, simpan file-file ini dan jalankan perintah berikut: <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-frontend-pod.yaml Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply pod "sa-frontend" configured kubectl apply -f sa-frontend-pod2.yaml Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply pod "sa-frontend2" configured</code> </pre> <br>  Ketika perintah ini dieksekusi, sistem akan mengeluarkan peringatan (itu tidak sesuai dengan kami yang kami gunakan <code>apply</code> alih-alih <code>create</code> , kami memahami ini), tetapi, setelah peringatan, ia melaporkan bahwa pod yang sesuai dikonfigurasikan.  Kami dapat memeriksa apakah label diberi label, dengan memfilter log yang ingin kami tampilkan informasinya: <br><br><pre> <code class="plaintext hljs">kubectl get pod -l app=sa-frontend NAME           READY STATUS    RESTARTS AGE sa-frontend    1/1 Running   0 2h sa-frontend2   1/1 Running   0 2h</code> </pre> <br>  Cara lain untuk memverifikasi bahwa label memang telah diberi label adalah dengan melampirkan kunci <code>--show-labels</code> ke perintah sebelumnya.  Karena ini, informasi tentang pod mereka juga akan mencakup data pada tanda mereka. <br><br>  Sekarang tag telah ditetapkan dan kami siap mengonfigurasi layanan untuk bekerja dengannya.  Karenanya, kami akan membahas deskripsi layanan seperti <code>LoadBalancer</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/081/7e9/e0f0817e9fc090628aa1d0d89577ce80.gif"></div><br>  <i><font color="#999999">Load balancing menggunakan layanan seperti LoadBalancer</font></i> <br><br><h3>  <font color="#3AC1EF">▍ Deskripsi Layanan</font> </h3><br>  Berikut ini adalah deskripsi YAML dari layanan seperti <code>LoadBalancer</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service              # 1 metadata: name: sa-frontend-lb spec: type: LoadBalancer       # 2 ports: - port: 80               # 3   protocol: TCP          # 4   targetPort: 80         # 5 selector:                # 6   app: sa-frontend       # 7</code> </pre> <br>  Jelaskan teks ini: <br><br><ol><li>  <code>Kind</code> : kami membuat layanan, sumber daya <code>Service</code> . </li><li>  <code>Type</code> : jenis sumber daya yang ditunjukkan dalam spesifikasinya.  Kami memilih jenis <code>LoadBalancer</code> , karena dengan layanan ini kami ingin menyelesaikan masalah keseimbangan beban antara perapian. </li><li>  <code>Port</code> : port tempat layanan menerima permintaan. </li><li>  <code>Protocol</code> : Protokol yang digunakan oleh layanan. </li><li>  <code>TargetPort</code> : port tempat permintaan masuk dialihkan. </li><li>  <code>Selector</code> : objek yang berisi informasi tentang pod mana layanan harus bekerja. </li><li>  <code>app: sa-frontend</code> : properti ini menunjukkan dengan pod mana layanan akan bekerja.  Yaitu, ini adalah pod tempat <code>app: sa-frontend</code> label <code>app: sa-frontend</code> diberikan. </li></ol><br>  Untuk membuat layanan, Anda harus menjalankan perintah berikut: <br><br><pre> <code class="plaintext hljs">kubectl create -f service-sa-frontend-lb.yaml service "sa-frontend-lb" created</code> </pre> <br>  Anda dapat memeriksa status layanan sebagai berikut: <br><br><pre> <code class="plaintext hljs">kubectl get svc NAME             TYPE CLUSTER-IP      EXTERNAL-IP PORT(S) AGE sa-frontend-lb   LoadBalancer 10.101.244.40   &lt;pending&gt; 80:30708/TCP 7m</code> </pre> <br>  Di sini Anda dapat melihat bahwa properti <code>EXTERNAL-IP</code> berada dalam status <code>&lt;pending&gt;</code> , tetapi Anda tidak dapat menunggu untuk itu berubah.  Ini karena kami menggunakan Minikube.  Jika kami membuat layanan seperti itu saat bekerja dengan penyedia layanan cloud tertentu, seperti Azure atau Google Cloud Platform, maka layanan tersebut akan memiliki alamat IP publik yang memungkinkan untuk mengaksesnya dari Internet. <br><br>  Meskipun demikian, Minikube tidak akan mengizinkan kami untuk dipusingkan, memberi kami perintah yang berguna untuk debugging lokal sistem: <br><br><pre> <code class="plaintext hljs">minikube service sa-frontend-lb Opening kubernetes service default/sa-frontend-lb in default browser...</code> </pre> <br>  Berkat perintah ini, browser akan diluncurkan yang akan mengakses layanan.  Setelah layanan menerima permintaan, itu akan mengarahkannya kembali ke salah satu perapian (tidak masalah yang mana yang berada di bawahnya).  Abstraksi ini memungkinkan kita untuk melihat sekelompok perapian sebagai entitas tunggal dan bekerja dengannya, menggunakan layanan sebagai titik akses tunggal untuk mereka. <br><br>  Di bagian ini, kami berbicara tentang cara menetapkan label ke sumber daya, cara menggunakannya ketika mengkonfigurasi layanan sebagai penyeleksi.  Di sini kami menggambarkan dan menciptakan layanan seperti <code>LoadBalancer</code> .  Berkat ini, kami memecahkan masalah penskalaan aplikasi (penskalaan terdiri dari menambahkan perapian baru dengan label yang sesuai ke kluster) dan mengatur penyeimbangan beban antara perapian menggunakan layanan sebagai titik masuk. <br><br><h2>  <font color="#3AC1EF">Praktik Kubernetes: Penempatan</font> </h2><br>  Penempatan adalah abstraksi dari Kubernet yang memungkinkan kita untuk mengontrol apa yang selalu ada dalam siklus hidup aplikasi.  Ini tentang mengelola perubahan aplikasi.  Aplikasi yang tidak berubah adalah aplikasi yang "mati".  Jika aplikasi "hidup", maka Anda mungkin menemukan fakta bahwa persyaratannya berubah secara berkala, kodenya berkembang, kode ini dikemas dan digunakan.  Selain itu, kesalahan dapat dilakukan pada setiap langkah proses. <br><br>  Sumber daya dari tampilan Penerapan memungkinkan Anda untuk mengotomatiskan transisi dari satu versi aplikasi ke yang lain.  Ini dilakukan tanpa mengganggu sistem, dan jika terjadi kesalahan selama proses ini, kami akan memiliki kesempatan untuk dengan cepat kembali ke versi aplikasi yang berfungsi sebelumnya. <br><br><h3>  <font color="#3AC1EF">▍Gunakan penyebaran</font> </h3><br>  Sekarang cluster memiliki dua perapian dan layanan yang memberikan akses kepada mereka dari luar dan menyeimbangkan beban pada mereka. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/426/651/0c4/4266510c40a1faa6086178e5db23d20c.png"></div><br>  <i><font color="#999999">Cluster Status Saat Ini</font></i> <br><br>  Kami berbicara tentang fakta bahwa menjalankan dua perapian berbeda dengan fungsi yang sama bukanlah ide yang baik.  Saat menggunakan skema semacam itu, kita harus bekerja dengan masing-masing perapian secara terpisah, membuat, memperbarui, menghapus setiap perapian tertentu, mengamati keadaannya.  Dengan pendekatan ini, tidak perlu berbicara tentang pembaruan cepat sistem atau rollback cepat dari pembaruan yang gagal.  Kami tidak puas dengan keadaan ini, oleh karena itu kami akan menggunakan kemungkinan sumber daya Penempatan, yang ditujukan untuk menyelesaikan masalah di atas. <br><br>  Sebelum kita melanjutkan pekerjaan, mari kita merumuskan tujuannya, yang akan memberi kita panduan yang akan berguna ketika mem-parsing file manifes penyebaran.  Jadi inilah yang kami butuhkan: <br><br><ol><li>  Kami ingin dapat membuat dua perapian berdasarkan satu wadah <code>rinormaloku/sentiment-analysis-frontend</code> . </li><li>  Kami membutuhkan sistem penyebaran aplikasi yang memungkinkannya bekerja tanpa gangguan saat diperbarui. </li><li>  Kami ingin label <code>app: sa-frontend</code> ditugaskan <code>app: sa-frontend</code> , yang memungkinkan layanan <code>sa-frontend-lb</code> mendeteksi pod ini. </li></ol><br>  Kami sekarang akan menyatakan persyaratan ini sebagai deskripsi sumber daya Penempatan. <br><br><h3>  <font color="#3AC1EF">▍ Deskripsi Penerapan</font> </h3><br>  Berikut ini adalah deskripsi YAML dari sumber daya tipe Penempatan, yang dibuat dengan mempertimbangkan persyaratan sistem di atas: <br><br><pre> <code class="plaintext hljs">apiVersion: extensions/v1beta1 kind: Deployment                                          # 1 metadata: name: sa-frontend spec: replicas: 2                                             # 2 minReadySeconds: 15 strategy:   type: RollingUpdate                                   # 3   rollingUpdate:     maxUnavailable: 1                                   # 4     maxSurge: 1                                         # 5 template:                                               # 6   metadata:     labels:       app: sa-frontend                                  # 7   spec:     containers:       - image: rinormaloku/sentiment-analysis-frontend         imagePullPolicy: Always                         # 8         name: sa-frontend         ports:           - containerPort: 80</code> </pre> <br>  Mari kita analisis uraian ini: <br><br><ol><li>  <code>Kind</code> : dikatakan di sini bahwa kami sedang menggambarkan sumber daya dari tampilan <code>Deployment</code> . </li><li>  <code>Replicas</code> : Properti objek spesifikasi penempatan yang menentukan berapa banyak instance (replika) perapian yang akan dijalankan. </li><li>  <code>Type</code> : menjelaskan strategi yang digunakan dalam penyebaran ini ketika beralih dari versi saat ini ke yang baru.  Strategi <code>RollingUpdate</code> memberikan nol waktu henti sistem selama peningkatan. </li><li>  <code>MaxUnavailable</code> : ini adalah properti dari objek <code>RollingUpdate</code> , yang menetapkan jumlah maksimum perapian yang tidak tersedia (dibandingkan dengan jumlah perapian yang diinginkan) ketika melakukan pembaruan sistem berurutan.  Dalam penerapan kami, yang menyiratkan adanya 2 replika, nilai properti ini menunjukkan bahwa setelah penyelesaian satu pod, pod lain akan dieksekusi, yang membuat aplikasi tersedia selama pembaruan. </li><li>  <code>MaxSurge</code> : ini adalah properti dari objek <code>RollingUpdate</code> yang menggambarkan jumlah maksimum perapian yang dapat ditambahkan ke penyebaran (dibandingkan dengan jumlah perapian tertentu).  Dalam kasus kami, nilainya, 1, berarti bahwa, ketika beralih ke versi baru dari program, kita dapat menambahkan sub lain ke kluster, yang akan mengarah pada fakta bahwa hingga tiga perapian dapat diluncurkan secara bersamaan. </li><li>  <code>Template</code> : objek ini mendefinisikan templat perapian yang akan digunakan sumber daya <code>Deployment</code> dijelaskan untuk membuat perapian baru.  Anda mungkin akan menemukan pengaturan ini akrab. </li><li>  <code>app: sa-frontend</code> : label untuk perapian dibuat sesuai dengan pola yang diberikan. </li><li>  <code>ImagePullPolicy</code> : mendefinisikan urutan kerja dengan gambar.  Dalam kasus kami, properti ini diatur ke <code>Always</code> , yaitu, selama setiap penyebaran, gambar yang sesuai akan diunduh dari repositori. </li></ol><br>  Setelah memeriksa semua ini, mari kita lanjutkan ke latihan.  Jalankan penyebaran: <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-frontend-deployment.yaml deployment "sa-frontend" created</code> </pre> <br>  Periksa status sistem: <br><br><pre> <code class="plaintext hljs">kubectl get pods NAME                           READY STATUS RESTARTS AGE sa-frontend                    1/1 Running 0 2d sa-frontend-5d5987746c-ml6m4   1/1 Running 0 1m sa-frontend-5d5987746c-mzsgg   1/1 Running 0 1m sa-frontend2                   1/1 Running 0 2d</code> </pre> <br>  Seperti yang Anda lihat, sekarang kami memiliki 4 pod.  Dua di antaranya dibuat menggunakan sumber daya Penempatan, dua lagi adalah yang kami buat sendiri.  Sekarang Anda dapat menghapus pod-pod yang kami buat sendiri menggunakan perintah dari jenis berikut: <br><br><pre> <code class="plaintext hljs">kubectl delete pod &lt;pod-name&gt;</code> </pre> <br>  Ngomong-ngomong, inilah tugas untuk pekerjaan independen.  Hapus salah satu perapian yang dibuat menggunakan sumber daya Penempatan dan monitor sistem.  Pikirkan alasan apa yang terjadi sebelum membaca lebih lanjut. <br><br>  Saat menghapus satu perapian, sumber daya Penyebaran mengetahui bahwa kondisi sistem saat ini (1 sub) berbeda dari yang diinginkan (2 sub), jadi sub yang lain diluncurkan. <br><br>  Apa gunanya sumber daya Penerapan, selain fakta bahwa ketika digunakan, sistem dipertahankan dalam keadaan yang benar?  Pertimbangkan kekuatan sumber daya ini. <br><br><h3>  <font color="#3AC1EF">▍ Melakukan penyebaran dengan nol downtime sistem</font> </h3><br>  Misalkan manajer produk mendatangi kami dan melaporkan bahwa klien yang kami buat produk ini ingin tombol hijau di aplikasi klien.  Pengembang menerapkan persyaratan ini dan memberi kami satu-satunya yang kami butuhkan dari mereka - wadah gambar yang disebut <code>rinormaloku/sentiment-analysis-frontend:green</code> .  Sekarang tiba saatnya kita.  Kami, tim DevOps, perlu menggunakan sistem yang diperbarui dan memastikan tidak ada downtime.  Sekarang mari kita lihat apakah upaya untuk mengembangkan dan mengkonfigurasi sumber daya Penempatan dibenarkan. <br><br>  Edit file <code>sa-frontend-deployment.yaml</code> , ganti nama wadah gambar dengan yang baru, dengan <code>rinormaloku/sentiment-analysis-frontend:green</code> , lalu simpan file ini sebagai <code>sa-frontend-deployment-green.yaml</code> dan jalankan perintah berikut: <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-frontend-deployment-green.yaml --record deployment "sa-frontend" configured</code> </pre> <br>  Periksa status sistem dengan perintah berikut: <br><br><pre> <code class="plaintext hljs">kubectl rollout status deployment sa-frontend Waiting for rollout to finish: 1 old replicas are pending termination... Waiting for rollout to finish: 1 old replicas are pending termination... Waiting for rollout to finish: 1 old replicas are pending termination... Waiting for rollout to finish: 1 old replicas are pending termination... Waiting for rollout to finish: 1 old replicas are pending termination... Waiting for rollout to finish: 1 of 2 updated replicas are available... deployment "sa-frontend" successfully rolled out</code> </pre> <br>  Sesuai dengan data yang ditampilkan dalam menanggapi perintah ini, kita dapat menyimpulkan bahwa penyebaran pembaruan berhasil.  Selama peningkatan, replika lama, satu per satu, diganti dengan yang baru.  ,   ,    ,   .     ,    ,    . <br><br><h4>   </h4><br>      ,     ,     : <br><br><pre> <code class="plaintext hljs">minikube service sa-frontend-lb</code> </pre> <br>       ,      . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/777/489/902/777489902694f46438ceae41ce59db9b.png"></div><br> <i><font color="#999999"> </font></i> <br><br>  ,     ,  —    . <br><br><h4>      RollingUpdate </h4><br>  ,     <code>kubectl apply -f sa-frontend-deployment-green.yaml --record</code> , Kubernetes   ,     ,    .         ,       ,    <code>rinormaloku/sentiment-analysis-frontend:green</code> .       ,    ,   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/465/7ee/290/4657ee29097dc99e4fa2a0ebd9180e7a.png"></div><br> <i><font color="#999999">     </font></i> <br><br>  <code>RollingUpdate</code>       ,  ,     <code>maxUnavailable: 1</code>  <code>maxSurge: 1</code> .  ,   Deployment ,     ,    ,     .  ,    ,    ,         . <br><br>         Deployment.     ,   .      . <br><br><h3> <font color="#3AC1EF">▍    </font> </h3><br>   ,   ,   . «!  !    !», —  .        . ,   ,      : <br><br><pre> <code class="plaintext hljs">kubectl rollout history deployment sa-frontend deployments "sa-frontend" REVISION  CHANGE-CAUSE 1         &lt;none&gt;    2         kubectl.exe apply --filename=sa-frontend-deployment-green.yaml --record=true</code> </pre> <br>          : «,    ,    ?». <br><br> «.  ,   ?», —   . <br><br>  ,         ,     : <br><br><pre> <code class="plaintext hljs">kubectl rollout undo deployment sa-frontend --to-revision=1 deployment "sa-frontend" rolled back</code> </pre> <br>      .   ,      . <br><br>       . <br><br>       . <br><br> ! <br><br>   ,  .   Kubernetes         ,  ,      . ,   ! <br><br>           . ,       .  <code>CHANGE-CAUSE</code>      <code>&lt;none&gt;</code> ,    — <code>kubectl.exe apply –filename=sa-frontend-deployment-green.yaml –record=true</code> ? <br><br>   ,         -- <code>record</code>     ,    . <br><br>       ,   ,  ,      . <br><br><h2> <font color="#3AC1EF">   Kubernetes:    </font> </h2><br>      Kubernetes,    ,     .      ,     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7cb/af4/880/7cbaf4880d435df50761d22508f61e83.png"></div><br> <i><font color="#999999">  </font></i> <br><br>       . <br><br><h3> <font color="#3AC1EF">▍  sa-logic</font> </h3><br>        <code>resource-manifests</code>    : <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-logic-deployment.yaml --record deployment "sa-logic" created</code> </pre> <br>  <code>sa-logic</code>   .     Python-.    <code>app: sa-logic</code> .          <code>sa-logic</code> ,   .   <code>sa-logic-deployment.yaml</code>     . <br><br>  -,        ,      —  <code>sa-logic</code> . <br><br><h3> <font color="#3AC1EF">▍ sa-logic</font> </h3><br>   ,       Service.   ,   Java-,        <code>sa-webapp</code> ,      ,  Python-.  ,    ,       ,     Python-,   .     ,  ,  ,  . <br><br>      , ,    ,       ,   .  ,      <code>sa-logic</code>   ,       <code>sa-logic</code> . <br><br>   : <br><br><pre> <code class="plaintext hljs">kubectl apply -f service-sa-logic.yaml service "sa-logic" created</code> </pre> <br>    ,        . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/693/79b/3e3/69379b3e373ad1bc728242db341411ab.png"></div><br> <i><font color="#999999">  </font></i> <br><br>   <code>sa-logic</code> ,   <code>sa-webapp</code> ,    ,    . <br><br>   <code>sa-webapp</code> . <br><br><h3> <font color="#3AC1EF">▍  sa-webapp</font> </h3><br>      ,          Deployment    - . ,     <code>sa-web-app-deployment.yaml</code> ,      : <br><br><pre> <code class="plaintext hljs">- image: rinormaloku/sentiment-analysis-web-app imagePullPolicy: Always name: sa-web-app env:   - name: SA_LOGIC_API_URL     value: "http://sa-logic" ports:   - containerPort: 8080</code> </pre> <br>     <code>env</code> ?  ,   ,  ,   <code>SA_LOGIC_API_URL</code>   <code>http://sa-logic</code> .   ,    ,       .    ? <br><br>             kube-dns. <br><br><h3> <font color="#3AC1EF">▍DNS-  Kubernetes</font> </h3><br>  Kubernetes   ,   <code>kube-dns</code> .        DNS-.     <code>kube-dns</code>   ,     DNS-    . <br><br>  ,      <code>sa-logic</code> ,   IP-.  <code>kube-dns</code>        IP- .        <code>http://sa-logic</code>  IP-. <br><br>      Deployment <code>sa-webapp</code> . <br><br><h3> <font color="#3AC1EF">▍  sa-webapp</font> </h3><br>   : <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-web-app-deployment.yaml --record deployment "sa-web-app" created</code> </pre> <br>         <code>sa-webapp</code>   ,   .   React-    ,       <code>sa-webapp</code> . <br><br><h3> <font color="#3AC1EF">▍ sa-webapp</font> </h3><br>     <code>service-sa-web-app-lb.yaml</code> ,  ,  ,    ,   . ,   ,   : <br><br><pre> <code class="plaintext hljs">kubectl apply -f service-sa-web-app-lb.yaml service "sa-web-app-lb" created</code> </pre> <br>    . ,     ,      . ,     <code>sa-frontend</code> ,        Java- <code>sa-webapp</code> ,    <code>http://localhost:8080/sentiment</code> .      ,       ,   <code>sa-webapp</code> ,    React-  ,     Java-. <br><br>           ,     . ,          —  ,    ,     . <br><br>  ,       : <br><br><ol><li>  IP-   <code>sa-webapp</code> ,   : <br><br> <code>minikube service list <br> |-------------|----------------------|-----------------------------| <br> |  NAMESPACE  | NAME         | URL       | <br> |-------------|----------------------|-----------------------------| <br> | default     | kubernetes         | No node port       | <br> | default     | sa-frontend-lb       | http://192.168.99.100:30708 | <br> | default     | sa-logic         | No node port       | <br> | default     | sa-web-app-lb        | http://192.168.99.100:31691 | <br> | kube-system | kube-dns             | No node port | <br> | kube-system | kubernetes-dashboard | http://192.168.99.100:30000 | <br> |-------------|----------------------|-----------------------------|</code> </li> <li>   IP-   <code>sa-frontend/src/App.js</code> .   ,     : <br><br><pre> <code class="plaintext hljs">analyzeSentence() {       fetch('http://192.168.99.100:31691/sentiment', { /*    */})           .then(response =&gt; response.json())           .then(data =&gt; this.setState(data));   }</code> </pre> </li><li>  React-,       <code>sa-frontend</code>    <code>npm run build</code> . </li><li>   : <br><br><pre> <code class="plaintext hljs">docker build -f Dockerfile -t $DOCKER_USER_ID/sentiment-analysis-frontend:minikube.</code> </pre> </li><li>     Docker Hub: <br><br><pre> <code class="plaintext hljs">docker push $DOCKER_USER_ID/sentiment-analysis-frontend:minikube</code> </pre> </li><li>   <code>sa-frontend-deployment.yaml</code> ,       . </li><li>   : <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-frontend-deployment.yaml</code> </pre> </li></ol><br>     ,   , ,      ,    <code>minikube service sa-frontend-lb</code> .  ,   - . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53d/19c/3ba/53d19c3bac2f8cdd66213c9b34e7b05b.png"></div><br> <i><font color="#999999">  </font></i> <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>   Kubernetes     ,        ,   ,   ,     .  Kubernetes   ,     ,           .    Kubernetes  Supernetes. <br><br>    ,   : <br><br><ul><li> ,    ,   React, Java  Python. </li><li>    Docker,  ,        <code>Dockerfile</code> . </li><li>    ,  ,  Docker Hub. </li></ul><br>  ,     Kubernetes: <br><br><ul><li>  </li><li>  Layanan </li><li>  </li><li>           </li><li>   </li></ul><br>      ,   ,   Kubernetes. <br><br>  <b>Pembaca yang budiman!</b>    Kubernetes? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438984/">https://habr.com/ru/post/id438984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438974/index.html">Realitas Virtual Membantu Menangani Gangguan Mental</a></li>
<li><a href="../id438976/index.html">Buku "Spring. Semua pola desain »</a></li>
<li><a href="../id438978/index.html">Belajar selalu dan di mana saja! Podcast untuk pengembang dalam bahasa Inggris</a></li>
<li><a href="../id438980/index.html">Spring Boot 2: apa yang baru?</a></li>
<li><a href="../id438982/index.html">Panduan Kubernetes, Bagian 1: Aplikasi, Layanan Mikro, dan Wadah</a></li>
<li><a href="../id438986/index.html">React Tutorial Bagian 14: Workshop Komponen Berbasis Kelas, Status Komponen</a></li>
<li><a href="../id438988/index.html">React Tutorial Bagian 15: Lokakarya State Komponen</a></li>
<li><a href="../id438992/index.html">Diary Pengembang atau Keputusan Buruk</a></li>
<li><a href="../id438994/index.html">Intel Xeon W-3175X, drummer panas. Pengujian</a></li>
<li><a href="../id438996/index.html">Jaringan perusahaan dan MitM. Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>