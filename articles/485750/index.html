<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë©üèæ ‚òùüèΩ üîÖ API para las que finalmente vale la pena actualizar desde Java 8. Parte 1 üë®üèª‚ÄçüöÄ üç¶ ü•ï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java 8 es, con mucho, la versi√≥n m√°s popular de Java y permanecer√° con ella durante bastante tiempo. Sin embargo, cinco nuevas versiones de Java ya se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>API para las que finalmente vale la pena actualizar desde Java 8. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485750/"><p>  Java 8 es, con mucho, la versi√≥n m√°s popular de Java y permanecer√° con ella durante bastante tiempo.  Sin embargo, cinco nuevas versiones de Java ya se han lanzado desde entonces (9, 10, 11, 12, 13), y pronto se lanzar√° otra Java 14. Una gran cantidad de nuevas caracter√≠sticas han aparecido en estas nuevas versiones.  Por ejemplo, si cuenta en JEP, se implementaron 141 en total: </p><br><ul><li>  99 en <a href="https://openjdk.java.net/projects/jdk9/" rel="nofollow">JDK 9</a> </li><li>  12 en <a href="https://openjdk.java.net/projects/jdk/10/" rel="nofollow">JDK 10</a> </li><li>  17 en <a href="https://openjdk.java.net/projects/jdk/11/" rel="nofollow">JDK 11</a> </li><li>  8 en <a href="https://openjdk.java.net/projects/jdk/12/" rel="nofollow">JDK 12</a> </li><li>  5 en <a href="https://openjdk.java.net/projects/jdk/13/" rel="nofollow">JDK 13</a> </li><li>  (+14 a <a href="https://openjdk.java.net/projects/jdk/14/" rel="nofollow">JDK 14</a> ) </li></ul><br><p>  Sin embargo, en esta serie de art√≠culos no habr√° una lista seca de JEP.  En cambio, solo quiero hablar sobre API interesantes que han aparecido en nuevas versiones.  Cada art√≠culo contendr√° 10 API.  En la elecci√≥n y el orden de estas API no habr√° ninguna l√≥gica y regularidad espec√≠ficas.  Ser√°n solo 10 API aleatorias, no TOP 10 y sin clasificar de la API m√°s importante a la menos importante.  Empecemos </p><a name="habracut"></a><br>
<h3>  1. M√©todos <code>Objects.requireNonNullElse()</code> y <code>Objects.requireNonNullElseGet()</code> </h3><br><h4>  Introducido en: Java 9 </h4><br><p>  Comenzamos nuestra lista con dos m√©todos muy simples pero muy √∫tiles en la clase <code>java.util.Objects</code> : <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Objects.html" rel="nofollow">requireNonNullElse()</a></code> y <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Objects.html" rel="nofollow">requireNonNullElseGet()</a></code> .  Estos m√©todos le permiten devolver el objeto transmitido, si no es <code>null</code> , y si es <code>null</code> , devuelva el objeto por defecto.  Por ejemplo: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCoder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Charset charset; MyCoder(Charset charset) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.charset = Objects.requireNonNullElse( charset, StandardCharsets.UTF_8); } }</code> </pre> <br><p>  <code>requireNonNullElseGet()</code> no es m√°s que una versi√≥n perezosa de <code>requireNonNullElse()</code> .  Puede ser √∫til si calcular el argumento predeterminado es costoso: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCoder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Charset charset; MyCoder(Charset charset) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.charset = Objects.requireNonNullElseGet( charset, MyCoder::defaultCharset); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Charset </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defaultCharset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// long operation... } }</span></span></code> </pre> <br><p>  S√≠, por supuesto, en ambos casos, uno podr√≠a prescindir f√°cilmente de estas funciones, por ejemplo, utilizando el operador ternario habitual u <code>Optional</code> , pero a√∫n utilizando una funci√≥n especial hace que el c√≥digo sea un poco m√°s corto y limpio.  Y si usa importaci√≥n y escritura est√°ticas, simplemente <code>requireNonNullElse()</code> lugar de <code>Objects.requireNonNullElse()</code> , entonces el c√≥digo se puede reducir a√∫n m√°s. </p><br><br><h3>  2. M√©todos de f√°brica que devuelven colecciones inmutables </h3><br><h4>  Introducido en: Java 9 </h4><br><p>  Si los dos m√©todos anteriores son solo cosm√©ticos, los m√©todos de f√°brica de recolecci√≥n est√°tica realmente pueden reducir en gran medida el c√≥digo e incluso mejorar su seguridad.  Estos son los siguientes m√©todos <a href="https://openjdk.java.net/jeps/269" rel="nofollow">introducidos</a> en Java 9: </p><br><ul><li>  <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/List.html" rel="nofollow">List.of(E... elements)</a></code> (y sobrecargas) </li><li>  <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Set.html" rel="nofollow">Set.of(E... elements)</a></code> (y sobrecargas) </li><li>  <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Map.html" rel="nofollow">Map.of(K k1, V v1, K k2, V v2, ...)</a></code> (y sobrecargas) </li><li> <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Map.html" rel="nofollow">Map.ofEntries(Entry&lt;? extends K, ? extends V&gt;... entries)</a></code> </li> </ul><br><p>  A la misma lista, puede agregar el <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Map.html" rel="nofollow">Map.entry(K k, V v)</a></code> que lo acompa√±a, que crea la <code>Entry</code> partir de la clave y el valor, as√≠ como los m√©todos para copiar colecciones que <a href="https://minijug.ru/unmodifiable_collections_enhancements_in_java_10.html" rel="nofollow">aparecieron</a> en Java 10: </p><br><ul><li> <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/List.html" rel="nofollow">List.copyOf(Collection&lt;? extends E&gt; coll)</a></code> </li> <li> <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Set.html" rel="nofollow">Set.copyOf(Collection&lt;? extends E&gt; coll)</a></code> </li> <li> <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Map.html" rel="nofollow">Map.copyOf(Map&lt;? extends K,‚Äã? extends V&gt; map)</a></code> </li> </ul><br><p>  Los m√©todos de f√°brica est√°ticos le permiten crear una colecci√≥n inmutable e inicializarla en una sola acci√≥n: </p><br><pre> <code class="java hljs">List&lt;String&gt; imageExtensions = List.of(<span class="hljs-string"><span class="hljs-string">"bmp"</span></span>, <span class="hljs-string"><span class="hljs-string">"jpg"</span></span>, <span class="hljs-string"><span class="hljs-string">"png"</span></span>, <span class="hljs-string"><span class="hljs-string">"gif"</span></span>);</code> </pre> <br><p>  Si no utiliza bibliotecas de terceros, un c√≥digo similar en Java 8 se ver√° mucho m√°s engorroso: </p><br><pre> <code class="java hljs">List&lt;String&gt; imageExtensions = Collections.unmodifiableList( Arrays.asList(<span class="hljs-string"><span class="hljs-string">"bmp"</span></span>, <span class="hljs-string"><span class="hljs-string">"jpg"</span></span>, <span class="hljs-string"><span class="hljs-string">"png"</span></span>, <span class="hljs-string"><span class="hljs-string">"gif"</span></span>));</code> </pre> <br><p>  Y en el caso de <code>Set</code> o <code>Map</code> todav√≠a es m√°s triste, porque no hay an√°logos de <code>Arrays.asList()</code> para <code>Set</code> y <code>Map</code> . </p><br><p>  Tal molestia provoca que muchas personas que escriben en Java 8 abandonen por completo las colecciones inmutables y usen siempre la <code>ArrayList</code> , <code>HashSet</code> y <code>HashMap</code> habituales, e incluso cuando se necesita el significado de colecciones inmutables.  Como resultado, esto rompe el concepto de inmutable por defecto y reduce la seguridad del c√≥digo. </p><br><p>  Si finalmente actualiza desde Java 8, trabajar con colecciones inmutables se vuelve mucho m√°s f√°cil y divertido gracias a los m√©todos de f√°brica. </p><br><br><h3>  3. <code>Files.readString()</code> y <code>Files.writeString()</code> </h3><br><h4>  Introducido en: Java 11 </h4><br><p>  Java siempre ha sido conocido por su introducci√≥n pausada de m√©todos listos para operaciones frecuentes.  Por ejemplo, para una de las operaciones m√°s populares en la programaci√≥n, leer un archivo, durante mucho tiempo no hab√≠a un m√©todo listo.  Solo 15 a√±os despu√©s del lanzamiento de Java 1.0, apareci√≥ NIO, donde se introdujo el m√©todo <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Files.html" rel="nofollow">Files.readAllBytes()</a></code> para leer el archivo en una matriz de bytes. </p><br><p>  Pero esto todav√≠a no era suficiente, porque la gente a menudo tiene que trabajar con archivos de texto y para esto necesita leer cadenas del archivo, no bytes.  Por lo tanto, en Java 8, se agreg√≥ el m√©todo <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Files.html" rel="nofollow">Files.readAllLines()</a></code> , devolviendo una <code>List&lt;String&gt;</code> . </p><br><p>  Sin embargo, esto no fue suficiente, ya que la gente pregunt√≥ qu√© tan f√°cil era leer el archivo completo como una sola l√≠nea.  Como resultado, para completar la imagen en Java 11, se <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Files.html" rel="nofollow">Files.readString()</a></code> el tan esperado m√©todo <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Files.html" rel="nofollow">Files.readString()</a></code> , cerrando as√≠ finalmente esta pregunta.  Sorprendentemente, si un m√©todo similar estuvo presente en muchos otros idiomas desde el principio, entonces Java tard√≥ m√°s de 20 a√±os en hacerlo. </p><br><p>  Junto con <code>readString()</code> supuesto, tambi√©n se introdujo el m√©todo sim√©trico <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/nio/file/Files.html" rel="nofollow">writeString()</a></code> .  Estos m√©todos tambi√©n tienen sobrecargas que le permiten especificar un <code>Charset</code> .  Juntos, todo esto hace que trabajar con archivos de texto sea extremadamente conveniente.  Un ejemplo: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/**        */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reencodeFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path path, Charset from, Charset to)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ String content = Files.readString(path, from); Files.writeString(path, content, to); }</code> </pre> <br><br><h3>  4. <code>Optional.ifPresentOrElse()</code> y <code>Optional.stream()</code> </h3><br><h4>  Introducido en: Java 9 </h4><br><p>  Cuando <code>Optional</code> apareci√≥ en Java 8, no ten√≠an una forma conveniente de realizar dos acciones diferentes, dependiendo de si tiene un valor o no.  Como resultado, las personas tienen que recurrir a la cadena habitual <code>isPresent()</code> y <code>get()</code> : </p><br><pre> <code class="java hljs">Optional&lt;String&gt; opt = ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opt.isPresent()) { log.info(<span class="hljs-string"><span class="hljs-string">"Value = "</span></span> + opt.get()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { log.error(<span class="hljs-string"><span class="hljs-string">"Empty"</span></span>); }</code> </pre> <br><p>  O a√∫n puedes esquivar de esta manera: </p><br><pre> <code class="java hljs">Optional&lt;String&gt; opt = ... opt.ifPresent(str -&gt; log.info(<span class="hljs-string"><span class="hljs-string">"Value = "</span></span> + str)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opt.isEmpty()) { log.error(<span class="hljs-string"><span class="hljs-string">"Empty"</span></span>); }</code> </pre> <br><p>  Ambas opciones no son perfectas.  Pero, comenzando con Java 9, esto se puede hacer de manera elegante usando el m√©todo <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Optional.html" rel="nofollow">Optional.ifPresentOrElse()</a></code> : </p><br><pre> <code class="java hljs">Optional&lt;String&gt; opt = ... opt.ifPresentOrElse( str -&gt; log.info(<span class="hljs-string"><span class="hljs-string">"Value = "</span></span> + str), () -&gt; log.error(<span class="hljs-string"><span class="hljs-string">"Empty"</span></span>));</code> </pre> <br><p>  Otro nuevo m√©todo interesante en Java 9 es <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Optional.html" rel="nofollow">Optional.stream()</a></code> , que devuelve un <code>Stream</code> de un elemento si el valor est√° presente, y un <code>Stream</code> vac√≠o si no lo est√°.  Tal m√©todo puede ser muy √∫til en cadenas con <code>flatMap()</code> .  Por ejemplo, en este ejemplo, es muy simple obtener una lista de todos los n√∫meros de tel√©fono de una empresa: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Employee</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Optional&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPhoneNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Department</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">List&lt;Employee&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEmployees</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Company</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">List&lt;Department&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDepartments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-function">Set&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAllPhoneNumbers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getDepartments() .stream() .flatMap(d -&gt; d.getEmployees().stream()) .flatMap(e -&gt; e.getPhoneNumber().stream()) .collect(Collectors.toSet()); } }</code> </pre> <br><p>  En Java 8, tendr√≠a que escribir algo como: </p><br><pre> <code class="plaintext hljs">e -&gt; e.getPhoneNumber().map(Stream::of).orElse(Stream.empty())</code> </pre> <br><p>  Se ve voluminoso y no muy legible. </p><br><br><h3>  5. <code>Process.pid()</code> , <code>Process.info()</code> y <code>ProcessHandle</code> </h3><br><h4>  Introducido en: Java 9 </h4><br><p>  Si a√∫n puede administrar sin las API anteriores, reemplazar el m√©todo <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Process.html" rel="nofollow">Process.pid()</a></code> en Java 8 ser√° bastante problem√°tico, especialmente multiplataforma.  Este m√©todo devuelve el ID de proceso nativo: </p><br><pre> <code class="java hljs">Process process = Runtime.getRuntime().exec(<span class="hljs-string"><span class="hljs-string">"java -version"</span></span>); System.out.println(process.pid());</code> </pre> <br><p>  Usando el m√©todo <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Process.html" rel="nofollow">Process.info()</a></code> , tambi√©n puede encontrar informaci√≥n √∫til adicional sobre el proceso.  Devuelve un objeto de tipo <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.Info.html" rel="nofollow">ProcessHandle.Info</a></code> .  Veamos qu√© nos devuelve para el proceso anterior: </p><br><pre> <code class="java hljs">Process process = Runtime.getRuntime().exec(<span class="hljs-string"><span class="hljs-string">"java -version"</span></span>); ProcessHandle.Info info = process.info(); System.out.println(<span class="hljs-string"><span class="hljs-string">"PID = "</span></span> + process.pid()); System.out.println(<span class="hljs-string"><span class="hljs-string">"User = "</span></span> + info.user()); System.out.println(<span class="hljs-string"><span class="hljs-string">"Command = "</span></span> + info.command()); System.out.println(<span class="hljs-string"><span class="hljs-string">"Args = "</span></span> + info.arguments().map(Arrays::toString)); System.out.println(<span class="hljs-string"><span class="hljs-string">"Command Line = "</span></span> + info.commandLine()); System.out.println(<span class="hljs-string"><span class="hljs-string">"Start Time = "</span></span> + info.startInstant()); System.out.println(<span class="hljs-string"><span class="hljs-string">"Total Time = "</span></span> + info.totalCpuDuration());</code> </pre> <br><p>  Conclusi√≥n </p><br><pre> <code class="plaintext hljs">PID = 174 User = Optional[orionll] Command = Optional[/usr/lib/jvm/java-13-openjdk-amd64/bin/java] Args = Optional[[-version]] Command Line = Optional[/usr/lib/jvm/java-13-openjdk-amd64/bin/java -version] Start Time = Optional[2020-01-24T05:54:25.680Z] Total Time = Optional[PT0.01S]</code> </pre> <br><p>  ¬øQu√© sucede si el proceso no se inici√≥ desde el proceso Java actual?  Para esto, <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.html" rel="nofollow">ProcessHandle</a></code> viene al <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.html" rel="nofollow">ProcessHandle</a></code> .  Por ejemplo, obtengamos la misma informaci√≥n para el proceso actual usando el m√©todo <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.html" rel="nofollow">ProcessHandle.current()</a></code> : </p><br><pre> <code class="java hljs">ProcessHandle handle = ProcessHandle.current(); ProcessHandle.Info info = handle.info(); System.out.println(<span class="hljs-string"><span class="hljs-string">"PID = "</span></span> + handle.pid()); System.out.println(<span class="hljs-string"><span class="hljs-string">"User = "</span></span> + info.user()); System.out.println(<span class="hljs-string"><span class="hljs-string">"Command = "</span></span> + info.command()); System.out.println(<span class="hljs-string"><span class="hljs-string">"Args = "</span></span> + info.arguments().map(Arrays::toString)); System.out.println(<span class="hljs-string"><span class="hljs-string">"Command Line = "</span></span> + info.commandLine()); System.out.println(<span class="hljs-string"><span class="hljs-string">"Start Time = "</span></span> + info.startInstant()); System.out.println(<span class="hljs-string"><span class="hljs-string">"Total Time = "</span></span> + info.totalCpuDuration());</code> </pre> <br><p>  Conclusi√≥n </p><br><pre> <code class="plaintext hljs">PID = 191 User = Optional[orionll] Command = Optional[/usr/lib/jvm/java-13-openjdk-amd64/bin/java] Args = Optional[[Main.java]] Command Line = Optional[/usr/lib/jvm/java-13-openjdk-amd64/bin/java Main.java] Start Time = Optional[2020-01-24T05:59:17.060Z] Total Time = Optional[PT1.56S]</code> </pre> <br><p>  Para obtener un <code>ProcessHandle</code> para cualquier proceso mediante su PID, puede usar el m√©todo <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.html" rel="nofollow">ProcessHandle.of()</a></code> (devolver√° <code>Optional.empty</code> si el proceso no existe). </p><br><p>  Tambi√©n en <code>ProcessHandle</code> hay muchos otros m√©todos interesantes, por ejemplo, <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ProcessHandle.html" rel="nofollow">ProcessHandle.allProcesses()</a></code> . </p><br><br><h3>  6. M√©todos de <code>String</code> : <code>isBlank()</code> , <code>strip()</code> , <code>stripLeading()</code> , <code>stripTrailing()</code> , <code>repeat()</code> y <code>lines()</code> </h3><br><h4>  Introducido en: Java 11 </h4><br><p>  Toda una monta√±a de m√©todos √∫tiles para cadenas apareci√≥ en Java 11. </p><br><p>  El m√©todo <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html" rel="nofollow">String.isBlank()</a></code> permite averiguar si una cadena consiste √∫nicamente en espacios en blanco: </p><br><pre> <code class="java hljs">System.out.println(<span class="hljs-string"><span class="hljs-string">" \n\r\t"</span></span>.isBlank()); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br><p>  Los <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html" rel="nofollow">String.stripLeading()</a></code> , <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html" rel="nofollow">String.stripTrailing()</a></code> y <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html" rel="nofollow">String.strip()</a></code> eliminan los caracteres de espacio en blanco al principio de una l√≠nea, al final de una l√≠nea o en ambos extremos: </p><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">" \tHello, world!\t\n"</span></span>; String str1 = str.stripLeading(); <span class="hljs-comment"><span class="hljs-comment">// "Hello, world!\t\n" String str2 = str.stripTrailing(); // " \tHello, world!" String str3 = str.strip(); // "Hello, world!"</span></span></code> </pre> <br><p>  Tenga en cuenta que <code>String.strip()</code> no <code>String.strip()</code> lo mismo que <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html" rel="nofollow">String.trim()</a></code> : el segundo solo elimina caracteres cuyo c√≥digo es menor o igual que U + 0020, y el primero tambi√©n elimina espacios de Unicode: </p><br><pre> <code class="java hljs">System.out.println(<span class="hljs-string"><span class="hljs-string">"str\u2000"</span></span>.strip()); <span class="hljs-comment"><span class="hljs-comment">// "str" System.out.println("str\u2000".trim()); // "str\u2000"</span></span></code> </pre> <br><br><p>  El m√©todo <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html" rel="nofollow">String.repeat()</a></code> concatena la cadena en s√≠ <code>n</code> veces: </p><br><pre> <code class="java hljs">System.out.print(<span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span>.repeat(<span class="hljs-number"><span class="hljs-number">3</span></span>));</code> </pre> <br><p>  Conclusi√≥n </p><br><pre> <code class="plaintext hljs">Hello, world! Hello, world! Hello, world!</code> </pre> <br><p>  Finalmente, el m√©todo <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html" rel="nofollow">String.lines()</a></code> divide la cadena en l√≠neas.  Goodbye <code>String.split()</code> , con el cual las personas constantemente confunden, qu√© argumento usar para √©l, ya sea <code>"\n"</code> o <code>"\r"</code> o <code>"\n\r"</code> (de hecho, es mejor usar regular expresi√≥n <code>"\R"</code> , que cubre todas las combinaciones).  Adem√°s, <code>String.lines()</code> menudo puede ser m√°s eficiente ya que devuelve l√≠neas perezosamente. </p><br><pre> <code class="java hljs">System.out.println(<span class="hljs-string"><span class="hljs-string">"line1\nline2\nline3\n"</span></span> .lines() .map(String::toUpperCase) .collect(Collectors.joining(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)));</code> </pre> <br><p>  Conclusi√≥n </p><br><pre> <code class="plaintext hljs">LINE1 LINE2 LINE3</code> </pre> <br><br><h3>  7. <code>String.indent()</code> </h3><br><h4>  Aparecido en: Java 12 </h4><br><p>  Diluyamos nuestra historia con algo nuevo que apareci√≥ recientemente.  Meet: el m√©todo <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html" rel="nofollow">String.indent()</a></code> , que aumenta (o disminuye) la sangr√≠a de cada l√≠nea en una l√≠nea dada por el valor especificado.  Por ejemplo: </p><br><pre> <code class="java hljs">String body = <span class="hljs-string"><span class="hljs-string">"&lt;h1&gt;Title&lt;/h1&gt;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"&lt;p&gt;Hello, world!&lt;/p&gt;"</span></span>; System.out.println(<span class="hljs-string"><span class="hljs-string">"&lt;html&gt;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" &lt;body&gt;\n"</span></span> + body.indent(<span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-string"><span class="hljs-string">" &lt;/body&gt;\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"&lt;/html&gt;"</span></span>);</code> </pre> <br><p>  Conclusi√≥n </p><br><pre> <code class="plaintext hljs">&lt;html&gt; &lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Hello, world!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;</code> </pre> <br><p>  Tenga en cuenta que para la √∫ltima l√≠nea, <code>String.indent()</code> insert√≥ el avance de l√≠nea, por lo que no tuvimos que agregar <code>'\n'</code> despu√©s de <code>body.indent(4)</code> . </p><br><p>  Por supuesto, tal m√©todo ser√° de gran inter√©s en combinaci√≥n con <a href="https://minijug.ru/text_blocks.html" rel="nofollow">bloques de texto</a> cuando se estabilicen, pero nada nos impide usarlo ahora sin ning√∫n bloque de texto. </p><br><br><h3>  8. M√©todos de <code>takeWhile()</code> : <code>takeWhile()</code> , <code>dropWhile()</code> , <code>iterate()</code> con un predicado y <code>ofNullable()</code> </h3><br><h4>  Introducido en: Java 9 </h4><br><p>  <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/stream/Stream.html" rel="nofollow">Stream.takeWhile()</a></code> es similar a <code>Stream.limit()</code> , pero restringe <code>Stream</code> no por cantidad, sino por predicado.  Tal necesidad de programaci√≥n surge muy a menudo.  Por ejemplo, si necesitamos obtener todas las entradas del diario para el a√±o actual: </p><br><pre> <code class="plaintext hljs">[ { "date" : "2020-01-27", "text" : "..." }, { "date" : "2020-01-25", "text" : "..." }, { "date" : "2020-01-22", "text" : "..." }, { "date" : "2020-01-17", "text" : "..." }, { "date" : "2020-01-11", "text" : "..." }, { "date" : "2020-01-02", "text" : "..." }, { "date" : "2019-12-30", "text" : "..." }, { "date" : "2019-12-27", "text" : "..." }, ... ]</code> </pre> <br><p>  <code>Stream</code> registros es casi infinita, por lo que <code>filter()</code> no se puede usar.  Entonces <code>takeWhile()</code> viene al <code>takeWhile()</code> : </p><br><pre> <code class="plaintext hljs">getNotesStream() .takeWhile(note -&gt; note.getDate().getYear() == 2020);</code> </pre> <br><p>  Y si queremos obtener registros para 2019, entonces podemos usar <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/stream/Stream.html" rel="nofollow">dropWhile()</a></code> : </p><br><pre> <code class="plaintext hljs">getNotesStream() .dropWhile(note -&gt; note.getDate().getYear() == 2020) .takeWhile(note -&gt; note.getDate().getYear() == 2019);</code> </pre> <br><p>  En Java 8, <code>Stream.iterate()</code> solo pod√≠a generar un <code>Stream</code> infinito.  Pero en Java 9, este m√©todo tiene una <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/stream/Stream.html" rel="nofollow"></a></code> que toma un predicado.  Gracias a esto, muchos bucles <code>for</code> ahora se pueden reemplazar con <code>Stream</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java 8 for (int i = 1; i &lt; 100; i *= 2) { System.out.println(i); }</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java 9+ IntStream .iterate(1, i -&gt; i &lt; 100, i -&gt; i * 2) .forEach(System.out::println);</span></span></code> </pre> <br><p>  Ambas versiones imprimen todos los grados de una deuce que no exceda de <code>100</code> : </p><br><pre> <code class="plaintext hljs">1 2 4 8 16 32 64</code> </pre> <br><p>  Por cierto, el √∫ltimo c√≥digo podr√≠a reescribirse usando <code>takeWhile()</code> : </p><br><pre> <code class="plaintext hljs">IntStream .iterate(1, i -&gt; i * 2) .takeWhile(i -&gt; i &lt; 100) .forEach(System.out::println);</code> </pre> <br><p>  Sin embargo, la opci√≥n con la <code>iterate()</code> tres argumentos <code>iterate()</code> sigue siendo m√°s limpia (e IntelliJ IDEA <a href="https://youtrack.jetbrains.com/issue/IDEA-214960" rel="nofollow">sugiere</a> corregirla nuevamente). </p><br><p>  Finalmente, <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/stream/Stream.html" rel="nofollow">Stream.ofNullable()</a></code> devuelve un <code>Stream</code> con un elemento si no es <code>null</code> , y un <code>Stream</code> vac√≠o si es <code>null</code> .  Este m√©todo es perfecto en el ejemplo anterior con tel√©fonos de la compa√±√≠a si <code>getPhoneNumber()</code> devolver√° una <code>String</code> anulable en lugar de <code>Optional&lt;String&gt;</code> : </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Employee</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPhoneNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Department</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">List&lt;Employee&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEmployees</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Company</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">List&lt;Department&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDepartments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-function">Set&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAllPhoneNumbers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getDepartments() .stream() .flatMap(d -&gt; d.getEmployees().stream()) .flatMap(e -&gt; Stream.ofNullable(e.getPhoneNumber())) .collect(Collectors.toSet()); } }</code> </pre> <br><br><h3>  9. <code>Predicate.not()</code> </h3><br><h4>  Aparecido en: Java 11 </h4><br><p>  Este m√©todo no introduce nada fundamentalmente nuevo y es m√°s cosm√©tico que fundamental.  Sin embargo, la capacidad de acortar ligeramente el c√≥digo siempre es muy agradable.  Usando <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/function/Predicate.html" rel="nofollow">Predicate.not()</a></code> lambdas que tienen negaci√≥n se pueden reemplazar con referencias de m√©todos: </p><br><pre> <code class="plaintext hljs">Files.lines(path) .filter(str -&gt; !str.isEmpty()) .forEach(System.out::println);</code> </pre> <br><p>  Y ahora usando <code>not()</code> : </p><br><pre> <code class="plaintext hljs">Files.lines(path) .filter(not(String::isEmpty)) .forEach(System.out::println);</code> </pre> <br><p>  S√≠, los ahorros no son tan grandes, y si usa <code>s -&gt; !s.isEmpty()</code> , la cantidad de caracteres, por el contrario, aumenta.  Pero incluso en este caso, sigo prefiriendo la segunda opci√≥n, ya que es m√°s declarativa y no utiliza una variable, lo que significa que el espacio de nombres no est√° abarrotado. </p><br><br><h3>  10. Limpiador </h3><br><h4>  Aparecido en: Java 9 </h4><br><p>  Quiero terminar la historia de hoy con una nueva API interesante que apareci√≥ en Java 9 y sirve para limpiar recursos antes de que el recolector de basura los elimine.  <code><a href="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/ref/Cleaner.html" rel="nofollow">Cleaner</a></code> es un reemplazo seguro para el m√©todo <code>Object.finalize()</code> , que en s√≠ mismo qued√≥ obsoleto en Java 9. </p><br><p>  Con <code>Cleaner</code> puede registrar una limpieza de recursos que suceder√° si olvid√≥ hacerlo expl√≠citamente (por ejemplo, olvid√≥ llamar al m√©todo <code>close()</code> o no us√≥ <code>try-with-resources</code> ).  Aqu√≠ hay un ejemplo de un recurso abstracto para el cual se registra una acci√≥n de limpieza en el constructor: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resource</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Closeable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Cleaner CLEANER = Cleaner.create(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Cleaner.Cleanable cleanable; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Resource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ cleanable = CLEANER.register(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, () -&gt; { <span class="hljs-comment"><span class="hljs-comment">//   // (,  ) }); } @Override public void close() { cleanable.clean(); } }</span></span></code> </pre> <br><p>  En el buen sentido, los usuarios deber√≠an crear dicho recurso en el bloque de <code>try</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Resource()) { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  Sin embargo, puede haber usuarios que se olviden de hacer esto y escriban simplemente <code>var resource = new Resource()</code> .  En tales casos, la limpieza no se realizar√° de inmediato, sino que se llamar√° m√°s adelante en uno de los siguientes ciclos de recolecci√≥n de basura.  Es mejor que nada. </p><br><p>  Si desea estudiar <code>Cleaner</code> mejor y descubrir por qu√© nunca debe usar <code>finalize()</code> , le recomiendo que escuche <a href="https://www.youtube.com/watch%3Fv%3DK5IctLPem0c" rel="nofollow">mi charla</a> sobre este tema. </p><br><br><h3>  Conclusi√≥n </h3><br><p>  Java no se detiene y se est√° desarrollando gradualmente.  Mientras est√° sentado en Java 8, con cada versi√≥n hay cada vez m√°s API nuevas e interesantes.  Hoy revisamos 10 de estas API.  Y puede usarlos todos si finalmente decide migrar desde Java 8. </p><br><p>  La pr√≥xima vez veremos 10 API nuevas m√°s. </p><br>  <i>Si no desea omitir la siguiente parte, le recomiendo que se suscriba a <a href="https://tlg.name/miniJUG" rel="nofollow">mi canal de Telegram</a> , donde tambi√©n publico noticias de Java.</i> </div></div><p>Source: <a href="https://habr.com/ru/post/485750/">https://habr.com/ru/post/485750/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../485740/index.html">El enfrentamiento en PHDays: participa en la batalla de aniversario de hackers y defensores</a></li>
<li><a href="../485742/index.html">C√≥mo creamos el directorio de direcciones de Rostelecom</a></li>
<li><a href="../485744/index.html">Inteligencia: la capacidad de un objeto de adaptar su comportamiento al entorno para preservar (sobrevivir)</a></li>
<li><a href="../485746/index.html">La cuarta plataforma parte del servidor usado</a></li>
<li><a href="../485748/index.html">Encadenamiento opcional, uni√≥n con nulo y c√≥mo cambian nuestro enfoque para escribir c√≥digo</a></li>
<li><a href="../485758/index.html">Gigante modular con control en l√≠nea, as√≠ como teclados textiles y de punto Joe Paradiso</a></li>
<li><a href="../485760/index.html">Extensiones en Kotlin. ¬øAtavismo peligroso o una herramienta √∫til?</a></li>
<li><a href="../485766/index.html">Reglas de alimentaci√≥n</a></li>
<li><a href="../485768/index.html">Tendencias web 2020 que vale la pena probar</a></li>
<li><a href="../485770/index.html">Pol√©mica incorrecta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>