<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗂️ 🛃 👨‍🌾 最小的自动化。 第一部分（零之后）。 网络虚拟化 😋 👃 🕤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在以前的版本中，我描述了网络自动化框架。 根据某些人的评论，即使是第一种解决问题的方法，也已经在货架上提出了一些问题。 这让我感到非常高兴，因为我们在本周期中的目标不是使用Python脚本来覆盖ansible，而是构建一个系统。 

 相同的框架确定了我们处理问题的顺序。 
 这个问题专门针对的网络...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>最小的自动化。 第一部分（零之后）。 网络虚拟化</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458622/"> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以前的版本中，</a>我描述了网络自动化框架。 根据某些人的评论，即使是第一种解决问题的方法，也已经在货架上提出了一些问题。 这让我感到非常高兴，因为我们在本周期中的目标不是使用Python脚本来覆盖ansible，而是构建一个系统。 <br><br> 相同的框架确定了我们处理问题的顺序。 <br> 这个问题专门针对的网络虚拟化并不完全适合我们分析自动化的ADSM主题。 <br><br> 但是让我们从另一个角度来看它。 <br><br> 长期以来，许多服务都使用一个网络。 在运营商的情况下，例如是2G，3G，LTE，宽带和B2B。 对于DC：不同客户端的连接，Internet，块存储，对象存储。 <br><br> 并且所有服务都需要彼此隔离。 因此出现了覆盖网络。 <br><br> 并且所有服务都不希望等待有人手动配置它们。 因此出现了协调器和SDN。 <br><br> 长期以来，采用网络或部分网络的系统自动化的第一种方法并已在许多地方实施：VMWare，OpenStack，Google Compute Cloud，AWS，Facebook。 <br><br> 今天我们在这里与他打交道。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b14/278/742/b142787424b1da02432df0291faaca95.jpg" width="800"></a> <br><a name="habracut"></a><br><h1> 目录内容 </h1><br><ul><li>  <b>原因</b> </li><li>  <b>术语学</b> </li><li>  <b>参考底图-物理网络</b> </li><li>  <b>叠加-虚拟网络</b> <br><br><ul><li> 用ToR覆盖 </li><li> 主机叠加 </li><li> 案例研究钨纤维 <br><br><ul><li> 一台物理机内的通信 </li><li> 位于不同物理机器上的VM之间的通信 </li><li> 退出外界 </li></ul><br></li></ul><br></li><li>  <b>常见问题</b> </li><li>  <b>结论</b> </li><li>  <b>有用的链接</b> </li></ul><br><hr><br><br><h1> 原因 </h1><br> 既然我们已经讨论了这一点，那么值得一提的是网络虚拟化的前提条件。 实际上，这个过程并不是昨天开始的。 <br><br> 您可能不止一次听到，网络一直是任何系统中最惰性的部分。 从任何意义上来说都是如此。 网络是一切事物的基础，在网络上进行更改非常困难-网络所在时，服务是无法容忍的。 通常，停用单个节点可能会增加大多数应用程序并影响许多客户端。 这就是网络团队可以抵制任何更改的部分原因-因为现在它可以某种方式起作用（ <i>我们甚至可能都不知道如何</i> ），但是在这里我们需要配置一些新内容，并且不知道它将如何影响网络。 <br><br> 为了不等待网络提供商通过VLAN并在每个网络节点上不注册任何服务，人们决定使用叠加层-叠加网络-其中种类繁多：GRE，IPinIP，MPLS，MPLS L2 / L3VPN，VXLAN，GENEVE，MPLSoverUDP，MPLSoverGRE等。 <br><br> 他们的吸引力在于两件简单的事情： <br><br><ul><li> 仅配置了终端节点-您不必触摸传输节点。 这大大加快了该过程，有时甚至允许您将网络基础结构部门排除在引入新服务的过程之外。 </li><li> 负载隐藏在标题的深处-传输节点无需了解任何有关主机的地址，所施加网络的路由的信息。 这意味着您需要在表中存储较少的信息，因此请使用更简单/更便宜的设备。 </li></ul><br> 在这个不太成熟的问题中，我不打算分析所有可能的技术，而是描述DC中覆盖网络的操作框架。 <br><br> 整个系列将描述一个数据中心，该数据中心由成排的类似机架组成，其中安装了相同的服务器设备。 <br><br> 该设备运行可实现服务的虚拟机/容器/无服务器。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f03/525/54b/f0352554b58d82955bd7c08f3034cd4f.jpg" width="600" title="数据线北直流"><br><br><hr><br><br><h1> 术语学 </h1><br> 在循环中，我将调用<b>服务器一个</b>实现客户端-服务器通信的服务器端的程序。 <br><br> 机架中的物理机将<b>不</b>称为服务器。 <br><br>  <b>该物理机</b>是一台x86机架式计算机。 大多数情况下，我们使用术语“ <b>主机”</b> 。 因此，我们将其称为“ <b>机器</b> ”或<b>主机</b> 。 <br><br>  <b>系统管理程序</b>是在物理计算机上运行的应用程序，它可以模拟运行虚拟机的物理资源。 有时在文学和网络中，“管理程序”一词被用作“主机”的同义词。 <br><br>  <b>虚拟机</b>是在管理程序顶部的物理机上运行的操作系统。 对于我们而言，在此周期的框架内，实际上是虚拟机还是容器并不重要。 我们将其称为“ <b>VM</b> ” <br><br>  <b>租户</b>是一个广泛的概念，我将在本文中将其定义为单独的服务或单独的客户端。 <br><br>  <b>多租户</b>或多租户-不同的客户端/服务使用同一应用程序。 同时，由于应用程序的架构而不是单独运行实例，因此实现了客户端之间的隔离。 <br><br>  <b>ToR-机架式交换机的顶部</b> -所有物理机都连接到<b>的机架式交换机</b> 。 <br><blockquote> 除了ToR拓扑结构之外，不同的提供程序还练习行尾（EoR）或行中间（尽管后者是一种可鄙的稀有性，我没有看到MoR的缩写）。 <br></blockquote>  <b>底层网络</b>或底层网络或底层-物理网络基础结构：交换机，路由器，电缆。 <br><br>  <b>覆盖网络</b>或覆盖网络或覆盖-在物理网络之上运行的虚拟隧道网络。 <br><br>  <b>L3工厂或IP工厂</b>是人类的一项伟大发明，它允许访谈不重复STP或不学习TRILL。 整个概念，直到访问级别的整个网络都是L3，没有VLAN和相应的扩展广播域。 下一部分“工厂”一词从何而来。 <br><br>  <b>SDN-</b>软件定义的网络。 几乎不需要介绍。 当网络更改不是由人执行而是由程序执行时的网络管理方法。 通常，这意味着将控制平面从终端网络设备移到控制器。 <br><br>  <b>NFV-</b>网络功能虚拟化-网络设备的虚拟化，它假定可以以虚拟机或容器的形式启动部分网络功能，以加快新服务的实施，组织服务链和简化水平扩展性。 <br><br>  <b>VNF-</b>虚拟网络功能。 特定的虚拟设备：路由器，交换机，防火墙，NAT，IPS / IDS等 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca9/501/33c/ca950133ca98bd1e2ca613342432c535.png" width="700"><br><blockquote> 我现在刻意将描述简化为特定的实现，以免使读者感到困惑。 如需更仔细的阅读，请将其发送到“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接”</a>部分。 此外，对本文的不准确性提出批评的Roma Gorge承诺将单独撰写有关服务器和网络虚拟化技术的文章，以期更深入，更关注细节。 </blockquote><br><hr><br> 当今大多数网络可以清楚地分为两个部分： <br><br>  <b>底层</b> -具有稳定配置的物理网络。 <br>  <b>覆盖</b> - <b>覆盖上的</b>抽象以隔离租户。 <br><br> 对于DC（我们将在本文中进行分析）和ISP（我们将不进行分析，因为它已经在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SDSM中</a> ）都适用。 对于企业网络，情况当然有所不同。 <br><br> 网络焦点图片： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/133/b41/5f8/133b415f8b32264e2fa877f4a4139267.png" width="800"><br><br><hr><br><br><h1> 底衬 </h1><br> 底层是一个物理网络：硬件交换机和电缆。 底层中的设备知道如何访问物理机。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/117/d04/880/117d04880232fa2c00ef303cf5f059a0.png" width="800"><br><br> 它依赖于标准协议和技术。 尤其重要的是，由于硬件设备仍在专有软件上运行，而专有软件既不允许芯片编程也不能实现其协议，因此需要与其他厂商的兼容性和标准化。 <br><blockquote> 但是像Google这样的人有能力开发自己的交换机并放弃公认的协议。 但是LAN_DC不是Google。 <br></blockquote> 相对很少更改底层，因为其任务是物理计算机之间的基本IP连接。  Underlay对在其上运行的服务，客户端，租户一无所知-它只需要将软件包从一台计算机传递到另一台计算机即可。 <br> 参考底图可以是这样的： <br><br><ul><li>  IPv4 + OSPF </li><li>  IPv6 + ISIS + BGP + L3VPN </li><li>  L2 + TRILL </li><li>  L2 + STP </li></ul><br>  Underlay网络以经典方式配置：CLI / GUI / NETCONF。 <br><br> 手动，脚本，专有实用程序。 <br><br> 更详细地讲，该系列的下一篇文章将专门介绍底层内容。 <br><br><hr><br><h1> 叠加层 </h1><br> 叠加-延伸到底层的虚拟隧道网络，它允许一个客户端的VM相互通信，同时提供与其他客户端的隔离。 <br><br> 客户端数据被封装在任何隧道头中，以通过共享网络进行传输。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c1/3ed/8d2/9c13ed8d2e6cec8f1b9fe500660f1c47.png" width="800"><br><br> 因此，一个客户端（一项服务）的VM可以通过Overlay相互通信，甚至不知道数据包实际经过的是什么。 <br><br> 例如，覆盖可以与我上面提到的相同： <br><br><ul><li>  GRE隧道 </li><li> 虚拟局域网 </li><li> 虚拟专用网 </li><li>  L3VPN </li><li> 给予 </li></ul><br> 覆盖网络通常是通过中央控制器配置和维护的。 通过它，配置，控制平面和数据平面被传递到路由和封装客户端流量的设备。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下面</a>我们将通过示例进行分析。 <br><br>  <b>是的，这是纯SDN。</b> <br><br> 组织覆盖网络有两种根本不同的方法： <br><br><ol><li> 用ToR覆盖 </li><li> 主机叠加 </li></ol><br><br><h2> 用ToR覆盖 </h2><br> 覆盖可以从机架安装的访问交换机（ToR）开始，例如在VXLAN工厂的情况下。 <br><br> 这是ISP网络上经过时间考验的机制，所有网络设备供应商都支持该机制。 <br><br> 但是，在这种情况下，ToR交换机应该能够分别共享不同的服务，并且网络管理员应在某种程度上与虚拟机的管理员合作，并对设备配置进行更改（尽管是自动进行）。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e3/0a1/87d/5e30a187dd5796e2a4232cb4e9db0b97.png" width="600"><br><br> 在这里，我将向读者介绍我们老朋友<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@bormoglotx</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的中心</a>上有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VxLAN</a>的文章。 <br> 在本次<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ENOG演示中，详细介绍了使用EVPN</a> VXLAN工厂构建DC网络的方法。 <br><br> 要更全面地了解现实，您可以阅读《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现代，开放和可扩展的结构：VXLAN EVPN》一书</a> 。 <br><blockquote> 我注意到，VXLAN只是一种封装方法，隧道终止不能在ToR上发生，而可以在主机上发生，例如OpenStack。 <br><br> 但是，在ToR上开始覆盖的VXLAN工厂是公认的覆盖网络设计之一。 <br></blockquote><br><h2> 主机叠加 </h2><br> 另一种方法是在最终主机上启动和终止隧道。 <br> 在这种情况下，网络（底层）将保持尽可能简单和静态。 <br> 主机本身进行所有必要的封装。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d7/400/c60/5d7400c60036ba0b6666bb0f733c172f.png" width="600"><br><br> 为此，您肯定需要在主机上运行一个特殊的应用程序，但这是值得的。 <br><br> 首先，在Linux机器上运行客户端更简单，或者说，通常可以，在切换时，您可能现在必须转向专有SDN解决方案，这消除了多供应商的想法。 <br><br> 其次，从控制平面和数据平面的角度来看，在这种情况下，ToR开关都可以保持尽可能简单。 确实-然后，他不需要与SDN控制器进行通信，也不需要存储所有连接的客户端的网络/ ARP-而且-只需知道物理机的IP地址即可，从而大大简化了交换/路由表。 <br><br><hr><br> 在ADSM系列中，我从主机中选择了叠加方法-然后我们只讨论它，而不会返回VXLAN工厂。 <br><br><hr><br> 考虑示例的最简单方法。 作为测试主题，我们将采用OpenSource SDN OpenContrail平台，现在称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tungsten Fabric</a> 。 <br><blockquote> 在本文的结尾，我将对与OpenFlow和OpenvSwitch的类比进行一些思考。 <br></blockquote><br><h2> 案例研究钨纤维 </h2><br> 每个物理机都有一个<b>vRouter-</b>一个虚拟路由器，它知道与其连接的网络以及它们属于的客户端-实际上是一个PE路由器。 对于每个客户端，它维护一个隔离的路由表（读取VRF）。 实际上，vRouter会执行覆盖隧道。 <br><br> 本文末尾还介绍了有关vRouter的更多信息。 <br><br> 虚拟机管理程序上的每个VM通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TAP接口</a>连接到该计算机的vRouter。 <br><br>  <b>TAP-</b>终端访问点-Linux内核中允许联网的虚拟接口。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a2/fc4/20f/7a2fc420f086b1588236ddc7d4f1c97e.png" width="500"><br><br> 如果vRouter后面有多个网络，则会为每个网络创建一个虚拟接口，并为其分配IP地址-这将是默认网关地址。 <br> 一个客户端的所有网络都放在一个<b>VRF</b> （一个表）中，不同-不同。 <br>  <i>在这里，我将保留一些内容，使其不那么简单，并将好奇的读者发送到本文的末尾</i> 。 <br><br> 为了使vRouter'y相互通信，并因此与位于其后的VM通信，它们通过<b>SDN控制器</b>交换路由信息。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3cd/6c5/c73/3cd6c5c7399e314b779a4b9ecf18e17e.png" width="900"></a> <br><br> 要进入外部世界，需要从矩阵中退出-虚拟网络网关<b>VNGW-</b>虚拟网络网关（ <i>我的术语</i> ）。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4d8/75f/a55/4d875fa552a4f144fb9338fa0093235c.png" width="900"></a> <br><br><hr><br> 现在考虑通信的示例-将会很清楚。 <br><br><br><h3> 一台物理机内的通信 </h3><br>  VM0希望将数据包发送到VM2。 现在假设这是单个客户端VM。 <br><br><h4> 数据平面 </h4><br><ol><li>  VM-0在其eth0接口中具有默认路由。 数据包被发送到那里。 <br> 该eth0接口实际上是通过tap0 TAP接口虚拟连接到vRouter虚拟路由器的。 </li><li>  vRouter会分析数据包到达哪个接口，即它属于哪个客户端（VRF），并使用此客户端的路由表检查收件人地址。 </li><li> 发现同一台计算机上的接收器位于其他端口后面之后，vRouter便将数据包直接发送给它而没有任何其他报头-在这种情况下，vRouter已经具有ARP记录。 </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/6be/2e5/1f0/6be2e51f0530a6fc7e9f2c6370c6e0d2.png" width="700"><br><br> 在这种情况下，数据包不进入物理网络-在vRouter内部路由。 <br><br><br><h4> 控制平面 </h4><br> 虚拟机启动时，系统管理程序会告诉她： <br><br><ul><li> 她自己的IP地址。 </li><li> 默认路由是通过该网络上vRouter的IP地址进行的。 </li></ul><br> 通过特殊的API，系统管理程序将向vRouter报告： <br><br><ul><li> 创建虚拟接口所需的内容。 </li><li> 创建虚拟网络需要哪个（VM）。 </li><li> 要绑定到哪个VRF（VN）。 </li><li> 此VM的静态ARP记录是哪个接口具有其IP地址以及它附加到哪个MAC地址。 </li></ul><br><blockquote> 同样，为了理解该概念，简化了实际的交互过程。 <br></blockquote><img src="https://habrastorage.org/getpro/habr/post_images/e14/f52/d49/e14f52d4935eb6d5fd5213c1bd3baeec.png" width="800"><br><br> 因此，vRouter将给定计算机上一个客户端的所有VM视为直接连接的网络，并且可以在它们自身之间进行路由。 <br><br><hr><br> 但是VM0和VM1分别属于不同的客户端，位于不同的表vRouter'a中。 <br><br> 它们之间是否可以直接通信取决于vRouter设置和网络设计。 <br> 例如，如果两个客户端的VM使用公共地址，或者vRouter本身发生NAT，则也可以直接路由到vRouter。 <br><br> 在相反的情况下，可以跨越地址空间-您需要通过NAT服务器来获取公共地址-这类似于访问外部网络，这将在下面进行描述。 <br><br><hr><br><br><h3> 位于不同物理机器上的VM之间的通信 </h3><br><h4> 数据平面 </h4><br><ol><li> 开头是完全一样的：默认情况下，VM-0使用目标VM-7（172.17.3.2）发送数据包。 </li><li>  vRouter接收到它，这次看到目的地在另一台计算机上，并且可以通过隧道Tunnel0访问。 </li><li> 首先，它挂起标识远程接口的MPLS标签，以便在vRouter的背面可以确定该数据包的放置位置，而无需附加挂钩。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/322/f94/328/322f943287f0e8956acc02654bdae580.png" width="1000"></a> <br></li><li>  Tunnel0的源为10.0.0.2，接收者为：10.1.0.2。 <br>  vRouter将GRE（或UDP）标头和新IP添加到原始数据包。 </li><li>  vRouter路由表具有通过地址ToR1 10.0.0.1。的默认路由。 在那里发送。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b9a/696/b8a/b9a696b8a0e97aba81107a3ad112f001.png" width="700"><br><br></li><li> 作为Underlay网络成员的ToR1知道（例如，通过OSPF）如何到达10.0.1.2，并沿着路由发送数据包。 请注意，此处包含ECMP。 在图示中，有两个nexsthops，并且不同的流将通过散列法布置在其中。 对于真正的工厂，可能会有4次nextops。 <br><br> 同时，他不需要知道外部IP标头下的内容。 也就是说，实际上，在IP下，IPv6，MPLS上的MPLS，以太网上的MPLS，GRE上的MPLS和希腊文之间可能存在三明治。 </li><li> 因此，在接收方，vRouter会删除GRE，并使用MPLS标签了解此数据包应发送到的接口，将其剥离并以其原始形式发送给接收者。 </li></ol><br><br><h4> 控制平面 </h4><br> 启动机器时，上面描述的所有操作。 <br><br> 并加上以下内容： <br><br><ul><li>  vRouter为每个客户端分配一个MPLS标签。 这是L3VPN服务标签，客户可以在同一物理计算机上分散。 <br><blockquote> 实际上，MPLS标签始终总是由vRouter'om分配-因为事先不知道该机器将仅与同一个vRouter'om后面的其他机器进行交互，而且这种情况极有可能不会发生。 <br></blockquote></li><li>  vRouter通过BGP与SDN控制器建立连接（或类似方法-对于TF，这是XMPP 0_o）。 </li><li> 通过此会话，vRouter告诉SDN控制器到连接网络的路由： <br><br><ul><li> 网络地址 </li><li> 封装方式（MPLSoGRE，MPLSoUDP，VXLAN） </li><li> 客户端MPLS标签 </li><li> 您的IP地址为下一跳 </li></ul><br></li><li>  SDN控制器从所有连接的vRouter'ov接收此类路由，并将它们反映给其他人。 即，他充当路线反射器。 </li></ul><br> 同一件事发生在相反的方向。 <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/5aa/e3a/b17/5aae3ab177a4ed58279e4c767618f770.png" width="1000"></a> <br><br> 覆盖面至少每分钟都会变化。 当客户定期启动并关闭其虚拟机时，这种情况会在公共云中发生。 <br><br> 中央控制器承担了维护配置以及控制vRouter上的交换/路由表的所有困难。 <br><br> 粗略地说，控制器通过BGP（或类似的协议）关闭所有vRouter，并简单地传输路由信息。 例如，BGP已经具有一个地址族，用于传输<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MPLS-GRE</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MPLS</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UDP-UDP</a>封装方法。 <br><br> 同时，Underlay网络的配置不会以任何方式改变，顺便说一句，自动化起来更加困难，并且由于笨拙的动作而更容易被破坏。 <br><br><hr><br><br><h3> 退出外界 </h3><br> 模拟应该在某个地方结束，您需要从虚拟世界进入真实世界。 您需要<s>公用电话</s>网关。 <br><br> 实践了两种方法： <br><br><ol><li> 已安装硬件路由器。 </li><li> 启动了实现路由器功能的设备（是的，在SDN之后我们遇到了VNF）。 我们称其为虚拟网关。 </li></ol><br><blockquote>        —    —      .    ,     , ,  ,   ,  , , , ,         . <br><br>       ,           ,   ,      ,    ( <i></i> ).     ,  -   ,   ,          —    . <br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网关只用一只脚就能像常规虚拟机一样查看Overlay虚拟网络，并且可以与所有其他VM进行交互。</font><font style="vertical-align: inherit;">同时，它可以自己终止所有客户端的网络，并因此在它们之间进行路由。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一方面，网关已经在寻找骨干网，并且知道如何连接到Internet。</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/930/3d2/d1a/9303d2d1a6777510d3bc87bc19349da2.png" width="800"><br><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 数据平面 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 也就是说，该过程如下所示： </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VM-0已在同一vRouter中默认所有设置，然后将带有外部目标（185.147.83.177）的数据包发送到eth0接口。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vRouter收到此数据包并在路由表中查找目标地址-它通过隧道1查找通过VNGW1网关的默认路由。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他还看到这是具有SIP 10.0.0.2和DIP 10.0.255.2的GRE隧道，仍然需要先挂断MPLS- VNGW1期望该客户端的标签。</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 默认情况下，vRouter将原始数据包打包在MPLS，GRE和新IP报头中，并将其发送到ToR1 10.0.0.1。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 底层网络将数据包传递到VNGW1网关。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VNGW1网关删除GRE和MPLS隧道标头，查看目标地址，查阅其路由表并了解将其定向到Internet-即通过“全视图”或“默认”。</font><font style="vertical-align: inherit;">如有必要，请执行NAT转换。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从VNGW到边界，可能会有一个常规IP网络，这不太可能。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它可以是经典的MPLS网络（IGP + LDP / RSVP TE），也可以是出厂时支持BGP LU的工厂，也可以是从VNGW通过IP网络到边界的GRE隧道。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不管怎样，VNGW1执行必要的封装并将原始数据包发送到边界。</font></font></li></ol><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d9e/49b/c01/d9e49bc0141200d07b7dbd6710495c83.png" width="1000"></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 方向相反的流量以相反的顺序经过相同的步骤。 </font></font><br><br><ol><li>     VNGW1 </li><li>   ,      ,      Tunnel1 (MPLSoGRE  MPLSoUDP). </li><li> ,   MPLS,  GRE/UDP   IP     ToR3 10.0.255.1. <br>    — IP- vRouter',      — 10.0.0.2. </li><li>       vRouter'. </li><li>  vRouter  GRE/UDP,  MPLS-      IP-   TAP-,   eth0 . </li></ol><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d4d/f49/892/d4df4989216a42c06343ba883b8f5db2.png" width="1000"></a> <br><br><br><h4> Control Plane </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VNGW1与SDN控制器建立BGP邻居，从该BGP邻居接收有关客户端的所有路由信息：哪个IP地址（vRouter）用于标识哪个客户端以及与之标识的MPLS标签。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样，他本人用该客户端的标签告诉SDN控制器默认路由，表示自己为nexthop。然后，此默认设置为vRouter'y。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VNGW通常会路由聚合或NAT转换。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而在相反的方向上，他恰好将这条汇总路线提供给与寄宿生或路线反射者的会议。然后从他们那里接收默认路由或“全屏”或其他内容。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在封装和流量交换方面，VNGW与vRouter并无不同。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果稍微扩展一下区域，则可以将其他网络设备添加到VNGW和vRouter中，例如防火墙，流量净化或扩充服务器场，IPS等。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">借助连续创建VRF和正确通告路由的帮助，您可以根据需要使流量循环，这称为服务链。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，这里的SDN控制器充当VNGW，vRouter'ami和其他网络设备之间的路由反射器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但实际上，控制器还会发布有关ACL和PBR（基于策略的路由）的信息，从而迫使各个流量流与路由指示的流向不同。</font></font><br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/917/7f6/97a/9177f697a1ff4a7560153286ac04f287.png" width="1000"></a> <br><br><hr><br><br><h1> 常见问题 </h1><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么总是执行GRE / UDP注释？</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，通常来说，它可以说是特定于钨纤维的-您可以完全忽略它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果您采用它，那么TF本身（尽管仍然是OpenContrail）仍支持两种封装：GRE中的MPLS和UDP中的MPLS。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDP很好，因为在其标头中的“源端口”中，从原始IP + Proto +端口编码哈希函数非常容易，这将实现平衡。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遗憾的是，对于GRE而言，只有外部IP和GRE标头对于所有封装的流量都是相同的，并且没有关于平衡的讨论-很少有人可以看到数据包内部如此之深。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直到某个时候，如果路由器知道如何使用动态隧道，那么它们只能在MPLSoGRE中使用，而直到最近才在MPLSoUDP中学习。因此，您始终必须对两种不同封装的可能性进行说明。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">公平地说，值得注意的是，TF完全支持使用VXLAN的L2连接。</font></font><br><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您答应与OpenFlow相似。</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他们真的在乞求。在同一OpenStack中的vSwitch使用VXLAN做非常相似的事情，顺便说一下，它还具有UDP标头。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在数据平面中，它们的工作原理大致相同，而控制平面则有很大不同。 Tungsten Fabric使用XMPP将路由信息传递到vRouter，而Openflow在OpenStack中工作。</font></font><br><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我可以进一步了解vRouter吗？</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它分为两部分：vRouter代理和vRouter转发器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个在主机OS的用户空间中启动，并与SDN控制器通信，交换有关路由，VRF和ACL的信息。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二种实现Data Plane-通常在内核空间中，但也可以在SmartNIC上启动-具有CPU和单独的可编程交换芯片的网卡，这使您可以减轻主机CPU的负担，并使网络更快，更可预测。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当vRouter是用户空间中的DPDK应用程序时，另一种情况是可能的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vRouter代理会丢弃vRouter转发器上的设置。</font></font><br><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么是虚拟网络？</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我在有关VRF的文章开头提到，每个租户都附加到其VRF。并且如果这足以使您对覆盖网络的工作有一个肤浅的了解，那么在下一次迭代中就必须进行澄清。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，在虚拟化机制中，虚拟网络实体（您可以使用专有名称）是与客户端/租户/虚拟机分开引入的-这是非常独立的。并且通过接口的此虚拟网络已经可以在一个租户中连接，在另一个租户中以两个租户连接，但至少要在何处连接。因此，例如，当需要按所需顺序将流量通过某些节点时，可以实施服务链，只需按正确的顺序创建和调用虚拟网络即可。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，因此，虚拟网络与租户之间没有直接对应关系。</font></font><br><br><hr><br><br><h1> 结论 </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是对虚拟网络操作的非常肤浅的描述，其中包含主机和SDN控制器的覆盖。但是，无论您今天使用哪种虚拟化平台，它都将以类似的方式工作，无论是VMWare，ACI，OpenStack，CloudStack，Tungsten Fabric还是Juniper Contrail。它们在封装类型和标头，向终端网络设备传递信息的协议方面会有所不同，但是在相对简单和静态的底层网络之上工作的软件调整的覆盖网络的原理将保持不变。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以说，到目前为止，基于覆盖网络的SDN在创建私有云的领域中赢了。</font><font style="vertical-align: inherit;">但是，这并不意味着Openflow在现代世界中没有地位-据我所知，Google在OpenStacke和同一VMWare NSX中使用了Openflow来配置底层网络。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您想更深入地研究该问题，下面我提供了指向更详细资料的链接。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么是我们的参考底图？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但总的来说，什么都没有。</font><font style="vertical-align: inherit;">他没有一路改变。</font><font style="vertical-align: inherit;">在主机覆盖的情况下，他要做的就是在vRouter / VNGW出现和消失以及在它们之间拖动数据包时更新路由和ARP。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们制定一个底层网络的需求列表。</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为了能够使用某些路由协议，在我们的情况下-BGP。 </font></font></li><li>   ,   ,     - . </li><li>  ECMP —   . </li><li>   QoS,     ,  ECN. </li><li>  NETCONF —   . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我在这里只花了很少的时间来进行Underlay网络本身的工作。</font><font style="vertical-align: inherit;">这是因为在本系列的后续文章中，我将重点介绍它，并且我们只会在通过时才涉及叠加。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然，我严格地限制了我们所有人，以在Klose工厂建立的DC网络为例，它具有纯IP路由和来自主机的覆盖。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，我确信任何具有设计的网络都可以用正式术语来描述和自动化。</font><font style="vertical-align: inherit;">只是我追求的目标是了解自动化方法，而不是让所有人困惑，以一般方式解决问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为ADSM的一部分，我和Roman Gorge计划发布有关计算能力虚拟化及其与网络虚拟化的交互作用的单独问题。</font><font style="vertical-align: inherit;">保持联系。</font></font><br><br><br><h1> 有用的链接 </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">钨纤维建筑</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于：云</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">关于Yandex.Cloud的6个小时，TF上的虚拟网络也受到影响。</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">什么是Open vSwitch？</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VxLAN简介</a> 。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC7348。虚拟可扩展局域网（VXLAN）：用于在第3层网络上覆盖虚拟化的第2层网络的框架。</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VXLAN EVPN Fabric的Scaleway方法</a> 。 它讲述了DC的整个网络，包括Underlay，Overlay，多宿主和管理方法。 </li></ul><br><h5> 谢谢啦 </h5><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Roman Gorge</a> ，linkmeup播客的前主持人，现在是云平台领域的专家。 用于评论和编辑。 好吧，我们期待在不久的将来有一篇关于虚拟化的更深入的文章。 </li><li> 我的同事，虚拟网络开发专家<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Alexander Shalimov</a> 。 用于评论和编辑。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Valentina Sinitsyna</a> ，我的同事兼钨面料专家。 用于评论和编辑。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Artyom Chernobay-</a>插画家linkmeup。 对于KDPV。 </li><li> 亚历山大·利蒙诺夫（Alexander Limonov）。 对于模因“自动机”。 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458622/">https://habr.com/ru/post/zh-CN458622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458604/index.html">为什么两家最大的电子制造商联手开展新的GPU项目</a></li>
<li><a href="../zh-CN458606/index.html">在2秒钟内在Docker中运行OpenVPN</a></li>
<li><a href="../zh-CN458608/index.html">Node.js开发人员工具 作业队列</a></li>
<li><a href="../zh-CN458612/index.html">宇宙 7年</a></li>
<li><a href="../zh-CN458614/index.html">创建一个Reactive UsePosition（）挂钩以获取和跟踪浏览器坐标</a></li>
<li><a href="../zh-CN458624/index.html">我们如何学习在画布上绘制文字</a></li>
<li><a href="../zh-CN458626/index.html">StealthWatch：基本概念和最低要求。 第一部分</a></li>
<li><a href="../zh-CN458630/index.html">我16年间在纯Windows Forms + C＃上开发游戏的一段小历史</a></li>
<li><a href="../zh-CN458632/index.html">真正输入vue</a></li>
<li><a href="../zh-CN458634/index.html">“不作恶”或Facebook对我们隐藏的内容</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>