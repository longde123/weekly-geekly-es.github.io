<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☠️ 🛫 ✊🏽 我们如何在Unity中优化脚本 🎪 👩🏿 😎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="有许多出色的Unity性能文章和教程。 我们不打算用本文替代或改进它们，这只是我们阅读这些文章后所采取的步骤的简要摘要，以及使我们能够解决问题的步骤。 我强烈建议您至少在https://learn.unity.com/上学习材料。 

 在开发游戏的过程中，我们遇到了一些问题，这些问题有时会导致游戏...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们如何在Unity中优化脚本</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481980/"> 有许多出色的Unity性能文章和教程。 我们不打算用本文替代或改进它们，这只是我们阅读这些文章后所采取的步骤的简要摘要，以及使我们能够解决问题的步骤。 我强烈建议您至少在<a href="https://learn.unity.com/">https://learn.unity.com/上</a>学习材料。 <br><br> 在开发游戏的过程中，我们遇到了一些问题，这些问题有时会导致游戏过程受到阻碍。 在Unity Profiler中花了一些时间之后，我们发现了两种类型的问题： <br><br><ul><li> 未优化的着色器 </li><li>  C＃中未优化的脚本 </li></ul><br> 大多数问题是由第二组引起的，所以我决定在本文中重点介绍C＃脚本（也许还因为我一生中没有编写任何着色器）。 <br><br><h1> 寻找弱点 </h1><br> 本文的目的不是编写有关使用事件探查器的教程； 我只是想谈一谈我们在分析过程中主要感兴趣的内容。 <br><br>  <strong>Unity Profiler始终是</strong>找出脚本延迟原因<strong>的最佳方法</strong> 。 我强烈建议<strong>直接在设备</strong>中而不是在编辑器中<strong>对游戏进行性能分析</strong> 。 由于我们的游戏是为iOS创建的，因此我需要连接设备并使用图像中所示的“构建设置”，然后探查器自动连接。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c7/fad/0e0/5c7fad0e0596f91c183a80ea3d72d1ae.png"></div><br>  <em>构建配置文件进行分析</em> <br><br> 如果您尝试通过Google搜索“ Unity中的随机滞后”或其他类似请求，就会发现大多数人建议您<strong>专注于垃圾收集</strong> ，这正是我所做的。 每次您停止使用某个对象（类实例）时都会生成垃圾，此后，Unity垃圾收集器会不时启动以清理混乱并释放内存，这会耗费大量时间并导致帧速率下降。 <br><a name="habracut"></a><br><h2> 如何在探查器中找到垃圾脚本？ </h2><br> 只需选择CPU使用率-&gt;选择层次结构视图-&gt;按GC Alloc排序 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/aed/605/167aed6059ad0276a4275d5edf2179db.png"></div><br>  <em>垃圾收集的探查器选项</em> <br><br> 您的任务是在游戏场景的GC分配列中获得一些零。 <br><br> 另一个好的方法是<strong>按时间ms</strong> （运行时） <strong>对条目</strong>进行<strong>排序</strong>并优化脚本，以使它们花费的时间尽可能少。 这一步对我们产生了巨大的影响，因为其中一个组件包含一个<strong>大的for循环</strong> ，该<strong>循环</strong>要花很长时间才能完成（是的，我们还没有找到摆脱循环的方法），因此优化所有脚本的执行时间对我们来说绝对必要，因为我们需要在昂贵的for循环中节省运行时间，同时保持60 fps的稳定频率。 <br><br> 根据概要分析数据，我将优化分为两部分： <br><br><ul><li> 垃圾处理 </li><li> 缩短交货时间 </li></ul><br><h1> 第1部分：战斗垃圾 </h1><br> 在这一部分中，我将告诉您我们为摆脱垃圾所做的工作。 这是任何开发人员都应该理解的最基本的知识； 在每个合并/合并请求中，它们已成为我们日常分析的重要组成部分。 <br><br><h2> 第一条规则：Update方法中没有新对象 </h2><br> 理想情况下， <strong>Update，FixedUpdate和LateUpdate方法不应包含“ new”关键字</strong> 。 您应该始终使用现有的资源。 <br><br> 有时在某些内部Unity方法中<strong>隐藏</strong>了<strong>创建新对象的过程</strong> ，因此它并不是那么明显。 我们稍后再讨论。 <br><br><h2> 第二条规则：一次创建并重用！ </h2><br> 本质上，这意味着您应该为Start和Awake方法中可以使用的所有内容分配内存。 此规则与第一个规则非常相似。 实际上，这只是从Update方法中消除“ new”关键字的另一种方法。 <br><br> 代码如下： <br><br><ul><li> 创建新实例 </li><li> 寻找任何游戏对象 </li></ul><br> 您应该始终尝试从Update方法转到Start或Awake。 <br><br> 以下是我们所做更改的示例： <br><br> 在Start方法中为列表分配内存，清除（清除）并在必要时重新使用。 <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code private List&lt;GameObject&gt; objectsList; void Update() { objectsList = new List&lt;GameObject&gt;(); objectsList.Add(......) } //Better Code private List&lt;GameObject&gt; objectsList; void Start() { objectsList = new List&lt;GameObject&gt;(); } void Update() { objectsList.Clear(); objectsList.Add(......) }</span></span></code> </pre> <br> 存储链接并重新使用它们，如下所示： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Update() { var levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); foreach(var obstacle in levelObstacles) { ....... } } //Better code private Object[] levelObstacles; void Start() { levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); } void Update() { foreach(var obstacle in levelObstacles) { ....... } }</span></span></code> </pre> <br> 这同样适用于FindGameObjectsWithTag方法或其他任何返回新数组的方法。 <br><br><h2> 第三条规则：当心字符串，避免串联它们 </h2><br> 当涉及到创建垃圾时，这些行很糟糕。 即使是最简单的字符串操作也会造成大量垃圾。 怎么了 字符串只是数组，而这些数组是不可变的。 这意味着每次连接两行时，都会创建一个新数组，而旧数组会变成垃圾。 幸运的是，可以使用StringBuilder来避免或减少此类垃圾的产生。 <br><br> 这是如何改善情况的示例： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Start() { text = GetComponent&lt;Text&gt;(); } void Update() { text.text = "Player " + name + " has score " + score.toString(); } //Better code void Start() { text = GetComponent&lt;Text&gt;(); builder = new StringBuilder(50); } void Update() { //StringBuilder has overloaded Append method for all types builder.Length = 0; builder.Append("Player "); builder.Append(name); builder.Append(" has score "); builder.Append(score); text.text = builder.ToString(); }</span></span></code> </pre> <br> 上面显示的示例一切都很好，但是仍有许多改进代码的可能性。 如您所见，几乎整个字符串都可以视为静态字符串。 我们将字符串分为两个UI.Text对象的两部分。 首先，一个仅包含静态文本<strong>“ Player” +名称+“具有分数”</strong> ，可以在Start方法中分配该静态文本，第二个包含分数值，该分数在每帧中都会更新。  <strong>始终使静态线真正静态，并以Start或Awake方法生成它们</strong> 。 进行此改进之后，几乎一切都井井有条，但是在调用Int.ToString（），Float.ToString（）等时仍然会产生一些垃圾。 <br><br> 我们通过为所有可能的行生成并预分配内存来解决此问题。 这似乎是对内存的愚蠢浪费，但是这种解决方案非常适合我们的需求并完全解决了问题。 因此，最后，我们获得了一个静态数组，可以使用索引直接访问该数组，并采用表示数字的所需字符串： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] NUMBERS_THREE_DECIMAL = { <span class="hljs-string"><span class="hljs-string">"000"</span></span>, <span class="hljs-string"><span class="hljs-string">"001"</span></span>, <span class="hljs-string"><span class="hljs-string">"002"</span></span>, <span class="hljs-string"><span class="hljs-string">"003"</span></span>, <span class="hljs-string"><span class="hljs-string">"004"</span></span>, <span class="hljs-string"><span class="hljs-string">"005"</span></span>, <span class="hljs-string"><span class="hljs-string">"006"</span></span>,..........</code> </pre> <br><h2> 第四条规则：访问方法返回的缓存值 </h2><br> 这可能非常困难，因为即使是如下所示的简单访问器方法，也会产生垃圾： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void Update() { gameObject.tag; //or gameObject.name; }</span></span></code> </pre> <br> 尝试避免在Update方法中使用访问方法。 在Start方法中仅调用一次访问方法，并缓存返回值。 <br><br> 通常，我建议<strong>不要在Update方法中调用任何字符串访问方法或数组访问方法</strong> 。 在大多数情况下， <strong>只需在Start方法中获取链接即可</strong> 。 <br><br> 这是另一个未优化的访问方法代码的两个更常见的示例： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void Update() { //Allocates new array containing all touches Input.touches[0]; } //Better Code void Update() { Input.GetTouch(0); } //Bad Code void Update() { //Returns new string(garbage) and compare the two strings gameObject.Tag == "MyTag"; } //Better Code void Update() { gameObject.CompareTag("MyTag"); }</span></span></code> </pre> <br><h2> 第五条规则：使用不分配内存的函数 </h2><br> 对于某些Unity功能，可以找到非内存替代方案。 在我们的案例中，所有这些功能都与物理学有关。 我们的碰撞识别基于 <br><br><pre> <code class="cs hljs">Physics2D. CircleCast();</code> </pre> <br> 对于这种特殊情况，您可以找到一个名为 <br><br><pre> <code class="cs hljs">Physics2D. CircleCastNonAlloc();</code> </pre> <br> 许多其他功能也有类似的替代方法，因此请<strong>始终查看NonAlloc功能的文档</strong> 。 <br><br><h2> 第六条规则：不要使用LINQ </h2><br> 只是不要这样做。 我的意思是，您不需要在经常运行的任何代码中使用它。 我知道使用LINQ时，代码更易于阅读，但是在许多情况下，此类代码的性能和内存分配都很糟糕。 当然，有时可以使用它，但是老实说，在我们的游戏中，我们根本不使用LINQ。 <br><br><h2> 第七条规则：创建一次然后重用，第2部分 </h2><br> 这次我们谈论的是池化对象。 我将不讨论池的详细信息，因为已经说过很多次了，例如，学习本教程： <a href="https://learn.unity.com/tutorial/object-pooling">https</a> : <a href="https://learn.unity.com/tutorial/object-pooling">//learn.unity.com/tutorial/object-pooling</a> <br><br> 在我们的例子中，使用以下对象池脚本。 我们生成的关卡充满了在一定时间内存在的障碍，直到玩家通过关卡的这一部分。 如果满足某些条件，则会从预制件中创建此类障碍的实例。 该代码在Update方法中。 就内存和运行时而言，此代码完全无效。 我们通过生成40个障碍物的池来解决该问题：如有必要，我们从池中获取障碍物，并在不再需要该对象时将其返回到池中。 <br><br><h2> 第八条规则：更专注于包装转换（拳击）！ </h2><br> 拳击产生垃圾！ 但是什么是拳击？ 通常，将值类型（int，float，bool等）传递给期望对象类型为Object的函数时，就会发生装箱。 <br><br> 这是我们需要在项目中修复的拳击示例： <br><br> 我们在项目中实现了自己的消息传递系统。 每条消息可以包含无限量的数据。 数据存储在定义如下的字典中： <br><br><pre> <code class="cs hljs">Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; data;</code> </pre> <br> 我们还有一个设置器，用于设置此字典中的值： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Action </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> attribute, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { data[attribute] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; }</code> </pre> <br> 这里的拳击非常明显。 您可以按以下方式调用该函数： <br><br><pre> <code class="cs hljs">SetAttribute(<span class="hljs-string"><span class="hljs-string">"my_int_value"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>);</code> </pre> <br> 然后对值“ 12”进行装箱并生成垃圾。 <br><br> 我们通过为每种原始类型创建单独的数据容器来解决该问题，并且以前的Object容器仅用于引用类型。 <br><br><pre> <code class="cs hljs">Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; data; Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; dataBool; Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; dataInt; .......</code> </pre> <br> 对于每种数据类型，我们还有单独的设置器： <br><br><pre> <code class="cs hljs">SetBoolAttribute(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) SetIntAttribute(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)</code> </pre> <br> 所有这些设置器的实现方式都使它们调用相同的通用函数： <br><br><pre> <code class="cs hljs">SetAttribute&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, T&gt; dict, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, T <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)</code> </pre> <br> 拳击问题已经解决！ <br><br> 在文章<a href="https://docs.microsoft.com/cs-cz/dotnet/csharp/programming-guide/types/boxing-and-unboxing">https://docs.microsoft.com/cs-cz/dotnet/csharp/programming-guide/types/boxing-and-unboxing中</a>阅读有关此内容的更多信息。 <br><br><h2> 第九条规则：周期总是令人怀疑 </h2><br> 该规则与第一和第二非常相似。 出于性能和内存原因，只需尝试从循环中删除所有可选代码。 <br><br> 在一般情况下，我们努力摆脱Update方法中的循环，但是如果我们不能没有循环，那么我们至少将避免在此类循环中分配任何内存。 因此，请遵循<strong>规则1–8，并将其应用于</strong>一般的<strong>循环</strong> ，而不仅仅是Update方法。 <br><br><h2> 规则10：外部库中无垃圾 </h2><br> 如果发现部分垃圾是由从资产存储下载的代码生成的，那么此问题有许多解决方案。 但是在进行逆向工程和调试之前，只需返回到Asset存储并更新库。 在我们的案例中，所有使用的资产仍得到作者的支持，他们继续发布可改善性能的更新，因此这解决了我们所有的问题。  <strong>依赖性必须相关！</strong> 我宁愿摆脱图书馆，也不愿不受支持。 <br><br><h1> 第2部分：最大化运行时间 </h1><br> 如果很少调用该代码，则上述某些规则会有细微的差别。 我们的代码在每个框架中运行一个大循环，因此即使这些小的更改也会产生巨大的影响。 <br><br> 如果使用不当或在错误的情况下使用其中的某些更改，可能会导致运行时间更糟。  <strong>在代码中输入每个优化之后，请始终检查探查器，以确保您朝正确的方向移动</strong> 。 <br><br> 老实说，其中一些<strong>规则导致可读性差得多的代码</strong> ，有时甚至<strong>违反建议</strong> ，例如，以下规则之一提到的代码嵌入。 <br><br> 其中许多规则与本文第一部分中介绍的规则重叠。 通常，与没有垃圾生成的代码相比，垃圾生成代码的性能较低。 <br><br><h2> 第一条规则：正确的执行顺序 </h2><br>  <strong>将代码从FixedUpdate，Update，LateUpdate方法移动到Start和Awake方法</strong> 。 我知道这听起来很疯狂，但是请相信我，如果您深入研究代码，会发现数百行代码可以移至只能执行一次的方法。 <br><br> 就我们而言，此代码通常与 <br><br><ul><li> 调用GetComponent &lt;&gt; </li><li> 在每一帧中实际返回相同结果的计算 </li><li> 同一对象的多个实例，通常列出 </li><li> 搜索游戏对象 </li><li> 获取到Transform的链接并使用其他访问方法 </li></ul><br> 这是我们从Update方法移动到Start方法的示例代码列表： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//There must be a good reason to keep GetComponent in Update gameObject.GetComponent&lt;LineRenderer&gt;(); gameObject.GetComponent&lt;CircleCollider2D&gt;(); //Examples of calculations returning same result every frame Mathf.FloorToInt(Screen.width / 2); var width = 2f * mainCamera.orthographicSize * mainCamera.aspect; var castRadius = circleCollider.radius * transform.lossyScale.x; var halfSize = GetComponent&lt;SpriteRenderer&gt;().bounds.size.x / 2f; //Finding objects var levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); var levelCollectibles = FindGameObjectsWithTag("COLLECTIBLE"); //References objectTransform = gameObject.transform; mainCamera = Camera.main;</span></span></code> </pre> <br><h2> 第二条规则：仅在必要时执行代码 </h2><br> 在我们的案例中，这主要与UI更新脚本有关。 这是我们如何更改代码实现的示例，该代码在级别上显示收集到的项目的当前状态。 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code Text text; GameState gameState; void Start() { gameState = StoreProvider.Get&lt;GameState&gt;(); text = GetComponent&lt;Text&gt;(); } void Update() { text.text = gameState.CollectedCollectibles.ToString(); }</span></span></code> </pre> <br> 由于在每个级别仅收集少量项目，因此更改每个框架中的UI文本没有任何意义。 因此，我们仅在数字更改时才更改文本。 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Better code Text text; GameState gameState; int collectiblesCount; void Start() { gameState = StoreProvider.Get&lt;GameState&gt;(); text = GetComponent&lt;Text&gt;(); collectiblesCount = gameState.CollectedCollectibles; } void Update() { if(collectiblesCount != gameState.CollectedCollectibles) { //This code is ran only about 5 times each level collectiblesCount = gameState.CollectedCollectibles; text.text = collectiblesCount.ToString(); } }</span></span></code> </pre> <br> 这段代码要好得多，特别是如果操作比仅更改UI要复杂得多时。 <br><br> 如果您正在寻找更全面的解决方案，我建议使用C＃事件（ <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/">https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/events/</a> ）来实现<a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer模板</a> 。 <br><br> 无论如何，对于我们来说这还不够，我们想实现一个完全通用的解决方案，因此我们创建了一个在Unity中实现<a href="https://facebook.github.io/flux/">Flux</a>的库。 这导致了一个非常简单的解决方案，其中将游戏的整个状态存储在“ Store”对象中，并且在状态更改时通知所有UI元素和其他组件，并且无需Update方法中的代码即可对此更改做出反应。 <br><br><h2> 第三条规则：周期总是令人怀疑 </h2><br> 这与我在本文的第一部分中提到的规则完全相同。 如果代码中有一个循环迭代地绕过大量元素的循环，则为了提高循环性能，请使用本文两部分的两条规则。 <br><br><h2> 第四条规则：胜于雄辩 </h2><br>  Foreach循环很容易编写，但是执行起来“非常困难”。 在Foreach循环内，Enumerator用于迭代处理数据集并返回值。 这比在简单的For循环中遍历索引更为复杂。 <br><br> 因此，在我们的项目中，我们尽可能将Foreach循环替换为For： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code foreach (GameObject obstacle in obstacles) //Better code var count = obstacles.Count; for (int i = 0; i &lt; count; i++) { obstacles[i]; }</span></span></code> </pre> <br> 在我们的for循环较大的情况下，此更改非常重要。  <strong>一个简单的for循环可使代码加速两次</strong> 。 <br><br><h2> 第五条规则：数组比列表更好 </h2><br> 在我们的代码中，我们发现大多数列表都是固定长度的，或者我们可以计算最大元素数。 因此，我们基于数组重新实现了它们，在某些情况下，这导致对数据进行迭代的速度加快了两倍。 <br><br> 在某些情况下，无法避免列表或其他复杂的数据结构。 碰巧您经常必须添加或删除元素，在这种情况下，最好使用列表。 但通常， <strong>数组应始终用于定长列表</strong> 。 <br><br><h2> 第六条规则：浮动操作优于矢量操作 </h2><br> 如果您不执行数千个这样的操作（在我们的案例中就是这种情况），则这种差异几乎不会引起注意，因此对我们而言，生产率的提高被认为是巨大的。 <br><br> 我们进行了类似的更改： <br><br><pre> <code class="cs hljs">Vector3 pos1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); Vector3 pos2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-comment"><span class="hljs-comment">//Bad code var pos3 = pos1 + pos2; //Better code var pos3 = new Vector3(pos1.x + pos2.x, pos1.y + pos2.y, ......); Vector3 pos1 = new Vector3(1,2,3); //Bad code var pos2 = pos1 * 2f; //Better code var pos2 = new Vector3(pos1.x * 2f, pos1.y * 2f, ......);</span></span></code> </pre> <br><h2> 第七条规则：正确寻找物体 </h2><br> 始终考虑一下是否真的需要使用GameObject.Find（）方法。 这种方法很重并且要花费大量的时间。 您永远不要在Update方法中使用此方法。 我们发现，我们的大多数Find调用都可以<strong>在编辑器中替换为直接链接</strong> ，这当然更好。 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code GameObject player; void Start() { player = GameObject.Find("PLAYER"); } //Better Code //Assign the reference to the player object in editor [SerializeField] GameObject player; void Start() { }</span></span></code> </pre> <br> 如果无法做到这一点，则至少<strong>考虑使用标签（Tag）并使用GameObject.FindWithTag通过其标签搜索对象</strong> 。 <br><br> 因此，在一般情况下： <strong>直接链接&gt; GameObject.FindWithTag（）&gt; GameObject.Find（）</strong> <br><br><h2> 第八条规则：仅适用于相关对象 </h2><br> 在我们的案例中，这对于使用RayCast-s（CircleCast等）识别碰撞非常重要。 无需识别冲突并确定其中哪些冲突在代码中很重要， <strong>我们将游戏对象移到了适当的层，</strong>这样我们就可以仅为必要的对象计算冲突。 <br><br> 这是一个例子 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void DetectCollision() { var count = Physics2D.CircleCastNonAlloc( position, radius, direction, results, distance); for (int i = 0; i &lt; count; i++) { var obj = results[i].collider.transform.gameObject; if(obj.CompareTag("FOO")) { ProcessCollision(results[i]); } } } //Better Code //We added all objects with tag FOO into the same layer void DetectCollision() { //8 is number of the desired layer var mask = 1 &lt;&lt; 8; var count = Physics2D.CircleCastNonAlloc( position, radius, direction, results, distance, mask); for (int i = 0; i &lt; count; i++) { ProcessCollision(results[i]); } }</span></span></code> </pre> <br><h2> 第九条规则：正确使用标签 </h2><br> 毫无疑问，标签非常有用并且可以提高代码性能，但是请记住， <strong>只有一种正确的方法可以比较对象标签</strong> ！ <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code gameObject.Tag == "MyTag"; //Better Code gameObject.CompareTag("MyTag");</span></span></code> </pre> <br><h2> 第十规则：当心用相机的把戏！ </h2><br> 使用<strong>Camera.main</strong>非常容易，但是此操作的性能非常差。 原因是在每次调用Camera.main的幕后，Unity引擎实际上执行了FindGameObjectsWithTag（）结果，因此我们已经知道您不需要经常调用它，最好通过<strong>在Start方法中缓存链接</strong>来解决此问题。还是醒着 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Update() { Camera.main.orthographicSize //Some operation with camera } //Better Code private Camera cam; void Start() { cam = Camera.main; } void Update() { cam.orthographicSize //Some operation with camera }</span></span></code> </pre> <br><h2> 第十一条规则：LocalPosition比位置更好 </h2><br>  <strong>尽可能将Transform.LocalPosition用于getter和setter而不是Transform.Position</strong> 。 在每个Transform.Position调用中，执行更多操作，例如，在getter调用的情况下计算全局位置，在setter调用的情况下从全局计算局部位置。 在我们的项目中，事实证明您可以在99％的情况下使用Transform.Position使用LocalPositions，而无需在代码中进行任何其他更改。 <br><br><h2> 第十二条规则：不要使用LINQ </h2><br> 在第一部分中已经对此进行了讨论。 只是不使用它，仅此而已。 <br><br><h2> 第十三条规则：不要害怕（有时）违反规则 </h2><br> 有时，甚至调用一个简单函数也可能太昂贵。 在这种情况下，您应该始终考虑嵌入代码（代码内联）。 这是什么意思？ 实际上，我们只是从函数中获取代码，然后将其直接复制到我们要使用该函数的位置，以避免调用其他方法。 <br><br> 在大多数情况下，这不会产生任何效果，因为代码的嵌入是在编译阶段自动执行的，但是编译器通过某些规则来决定是否嵌入代码（例如，从不嵌入虚拟方法;有关更多详细信息，请参见<a href="https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity8.html">https： //docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity8.html</a> ）。 因此，只需打开事件探查器，在目标设备上启动游戏，看看是否可以改进。 <br><br> 在我们的案例中，我们决定集成一些功能来提高性能，尤其是在大型for循环中。 <br><br><h1> 结论 </h1><br> 应用本文中列出的规则，即使在iPhone 5S上，我们也可以轻松地在iOS游戏中获得稳定的60 fps。 也许某些规则可能仅特定于我们的项目，但是我认为在编写代码或检查代码时应记住大多数规则，以避免将来出现问题。 始终根据性能不断编写代码总是比以后重构大型代码更好。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN481980/">https://habr.com/ru/post/zh-CN481980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN481960/index.html">2.弹性堆栈：分析安全日志。 Logstash</a></li>
<li><a href="../zh-CN481964/index.html">如何组织发布</a></li>
<li><a href="../zh-CN481970/index.html">“被遗忘的音频格式和媒体”：紧凑音频时代的开始或筒管的“首次变革”</a></li>
<li><a href="../zh-CN481974/index.html">使用神经网络测试西瓜：完整版。 从原型到应用程序的循环。 在Google Play</a></li>
<li><a href="../zh-CN481978/index.html">如何组织分布式布局团队的有效工作</a></li>
<li><a href="../zh-CN481988/index.html">为什么Koji是新手KaiOS应用创建者的理想资源</a></li>
<li><a href="../zh-CN481990/index.html">恶意软件十年：2010年最大的僵尸网络</a></li>
<li><a href="../zh-CN481992/index.html">Tekton管道-Kubernetes原生管道</a></li>
<li><a href="../zh-CN481996/index.html">周末哈布拉侦探2。新水平</a></li>
<li><a href="../zh-CN481998/index.html">图灵机，作为自动机程序的模型</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>