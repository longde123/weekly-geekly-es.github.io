<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋🏽 🌒 🖕🏽 Kami telah mempercepat penjadwal Tokio sepuluh kali 🤽🏽 👨‍🍳 🕴🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami sedang dalam proses mempersiapkan versi utama Tokio berikutnya, lingkungan runtime asinkron untuk Rust. Pada 13 Oktober, permintaan kumpulan deng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami telah mempercepat penjadwal Tokio sepuluh kali</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472242/"> Kami sedang dalam proses mempersiapkan versi utama Tokio berikutnya, lingkungan runtime asinkron untuk Rust.  Pada 13 Oktober, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan kumpulan</a> dengan penjadwal tugas yang ditulis ulang sepenuhnya dikeluarkan untuk bergabung ke cabang.  Hasilnya adalah peningkatan kinerja yang sangat besar dan latensi yang berkurang.  Beberapa tes mencatat percepatan sepuluh kali lipat!  Seperti biasa, tes sintetik tidak mencerminkan manfaat aktual dalam kenyataan.  Karena itu, kami juga memeriksa bagaimana perubahan pada penjadwal memengaruhi tugas nyata, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hyper</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tonic</a> (spoiler: hasilnya luar biasa). <br><br>  Bersiap untuk bekerja pada perencana baru, saya menghabiskan waktu mencari sumber daya tematik.  Terlepas dari implementasi yang sebenarnya, tidak ada yang istimewa yang ditemukan.  Saya juga menemukan bahwa kode sumber untuk implementasi yang ada sulit dinavigasi.  Untuk mengatasinya, kami mencoba menulis sheduler Tokio sebersih mungkin.  Saya harap artikel terperinci tentang implementasi penjadwal ini akan membantu mereka yang berada di posisi yang sama dan tidak berhasil mencari informasi tentang topik ini. <br><br>  Artikel ini dimulai dengan tinjauan desain tingkat tinggi, termasuk kebijakan penangkapan pekerjaan.  Kemudian selami rincian optimasi khusus dalam penjadwal Tokio baru. <br><a name="habracut"></a><br>  Optimasi yang dipertimbangkan: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Std baru :: sistem tugas masa depan</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memilih algoritma antrian terbaik</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Streamline Templat Pesan</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengambilan throttle</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kurangi sinkronisasi antar utas</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kurangi alokasi memori</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengurangi penghitungan tautan atom</a> </li></ul><br>  Seperti yang Anda lihat, tema utamanya adalah "pengurangan."  Bagaimanapun, kode tercepat adalah kekurangannya! <br><br>  Kami juga akan berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengujian penjadwal baru</a> .  Sangat sulit untuk menulis kode paralel yang benar tanpa kunci.  Lebih baik bekerja lambat, tetapi benar, daripada cepat, tetapi dengan gangguan, terutama jika bug berhubungan dengan keamanan memori.  Opsi terbaik, bagaimanapun, harus bekerja dengan cepat dan tanpa kesalahan, jadi kami menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat tenun</a> , alat pengujian konkurensi. <br><br>  Sebelum terjun ke topik, saya ingin mengucapkan terima kasih: <br><br><ul><li> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@withoutboats</a></b> dan lainnya yang mengerjakan fungsi <code>async / await</code> di Rust.  Anda melakukan pekerjaan dengan baik.  Ini adalah fitur pembunuh. <br></li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@cramertj</a></b> dan lainnya yang mengembangkan <code>std::task</code> .  Ini merupakan peningkatan besar dibandingkan sebelumnya.  Dan kode yang bagus. <br></li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buoyant</a></b> , pencipta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Linkerd,</a> dan yang lebih penting, atasan saya.  Terima kasih telah mengizinkan saya menghabiskan begitu banyak waktu untuk pekerjaan ini.  Jika ada yang tertarik dengan layanan mesh, lihat Linkerd.  Segera itu akan mencakup semua manfaat yang dibahas dalam artikel ini. <br></li><li>  <b><a href="">Pergi</a></b> untuk implementasi perencana yang baik. </li></ul><br>  Ambil secangkir kopi dan duduk.  Ini akan menjadi artikel yang panjang. <br><br><h1>  Bagaimana cara kerja perencana? </h1><br>  Tugas sheduler adalah merencanakan pekerjaan.  Aplikasi ini dibagi menjadi beberapa unit kerja, yang akan kita sebut <i>tugas</i> .  Suatu tugas dianggap runnable ketika dapat maju dalam pelaksanaannya, tetapi tidak lagi dilakukan atau dalam mode siaga, ketika itu dikunci pada sumber daya eksternal.  Tugas bersifat independen dalam arti bahwa sejumlah tugas dapat dilakukan secara bersamaan.  Penjadwal bertanggung jawab untuk menjalankan tugas dalam keadaan berjalan sampai mereka kembali ke mode siaga.  Eksekusi tugas menyiratkan menetapkan waktu prosesor untuk tugas - sumber daya global. <br><br>  Artikel ini membahas penjadwal ruang pengguna, yaitu, bekerja di atas utas sistem operasi (yang, pada gilirannya, dikendalikan oleh penjadwal level kernel).  Penjadwal Tokio mengeksekusi Rust futures, yang dapat dianggap sebagai "thread hijau asinkron."  Ini adalah pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">streaming campuran M: N</a> di mana banyak tugas antarmuka pengguna di-multiplex ke banyak utas sistem operasi. <br><br>  Ada banyak cara berbeda untuk mensimulasikan sheduler, masing-masing dengan pro dan kontra sendiri.  Pada tingkat paling dasar, penjadwal dapat dimodelkan sebagai <i>run antrian</i> dan <i>prosesor</i> yang menariknya terpisah.  Prosesor adalah bagian dari kode yang berjalan di utas.  Dalam kode semu, ia melakukan hal berikut: <br><br><pre> <code class="plaintext hljs">while let Some(task) = self.queue.pop() { task.run(); }</code> </pre> <br>  Ketika suatu tugas menjadi layak, itu dimasukkan ke dalam antrian eksekusi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff6/1f4/18f/ff61f418f73f08c62b5e9eaeacaeb8ed.png"><br><br>  Meskipun Anda dapat merancang sistem di mana sumber daya, tugas, dan prosesor ada di utas yang sama, Tokio lebih suka menggunakan beberapa utas.  Kita hidup di dunia di mana komputer memiliki banyak prosesor.  Pengembangan penjadwal single-threaded akan menyebabkan pemuatan besi yang tidak mencukupi.  Kami ingin menggunakan semua CPU.  Ada beberapa cara untuk melakukan ini: <br><br><ul><li>  Satu antrian eksekusi global, banyak prosesor. <br></li><li>  Banyak prosesor, masing-masing dengan menjalankan antrian sendiri. </li></ul><br><h3>  Satu putaran, banyak prosesor </h3><br>  Model ini memiliki satu antrian eksekusi global.  Ketika tugas menjadi selesai, mereka ditempatkan di ujung antrian.  Ada beberapa prosesor, masing-masing di utas terpisah.  Setiap prosesor mengambil tugas dari kepala antrian atau memblokir utas jika tidak ada tugas yang tersedia. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/85c/8d0/23d/85c8d023dfeba249bba01234e0e8783a.png"><br><br>  Garis eksekusi harus didukung oleh banyak produsen dan konsumen.  Biasanya daftar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">intrusif</a> digunakan, di mana struktur setiap tugas menyertakan pointer ke tugas berikutnya dalam antrian (alih-alih membungkus tugas dalam daftar tertaut).  Dengan demikian, alokasi memori untuk operasi push dan pop dapat dihindari.  Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">operasi push tanpa mengunci</a> , tetapi untuk mengoordinasikan konsumen, mutex diperlukan untuk operasi pop (secara teknis dimungkinkan untuk menerapkan antrian multi-pengguna tanpa mengunci). <br><br>  Namun, dalam praktiknya, overhead untuk perlindungan yang tepat terhadap kunci lebih dari sekadar menggunakan mutex. <br><br>  Pendekatan ini sering digunakan untuk thread pool tujuan umum, karena memiliki beberapa keuntungan: <br><br><ul><li>  Tugas cukup terencana. <br></li><li>  Implementasi yang relatif sederhana.  Antrian standar kurang lebih dihubungkan dengan siklus prosesor yang dijelaskan di atas. </li></ul><br>  Catatan singkat tentang perencanaan yang adil (adil).  Ini berarti bahwa tugas dilakukan dengan jujur: siapa pun yang datang lebih awal adalah orang yang pergi lebih awal.  Perencana tujuan umum mencoba bersikap adil, tetapi ada pengecualian, seperti paralelisasi melalui pertigaan, di mana kecepatan menghitung hasilnya, dan bukannya keadilan untuk setiap subtugas, merupakan faktor penting. <br><br>  Model ini memiliki kelemahan.  Semua prosesor melamar untuk tugas dari kepala antrian.  Untuk utas keperluan umum, ini biasanya bukan masalah.  Waktu untuk menyelesaikan tugas jauh melebihi waktu untuk mengambilnya dari antrian.  Ketika tugas dilakukan dalam jangka waktu yang lama, kompetisi dalam antrian berkurang.  Namun, tugas Karat asinkron diharapkan selesai dengan sangat cepat.  Dalam hal ini, biaya overhead untuk pertarungan dalam antrian meningkat secara signifikan. <br><br><h3>  Konkurensi dan simpati mekanis </h3><br>  Untuk mencapai kinerja maksimum, kita harus memaksimalkan fitur perangkat keras.  Istilah "simpati mekanis" untuk perangkat lunak pertama kali digunakan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Martin Thompson</a> (yang blognya tidak lagi diperbarui, tetapi masih sangat informatif). <br><br>  Diskusi rinci tentang penerapan paralelisme dalam peralatan modern berada di luar ruang lingkup artikel ini.  Secara umum, zat besi meningkatkan produktivitas bukan karena akselerasi, tetapi karena pengenalan sejumlah besar inti CPU (bahkan laptop saya memiliki enam!). Setiap core dapat melakukan komputasi dalam jumlah besar dalam interval waktu yang sangat kecil.  Tindakan seperti mengakses cache dan memori membutuhkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">waktu lebih banyak</a> dibandingkan waktu eksekusi pada CPU.  Karena itu, untuk mempercepat aplikasi, Anda perlu memaksimalkan jumlah instruksi CPU untuk setiap akses memori.  Meskipun kompiler banyak membantu, kita masih harus memikirkan hal-hal seperti penyelarasan dan pola akses memori. <br><br>  Utas terpisah secara terpisah bekerja sangat mirip dengan utas tunggal yang terisolasi, <b>hingga</b> beberapa utas secara bersamaan memodifikasi garis cache yang sama (mutasi bersamaan) atau diperlukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konsistensi yang konsisten</a> .  Dalam hal ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">protokol koherensi cache CPU</a> diaktifkan.  Ini menjamin relevansi cache dari setiap CPU. <br><br>  Kesimpulannya jelas: sejauh mungkin, hindari sinkronisasi antara utas, karena lambat. <br><br><h3>  Banyak prosesor, masing-masing dengan antrian eksekusi sendiri </h3><br>  Model lain adalah beberapa penjadwal single-threaded.  Setiap prosesor menerima antrian eksekusi sendiri, dan tugas diperbaiki pada prosesor tertentu.  Ini sepenuhnya menghindari masalah sinkronisasi.  Karena model tugas Rust memerlukan kemampuan untuk mengantri tugas dari utas apa pun, masih harus ada cara aman untuk memasukkan tugas ke penjadwal.  Baik antrian eksekusi dari masing-masing prosesor mendukung operasi push-safe-thread (MPSC), atau setiap prosesor memiliki <b>dua</b> antrian eksekusi: tidak tersinkronisasi dan aman-thread. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6d/a3c/35e/c6da3c35e7f6fb28b63fdb3ff6417882.png"><br><br>  Strategi ini menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seastar</a> .  Karena kita hampir sepenuhnya menghindari sinkronisasi, strategi ini memberikan kecepatan yang sangat baik.  Tapi dia tidak menyelesaikan semua masalah.  Jika beban kerja tidak sepenuhnya homogen, maka beberapa prosesor berada di bawah beban, sementara yang lain menganggur, yang mengarah pada penggunaan sumber daya yang tidak optimal.  Ini terjadi karena tugas diperbaiki pada prosesor tertentu.  Ketika sekelompok tugas direncanakan dalam satu paket pada satu prosesor, itu sendiri memenuhi beban puncak, bahkan jika yang lain menganggur. <br><br>  Sebagian besar beban kerja “nyata” tidak homogen.  Oleh karena itu, perencana tujuan umum biasanya menghindari model ini. <br><br><h3>  Penjadwal Pengambilan Pekerjaan </h3><br>  Penjadwal dengan penjadwalan pencurian-kerja didasarkan pada model penjadwalan berjuntai dan menyelesaikan masalah pemuatan sumber daya perangkat keras yang tidak lengkap.  Setiap prosesor mendukung antrian eksekusi sendiri.  Tugas-tugas yang menjadi dilakukan ditempatkan dalam antrian eksekusi prosesor saat ini, dan berfungsi di atasnya.  Tetapi ketika prosesor dalam keadaan diam, ia memeriksa antrian dari prosesor saudara perempuan dan mencoba untuk mengambil sesuatu dari sana.  Prosesor masuk ke mode tidur hanya setelah tidak dapat menemukan pekerjaan dari antrian eksekusi peer-to-peer. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/561/9a9/02c/5619a902c1d95252d20ac7db1273e57f.png"><br><br>  Pada level model, ini adalah pendekatan "terbaik dari kedua dunia".  Di bawah beban, prosesor bekerja secara independen, menghindari sinkronisasi overhead.  Dalam kasus di mana beban antara prosesor didistribusikan secara tidak merata, penjadwal dapat mendistribusikannya kembali.  Inilah sebabnya mengapa penjadwal tersebut digunakan dalam bahasa <a href="">Go</a> , <a href="">Erlang</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java,</a> dan lainnya. <br><br>  Kerugiannya adalah bahwa pendekatan ini jauh lebih rumit.  Algoritme antrian harus mendukung tangkapan pekerjaan, dan untuk kelancaran pelaksanaan <b>beberapa</b> sinkronisasi antara prosesor diperlukan.  Jika tidak diimplementasikan dengan benar, maka overhead untuk menangkap bisa lebih dari keuntungan. <br><br>  Pertimbangkan situasi ini: prosesor A sedang menjalankan tugas, dan memiliki antrian eksekusi yang kosong.  Prosesor B menganggur;  dia mencoba menangkap beberapa tugas, tetapi gagal, jadi dia beralih ke mode tidur.  Kemudian 20 tugas muncul dari tugas prosesor A.  Idealnya, prosesor B harus bangun dan mengambil beberapa dari mereka.  Untuk ini, perlu menerapkan heuristik tertentu dalam penjadwal, di mana prosesor memberi sinyal ke prosesor rekan tidur tentang penampilan tugas baru dalam antrian mereka.  Tentu saja, ini membutuhkan sinkronisasi tambahan, jadi operasi seperti itu sebaiknya diminimalkan. <br><br>  Singkatnya: <br><br><ul><li>  Semakin sedikit sinkronisasi, semakin baik. <br></li><li>  Job capture adalah algoritma optimal untuk perencana tujuan umum. <br></li><li>  Setiap prosesor bekerja secara independen dari yang lain, tetapi beberapa sinkronisasi diperlukan untuk menangkap pekerjaan. </li></ul><br><h1>  Penjadwal Tokio 0.1 </h1><br>  Penjadwal kerja pertama untuk Tokio dirilis pada Maret 2018.  Ini adalah upaya pertama, berdasarkan pada beberapa asumsi yang ternyata salah. <br><br>  Pertama, penjadwal Tokio 0.1 menyarankan agar utas prosesor harus ditutup jika tidak digunakan dalam waktu tertentu.  Penjadwal awalnya dibuat sebagai sistem "tujuan umum" untuk kumpulan thread Rust.  Pada saat itu, runtime Tokio masih pada tahap awal pengembangan.  Kemudian model mengasumsikan bahwa tugas I / O akan dilakukan pada utas yang sama dengan pemilih I / O (epoll, kqueue, iocp ...).  Lebih banyak tugas komputasi dapat diarahkan ke kumpulan utas.  Dalam konteks ini, konfigurasi fleksibel dari jumlah utas aktif diasumsikan, sehingga lebih masuk akal untuk menonaktifkan utas menganggur.  Namun, dalam penjadwal dengan tangkapan pekerjaan, model beralih untuk melakukan <i>semua</i> tugas asinkron, dan dalam hal ini masuk akal untuk selalu mempertahankan sejumlah kecil utas dalam keadaan aktif. <br><br>  Kedua, garis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">silang</a> dua arah diterapkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sana</a> .  Implementasi ini didasarkan pada jalur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chase-Lev dua arah</a> , dan tidak cocok untuk merencanakan tugas asinkron independen karena alasan yang dijelaskan di bawah ini. <br><br>  Ketiga, implementasinya ternyata terlalu rumit.  Ini sebagian disebabkan oleh fakta bahwa ini adalah penjadwal tugas pertama saya.  Selain itu, saya terlalu tidak sabar ketika menggunakan atom di cabang, di mana mutex akan baik-baik saja.  Pelajaran penting adalah bahwa sering kali mutex yang paling berhasil. <br><br>  Akhirnya, ada banyak kelemahan kecil dalam implementasi awal.  Pada tahun-tahun awal, detail implementasi dari model Rust asinkron berkembang secara signifikan, tetapi pustaka menjaga API stabil sepanjang waktu.  Ini menyebabkan akumulasi beberapa hutang teknis. <br><br>  Sekarang Tokio mendekati rilis besar pertama - dan kita dapat membayar semua hutang ini, serta belajar dari pengalaman yang diperoleh selama bertahun-tahun pembangunan.  Ini adalah waktu yang menyenangkan! <br><br><h1>  Penjadwal Tokio Generasi Selanjutnya </h1><br>  Sekarang saatnya untuk melihat lebih dekat apa yang telah berubah di penjadwal baru. <br><br><a name="1"></a><h3>  Sistem tugas baru </h3><br>  Pertama, penting untuk menyoroti apa yang <b>bukan</b> bagian dari Tokio, tetapi sangat penting dalam hal meningkatkan efisiensi: ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem tugas baru</a> di <code>std</code> , yang awalnya dikembangkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Taylor Kramer</a> .  Sistem ini menyediakan kait yang harus diimplementasikan oleh penjadwal untuk melakukan tugas-tugas Karat asinkron, dan sistem dirancang dan diimplementasikan dengan luar biasa.  Ini jauh lebih ringan dan lebih fleksibel daripada iterasi sebelumnya. <br><br>  Struktur <code>Waker</code> dari sumber daya menandakan bahwa ada tugas yang <i>layak</i> yang harus ditempatkan dalam antrian scheduler.  Dalam sistem tugas yang baru, ini adalah struktur dua-pointer, padahal sebelumnya jauh lebih besar.  Mengurangi ukuran penting untuk meminimalkan overhead menyalin nilai <code>Waker</code> di tempat yang berbeda, dan itu memakan lebih sedikit ruang dalam struktur, yang memungkinkan Anda untuk memasukkan lebih banyak data penting ke dalam garis cache.  Desain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vtable</a> membuat sejumlah optimasi, yang akan kita bahas nanti. <br><br><a name="2"></a><h3>  Memilih algoritma antrian terbaik </h3><br>  Antrian eksekusi berada di tengah-tengah penjadwal.  Oleh karena itu, ini adalah komponen yang paling penting untuk diperbaiki.  Penjadwal Tokio asli menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antrian balok</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">silang</a> dua arah: implementasi sumber tunggal (produsen) dan banyak konsumen.  Sebuah tugas ditempatkan di satu ujung, dan nilai diambil dari yang lain.  Sebagian besar waktu, utas “mendorong” nilai dari akhir antrian, tetapi kadang-kadang utas lain mencegat pekerjaan, melakukan operasi yang sama.  Antrian dua arah didukung oleh array dan serangkaian indeks yang melacak kepala dan ekor.  Ketika antrian penuh, pengenalan itu akan menyebabkan peningkatan ruang penyimpanan.  Array baru yang lebih besar dialokasikan, dan nilainya dipindahkan ke penyimpanan baru. <br><br>  Kemampuan untuk tumbuh dicapai melalui kompleksitas dan overhead.  Operasi push / pop harus memperhitungkan pertumbuhan ini.  Selain itu, membebaskan array asli penuh dengan kesulitan tambahan.  Dalam bahasa pengumpulan sampah (GC), array lama akan keluar dari ruang lingkup dan akhirnya GC akan menghapusnya.  Namun, kapal Rust tanpa GC.  Ini berarti bahwa kita sendiri bertanggung jawab untuk membebaskan array, tetapi utas dapat mencoba mengakses memori pada saat yang sama.  Untuk mengatasi masalah ini, crossbeam menggunakan strategi reklamasi berbasis zaman.  Meskipun tidak memerlukan banyak sumber daya, ia menambahkan overhead non-sepele ke jalur utama (hot path).  Setiap operasi sekarang harus melakukan operasi atom RMW (baca-modifikasi-tulis) di pintu masuk dan keluar dari bagian kritis untuk memberi sinyal ke utas lain bahwa memori sedang digunakan dan tidak dapat dihapus. <br><br>  Karena overhead untuk pertumbuhan antrian eksekusi, masuk akal untuk berpikir: apakah dukungan untuk pertumbuhan ini benar-benar diperlukan?  Pertanyaan ini akhirnya mendorong saya untuk menulis ulang perencana.  Strategi baru adalah memiliki ukuran antrian tetap untuk setiap proses.  Ketika antrian penuh, alih-alih menambah antrian lokal, tugas berpindah ke antrian global dengan beberapa konsumen dan beberapa produsen.  Prosesor akan memeriksa antrian global ini secara berkala, tetapi pada frekuensi yang jauh lebih rendah daripada yang lokal. <br><br>  Sebagai bagian dari salah satu percobaan pertama, kami mengganti balok silang dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mpmc</a> .  Ini tidak mengarah pada peningkatan yang signifikan karena jumlah sinkronisasi untuk push dan pop.  Kunci untuk menangkap pekerjaan adalah bahwa hampir tidak ada persaingan dalam antrian di bawah beban, karena setiap prosesor hanya mengakses antriannya sendiri. <br><br>  Pada tahap ini, saya memutuskan untuk mempelajari sumber Go dengan hati-hati - dan menemukan bahwa mereka menggunakan ukuran antrian tetap dengan satu produsen dan beberapa konsumen, dengan sinkronisasi minimal, yang sangat mengesankan.  Untuk menyesuaikan algoritme dengan penjadwal Tokio, saya membuat beberapa perubahan.  Perlu dicatat bahwa implementasi Go menggunakan operasi atom berurutan (seperti yang saya mengerti).  Versi Tokio juga mengurangi jumlah beberapa operasi penyalinan di cabang kode yang lebih jarang. <br><br>  Implementasi antrian adalah buffer melingkar yang menyimpan nilai dalam array.  Kepala dan ekor antrian dilacak oleh operasi atom dengan nilai integer. <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Queue</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/// Concurrently updated by many threads. head: AtomicU32, /// Only updated by producer thread but read by many threads. tail: AtomicU32, /// Masks the head / tail position value to obtain the index in the buffer. mask: usize, /// Stores the tasks. buffer: Box&lt;[MaybeUninit&lt;Task&gt;]&gt;, }</span></span></code> </pre> <br>  Antrian dilakukan oleh satu utas: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> head = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.head.load(Acquire); <span class="hljs-comment"><span class="hljs-comment">// safety: this is the **only** thread that updates this cell. let tail = self.tail.unsync_load(); if tail.wrapping_sub(head) &lt; self.buffer.len() as u32 { // Map the position to a slot index. let idx = tail as usize &amp; self.mask; // Don't drop the previous value in `buffer[idx]` because // it is uninitialized memory. self.buffer[idx].as_mut_ptr().write(task); // Make the task available self.tail.store(tail.wrapping_add(1), Release); return; } // The local buffer is full. Push a batch of work to the global // queue. match self.push_overflow(task, head, tail, global) { Ok(_) =&gt; return, // Lost the race, try again Err(v) =&gt; task = v, } }</span></span></code> </pre> <br>  Perhatikan bahwa dalam fungsi <code>push</code> ini, satu-satunya operasi atom memuat dengan memesan <code>Acquire</code> dan menyimpan dengan pesanan <code>Release</code> .  Tidak ada operasi RMW ( <code>compare_and_swap</code> , <code>fetch_and</code> ...) atau urutan berurutan, seperti sebelumnya.  Ini penting karena pada chip x86 semua unduhan / penyimpanan sudah “atomik”.  Jadi, pada level CPU, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi ini tidak akan disinkronkan</a> .  Operasi atom akan mencegah optimasi tertentu dalam kompiler, tetapi hanya itu saja.  Kemungkinan besar, operasi <code>load</code> pertama dapat dilakukan dengan aman dengan pemesanan <code>Relaxed</code> , tetapi penggantian tidak membawa overhead yang terlihat. <br><br>  Ketika antrian penuh, <code>push_overflow</code> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi ini memindahkan setengah dari tugas dari antrian lokal ke global. Antrian global adalah daftar intrusif yang dilindungi oleh mutex. Saat pindah ke antrian global, tugas pertama kali dihubungkan bersama, kemudian dibuat mutex, dan semua tugas dimasukkan dengan memperbarui pointer ke ujung antrian global. Ini menyimpan ukuran bagian kritis kecil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda terbiasa dengan rincian pemesanan memori atom, Anda mungkin melihat "masalah" potensial dengan fungsi yang ditunjukkan di atas </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Operasi </font></font><code>load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pemesanan </font><font style="vertical-align: inherit;">atom </font></font><code>Acquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agak lemah. Ini dapat mengembalikan nilai yang usang, mis., Operasi penangkapan paralel mungkin sudah meningkatkan nilai </font></font><code>self.head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi dalam cache aliran</font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai lama akan tetap, sehingga tidak akan melihat operasi penangkapan. Ini bukan masalah dengan kebenaran dari algoritma. Dengan cara utama (cepat), </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami hanya peduli apakah antrian lokal penuh atau tidak. Karena hanya utas saat ini yang dapat mendorong antrian, operasi yang sudah ketinggalan zaman </font></font><code>load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya akan membuat antrian terlihat lebih penuh daripada yang sebenarnya. Ini mungkin salah menentukan bahwa antrian penuh, dan menyebabkan </font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi fungsi ini termasuk operasi atom yang lebih kuat. Jika </font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menentukan bahwa antrian sebenarnya tidak penuh, maka kembali w / </font></font><code>Err</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan operasi </font></font><code>push</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dimulai lagi. Ini adalah alasan lain mengapa</font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memindahkan setengah dari antrian eksekusi ke antrian global. </font><font style="vertical-align: inherit;">Setelah gerakan ini, kesalahan positif semacam itu terjadi jauh lebih jarang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lokal </font></font><code>pop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dari prosesor yang menjadi antrian) juga diimplementasikan secara sederhana:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> head = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.head.load(Acquire); <span class="hljs-comment"><span class="hljs-comment">// safety: this is the **only** thread that updates this cell. let tail = self.tail.unsync_load(); if head == tail { // queue is empty return None; } // Map the head position to a slot index. let idx = head as usize &amp; self.mask; let task = self.buffer[idx].as_ptr().read(); // Attempt to claim the task read above. let actual = self .head .compare_and_swap(head, head.wrapping_add(1), Release); if actual == head { return Some(task.assume_init()); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam fungsi ini, satu singlet </font></font><code>load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan satu </font></font><code>compare_and_swap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan </font></font><code>Release</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Overhead utama berasal </font></font><code>compare_and_swap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsinya </font></font><code>steal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mirip dengan </font></font><code>pop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi </font></font><code>self.tail</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muatan atom harus ditransfer </font><font style="vertical-align: inherit;">dari </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Selain itu, sama halnya </font></font><code>push_overflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, operasi </font></font><code>steal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mencoba berpura-pura menjadi setengah antrian alih-alih satu tugas. </font><font style="vertical-align: inherit;">Ini memiliki efek yang baik pada kinerja, yang akan kita bahas nanti.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian terakhir yang hilang adalah analisis antrian global, yang menerima tugas yang melebihi antrian lokal, serta untuk mentransfer tugas ke penjadwal dari utas non-prosesor. </font><font style="vertical-align: inherit;">Jika prosesor berada di bawah beban, yaitu, ada tugas di antrian lokal, prosesor akan mencoba menarik tugas keluar dari antrian global setelah setiap 60 tugas dalam antrian lokal. </font><font style="vertical-align: inherit;">Itu juga memeriksa antrian global ketika berada dalam keadaan "pencarian" yang dijelaskan di bawah ini.</font></font><br><br><a name="3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Streamline Templat Pesan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplikasi Tokio biasanya terdiri dari banyak tugas kecil yang independen. Mereka berinteraksi satu sama lain melalui pesan. Templat semacam itu mirip dengan bahasa lain seperti Go dan Erlang. Mengingat betapa umum template itu, masuk akal bagi perencana untuk mengoptimalkannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalkan tugas A dan B diberikan. Tugas A sekarang menjalankan dan mengirim pesan ke tugas B melalui saluran transmisi. Saluran adalah sumber daya tempat tugas B saat ini dikunci, sehingga tindakan mengirim pesan akan menyebabkan tugas B beralih ke status yang dapat dieksekusi - dan itu akan ditempatkan dalam antrian eksekusi prosesor saat ini. Kemudian prosesor akan menyimpulkan tugas berikutnya dari antrian eksekusi, jalankan, dan ulangi siklus ini hingga mencapai tugas B.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalahnya adalah bahwa mungkin ada penundaan yang signifikan antara mengirim pesan dan menyelesaikan tugas B. </font><font style="vertical-align: inherit;">Selain itu, data panas, seperti pesan, disimpan dalam cache CPU, tetapi pada saat tugas selesai, ada kemungkinan bahwa cache yang sesuai akan dihapus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengatasi masalah ini, penjadwal Tokio baru mengimplementasikan optimasi (seperti pada penjadwal Go dan Kotlin). </font><font style="vertical-align: inherit;">Ketika tugas masuk ke status yang dapat dieksekusi, itu tidak ditempatkan di akhir antrian, tetapi disimpan dalam slot "tugas berikutnya" khusus. </font><font style="vertical-align: inherit;">Prosesor selalu memeriksa slot ini sebelum memeriksa antrian. </font><font style="vertical-align: inherit;">Jika sudah ada tugas lama di sana saat memasukkan ke dalam slot, itu dihapus dari slot dan pindah ke akhir antrian. </font><font style="vertical-align: inherit;">Dengan demikian, tugas pengiriman pesan akan selesai tanpa penundaan.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/12f/e12/a32/12fe12a324d1855a6c62cacd56cb4f70.png"><br><br><a name="4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengambilan throttle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam penjadwalan tangkapan pekerjaan, jika antrian eksekusi prosesor kosong, prosesor mencoba untuk menangkap tugas dari peer CPU. Pertama, CPU rekan acak dipilih, jika tidak ada tugas yang ditemukan untuk itu, yang berikutnya dicari, dan seterusnya, sampai tugas ditemukan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam prakteknya, beberapa prosesor sering selesai memproses antrian eksekusi pada waktu yang hampir bersamaan. Ini terjadi ketika paket pekerjaan tiba (misalnya, kapan</font></font><code>epoll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disurvei untuk kesiapan soket). Prosesor bangun, menerima tugas, memulai dan menyelesaikan. Ini mengarah pada fakta bahwa semua prosesor secara bersamaan mencoba menangkap tugas orang lain, yaitu, banyak utas yang mencoba mengakses antrian yang sama. Ada konflik. Pilihan titik awal yang acak membantu mengurangi persaingan, tetapi situasinya masih belum terlalu baik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengatasi masalah ini, penjadwal baru membatasi jumlah prosesor paralel yang melakukan operasi penangkapan. Kami menyebut status prosesor di mana ia mencoba menangkap tugas orang lain sebagai "pencarian pekerjaan" atau "pencarian" singkat (lebih lanjut tentang itu nanti). Optimalisasi semacam itu dilakukan dengan menggunakan nilai atom</font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang meningkat oleh prosesor sebelum memulai pencarian dan berkurang saat keluar dari kondisi pencarian. </font><font style="vertical-align: inherit;">Sebisa mungkin dalam kondisi pencarian bisa setengah dari jumlah total prosesor. </font><font style="vertical-align: inherit;">Yaitu, batas perkiraan ditetapkan, dan ini normal. </font><font style="vertical-align: inherit;">Kami tidak perlu batasan keras pada jumlah CPU dalam pencarian, hanya pelambatan. </font><font style="vertical-align: inherit;">Kami mengorbankan akurasi demi efisiensi algoritma. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah memasuki kondisi pencarian, prosesor mencoba menangkap pekerjaan dari peer CPU dan memeriksa antrian global.</font></font><br><br><a name="5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kurangi sinkronisasi antar utas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian penting lain dari penjadwal adalah memberi tahu rekan CPU tentang tugas baru. Jika "saudara" itu tertidur, ia bangun dan mengambil tugas. Pemberitahuan memainkan peran penting lainnya. Ingat bahwa algoritma antrian menggunakan urutan atom lemah ( </font></font><code>Acquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>Release</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Karena alokasi memori atom, tidak ada jaminan bahwa prosesor peer akan pernah melihat tugas dalam antrian tanpa sinkronisasi tambahan. Karena itu, notifikasi juga bertanggung jawab untuk itu. Karena alasan ini, notifikasi menjadi mahal. Tujuannya adalah untuk meminimalkan jumlah mereka agar tidak menggunakan sumber daya CPU, yaitu, prosesor memiliki tugas, dan saudara tidak dapat mencurinya. Jumlah pemberitahuan yang berlebihan menyebabkan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masalah kawanan guntur</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perencana Tokio yang asli mengambil pendekatan naif terhadap notifikasi. Setiap kali tugas baru ditempatkan dalam antrian eksekusi, prosesor menerima pemberitahuan. Setiap kali CPU diberi tahu dan melihat tugas setelah bangun, itu memberi tahu CPU lain. Logika ini sangat cepat menyebabkan semua prosesor bangun dan mencari pekerjaan (menyebabkan konflik). Seringkali, sebagian besar prosesor tidak menemukan pekerjaan dan tertidur lagi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penjadwal baru sangat memperbaiki pola ini, mirip dengan penjadwal Go. Pemberitahuan dikirim seperti sebelumnya, tetapi hanya jika tidak ada CPU dalam kondisi pencarian (lihat bagian sebelumnya). Ketika prosesor menerima notifikasi, ia segera memasuki kondisi pencarian. Ketika prosesor dalam kondisi pencarian menemukan tugas baru, ia terlebih dahulu meninggalkan status pencarian dan kemudian memberitahu prosesor lainnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logika ini membatasi kecepatan prosesor bangun. Jika seluruh paket tugas direncanakan segera (misalnya, kapan</font></font><code>epoll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disurvei untuk kesiapan soket), maka tugas pertama akan menghasilkan pemberitahuan kepada prosesor. </font><font style="vertical-align: inherit;">Dia sekarang dalam kondisi pencarian. </font><font style="vertical-align: inherit;">Tugas terjadwal yang tersisa dalam paket tidak akan memberi tahu prosesor, karena setidaknya ada satu CPU dalam kondisi pencarian. </font><font style="vertical-align: inherit;">Prosesor yang diberitahukan ini akan menangkap setengah tugas dalam batch dan, pada gilirannya, akan memberi tahu prosesor lainnya. </font><font style="vertical-align: inherit;">Prosesor ketiga bangun, menemukan tugas salah satu dari dua prosesor pertama dan menangkap setengah dari mereka. </font><font style="vertical-align: inherit;">Hal ini menyebabkan peningkatan yang lancar dalam jumlah CPU yang bekerja, serta penyeimbangan beban yang cepat.</font></font><br><br><a name="6"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kurangi alokasi memori </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penjadwal Tokio baru hanya membutuhkan satu alokasi memori untuk setiap tugas yang dimunculkan, sedangkan yang lama membutuhkan dua. </font><font style="vertical-align: inherit;">Sebelumnya, struktur tugas terlihat seperti ini:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/// All state needed to manage the task state: TaskState, /// The logic to run is represented as a future trait object. future: Box&lt;dyn Future&lt;Output = ()&gt;&gt;, }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juga akan disorot dalam </font></font><code>Box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Untuk waktu yang sangat lama saya ingin memperbaiki sambungan ini (saya pertama kali mencoba pada tahun 2014). Dua hal telah berubah sejak perencana Tokio lama. Pertama, stabil </font></font><code>std::alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kedua, sistem tugas masa depan telah beralih ke </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strategi vtable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eksplisit </font><font style="vertical-align: inherit;">. Dua hal inilah yang akhirnya hilang, untuk menyingkirkan alokasi memori ganda yang tidak efisien untuk setiap tugas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang struktur </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disajikan dalam bentuk berikut:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span></span>&lt;T&gt; { header: Header, future: T, trailer: Trailer, }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk tugas-tugas yang diperlukan dan </font></font><code>Header</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>Trailer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi mereka dibagi antara "panas" Data (kepala) dan "dingin" (ekor), m. E. Sekitar antara data yang sering diakses dan orang-orang yang jarang digunakan. </font><font style="vertical-align: inherit;">Data "Hot" ditempatkan di kepala struktur dan disimpan sesedikit mungkin. </font><font style="vertical-align: inherit;">Saat prosesor meringkas penunjuk tugas, ia segera memuat garis cache (dari 64 hingga 128 byte). </font><font style="vertical-align: inherit;">Kami ingin data ini serelevan mungkin.</font></font><br><br><a name="7"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengurangi penghitungan tautan atom </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimalisasi terakhir yang kita bahas dalam artikel ini adalah mengurangi jumlah tautan atom. Ada banyak referensi untuk struktur tugas, termasuk dari penjadwal dan dari setiap pembuat. Strategi umum untuk mengelola memori ini adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penghitungan tautan atom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Strategi ini membutuhkan operasi atom setiap kali tautan dikloning dan setiap kali tautan dihapus. Ketika tautan terakhir keluar dari ruang lingkup, memori dibebaskan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di penjadwal Tokio lama, penjadwal dan semua pembuat berisi tautan ke deskriptor tugas, kira-kira:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Waker</span></span></span></span> { task: Arc&lt;Task&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Waker { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.task.clone(); task.scheduler.schedule(task); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika tugas bangun, tautan diklon (terjadi peningkatan atom). </font><font style="vertical-align: inherit;">Kemudian tautan ditempatkan di antrian eksekusi. </font><font style="vertical-align: inherit;">Saat prosesor menerima tugas dan menyelesaikan eksekusi, prosesor membuang tautan, yang mengarah ke pengurangan atom. </font><font style="vertical-align: inherit;">Operasi atomik ini (bertambah dan berkurang) bertambah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah ini sebelumnya diidentifikasi oleh pengembang sistem tugas </font></font><code>std::future</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mereka memperhatikan bahwa ketika menelepon, </font></font><code>Waker::wake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tautan asli ke </font></font><code>waker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sering tidak lagi diperlukan. </font><font style="vertical-align: inherit;">Ini memungkinkan Anda untuk menggunakan kembali penghitung tautan atom saat memindahkan tugas ke antrian eksekusi. </font><font style="vertical-align: inherit;">Sistem tugas </font></font><code>std::future</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sekarang mencakup dua panggilan API untuk "bangun":</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>wake</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang menerima </font></font><code>self</code> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>wake_by_ref</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang menerima </font></font><code>&amp;self</code> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstruksi API seperti itu membuat kami menggunakannya saat menelepon </font></font><code>wake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, menghindari kenaikan atom. </font><font style="vertical-align: inherit;">Implementasinya menjadi seperti ini:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Waker { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { task.scheduler.schedule(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.task); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake_by_ref</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.task.clone(); task.scheduler.schedule(task); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini menghindari overhead dari jumlah tautan tambahan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jika Anda dapat bertanggung jawab untuk bangun. Dalam pengalaman saya, sebaliknya, hampir selalu disarankan untuk bangun bersama </font></font><code>&amp;self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kebangkitan </font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mencegah penggunaan kembali waker (berguna dalam kasus-kasus di mana sumber daya mengirimkan banyak nilai, misalnya saluran, soket, ...). Juga dalam kasus ini </font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lebih sulit untuk menerapkan bangun dengan aman (kami akan meninggalkan detail untuk artikel lain). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perencana baru memecahkan masalah "waking through </font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" dengan menghindari kenaikan atom </font></font><code>wake_by_ref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang membuatnya seefektif</font></font><code>wake(self)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk melakukan ini, penjadwal menyimpan daftar semua tugas yang saat ini aktif (belum selesai). </font><font style="vertical-align: inherit;">Daftar tersebut mewakili penghitung referensi yang diperlukan untuk mengirimkan tugas ke antrian eksekusi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompleksitas dari optimasi ini terletak pada kenyataan bahwa penjadwal tidak akan menghapus tugas dari daftar sampai ia menerima jaminan bahwa tugas akan ditempatkan di antrian eksekusi lagi. </font><font style="vertical-align: inherit;">Detail implementasi skema ini berada di luar cakupan artikel ini, tetapi saya sangat menyarankan Anda melihat sumbernya.</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konkurensi tebal (tidak aman) dengan Loom </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sangat sulit untuk menulis kode paralel yang benar tanpa kunci. Lebih baik bekerja perlahan, tetapi dengan benar, daripada dengan cepat, tetapi dengan gangguan, terutama jika bug berhubungan dengan keamanan memori. Opsi terbaik, bagaimanapun, harus bekerja dengan cepat dan tanpa kesalahan. Penjadwal baru membuat beberapa optimasi yang agak agresif dan menghindari sebagian besar tipe </font></font><code>std</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demi spesialisasi. Secara umum, ada cukup banyak kode tidak aman di dalamnya </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada beberapa cara untuk menguji kode paralel. Salah satunya adalah bagi pengguna untuk menguji dan men-debug bukan Anda (opsi yang menarik, itu pasti). Lain adalah menulis unit test yang dijalankan dalam satu lingkaran dan dapat menangkap kesalahan. Mungkin bahkan menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TSAN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tentu saja, jika ia menemukan kesalahan, itu tidak dapat dengan mudah direproduksi tanpa memulai kembali siklus tes. Juga, berapa lama siklus ini? Sepuluh detik? Sepuluh menit? Sepuluh hari? Sebelumnya, Anda harus menguji kode paralel di Rust. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menemukan situasi ini tidak dapat diterima. Ketika kami merilis kode, kami ingin merasa percaya diri (sebanyak mungkin), terutama dalam kasus kode paralel tanpa kunci. Pengguna Tokio membutuhkan keandalan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleh karena itu, kami mengembangkan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : alat untuk pengujian permutasi kode paralel. Tes ditulis seperti biasa, tetapi</font></font><code>loom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini akan menjalankannya berkali-kali, mengatur ulang semua opsi yang mungkin untuk dieksekusi dan perilaku yang mungkin ditemui tes dalam lingkungan streaming. Itu juga memeriksa akses memori yang benar, membebaskan memori, dll. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai contoh, di sini adalah tes alat tenun untuk penjadwal baru:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multi_spawn</span></span></span></span>() { loom::model(|| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pool = ThreadPool::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c1 = Arc::new(AtomicUsize::new(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (tx, rx) = oneshot::channel(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tx1 = Arc::new(Mutex::new(<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(tx))); <span class="hljs-comment"><span class="hljs-comment">// Spawn a task let c2 = c1.clone(); let tx2 = tx1.clone(); pool.spawn(async move { spawn(async move { if 1 == c1.fetch_add(1, Relaxed) { tx1.lock().unwrap().take().unwrap().send(()); } }); }); // Spawn a second task pool.spawn(async move { spawn(async move { if 1 == c2.fetch_add(1, Relaxed) { tx2.lock().unwrap().take().unwrap().send(()); } }); }); rx.recv(); }); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu terlihat sangat normal, tetapi sepotong kode dalam sebuah blok </font></font><code>loom::model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berjalan ribuan kali (mungkin jutaan), setiap kali dengan sedikit perubahan perilaku. Setiap proses mengubah urutan persis dari utas. Selain itu, untuk setiap operasi atom, alat tenun mencoba semua perilaku berbeda yang diizinkan dalam model memori C ++ 11. Ingat bahwa muatan atom </font></font><code>Acquire</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agak lemah dan dapat mengembalikan nilai yang usang. Tes </font></font><code>loom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan mencoba semua nilai yang mungkin dapat dimuat. </font></font><br><br> <code>loom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menjadi alat yang tak ternilai dalam mengembangkan perencana baru. Dia menangkap lebih dari sepuluh bug yang lulus semua pengujian unit, pengujian manual dan pengujian beban.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembaca yang cerdas mungkin ragu bahwa alat tenun memeriksa "semua permutasi yang mungkin," dan ia akan benar. Permutasi naif akan menyebabkan ledakan kombinatorial. Tes non-sepele tidak akan pernah berakhir. Masalah ini telah dipelajari selama bertahun-tahun dan sejumlah algoritma telah dikembangkan untuk mencegah ledakan kombinatorial. Loom dasar algoritma berdasarkan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengurangan dinamis dengan memesan parsial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (pengurangan parsial-order dinamis). Algoritma ini menghilangkan permutasi yang mengarah ke hasil yang sama. Tetapi ruang keadaan masih dapat tumbuh sedemikian rupa sehingga tidak akan diproses dalam jumlah waktu yang wajar (beberapa menit). Loom memungkinkan Anda untuk membatasi penggunaan pengurangan dinamis dengan pemesanan parsial.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, berkat pengujian ekstensif dengan Loom, saya sekarang </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jauh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lebih percaya diri dalam kebenaran penjadwal.</font></font><br><br><h1>  Hasil </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, kami melihat penjadwal apa dan bagaimana penjadwal Tokio baru mencapai peningkatan kinerja besar ... tapi seperti apa pertumbuhannya? </font><font style="vertical-align: inherit;">Mengingat bahwa penjadwal baru hanya dikembangkan, di dunia nyata belum diuji secara penuh. </font><font style="vertical-align: inherit;">Inilah yang kita ketahui. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, penjadwal baru jauh lebih cepat dalam tolok ukur mikro:</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perencana tua </font></font></h4><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> test chained_spawn ... bangku: 2,019,796 ns / iter (+/- 302,168)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
test ping_pong ... bench: 1.279.948 ns / iter (+/- 154.365)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
test spawn_many ... bangku: 10.283.608 ns / iter (+/- 1.284.275)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
test yield_many ... bangku: 21,450,748 ns / iter (+/- 1,201,337) </font></font></pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perencana baru </font></font></h4><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> test chained_spawn ... bench: 168,854 ns / iter (+/- 8,339)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
test ping_pong ... bench: 562.659 ns / iter (+/- 34.410)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
test spawn_many ... bangku: 7.320.737 ns / iter (+/- 264.620)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
test yield_many ... bangku: 14.638.563 ns / iter (+/- 1.573.678) </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benchmark ini meliputi: </font></font><br><br><ul><li> <code>chained_spawn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> secara rekursif menelurkan tugas baru, mis., menghasilkan tugas yang menghasilkan tugas lain, yang juga menghasilkan tugas, dll. </font></font><br></li><li> <code>ping_pong</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memilih saluran </font></font><code>oneshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan memunculkan tugas yang mengirim pesan pada saluran itu. </font><font style="vertical-align: inherit;">Tugas asli sedang menunggu pesan. </font><font style="vertical-align: inherit;">Ini adalah ujian yang paling dekat dengan "dunia nyata".</font></font><br></li><li> <code>spawn_many</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memeriksa pelaksanaan tugas dalam penjadwal, mis. Menghasilkan tugas dari luar konteksnya. </font></font><br></li><li> <code>yield_many</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memeriksa kebangkitan tugas independen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbedaan dalam tolok ukur sangat mengesankan. </font><font style="vertical-align: inherit;">Tetapi bagaimana ini akan tercermin dalam "dunia nyata"? </font><font style="vertical-align: inherit;">Sulit untuk mengatakannya dengan pasti, tetapi saya mencoba menjalankan tolok ukur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hyper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut adalah server Hyper paling sederhana, yang kinerjanya diukur menggunakan </font></font><code>wrk -t1 -c50 -d10</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perencana tua </font></font></h4><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menjalankan uji 10s @ http://127.0.0.1 {000</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1 utas dan 50 koneksi</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Thread Stats Rata-rata Stdev Max +/- Stdev</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Latency 371.53us 99.05us 1.97ms 60.53%</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Req / Sec 114.61k 8.45k 133.85k 67.00%</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1139307 permintaan dalam 10.00, baca 95.61MB</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Permintaan / dtk: 113923.19</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transfer / dtk: 9.56MB </font></font></pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perencana baru </font></font></h4><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menjalankan uji 10s @ http://127.0.0.1 {000</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1 utas dan 50 koneksi</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  Thread Stats Rata-rata Stdev Max +/- Stdev</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Latency 275.05us 69.81us 1.09ms 73.57%</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Req / Sec 153.17k 10.68k 171.51k 71.00%</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1522671 permintaan dalam 10.00, baca 127.79MB</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Permintaan / dtk: 152258.70</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Transfer / dtk: 12,78MB </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami melihat peningkatan 34% dalam permintaan per detik setelah perubahan scheduler! Pertama kali saya melihat ini, saya sangat senang, karena saya mengharapkan peningkatan maksimal 5-10%. Tapi kemudian saya merasa sedih, karena hasil ini juga menunjukkan bahwa penjadwal Tokio lama tidak begitu baik. Lalu saya ingat bahwa Hyper </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sudah menjadi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pemimpin dalam peringkat </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">TechEmpower</font></a><font style="vertical-align: inherit;"> . Sangat menarik untuk melihat bagaimana perencana baru akan mempengaruhi peringkat. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tonic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , klien dan server gRPC, dengan penjadwal baru telah dipercepat sekitar 10%, yang cukup mengesankan mengingat bahwa Tonic belum sepenuhnya dioptimalkan.</font></font><br><br><h1>  Kesimpulan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya sangat senang akhirnya menyelesaikan proyek ini setelah beberapa bulan bekerja. </font><font style="vertical-align: inherit;">Ini adalah peningkatan besar pada Rust I / O yang tidak sinkron. </font><font style="vertical-align: inherit;">Saya sangat senang dengan perbaikan yang dilakukan. </font><font style="vertical-align: inherit;">Masih ada banyak ruang untuk optimasi dalam kode Tokio, jadi kami belum selesai dengan peningkatan kinerja. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya berharap bahwa materi dalam artikel ini akan bermanfaat bagi kolega yang mencoba menulis penjadwal tugas mereka.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472242/">https://habr.com/ru/post/id472242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472228/index.html">9 Trik untuk Bekerja dengan Visual Studio Code</a></li>
<li><a href="../id472230/index.html">Chips untuk ML - bicarakan produk baru</a></li>
<li><a href="../id472232/index.html">Dari "Color Extender untuk ZX-Spectrum" ke ZX-Poly</a></li>
<li><a href="../id472234/index.html">Cryptocurrency: apakah masih freeloader, atau partner?</a></li>
<li><a href="../id472240/index.html">Tentang gamification. Apa itu, mengapa dan bagaimana melakukannya? Tampilan Pengembang</a></li>
<li><a href="../id472246/index.html">Bereaksi + IndexDb + pembaruan otomatis = hampir AsyncRedux</a></li>
<li><a href="../id472248/index.html">Bagaimana kami menggabungkan pemrograman IT-Planet final</a></li>
<li><a href="../id472252/index.html">Acara digital di Moskow dari 21 hingga 28 Oktober</a></li>
<li><a href="../id472254/index.html">Acara digital di St. Petersburg dari 21 hingga 28 Oktober</a></li>
<li><a href="../id472258/index.html">Cara "belajar belajar" - meningkatkan perhatian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>