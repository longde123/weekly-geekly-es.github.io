<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾 🧣 🙇🏾 Seluruh kebenaran tentang linux epoll 🤜🏾 🕢 🔤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ya, atau hampir semua ... 





 Saya percaya bahwa masalah di Internet modern adalah meluap-luapnya informasi dengan kualitas yang berbeda. Menemukan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seluruh kebenaran tentang linux epoll</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416669/"><p>  Ya, atau hampir semua ... </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/91f/776/71c/91f77671c2186bc1f2393c47e0696ee9.png"></p><br><p>  Saya percaya bahwa masalah di Internet modern adalah meluap-luapnya informasi dengan kualitas yang berbeda.  Menemukan materi tentang topik yang menarik bukanlah masalah, masalahnya adalah membedakan materi yang baik dari materi yang buruk jika Anda memiliki sedikit pengalaman di bidang ini.  Saya mengamati gambar ketika ada banyak informasi ikhtisar "di atas" (hampir pada tingkat penghitungan sederhana), sangat sedikit artikel mendalam dan tidak ada artikel transisi dari sederhana ke kompleks.  Namun demikian, pengetahuan tentang fitur-fitur mekanisme tertentu yang memungkinkan kita untuk membuat pilihan berdasarkan informasi selama pengembangan. </p><br><p>  Dalam artikel ini saya akan mencoba mengungkap apa perbedaan mendasar antara <strong>epoll</strong> dan mekanisme lainnya, apa yang membuatnya unik, serta mengutip artikel yang hanya perlu Anda baca untuk lebih memahami kemungkinan dan masalah <strong>epoll</strong> . </p><br><blockquote> Siapa pun dapat menggunakan kapak, tetapi dibutuhkan pejuang sejati untuk membuatnya melodi melee. </blockquote><p>  Saya menganggap pembaca sudah terbiasa dengan <strong>epoll</strong> , setidaknya membaca halaman manual.  Cukup telah ditulis tentang <strong>epoll</strong> , <strong>polling</strong> , <strong>pilih</strong> sehingga setiap orang yang berkembang di Linux telah mendengarnya setidaknya sekali. </p><a name="habracut"></a><br><h1 id="mnoga--fd">  Banyak sekali </h1><br><p>  Ketika orang berbicara tentang <strong>epoll</strong> pada dasarnya saya mendengar tesis bahwa "kinerjanya lebih baik ketika ada banyak deskriptor file". </p><br><p>  Hanya ingin mengajukan pertanyaan - berapa banyak?  Berapa banyak koneksi yang dibutuhkan, dan yang paling penting, dalam kondisi apa <strong>epoll</strong> akan mulai memberikan keuntungan kinerja yang nyata? </p><br><p>  Bagi mereka yang mempelajari <strong>epoll</strong> (ada cukup banyak bahan termasuk artikel ilmiah), jawabannya jelas - lebih baik jika dan hanya jika jumlah senyawa "menunggu suatu peristiwa" secara signifikan melebihi jumlah "siap untuk diproses".  Tanda kuantitas, ketika keuntungan menjadi sangat signifikan sehingga tidak ada urin untuk mengabaikan fakta ini, senyawa 10k dianggap [4]. </p><br><p>  Asumsi bahwa sebagian besar koneksi akan ditangguhkan berasal dari logika suara dan pemantauan beban server yang sedang digunakan aktif. </p><br><p>  Jika jumlah senyawa aktif berusaha untuk jumlah total, <del>  tidak akan ada keuntungan </del>  tidak akan ada perolehan yang signifikan, keuntungan yang signifikan disebabkan dan hanya karena <strong>epoll</strong> mengembalikan hanya deskriptor yang membutuhkan perhatian, dan <strong>polling</strong> mengembalikan semua deskriptor yang ditambahkan untuk observasi. </p><br><p>  Jelas, dalam kasus terakhir, kami menghabiskan waktu melintasi semua deskriptor + overhead menyalin berbagai peristiwa dari kernel. </p><br><p>  Memang, dalam pengukuran kinerja awal, yang dilampirkan pada tambalan [9], titik ini tidak ditekankan dan orang hanya bisa menebak dengan adanya utilitas deadcon yang disebutkan dalam artikel (sayangnya, kode utilitas pipetest.c hilang).  Di sisi lain, dalam sumber lain [6, 8] sangat sulit untuk tidak memperhatikan, karena fakta ini praktis mencuat. </p><br><p>  Pertanyaan segera muncul, tetapi bagaimana sekarang jika tidak direncanakan untuk melayani sejumlah deskriptor file <strong>epoll</strong> , seolah-olah, dan tidak diperlukan? </p><br><p>  Terlepas dari kenyataan bahwa <strong>epoll</strong> awalnya dibuat khusus untuk situasi seperti itu [5, 8, 9], ini jauh dari satu-satunya perbedaan antara <strong>epoll</strong> . </p><br><h1 id="epollet">  EPOLLET </h1><br><p>  Untuk memulainya, kita akan melihat perbedaan antara pemicu tepi dan pemicu level. Ada pernyataan yang sangat bagus tentang topik ini dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Edge Triggered Vs Level Pemicu terputus - Venkatesh Yadav</a> : </p><br><blockquote>  Gangguan di level, itu seperti anak kecil.  Jika bayi menangis, Anda harus menyerahkan semua yang Anda lakukan dan lari ke bayi untuk memberinya makan.  Lalu Anda memasukkan bayi kembali ke boks.  Jika dia menangis lagi, Anda tidak akan meninggalkannya di mana pun, tetapi Anda akan mencoba menenangkannya.  Dan sementara anak itu menangis, Anda tidak akan meninggalkannya sejenak, dan akan kembali bekerja hanya ketika dia tenang.  Tetapi katakanlah kita pergi ke kebun (gangguan berhenti) ketika anak mulai menangis, lalu ketika Anda kembali ke rumah (gangguan dihidupkan) hal pertama yang Anda lakukan adalah pergi memeriksa anak.  Tetapi Anda tidak akan pernah tahu bahwa dia menangis saat Anda berada di taman. <br><br>  Gangguan di bagian depan seperti pengasuh elektronik untuk orang tua tuli.  Segera setelah anak mulai menangis pada perangkat, lampu merah menyala dan menyala sampai Anda menekan tombol.  Sekalipun anak mulai menangis, tetapi dengan cepat berhenti dan tertidur, Anda akan tetap tahu bahwa anak itu sedang menangis.  Tetapi jika dia mulai menangis, dan Anda menekan tombol (konfirmasi gangguan), cahaya tidak akan menyala bahkan jika dia terus menangis.  Level suara di ruangan harus turun dan kemudian naik lagi sehingga cahaya menyala. </blockquote><p>  Jika <strong>epoll</strong> (serta <strong>jajak pendapat</strong> / <strong>pilih</strong> ) tidak dikunci dalam perilaku yang dipicu tingkat jika deskriptor dalam keadaan yang ditentukan dan akan dianggap aktif sampai keadaan ini dihapus, tepi-dipicu dibuka hanya dengan mengubah keadaan saat ini yang diperintahkan. </p><br><p>  Hal ini memungkinkan Anda untuk menangani acara nanti, dan tidak segera setelah diterima (hampir analogi langsung dengan bagian atas dan bawah setengah dari penangan interrupt). </p><br><p>  Contoh spesifik dengan epoll: </p><br><p>  Level dipicu </p><br><ul><li>  handle ditambahkan ke <strong>epoll</strong> dengan flag <strong>EPOLLIN</strong> </li><li>  <strong>epoll_wait ()</strong> mencekal sambil menunggu acara </li><li>  menulis ke deskriptor file 19 byte </li><li>  <strong>epoll_wait ()</strong> <strong>buka</strong> dengan acara <strong>EPOLLIN</strong> </li><li>  kami tidak melakukan apa pun dengan data yang datang </li><li>  <strong>epoll_wait ()</strong> membuka lagi dengan acara <strong>EPOLLIN</strong> </li></ul><br><p>  Dan ini akan berlanjut sampai kita benar-benar menghitung atau mereset data dari deskriptor. </p><br><p>  Edge dipicu </p><br><ul><li>  handle ditambahkan ke <strong>epoll</strong> dengan flag <strong>EPOLLIN |</strong>  <strong>EPOLLET</strong> </li><li>  <strong>epoll_wait ()</strong> mencekal sambil menunggu acara </li><li>  menulis ke deskriptor file 19 byte </li><li>  <strong>epoll_wait ()</strong> <strong>buka</strong> dengan acara <strong>EPOLLIN</strong> </li><li>  kami tidak melakukan apa pun dengan data yang datang </li><li>  <strong>epoll_wait ()</strong> diblokir menunggu acara baru </li><li>  tulis 19 byte lagi ke deskriptor file </li><li>  <strong>epoll_wait ()</strong> membuka dengan acara <strong>EPOLLIN</strong> baru </li><li>  <strong>epoll_wait ()</strong> diblokir menunggu acara baru </li></ul><br><p>  contoh sederhana: <a href="">epollet_socket.c</a> </p><br><p>  Mekanisme ini <strong>dirancang</strong> untuk mencegah kembalinya <strong>epoll_wait ()</strong> karena suatu peristiwa yang sudah diproses. </p><br><p>  Jika, dalam kasus level, saat memanggil <strong>epoll_wait (),</strong> kernel memeriksa untuk melihat apakah fd dalam keadaan ini, kemudian edge melewatkan pemeriksaan ini dan segera memasukkan proses panggilan ke kondisi tidur. </p><br><p>  <strong>EPOLLET sendiri</strong> adalah yang membuat <strong>epoll</strong> O (1) multiplexer untuk berbagai acara. </p><br><p>  Penting untuk mengklarifikasi tentang <strong>EAGAIN</strong> dan <strong>EPOLLET</strong> - rekomendasi dengan <strong>EAGAIN</strong> bukan untuk memperlakukan byte-stream, bahaya dalam kasus yang terakhir hanya muncul jika Anda tidak membaca deskriptor hingga akhir, dan data baru tidak datang.  Maka ekor akan menggantung di deskriptor, tetapi Anda tidak akan menerima pemberitahuan baru.  Dengan <strong>accept (),</strong> situasinya hanya berbeda, di sana Anda harus melanjutkan sampai <strong>accept ()</strong> mengembalikan <strong>EAGAIN</strong> , hanya dalam hal ini operasi yang benar dijamin. </p><br><pre><code class="hljs lua">// TCP socket (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> stream) //  fd    EPOLLIN      int <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">read</span></span>(fd, buffer, BUFFER_LEN); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span> &lt; BUFFER_LEN) { //   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //         //  -       epoll_wait, //      }</code> </pre> <br><pre> <code class="hljs ruby"> /<span class="hljs-regexp"><span class="hljs-regexp">/ accept /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  listenfd    EPOLLIN      event.events = EPOLLIN | EPOLLERR; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &amp;event); sleep(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       &gt;1  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   while(epoll_wait()) { newfd = accept(listenfd, ...); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  epoll_wait    listenfd    } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   while(epoll_wait()) { while((newfd = accept(...)) &gt; 0) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  -  } if(newfd == -1 &amp;&amp; errno = EAGAIN) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       } }</span></span></code> </pre> <br><p>  Dengan properti ini, cukup kelaparan saja sudah cukup: </p><br><ul><li>  paket datang ke deskriptor </li><li>  baca paket ke buffer </li><li>  paket lain datang </li><li>  baca paket ke buffer </li><li>  datang sebagian kecil </li><li>  ... </li></ul><br><p>  Dengan demikian <strong>,</strong> kami tidak akan segera menerima <strong>EAGAIN</strong> , tetapi kami mungkin tidak akan menerima sama sekali. </p><br><p>  Dengan demikian, deskriptor file lainnya tidak menerima waktu untuk diproses, dan kami sibuk membaca data kecil yang datang secara tiba-tiba. </p><br><h1 id="thundering-nerd-herd">  guntur <del>  kutu buku </del>  kawanan </h1><br><p>  Untuk menuju ke bendera terakhir, Anda perlu memahami mengapa itu benar-benar dibuat dan salah satu masalah apa yang muncul bagi pengembang dengan evolusi teknologi dan perangkat lunak. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://en.wikipedia.org/wiki/">Gemuruh masalah kawanan</a> </p><br><blockquote>  Guntur masalah kawanan <br><br>  Bayangkan sejumlah besar proses menunggu acara.  Jika suatu peristiwa terjadi, mereka akan dibangunkan dan perjuangan untuk sumber daya akan dimulai, meskipun hanya satu proses yang diperlukan yang akan menangani proses lebih lanjut dari peristiwa tersebut.  Sisa proses akan tidur lagi. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terminologi IT - Vasily Alekseenko</a> </blockquote><p>  Dalam hal ini, kami tertarik dengan masalah <strong>accept ()</strong> dan <strong>read () yang</strong> didistribusikan melalui stream bersama dengan <strong>epoll</strong> . </p><br><h1 id="accept">  terima </h1><br><p>  Sebenarnya, dengan panggilan pemblokiran untuk <strong>menerima (),</strong> tidak ada masalah untuk waktu yang lama.  Kernel akan berhati-hati bahwa hanya satu proses telah dibuka untuk acara ini, dan semua koneksi masuk serial. </p><br><p>  Tetapi dengan <strong>epoll,</strong> trik seperti itu tidak akan berhasil.  Jika kami telah <strong>mendengarkan () dibuat</strong> pada soket non-pemblokiran, ketika koneksi dibuat, semua <strong>epoll_wait ()</strong> akan <strong>menunggu</strong> acara dari deskriptor ini. </p><br><p>  Tentu saja, <strong>accept ()</strong> hanya dapat melakukan satu utas, sisanya akan menerima <strong>EAGAIN</strong> , tetapi ini adalah pemborosan sumber daya. </p><br><p>  Selain itu, <strong>EPOLLET</strong> juga tidak membantu kami, karena kami tidak tahu persis berapa banyak koneksi yang ada dalam antrian koneksi ( <strong>backlog</strong> ).  Seperti yang kita ingat, ketika menggunakan <strong>EPOLLET</strong> , pemrosesan soket harus dilanjutkan sampai kembali dengan <strong>kode</strong> kesalahan <strong>EAGAIN</strong> , sehingga ada kemungkinan semua <strong>menerima ()</strong> akan diproses oleh satu utas dan sisanya tidak akan berfungsi. </p><br><p>  Dan ini sekali lagi membawa kita ke situasi di mana aliran tetangga terbangun dengan sia-sia. </p><br><p>  Kami juga bisa mendapatkan jenis kelaparan yang berbeda - kami hanya akan memiliki satu utas dimuat, dan sisanya tidak akan menerima koneksi untuk diproses. </p><br><h1 id="epolloneshot">  EPOLLONESHOT </h1><br><p>  Sebelum versi 4.5, satu-satunya cara yang benar untuk memproses <strong>epoll yang</strong> didistribusikan menjadi deskriptor <strong>listen () yang</strong> tidak menghalangi dengan panggilan <strong>accept ()</strong> berikutnya adalah dengan mengatur flag <strong>EPOLLONESHOT</strong> , yang sekali lagi membuat kami <strong>menerima ()</strong> hanya diproses dalam satu utas pada satu waktu. </p><br><p>  Singkatnya - jika <strong>EPOLLONESHOT</strong> digunakan <strong>,</strong> peristiwa yang terkait dengan deskriptor tertentu akan diaktifkan hanya sekali, setelah itu perlu untuk mengokang ulang bendera menggunakan <strong>epoll_ctl ()</strong> . </p><br><h1 id="epollexclusive">  EPOLLEXKLUSIF </h1><br><p>  Di sini <strong>EPOLLEXCLUSIVE</strong> dan level-triggered datang untuk membantu kami. </p><br><p>  <strong>EPOLLEXCLUSIVE</strong> membuka satu <strong>epoll_wait () yang</strong> tertunda pada satu waktu untuk satu acara. </p><br><p>  Skema ini cukup sederhana (sebenarnya tidak): </p><br><ul><li>  Kami memiliki N utas menunggu acara koneksi </li><li>  Klien pertama terhubung ke kami </li><li>  Thread 0 akan tersebar dan mulai memproses, utas lainnya akan tetap diblokir </li><li>  Klien kedua terhubung ke kami, jika utas 0 masih sibuk dengan pemrosesan, maka utas 1 tidak dikunci </li><li>  Kami melanjutkan lebih jauh sampai kumpulan utas habis (tidak ada yang mengharapkan acara di <strong>epoll_wait ()</strong> ) </li><li>  Klien lain terhubung ke kami </li><li>  Dan prosesnya akan menerima utas pertama, yang akan memanggil <strong>epoll_wait ()</strong> </li><li>  Utas kedua akan menerima klien kedua, yang akan memanggil <strong>epoll_wait ()</strong> </li></ul><br><p>  Dengan demikian, semua perawatan didistribusikan secara merata di seluruh aliran. </p><br><pre> <code class="bash hljs">$ ./epollexclusive --<span class="hljs-built_in"><span class="hljs-built_in">help</span></span> -i, --ip=ADDR specify ip address -p, --port=PORT specify port -n, --threads=NUM specify number of threads to use <span class="hljs-comment"><span class="hljs-comment">#    -  n*8 -t, --thunder not adding EPOLLEXCLUSIVE #     thunder herd -h, --help prints this message $ sudo taskset -c 0-7 ./epollexclusive -i 10.56.75.201 -p 40000 -n 8 2&gt;&amp;1</span></span></code> </pre> <br><p>  contoh kode: <a href="">epollexclusive.c</a> (hanya akan berfungsi dengan versi kernel dari 4.5) </p><br><p>  Kami mendapatkan model pre-fork di epoll.  Skema ini berlaku untuk koneksi TCP <strong>jangka pendek</strong> . </p><br><h1 id="read">  baca </h1><br><p>  Tetapi dengan <strong>read ()</strong> dalam hal byte-streaming, <strong>EPOLLEXCLUSIVE</strong> , seperti <strong>EPOLLET,</strong> tidak akan membantu kami. </p><br><p>  Untuk alasan yang jelas, tanpa <strong>EPOLLEXCLUSIVE</strong> kita tidak dapat menggunakan pemicu level sama sekali.  Dengan <strong>EPOLLEXCLUSIVE,</strong> semuanya tidak lebih baik, karena kita bisa mendapatkan paket yang tersebar di stream, selain itu dengan urutan byte yang tidak diketahui telah tiba. </p><br><p>  Dengan <strong>EPOLLET,</strong> situasinya sama. </p><br><p>  Dan di sini <strong>EPOLLONESHOT</strong> dengan reinitialization setelah menyelesaikan pekerjaan akan menjadi <strong>jalan</strong> keluar.  Jadi, segera setelah satu utas akan berfungsi dengan deskriptor dan buffer file ini: </p><br><ul><li>  handle ditambahkan ke <strong>epoll</strong> dengan flag <strong>EPOLLONESHOT |</strong>  <strong>EPOLLET</strong> </li><li>  menunggu di <strong>epoll_wait ()</strong> </li><li>  baca dari socket ke buffer sampai <strong>read ()</strong> mengembalikan <strong>EAGAIN</strong> </li><li>  menginisialisasi ulang dengan flag <strong>EPOLLONESHOT |</strong>  <strong>EPOLLET</strong> </li></ul><br><h1 id="struct--epoll_event">  struct epoll_event </h1><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> epoll_data { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ptr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> u32; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> u64; } <span class="hljs-keyword"><span class="hljs-keyword">epoll_data_t</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">epoll_event</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> events; <span class="hljs-comment"><span class="hljs-comment">/* Epoll events */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">epoll_data_t</span></span> data; <span class="hljs-comment"><span class="hljs-comment">/* User data variable */</span></span> };</code> </pre> <br><p>  Item ini mungkin satu-satunya di artikel saya IMHO pribadi saya.  Kemampuan untuk menggunakan pointer atau angka sangat membantu.  Misalnya, menggunakan pointer saat menggunakan epoll memungkinkan Anda melakukan trik seperti ini: </p><br><pre> <code class="hljs go">#define container_of(ptr, <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, member) ({ \ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> typeof( ((<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>)-&gt;member ) *__mptr = (ptr); \ (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> *)( (char *)__mptr - offsetof(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>,member) );}) <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client { <span class="hljs-comment"><span class="hljs-comment">/** some usefull associated data...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_event event; }; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client* to_epoll_client(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_event* event) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container_of(event, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client, event); } <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client ec; ... epoll_ctl(efd, EPOLL_CTL_ADD, fd, &amp;ec.e); ... epoll_wait (efd, events, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> epoll_client* ec_ = to_epoll_client(events[<span class="hljs-number"><span class="hljs-number">0</span></span>].data.ptr);</code> </pre> <br><p>  Saya pikir semua orang tahu dari mana teknik ini berasal. </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Saya harap kami bisa membuka topik <strong>epoll</strong> .  Mereka yang ingin menggunakan mekanisme ini secara sadar, hanya perlu membaca artikel dalam daftar referensi [1, 2, 3, 5]. </p><br><p>  Berdasarkan materi ini (dan bahkan lebih baik membaca materi dari daftar referensi), Anda dapat membuat server pre-fork (pembuatan proses awal) multi-threaded (tanpa proses pemblokiran) atau merevisi strategi yang ada berdasarkan sifat khusus <strong>epoll ()</strong> ). </p><br><p>  <strong>epoll adalah</strong> salah satu mekanisme unik yang perlu diketahui oleh orang-orang yang memilih jalur pemrograman Linux, karena mereka memberikan keuntungan serius dibandingkan sistem operasi lain), dan, mungkin, akan menolak cross-platforming untuk kasus tertentu (biarkan bekerja hanya di Linux tetapi akan melakukannya dengan baik). </p><br><h2 id="rassuzhdeniya-ob-specifichnosti-zadachi">  Penalaran tentang "kekhususan" masalah </h2><br><p>  Sebelum seseorang berbicara tentang kekhasan bendera dan pola penggunaan ini, saya ingin bertanya: </p><br><p>  "Tapi bukankah kita mencoba membahas spesifisitas untuk mekanisme yang diciptakan untuk tugas-tugas spesifik pada awalnya [9, 11]? Atau apakah kita bahkan melayani koneksi 1k adalah tugas harian bagi seorang programmer?" </p><br><p>  Saya tidak mengerti konsep "tugas khusus", ini mengingatkan saya pada semua jenis tangisan tentang kegunaan dan kesia-siaan dari berbagai disiplin ilmu yang diajarkan.  Membiarkan diri kita untuk bernalar dengan cara ini, kita memberikan kepada diri kita sendiri hak untuk memutuskan bagi orang lain informasi mana yang berguna bagi mereka dan mana yang tidak berguna, sementara, ingatlah, tidak berpartisipasi dalam proses pendidikan secara keseluruhan. </p><br><p>  Untuk skeptis, beberapa tautan: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Meningkatkan kinerja dengan SO_REUSEPORT di NGINX 1.9.1 - VBart</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Belajar dari Unicorn: kawanan accept () bergemuruh tidak bermasalah - Chris Siebenmann</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Serializing accept (), AKA Thundering Herd, AKA the Zeeg Problem - Roberto De Ioris</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana cara mode EPOLLEXCLUSIVE epoll berinteraksi dengan pemicu level?</a> </p><br><h1 id="spisok-literatury">  Referensi </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pilih rusak secara fundamental - Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Epoll pada dasarnya rusak 1/2 - Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Epoll secara fundamental rusak 2/2 - Marek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah C10K - Dan Kegel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Poll vs Epoll, sekali lagi - Jacques Mattheij</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">epoll - Fasilitas notifikasi acara I / O - The Mann</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metode untuk kegilaan epoll - Cindy Sridharan</a> </li></ol><br><h2 id="benchmarks">  Tingkatan yang dicapai </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.kernel.org/doc/ols/2004/ols2004v1-pages-215-226.pdf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://lse.sourceforge.net/epoll/index.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://mvitolin.wordpress.com/2015/12/12/endurox-testing-epollexclusive-flag/</a> </li></ol><br><h2 id="evolyuciya-epoll">  Evolusi epoll </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://lwn.net/Articles/13918/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://lwn.net/Articles/520012/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://lwn.net/Articles/520198/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://lwn.net/Articles/542629/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://lwn.net/Articles/633422/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://lwn.net/Articles/637435/</a> </li></ol><br><h1 id="postskriptum">  Catatan tambahan </h1><br><p>  Banyak terima kasih kepada Sergey ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">dlinyj</a> ) dan Peter Ovchenkov untuk diskusi, komentar, dan bantuan yang berharga! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416669/">https://habr.com/ru/post/id416669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416657/index.html">Dua pertiga kartu memori bekas berisi data pribadi pemilik sebelumnya</a></li>
<li><a href="../id416659/index.html">Karena apa volume pembayaran digital untuk ekonomi pertunjukan akan mencapai $ 1,2 triliun dolar</a></li>
<li><a href="../id416661/index.html">Tren apa yang harus dipertimbangkan oleh pengguna dan penyedia mobile banking</a></li>
<li><a href="../id416665/index.html">Menggunakan kembali Perpustakaan Android Pribadi dengan Sonatype Nexus Repository OSS</a></li>
<li><a href="../id416667/index.html">Isolasi debu dan kebisingan dari unit sistem lama</a></li>
<li><a href="../id416673/index.html">Solusi analitis untuk manajer</a></li>
<li><a href="../id416677/index.html">Kacamata Cyberpunk dan Cermin: Refleksi dalam Mode dan Budaya</a></li>
<li><a href="../id416679/index.html">Komputasi periferal: pertandingan persahabatan "kabut" dengan "awan"</a></li>
<li><a href="../id416681/index.html">Bagaimana dari PostgreSQL dan ClickHouse di Python banyak, cepat dan langsung di numpy</a></li>
<li><a href="../id416683/index.html">Apa selanjutnya Atau bagaimana memilih fitur untuk pengembangan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>