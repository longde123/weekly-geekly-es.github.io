<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😞 👵🏽 🌂 Percabangan yang salah diprediksi dapat secara signifikan meningkatkan waktu pelaksanaan program 🕹️ 🥔 👐🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prosesor modern adalah superscalar, yaitu, mereka dapat menjalankan beberapa instruksi secara bersamaan. Misalnya, beberapa prosesor dapat memproses d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Percabangan yang salah diprediksi dapat secara signifikan meningkatkan waktu pelaksanaan program</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472214/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/0a4/307/7ec0a4307d749114c76ad30d974de620.png" alt="gambar"></div><br>  Prosesor modern adalah superscalar, yaitu, mereka dapat menjalankan beberapa instruksi secara bersamaan.  Misalnya, beberapa prosesor dapat memproses dari empat hingga enam instruksi per siklus.  Selain itu, banyak prosesor seperti itu mampu memulai instruksi rusak: mereka dapat mulai bekerja dengan perintah yang terletak di kode jauh kemudian. <br><br>  Pada saat yang sama, kode sering berisi cabang ( <code>if–then</code> ).  Cabang-cabang tersebut sering diimplementasikan sebagai "transisi", di mana prosesor dapat melanjutkan untuk menjalankan instruksi di bawah kode atau melanjutkan jalur saat ini. <br><br>  Dengan eksekusi perintah superscalar yang rusak, percabangan menjadi sulit.  Untuk ini, prosesor memiliki blok prediksi cabang yang canggih.  Artinya, prosesor sedang mencoba untuk memprediksi masa depan.  Ketika dia melihat cabang, dan karena itu transisi, dia mencoba menebak ke arah mana program akan berjalan. <br><a name="habracut"></a><br>  Sangat sering ini bekerja dengan baik.  Sebagai contoh, sebagian besar loop diimplementasikan sebagai cabang.  Pada akhir setiap iterasi loop, prosesor harus memprediksi apakah iterasi berikutnya akan dilakukan.  Seringkali lebih aman bagi prosesor untuk memprediksi bahwa siklus akan berlanjut (selamanya).  Dalam hal ini, prosesor secara keliru memprediksi hanya satu cabang per siklus. <br><br>  Ada contoh umum lainnya.  Jika Anda mengakses konten array, maka banyak bahasa pemrograman menambahkan "memeriksa terikat" - pemeriksaan tersembunyi dari kebenaran indeks sebelum mengakses nilai array.  Jika indeks tidak benar, kesalahan dihasilkan, jika tidak kode terus dieksekusi dengan cara biasa.  Pemeriksaan perbatasan dapat diprediksi, karena dalam situasi normal semua operasi akses harus benar.  Akibatnya, sebagian besar prosesor seharusnya memprediksi hasil dengan sempurna. <br><br><h2>  Apa yang terjadi jika percabangan sulit diprediksi? </h2><br>  Di dalam prosesor, semua instruksi yang telah dieksekusi tetapi berada pada cabang yang diprediksi salah harus dibatalkan, dan perhitungan harus dimulai lagi.  Diharapkan bahwa untuk setiap kesalahan prediksi cabang kami membayar lebih dari 10 siklus.  Karena itu, waktu pelaksanaan program dapat meningkat secara signifikan. <br><br>  Mari kita lihat kode sederhana di mana kita menulis bilangan bulat acak ke dalam array keluaran: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (howmany != <span class="hljs-number"><span class="hljs-number">0</span></span>) { out[index] = random(); index += <span class="hljs-number"><span class="hljs-number">1</span></span>; howmany--; }</code> </pre> <br>  Kami dapat menghasilkan angka acak yang cocok rata-rata selama 3 siklus.  Artinya, total keterlambatan generator angka acak dapat sama dengan 10 siklus.  Tetapi prosesor kami adalah superscalar, yaitu, kami dapat melakukan beberapa perhitungan angka acak secara bersamaan.  Oleh karena itu, kami akan dapat menghasilkan angka acak baru kira-kira setiap 3 siklus. <br><br>  Mari kita ubah fungsi sedikit sehingga hanya angka ganjil ditulis ke array: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (howmany != <span class="hljs-number"><span class="hljs-number">0</span></span>) { val = random(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( val is an odd integer ) { out[index] = val; index += <span class="hljs-number"><span class="hljs-number">1</span></span>; } howmany--; }</code> </pre> <br>  Anda mungkin secara naif berpikir bahwa fitur baru ini mungkin lebih cepat.  Dan faktanya, karena kita perlu mencatat rata-rata hanya satu dari dua bilangan bulat.  Ada cabang dalam kode, tetapi untuk memeriksa paritas bilangan bulat, cukup periksa satu bit. <br><br>  Saya membandingkan kedua fungsi ini dalam C ++ pada prosesor Skylake: <br><br><div class="scrollable-table"><table><tbody><tr><td>  Rekam semua angka acak </td><td>  3,3 siklus pada bilangan bulat </td></tr><tr><td>  Hanya menulis angka acak ganjil </td><td>  15 siklus pada integer </td></tr></tbody></table></div><br>  Fungsi kedua bekerja sekitar lima kali lebih lama! <br><br>  Adakah yang bisa diperbaiki di sini?  Ya, kita bisa menghilangkan percabangan saja.  Integer ganjil dapat dikarakterisasi sedemikian rupa sehingga merupakan bitwise logis DAN dengan nilai 1 sama dengan satu.  Caranya adalah dengan menambah indeks array dengan satu hanya jika nilai acaknya ganjil. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (howmany != <span class="hljs-number"><span class="hljs-number">0</span></span>) { val = random(); out[index] = val; index += (val bitand <span class="hljs-number"><span class="hljs-number">1</span></span>); howmany--; }</code> </pre> <br>  Dalam versi baru ini, kami selalu menulis nilai acak ke array output, bahkan jika itu tidak diperlukan.  Sepintas, ini adalah pemborosan sumber daya.  Namun, itu menyelamatkan kita dari cabang-cabang yang diprediksi secara keliru.  Dalam praktiknya, kinerjanya hampir sama dengan kode asli, dan jauh lebih baik daripada versi dengan cabang: <br><br><div class="scrollable-table"><table><tbody><tr><td>  Rekam semua angka acak </td><td>  3,3 siklus pada bilangan bulat </td></tr><tr><td>  hanya menulis angka acak ganjil </td><td>  15 siklus pada integer </td></tr><tr><td>  <strong>dengan bercabang dihilangkan</strong> </td><td>  <strong>3,8 siklus per bilangan bulat</strong> </td></tr></tbody></table></div><br>  Bisakah kompiler menyelesaikan masalah ini sendiri?  Secara umum, jawabannya adalah tidak.  Terkadang kompiler memiliki opsi untuk sepenuhnya menghilangkan percabangan, bahkan jika ada pernyataan <code>if-then</code> dalam kode sumber.  Misalnya, percabangan kadang-kadang dapat diganti dengan "conditional move" atau trik aritmatika lainnya.  Namun, trik semacam itu tidak aman untuk digunakan dalam kompiler. <br><br>  Kesimpulan penting: percabangan yang diprediksi secara keliru bukanlah masalah yang tidak signifikan, ia memiliki pengaruh yang besar. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sumber saya ada di Github</a> . <br><br><h2>  Membuat tolok ukur adalah tugas yang sulit: prosesor belajar untuk memprediksi percabangan </h2><br>  [Catatan  terjemahan: bagian ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terpisah</a> dari penulis, tetapi saya menggabungkannya dengan yang sebelumnya, karena mereka memiliki tema yang sama.] <br><br>  Pada bagian sebelumnya, saya menunjukkan bahwa sebagian besar waktu eksekusi suatu program dapat disebabkan oleh prediksi cabang yang salah.  Tolok ukur saya adalah menulis 64 juta nilai integer acak ke sebuah array.  Ketika saya mencoba untuk merekam hanya angka acak ganjil, kinerja karena prediksi yang salah sangat menurun. <br><br>  Mengapa saya menggunakan 64 juta bilangan bulat, bukan, katakanlah, 2000?  Jika Anda menjalankan hanya satu tes, maka itu tidak masalah.  Namun, apa yang akan terjadi jika kita melakukan banyak upaya?  Jumlah cabang yang keliru diprediksi akan dengan cepat turun ke nol.  Kinerja prosesor Intel Skylake berbicara untuk dirinya sendiri: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Jumlah tes </th><th>  Cabang yang Diprediksi Salah (Intel Skylake) </th></tr><tr><td>  1 </td><td>  48% </td></tr><tr><td>  2 </td><td>  38% </td></tr><tr><td>  3 </td><td>  28% </td></tr><tr><td>  4 </td><td>  22% </td></tr><tr><td>  5 </td><td>  14% </td></tr></tbody></table></div><br>  Seperti dapat dilihat dari grafik di bawah ini, "pelatihan" berlanjut lebih jauh.  Secara bertahap, proporsi cabang yang diprediksi salah turun menjadi sekitar 2%. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/0a4/307/7ec0a4307d749114c76ad30d974de620.png" width="640" height="480"></div><br>  Artinya, jika kita terus mengukur waktu yang diambil oleh tugas yang sama, maka itu menjadi semakin berkurang, karena prosesor belajar untuk memprediksi hasil dengan lebih baik.  Kualitas "pelatihan" tergantung pada model prosesor tertentu, tetapi diharapkan prosesor yang lebih baru harus belajar lebih baik. <br><br>  Prosesor server AMD terbaru belajar untuk memprediksikan percabangan hampir sempurna (dalam 0,1%) dalam waktu kurang dari 10 upaya. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Jumlah tes </th><th>  Cabang yang Diprediksi Salah (AMD Rome) </th></tr><tr><td>  1 </td><td>  52% </td></tr><tr><td>  2 </td><td>  18% </td></tr><tr><td>  3 </td><td>  6% </td></tr><tr><td>  4 </td><td>  2% </td></tr><tr><td>  5 </td><td>  1% </td></tr><tr><td>  6 </td><td>  0,3% </td></tr><tr><td>  7 </td><td>  0,15% </td></tr><tr><td>  8 </td><td>  0,15% </td></tr><tr><td>  9 </td><td>  0,1% </td></tr></tbody></table></div><br>  Prediksi ideal pada AMD Roma ini menghilang ketika jumlah nilai dalam masalah meningkat dari 2000 menjadi 10.000: prediksi terbaik berubah dari sebagian kecil kesalahan dari 0,1% menjadi 33%. <br><br>  Anda mungkin harus menghindari kode pembandingan dengan percabangan untuk tugas-tugas kecil. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode github saya</a> . <br><br>  <strong>Pengakuan</strong> : Nilai-nilai AMD Rome diberikan oleh Vel Erwan. <br><br>  <strong>Bacaan tambahan</strong> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kasus untuk (sebagian) prediksi cabang panjang sejarah GEometrik TAgged</a> (Seznec et al.) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472214/">https://habr.com/ru/post/id472214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472202/index.html">Windows 10 + Python = VS Code + WSL</a></li>
<li><a href="../id472204/index.html">Eksperimen sederhana dengan mikrokontroler STM32F103 (Blue Tablet)</a></li>
<li><a href="../id472208/index.html">Layar OLED smartphone Android dan cara menghadapinya</a></li>
<li><a href="../id472210/index.html">"Sepertinya ini sudah terjadi?" Cari insiden dan klaim serupa</a></li>
<li><a href="../id472212/index.html">Bagaimana cara mendaratkan Pesawat Ulang-alik dari luar angkasa</a></li>
<li><a href="../id472216/index.html">Apa yang harus kita bangun IOT? IoT Anda di Amazon dalam Satu Hari</a></li>
<li><a href="../id472220/index.html">Mengapa fisikawan papan atas tidak menyukai interpretasi multi-dunia</a></li>
<li><a href="../id472222/index.html">“Baca jika Anda suka mendengarkan”: buku-buku untuk mereka yang tidak acuh pada musik - dari klasik hingga hip-hop</a></li>
<li><a href="../id472224/index.html">Menggunakan NVMe SSD baru sebagai disk boot pada sistem lama dengan Legacy BIOS (untuk OS apa pun)</a></li>
<li><a href="../id472226/index.html">Meningkatkan kontrol formulir di Microsoft Edge dan Chromium</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>