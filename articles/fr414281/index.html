<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêü ü§∞üèº ü§∏ D√©veloppement d'un compteur de vitesse de v√©lo bas√© sur un √©cran du Nokia 3310 üë©üèæ‚Äçüé® üìª ‚òπÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="R√©cemment, les compteurs de v√©lo dits num√©riques (ordinateurs de cycle) se sont r√©pandus parmi les accessoires de v√©lo. Ces appareils sont capables de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©veloppement d'un compteur de vitesse de v√©lo bas√© sur un √©cran du Nokia 3310</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414281/">  R√©cemment, les compteurs de v√©lo dits num√©riques (ordinateurs de cycle) se sont r√©pandus parmi les accessoires de v√©lo.  Ces appareils sont capables de mesurer de nombreux param√®tres, dont les principaux sont la vitesse et la distance.  Le principe de mesure de la vitesse est bas√© sur le calcul de la p√©riode de r√©volution de la roue, et la distance est calcul√©e sur la base de la mesure du nombre de telles r√©volutions.  Souvent, le capteur de r√©volution des roues est un interrupteur √† lames combin√© √† un aimant sur le rayon de la roue.  Selon la fonctionnalit√©, le prix de ces appareils varie consid√©rablement.  Le compteur de vitesse de v√©lo le moins cher peut √™tre achet√© pour environ 500 p. <br><br>  J'ai toujours eu envie d'avoir un appareil similaire.  Dans le m√™me temps, j'ai formul√© un certain nombre de mes propres exigences, auxquelles il devrait satisfaire.  Tout d'abord, je voulais vraiment voir un graphique des changements de vitesse en fonction de la distance ou du temps accumul√© sur une courte p√©riode au fur et √† mesure de ses d√©placements.  Et aussi, pour enregistrer (enregistrer) les mesures sur un p√©riph√©rique de stockage pour un transfert ult√©rieur des donn√©es statistiques vers un ordinateur, leur visualisation plus d√©taill√©e.  Les mod√®les bon march√© ne r√©pondent pas enti√®rement √† mes exigences, mais je ne veux pas payer trop cher pour des mod√®les co√ªteux. <br><a name="habracut"></a><br>  Sur la base de ce qui pr√©c√®de, j'ai d√©cid√© de cr√©er mon propre compteur de vitesse de v√©lo bas√© sur le microcontr√¥leur ATmega8.  De nombreuses questions ont √©t√© pos√©es, notamment sur les p√©riph√©riques utilis√©s.  Je suis tomb√© par hasard sur des articles sur l'utilisation de l'√©cran du t√©l√©phone mobile Nokia 3310. Apr√®s avoir lu la fiche technique et v√©rifi√© qu'il √©tait simple √† utiliser, je ne doutais pas que l'indicateur de vitesse serait fabriqu√© dans le corps du t√©l√©phone susmentionn√© avec son propre √©cran.  Le bo√Ætier est assez bon, et l'appareil lui-m√™me n'est pas difficile √† trouver. <br><br><img src="https://habrastorage.org/webt/co/vu/d2/covud2fzqkaw8fiojo2mes8xfl4.png"><br><br>  En tant que ROM pour l'enregistrement des statistiques de mesure, j'ai d√©cid√© de mettre une ROM 24XX512 classique (512 Kbps), qui est contr√¥l√©e via l'interface I2C.  Je n'ai pas pris la peine d'utiliser une carte m√©moire SD / MMC.  Une autre fonction importante de l'appareil est la montre.  Ils servent √† lier certains param√®tres sp√©cifiques mesur√©s (par exemple, la vitesse maximale) √† la date et √† l'heure, et sont √©galement n√©cessaires pour enregistrer des horodatages dans les statistiques.  En tant qu'horloge, j'ai utilis√© une puce d'horloge en temps r√©el (RTC) distincte du microcontr√¥leur, qui a une alimentation ind√©pendante de la batterie et communique √©galement avec le contr√¥leur via I2C. <br><br>  J'ai impl√©ment√© des exigences secondaires suppl√©mentaires dans la fonctionnalit√© de l'appareil au stade de l'√©criture du programme.  Cela inclut toutes sortes de probl√®mes d'organisation: le nombre de boutons impliqu√©s, l'emplacement sur l'affichage de divers √©l√©ments, la navigation sur l'interface, etc.  En termes de navigation, j'ai d√©cid√© √† l'avance de ne pas compliquer le programme, par exemple, de ne pas impl√©menter le menu des param√®tres, en particulier les param√®tres de date et d'heure.  L'horloge est r√©gl√©e une fois.  L'horloge tourne ind√©pendamment dans la puce RTC elle-m√™me, gr√¢ce √† un quartz √† 32,768 KHz et √† une batterie qui dure longtemps.  Les r√©glages de la date et de l'heure sont effectu√©s via l'interface UART du compteur de vitesse, connect√© au port COM de l'ordinateur en un clic.  √Ä travers la m√™me interface, il √©tait cens√© lire les donn√©es statistiques de la ROM sur un ordinateur.  Pour tout cela, vous devez √©crire le programme appropri√© pour l'ordinateur.  Cependant, comme le montre la pratique, ce dernier a d√ª √™tre abandonn√©.  Premi√®rement, il y avait le probl√®me de mettre en ≈ìuvre la r√©ception des donn√©es du contr√¥leur vers l'ordinateur au stade de l'√©criture d'un programme informatique.  Et, encore plus important, le volume du programme pour le contr√¥leur a augment√©.  Il √©tait beaucoup plus int√©ressant de placer la ROM (dans le bo√Ætier SMIC SOIC-8) sur une plate-forme amovible, proportionnelle √† la carte SIM et d'utiliser l'emplacement libre appropri√© sur le t√©l√©phone mobile.  Pour ce faire, il est n√©cessaire de fabriquer un lecteur ROM bas√© sur un lecteur SIM selon l'un des sch√©mas bien connus du programmeur I2C ROM.  Comme il s'est av√©r√© plus tard, cette d√©cision n'a pas caus√© d'inconv√©nients inutiles. <br><br>  Un autre probl√®me important est la sortie d'informations symboliques (y compris num√©riques) sur un √©cran graphique.  Cela n√©cessite des informations graphiques sur un symbole particulier.  Ces informations sont √©troitement li√©es √† un param√®tre tel que la taille de la police affich√©e.  Pour afficher le param√®tre principal, la vitesse de d√©placement, pour une bonne clart√©, il est souhaitable d'utiliser une grande police.  Cependant, comme nous le montrerons plus loin, de telles informations graphiques sur dix chiffres ne rentreront pas dans la m√©moire de MK, et l'utilisation de la m√™me ROM externe plus spacieuse ralentira la vitesse de dessin de la police.  J'ai d√©cid√© d'utiliser une police d'une hauteur de 8 points comme police la plus grande.  J'ai tir√© les informations graphiques de cette police du fichier ¬´8X8.FNT¬ª d'un programme de MS DOS, apr√®s avoir d√©m√™l√© sa structure et effectu√© un traitement ult√©rieur. <br><br><img src="https://habrastorage.org/webt/wu/eo/ft/wueoftqpob-qnbg5kpd3phvlfes.png"><br><br>  Comme il s'est av√©r√© plus tard dans la pratique, cette taille est assez suffisante pour la clart√© de la vitesse.  Comme taille pour la police suppl√©mentaire, j'ai choisi la taille 3x5 et dessin√© ind√©pendamment les graphiques pour les num√©ros de cette taille.  Ces petits nombres affichent des param√®tres suppl√©mentaires: date / heure, vitesse moyenne et maximale, chemin. <br><br>  Les informations graphiques des deux polices sont stock√©es dans certains tableaux bidimensionnels.  Chaque √©l√©ment de tableau, d'une taille de 1 octet, indique la distribution de pixels d'une colonne particuli√®re d'un chiffre sp√©cifique.  Pour les gros caract√®res, 8 colonnes sont allou√©es pour chaque chiffre et 3 pour 3. Pour les petits caract√®res de taille 3X5, la hauteur formelle n'est pas 5, mais 8 points (arrondi √† un octet).  Cela vous permet de pr√©-organiser l'emplacement de la police √† 5 positions dans la zone √† 8 positions dans le sens vertical en utilisant l'une des 4 m√©thodes possibles.  Ces faits sont bien affich√©s dans la figure ci-dessous, qui montre la mod√©lisation des graphiques pour les deux premiers chiffres de cette police.  Excel est bien connu pour la mod√©lisation.  Les donn√©es initiales sont la disposition des "unit√©s" dans les champs appropri√©s pour les graphiques souhait√©s.  Parmi celles-ci, les formules calculent les valeurs des tableaux, jusqu'au code du langage C, qui peut ensuite √™tre copi√© dans le texte du programme pour le microcontr√¥leur. <br><br><img src="https://habrastorage.org/webt/fh/ls/ov/fhlsov48egokegrdbnlteowsxh0.png"><br><br>  Nous allons maintenant parler des fonctions de contr√¥le de l'√©cran utilis√©.  Cet √©cran est monochrome et ses dimensions sont de 84 par 48 pixels.  Le contr√¥le de l'affichage √† partir du MK s'effectue via l'interface SPI.  Les octets transmis par SPI sont interpr√©t√©s dans l'affichage en deux modes: octets pour l'affichage et octets des commandes de configuration.  Ces modes sont d√©finis par le MK lui-m√™me pour une broche d'affichage sp√©cifique (D / C).  Une liste compl√®te des commandes est donn√©e dans la fiche technique √† l'√©cran.  Certaines de ces commandes sont utilis√©es dans mon appareil et sont utilis√©es pour initialiser l'affichage lorsque l'alimentation est appliqu√©e √† l'appareil: coefficient de temp√©rature, contraste, mode de dessin s√©quentiel (horizontal ou vertical), etc.  Je constate tout de suite que le mode de dessin horizontal est appliqu√©.  Cela signifie que lors du transfert d'un octet en mode d'affichage, l'adresse augmente automatiquement d'une ligne par ligne vers la droite.  Lorsque la ligne se termine, l'adresse de position va au d√©but de la ligne suivante.  Il suffit d'envoyer d'abord une commande de positionnement sp√©ciale √† l'√©cran √† une adresse de ligne et de colonne sp√©cifique (position initiale), puis d'envoyer les octets de donn√©es les uns apr√®s les autres pour afficher les graphiques.  Il convient de noter la caract√©ristique de l'espace d'adressage et l'interpr√©tation des graphiques, en fonction des octets re√ßus par l'affichage.  Je note que pour les graphiques monochromes, un octet contient des informations sur huit pixels √† la fois. <br><br>  L'affichage en question est divis√© verticalement en 6 zones horizontales de 8 lignes chacune (6 * 8 = 48).  Chaque colonne de chaque zone correspondra √† un octet sp√©cifique, qui sera envoy√© avec l'adresse de la colonne correspondante (0 ... 83) et le num√©ro de zone (0 ... 5).  L'adresse n'est pas compt√©e √† partir de un, √† partir de z√©ro.  Par exemple, si vous vous positionnez √† l'adresse (34; 2) et envoyez un octet de donn√©es de 255 (sous la forme binaire ¬´11111111¬ª), alors les 8 pixels s'allument de 16 √† 23 verticalement et dans la 35e colonne horizontalement.  √Ä mon avis, l'un des inconv√©nients d√©coule de cette caract√©ristique: l'incapacit√© de contr√¥ler l'√©tat de chaque pixel individuellement au niveau mat√©riel.  Un octet est la plus petite donn√©e pour les graphiques.  Lorsqu'un octet est transmis √† l'adresse actuelle, les 8 pixels correspondants de la zone actuelle sont mis √† jour.  L'√©cran ne prend pas en charge la lecture des informations graphiques actuellement affich√©es vers le microcontr√¥leur.  Par cons√©quent, si n√©cessaire, il est n√©cessaire de stocker √† l'avance les informations de sortie dans un tampon d√©di√© et de modifier l'√©tat de tout pixel (bits), d'appliquer des masques de bits pour les octets de ce tampon et de les transf√©rer √† nouveau sur l'affichage. <br><br>  La mod√©lisation et la r√©flexion sur l'emplacement d'une information graphique particuli√®re sur l'√©cran ont √©t√© effectu√©es en tenant compte des caract√©ristiques ci-dessus.  Cela a √©t√© fait pour simplifier le code lors de l'√©criture du programme.  Et ce n'est pas par hasard que la taille de la police a √©t√© consid√©r√©e dans la cat√©gorie 8, 16, 24, c'est-√†-dire un multiple de 8. J'ai √©galement divis√© les informations graphiques, par analogie avec l'affichage, en 6 zones horizontales.  Dans la premi√®re zone, les valeurs absolues et actuelles (√† partir du moment o√π l'appareil est allum√©) sont affich√©es en petits caract√®res.  Dans la deuxi√®me zone, les valeurs absolues et actuelles du chemin (en kilom√®tres avec arrondi aux centi√®mes).  Dans la troisi√®me zone - vitesse moyenne.  Dans le quatri√®me - vitesse maximale et en gros caract√®res - la vitesse actuelle.  Dans la cinqui√®me zone, deux barres de progression sont affich√©es pour indiquer que la ROM est pleine et le nombre d'√©crasements.  Dans la sixi√®me, derni√®re zone, la date et l'heure.  C'est la cinqui√®me zone qui fait exception lorsque dans la direction verticale de n'importe quelle colonne prise il y a des pixels li√©s √† diff√©rentes informations.  Par cons√©quent, ces informations √† l'aide de masques de bits sont collect√©es dans un tampon, dont le contenu est ensuite affich√© sur cette cinqui√®me zone.  De plus, dans 3 √† 5 zones, des informations permettent de tracer un cadre autour de la valeur de vitesse affich√©e.  Dans la derni√®re zone, chaque premier bit (le moins significatif) de toutes les colonnes est d√©fini sur ¬´1¬ª pour tracer la ligne de s√©paration (40e ligne).  Pour cette simulation et visualisation des adresses, j'ai repr√©sent√© tout ce qui pr√©c√®de dans des cellules Excel. <br><br><img src="https://habrastorage.org/webt/nd/5z/vk/nd5zvk7smre6acj0voalhm5bimi.png"><br><br>  Voici √† quoi ressemble la premi√®re fen√™tre d'affichage.  Seulement deux fen√™tres.  La deuxi√®me fen√™tre est la sortie du graphique (histogramme) du mouvement.  Pour cela, 5 zones sont attribu√©es (40 lignes) verticalement et les 84 colonnes horizontalement.  La sixi√®me zone avec l'horloge est la m√™me pour les deux fen√™tres. <br><br>  Lors de la programmation, j'ai d√©cid√© de ne recourir √† aucune biblioth√®que pour travailler avec cet affichage.  Personnellement, il m‚Äôest plus facile de comprendre la fiche technique, d‚Äôimpl√©menter moi-m√™me une partie des fonctions que de comprendre la biblioth√®que.  De plus, certains avantages y ont √©t√© trouv√©s.  R√©cemment, apr√®s avoir t√©l√©charg√© une des biblioth√®ques, j'ai n√©anmoins d√©couvert ses fonctionnalit√©s.  Il est universel, avec son aide, vous pouvez contr√¥ler les pixels individuellement et vous positionner sur la v√©ritable adresse des pixels.  Mais la biblioth√®que utilise un tampon de 84 * 6 octets, et ce tampon de minuterie est p√©riodiquement envoy√© √† l'√©cran, mettant √† jour les graphiques.  Ainsi, le temporisateur et une partie de la m√©moire MK sont occup√©s.  Dans mon cas particulier, il n'est pas n√©cessaire d'utiliser une biblioth√®que, car lors de la mod√©lisation, j'ai pris soin √† l'avance de maximiser la s√©paration des informations entre les zones affich√©es, qui sont en totale conformit√© avec les zones d'affichage.  Et il n'est pas n√©cessaire de mettre √† jour p√©riodiquement les informations √† l'√©cran: les informations ne sont mises √† jour que si et seulement quand elles changent (√† chaque rotation de la roue, √† chaque pression sur un bouton, etc.).  Ainsi, je souligne une fois de plus: selon la t√¢che, vous pouvez √©viter l'utilisation de biblioth√®ques. <br><br>  Pour travailler avec un microcircuit d'horloge et une ROM, je n'ai pas non plus recouru √† l'utilisation de biblioth√®ques: toutes les fonctions sont assez simples et impl√©ment√©es par moi apr√®s avoir √©tudi√© les fiches techniques de ces composants. <br><br>  Consid√©rons maintenant le circuit √©lectrique de l'appareil. <br><br><img src="https://habrastorage.org/webt/fj/6h/ry/fj6hryk8yrvhu4wr9ckd9njfkj0.png"><br><br>  La disposition de l'indicateur de vitesse est relativement simple.  En plus de tout ce qui pr√©c√®de, le circuit contient un √©l√©ment IC5 MAX756, qui sert de convertisseur d'alimentation de 3 √† 5 volts pour une alimentation fiable √† partir de la batterie d'origine du t√©l√©phone mobile Nokia 3310. Je n'ai pas mis en ≈ìuvre le circuit pour une alimentation de 3 volts en raison du manque de MK et de p√©riph√©riques appropri√©s.  √Ä l'heure actuelle, je n'ai pas encore acquis le MAX756, et l'ensemble du circuit est toujours aliment√© par une batterie externe Krona utilisant le r√©gulateur LM7805 (pas tout √† fait la meilleure option).  Il se connecte √† la prise casque en bas du t√©l√©phone.  L'interrupteur √† lames SF1, qui est un capteur de rotation de roue, est connect√© au port d'interruption INT0 MK (broche 32).  Il se connecte en toute s√©curit√© du bas du t√©l√©phone au port de charge.  Les boutons fonctionnels S1-S3 connect√©s aux boutons ¬´1¬ª, ¬´2¬ª, ¬´3¬ª du t√©l√©phone mobile sont connect√©s √† des ports arbitraires (broches 23, 27, 28).  Une broche S4 est connect√©e √† la broche 29 de la r√©initialisation MK, qui co√Øncide avec le bouton d'extr√©mit√© sup√©rieur pour allumer le t√©l√©phone mobile.  Je l'ai fait comme √ßa.  L'appareil lui-m√™me n'a pas de mode veille et se met sous tension.  Un √©cran IC2 et un connecteur pour clignoter X1 sont connect√©s au port SPI du contr√¥leur (broches 15-17).  Avec le connecteur, que je voulais faire sur la base des ¬´spots¬ª existants sur la carte m√®re d'origine pour l'appairage avec un PC (au m√™me endroit), j'ai eu un petit hic, et √† l'avenir je le transf√©rerai dans un autre endroit.  Une interface UART pour la connexion de l'utilisateur √† un ordinateur est raccord√©e au m√™me connecteur, via lequel la date et l'heure sur l'appareil sont configur√©es (broches 30-31, RX / TX).  L'√©cran est connect√© au contr√¥leur via des diviseurs sur des r√©sistances, qui servent √† r√©duire la tension, car l'√©cran fonctionne √† une tension de 3,3 V.En outre, les broches d'affichage D / C (donn√©es / commande), SCE (stroboscope) et RES (r√©initialisation de l'affichage) sont connect√©es √† des ports arbitraires MK PB0, PB1 et PB2, respectivement (broches 12-14).  L'affichage est aliment√© par les diodes D1-D3 et la r√©sistance R6, qui servent √† r√©duire la tension de 5 √† 3,3 V, en √©vitant l'utilisation d'un r√©gulateur lin√©aire.  Le quartz Cr1 cadenc√© par MK avec une valeur nominale de 4,5 MHz a √©t√© choisi au hasard, mais d√©lib√©r√©ment.  Il est juste tomb√© dans mon bras et j'ai d√©cid√© de l'utiliser.  Aux ports de MK PD4 et PD5 (broches 2 et 9), des transistors Q1 et Q2 sont connect√©s, sur lesquels les LED pour le r√©tro√©clairage de l'√©cran et du clavier sont charg√©es.  Le contr√¥leur offre la possibilit√© de contr√¥ler les r√©tro-√©clairages individuellement, comme le pr√©voit la disposition d'origine du t√©l√©phone mobile (c'√©tait au niveau du mat√©riel et non au niveau de l'utilisateur), bien qu'en pratique ce ne soit pas n√©cessaire.  Le bus I2C est connect√© aux ports PC2-PC3 (broches 25-26) et, pour plus de simplicit√©, est impl√©ment√© par programme √† l'aide de la biblioth√®que appropri√©e (bien qu'il soit connect√© aux ports mat√©riels TWI).  La ROM IC3 et l'horloge en temps r√©el (RTC) IC4 sont suspendues sur le bus.  Faites imm√©diatement une r√©serve pour qu'il n'y ait pas de critique dans les commentaires: je sais que le DS1307 n'est pas la meilleure solution, mais au moment du d√©veloppement du circuit je ne connaissais pas l'existence du DS3231.  La ROM est situ√©e sur un connecteur amovible, semblable √† une carte SIM.  Un port suppl√©mentaire du contr√¥leur PC1 (broche 24) est utilis√© pour recevoir des impulsions d'une fr√©quence de 1 Hz avec RTC, par lesquelles l'heure sur l'affichage est mise √† jour.  Tous les composants du kit carrosserie passif - selon les fiches techniques de chaque composant actif. <br><br>  Tenez compte des consid√©rations math√©matiques pour calculer certains param√®tres.  Comme d√©j√† mentionn√© au d√©but, le principe de mesure de la vitesse est bas√© sur le calcul de la p√©riode de r√©volution de la roue, et la distance est calcul√©e sur la base de la mesure du nombre de telles r√©volutions.  Le contr√¥leur mesure le temps entre l'impulsion pr√©c√©dente et l'impulsion entrante du commutateur √† lames.  Le r√©sultat de la mesure est converti en valeur de vitesse en divisant la valeur du p√©rim√®tre de la roue par la p√©riode de r√©volution, et cette valeur est mise √† jour sur l'affichage √† chaque impulsion (r√©volution de roue).  Il convient de noter ici que, du point de vue de la physique, la vitesse moyenne d'un v√©lo sur une section de la trajectoire correspondant au p√©rim√®tre de la roue est calcul√©e.  S√©par√©ment, le nombre d'impulsions est calcul√©, puis converti en une valeur de distance.  Pour mesurer la p√©riode de rotation de la roue, le contr√¥leur utilise sa propre minuterie.  ATmega8 a un temporisateur 8 bits et 16 bits.  La plage dynamique de la mesure d√©pend de la profondeur de bits du temporisateur.  Dans mon cas, un temporisateur de 16 bits est utilis√©, car 8 bits (256 comptes de comptes) sont cat√©goriquement insuffisants.  La p√©riode de mesure maximale (avant que la minuterie ne d√©borde) correspondra √† la vitesse mesur√©e minimale.  Vous pouvez entrer ce que l'on appelle la minuterie logicielle, qui mesurera de grandes p√©riodes.  Cependant, pour simplifier le programme, je ne l'ai pas fait.  Avec le quartz utilis√© de 4,5 MHz et une valeur de diviseur maximale de 1024 dans la configuration de la minuterie, nous avons: (1 / (4500000/1024)) = 0,000227556 ‚Äã‚Äãsec.  Cette valeur correspond √† la p√©riode minimale du compte.  Et la p√©riode de compte maximale sera de 0,000227556 ‚Äã‚Äã* 65536 = 14,913 secondes.  La vitesse maximale mesurable correspondant √† la p√©riode minimale mesurable sera d'environ 30 000 km / h.  Cela ne valait m√™me pas la peine d'√™tre stipul√©, la ¬´r√©serve d'en haut¬ª est tout simplement √©norme.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais la vitesse minimale mesur√©e correspondant √† la p√©riode maximale mesur√©e sera de 2,26 / 14,913 / 1000 * 3600 = 0,54 km / h. Ici 2,26 est le p√©rim√®tre de la roue de v√©lo (en m√®tres) dans mon cas. Je suis assez satisfait de cette valeur mesur√©e minimale. Si le v√©lo se d√©place √† une vitesse inf√©rieure √† 0,54 km / h, le compteur de vitesse du v√©lo enregistrera le manque de mouvement (et le d√©bordement de la minuterie). Avec cette interface UART √† quartz de 4,5 MHz, cela fonctionne tr√®s bien √† une vitesse de 2400 bauds avec une erreur acceptable acceptable. Cette vitesse est √©galement assez suffisante, d'autant plus que j'utilise UART pour les param√®tres d'horloge uniques √† partir d'un ordinateur (pour copier la date et l'heure d'un ordinateur vers un appareil). Si vous prenez du quartz en fr√©quence plus √©lev√©e, la vitesse minimale mesurable augmentera, ce qui sera inacceptable pour moi,et vous devrez utiliser une minuterie logicielle. Et si vous le prenez ci-dessous, les performances de l'appareil dans son ensemble diminuent. Par cons√©quent, j'ai d√©cid√© de quitter ce quartz particulier.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je note que les valeurs de p√©riode et de vitesse sont inversement proportionnelles, et la minuterie du microcontr√¥leur mesure la p√©riode discr√®tement. Dans notre cas, la plage de mesure (0,000227556 ‚Äã‚Äã... 14,913) est uniform√©ment marqu√©e par des points d'un montant de 65535, la divisant en plusieurs intervalles √©gaux. Et ces points correspondent √† toutes sortes de valeurs mesur√©es. En utilisant la conversion d'intervalles de temps en vitesse, ce syst√®me d'intervalles est converti d'uniforme en inversement proportionnel. Par cons√©quent, la plage de vitesses mesur√©es de diff√©rentes mani√®res est divis√©e en intervalles in√©gaux. La longueur de ces intervalles augmente avec l'augmentation de la valeur de vitesse elle-m√™me. Compte tenu de ce fait, l'immense "r√©serve d'en haut", sur laquelle j'ai √©crit un peu plus haut, ne fera pas d√©faut. En pratique, il suffira de prendre la valeur de 100 km / h pour la vitesse maximale mesur√©e du v√©lo.Il s'agit simplement de ne pas introduire de nouveau chiffre (des centaines) et de ne pas augmenter la largeur du param√®tre affich√© √† l'√©cran. Nous calculons ce que la longueur de l'intervalle entre les valeurs possibles adjacentes √† une vitesse voisine est √©gale, par exemple, √† 90 km / h. En utilisant les formules inverses ou la s√©lection, il est facile de calculer que pour la valeur du temporisateur 397 (sur 65536 possible) la vitesse mesur√©e correspond √† 90,06 km / h. Et avec une valeur de minuterie voisine de 398 - 89,83 km / h. Et la diff√©rence entre les vitesses est de 0,23 km / h, ce qui est d√©j√† plus qu'acceptable. Et √† des vitesses inf√©rieures, cette diff√©rence sera encore plus petite. L'√©cran affiche la valeur de la vitesse au centi√®me pr√®s. Cependant, dans la pratique, l'arrondi √† l'entier le plus proche ou aux dixi√®mes suffit g√©n√©ralement. De ce qui pr√©c√®de, nous pouvons conclure: la non-uniformit√© de la ¬´grille¬ª des vitesses peut √™tre n√©glig√©e,car l'erreur de mesure qui en r√©sulte ne d√©passe pas l'erreur tol√©r√©e.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour calculer la distance, il suffit de multiplier le nombre d'impulsions (tours) par le p√©rim√®tre de la roue. Dans ce cas, bien s√ªr, la distance est calcul√©e avec pr√©cision au p√©rim√®tre de la roue, ce qui est tout √† fait acceptable. La vitesse moyenne actuelle est calcul√©e comme le rapport de la distance actuelle parcourue √† la valeur de temps √† partir du moment o√π elle a √©t√© allum√©e. C'est le temps que le contr√¥leur consid√®re en comptant le nombre d'impulsions arrivant une fois par seconde avec RTC. La vitesse moyenne sur l'√©cran est mise √† jour avec la mise √† jour de l'heure (une fois par seconde). Tous les autres param√®tres sont mis √† jour √† chaque tour de roue.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant sur les petites fonctionnalit√©s de l'interface. Le premier bouton permet de changer de mode (mode graphique ou mode d'affichage des valeurs). Le deuxi√®me bouton - pour afficher la vitesse maximale absolue (pour tous les temps) au lieu de la relative lorsque vous la maintenez. De plus, la date et l'heure pour atteindre cette vitesse sont affich√©es √† la place de la date et de l'heure actuelles. Et aussi, la valeur de l'adresse ROM actuelle est affich√©e √† la place de la valeur de la vitesse relative (pour le contr√¥le). Cette valeur peut √™tre estim√©e par la barre de progression horizontale sur la 38e ligne de l'√©cran. Sur cette ROM, d'une capacit√© de 65536 octets (512 kbit), les param√®tres mesur√©s sont enregistr√©s. Comme on le dira plus loin, il suffit d'enregistrer le param√®tre initialement mesur√© (la p√©riode de rotation de la roue) avec une marque du temps initial.Tous les autres param√®tres sont facilement calcul√©s par un programme informatique au stade du balayage de la ROM. Le troisi√®me bouton est utilis√© pour contr√¥ler le r√©tro-√©clairage. Contrairement √† l'esquisse d'√©cran ci-dessus, j'ai supprim√© plus tard des z√©ros insignifiants sur les param√®tres secondaires pour les afficher plus clairement. En mode graphique, un histogramme de la vitesse de d√©placement est trac√© de gauche √† droite, ce qui montre clairement le processus de changement de vitesse sur une petite portion de la distance de 84 tours de la roue. La valeur de l'histogramme est la vitesse √† une √©chelle de 1 pixel par 1 km / h. Si la vitesse d√©passe 40 km / h, l'image est r√©duite verticalement de 2 fois pour √©viter de sortir de l'√©chelle. Il n'est pas n√©cessaire de d√©crire ici les caract√©ristiques d√©taill√©es du comportement de l'appareil.Plus tard, j'ai supprim√© des z√©ros insignifiants sur les param√®tres secondaires pour les afficher plus clairement. En mode graphique, un histogramme de la vitesse de d√©placement est trac√© de gauche √† droite, ce qui montre clairement le processus de changement de vitesse sur une petite portion de la distance de 84 tours de la roue. La valeur de l'histogramme est la vitesse √† une √©chelle de 1 pixel par 1 km / h. Si la vitesse d√©passe 40 km / h, l'image est r√©duite verticalement de 2 fois pour √©viter de sortir de l'√©chelle. Il n'est pas n√©cessaire de d√©crire ici les caract√©ristiques d√©taill√©es du comportement de l'appareil.Plus tard, j'ai supprim√© des z√©ros insignifiants sur les param√®tres secondaires pour les afficher plus clairement. En mode graphique, un histogramme de la vitesse de d√©placement est trac√© de gauche √† droite, ce qui montre clairement le processus de changement de vitesse sur une petite portion de la distance de 84 tours de la roue. La valeur de l'histogramme est la vitesse √† une √©chelle de 1 pixel par 1 km / h. Si la vitesse d√©passe 40 km / h, l'image est r√©duite verticalement de 2 fois pour √©viter de sortir de l'√©chelle. Il n'est pas n√©cessaire de d√©crire ici les caract√©ristiques d√©taill√©es du comportement de l'appareil.La valeur de l'histogramme est la vitesse √† une √©chelle de 1 pixel par 1 km / h. Si la vitesse d√©passe 40 km / h, l'image est r√©duite verticalement de 2 fois pour √©viter de sortir de l'√©chelle. Il n'est pas n√©cessaire de d√©crire ici les caract√©ristiques d√©taill√©es du comportement de l'appareil.La valeur de l'histogramme est la vitesse √† une √©chelle de 1 pixel par 1 km / h. Si la vitesse d√©passe 40 km / h, l'image est r√©duite verticalement de 2 fois pour √©viter de sortir de l'√©chelle. Il n'est pas n√©cessaire de d√©crire ici les caract√©ristiques d√©taill√©es du comportement de l'appareil.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient de noter l'une des diff√©rences caract√©ristiques entre mon compteur de vitesse et achet√© √† bas prix. Elle consiste en la vitesse de mise √† jour de l'indication de vitesse sur l'afficheur. Dans mon appareil, il est mis √† jour imm√©diatement, tel que calcul√©, √† chaque rotation de la roue. Dans les appareils achet√©s, il est mis √† jour avec un certain retard. Ce retard est peut-√™tre d√ª √† une tentative de filtrage du bruit de mesure (par exemple, en utilisant la m√©thode de la moyenne mobile) afin de stabiliser l'affichage de la vitesse sur l'affichage pour une clart√© plus d√©taill√©e. Ou peut-√™tre que l'affichage est compl√®tement mis √† jour √† intervalles r√©guliers (par exemple, deux fois par seconde). Cela peut √™tre pratique, mais je voulais impl√©menter une mise √† jour de la vitesse √† chaque r√©volution de la roue.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La carte de circuit imprim√© est r√©alis√©e par la m√©thode LUT sous la forme de la carte de circuit imprim√© d'origine du t√©l√©phone mobile utilis√©. Dans la fabrication du circuit imprim√©, j'ai utilis√© le programme SLayout. En m√™me temps, j'ai pris √† l'avance une photo de la carte d'origine des deux c√¥t√©s du scanner et j'ai mis les images dans SLayout comme mod√®le. Cela est n√©cessaire pour dessiner des pads pour connecter l'√©cran, les boutons et les connecteurs aux endroits exclusivement n√©cessaires. Lors de la fabrication de la planche, une erreur d'environ 0,5 mm s'est produite. Cette erreur s'est av√©r√©e acceptable en termes de combinaison de pads et d'√©l√©ments. Cependant, cette erreur a affect√© la qualit√© du r√©tro√©clairage: les LED scell√©es ont √©t√© d√©cal√©es d'une fraction de millim√®tres et ne sont pas tomb√©es au centre des mandrins diffusant la lumi√®re. Pour cette raison, la luminosit√© du r√©tro√©clairage a diminu√©, ce qui a r√©duit l'efficacit√©.Les figures ci-dessous montrent une vue de la carte de circuit imprim√© dans SLayout avec trois petites cartes de circuit imprim√© pour ROM sous la forme d'une carte SIM. En outre, des num√©risations de la carte de circuit imprim√© originale de deux c√¥t√©s sont affich√©es.</font></font><br><br><img src="https://habrastorage.org/webt/t4/x_/5a/t4x_5ad0pzcc8eyisyxrlmngkvu.png"><br><br><img src="https://habrastorage.org/webt/hj/gm/wp/hjgmwpma4fq8jbfeasauhjgfaqw.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Certains √©l√©ments (boutons, connecteurs) sont interconnect√©s par des cavaliers en fil mince faute de pouvoir tracer des pistes. Il y a une marge pour tous les boutons disponibles, c'est-√†-dire qu'il est possible d'utiliser n'importe quel bouton disponible. Il peut √™tre pratique de faire du grand bouton au centre un bouton pour changer les modes d'affichage. Dans le coin sup√©rieur gauche de la carte se trouve une batterie d'alimentation RTC de 3 volts. En g√©n√©ral, tous les √©l√©ments sur la planche sont plac√©s correctement avec la coordination de leurs dimensions avec les dimensions du bo√Ætier. Contrairement √† l'original dor√©, le panneau interne est enduit de soudure ordinaire. Comme le montre la pratique initiale, le contact avec l'√©cran et les autres p√©riph√©riques n'est pas perdu.</font></font><br><br>            .  ,        (EEPROM)      .         EEPROM. <br><br><table border="1" cellpadding="7"><tbody><tr><td> <b>Address</b> </td><td>  <b>La taille</b> </td><td> <b>Data</b> </td></tr><tr><td>  0 </td><td>  4 </td><td> n (for S) </td></tr><tr><td>  4 </td><td>  2 </td><td> t_min (for v_max) </td></tr><tr><td>  6 </td><td>  6 </td><td> Date of t_min </td></tr><tr><td>  12 </td><td>  2 </td><td> Address EEPROM </td></tr><tr><td>  14 </td><td>  1 </td><td> EEPROM RW Count </td></tr><tr><td>  128 </td><td> 80 </td><td> Digits 8X8 </td></tr><tr><td>  208 </td><td>  30 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chiffres 3X5 </font></font></td></tr></tbody></table> Les quatre premiers octets stockent la distance parcourue comme le nombre de tours de la roue.  J'ai choisi sp√©cifiquement le type entier 32 bits pour cette variable, car en pratique les valeurs du chemin parcouru sont relativement grandes.  Par exemple, une variable enti√®re de 16 bits pourrait enregistrer un maximum de 65 536 tours (environ 148 km), ce qui est naturellement petit.  Deux octets suivent pour maintenir la vitesse maximale absolue.  En fait, le temps minimum de rotation des roues est enregistr√©.  La variable prend deux octets, car sa valeur est le r√©sultat de la mesure d'un temporisateur 16 bits.  Les 6 octets suivants sont la date et l'heure auxquelles la vitesse maximale ci-dessus a √©t√© atteinte.  Les donn√©es sont pr√©sent√©es exactement dans le format dans lequel elles sont lues √† partir de la puce RTC (√† l'exclusion du jour de la semaine).  Ensuite, deux octets qui stockent la valeur de l'adresse actuelle de la ROM externe.  Il s'agit d'une sorte de pointeur, qui est n√©cessaire pour la possibilit√© de poursuivre l'enregistrement des statistiques sur la ROM apr√®s la prochaine mise sous tension de l'appareil.  MK doit savoir quelle position de l'espace d'adressage de la ROM externe il a arr√™t√©e pour la derni√®re fois.  √Ä partir de cette position, MK continuera d'enregistrer.  Cette valeur est allou√©e de 2 octets, car l'espace d'adressage de la ROM externe est de 16 bits.  Cela d√©coule d'une taille de ROM de 64 Ko.  Vient ensuite une variable √† un octet qui stocke la valeur du nombre de remplacements de ROM.  L'√©crasement est le cas lorsque le pointeur ci-dessus atteint la valeur maximale et passe √† z√©ro.  Dans ce cas, les informations nouvellement re√ßues sur la ROM commenceront √† √™tre enregistr√©es d√®s le d√©but, effa√ßant les anciennes informations disponibles sur celle-ci.  Une variable enti√®re sur un octet est capable de stocker un maximum de 256 valeurs.  Je vous rappelle que les valeurs du pointeur d'adresse ROM et le nombre d'√©crasements sont visuellement indiqu√©s par deux barres de progression sur l'affichage.  De plus, apr√®s un grand espace de sauvegarde de l'EEPROM MK, √† partir de l'adresse 128, des informations graphiques sur 8x8 chiffres sont stock√©es.  Pour cela, 80 octets sont allou√©s (8 octets pour chaque chiffre, comme mentionn√© pr√©c√©demment).  Et enfin, √† partir de l'adresse 208, 30 octets sont stock√©s pour des informations graphiques sur les petits chiffres 3x5 (trois octets par chiffre). <br><br>  En plus du programme principal pour le microcontr√¥leur, j'ai √©crit trois autres programmes auxiliaires pour l'ordinateur, qui seront discut√©s ci-dessous.  Tous les programmes n'ont pas d'interface graphique et fonctionnent √† partir de la ligne de commande de Windows XP. <br><br>  Le premier programme vous permet de copier la date et l'heure d'un ordinateur vers le compteur de vitesse du v√©lo via le port COM.  Le compteur de vitesse du v√©lo est connect√© √† l'ordinateur via la puce MAX232.  √Ä l'aide de WinAPI, le programme re√ßoit la date et l'heure actuelles dans une variable structurelle sp√©ciale de type SYSTEMTIME.  Le jour, le mois, l'ann√©e, le jour de la semaine, les heures, les minutes et les secondes en format d√©cimal sont extraits de cette variable.  Tous ces nombres, √† l'exception de l'ann√©e, ne d√©passent pas deux d√©cimales (moins de 100) et se situent √† l'int√©rieur d'un octet.  La valeur de l'ann√©e est convertie en un nombre √† deux chiffres en lui soustrayant le nombre 2000, la valeur du mill√©naire actuel.  Chacun de ces nombres d√©cimaux √† deux chiffres est converti au format d√©cimal binaire caract√©ristique de la puce RTC.  Dans ce format, un nombre √† deux chiffres occupe √©galement un volume d'un octet.  Les 4 bits les plus significatifs sont cod√©s le chiffre de dizaines, et le moins significatif - le nombre d'unit√©s.  Par la suite, un colis de 13 octets est form√© √† partir de ces num√©ros, selon un protocole que j'ai d√©termin√© pr√©c√©demment.  Les cinq premiers octets repr√©sentent le mot "TIME =" selon le codage ASCII standard.  Ensuite, suivez les secondes, minutes, heures, jour de la semaine, jour, mois, ann√©e.  Le dernier octet est le caract√®re "#", comme le caract√®re de la fin du message.  Ce package est envoy√© de l'ordinateur √† l'appareil via le port COM.  Le programme du microcontr√¥leur re√ßoit le package et v√©rifie son exactitude, selon le format ci-dessus.  Si les cinq premiers octets sont "TIME =" et le dernier est "#", l'envoi est consid√©r√© comme correct et les octets √† l'int√©rieur sont interpr√©t√©s dans l'ordre correspondant.  Sans modifier cette cha√Æne d'octets, le contr√¥leur l'envoie √† la puce RTC via le bus I2C, en la configurant pour la date et l'heure actuelles.  Je note que ce microcircuit prend en charge le calcul des jours de la semaine de 1 √† 7, bien qu'en tant que calendrier qui d√©termine la correspondance de la date et du jour de la semaine, il ne l'est pas.  Je n'ai pas pr√©vu l'affichage d'informations sur le jour de la semaine dans mon appareil. <br><br>  Le deuxi√®me programme est con√ßu pour traiter les donn√©es du contenu d'une ROM externe.  Initialement, on supposait que ce contenu devait √™tre copi√© de la ROM vers le fichier image en utilisant un programme bien connu qui fonctionne avec des programmeurs MK et ROM bien connus (par exemple, ¬´icprog¬ª).  Cependant, apr√®s avoir √©tudi√© le principe de fonctionnement I2C plus en d√©tail, j'ai r√©ussi √† impl√©menter cette fonctionnalit√© et √† l'inclure dans mon programme.  Le sch√©ma du programmeur ROM de cette s√©rie, que j'ai utilis√© dans l'appareil, est pr√©sent√© dans la figure ci-dessous. <br><br><img src="https://habrastorage.org/webt/ke/be/p1/kebep1s6zkpkgf0i5eyxu5jcvbi.png"><br><br>  La ROM est connect√©e au port COM de l'ordinateur, qui n'est pas utilis√© comme moyen d'√©change d'informations via RS-232 (o√π il suffit d'utiliser les sorties TX, RX, GND), mais comme moyen d'entr√©e-sortie arbitraire de signaux logiques.  Gr√¢ce √† la borne TX, la ROM est aliment√©e, qui est stabilis√©e jusqu'√† 5 V par le r√©gulateur 78L05.  En contr√¥lant la sortie TX de l'ordinateur, nous pouvons activer ou d√©sactiver la puce ROM.  La ligne d'horloge unidirectionnelle SCL est concentr√©e sur la broche RTS du port COM, et la ligne de donn√©es bidirectionnelle SDA est concentr√©e sur deux broches: CTS (r√©ception des donn√©es) et DTR (transmission des donn√©es).  Les r√©sistances et les diodes zener D1 et D2 sont utilis√©es pour limiter le niveau du signal √† TTL, sur lequel la ROM fonctionne. <br><br>  J'ai fait ce programmeur standard pour mon cas sp√©cial, o√π au lieu d'une prise pour ROM, un lecteur SIM d'un t√©l√©phone mobile cass√© est utilis√©. <br><br><img src="https://habrastorage.org/webt/-w/as/0e/-was0enetz2tighj_9_bziqip90.jpeg"><br><br>  Au moyen de WinAPI, le programme acc√®de aux broches du port COM de l'ordinateur, d√©finit les valeurs n√©cessaires pour celles-ci (0 ou 1) et supprime √©galement la valeur binaire entrante de la ROM de la broche CTS.  Sur la base de cette bo√Æte √† outils, la fonctionnalit√© I2C a √©t√© impl√©ment√©e conform√©ment aux sp√©cifications pertinentes, sur lesquelles je n'entrerai pas dans les d√©tails.  Le programme peut lire le contenu de la ROM dans une image de fichier (comme un programmeur ordinaire), et √©galement traiter un tel fichier, ou traiter directement les informations de la ROM.  Le traitement de l'information consiste √† obtenir les fichiers statistiques de sortie dans un format tabulaire pr√©d√©termin√© sur la base des informations d'entr√©e de la ROM.  Chacun de ces fichiers correspond √† un trajet (√† partir du moment o√π le courant est activ√© jusqu'√† la prochaine mise sous tension de l'appareil).  Tout d'abord, je d√©crirai bri√®vement le format d'entr√©e que j'ai d√©fini √† l'avance.  Chaque fois que l'appareil est allum√©, deux octets de z√©ros sont √©crits √† l'adresse actuelle, qui est lue √† partir de l'EEPROM du microcontr√¥leur.  Lorsque la roue commence √† tourner (√† la premi√®re impulsion) apr√®s une temporisation ou apr√®s avoir allum√© l'appareil, la date et l'heure actuelles sont √©crites au format d√©cimal binaire (car elles sont stock√©es dans les registres de la puce RTC).  Et puis deux octets de "unit√©s" 0xFF sont enregistr√©s.  Pendant la rotation de la roue, pour chaque k-√®me impulsion (k = 2,3, ...), le temps de rotation de la roue entre la (k-1) √®me et k-√®me impulsion est enregistr√© sur deux octets (haut et bas).  De toute √©vidence, ces informations sont suffisantes pour relier la distance actuelle (non absolue) parcourue et la vitesse √† la date et √† l'heure.  Le format de sortie est du texte et est un tableau tabulaire dans des fichiers * .csv qui sont ouverts dans Excel en double-cliquant avec la souris.  Les lignes de ce tableau correspondent aux r√©volutions des roues et les valeurs des colonnes sont indiqu√©es ci-dessous. <br><br><table border="1" cellpadding="7"><tbody><tr><td>  <b>ADR</b> </td><td>  Valeur d'adresse ROM </td></tr><tr><td>  <b>DATE / HEURE</b> </td><td>  Date et heure de d√©but </td></tr><tr><td>  <b>D√©c</b> </td><td>  Valeur de minuterie d√©cimale </td></tr><tr><td>  <b>le temps</b> </td><td>  Heure actuelle </td></tr><tr><td>  <b>t</b> </td><td>  Temps de trajet depuis la mise sous tension </td></tr><tr><td>  <b>v</b> </td><td>  La vitesse </td></tr><tr><td>  <b>n</b> </td><td>  La vitesse </td></tr><tr><td>  <b>S</b> </td><td>  Le chemin </td></tr><tr><td>  <b>un</b> </td><td>  Le nombre absolu de r√©volutions (uniquement dans la ROM actuelle) </td></tr><tr><td>  <b>aS</b> </td><td>  Chemin absolu (uniquement dans la ROM actuelle) </td></tr><tr><td>  <b>n_day</b> </td><td>  Le nombre de tours pour la journ√©e en cours </td></tr><tr><td>  <b>S_day</b> </td><td>  Le chemin de la journ√©e en cours </td></tr><tr><td>  <b>v_max</b> </td><td>  Vitesse maximale pour le trajet en cours </td></tr><tr><td>  <b>av_max</b> </td><td>  Vitesse maximale absolue (uniquement dans la ROM actuelle) </td></tr><tr><td>  <b>v_mid</b> </td><td>  Vitesse moyenne pour le trajet en cours </td></tr></tbody></table>  Une capture d'√©cran du contenu d'un tel fichier dans Excel est illustr√©e dans la figure ci-dessous.  En outre, des graphiques des changements de la vitesse actuelle, moyenne et maximale dans diff√©rentes couleurs dans un syst√®me de coordonn√©es sont affich√©s.  Argument (axe X) - valeurs de vitesse comme donn√©es d'entr√©e.  La figure montre les changements de param√®tres pour les 730 premi√®res r√©volutions.  La distance parcourue est associ√©e √† cette d√©pendance lin√©aire variable (730 tours correspondent √† environ 1650 m).  Par cons√©quent, nous pouvons dire que les graphiques refl√®tent la d√©pendance des vitesses sur la distance (pr√©cise √† l'√©chelle horizontale), contrairement √† la d√©pendance traditionnelle de la vitesse sur le temps, √† laquelle il convient de pr√™ter attention.  Comme d√©j√† mentionn√©, cette caract√©ristique est due √† l'id√©ologie et au principe de la mesure de la vitesse par la vitesse des roues.  Mais apr√®s tout, un certain moment est assign√© √† chaque r√©volution de la roue (le moment d'approche de l'aimant et du commutateur √† lames).  Naturellement, cette s√©quence d'horodatages n'est pas uniforme.  Cependant, pour des raisons de formalit√© et de commodit√©, Excel a la possibilit√© de sp√©cifier un tableau de valeurs d'heure dans le chemin ou l'heure actuelle comme argument pour les graphiques.  Mais tout de m√™me, il faut rappeler que la r√©elle d√©pendance de la vitesse sur le temps (√† intervalles de temps uniformes pour le cas discret) aurait √©t√© diff√©rente, avec une √©chelle horizontale variable. <br><br><img src="https://habrastorage.org/webt/fn/af/to/fnaftofg4-o5ihmbxhhn9olwlha.png"><br><br><img src="https://habrastorage.org/webt/lw/ul/qa/lwulqayq1gcskndypndok_opb3i.png"><br><br>  La figure ci-dessous montre la m√™me d√©pendance de la vitesse sur les r√©volutions, mais utilise d√©j√† le filtre en utilisant la m√©thode de la moyenne mobile avec une largeur de fen√™tre de 11 r√©volutions.  Tous les graphiques sont construits dans Excel en utilisant des m√©thodes bien connues. <br><br><img src="https://habrastorage.org/webt/gx/xu/qk/gxxuqkk_mqlghugdmrgkhevpeem.png"><br><br>  En comparant les deux graphiques du changement de vitesse, il est √©vident que la composante haute fr√©quence est absente dans le graphique filtr√©, c'est-√†-dire  bruit supprim√©.  La largeur de la fen√™tre moyenne mobile de 11 tours (environ 25 m), √† mon avis, est trop grande.  Si vous vous posez vraiment la question du filtrage des lectures du bruit, alors il suffit de prendre une petite largeur de fen√™tre, par exemple √©gale √† trois.  Cet algorithme peut √™tre int√©gr√© au programme de compteur de vitesse de v√©lo, car il peut √™tre utilis√© non seulement pour analyser les lectures, mais aussi pour afficher ces lectures en temps r√©el.  Malgr√© la simplicit√© de cet algorithme, je n'entrerai pas dans les d√©tails de sa description, car ce sujet est trait√© dans le cadre des math√©matiques et d√©passe le cadre de cet article.  Et voici une autre clarification sur la vitesse moyenne.  Comme je l'ai d√©j√† √©crit, la vitesse moyenne est le seul param√®tre mis √† jour non pas √† chaque rotation de la roue, mais √† chaque seconde.  J'ai fait cela pour m'assurer que l'affichage montre un changement de vitesse moyenne m√™me avec un mouvement tr√®s lent.  Par cons√©quent, les valeurs des lectures sur l'affichage en temps r√©el diff√©reront l√©g√®rement des valeurs calcul√©es √† l'avenir par le programme informatique au stade du balayage de la ROM.  Les lectures de la vitesse absolue, du chemin absolu et de la vitesse maximale absolue diff√©reront √©galement.  L'√©cran affiche des valeurs vraiment absolues (pour toute la dur√©e de vie de l'appareil) et dans les tableaux de sortie - uniquement dans les limites de la ROM en cours de lecture. <br><br>  Le troisi√®me programme, en substance, est le m√™me programme pour le microcontr√¥leur de micrologiciel.  Je travaille avec le programmateur STK 200 le plus simple connect√© au port LPT de l'ordinateur, ou plut√¥t avec son analogue, si vous pouvez l'appeler ainsi, car dans le cas le plus simple, le programmateur ne contient aucun √©l√©ment actif.  En fait, MK via l'interface SPI se connecte directement √† des broches sp√©cifiques du port LPT et fonctionne comme esclave.  Le programme impl√©mente un protocole d'√©change de donn√©es avec le contr√¥leur ATmega8 selon sa fiche technique (p. 237).  La couche physique SPI est impl√©ment√©e en g√©rant les registres de ports LPT √† l'aide de la biblioth√®que dynamique bien connue ¬´inpout32.dll¬ª.  Ma biblioth√®que n'est pas connect√©e en tant que projet (car j'ai √©vit√© de cr√©er un projet en tant que tel dans ¬´Dev-cpp¬ª en cr√©ant un simple ¬´fichier¬ª), mais en utilisant la fonction LoadLibrary en utilisant le type structurel HINSTANCE.  La biblioth√®que ¬´inpout32.dll¬ª est mapp√©e √† une variable de ce type, et les pointeurs vers les fonctions de cette biblioth√®que sont ensuite extraits dans des variables distinctes.  Inpout32.dll n'a que deux fonctions responsables de l'entr√©e et de la sortie des donn√©es.  Ces fonctions sont accessibles √† l'aide de pointeurs pr√©-extraits.  Les broches du port LPT sont contr√¥l√©es individuellement √† l'aide de masques de bits.  Dans mon cas particulier, le programme que j'ai √©crit fonctionne avec la zone EEPROM du contr√¥leur et est con√ßu pour lire, r√©server, √©crire, corriger et restaurer √† partir d'une copie de sauvegarde des donn√©es qu'il contient que j'ai peintes plus t√¥t.  Comme tous les autres programmes, le programme s'ex√©cute √† partir de la ligne de commande.  Dans de tels cas, pour mettre en ≈ìuvre la multifonctionnalit√© du programme, les fonctions ¬´bo√Ætier de commutation¬ª et une bo√Æte de dialogue utilisateur de texte sont utilis√©es, par exemple, ¬´entrez¬´ 1 ¬ªpour l'op√©ration n ¬∞ 1, ..., entrez¬´ 0 ¬ªpour quitter le programme.¬ª  Les donn√©es sont affich√©es dans diff√©rents formats qui me conviennent.  En plus de ce qui pr√©c√®de, le programme peut afficher un vidage complet du contr√¥leur EEPROM en 512 octets √† l'√©cran.  De plus, le programme peut enregistrer des informations graphiques sur les polices utilis√©es dans la m√©moire du contr√¥leur.  Dans le cas de petits caract√®res, taille 3X5, le programme prend les informations du fichier texte "Fonts 3X5.txt", qui se trouve dans le m√™me r√©pertoire que lui.  Le fichier contient un tableau tabulaire de 30 octets (3 par 10) √©crit au format hexad√©cimal.  Si vous le souhaitez, il peut √™tre facilement √©dit√© dans un √©diteur de texte, changeant ainsi les graphiques de cette police.  Comme d√©j√† mentionn√©, cette petite impression est si simple que changer ses graphiques n'a pas de sens.  La seule chose est que son d√©calage vertical peut seulement √™tre requis, car il y a un stock d'espace en hauteur de 8 pixels, et la police a une hauteur √©gale √† 5. Dans le cas d'une grande police, taille 8X8, qui affiche la vitesse actuelle, j'ai fourni la fonctionnalit√© beaucoup plus int√©ressante.  Les informations graphiques sur cette police ne sont pas pr√©sent√©es dans un fichier texte sous forme de tableau d'octets, mais dans des fichiers graphiques BMP visuels.  Chaque chiffre correspond √† un de ces fichiers.  Ses param√®tres sont la taille 8X8, monochrome avec une palette noir et blanc.  Ci-dessous, une capture d'√©cran de l'√©diteur graphique bien connu "MS Paint" avec le fichier "8.bmp" ouvert. <br><br><img src="https://habrastorage.org/webt/s3/7o/ek/s37oekzshuoye0acdpxotluebas.png"><br><br>  Empiriquement, j'ai √©tudi√© la structure des fichiers BMP monochromes obtenus √† partir de MS Paint ¬ª, et sur cette base j'ai pu apprendre √† lire chaque pixel d'une image BMP monochrome (hors utilisation des structures et biblioth√®ques auxiliaires).  Au stade de la lecture horizontale ligne par ligne de bas en haut (c'est ainsi que la structure du fichier BMP est organis√©e), le programme convertit les informations dans le format vertical sp√©cifique √† l'affichage utilis√©.  Cette op√©ration est effectu√©e en une seule passe, o√π les masques de bits et l'accumulation de valeurs variables sont utilis√©s.  Ci-dessous, je vais montrer cette section de code pour le i-√®me chiffre, en faisant attention √† la simplicit√© du processus. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; k++){ fnt[i][k] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; j++){ fseek(f, <span class="hljs-number"><span class="hljs-number">62</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*j, SEEK_SET); byte = ~fgetc(f); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(k=<span class="hljs-number"><span class="hljs-number">0</span></span>; k&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; k++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(byte &amp; pow2(<span class="hljs-number"><span class="hljs-number">7</span></span>-k)){ fnt[i][k] += pow2(<span class="hljs-number"><span class="hljs-number">7</span></span>-j); } } }</code> </pre> <br>  Dans la premi√®re boucle, les √©l√©ments du tableau fnt sont initialis√©s √† z√©ro.  √Ä l'avenir, chaque k-√®me √©l√©ment de ce tableau (k = 0 ... 7) pour le i-√®me chiffre (i = 0 ... 9) portera des informations graphiques sur chaque colonne correspondante de chaque chiffre correspondant.  Le cycle suivant est l'ex√©cution le long des lignes de l'image du fichier BMP.  Avec l'op√©rateur fseek, on se positionne en octets √† l'offset 62 + 4 * j du fichier BMP pr√©d√©fini f.  La sp√©cificit√© de la formule de calcul du d√©calage en fonction du num√©ro de ligne j est d√©termin√©e par la structure du fichier BMP.  Dans la variable interm√©diaire d'octet, nous obtenons la valeur d'octet au d√©calage ci-dessus.  Cet octet stocke des informations sur les huit pixels d'une image monochrome dans la ligne actuelle j.  L'op√©rateur ¬´~¬ª effectue une inversion au niveau du bit de l'octet, ce qui entra√Æne une inversion des couleurs de chaque pixel.  Cela est d√ª au fait qu'un pixel noir dans la palette d'un fichier BMP monochrome correspond √† un ¬´0¬ª logique et un blanc - ¬´1¬ª.  Dans l'affichage appliqu√©, au contraire.  Dans une boucle imbriqu√©e, une analyse d'octets de l'octet se produit et en m√™me temps, les informations sont accumul√©es dans le tableau de sortie fnt.  Fonction pow2 - √©levant un deux √† une puissance enti√®re non n√©gative, √©crite ind√©pendamment.  Au lieu de cette fonction, vous pouvez utiliser l'op√©rateur de d√©calage au niveau du bit plus efficace ¬´&lt;&lt;¬ª, mais au moment d'√©crire ce programme, je ne l'utilisais pas. <br><br>  De plus, le programme offre la possibilit√© d'√©crire dans la m√©moire de MK l'une des nombreuses options graphiques pour cette police de mon choix.  Ces options sont impl√©ment√©es √† l'aide de r√©pertoires (dossiers) avec un nom de la forme ¬´v1¬ª, ¬´v2¬ª, ¬´v3¬ª, etc., qui se trouvent dans le dossier ¬´Fonts 8X8¬ª dans le m√™me r√©pertoire que le programme.  Et d√©j√† dans ces dossiers sont les fichiers BMP n√©cessaires.  Gr√¢ce √† la fonctionnalit√© ci-dessus, il est possible de corriger ou de dessiner des nombres √† partir d'une ¬´feuille vierge¬ª dans un √©diteur graphique, en les sauvegardant et en les r√©partissant entre les r√©pertoires.  J'ai trois options de police.  La premi√®re option est l'original.  Le second - comme l'original, mais avec un z√©ro barr√© et une unit√© modifi√©e (sans trait de soulignement).  Le troisi√®me est une police avec une bordure rectangulaire. <br><br>  Les photos ci-dessous montrent: la carte de circuit imprim√© de l'appareil de l'arri√®re;  un appareil sur la table avec une alimentation connect√©e (avec une version non finale du firmware);  un appareil en fonctionnement mont√© sur un v√©lo avec un graphique des changements de vitesse affich√© sur celui-ci. <br><br><img src="https://habrastorage.org/webt/zm/5l/ly/zm5llykx8zbjhlpvl9hw72tfd98.jpeg"><br><br><img src="https://habrastorage.org/webt/kx/_b/mz/kx_bmzvxzlw-srwhzbudrpsdcg0.jpeg"><br><br><img src="https://habrastorage.org/webt/ak/lh/gx/aklhgxhxfzvj653rpxh4uqbrbri.jpeg"><br><br>  Au cours du fonctionnement de l'appareil, cependant, de petits d√©fauts ont √©t√© identifi√©s associ√©s aux caract√©ristiques de fabrication.  Tout d'abord - mauvais contact de l'√©cran avec les plots de la carte de circuit imprim√©.  Dans le t√©l√©phone portable d'origine, les contacts de la carte sont plaqu√©s or et il n'y a pas d'oxydation.  Dans mon cas, ils sont simplement en conserve. <br><br>  Sur la base de ce qui pr√©c√®de, il a √©t√© d√©cid√© de refaire l'appareil dans un autre cas, ainsi que de refaire la carte de circuit imprim√©, sur laquelle l'√©cran sera soud√© insolemment.  J'ai commenc√© ce processus r√©cemment.  Le r√©sultat est une conception plus robuste. <br><br><img src="https://habrastorage.org/webt/el/tw/r1/eltwr1m1zmbt1q5bj11v3a3cxks.png"><br><br><img src="https://habrastorage.org/webt/rh/hs/dw/rhhsdwamztytb2ix0le9mmyj2na.jpeg"><br><br><img src="https://habrastorage.org/webt/mp/rt/-h/mprt-hnrwvztbrvggcj6jhwx0qk.jpeg"><br><br>  J'ai fabriqu√© le bo√Ætier de l'appareil √† partir d'un morceau de plexiglas de 17 mm d'√©paisseur sur une fraiseuse CNC.  Pour ce faire, j'ai pr√©alablement esquiss√© les esquisses du bo√Ætier dans le programme SPlan, ne connaissant presque pas le sujet des dessins, de la CAO, etc. <br><br><img src="https://habrastorage.org/webt/tn/j6/w-/tnj6w-zgduldrbd4-t9rqw1hihe.jpeg"><br><br>  Ces esquisses sont n√©cessaires pour la pr√©sentation g√©n√©rale et l'obtention des coordonn√©es des points de contr√¥le.  Sur la base de ceux-ci, un programme est √©crit pour la machine CNC, en tenant compte des principes g√©n√©raux et des s√©quences de fraisage.  J'ai √©crit le programme CNC manuellement dans Excel, en utilisant les fonctions de saisie semi-automatique pour des op√©rations r√©p√©t√©es. <br><br><img src="https://habrastorage.org/webt/eb/g1/ie/ebg1iewnui1ptplfwit3gvrbya0.jpeg"><br><br><img src="https://habrastorage.org/webt/qr/qa/kk/qrqakkmdcsuifjphgg_h8wcqybc.jpeg"><br><br>  J'ai √©galement l√©g√®rement corrig√© la disposition de l'appareil, elle est pr√©sent√©e dans la figure ci-dessous. <br><br><img src="https://habrastorage.org/webt/wd/e5/lh/wde5lh6inym01_4elygpybkuuqy.png"><br><br>  Au lieu du r√©tro-√©clairage d√©j√† inutile du clavier, il y a une LED pour la beaut√© qui clignote √† chaque tour de roue.  Les connecteurs sont √©galement redessin√©s et aucun autre √©l√©ment n'√©tait n√©cessaire dans la version mise √† jour de la conception.  De plus, j'ai trouv√© et install√© du quartz √† 4,433619 MHz, corrigeant l√©g√®rement certaines constantes dans le code source de mon propre programme.  Quelques modifications mineures ont √©galement √©t√© apport√©es au programme. <br><br>  Une photographie du produit fini est pr√©sent√©e ci-dessous.  L'appareil est aliment√© par une batterie qui se trouve √† bord du v√©lo.  De l√†, l'√©clairage est √©galement fourni pour les voyages dans l'obscurit√©. <br><br><img src="https://habrastorage.org/webt/qa/1w/ln/qa1wln2ikvghei7heep_puqn9ay.jpeg"><br><br>  C'est dans cette conception que l'appareil a fonctionn√© compl√®tement sans aucun probl√®me.  Le seul inconv√©nient est l'utilisation d'une puce RTC de tr√®s mauvaise qualit√©: en hiver √† basse temp√©rature, le temps presse, il faut l'ajuster une fois par mois. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414281/">https://habr.com/ru/post/fr414281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414269/index.html">"20 000 IOPS par n≈ìud sont de bonnes performances avec une latence de 5 ms." Pour OLTP - non</a></li>
<li><a href="../fr414271/index.html">Comment apprivoiser un disque dur dans un ordinateur portable et emp√™cher le stationnement en 8 secondes d'arr√™t</a></li>
<li><a href="../fr414273/index.html">Ce que vous devez savoir avant de d√©velopper un backtester pour une strat√©gie de trading: probl√®mes typiques, types de syst√®mes et leurs param√®tres</a></li>
<li><a href="../fr414277/index.html">L'homme, son environnement et l'Internet des objets</a></li>
<li><a href="../fr414279/index.html">Vote des rapports lors de la huiti√®me r√©union de bricolage du groupe Mail.Ru (07.07.2018)</a></li>
<li><a href="../fr414283/index.html">Comment distinguer la crypto-monnaie de la non-crypto-monnaie</a></li>
<li><a href="../fr414285/index.html">Nous utilisons un commutateur sans fil 433 MHz pour contr√¥ler le PC</a></li>
<li><a href="../fr414289/index.html">SpaceX a ouvert un poste d'ing√©nieur de fus√©e pour cr√©er un BFR</a></li>
<li><a href="../fr414293/index.html">Le troisi√®me ReactOS Hackfest annuel se tiendra du 14 au 21 ao√ªt 2018 √† Berlin</a></li>
<li><a href="../fr414295/index.html">¬´C'√©tait possible¬ª: des moyens inhabituels mais efficaces d'utiliser les technologies ¬´audio¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>