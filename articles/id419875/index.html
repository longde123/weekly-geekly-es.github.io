<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ—³ï¸ â‡ï¸ ğŸ‚ğŸ¼ Sekali lagi tentang keterlambatan dalam kode sumber proyek FPGA atau pertanyaan sederhana untuk wawancara untuk pekerjaan pengembang FPGA ğŸ˜ª ğŸ‘²ğŸ½ ğŸ‘¶ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa waktu yang lalu, selama diskusi di perusahaan pengembang FPGA profesional, diskusi muncul tentang lulus wawancara. Pertanyaan apa yang diajuk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sekali lagi tentang keterlambatan dalam kode sumber proyek FPGA atau pertanyaan sederhana untuk wawancara untuk pekerjaan pengembang FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419875/"><img src="https://habrastorage.org/webt/z6/f-/6r/z6f-6rzaupd6oxldcxbx5dkz0ew.png"><br><br>  Beberapa waktu yang lalu, selama diskusi di perusahaan pengembang FPGA profesional, diskusi muncul tentang lulus wawancara.  Pertanyaan apa yang diajukan di sana, dan apa yang bisa ditanyakan.  Saya menyarankan dua pertanyaan: <br><br><ol><li>  Berikan contoh kode sinkron tanpa menggunakan penundaan, yang akan memberikan hasil yang berbeda saat memodelkan dan ketika bekerja di peralatan nyata </li><li>  Perbaiki kode ini dengan penundaan. </li></ol><br>  Setelah pertanyaan ini, sebuah diskusi yang hidup terjadi, sebagai akibatnya saya memutuskan untuk mempertimbangkan masalah ini secara lebih rinci. <br><a name="habracut"></a><br>  Saya sudah sedikit menyentuh masalah ini pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> .  Sekarang lebih detail.  Berikut ini contoh teks: <br><br><pre><code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">library</span></span> IEEE; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> IEEE.STD_LOGIC_1164.<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">entity</span></span> delta_delay <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> delta_delay; <span class="hljs-keyword"><span class="hljs-keyword">architecture</span></span> delta_delay <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> delta_delay <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">signal</span></span> clk1 : <span class="hljs-built_in"><span class="hljs-built_in">std_logic</span></span>:=<span class="hljs-string"><span class="hljs-string">'0'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">signal</span></span> clk2 : <span class="hljs-built_in"><span class="hljs-built_in">std_logic</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> clk3 : <span class="hljs-built_in"><span class="hljs-built_in">std_logic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> clk1; <span class="hljs-comment"><span class="hljs-comment">--    clk1 signal a : std_logic; signal b : std_logic; signal c : std_logic; signal d : std_logic; begin ---    --- clk1 &lt;= not clk1 after 5 ns; pr_a: process begin a &lt;= '0' after 1 ns; wait until rising_edge( clk1 ); wait until rising_edge( clk1 ); a &lt;= '1' after 1 ns; wait until rising_edge( clk1 ); wait until rising_edge( clk1 ); wait until rising_edge( clk1 ); wait until rising_edge( clk1 ); end process; ---   -    --- clk2 &lt;= clk1; --    ,        ---  1 -     --- b &lt;= a when rising_edge( clk1 ); c &lt;= b when rising_edge( clk1 ); d &lt;= b when rising_edge( clk2 ); ---  2 -     --- -- --clk2 &lt;= clk1; --b &lt;= a after 1 ns when rising_edge( clk1 ); --c &lt;= b after 1 ns when rising_edge( clk1 ); --d &lt;= b after 1 ns when rising_edge( clk2 ); ---  3 -          alias --- --b &lt;= a when rising_edge( clk1 ); --c &lt;= b when rising_edge( clk1 ); --d &lt;= b when rising_edge( clk3 ); end delta_delay;</span></span></code> </pre> <br>  Untuk mempermudah, semua kode ditempatkan dalam satu komponen. <br><br>  Sinyal <b>clk1</b> dan <b>a</b> adalah sinyal paparan uji.  <b>clk1</b> adalah frekuensi clock 100 MHz, Sinyal <b>a</b> menahan dua siklus clock pada 0 dan empat clock cycle pada 1. Sinyal <b>a</b> dihasilkan dengan penundaan 1 nc relatif terhadap kenaikan edge <b>clk1</b> .  Kedua sinyal ini cukup untuk menggambarkan masalahnya. <br><br>  Opsi kode sintetik yang berbeda dapat dibatalkan komentar dan dimodelkan. <br>  Pertimbangkan opsi pertama, ini adalah kode yang disintesis tanpa penundaan dan menggunakan penugasan kembali frekuensi clock. <br><br>  Berikut adalah hasil simulasi untuk opsi 1: <br><br><img src="https://habrastorage.org/webt/34/ew/l_/34ewl_wuqjudvf6ehn6gw5cf164.png"><br><br>  Diagram secara visual menunjukkan bahwa sinyal clock <b>clk1</b> dan <b>clk2</b> bertepatan, tetapi sebenarnya <b>clk2</b> tertunda relatif terhadap <b>clk1</b> oleh nilai delta delay.  Sinyal <b>c</b> memperlambat sinyal <b>b</b> oleh satu siklus clock.  Ini benar  Tetapi sinyal <b>d</b> harus bertepatan dengan sinyal <b>c</b> , tetapi ini tidak terjadi.  Ini bekerja lebih awal. <br><br>  Mari kita ingat apa itu penundaan delta.  Ini adalah konsep mendasar, didasarkan pada karya simulator acara, yang kami gunakan saat memodelkan sirkuit logika. <br><br>  Simulator memiliki konsep waktu model.  Semua peristiwa dalam sistem terlampir pada waktu model ini.  Mari kita lihat pembentukan frekuensi jam: <br><br><pre> <code class="vhdl hljs">clk1 &lt;= <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> clk1 <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> ns;</code> </pre> <br>  Misalkan sekarang kita hanya memodelkan <b>clk1</b> , tidak ada sinyal lain. <br>  Pada saat awal waktu, <b>clk1</b> adalah 0, ini diatur ketika sinyal dinyatakan.  Simulator melihat persyaratan untuk membalikkan sinyal.  Kata kunci setelah memberikan instruksi untuk menetapkan nilai baru dalam 5 ns relatif terhadap waktu model saat ini.  Simulator melihat ini dan membuat catatan bahwa pada waktu 5 ns nilai <b>clk1</b> akan menjadi 1. Meskipun ini adalah model masa depan, omong-omong itu masih dapat berubah.  Selanjutnya, simulator memindai sinyal yang tersisa.  Simulator akan melihat bahwa untuk momen tertentu dalam waktu model, semuanya dilakukan dan dia dapat menghitung momen berikutnya.  Muncul pertanyaan - apa momen selanjutnya?  Pada prinsipnya, berbagai opsi dimungkinkan.  Misalnya, Simulink memiliki mode pitch-tetap.  Dalam hal ini, waktu model akan bertambah dengan jumlah tertentu dan perhitungan berlanjut. <br><br>  Sistem simulasi sirkuit digital melakukan hal yang berbeda.  Mereka pindah ke acara berikutnya, yang telah mereka tempatkan di masa depan pada sumbu waktu model mereka.  Dalam hal ini, akan menjadi 5 ns.  Simulator akan melihat bahwa <b>clk1</b> telah berubah dan akan menghitung nilai baru untuk itu, itu akan menjadi 0 yang juga akan ditempatkan dengan penundaan 5 ns pada sumbu waktu.  Yaitu  itu akan menjadi 10 ns.  Maka proses akan berlanjut sampai waktu simulasi yang ditentukan berakhir. <br><br>  Sekarang mari kita tambahkan sinyal <b>a</b> dan <b>b</b> . <br><br>  Sinyal <b>a</b> ditugaskan dalam proses.  Untuk sinyal <b>b</b> , konstruksi bersyarat saat digunakan;  Fungsi rising_edge ( <b>clk1</b> ) mem-parsing <b>clk1</b> dan mengembalikan <b>true</b> ketika bagian depan diperbaiki, mis.  nilai sebelumnya adalah 0 dan nilai saat ini adalah 1. <br><br>  Pada model waktu 5 ns, <b>clk1</b> akan berubah.  Itu akan menjadi sama dengan 1 dan untuk saat 10 ns suatu acara akan dibuat dari pengaturan ke 0. Tapi ini nanti.  Sementara kami masih dalam 5 ns dan kami terus perhitungan.  Simulator menuju ke garis <pre> <code class="vhdl hljs">b&lt;=a <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> rising_edge(clk1);</code> </pre>  Karena ada fungsi yang bergantung pada <b>clk1,</b> simulator akan menghitung nilai fungsi, melihat bahwa ia mengembalikan true dan akan menetapkan <pre> <code class="vhdl hljs">b&lt;=a;</code> </pre> <br><br>  Di sini bagian yang paling menarik dimulai - ketika perlu untuk mengubah nilai <b>b</b> .  Tampaknya perlu untuk mengubahnya sekarang, pada saat ini.  Tetapi kami memiliki proses paralel.  Mungkin kita masih membutuhkan nilai <b>b</b> untuk menghitung sinyal lain.  Dan inilah konsep penundaan delta.  Ini adalah nilai minimum dimana waktu model bergeser.  Nilai ini bahkan tidak memiliki dimensi waktu.  Ini hanya sebuah delta.  Tetapi mungkin ada banyak dari mereka.  Dan simulator itu berhenti karena kesalahan atau macet. <br>  Jadi, nilai baru <b>b</b> akan ditetapkan untuk momen 5 ns + 1 (1 adalah penundaan delta pertama).  Simulator akan melihat bahwa tidak ada yang perlu dihitung untuk saat ini 5 ns dan akan pergi ke saat berikutnya, dan ini akan menjadi 5 ns + 1;  Saat ini, rising_edge (ckl1) tidak berfungsi.  Dan nilai b akan ditetapkan ke 1. Setelah itu, simulator akan menuju ke saat 10 nc. <br><br>  Sekarang mari kita tambahkan sinyal <b>c</b> , <b>d</b> dan lihat mengapa mereka berbeda. <br>  Yang terbaik untuk mempertimbangkan saat model waktu 25 n dengan mempertimbangkan penundaan akun <br><br><table><tbody><tr><th>  delta </th><th>  clk1 </th><th>  clk2 </th><th>  re (clk1) </th><th>  re (clk2) </th><th>  b </th><th>  c </th><th>  d </th></tr><tr><th>  0 </th><th>  1 </th><th>  0 </th><th>  benar </th><th>  salah </th><th>  0 </th><th>  0 </th><th>  0 </th></tr><tr><th>  1 </th><th>  1 </th><th>  1 </th><th>  salah </th><th>  benar </th><th>  1 </th><th>  0 </th><th>  0 </th></tr><tr><th>  2 </th><th>  1 </th><th>  0 </th><th>  salah </th><th>  salah </th><th>  1 </th><th>  0 </th><th>  1 </th></tr></tbody></table><br>  Catatan: re - rise_edge <br><br>  Tabel menunjukkan bahwa pada saat fungsi rising_edge ( <b>clk2</b> ) dipicu, nilai <b>b</b> sudah 1. Dan karenanya, ia akan ditugaskan ke sinyal <b>d</b> . <br><br>  Berdasarkan akal sehat, ini bukan perilaku yang kami harapkan dari kode.  Setelah semua, kami cukup menetapkan kembali sinyal <b>clk1</b> ke <b>clk2</b> dan berharap bahwa sinyal <b>c</b> dan <b>d</b> akan sama.  Tetapi mengikuti logika simulator, ini tidak benar.  Ini adalah fitur <b>PRINCIPAL</b> .  Fitur ini, tentu saja, harus diketahui oleh pengembang proyek FPGA dan oleh karena itu ini adalah pertanyaan yang baik dan perlu untuk wawancara. <br><br>  Apa yang akan terjadi selama sintesis?  Tetapi synthesizer akan mengikuti akal sehat, itu akan membuat sinyal <b>clk2</b> dan <b>clk1</b> satu sinyal dan karena itu <b>c</b> dan <b>d</b> juga akan sama.  Dan dengan pengaturan synthesizer tertentu, mereka juga akan digabungkan menjadi satu sinyal. <br><br>  Ini hanya kasus ketika pemodelan dan bekerja di peralatan nyata akan menghasilkan hasil yang berbeda.  Saya ingin mencatat bahwa alasan untuk hasil yang berbeda adalah logika simulator dan synthesizer yang berbeda.  Ini adalah perbedaan DASAR.  Ini tidak ada hubungannya dengan kendala waktu.  Dan jika proyek Anda di model dan di besi menunjukkan hasil yang berbeda, maka periksa, mungkin desain seperti itu merayap di sana <br><br><pre> <code class="vhdl hljs">clk2 &lt;= clk1</code> </pre> <br>  Sekarang pertanyaan kedua adalah memperbaiki kode ini dengan penundaan. <br>  Ini adalah opsi 2. Ini dapat dihapus dan dimodelkan. <br>  Inilah hasilnya. <br><br><img src="https://habrastorage.org/webt/vu/4z/t0/vu4zt0pe3gxnpav3vje3kwoi_ye.png"><br><br>  Hasilnya benar.  Apa yang terjadi  Mari kita membuat tabel lagi untuk interval 25 - 36 ns <br><table><tbody><tr><th>  waktu </th><th>  delta </th><th>  clk1 </th><th>  clk2 </th><th>  re (clk1) </th><th>  re (clk2) </th><th>  b </th><th>  c </th><th>  d </th></tr><tr><th>  25 </th><th>  0 </th><th>  1 </th><th>  0 </th><th>  benar </th><th>  salah </th><th>  0 </th><th>  0 </th><th>  0 </th></tr><tr><th>  25 </th><th>  1 </th><th>  1 </th><th>  1 </th><th>  salah </th><th>  benar </th><th>  0 </th><th>  0 </th><th>  0 </th></tr><tr><th>  26 </th><th>  0 </th><th>  1 </th><th>  1 </th><th>  salah </th><th>  salah </th><th>  1 </th><th>  0 </th><th>  0 </th></tr><tr><th>  35 </th><th>  0 </th><th>  1 </th><th>  0 </th><th>  benar </th><th>  salah </th><th>  1 </th><th>  0 </th><th>  0 </th></tr><tr><th>  35 </th><th>  1 </th><th>  1 </th><th>  1 </th><th>  salah </th><th>  benar </th><th>  1 </th><th>  0 </th><th>  0 </th></tr><tr><th>  36 </th><th>  0 </th><th>  1 </th><th>  1 </th><th>  salah </th><th>  salah </th><th>  1 </th><th>  1 </th><th>  1 </th></tr></tbody></table><br>  Dapat dilihat bahwa nilai <b>b</b> tidak berubah pada saat front <b>clk1</b> , <b>clk2</b> .  Penundaan 1 ns membutuhkan waktu saat sinyal berubah di luar zona respons tepi.  Kode ini semakin mendekati kenyataan.  Dalam rangkaian nyata, ada beberapa waktu untuk memicu untuk memicu dan untuk menyebarkan sinyal.  Waktu ini harus kurang dari periode frekuensi jam, pada kenyataannya, inilah yang dilakukan pelacak, dan inilah yang diperiksa oleh analisis waktu. <br><br>  Penyebab kesalahan adalah penugasan kembali sinyal clock oleh penugasan biasa di mana penundaan delta muncul.  Namun, bahasa VHDL memiliki alias alias.  Ini memungkinkan Anda untuk mendapatkan nama yang berbeda untuk sinyal tersebut.  Berikut pengumumannya: <br><br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> clk3 : <span class="hljs-built_in"><span class="hljs-built_in">std_logic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> clk1;</code> </pre> <br>  Dalam teks contoh, Anda dapat menghapus komentar opsi 3 - itu akan berfungsi dengan benar. <br><br>  Contoh ini ditulis dalam VHDL.  Mungkin ini masalahnya hanya dari bahasa ini?  Tapi di sini ada opsi yang sama di Verilog. <br><br><div class="spoiler">  <b class="spoiler_title">Teks tersembunyi</b> <div class="spoiler_text"><pre> <code class="hljs delphi">`timescale <span class="hljs-number"><span class="hljs-number">1</span></span> ns / <span class="hljs-number"><span class="hljs-number">1</span></span> ps module delta_delay_2 (); reg clk1 = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0; reg clk2; wire clk3; reg a = 1'</span></span>b0; reg b; reg c; reg d; initial <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> forever clk1 = <span class="hljs-string"><span class="hljs-string">#5</span></span> ~clk1; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> initial <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-string"><span class="hljs-string">#20</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; #60 a = 1'</span></span>b0; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">//   -    --- always @(clk1) clk2 &lt;= clk1; //  1 -     always @(posedge clk2) d &lt;= b; always @(posedge clk1) begin c &lt;= b; b &lt;= a; end //  2 -     //always @(posedge clk1) b = #1 a; // //always @(posedge clk1) c = #1 b; // //always @(posedge clk2) d = #1 b; //  3 -     //      assign //assign clk3 = clk1; // //always @(posedge clk3) d &lt;= b; // //always @(posedge clk1) //begin // c &lt;= b; // b &lt;= a; //end endmodule</span></span></code> </pre><br><br></div></div><br><ul><li>  Opsi 1 - tidak ada penundaan.  Itu tidak berfungsi dengan baik. </li><li>  Opsi 2 - dengan penundaan.  Itu bekerja dengan benar. </li><li>  Opsi 3 - penugasan kembali melalui kawat.  Itu bekerja dengan benar. </li></ul><br>  Verilog memiliki konsep reg dan kawat.  Dalam hal ini, penugasan kembali sinyal clock melalui kawat terlihat lebih alami.  Ini analog dengan penugasan alias dalam VHDL.  Ini agak mengurangi ketegangan dari masalah, tetapi Anda masih perlu tahu ini. <br>  Verilog juga memiliki konsep tugas pemblokiran dan non-pemblokiran.  Penugasan sinyal <b>b</b> dan <b>c</b> dapat ditulis dengan cara lain: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">always</span></span> @(posedge clk1) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> c = b; b = a; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Dan Anda dapat melakukan ini: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">always</span></span> @(posedge clk1) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> b = a; c = b; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Bergantung pada urutan garis, hasilnya akan berbeda. <br><br>  Kembali ke topik wawancara, saya ingin menekankan sekali lagi bahwa pertanyaan-pertanyaan ini adalah untuk memahami esensi masalah.  Dan dari pemahaman masalah, orang dapat menarik berbagai kesimpulan, misalnya, gaya kode yang digunakan.  Secara pribadi, saya selalu menggunakan tugas keterlambatan. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">File sampel tersedia di sini.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419875/">https://habr.com/ru/post/id419875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419865/index.html">Cara tidak sengaja menulis Web-GUI untuk Haproxy</a></li>
<li><a href="../id419867/index.html">Enam mitos lagi tentang blockchain, di mana itu masih akan diterapkan</a></li>
<li><a href="../id419869/index.html">Revolusi AI tidak akan dibuat oleh droid, tetapi oleh pemanggang roti</a></li>
<li><a href="../id419871/index.html">Bagaimana Google mencoba mengembangkan mesin pencari yang disensor untuk China</a></li>
<li><a href="../id419873/index.html">Pengujian hanya melalui metode publik itu buruk</a></li>
<li><a href="../id419877/index.html">Bagaimana kami menemukan "rumah pintar" lagi</a></li>
<li><a href="../id419879/index.html">PWA mudah. Halo joomla</a></li>
<li><a href="../id419883/index.html">Dapatkan perbedaan antara file biner menggunakan vcdiff</a></li>
<li><a href="../id419885/index.html">Terjemahan buku Andrew Un, Passion for Machine Learning, Bab 15-19</a></li>
<li><a href="../id419893/index.html">Cara melakukan pencarian pengguna di Github menggunakan VanillaJS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>