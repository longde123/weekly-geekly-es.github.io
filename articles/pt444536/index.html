<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèª ‚úâÔ∏è üöå MVCC-2. Camadas, arquivos, p√°ginas üßùüèº üë§ ‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na √∫ltima vez em que conversamos sobre a consist√™ncia dos dados, analisamos a diferen√ßa entre os diferentes n√≠veis de isolamento de transa√ß√µes pelos o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-2. Camadas, arquivos, p√°ginas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/444536/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Na √∫ltima vez em</a> que conversamos sobre a consist√™ncia dos dados, analisamos a diferen√ßa entre os diferentes n√≠veis de isolamento de transa√ß√µes pelos olhos do usu√°rio e descobrimos por que √© importante saber.  Agora estamos come√ßando a aprender como o PostgreSQL implementa o isolamento baseado em imagem e o mecanismo de multi-vers√£o. <br><br>  Neste artigo, veremos como os dados est√£o fisicamente localizados em arquivos e p√°ginas.  Isso nos afasta do t√≥pico do isolamento, mas essa digress√£o √© necess√°ria para entender mais material.  Precisamos entender como o armazenamento de dados de baixo n√≠vel funciona. <br><br><h1>  Rela√ß√µes </h1><br>  Se voc√™ olhar dentro das tabelas e √≠ndices, eles ser√£o organizados de maneira semelhante.  Tanto isso quanto outro - objetos de base que cont√™m alguns dados que consistem em linhas. <br><br>  O fato de a tabela consistir em linhas est√° fora de d√∫vida;  para o √≠ndice, isso √© menos √≥bvio.  No entanto, imagine uma √°rvore B: consiste em n√≥s que cont√™m valores indexados e links para outros n√≥s ou para linhas da tabela.  Esses n√≥s podem ser considerados linhas de √≠ndice - de fato, do jeito que s√£o. <br><br>  De fato, ainda existem v√°rios objetos organizados de maneira semelhante: sequ√™ncias (essencialmente tabelas de linha √∫nica), visualiza√ß√µes materializadas (essencialmente tabelas que lembram a consulta).  E h√° as visualiza√ß√µes usuais, que por si s√≥ n√£o armazenam dados, mas em todos os outros sentidos s√£o semelhantes √†s tabelas. <br><br>  Todos esses objetos no PostgreSQL s√£o chamados de <em>rela√ß√£o de</em> palavras comuns.  A palavra √© extremamente infeliz, porque √© um termo da teoria relacional.  Voc√™ pode tra√ßar um paralelo entre a rela√ß√£o e a tabela (exibi√ß√£o), mas certamente n√£o entre a rela√ß√£o e o √≠ndice.  Mas aconteceu: as ra√≠zes acad√™micas do PostgreSQL se fazem sentir.  Eu acho que no come√ßo isso foi chamado de tabelas e visualiza√ß√µes, e o resto cresceu com o tempo. <br><a name="habracut"></a><br>  Al√©m disso, por simplicidade, falaremos apenas sobre tabelas e √≠ndices, mas o restante dos <em>relacionamentos</em> √© estruturado exatamente da mesma maneira. <br><br><h1>  Camadas (garfos) e arquivos </h1><br>  Geralmente, cada rela√ß√£o tem v√°rias <em>camadas</em> (garfos).  As camadas s√£o de v√°rios tipos e cada uma delas cont√©m um certo tipo de dados. <br><br>  Se houver uma camada, primeiro ela ser√° representada por um √∫nico <em>arquivo</em> .  O nome do arquivo consiste em um identificador num√©rico ao qual a final correspondente ao nome da camada pode ser adicionada. <br><br>  O arquivo aumenta gradualmente e quando seu tamanho atinge 1 GB, o pr√≥ximo arquivo da mesma camada √© criado (esses arquivos s√£o chamados de <em>segmentos</em> ).  O n√∫mero do segmento √© anexado ao final do nome do arquivo. <br><br>  A limita√ß√£o de tamanho de arquivo de 1 GB surgiu historicamente para oferecer suporte a v√°rios sistemas de arquivos, alguns dos quais n√£o podem funcionar com arquivos grandes.  A restri√ß√£o pode ser alterada ao criar o PostgreSQL ( <code>./configure --with-segsize</code> ). <br><br>  Assim, v√°rios arquivos podem corresponder a uma rela√ß√£o em um disco.  Por exemplo, para uma mesa pequena, haver√° tr√™s delas. <br><br>  Todos os arquivos de objetos pertencentes a um espa√ßo de tabela e um banco de dados ser√£o colocados em um diret√≥rio.  Isso deve ser levado em considera√ß√£o, porque os sistemas de arquivos geralmente n√£o funcionam muito bem com um grande n√∫mero de arquivos em um diret√≥rio. <br><br>  Observe que os arquivos, por sua vez, s√£o divididos em <em>p√°ginas</em> (ou <em>blocos</em> ), geralmente 8 KB.  Falaremos sobre a estrutura interna das p√°ginas abaixo. <br><br><img src="https://habrastorage.org/webt/oz/ur/4z/ozur4zenihys-v-7wl5rnxyi8em.png"><br><br>  Agora vamos ver os tipos de camadas. <br><br>  <strong>A camada principal</strong> s√£o os pr√≥prios dados: a mesma tabela ou linhas de √≠ndice.  A camada principal existe para qualquer relacionamento (exceto para representa√ß√µes que n√£o cont√™m dados). <br><br>  Os nomes dos arquivos na camada principal consistem em apenas um identificador num√©rico.  Aqui est√° um caminho de exemplo para o arquivo de tabela que criamos na √∫ltima vez: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41496 (1 row)</code> </pre><br>  De onde v√™m esses identificadores?  O diret√≥rio base corresponde ao espa√ßo de tabela pg_default, o pr√≥ximo subdiret√≥rio corresponde ao banco de dados e o arquivo em que estamos interessados ‚Äã‚Äãj√° est√° nele: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = <span class="hljs-string"><span class="hljs-string">'test'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> oid ------- 41493 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfilenode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfilenode ------------- 41496 (1 row)</code> </pre><br>  O caminho √© relativo, √© contado a partir do diret√≥rio de dados (PGDATA).  Al√©m disso, quase todos os caminhos no PostgreSQL s√£o contados no PGDATA.  Gra√ßas a isso, voc√™ pode transferir o PGDATA com seguran√ßa para outro local - ele n√£o cont√©m nada (a menos que voc√™ precise configurar o caminho para as bibliotecas em LD_LIBRARY_PATH). <br><br>  Analisamos mais a fundo o sistema de arquivos: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41496</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41496</code> </pre><br>  <strong>Uma camada de inicializa√ß√£o</strong> existe apenas para tabelas n√£o registradas no di√°rio (criadas com UNLOGGED) e seus √≠ndices.  Esses objetos n√£o s√£o diferentes dos objetos comuns, exceto que as a√ß√µes com eles n√£o s√£o registradas no log de pr√©-registro.  Devido a isso, o trabalho com eles √© mais r√°pido, mas, no caso de uma falha, √© imposs√≠vel restaurar os dados em um estado consistente.  Portanto, ao recuperar, o PostgreSQL simplesmente exclui todas as camadas desses objetos e grava a camada de inicializa√ß√£o no local da camada principal.  O resultado √© um "manequim".  Falaremos sobre o registro em di√°rio em detalhes, mas em um ciclo diferente. <br><br>  A tabela de contas √© registrada no di√°rio, portanto, n√£o h√° camada de inicializa√ß√£o para ela.  Mas para a experi√™ncia, voc√™ pode desativar o log: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNLOGGED</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41507 (1 row)</code> </pre><br>  A capacidade de ativar e desativar o registro no di√°rio em tempo real, como pode ser visto no exemplo, envolve a substitui√ß√£o de dados em arquivos com nomes diferentes. <br><br>  A camada de inicializa√ß√£o tem o mesmo nome que a camada principal, mas com o sufixo "_init": <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 0 /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><br>  <strong>Mapa de espa√ßo livre</strong> (mapa de espa√ßo livre) - uma camada na qual h√° um espa√ßo vazio dentro das p√°ginas.  Este lugar est√° mudando constantemente: quando novas vers√µes de strings s√£o adicionadas, ela diminui, enquanto a limpeza - ela aumenta.  O mapa de espa√ßo livre √© usado ao inserir novas vers√µes de linhas para encontrar rapidamente uma p√°gina adequada na qual os dados a serem adicionados ser√£o ajustados. <br><br>  O mapa de espa√ßo livre possui o sufixo "_fsm".  Mas o arquivo n√£o aparece imediatamente, mas somente se necess√°rio.  A maneira mais f√°cil de conseguir isso √© limpar a mesa (por que - vamos conversar no devido tempo): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> accounts;</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 24576 /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><br>  <strong>Um</strong> mapa de visibilidade √© uma camada na qual as p√°ginas que cont√™m apenas vers√µes atuais de cadeias s√£o marcadas com um bit.  Grosso modo, isso significa que quando uma transa√ß√£o tenta ler uma linha dessa p√°gina, a linha pode ser exibida sem verificar sua visibilidade.  Examinaremos em detalhes como isso acontece nos seguintes artigos. <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><br><h1>  P√°ginas </h1><br>  Como j√° dissemos, os arquivos s√£o logicamente divididos em p√°ginas. <br><br>  Normalmente, uma p√°gina tem 8 KB de tamanho.  Voc√™ pode alterar o tamanho dentro de certos limites (16 KB ou 32 KB), mas apenas durante a montagem ( <code>./configure --with-blocksize</code> ).  A inst√¢ncia montada e em execu√ß√£o pode funcionar com p√°ginas de apenas um tamanho. <br><br>  Independentemente de qual camada os arquivos pertencem, eles s√£o usados ‚Äã‚Äãpelo servidor aproximadamente da mesma maneira.  As p√°ginas s√£o lidas primeiro no cache do buffer, onde os processos podem l√™-las e modific√°-las;  depois, se necess√°rio, as p√°ginas s√£o enviadas de volta ao disco. <br><br>  Cada p√°gina possui marca√ß√£o interna e geralmente cont√©m as seguintes se√ß√µes: <br><br><pre>        0 + ----------------------------------- +
           |  posi√ß√£o
       24 + ----------------------------------- +
           |  matriz de ponteiros para seq√º√™ncias de vers√£o |
    menor + ----------------------------------- +
           |  espa√ßo livre |
    superior + ----------------------------------- +
           |  vers√µes de linha |
  especial + ----------------------------------- +
           |  √°rea especial |
 tamanho da p√°gina + ----------------------------------- +
</pre><br>  √â f√°cil descobrir o tamanho dessas se√ß√µes com a p√°gina "pesquisa"; inspecione a extens√£o: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lower, upper, special, pagesize <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lower | upper | special | pagesize -------+-------+---------+---------- 40 | 8016 | 8192 | 8192 (1 row)</code> </pre><br>  Aqui, examinamos o <strong>t√≠tulo da</strong> primeira p√°gina (zero) da tabela.  Al√©m do tamanho das √°reas restantes, o cabe√ßalho cont√©m outras informa√ß√µes sobre a p√°gina, mas ainda n√£o nos interessa. <br><br>  Na parte inferior da p√°gina, h√° uma <strong>√°rea especial</strong> , no nosso caso, vazia.  √â usado apenas para √≠ndices e depois n√£o para todos.  O "fundo" aqui corresponde √† imagem;  talvez seja mais correto dizer "em endere√ßos altos". <br><br>  Ap√≥s a √°rea especial est√£o <strong>as vers√µes de linha</strong> - os mesmos dados que armazenamos na tabela, al√©m de algumas informa√ß√µes gerais. <br><br>  No topo da p√°gina, imediatamente ap√≥s o cabe√ßalho, est√° o √≠ndice: uma <strong>matriz de ponteiros</strong> para a vers√£o das linhas dispon√≠veis na p√°gina. <br><br>  Entre vers√µes de linhas e ponteiros, pode haver <strong>espa√ßo livre</strong> (marcado no mapa de espa√ßo livre).  Observe que n√£o h√° fragmenta√ß√£o dentro da p√°gina, todo o espa√ßo livre √© sempre representado por um fragmento. <br><br><h2>  Ponteiros </h2><br>  Por que os ponteiros para vers√µes de cadeia s√£o necess√°rios?  O fato √© que as linhas de √≠ndice devem, de alguma forma, se referir √† vers√£o das linhas na tabela.  √â claro que o link deve conter o n√∫mero do arquivo, o n√∫mero da p√°gina no arquivo e alguma indica√ß√£o da vers√£o da linha.  Um deslocamento do in√≠cio da p√°gina pode ser usado como uma indica√ß√£o, mas isso √© inconveniente.  N√£o poder√≠amos mover a vers√£o da linha para dentro da p√°gina, pois isso quebraria os links existentes.  E isso levaria √† fragmenta√ß√£o do espa√ßo dentro das p√°ginas e outras conseq√º√™ncias desagrad√°veis.  Portanto, o √≠ndice se refere ao n√∫mero do √≠ndice e o ponteiro se refere √† posi√ß√£o atual da vers√£o da linha na p√°gina.  Acontece endere√ßamento indireto. <br><br>  Cada ponteiro ocupa exatamente 4 bytes e cont√©m: <br><br><ul><li>  link para a vers√£o da string; </li><li>  o comprimento desta vers√£o da string; </li><li>  v√°rios bits que determinam o status da vers√£o de uma string. </li></ul><br><h2>  Formato de dados </h2><br>  O formato dos dados no disco coincide completamente com a representa√ß√£o dos dados na RAM.  A p√°gina √© lida no cache do buffer "como est√°", sem nenhuma transforma√ß√£o.  Portanto, os arquivos de dados de uma plataforma s√£o incompat√≠veis com outras plataformas. <br><br>  Por exemplo, na arquitetura x86, a ordem dos bytes √© adotada da menos significativa para a mais alta (little-endian), o z / Architecture usa a ordem inversa (big-endian) e, no ARM, a ordem dos comutadores. <br><br>  Muitas arquiteturas fornecem alinhamento de dados atrav√©s dos limites das palavras de m√°quina.  Por exemplo, em um sistema x86 de 32 bits, n√∫meros inteiros (tipo inteiro, ocupa 4 bytes) ser√£o alinhados no limite de palavras de 4 bytes, al√©m de n√∫meros de ponto flutuante de precis√£o dupla (tipo de precis√£o dupla, 8 bytes).  E em um sistema de 64 bits, os valores duplos ser√£o alinhados na borda das palavras de 8 bytes.  Esse √© outro motivo de incompatibilidade. <br><br>  Devido ao alinhamento, o tamanho da linha da tabela depende da ordem dos campos.  Normalmente, esse efeito n√£o √© muito percept√≠vel, mas, em alguns casos, pode levar a um aumento significativo no tamanho.  Por exemplo, se voc√™ colocar os campos char (1) e n√∫mero inteiro misturados, 3 bytes geralmente ser√£o desperdi√ßados entre eles.  Voc√™ pode ver mais sobre isso na apresenta√ß√£o de Nikolai Shaplov " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">What's Inside It</a> ". <br><br><h1>  Vers√µes String e TOAST </h1><br>  Sobre como as vers√µes das strings s√£o organizadas por dentro, falaremos em detalhes da pr√≥xima vez.  At√© agora, a √∫nica coisa importante para n√≥s √© que cada vers√£o deve caber inteiramente em uma p√°gina: o PostgreSQL n√£o fornece uma maneira de "continuar" a linha na pr√≥xima p√°gina.  Em vez disso, √© usada uma tecnologia chamada TOAST (The Oversized Attributes Storage Technique).  O pr√≥prio nome sugere que o barbante possa ser cortado em brindes. <br><br>  Falando s√©rio, o TOAST envolve v√°rias estrat√©gias.  Os valores dos atributos "longos" podem ser enviados para uma tabela de servi√ßo separada, previamente cortada em pequenos peda√ßos de torradas.  Outra op√ß√£o √© compactar o valor para que a vers√£o da linha ainda caiba em uma p√°gina de tabela comum.  E √© poss√≠vel tanto isso como outro: primeiro comprimir e s√≥ depois cortar e enviar. <br><br>  Para cada tabela principal, se necess√°rio, √© criada uma tabela separada, mas uma para todos os atributos, a tabela TOAST (e um √≠ndice especial).  A necessidade √© determinada pela presen√ßa de atributos potencialmente longos na tabela.  Por exemplo, se uma tabela tiver uma coluna do tipo num√©rico ou texto, uma tabela TOAST ser√° criada imediatamente, mesmo que valores longos n√£o sejam usados. <br><br>  Como a tabela TOAST √© essencialmente uma tabela regular, ela ainda possui o mesmo conjunto de camadas.  E isso dobra o n√∫mero de arquivos que "servem" a tabela. <br><br>  Inicialmente, as estrat√©gias s√£o determinadas pelos tipos de dados da coluna.  Voc√™ pode visualiz√°-los com o comando <code>\d+</code> no psql, mas como tamb√©m exibe muitas outras informa√ß√µes, usaremos a solicita√ß√£o no diret√≥rio do sistema: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attname, atttypid::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> attstorage <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'p'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'plain'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'external'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'m'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'extended'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attrelid = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attnum &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | extended client | text | extended amount | numeric | main (4 rows)</code> </pre><br>  Os nomes das estrat√©gias t√™m os seguintes significados: <br><br><ul><li>  plain - TOAST n√£o √© usado (usado para tipos de dados obviamente "curtos", como n√∫mero inteiro); </li><li>  estendido - a compacta√ß√£o e o armazenamento em uma tabela TOAST separada s√£o permitidos; </li><li>  valores externos externos s√£o armazenados na tabela TOAST descompactada; </li><li>  Os valores main - long s√£o compactados primeiro e somente na tabela TOAST se a compacta√ß√£o n√£o ajudar. </li></ul><br>  Em termos gerais, o algoritmo √© o seguinte.  O PostgreSQL deseja que pelo menos 4 linhas caibam na p√°gina.  Portanto, se o tamanho da linha exceder a quarta parte da p√°gina, levando em considera√ß√£o o cabe√ßalho (com uma p√°gina normal de 8K, 2040 bytes), o TOAST deve ser aplicado a parte dos valores.  Agimos na ordem descrita abaixo e paramos assim que a linha parar de exceder o limite: <br><br><ol><li>  Primeiro, classificamos atributos com estrat√©gias externas e estendidas, passando do mais longo para o mais curto.  Os atributos estendidos s√£o compactados (se isso tiver um efeito) e, se o valor em si exceder um quarto da p√°gina, ele ser√° imediatamente enviado para a tabela TOAST.  Atributos externos s√£o tratados da mesma maneira, mas n√£o s√£o compactados. </li><li>  Se ap√≥s a primeira passagem a vers√£o da linha ainda n√£o se ajustar, enviaremos os atributos restantes com as estrat√©gias externas e estendidas para a tabela TOAST. </li><li>  Se isso tamb√©m n√£o ajudar, tente compactar os atributos com a estrat√©gia principal, deixando-os na p√°gina da tabela. </li><li>  E somente se depois disso a linha ainda n√£o for curta o suficiente, os principais atributos ser√£o enviados para a tabela TOAST. </li></ol><br>  √Äs vezes, pode ser √∫til alterar a estrat√©gia para algumas colunas.  Por exemplo, se for sabido antecipadamente que os dados na coluna n√£o est√£o compactados, voc√™ pode definir uma estrat√©gia externa para isso - isso economizar√° em tentativas de compacta√ß√£o in√∫teis.  Isso √© feito da seguinte maneira: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STORAGE external</span></span>;</code> </pre><br>  Repetindo a solicita√ß√£o, obtemos: <br><br><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | external client | text | extended amount | numeric | main</code> </pre><br>  As tabelas e √≠ndices TOAST est√£o localizados em um esquema pg_toast separado e, portanto, geralmente n√£o s√£o vis√≠veis.  Para tabelas tempor√°rias, o esquema pg_toast_temp_ <em>N</em> √© usado, semelhante ao usual pg_temp_ <em>N.</em> <br><br>  √â claro que, se desejado, ningu√©m se incomoda em espiar a mec√¢nica interna do processo.  Digamos que haja tr√™s atributos potencialmente longos na tabela de contas, portanto, uma tabela TOAST deve ser.  Aqui est√°: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relnamespace::<span class="hljs-type"><span class="hljs-type">regnamespace</span></span>, relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltoastrelid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> relnamespace | relname --------------+---------------- pg_toast | pg_toast_33953 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d+ pg_toast.pg_toast_33953</code> </pre><pre> <code class="plaintext hljs">TOAST table "pg_toast.pg_toast_33953" Column | Type | Storage ------------+---------+--------- chunk_id | oid | plain chunk_seq | integer | plain chunk_data | bytea | plain</code> </pre><br>  √â l√≥gico que, para os ‚Äúbrindes‚Äù nos quais a linha √© cortada, a estrat√©gia simples seja aplicada: o TOAST do segundo n√≠vel n√£o existe. <br><br>  O √≠ndice do PostgreSQL √© oculto com mais cuidado, mas tamb√©m √© f√°cil encontrar: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indrelid = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'pg_toast_33953'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> indexrelid ------------------------------- pg_toast.pg_toast_33953_index (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d pg_toast.pg_toast_33953_index</code> </pre><pre> <code class="plaintext hljs">Unlogged index "pg_toast.pg_toast_33953_index" Column | Type | Key? | Definition -----------+---------+------+------------ chunk_id | oid | yes | chunk_id chunk_seq | integer | yes | chunk_seq primary key, btree, for table "pg_toast.pg_toast_33953"</code> </pre><br>  A coluna do cliente usa a estrat√©gia estendida: os valores nela ser√£o compactados.  Verifique: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = repeat(<span class="hljs-string"><span class="hljs-string">'A'</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | chunk_data ----------+-----------+------------ (0 rows)</code> </pre><br>  N√£o h√° nada na tabela TOAST: caracteres repetidos s√£o perfeitamente compactados e, depois disso, o valor se encaixa em uma p√°gina de tabela comum. <br><br>  Agora deixe o nome do cliente consistir em caracteres aleat√≥rios: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> string_agg( chr(trunc(<span class="hljs-number"><span class="hljs-number">65</span></span>+random()*<span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> left(client,<span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(client,<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ------------------------- TCKGKZZSLI...RHQIOLWRRX (1 row)</code> </pre><br>  Esta sequ√™ncia n√£o pode ser compactada e se enquadra na tabela TOAST: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> chunk_id, chunk_seq, length(chunk_data), left(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | length | ?column? ----------+-----------+--------+------------------------- 34000 | 0 | 2000 | TCKGKZZSLI...ZIPFLOXDIW 34000 | 1 | 1000 | DDXNNBQQYH...RHQIOLWRRX (2 rows)</code> </pre><br>  Como voc√™ pode ver, os dados s√£o cortados em fragmentos de 2000 bytes. <br><br>  Ao acessar um valor "longo", o PostgreSQL automaticamente, transparente para a aplica√ß√£o, restaura o valor original e o retorna ao cliente. <br><br>  Obviamente, muitos recursos s√£o gastos em compacta√ß√£o fatiada e recupera√ß√£o subseq√ºente.  Portanto, armazenar dados volumosos no PostgreSQL n√£o √© uma boa ideia, especialmente se for usado ativamente e a l√≥gica transacional n√£o for necess√°ria para eles (como um exemplo: originais digitalizados de documentos cont√°beis).  Uma alternativa mais lucrativa pode ser armazenar esses dados no sistema de arquivos e no DBMS, os nomes dos arquivos correspondentes. <br><br>  Uma tabela TOAST √© usada apenas quando se refere a um valor "longo".  Al√©m disso, a tabela de brinde possui seu pr√≥prio controle de vers√£o: se a atualiza√ß√£o de dados n√£o afetar o valor "longo", a nova vers√£o da linha far√° refer√™ncia ao mesmo valor na tabela de brinde - isso economizar√° espa√ßo. <br><br>  Observe que o TOAST funciona apenas para tabelas, mas n√£o para √≠ndices.  Isso imp√µe um limite no tamanho das chaves indexadas. <br><blockquote>  Voc√™ pode ler mais sobre a organiza√ß√£o interna de dados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na documenta√ß√£o</a> . <br></blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para ser continuado</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444536/">https://habr.com/ru/post/pt444536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444524/index.html">Lambdas: de C ++ 11 a C ++ 20. Parte 1</a></li>
<li><a href="../pt444526/index.html">Pilha de DOTS: C ++ e C #</a></li>
<li><a href="../pt444528/index.html">Situa√ß√£o: o Jap√£o pode limitar o download de conte√∫do da rede - entendemos e discutimos</a></li>
<li><a href="../pt444530/index.html">O futuro da inje√ß√£o de depend√™ncia no Android</a></li>
<li><a href="../pt444534/index.html">Verifica√ß√£o de vulnerabilidades e desenvolvimento seguro. Parte 1</a></li>
<li><a href="../pt444540/index.html">Intel est√° pronta para come√ßar a produ√ß√£o de mem√≥ria MRAM</a></li>
<li><a href="../pt444542/index.html">Transmiss√£o ao vivo e programa√ß√£o de confer√™ncias para SmartMail Conf: Machine Learning</a></li>
<li><a href="../pt444544/index.html">Algo sobre data centers distribu√≠dos para empresas</a></li>
<li><a href="../pt444546/index.html">Como e por que trabalhar mais devagar? O m√©todo de Sergey Korolev</a></li>
<li><a href="../pt444548/index.html">Experi√™ncia pessoal: como nos envolvemos na promo√ß√£o de startups hisp√¢nicas na Am√©rica Latina</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>