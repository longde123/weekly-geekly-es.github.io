<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👝 💲 🐚 Kode itu hidup dan mati. Bagian tiga. Kode sebagai teks ⛹🏻 🤙🏾 🙍🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anda harus membaca kode untuk menemani program, dan semakin mudah untuk melakukannya, semakin terlihat seperti bahasa alami - maka Anda akan masuk leb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kode itu hidup dan mati. Bagian tiga. Kode sebagai teks</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447830/"><p>  Anda harus membaca kode untuk menemani program, dan semakin mudah untuk melakukannya, semakin terlihat seperti bahasa alami - maka Anda akan masuk lebih cepat dan fokus pada hal utama. </p><br><p> Dalam dua artikel terakhir, saya menunjukkan bahwa kata-kata yang dipilih dengan cermat membantu untuk lebih memahami esensi dari apa yang ditulis, tetapi <em>hanya</em> memikirkannya <em>saja</em> tidak cukup, karena setiap kata ada dalam dua bentuk: seperti dalam dirinya sendiri dan sebagai bagian dari kalimat.  Mengulang <code>CurrentThread</code> belum berulang sampai kita <em>membacanya</em> dalam konteks <code>Thread.CurrentThread</code> . </p><br><p>  Dengan demikian, dipandu oleh not dan melodi sederhana, kita sekarang akan melihat apa itu musik. </p><a name="habracut"></a><br><h2 id="oglavlenie-cikla">  Siklus daftar isi </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Benda-benda</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tindakan dan properti</a> </li><li>  Kode sebagai teks </li></ol><br><h2 id="kod-kak-tekst">  Kode sebagai teks </h2><br><p>  Kebanyakan antarmuka yang <em>lancar</em> dirancang dengan penekanan pada eksternal daripada internal, sehingga sangat mudah dibaca.  Tentu saja, tidak gratis: isinya melemah.  Jadi, katakanlah, dalam paket <code>FluentAssertions</code> dapat menulis: <code>(2 + 2).Should().Be(4, because: "2 + 2 is 4!")</code> , Dan, relatif terhadap membaca, <code>because</code> terlihat elegan, tetapi di dalam <code>Be()</code> lebih tepatnya, parameter <code>error</code> atau <code>errorMessage</code> . </p><br><p>  Menurut pendapat saya, pengecualian seperti itu tidak signifikan.  Ketika kami sepakat bahwa kode tersebut adalah teks, komponen-komponennya tidak lagi menjadi milik mereka: mereka sekarang menjadi bagian dari semacam <em>"Eter"</em> universal. </p><br><p>  Saya akan menunjukkan dengan contoh bagaimana pertimbangan seperti itu menjadi pengalaman. </p><br><h3 id="interlocked"> <code>Interlocked</code> </h3> <br><p>  Biarkan saya mengingatkan Anda tentang <code>Interlocked.CompareExchange(ref x, newX, oldX)</code> <code>Interlocked</code> , yang kami beralih dari <code>Interlocked.CompareExchange(ref x, newX, oldX)</code> ke <code>Atomically.Change(ref x, from: oldX, to: newX)</code> , menggunakan nama metode dan parameter yang jelas. </p><br><h3 id="exceptwith"> <code>ExceptWith</code> </h3> <br><p>  Tipe <code>ISet&lt;&gt;</code> memiliki metode yang disebut <code>ExceptWith</code> .  Jika Anda melihat panggilan seperti <code>items.ExceptWith(other)</code> , Anda tidak akan segera menyadari apa yang terjadi.  Tapi Anda hanya perlu menulis: <code>items.Exclude(other)</code> , karena semuanya jatuh pada tempatnya. </p><br><h3 id="getvalueordefault"> <code>GetValueOrDefault</code> </h3> <br><p>  Saat bekerja dengan <code>Nullable&lt;T&gt;</code> memanggil <code>x.Value</code> akan mengeluarkan pengecualian jika <code>x</code> adalah <code>null</code> .  Jika Anda masih perlu mendapatkan <code>Value</code> , gunakan <code>x.GetValueOrDefault</code> : itu adalah <code>Value</code> atau nilai default.  Tebal. </p><br><p>  Ekspresi <em>"atau x, atau nilai default"</em> cocok dengan <code>x.OrDefault</code> pendek dan elegan. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? x = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = x.GetValueOrDefault(); <span class="hljs-comment"><span class="hljs-comment">// ,  .  . var b = x.OrDefault(); //  —  ,   . var c = x.Or(10); //     .</span></span></code> </pre> <br><p>  Dengan <code>OrDefault</code> dan <code>Or</code> ada satu hal yang patut diingat: ketika bekerja dengan operator <code>.?</code>  Anda tidak dapat menulis sesuatu seperti <code>x?.IsEnabled.Or(false)</code> , hanya <code>(x?.IsEnabled).Or(false)</code> (dengan kata lain, operator <code>.?</code> Membatalkan <em>seluruh</em> sisi kanan jika <code>null</code> di sebelah kiri). </p><br><p>  Templat dapat diterapkan saat bekerja dengan <code>IEnumerable&lt;T&gt;</code> : </p><br><pre> <code class="cs hljs">IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">// . var x = numbers ?? Enumerable.Empty&lt;int&gt;(); //   . var x = numbers.OrEmpty();</span></span></code> </pre> <br><h3 id="mathmin-i-mathmax">  <code>Math.Min</code> dan <code>Math.Max</code> </h3><br><p>  Sebuah ide dengan <code>Or</code> dapat dikembangkan menjadi tipe numerik.  Misalkan Anda ingin mengambil angka maksimum dari <code>a</code> dan <code>b</code> .  Kemudian kita menulis: <code>Math.Max(a, b)</code> atau <code>a &gt; b ? a : b</code>  <code>a &gt; b ? a : b</code> .  Kedua opsi terlihat cukup akrab, tetapi, bagaimanapun, tidak terlihat seperti bahasa alami. </p><br><p>  Anda dapat menggantinya dengan: <code>a.Or(b).IfLess()</code> - <em>ambil</em> <code>a</code> <em>atau</em> <code>b</code> <em>jika</em> <code>a</code> <em>kurang</em> .  Cocok untuk situasi seperti itu: </p><br><pre> <code class="cs hljs">Creature creature = ...; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> damage = ...; <span class="hljs-comment"><span class="hljs-comment">//   . creature.Health = Math.Max(creature.Health - damage, 0); // Fluent. creature.Health = (creature.Health - damage).Or(0).IfGreater(); //   : creature.Health = (creature.Health - damage).ButNotLess(than: 0);</span></span></code> </pre> <br><h3 id="stringjoin"> <code>string.Join</code> </h3> <br><p>  Terkadang Anda perlu merakit urutan menjadi string, memisahkan elemen dengan spasi atau koma.  Untuk melakukan ini, gunakan <code>string.Join</code> , misalnya, seperti ini: <code>string.Join(", ", new [] { 1, 2, 3 }); //  "1, 2, 3".</code> <code>string.Join(", ", new [] { 1, 2, 3 }); //  "1, 2, 3".</code>  . </p><br><p>  Sederhana <em>"Bagi nomor koma"</em> tiba-tiba menjadi <em>"Lampirkan koma ke setiap nomor dari daftar"</em> - ini tentu bukan kode sebagai teks. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// ""    —  . var x = string.Join(", ", numbers); //    — ! var x = numbers.Separated(with: ", ");</span></span></code> </pre> <br><h3 id="regex"> <code>Regex</code> </h3> <br><p>  Namun, <code>string.Join</code> sangat tidak berbahaya dibandingkan dengan bagaimana <code>Regex</code> kadang <code>Regex</code> kadang digunakan secara tidak benar dan untuk tujuan lain.  Di mana Anda dapat bertahan dengan teks sederhana dan mudah dibaca, karena alasan tertentu entri yang terlalu rumit lebih disukai. </p><br><p>  Mari kita mulai dengan yang sederhana - menentukan bahwa string mewakili sekumpulan angka: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> id = ...; <span class="hljs-comment"><span class="hljs-comment">// ,  . var x = Regex.IsMatch(id, "^[0-9]*$"); // . var x = id.All(x =&gt; x.IsDigit()); // ! var x = id.IsNumer();</span></span></code> </pre> <br><p>  Kasus lain adalah untuk mengetahui apakah ada setidaknya satu karakter dalam string dari urutan: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = ...; <span class="hljs-comment"><span class="hljs-comment">//   . var x = Regex.IsMatch(text, @"["&lt;&gt;[]'"); //   . ( .) var x = text.ContainsAnyOf('"', '&lt;', '&gt;', '[', ']', '\''); //  . var x = text.ContainsAny(charOf: @"["&lt;&gt;[]'");</span></span></code> </pre> <br><p>  Semakin rumit tugasnya, semakin sulit solusi "pola": untuk membagi catatan jenis <code>"HelloWorld"</code> menjadi beberapa kata <code>"Hello World"</code> , seseorang bukannya algoritma sederhana menginginkan monster: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = ...; <span class="hljs-comment"><span class="hljs-comment">//   -   . var x = Regex.Replace(text, "([az](?=[AZ])|[AZ](?=[AZ][az]))", "$1 "); //  . var x = text.PascalCaseWords().Separated(with: " "); //   . var x = text.AsWords(eachStartsWith: x =&gt; x.IsUpper()).Separated(with: " ");</span></span></code> </pre> <br><p>  Tidak diragukan lagi, ekspresi reguler efektif dan universal, tetapi saya ingin memahami apa yang terjadi pada pandangan pertama. </p><br><h3 id="substring-i-remove">  <code>Substring</code> dan <code>Remove</code> </h3><br><p>  Itu terjadi bahwa Anda perlu menghapus beberapa bagian dari baris dari awal atau akhir, misalnya, dari <code>path</code> - <code>.txt</code> ekstensi, jika ada. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = ...; <span class="hljs-comment"><span class="hljs-comment">//    . var x = path.EndsWith(".txt") ? path.Remove(path.Length - "txt".Length) : path; //   . var x = path.Without(".exe").AtEnd;</span></span></code> </pre> <br><p>  Sekali lagi, <em>tindakan</em> dan <em>algoritme</em> hilang, dan <em>garis</em> sederhana <em>dibiarkan tanpa ekstensi .exe di akhir</em> . </p><br><p>  Karena metode <code>Without</code> harus mengembalikan <code>WithoutExpression</code> tertentu, mereka memohon untuk yang lain: <code>path.Without("_").AtStart</code> dan <code>path.Without("_").AtStart</code> <code>path.Without("Something").Anywhere</code> .  Menarik juga bahwa ungkapan lain dapat dikonstruksikan dengan kata yang sama: <code>name.Without(charAt: 1)</code> - menghapus karakter pada indeks 1 dan mengembalikan baris baru (berguna dalam menghitung permutasi).  Dan juga bisa dibaca! </p><br><h3 id="typegetmethods"> <code>Type.GetMethods</code> </h3> <br><p>  Untuk mendapatkan metode jenis tertentu menggunakan refleksi, gunakan: </p><br><pre> <code class="cs hljs">Type type = ...; <span class="hljs-comment"><span class="hljs-comment">//   `Get` ,   `|`.     . var x = type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance); // ,  . `Or`   , . var x = type.Methods(_ =&gt; _.Instance.Public.Or.NonPublic);</span></span></code> </pre> <br><p>  (Hal yang sama berlaku untuk <code>GetFields</code> dan <code>GetProperties</code> .) </p><br><h3 id="directorycopy"> <code>Directory.Copy</code> </h3> <br><p>  Semua operasi dengan folder dan file sering digeneralisasi ke <code>DirectoryUtils</code> , <code>FileSystemHelper</code> .  Mereka menerapkan bypass sistem file, pembersihan, penyalinan, dll.  Tetapi di sini Anda dapat menemukan sesuatu yang lebih baik! </p><br><p>  Kami menampilkan teks <em>"salin semua file dari 'D: \ Source' ke 'D: \ Target'"</em> ke kode <code>"D:\\Source".AsDirectory().Copy().Files.To("D:\\Target")</code>  <code>AsDirectory()</code> - mengembalikan <code>DirectoryInfo</code> dari <code>string</code> , dan <code>Copy()</code> - membuat instance <code>CopyExpression</code> yang menjelaskan API unik untuk membangun ekspresi (Anda tidak dapat memanggil <code>Copy().Files.Files</code> , misalnya).  Maka kesempatan terbuka untuk menyalin tidak semua file, tetapi beberapa: <code>Copy().Files.Where(x =&gt; x.IsNotEmpty)</code> . </p><br><h3 id="getorderbyid"> <code>GetOrderById</code> </h3> <br><p>  Pada artikel kedua, saya menulis bahwa <code>IUsersRepository.GetUser(int id)</code> berlebihan, dan lebih baik, <code>IUsersRepository.User(int id)</code> .  Dengan demikian, dalam <code>IOrdersRepository</code> serupa <code>IOrdersRepository</code> kami belum <code>GetOrderById(int id)</code> , tetapi <code>Order(int id)</code> .  Namun, dalam contoh lain, disarankan agar variabel repositori seperti itu disebut bukan <code>_ordersRepository</code> , tetapi hanya <code>_orders</code> . </p><br><p>  Kedua perubahan itu baik pada mereka sendiri, tetapi mereka tidak dijumlahkan bersama dalam konteks membaca: menelepon <code>_orders.Order(id)</code> terlihat bertele-tele.  Mungkin untuk <code>_orders.Get(id)</code> , tetapi pesanan gagal, kami hanya ingin menentukan <em>yang memiliki pengidentifikasi seperti itu</em> .  <em>Satu itu</em> adalah <code>One</code> , oleh karena itu: </p><br><pre> <code class="cs hljs">IOrdersRepository orders = ...; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = ...; <span class="hljs-comment"><span class="hljs-comment">//   . var x = orders.GetOrderById(id); //      : var x = orders.Order(id); //     ,    . var x = orders.One(id); //    : var x = orders.One(with: id);</span></span></code> </pre> <br><h3 id="getorders"> <code>GetOrders</code> </h3> <br><p>  Dalam objek seperti <code>IOrdersRepository</code> , metode lain sering ditemukan: <code>AddOrder</code> , <code>RemoveOrder</code> , <code>GetOrders</code> .  Dua pengulangan pertama hilang, dan <code>Add</code> dan <code>Remove</code> diperoleh (dengan entri <code>_orders.Add(order)</code> dan <code>_orders.Remove(order)</code> ) yang sesuai.  Dengan <code>GetOrders</code> agak sulit untuk mengubah nama <code>Orders</code> sedikit.  Mari kita lihat: </p><br><pre> <code class="cs hljs">IOrdersRepository orders = ...; <span class="hljs-comment"><span class="hljs-comment">//   . var x = orders.GetOrders(); //  `Get`,  . var x = orders.Orders(); // ! var x = orders.All();</span></span></code> </pre> <br><p>  Perlu dicatat bahwa dengan <code>_ordersRepository</code> lama <code>_ordersRepository</code> pengulangan di <code>GetOrders</code> atau <code>GetOrderById</code> tidak begitu terlihat, karena kami bekerja dengan repositori! </p><br><p>  Nama seperti <code>One</code> , <code>All</code> cocok untuk banyak antarmuka yang mewakili banyak.  Katakanlah, dalam implementasi API GitHub yang terkenal - <code>octokit</code> - mendapatkan semua repositori pengguna terlihat seperti <code>gitHub.Repository.GetAllForUser("John")</code> , meskipun lebih logis - <code>gitHub.Users.One("John").Repositories.All</code> .  Dalam hal ini, mendapatkan <em>satu</em> repositori akan menjadi, masing-masing, <code>gitHub.Repository.Get("John", "Repo")</code> alih-alih <code>gitHub.Users.One("John").Repositories.One("Repo")</code> jelas. <code>gitHub.Users.One("John").Repositories.One("Repo")</code> .  Kasus kedua terlihat lebih panjang, tetapi konsisten secara internal dan mencerminkan platform.  Selain itu, dengan menggunakan metode ekstensi, dapat disingkat menjadi <code>gitHub.User("John").Repository("Repo")</code> . </p><br><h3 id="dictionarytrygetvalue"> <code>Dictionary.TryGetValue</code> </h3> <br><p>  Memperoleh nilai dari kamus dibagi menjadi beberapa skenario yang hanya berbeda dalam <em>apa yang</em> perlu dilakukan jika kunci tidak ditemukan: </p><br><ul><li>  melempar kesalahan ( <code>dictionary[key]</code> ); </li><li>  mengembalikan nilai default (tidak diterapkan, tetapi sering menulis <code>GetValueOrDefault</code> atau <code>TryGetValue</code> ); </li><li>  kembalikan sesuatu yang lain (tidak diterapkan, tapi saya harapkan <code>GetValueOrOther</code> ); </li><li>  tulis nilai yang ditentukan ke kamus dan kembalikan (tidak diterapkan, tetapi <code>GetOrAdd</code> ). </li></ul><br><p>  Ekspresi bertemu pada titik " <em>ambil X, atau Y jika X tidak</em> ."  Selain itu, seperti dalam kasus <code>_ordersRepository</code> , kita akan memanggil variabel kamus bukan <code>itemsDictionary</code> , tetapi <code>items</code> . </p><br><p>  Kemudian untuk bagian <em>"ambil beberapa X"</em> , panggilan <code>items.One(withKey: X)</code> formulir. <code>items.One(withKey: X)</code> ideal, mengembalikan struktur dengan empat <em>ujung</em> : </p><br><pre> <code class="cs hljs">Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, Item&gt; items = ...; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = ...; <span class="hljs-comment"><span class="hljs-comment">//  ,   : var x = items.GetValueOrDefault(id); var x = items[id]; var x = items.GetOrAdd(id, () =&gt; new Item()); //    : var x = items.One(with: id).OrDefault(); var x = items.One(with: id).Or(Item.Empty); var x = items.One(with: id).OrThrow(withMessage: $"Couldn't find item with '{id}' id."); var x = items.One(with: id).OrNew(() =&gt; new Item());</span></span></code> </pre> <br><h3 id="assemblygettypes"> <code>Assembly.GetTypes</code> </h3> <br><p>  Mari kita lihat cara membuat semua contoh tipe <code>T</code> dalam perakitan: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// . var x = Assembly .GetAssembly(typeof(T)) .GetTypes() .Where(...) .Select(Activator.CreateInstance); // "" . var x = TypesHelper.GetAllInstancesOf&lt;T&gt;(); // . var x = Instances.Of&lt;T&gt;();</span></span></code> </pre> <br><p>  Jadi, kadang-kadang, nama kelas statis adalah <em>awal dari sebuah</em> ekspresi. </p><br><p>  Sesuatu yang serupa dapat ditemukan di NUnit: <code>Assert.That(2 + 2, Is.EqualTo(4))</code> - <code>Is</code> dan tidak dipahami sebagai tipe mandiri. </p><br><h3 id="argumentthrowifnull"> <code>Argument.ThrowIfNull</code> </h3> <br><p>  Sekarang lihat pada pemeriksaan prasyarat: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  . Argument.ThrowIfNull(x); Guard.CheckAgainstNull(x); // . x.Should().BeNotNull(); // ,  ...  ? Ensure(that: x).NotNull();</span></span></code> </pre> <br><p>  <code>Ensure.NotNull(argument)</code> - bagus, tetapi tidak cukup bahasa Inggris.  Hal lain adalah <code>Ensure(that: x).NotNull()</code> ditulis di atas.  Kalau saja ada ... </p><br><p>  Ngomong-ngomong, kamu bisa!  Kami menulis <code>Contract.Ensure(that: argument).IsNotNull()</code> dan impor jenis <code>Contract</code> <code>using static</code> .  Jadi segala macam <code>Ensure(that: type).Implements&lt;T&gt;()</code> , <code>Ensure(that: number).InRange(from: 5, to: 10)</code> , dll <code>Ensure(that: number).InRange(from: 5, to: 10)</code> . </p><br><p>  Gagasan impor statis membuka banyak pintu.  Contoh yang bagus untuk kepentingan: alih-alih <code>Remove(x, from: items)</code> . <code>Remove(x, from: items)</code> <code>items.Remove(x)</code> tulis <code>Remove(x, from: items)</code> .  Namun rasa ingin tahu adalah pengurangan <code>enum</code> dan properti yang mengembalikan fungsi. </p><br><pre> <code class="cs hljs">IItems items = ...; <span class="hljs-comment"><span class="hljs-comment">// . var x = items.All(where: x =&gt; x.IsWeapon); //  . // `ItemsThatAre.Weapons`  `Predicate&lt;bool&gt;`. var x = items.All(ItemsThatAre.Weapons); // `using static`  !  . var x = items.All(Weapons);</span></span></code> </pre> <br><h3 id="ekzoticheskiy-find">  <code>Find</code> Eksotis </h3><br><p>  Dalam C # 7.1 dan lebih tinggi, Anda dapat menulis bukan <code>Find(1, @in: items)</code> , tetapi <code>Find(1, in items)</code> , di mana <code>Find</code> didefinisikan sebagai <code>Find&lt;T&gt;(T item, in IEnumerable&lt;T&gt; items)</code> .  Contoh ini tidak praktis, tetapi menunjukkan bahwa semua sarana bagus dalam perjuangan untuk keterbacaan. </p><br><h2 id="itogo">  Total </h2><br><p>  Pada bagian ini, saya melihat beberapa cara untuk bekerja dengan keterbacaan kode.  Semuanya dapat digeneralisasi ke: </p><br><ul><li>  <strong>Parameter bernama sebagai bagian dari ekspresi</strong> adalah <code>Should().Be(4, because: "")</code> , <code>Atomically.Change(ref x, from: oldX, to: newX)</code> . <code>Atomically.Change(ref x, from: oldX, to: newX)</code> . </li><li>  <strong>Nama sederhana alih-alih detail teknis</strong> <code>Separated(with: ", ")</code> , <code>Exclude</code> . </li><li>  <strong>Metode sebagai bagian dari variabel</strong> adalah <code>x.OrDefault()</code> , <code>x.Or(b).IfLess()</code> , <code>orders.One(with: id)</code> , <code>orders.All</code> . </li><li>  <strong>Metode sebagai bagian dari ekspresi</strong> adalah <code>path.Without(".exe").AtEnd</code> . </li><li>  <strong>Jenis sebagai bagian dari ekspresi</strong> adalah <code>Instances.Of</code> , <code>Is.EqualTo</code> . </li><li>  <strong>Metode sebagai bagian dari ekspresi ( <code>using static</code> )</strong> adalah <code>Ensure(that: x)</code> , <code>items.All(Weapons)</code> . </li></ul><br><p>  Dengan demikian, yang eksternal dan yang direnungkan dibawa ke permukaan.  Mula-mula ia dianggap, dan kemudian inkarnasi spesifiknya dipikirkan, tidak begitu penting, selama kode itu dibaca sebagai teks.  Oleh karena itu, juri tidak begitu menyukai <em>bahasa</em> - ia menentukan perbedaan antara <code>item.GetValueOrDefault</code> dan <code>item.OrDefault</code> . </p><br><h2 id="epilog">  Epilog </h2><br><p>  Mana yang lebih baik, jelas, tetapi bukan metode kerja, atau bekerja, tetapi tidak bisa dipahami?  Kastil berwarna putih salju tanpa perabotan dan kamar atau gudang dengan gaya Louis XIV?  Kapal pesiar mewah tanpa mesin atau tongkang mengerang dengan komputer kuantum yang tidak dapat digunakan siapa pun? </p><br><p>  Jawaban kutub tidak cocok, tetapi <em>"di suatu tempat di tengah"</em> juga. </p><br><p>  Menurut pendapat saya, kedua konsep itu tidak dapat dipisahkan: dengan hati-hati memilih sampul buku, kami ragu-ragu melihat kesalahan dalam teks, dan sebaliknya.  Saya tidak ingin <em>The Beatles</em> memainkan musik berkualitas rendah, tetapi mereka juga harus disebut <em>MusicHelper</em> . </p><br><p>  Hal lain adalah bahwa mengerjakan kata sebagai bagian dari proses pembangunan adalah hal yang diremehkan, hal yang tidak biasa, dan oleh karena itu semacam penilaian ekstrem masih diperlukan.  Siklus ini adalah bentuk dan gambar yang ekstrem. </p><br><p>  Terima kasih atas perhatian Anda! </p><br><h2 id="ssylki">  Referensi </h2><br><p>  Siapa pun yang tertarik melihat lebih banyak contoh dapat ditemukan di GitHub saya, misalnya, di perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Pocket.Common</code></a> .  <em>(tidak untuk penggunaan di seluruh dunia dan universal)</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447830/">https://habr.com/ru/post/id447830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447818/index.html">AgileDays 2019</a></li>
<li><a href="../id447820/index.html">Impor model 3D ke dalam Unity dan jebakan</a></li>
<li><a href="../id447822/index.html">Hampir dipecat. Bagaimana saya membangun departemen analitik Yandex</a></li>
<li><a href="../id447826/index.html">Perekrut harus dapat menjual</a></li>
<li><a href="../id447828/index.html">Bagaimana kami melakukannya untuk orang-orang di Rostelecom</a></li>
<li><a href="../id447832/index.html">Belum lama ini</a></li>
<li><a href="../id447834/index.html">Hancurkan dalam 9 detik. Bagaimana algoritma yang tidak diketahui menghancurkan IPO BATS</a></li>
<li><a href="../id447836/index.html">Test drive nanoCAD SPDS Metalwork 1.2. Bagian 1</a></li>
<li><a href="../id447838/index.html">Bagaimana Teknologi IoT Akan Mengubah Dunia dalam 10 Tahun Mendatang</a></li>
<li><a href="../id447842/index.html">Mikrobiota. Apa organ ini dan mengapa kita membutuhkannya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>