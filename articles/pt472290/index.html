<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêüèΩ üêü ‚úåüèæ Estruturas vs. Classes üîè üéÄ üõÄüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desde o in√≠cio, quando comecei a programar, surgiu a quest√£o sobre o que usar para melhorar o desempenho: estrutura ou classe; quais matrizes s√£o melh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estruturas vs. Classes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472290/">  Desde o in√≠cio, quando comecei a programar, surgiu a quest√£o sobre o que usar para melhorar o desempenho: estrutura ou classe;  quais matrizes s√£o melhores para usar e como.  Em rela√ß√£o √†s estruturas, a Apple agradece seu uso, explicando que elas s√£o melhores em otimiza√ß√£o, e toda a ess√™ncia da linguagem Swift √© a estrutura.  Mas h√° quem n√£o concorde com isso, porque voc√™ pode simplificar lindamente o c√≥digo herdando uma classe da outra e trabalhando com essa classe.  Para acelerar o trabalho com as classes, criamos diferentes modificadores e objetos que foram otimizados especificamente para as classes, e j√° √© dif√≠cil dizer o que ser√° mais r√°pido e, nesse caso. <br><br>  Para organizar todos os pontos no "e", escrevi v√°rios testes que usam as abordagens usuais do processamento de dados: passando para um m√©todo, copiando, trabalhando com matrizes e assim por diante.  Decidi n√£o tirar grandes conclus√µes, todos decidir√£o por si mesmos se vale a pena acreditar nos testes, poder√£o fazer o download do projeto e ver como ele funcionar√° para voc√™, e tentar otimizar a opera√ß√£o de um teste espec√≠fico.  Talvez at√© novos chips sejam lan√ßados que eu n√£o mencionei, ou eles s√£o t√£o raramente usados ‚Äã‚Äãque eu simplesmente n√£o ouvi falar deles. <br><a name="habracut"></a><br>  PS: Comecei a trabalhar em um artigo no Xcode 10.3 e pensei em tentar comparar sua velocidade com o Xcode 11, mas ainda assim, o artigo n√£o trata de comparar dois aplicativos, mas da velocidade de nossos aplicativos.  N√£o tenho d√∫vidas de que o tempo de execu√ß√£o das fun√ß√µes diminuir√° e o que foi mal otimizado se tornar√° mais r√°pido.  Como resultado, esperei pelo novo Swift 5.1 e decidi testar as hip√≥teses na pr√°tica.  Boa leitura. <br><br><h4>  Teste 1: comparar matrizes em estruturas e classes </h4><br>  Suponha que tenhamos uma classe e desejemos colocar os objetos dessa classe em uma matriz, a a√ß√£o usual em uma matriz √© fazer um loop atrav√©s dela. <br><br>  Em uma matriz, ao usar classes e tentar percorr√™-lo, o n√∫mero de links aumenta; ap√≥s a conclus√£o, o n√∫mero de links para o objeto diminui. <br><br>  Se percorrermos a estrutura, no momento em que o objeto for chamado pelo √≠ndice, uma c√≥pia do objeto ser√° criada, olhando para a mesma √°rea de mem√≥ria, mas marcada como imut√°vel.  √â dif√≠cil dizer o que √© mais r√°pido: aumentar o n√∫mero de links para um objeto ou criar um link para uma √°rea na mem√≥ria com a falta da capacidade de alter√°-lo.  Vamos verificar na pr√°tica: <br><br><img src="https://habrastorage.org/webt/me/i5/2g/mei52ghwjxv_pg3c1toaoqachty.png"><br>  <i>Fig.</i>  <i>1: Compara√ß√£o de obter uma vari√°vel de matrizes com base em estruturas e classes</i> <br><br><h4>  Teste 2. Compara√ß√£o ContiguousArray vs Array </h4><br>  O mais interessante √© comparar o desempenho de uma matriz (Matriz) com uma matriz de refer√™ncia (ContiguousArray), necess√°ria especificamente para trabalhar com as classes armazenadas na matriz. <br><br>  Vamos verificar o desempenho para os seguintes casos: <br><br>  ContiguousArray armazenando uma estrutura com o tipo de valor <br>  ContiguousArray armazenando struct com String <br>  ContiguousArray armazenando classe com tipo de valor <br>  ContiguousArray armazenando classe com String <br>  Matriz armazenando struct com tipo de valor <br>  Matriz armazenando struct com String <br>  Matriz armazenando classe com tipo de valor <br>  Matriz armazenando classe com String <br><br>  Como os resultados do teste (testes: passando para uma fun√ß√£o com otimiza√ß√£o embutida desativada, passando para uma fun√ß√£o com otimiza√ß√£o embutida ativada, excluindo elementos, adicionando elementos, acesso seq√ºencial a um elemento em um loop) incluir√£o um grande n√∫mero de testes (para 8 matrizes de 5 testes cada) , Darei os resultados mais significativos: <br><br><ol><li>  Se voc√™ chamar uma fun√ß√£o e passar uma matriz para ela, desativando a linha, essa chamada ser√° muito cara (para classes baseadas na String de refer√™ncia, √© 20.000 vezes mais lenta, para classes baseadas em Value, o tipo √© 60.000 vezes, pior com o otimizador embutido desativado) . </li><li>  Se a otimiza√ß√£o (em linha) funcionar para voc√™, a degrada√ß√£o deve ser esperada apenas 2 vezes, dependendo do tipo de dados adicionado a qual matriz.  A √∫nica exce√ß√£o foi o tipo de valor, envolto em uma estrutura localizada no ContiguousArray - sem degrada√ß√£o do tempo. </li><li>  Remo√ß√£o - a diferen√ßa entre a matriz de refer√™ncia e a usual era de cerca de 20% (a favor da matriz usual). </li><li>  Anexar - ao usar objetos agrupados em classes, o ContiguousArray tinha uma velocidade cerca de 20% mais r√°pida que o Array com os mesmos objetos, enquanto o Array era mais r√°pido ao trabalhar com estruturas do que o ContiguousArray com estruturas. </li><li>  O acesso aos elementos da matriz ao usar wrappers de estruturas acabou sendo mais r√°pido do que qualquer wrapper nas classes, incluindo o ContiguousArray (cerca de 500 vezes mais r√°pido). </li></ol><br>  Na maioria dos casos, o uso de matrizes regulares para trabalhar com objetos √© mais eficiente.  Usado antes, usamos mais. <br><br>  A otimiza√ß√£o do loop para matrizes √© atendida pelo inicializador de cole√ß√£o lenta, que permite percorrer toda a matriz apenas uma vez, mesmo se voc√™ usar v√°rios filtros ou mapas sobre os elementos da matriz. <br><br>  Ao usar estruturas como uma ferramenta de otimiza√ß√£o, existem armadilhas, como o uso de tipos que s√£o internamente referenciados na natureza: seq√º√™ncias de caracteres, dicion√°rios, matrizes de refer√™ncia.  Ent√£o, quando uma vari√°vel que armazena um tipo de refer√™ncia em si √© inserida em uma fun√ß√£o, uma refer√™ncia adicional √© criada para cada elemento que √© uma classe.  Isso tem outro lado, sobre isso um pouco mais.  Voc√™ pode tentar usar uma classe de wrapper sobre uma vari√°vel.  Em seguida, o n√∫mero de links ao passar para a fun√ß√£o aumentar√° apenas para ela, e o n√∫mero de links para valores dentro da estrutura permanecer√° o mesmo.  Em geral, quero ver quantas vari√°veis ‚Äã‚Äãde um tipo de refer√™ncia devem estar na estrutura para que seu desempenho diminua mais que o desempenho de classes com os mesmos par√¢metros.  Existe um artigo na web chamado ‚ÄúPare de usar estruturas!‚Äù, Que faz a mesma pergunta e a responde.  Baixei o projeto e decidi descobrir o que acontece onde e em que casos temos estruturas lentas.  O autor mostra o baixo desempenho das estruturas em compara√ß√£o com as classes, argumentando que criar um novo objeto √© muito mais lento do que aumentar a refer√™ncia ao objeto √© um absurdo (ent√£o removi a linha em que um novo objeto √© criado no loop todas as vezes).  Mas se n√£o criarmos um link para o objeto, mas simplesmente pass√°-lo para uma fun√ß√£o para trabalhar com ele, a diferen√ßa de desempenho ser√° muito insignificante.  Cada vez que colocamos em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">linha</a> (nunca) uma fun√ß√£o, nosso aplicativo deve execut√°-la e n√£o criar c√≥digo em uma string.  A julgar pelos testes, a Apple fez com que o objeto passado para a fun√ß√£o fosse ligeiramente modificado. Para estruturas, o compilador altera a mutabilidade e torna o acesso a propriedades n√£o mut√°veis ‚Äã‚Äãdo objeto pregui√ßosamente.  Algo semelhante acontece na classe, mas ao mesmo tempo aumenta o n√∫mero de refer√™ncias ao objeto.  E agora temos um objeto lento, todos os seus campos tamb√©m s√£o pregui√ßosos e toda vez que chamamos uma vari√°vel de objeto, ela √© inicializada.  Nisso, as estruturas n√£o t√™m igual: quando uma fun√ß√£o chama duas vari√°veis, a estrutura do objeto √© apenas ligeiramente inferior √† classe em velocidade;  quando voc√™ liga para tr√™s ou mais, a estrutura sempre ser√° mais r√°pida. <br><br><h4>  Teste 3: Compare o desempenho de Estruturas e Classes armazenando grandes classes </h4><br>  Al√©m disso, mudei levemente o pr√≥prio m√©todo, que foi chamado quando outra vari√°vel foi adicionada (dessa forma, tr√™s vari√°veis ‚Äã‚Äãforam inicializadas no m√©todo, e n√£o duas, como no artigo), e que n√£o haveria um estouro de Int, substitu√≠ as opera√ß√µes nas vari√°veis ‚Äã‚Äãpela soma e subtra√ß√£o.  Adicionadas m√©tricas de tempo mais claras (na captura de tela s√£o segundos, mas n√£o √© t√£o importante para n√≥s, √© importante entender as propor√ß√µes resultantes), removendo a estrutura de Darwin (n√£o uso em projetos, talvez em v√£o, n√£o h√° diferen√ßas nos testes antes / depois de adicionar a estrutura em meu teste), a inclus√£o da otimiza√ß√£o m√°xima e do build no release (parece que isso ser√° mais honesto), e aqui est√° o resultado: <br><br><img src="https://habrastorage.org/webt/zv/q_/en/zvq_ens-bwgnuetcl53shkecjd0.png"><br>  <i>Fig.</i>  <i>2: Desempenho de estruturas e classes do artigo "Pare de usar estruturas"</i> <br><br>  As diferen√ßas nos resultados dos testes s√£o insignificantes. <br><br><h4>  Teste 4: Fun√ß√£o que aceita gen√©rico, protocolo e fun√ß√£o sem gen√©rico </h4><br>  Se pegarmos uma fun√ß√£o gen√©rica e passarmos dois valores para l√°, unidos apenas pela capacidade de comparar esses valores (func min), o c√≥digo de tr√™s linhas se transformar√° no c√≥digo de oito (como a Apple diz).  Mas nem sempre √© esse o caso, o Xcode possui m√©todos de otimiza√ß√£o nos quais, se, ao chamar uma fun√ß√£o, v√™ que dois valores estruturais s√£o passados ‚Äã‚Äãpara ela, gera automaticamente uma fun√ß√£o que utiliza duas estruturas e n√£o copia mais os valores. <br><br><img src="https://habrastorage.org/webt/zo/fd/2v/zofd2v5qz7q3dkhzdcp_srpspyg.png"><br>  <i>Fig.</i>  <i>3: Fun√ß√£o Gen√©rica T√≠pica</i> <br><br>  Eu decidi testar duas fun√ß√µes: na primeira, o tipo de dados gen√©rico √© declarado, a segunda aceita apenas protocolo.  Na nova vers√£o do Protocolo Swift 5.1, √© um pouco mais r√°pido que o Gen√©rico (antes do Swift 5.1 os protocolos eram 2 vezes mais lentos), embora de acordo com a Apple deva ser o contr√°rio, mas quando se trata de passar por uma matriz, j√° precisamos digitar, o que diminui a velocidade Gen√©ricos (mas ainda s√£o √≥timos, porque s√£o mais r√°pidos que os protocolos): <br><br><img src="https://habrastorage.org/webt/k-/ox/vr/k-oxvrhsx5mbw_osj7azkzu9x7y.png"><br>  <i>Fig.</i>  <i>4: Compara√ß√£o de fun√ß√µes de host gen√©rico e de protocolo.</i> <br><br><h4>  Teste 5: compare a chamada do m√©todo pai e a nativa e, ao mesmo tempo, verifique a classe final para essa chamada </h4><br>  O que sempre me interessou √© o qu√£o lentamente as aulas trabalham com um grande n√∫mero de pais, a rapidez com que uma classe chama suas fun√ß√µes e as de um pai.  Nos casos em que estamos tentando chamar um m√©todo que leva uma classe, o despacho din√¢mico entra em jogo.  O que √© isso  Toda vez que um m√©todo ou vari√°vel √© chamado dentro de nossa fun√ß√£o, uma mensagem √© gerada solicitando ao objeto essa vari√°vel ou m√©todo.  O objeto, recebendo essa solicita√ß√£o, come√ßa a procurar o m√©todo na tabela de despacho de sua classe e, se uma substitui√ß√£o do m√©todo ou vari√°vel foi chamada, pega e retorna, ou alcan√ßa recursivamente a classe base. <br><br><img src="https://habrastorage.org/webt/tr/wz/i-/trwzi-l8v51yv4oftdl33a-30z4.png"><br>  <i>Fig.</i>  <i>5: Chamadas de m√©todo de classe, para teste de despacho</i> <br><br>  V√°rias conclus√µes podem ser tiradas do teste acima: quanto maior a classe de classes pai, mais lenta ela funcionar√° e que a diferen√ßa de velocidade √© t√£o pequena que pode ser negligenciada com seguran√ßa, a otimiza√ß√£o de c√≥digo mais prov√°vel far√° com que n√£o haja diferen√ßa de velocidade.  Neste exemplo, o modificador de classe final n√£o tem uma vantagem, pelo contr√°rio, o trabalho da classe √© ainda mais lento, possivelmente devido ao fato de n√£o se tornar uma fun√ß√£o realmente r√°pida. <br><br><h4>  Teste 6: Chamando uma vari√°vel com modificador final em rela√ß√£o a uma vari√°vel de classe regular </h4><br>  Tamb√©m com resultados muito interessantes ao atribuir o modificador final a uma vari√°vel, voc√™ pode us√°-lo quando tiver certeza de que a vari√°vel n√£o ser√° reescrita em nenhum lugar nos herdeiros da classe.  Vamos tentar colocar o modificador final em uma vari√°vel.  Se em nosso teste criamos apenas uma vari√°vel e chamamos uma propriedade nela, ela seria inicializada uma vez (o resultado √© a seguir).  Se honestamente criarmos cada vez que um novo objeto e solicitar sua vari√°vel, a velocidade diminuir√° visivelmente (o resultado est√° acima): <br><br><img src="https://habrastorage.org/webt/ef/t7/d7/eft7d7u2wpc4htxcas5tiffnari.png"><br>  <i>Fig.</i>  <i>6: Chamar vari√°vel final</i> <br><br>  Obviamente, o modificador n√£o foi para o benef√≠cio da vari√°vel e √© sempre mais lento que seu concorrente. <br><br><h4>  Teste 7: Problema de polimorfismo e protocolos para estruturas.  Ou o desempenho de um cont√™iner existente </h4><br>  Problema: se usarmos um protocolo que suporta um determinado m√©todo e v√°rias estruturas herdadas desse protocolo, o que o nosso compilador pensar√° quando colocarmos estruturas com diferentes volumes de valores armazenados em uma matriz, unidos pelo protocolo original? <br><br>  Para resolver o problema de chamar um m√©todo predefinido nos herdeiros, √© usado o mecanismo da Tabela de Testemunhas de Protocolo.  Ele cria estruturas de shell que fazem refer√™ncia aos m√©todos necess√°rios. <br><br>  Para resolver o problema do armazenamento de dados, √© usado um cont√™iner existencial.  Ele armazena em si 5 c√©lulas de informa√ß√£o, cada uma com 8 bytes.  Nos tr√™s primeiros, o espa√ßo √© alocado para os dados armazenados na estrutura (se eles n√£o couberem, cria um link para o heap no qual os dados s√£o armazenados), o quarto armazena informa√ß√µes sobre os tipos de dados que s√£o usados ‚Äã‚Äãna estrutura e nos informa como gerenciar esses dados. , o quinto cont√©m refer√™ncias aos m√©todos do objeto. <br><br><img src="https://habrastorage.org/webt/jh/tu/6c/jhtu6cgi7hcnllrybgfphk9gx-i.png"><br>  <i>Figura 7. Compara√ß√£o do desempenho de uma matriz que cria um link para um objeto e que o cont√©m</i> <br><br>  Entre o primeiro e o segundo resultado, o n√∫mero de vari√°veis ‚Äã‚Äãtriplicou.  Em teoria, eles devem ser colocados em um cont√™iner, s√£o armazenados nesse cont√™iner e a diferen√ßa de velocidade √© devida ao volume da estrutura.  Curiosamente, se voc√™ reduzir o n√∫mero de vari√°veis ‚Äã‚Äãna segunda estrutura, o tempo de opera√ß√£o n√£o ser√° alterado, ou seja, o cont√™iner armazenar√° 3 ou 2 vari√°veis, mas, aparentemente, existem condi√ß√µes especiais para uma vari√°vel que aumentam significativamente a velocidade.  A segunda estrutura se encaixa perfeitamente no cont√™iner e difere do volume da terceira pela metade, o que gera uma forte degrada√ß√£o no tempo de execu√ß√£o, em compara√ß√£o com outras estruturas. <br><br><h4>  Um pouco de teoria para otimizar seus projetos </h4><br>  Os seguintes fatores podem influenciar o desempenho das estruturas: <br><br><ul><li>  onde suas vari√°veis ‚Äã‚Äãs√£o armazenadas (heap / stack); </li><li>  a necessidade de contagem de refer√™ncia para propriedades; </li><li>  m√©todos de agendamento (est√°tico / din√¢mico); </li><li>  O Copy-On-Write √© usado apenas por estruturas de dados que s√£o tipos de refer√™ncia que pretendem ser estruturas (String, Matriz, Conjunto, Dicion√°rio) sob o cap√¥. </li></ul><br>  Vale esclarecer imediatamente que o mais r√°pido de todos ser√£o os objetos que armazenam propriedades na pilha, n√£o usam contagem de refer√™ncia com o m√©todo est√°tico de exame m√©dico. <br><h4>  Do que as classes s√£o ruins e perigosas em compara√ß√£o com estruturas </h4><br><br>  Nem sempre controlamos a c√≥pia de nossos objetos e, se fizermos isso, podemos obter muitas c√≥pias que ser√£o dif√≠ceis de gerenciar (criamos objetos no projeto que s√£o respons√°veis ‚Äã‚Äãpor formar a exibi√ß√£o, por exemplo). <br><br>  Eles n√£o s√£o t√£o r√°pidos quanto estruturas. <br><br>  Se tivermos um link para um objeto e estivermos tentando gerenciar nosso aplicativo em um estilo multithread, podemos obter a Condi√ß√£o de Corrida quando nosso objeto for usado em dois lugares diferentes (o que n√£o √© t√£o dif√≠cil, porque um projeto criado com o Xcode √© sempre um pouco mais lento, que a vers√£o Store). <br><br>  Se tentarmos evitar a Condi√ß√£o de Corrida, gastamos muitos recursos no Lock e em nossos dados, que come√ßam a consumir recursos e desperdi√ßar tempo em vez de processamento r√°pido e obtemos objetos ainda mais lentos que os mesmos constru√≠dos em estruturas. <br><br>  Se fizermos todas as a√ß√µes acima em nossos objetos (links), a probabilidade de conflitos imprevistos √© alta. <br><br>  A complexidade do c√≥digo est√° aumentando por causa disso. <br><br>  Mais c√≥digo = mais bugs, sempre! <br><br><h4>  Conclus√µes </h4><br>  Eu pensei que as conclus√µes deste artigo s√£o simplesmente necess√°rias, porque eu n√£o quero ler o artigo de tempos em tempos, e uma lista consolidada de pontos √© simplesmente necess√°ria.  Resumindo as linhas sob os testes, quero destacar o seguinte: <br><br><ol><li>  As matrizes s√£o melhor colocadas em uma matriz. </li><li>  Se voc√™ deseja criar uma matriz a partir de classes, √© melhor escolher uma matriz regular, pois o ContiguousArray raramente oferece vantagens e elas n√£o s√£o muito altas. </li><li>  A otimiza√ß√£o em linha acelera o trabalho, n√£o o desative. </li><li>  O acesso aos elementos Array √© sempre mais r√°pido que o acesso aos elementos ContiguousArray. </li><li>  As estruturas s√£o sempre mais r√°pidas que as classes (a menos que voc√™ ative a otimiza√ß√£o do m√≥dulo inteiro ou otimiza√ß√£o semelhante). </li><li>  Ao passar um objeto para uma fun√ß√£o e chamar suas propriedades, a partir do terceiro, a estrutura √© mais r√°pida que as classes. </li><li>  Quando voc√™ passa um valor para uma fun√ß√£o escrita para Gen√©rico e Protocolo, o Gen√©rico √© mais r√°pido. </li><li>  Com heran√ßa de v√°rias classes, a velocidade da chamada de fun√ß√£o diminui. </li><li>  As vari√°veis ‚Äã‚Äãmarcaram o trabalho final mais lentamente do que os piment√µes comuns. </li><li>  Se uma fun√ß√£o aceitar um objeto que combine v√°rios objetos com o protocolo, ela funcionar√° rapidamente se apenas uma propriedade estiver armazenada nela e se degradar√° bastante ao adicionar mais propriedades. </li></ol><br>  Refer√™ncias: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">medium.com/@vhart/protocols-generics-and-existential-containers-wait-what-e2e698262ab1</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">developer.apple.com/videos/play/wwdc2016/416</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">developer.apple.com/videos/play/wwdc2015/409</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">developer.apple.com/videos/play/wwdc2016/419</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">medium.com/commencis/stop-using-structs-e1be9a86376f</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C√≥digo fonte do teste</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472290/">https://habr.com/ru/post/pt472290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472272/index.html">Um novo jogo com uma atmosfera antiga no Three.js. Parte 2</a></li>
<li><a href="../pt472274/index.html">SSH remoto: dicas e hacks</a></li>
<li><a href="../pt472278/index.html">Meu commit git favorito</a></li>
<li><a href="../pt472280/index.html">A tarefa de determinar a presen√ßa de uma palma em um scanner de veias</a></li>
<li><a href="../pt472288/index.html">9 extens√µes √∫teis de navegador para desenvolvedores (lista para 2020)</a></li>
<li><a href="../pt472292/index.html">Bloqueio de conte√∫do: o cen√°rio mundial</a></li>
<li><a href="../pt472294/index.html">Crie jogos e v√≠deos no YouTube. Meu experimento de intera√ß√£o e a receita desse</a></li>
<li><a href="../pt472296/index.html">Sistema de prote√ß√£o contra vazamentos para uma m√°quina de lavar</a></li>
<li><a href="../pt472298/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 385 (14 a 20 de outubro de 2019)</a></li>
<li><a href="../pt472300/index.html">Descida de gradiente estoc√°stico (SGD) para a fun√ß√£o de perda logar√≠tmica (LogLoss) em um problema de classifica√ß√£o bin√°ria</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>