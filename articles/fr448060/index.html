<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💽 📜 🧑🏼‍🤝‍🧑🏼 Écriture d'un client NTP simple 🧑🏽‍🤝‍🧑🏼 🤪 🖐🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, habrayuzery. Aujourd'hui, je veux parler de la façon d'écrire mon simple client NTP. Fondamentalement, nous parlerons de la structure du paqu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Écriture d'un client NTP simple</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448060/"> Bonjour, habrayuzery.  Aujourd'hui, je veux parler de la façon d'écrire mon simple client NTP.  Fondamentalement, nous parlerons de la structure du paquet et de la façon de traiter la réponse du serveur NTP.  Le code sera écrit en python, car, il me semble, le meilleur langage pour de telles choses ne peut tout simplement pas être trouvé.  Les connaisseurs feront attention à la similitude du code avec le code ntplib - je m'en suis «inspiré». <br><a name="habracut"></a><br>  Alors, quel est exactement NTP?  NTP - protocole d'interaction avec des serveurs de temps exacts.  Ce protocole est utilisé dans de nombreuses machines modernes.  <i>Par exemple, le service w32tm dans Windows.</i> <br><br>  Il existe 5 versions du protocole NTP au total.  La première, la 0e version (1985, RFC958)) est actuellement considérée comme obsolète.  Maintenant, les plus récents sont utilisés, 1er (1988, RFC1059), 2e (1989, RFC1119), 3e (1992, RFC1305) et 4e (1996, RFC2030).  Les versions 1-4 sont compatibles les unes avec les autres, elles ne diffèrent que par les algorithmes de fonctionnement du serveur. <br><br><h3>  Format du paquet </h3><br><img src="https://habrastorage.org/webt/fq/il/6l/fqil6lihcd8xozi7v2z7sbylrbm.png"><br><br>  <b>Indicateur de saut</b> ( <b>indicateur de</b> correction) - un nombre indiquant un avertissement concernant la deuxième coordination.  Valeur: <br><br><ul><li>  0 - aucune correction </li><li>  1 - la dernière minute de la journée contient 61 secondes </li><li>  2 - la dernière minute de la journée contient 59 secondes </li><li>  3 - dysfonctionnement du serveur (heure non synchronisée) </li></ul><br>  <b>Numéro de version</b> - Le numéro de version du protocole NTP (1-4). <br><br>  <b>Mode</b> - mode de fonctionnement de l'expéditeur de paquets.  Valeur de 0 à 7, la plus courante: <br><br><ul><li>  3 - client </li><li>  4 - serveur </li><li>  5 - mode de diffusion </li></ul><br>  <b>Strate</b> (niveau de superposition) - le nombre de couches intermédiaires entre le serveur et l'horloge de référence (1 - le serveur prend les données directement de l'horloge de référence, 2 - le serveur prend les données du serveur avec le niveau 1, etc.). <br>  <b>Poll</b> est un entier signé représentant l'intervalle maximum entre les messages consécutifs.  Ici, le client NTP indique l'intervalle auquel il s'attend à interroger le serveur et le serveur NTP indique l'intervalle auquel il s'attend à être interrogé.  La valeur est le logarithme binaire des secondes. <br>  <b>La précision</b> est un entier signé représentant la précision de l'horloge système.  La valeur est le logarithme binaire des secondes. <br>  <b>Délai racine</b> ( <b>délai du</b> serveur) - le temps pendant lequel l'horloge atteint le serveur NTP, comme le nombre de secondes avec un point fixe. <br>  <b>Dispersion racine</b> - la dispersion de l'horloge du serveur NTP en nombre de secondes avec un point fixe. <br>  <b>Ref id</b> (identifiant source) - id de la montre.  Si le serveur a une strate de 1, alors ref id est le nom de l'horloge atomique (4 caractères ASCII).  Si le serveur utilise un autre serveur, l'adresse de ce serveur est écrite dans l'ID de référence. <br>  Les 4 derniers champs sont le temps - 32 bits - la partie entière, 32 bits - la partie fractionnaire. <br>  <b>Référence</b> - la dernière horloge du serveur. <br>  <b>Originate</b> - l'heure à laquelle le paquet a été envoyé (rempli par le serveur - plus de détails ci-dessous). <br>  <b>Receive</b> - heure à laquelle le paquet a été reçu par le serveur. <br>  <b>Transmit</b> - heure à laquelle le paquet a été envoyé du serveur au client (rempli par le client, plus à ce sujet ci-dessous). <br><br>  Nous ne considérerons pas les deux derniers champs. <br><br>  Écrivons notre package: <br><br><div class="spoiler">  <b class="spoiler_title">Code du package</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NTPPacket</span></span></span><span class="hljs-class">:</span></span> _FORMAT = <span class="hljs-string"><span class="hljs-string">"!BB bb 11I"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, version_number=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, mode=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">, transmit=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Necessary of enter leap second (2 bits) self.leap_indicator = 0 # Version of protocol (3 bits) self.version_number = version_number # Mode of sender (3 bits) self.mode = mode # The level of "layering" reading time (1 byte) self.stratum = 0 # Interval between requests (1 byte) self.pool = 0 # Precision (log2) (1 byte) self.precision = 0 # Interval for the clock reach NTP server (4 bytes) self.root_delay = 0 # Scatter the clock NTP-server (4 bytes) self.root_dispersion = 0 # Indicator of clocks (4 bytes) self.ref_id = 0 # Last update time on server (8 bytes) self.reference = 0 # Time of sending packet from local machine (8 bytes) self.originate = 0 # Time of receipt on server (8 bytes) self.receive = 0 # Time of sending answer from server (8 bytes) self.transmit = transmit</span></span></code> </pre> <br></div></div><br>  Pour envoyer (et recevoir) un paquet au serveur, nous devons être en mesure de le transformer en un tableau d'octets. <br>  Pour cette opération (et inversée), nous allons écrire deux fonctions - pack () et unpack (): <br><br><div class="spoiler">  <b class="spoiler_title">Fonction Pack</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct.pack(NTPPacket._FORMAT, (self.leap_indicator &lt;&lt; <span class="hljs-number"><span class="hljs-number">6</span></span>) + (self.version_number &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) + self.mode, self.stratum, self.pool, self.precision, int(self.root_delay) + get_fraction(self.root_delay, <span class="hljs-number"><span class="hljs-number">16</span></span>), int(self.root_dispersion) + get_fraction(self.root_dispersion, <span class="hljs-number"><span class="hljs-number">16</span></span>), self.ref_id, int(self.reference), get_fraction(self.reference, <span class="hljs-number"><span class="hljs-number">32</span></span>), int(self.originate), get_fraction(self.originate, <span class="hljs-number"><span class="hljs-number">32</span></span>), int(self.receive), get_fraction(self.receive, <span class="hljs-number"><span class="hljs-number">32</span></span>), int(self.transmit), get_fraction(self.transmit, <span class="hljs-number"><span class="hljs-number">32</span></span>))</code> </pre><br></div></div><br>  Pour sélectionner la partie fractionnaire du nombre à écrire dans le package, nous avons besoin de la fonction get_fraction (): <br><div class="spoiler">  <b class="spoiler_title">get_fraction ()</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_fraction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number, precision)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> int((number - int(number)) * <span class="hljs-number"><span class="hljs-number">2</span></span> ** precision)</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Fonction de déballage</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, data: bytes)</span></span></span><span class="hljs-function">:</span></span> unpacked_data = struct.unpack(NTPPacket._FORMAT, data) self.leap_indicator = unpacked_data[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;&gt; <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-comment"><span class="hljs-comment"># 2 bits self.version_number = unpacked_data[0] &gt;&gt; 3 &amp; 0b111 # 3 bits self.mode = unpacked_data[0] &amp; 0b111 # 3 bits self.stratum = unpacked_data[1] # 1 byte self.pool = unpacked_data[2] # 1 byte self.precision = unpacked_data[3] # 1 byte # 2 bytes | 2 bytes self.root_delay = (unpacked_data[4] &gt;&gt; 16) + \ (unpacked_data[4] &amp; 0xFFFF) / 2 ** 16 # 2 bytes | 2 bytes self.root_dispersion = (unpacked_data[5] &gt;&gt; 16) + \ (unpacked_data[5] &amp; 0xFFFF) / 2 ** 16 # 4 bytes self.ref_id = str((unpacked_data[6] &gt;&gt; 24) &amp; 0xFF) + " " + \ str((unpacked_data[6] &gt;&gt; 16) &amp; 0xFF) + " " + \ str((unpacked_data[6] &gt;&gt; 8) &amp; 0xFF) + " " + \ str(unpacked_data[6] &amp; 0xFF) self.reference = unpacked_data[7] + unpacked_data[8] / 2 ** 32 # 8 bytes self.originate = unpacked_data[9] + unpacked_data[10] / 2 ** 32 # 8 bytes self.receive = unpacked_data[11] + unpacked_data[12] / 2 ** 32 # 8 bytes self.transmit = unpacked_data[13] + unpacked_data[14] / 2 ** 32 # 8 bytes return self</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pour les paresseux, comme une application - un code qui transforme un package en une belle chaîne</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Leap indicator: {0.leap_indicator}\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">"Version number: {0.version_number}\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">"Mode: {0.mode}\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">"Stratum: {0.stratum}\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">"Pool: {0.pool}\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">"Precision: {0.precision}\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">"Root delay: {0.root_delay}\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">"Root dispersion: {0.root_dispersion}\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">"Ref id: {0.ref_id}\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">"Reference: {0.reference}\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">"Originate: {0.originate}\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">"Receive: {0.receive}\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">"Transmit: {0.transmit}"</span></span>\ .format(self)</code> </pre><br></div></div><br><h3>  Envoi d'un paquet au serveur </h3><br>  Il est nécessaire d'envoyer un paquet au serveur avec les champs <b>Version</b> , <b>Mode</b> et <b>Transmit</b> remplis.  Dans <b>Transmit,</b> vous devez spécifier l'heure actuelle sur la machine locale (nombre de secondes depuis le 1er janvier 1900), version - 1 à 4, mode - 3 (mode client). <br><br>  Après avoir accepté la demande, le serveur remplit tous les champs du paquet NTP en copiant la valeur de <b>transmission</b> de la demande dans le champ <b>Originate</b> .  C'est un mystère pour moi que le client ne puisse pas saisir immédiatement la valeur de son temps dans le champ <b>Originate</b> .  Par conséquent, lorsque le paquet revient, le client dispose de 4 fois - l'heure à laquelle la demande a été envoyée ( <b>origine</b> ), l'heure à laquelle le serveur a reçu la demande ( <b>réception</b> ), l'heure à laquelle le serveur a envoyé la réponse ( <b>transmission</b> ) et l'heure à laquelle le client a reçu la réponse - à l' <b>arrivée</b> (pas dans le paquet).  En utilisant ces valeurs, nous pouvons définir l'heure correcte. <br><br><div class="spoiler">  <b class="spoiler_title">Envoi et réception de colis</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Time difference between 1970 and 1900, seconds FORMAT_DIFF = (datetime.date(1970, 1, 1) - datetime.date(1900, 1, 1)).days * 24 * 3600 # Waiting time for recv (seconds) WAITING_TIME = 5 server = "pool.ntp.org" port = 123 packet = NTPPacket(version_number=2, mode=3, transmit=time.time() + FORMAT_DIFF) answer = NTPPacket() with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s: s.settimeout(WAITING_TIME) s.sendto(packet.pack(), (server, port)) data = s.recv(48) arrive_time = time.time() + FORMAT_DIFF answer.unpack(data)</span></span></code> </pre><br></div></div><br><h3>  Traitement des données du serveur </h3><br>  Le traitement des données du serveur est similaire aux actions du gentleman anglais de l'ancienne tâche de Raymond M. Sullian (1978): «Une personne n'avait pas de montre, mais d'autre part il y avait une horloge murale exacte qu'il oubliait parfois de démarrer.  Une fois, ayant oublié de redémarrer la montre, il est allé rendre visite à son ami, a passé la soirée à cet endroit, et quand il est rentré chez lui, il a réussi à régler correctement l'horloge.  Comment a-t-il réussi à faire cela si le temps de trajet n'était pas connu à l'avance?  La réponse est: «En quittant la maison, une personne démarre la montre et se souvient de la position des aiguilles.  Venant chez un ami et quittant les invités, il note l'heure de son arrivée et de son départ.  Cela lui permet de savoir combien il visitait.  De retour chez elle et en regardant la montre, une personne détermine la durée de son absence.  Soustrayant de ce temps le temps qu'il a passé en visite, une personne apprend le temps passé sur le trajet aller-retour.  Ayant ajouté la moitié du temps consacré au voyage au moment de quitter les invités, il a la possibilité de connaître l'heure d'arrivée à la maison et de traduire les aiguilles de l'horloge en conséquence. » <br><br>  On retrouve le temps de travail du serveur sur demande: <br><br><ol><li>  Nous trouvons le temps de chemin du paquet du client au serveur: <i>((Arrive - Originate) - (Transmit - Receive)) / 2</i> </li><li>  Trouvez la différence entre l'heure du client et celle du serveur: <br>  <i>Recevoir - Émettre - ((Arriver - Émettre) - (Transmettre - Recevoir)) / 2 =</i> <i><br></i>  <i>2 * Réception - 2 * Origine - Arrivée + Origine + Transmission - Réception =</i> <i><br></i>  <i>Recevoir - Émettre - Arriver + Transmettre</i> </li></ol><br>  Ajoutez la valeur obtenue à l'heure locale et profitez de la vie. <br><br><div class="spoiler">  <b class="spoiler_title">Résultat de sortie</b> <div class="spoiler_text"><pre> <code class="python hljs">time_different = answer.get_time_different(arrive_time) result = <span class="hljs-string"><span class="hljs-string">"Time difference: {}\nServer time: {}\n{}"</span></span>.format( time_different, datetime.datetime.fromtimestamp(time.time() + time_different).strftime(<span class="hljs-string"><span class="hljs-string">"%c"</span></span>), answer.to_display()) print(result)</code> </pre><br></div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien</a> utile. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448060/">https://habr.com/ru/post/fr448060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448050/index.html">Holographie amateur - matériaux aux halogénures d'argent</a></li>
<li><a href="../fr448052/index.html">Mikrotik. VPN IPSEC pour NAT en tant que client</a></li>
<li><a href="../fr448054/index.html">SciPy, optimisation sous conditions</a></li>
<li><a href="../fr448056/index.html">Que sont les contrats intelligents?</a></li>
<li><a href="../fr448058/index.html">Développer un hexapode à partir de zéro (partie 5) - électronique</a></li>
<li><a href="../fr448068/index.html">Des scientifiques américains ont appris aux robots à utiliser des outils auxiliaires</a></li>
<li><a href="../fr448070/index.html">La substitution des importations dans la pratique. Partie 3. Systèmes d'exploitation</a></li>
<li><a href="../fr448072/index.html">La compréhension des jointures est rompue. Ce n'est certainement pas l'intersection de cercles, honnêtement</a></li>
<li><a href="../fr448074/index.html">ALU avec 12 transistors (en fait pas)</a></li>
<li><a href="../fr448076/index.html">Système de simulation simple Go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>