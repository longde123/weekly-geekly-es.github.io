<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêñ ü§∂üèæ üôéüèª A evolu√ß√£o de um √∫nico algoritmo üëÇ üòó ü¶è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√° algum tempo, meu colega me pediu para ajud√°-lo com um problema. Eu resolvi o problema para ele, mas al√©m disso, pareceu-me que, ao resolver esse pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A evolu√ß√£o de um √∫nico algoritmo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454850/"><p> H√° algum tempo, meu colega me pediu para ajud√°-lo com um problema.  Eu resolvi o problema para ele, mas al√©m disso, pareceu-me que, ao resolver esse problema, v√°rios algoritmos e t√©cnicas de programa√ß√£o podem ser explicados.  E tamb√©m mostra a acelera√ß√£o do tempo de execu√ß√£o do algoritmo de 25 segundos a 40 ms. </p><a name="habracut"></a><br><h1 id="postanovka-zadachi">  Declara√ß√£o do problema </h1><br><p>  Para um projeto pessoal, meu colega precisava de um algoritmo para encontrar cinquenta v√≠deos mais semelhantes para um determinado v√≠deo.  A similaridade deveria ser estimada pelo n√∫mero de tags expostas correspondentes.  Quanto mais tags o v√≠deo corresponder, mais semelhantes.  A partir disso, podemos tirar imediatamente v√°rias conclus√µes: </p><br><ul><li>  Todas as tags do v√≠deo podem ser combinadas em um grupo; </li><li>  Definitivamente, n√£o haver√° mais grupos do que os pr√≥prios v√≠deos; </li><li>  se o v√≠deo for semelhante a outro v√≠deo de um determinado grupo de tags, ser√° igualmente semelhante a outros v√≠deos desse grupo; </li></ul><br><p>  Acontece que basta trabalhar apenas com grupos de tags.  Na primeira vers√£o, um colega decidiu armazenar tags em uma tabela de tags: cada v√≠deo possui um link para o ID do grupo de tags e os pr√≥prios grupos s√£o uma sequ√™ncia de valores booleanos que indicam se a tag correspondente est√° definida.  Em C #, um grupo de tags fica assim: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br><p>  Um colega sugeriu que ele n√£o teria mais de um milh√£o de v√≠deos no site e mais de 4.000 tags diferentes. Para uma conta redonda, voc√™ pode usar 4096 = 2 ^ 12. <br>  Em seguida, a classe <code>TagsGroup</code> pode ser representada assim: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TagsGroupLength = <span class="hljs-number"><span class="hljs-number">4096</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } InnerTags = innerTags; } }</code> </pre> <br><p>  Agora voc√™ precisa verificar os dois grupos de tags quanto √† semelhan√ßa.  Nas condi√ß√µes atuais, isso se transforma em uma simples verifica√ß√£o de true nos elementos correspondentes das matrizes <code>InnerTags</code> de dois grupos de tags: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.InnerTags[i] &amp;&amp; a.InnerTags[i] == b.InnerTags[i]) result++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Agora resta apenas calcular a semelhan√ßa do grupo de tags desejado com cada grupo existente e selecionar os cinquenta mais semelhantes.  Estabeleci outra condi√ß√£o para garantir a estabilidade da amostra, ou seja,  na amostra final, haver√° cinquenta grupos de tags para os quais o <code>MeasureSimilarity</code> obteve o resultado mais alto, enquanto os grupos de tags com o mesmo <code>MeasureSimilarity</code> √≠ndice mais baixo para aqueles que tiveram um √≠ndice mais baixo no grupo existente original.  Mais detalhes podem ser encontrados, por exemplo, aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://ru.wikipedia.org/wiki/Sustainable_Sort</a> . <br>  Para resolver esse problema, decidi fazer a classe <code>SimilarTagsCalculator</code> , aqui est√° o c√≥digo: </p><br><div class="spoiler">  <b class="spoiler_title">SimilarTagsCalculator</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimilarTagsCalculator</span></span> { TagsGroup[] Groups { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimilarTagsCalculator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup[] groups</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (groups == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(groups)); Groups = groups; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroups</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-comment"><span class="hljs-comment">//,          var list = new List&lt;TagsSimilarityInfo&gt;(resultLength); //      for (int groupIndex = 0; groupIndex &lt; Groups.Length; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; //      int similarityValue = TagsGroup.MeasureSimilarity(value, tagsGroup); // -  TagsSimilarityInfo newInfo = new TagsSimilarityInfo(groupIndex, similarityValue); //    ,     , if (list.Count == resultLength &amp;&amp; list[resultLength - 1].CompareTo(newInfo) == -1) { continue; //     } //   ,    -  int index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); // if (list.Count &gt; resultLength) { //    , //   , ..    list.RemoveAt(resultLength); } } // -   TagsGroup[] result = new TagsGroup[resultLength]; for (int i = 0; i &lt; resultLength; i++) { result[i] = Groups[list[i].Index]; } return result; } }</span></span></code> </pre> </div></div><br><p>  e a estrutura <code>TagsSimilarityInfo</code> : </p><br><div class="spoiler">  <b class="spoiler_title">TagsSimilarityInfo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TagsSimilarityInfo : IComparable&lt;TagsSimilarityInfo&gt;, IComparable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Similarity { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsSimilarityInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> similarity</span></span></span><span class="hljs-function">)</span></span> { Index = index; Similarity = similarity; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsSimilarityInfo other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Index == other.Index &amp;&amp; Similarity == other.Similarity; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TagsSimilarityInfo other &amp;&amp; Equals(other); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">unchecked</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Index * <span class="hljs-number"><span class="hljs-number">397</span></span>) ^ Similarity; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsSimilarityInfo other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityComparison = other.Similarity.CompareTo(Similarity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> similarityComparison != <span class="hljs-number"><span class="hljs-number">0</span></span> ? similarityComparison : Index.CompareTo(other.Index); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ReferenceEquals(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, obj)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TagsSimilarityInfo other ? CompareTo(other) : <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">$"Object must be of type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">nameof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(TagsSimilarityInfo)}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> </div></div><br><p>  Eu preparei tr√™s benchmarks para esse algoritmo: </p><br><ul><li>  refer√™ncia completamente aleat√≥ria, ou seja,  o n√∫mero de tags definidas nos grupos √© aleat√≥rio e o grupo de tags com o qual compararemos tamb√©m √© aleat√≥rio; </li><li>  Se o n√∫mero de tags definidas em grupos estiver aumentando, compararemos com o grupo em que todas as tags est√£o definidas.  Acontece que alguns dos √∫ltimos grupos de tags devem ser os mais adequados; </li><li>  o mesmo que acima, mas o n√∫mero de tags expostas est√° diminuindo.  Os primeiros 50 grupos de tags ser√£o mais adequados; </li></ul><br><p>  Aqui est√£o os resultados de refer√™ncia para um milh√£o de grupos: </p><br><p>  BenchmarkDotNet = v0.11.5, OS = Windows 10.0.17134.765 (1803 / April2018Update / Redstone4) <br>  CPU Intel Core i7-6700 de 3,40 GHz (Skylake), 1 CPU, 8 n√∫cleos l√≥gicos e 4 f√≠sicos <br>  Frequ√™ncia = 3328126 Hz, Resolu√ß√£o = 300.4694 ns, Temporizador = TSC <br>  SDK do .NET Core = 3.0.100-preview5-011568 <br>  [Host]: .NET Core 3.0.0-preview5-27626-15 (CoreCLR 4.6.27622.75, CoreFX 4.700.19.22408), RyuJIT de 64 bits </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th><th>  Alocado </th></tr></thead><tbody><tr><td>  Randomtest </td><td>  25.054 s </td><td>  0.1786 s </td><td>  0,1670 s </td><td>  1,53 KB </td></tr><tr><td>  Ascendanttest </td><td>  4.180 s </td><td>  0,0174 s </td><td>  0,0162 s </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  4.147 s </td><td>  0,0118 s </td><td>  0,0104 s </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  O tempo de execu√ß√£o √© muito grande, al√©m de 25 segundos √© muito tempo, meu colega n√£o concorda em esperar tanto.  Ent√£o, vamos fazer otimiza√ß√µes.  Agora, existem tr√™s √°reas principais para acelerar o programa: </p><br><ul><li>  M√©todo <code>MeasureSimilarity</code> ; </li><li>  um algoritmo no corpo do loop em <code>GetFiftyMostSimilarGroups</code> ; </li><li>  o pr√≥prio loop em <code>GetFiftyMostSimilarGroups</code> ; </li></ul><br><p>  Vamos considerar cada uma das tr√™s dire√ß√µes em sequ√™ncia. </p><br><h1 id="predskazanie-vetvleniy">  Previs√£o de ramifica√ß√£o </h1><br><p>  Primeiro, considere o m√©todo <code>MeasureSimilarity</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.InnerTags[i] &amp;&amp; a.InnerTags[i] == b.InnerTags[i]) result++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  No benchmark anterior, houve uma varia√ß√£o muito grande no tempo de execu√ß√£o entre o teste aleat√≥rio e qualquer um dos sequenciais.  Os grupos de tags para testes sequenciais foram criados pelo seguinte princ√≠pio: </p><br><ul><li>  o n√∫mero necess√°rio de grupos foi dividido em pacotes.  N√∫mero de pacotes - o n√∫mero m√°ximo de tags no grupo; </li><li>  para cada grupo no i-√©simo pacote, as primeiras tags i foram definidas; </li></ul><br><p>  Acontece que cada grupo de tags nesses testes consiste em duas partes consecutivas de tags expostas e n√£o expostas.  <code>MeasureSimilarity</code> possui todos os pr√©-requisitos para que a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">previs√£o de ramifica√ß√£o</a> do processador tenha um efeito significativo nas condi√ß√µes atuais.  Para verificar isso, basta escrever uma refer√™ncia que compare o tempo de execu√ß√£o do MeasureSimilarity para dados aleat√≥rios e sequenciais: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSimilaritySum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup[] tagsGroups</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (TagsGroup tagsGroup <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tagsGroups) { result += TagsGroup.MeasureSimilarity(tagsGroup, etalon); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sorted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GetSimilaritySum(sortedGroups); [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsorted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GetSimilaritySum(unsortedGroups);</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Classificado </td><td>  3,704 s </td><td>  0,0411 s </td><td>  0,0364 s </td></tr><tr><td>  N√£o classificado </td><td>  8.211 s </td><td>  0,0381 s </td><td>  0,0338 s </td></tr></tbody></table></div><br><p>  Um milh√£o de grupos de tags foi testado, mas em <code>Sorted</code> em cada grupo, inicialmente, havia v√°rias tags expostas e depois n√£o expostas, e em <code>Unsorted</code> o mesmo n√∫mero de tags expostas foi espalhado aleatoriamente por todo o grupo. <br>  A diferen√ßa de 5 segundos √© impressionante, e algo precisa ser feito.  Para se livrar da influ√™ncia da previs√£o de ramifica√ß√£o e geralmente acelerar o m√©todo, voc√™ precisa se livrar das ramifica√ß√µes.  Existe apenas uma ramifica√ß√£o no <code>MeasureSimilarity</code> - verificando se as tags correspondentes est√£o definidas em dois grupos.  Vamos estimar em quais casos a condi√ß√£o ser√° verdadeira, para isso faremos uma tabela da verdade da condi√ß√£o: </p><br><div class="scrollable-table"><table><thead><tr><th>  a.InnerTags [i] </th><th>  b.InnerTags [i] </th><th>  Resultado </th></tr></thead><tbody><tr><td>  Falso </td><td>  Falso </td><td>  Falso </td></tr><tr><td>  Falso </td><td>  Verdadeiro </td><td>  Falso </td></tr><tr><td>  Verdadeiro </td><td>  Falso </td><td>  Falso </td></tr><tr><td>  Verdadeiro </td><td>  Verdadeiro </td><td>  Verdadeiro </td></tr></tbody></table></div><br><p>  A tabela verdade coincide completamente com o l√≥gico "AND", ou seja,  o resultado ser√° verdadeiro se, e somente se as duas tags forem verdadeiras, a condi√ß√£o poder√° ser reduzida para: <code>if (a.InnerTags[i] &amp;&amp; b.InnerTags[i])</code> .  Mas desta maneira a condi√ß√£o ainda permanece.  Na pr√≥xima etapa, garantiremos que a adi√ß√£o ao resultado seja sempre realizada, para isso reescrevemos o corpo do loop da seguinte maneira: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp;&amp; b.InnerTags[i] ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; result += t;</code> </pre> <br><p>  Ainda n√£o nos livramos da condi√ß√£o e at√© tornamos o m√©todo mais lento.  Mas agora ficou √≥bvio que, se o tipo de <code>InnerTags</code> alterado de bool para byte (1 para true e 0 para false), voc√™ poder√° se livrar da condi√ß√£o no operador tern√°rio.  Em seguida, a classe <code>TagsGroup</code> ficar√° assim: </p><br><div class="spoiler">  <b class="spoiler_title">TagsGrupo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TagsGroupLength = <span class="hljs-number"><span class="hljs-number">4096</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += t; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } InnerTags = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[TagsGroupLength]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { InnerTags[i] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (innerTags[i] ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); } } }</code> </pre> </div></div><br><p>  Aqui est√£o os resultados de refer√™ncia para o <code>MeasureSimilarity</code> atualizado: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Classificado </td><td>  3.180 s </td><td>  0,0118 s </td><td>  0,0111 s </td></tr><tr><td>  N√£o classificado </td><td>  3,236 s </td><td>  0,0622 s </td><td>  0,0764 s </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">foi:</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Classificado </td><td>  3,704 s </td><td>  0,0411 s </td><td>  0,0364 s </td></tr><tr><td>  N√£o classificado </td><td>  8.211 s </td><td>  0,0381 s </td><td>  0,0338 s </td></tr></tbody></table></div></div></div><br><p>  mas para o bechmark principal atualizado: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th><th>  Alocado </th></tr></thead><tbody><tr><td>  Randomtest </td><td>  3.219 s </td><td>  0,0492 s </td><td>  0,0436 s </td><td>  1,53 KB </td></tr><tr><td>  Ascendanttest </td><td>  3,222 s </td><td>  0,0117 s </td><td>  0,0110 s </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  3.422 s </td><td>  0,0697 s </td><td>  0,0999 s </td><td>  1,53 KB </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">foi:</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th><th>  Alocado </th></tr></thead><tbody><tr><td>  Randomtest </td><td>  25.054 s </td><td>  0.1786 s </td><td>  0,1670 s </td><td>  1,53 KB </td></tr><tr><td>  Ascendanttest </td><td>  4.180 s </td><td>  0,0174 s </td><td>  0,0162 s </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  4.147 s </td><td>  0,0118 s </td><td>  0,0104 s </td><td>  1,53 KB </td></tr></tbody></table></div></div></div><br><p>  Na minha opini√£o, j√° foi √≥timo.  Para aqueles que estavam convencidos de que toda a acelera√ß√£o aconteceu apenas porque o tipo booleano foi substitu√≠do por um byte, lancei uma refer√™ncia para esse corpo de loop: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == <span class="hljs-number"><span class="hljs-number">1</span></span>) result += t;</code> </pre> <br><p>  e estes s√£o os resultados: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Classificado </td><td>  3.760 s </td><td>  0,0746 s </td><td>  0.1541 s </td></tr><tr><td>  N√£o classificado </td><td>  8.628 s </td><td>  0,1699 s </td><td>  0,2382 s </td></tr></tbody></table></div><br><h1 id="upakovyvanie-dannyh">  Empacotamento de dados </h1><br><p>  Cada grupo possui muitas tags e seu n√∫mero n√£o pode ser reduzido de forma alguma.  Al√©m disso, voc√™ deve comparar as tags com o mesmo √≠ndice e n√£o pode dar uma resposta final sem verificar todas as tags.  Portanto, em qualquer caso, teremos que repetir todo o grupo de tags.  Seria √≥timo poder paralelizar essa tarefa de alguma forma, para que fosse poss√≠vel processar v√°rias tags em uma opera√ß√£o condicional.  Voc√™ pode fazer isso atrav√©s de paralelismo real ou atrav√©s de empacotamento de dados especiais, que usaremos.  Cada tag agora representa 1 ou 0. No <code>result</code> resultado da opera√ß√£o "AND" √© simplesmente acumulado.  Mas a mesma opera√ß√£o l√≥gica pode ser aplicada n√£o apenas aos n√∫meros de um bit.  O C # permite fazer isso sem problemas, com n√∫meros de at√© 64 bits (voc√™ pode fazer mais com o <code>BitArray</code> , mas n√£o √© isso).  Se representarmos dois grupos de tags como um conjunto de n√∫meros de 64 bits com o conjunto de bits correspondente, ser√° poss√≠vel executar uma opera√ß√£o "AND" em cada grupo de n√∫meros de 64 bits.  N√£o est√° claro o que fazer com o resultado.  Vamos olhar novamente para o corpo do loop: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += t;</code> </pre> <br><p>  o resultado aumenta em 1 toda vez que t == 1 e n√£o muda quando t == 0. Como resultado, o resultado ser√° igual a quantas vezes o resultado de <code>a.InnerTags[i] &amp; b.InnerTags[i]</code> era um.  Assim, seria poss√≠vel salvar todos os resultados de <code>a.InnerTags[i] &amp; b.InnerTags[i]</code> em algum tipo de matriz e, no resultado, gravar apenas o n√∫mero de unidades nessa matriz.  Ao executar a opera√ß√£o AND em mais de n√∫meros de n bits, um resultado de n bits ser√° e ser√° suficiente apenas para saber quantos bits s√£o definidos entre n.  O n√∫mero de bits definido no n√∫mero √© inalterado, o que significa que voc√™ pode contar esses n√∫meros.  N√£o faz sentido contar para 64 bits, pois  n√£o encontraremos tanta mem√≥ria RAM.  Para 32 bits, voc√™ j√° pode encontrar espa√ßo em computadores modernos, mas isso ainda √© muito.  N√£o √© dif√≠cil encontrar mem√≥ria com menos de 16 bits, mas o c√°lculo ser√° relativamente longo.  Como compromisso, vamos calcular n√∫meros de 8 bits: </p><br><div class="spoiler">  <b class="spoiler_title">GenerateCountOfSettedBits</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] CountOfSettedBits = GenerateCountOfSettedBits(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateCountOfSettedBits</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  result   i      i- . byte[] result = new byte[256]; //  ,      i   , //        int[] b = new int[8]; //     for (int i = 1; i &lt; 256; i++) { //       int settedBitsCount = 0; //,       int m = 1; //   for (int j = 0; j &lt; 8; j++) { //     b[j] += m; //  ,       2. m = b[j] &gt;&gt; 1; //        b[j] = b[j] &amp; 1; //,        settedBitsCount += b[j]; } result[i] = (byte) settedBitsCount; //   } return result; }</span></span></code> </pre> </div></div><br><p>  agora o construtor TagsGroup se parece com isso: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BucketSize = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    InnerTags = new byte[TagsGroupLength / BucketSize]; //   for (int i = 0; i &lt; TagsGroupLength / BucketSize; i++) { //     for (int j = 0; j &lt; BucketSize; j++, index++) { //    2,      InnerTags[i] &lt;&lt;= 1; //    InnerTags[i] += (byte) (innerTags[index] ? 1 : 0); } } }</span></span></code> </pre> <br><p>  E o <code>MeasureSimilarity</code> come√ßou a ficar assim: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += CountOfSettedBits[t]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Voc√™ pode executar uma grande refer√™ncia e garantir que tudo esteja melhor: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th><th>  Alocado </th></tr></thead><tbody><tr><td>  Randomtest </td><td>  560,5 ms </td><td>  8.285 ms </td><td>  7.344 ms </td><td>  1,53 KB </td></tr><tr><td>  Ascendanttest </td><td>  570,1 ms </td><td>  4,108 ms </td><td>  3,431 ms </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  608,1 ms </td><td>  5.691 ms </td><td>  5.324 ms </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  √â poss√≠vel tornar o m√©todo <code>MeasureSimilarity</code> ainda mais r√°pido?  Claro!  Para fazer isso, basta perceber o fato de que os registros de uso geral agora s√£o na sua maioria de 64 bits, e n√≥s direcionamos dados de oito bits neles.  Para fazer isso, aumente o tamanho do pacote no qual as tags originais s√£o empacotadas, aumente para 64 bits e reescreva os m√©todos necess√°rios: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BucketSize = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; BucketSize / <span class="hljs-number"><span class="hljs-number">8</span></span>; j++) { result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  e acontece: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th><th>  Alocado </th></tr></thead><tbody><tr><td>  Randomtest </td><td>  533,3 ms </td><td>  4,802 ms </td><td>  4,492 ms </td><td>  1,53 KB </td></tr><tr><td>  Ascendanttest </td><td>  550,9 ms </td><td>  5.435 ms </td><td>  5,084 ms </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  567,6 ms </td><td>  3.879 ms </td><td>  3,439 ms </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  Ent√£o voc√™ pode expandir o loop interno: </p><br><div class="spoiler">  <b class="spoiler_title">MeasureSimilarity</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th><th>  Alocado </th></tr></thead><tbody><tr><td>  Randomtest </td><td>  370,5 ms </td><td>  2,802 ms </td><td>  2.484 ms </td><td>  1,53 KB </td></tr><tr><td>  Ascendanttest </td><td>  395,8 ms </td><td>  2,682 ms </td><td>  2.509 ms </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  419,5 ms </td><td>  3,352 ms </td><td>  2.971 ms </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  √â ainda mais r√°pido?  Sim  Se voc√™ usar as inova√ß√µes do .NET Core 3.0.  Embora esta vers√£o ainda esteja em pr√©-visualiza√ß√£o, mas desde o in√≠cio h√° uma implementa√ß√£o de algumas intr√≠nsecas.  O Guia intr√≠nseco da Intel possui o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>_mm_popcnt_u64</code></a> intr√≠nseco.  Que, conforme descrito: " <em>Conte o n√∫mero de bits definido como 1 no n√∫mero inteiro n√£o assinado de 64 bits a e retorne essa contagem em dst.</em> ".  √â exatamente isso que estamos tentando alcan√ßar!  No .NET Core 3.0 Preview 5, esse intr√≠nseco √© implementado em <code>System.Runtime.Intrinsics.X86.Popcnt.X64.PopCount</code> (conforme observado corretamente nos coment√°rios do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">a-tk</a> , voc√™ deve verificar se o processador os suporta antes de usar o intr√≠nseco. Nesse caso, verifique a condi√ß√£o do <code>System.Runtime.Intrinsics.X86.Popcnt.X64.IsSupported</code> . <code>System.Runtime.Intrinsics.X86.Popcnt.X64.IsSupported</code> ).  Utilizando-o, o c√≥digo do m√©todo <code>MeasureSimilarity</code> ficar√° assim: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) System.Runtime.Intrinsics.X86.Popcnt.X64.PopCount(t); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  e tempo de execu√ß√£o: </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Mean </th><th>  Erro </th><th>  Stddev </th><th>  Alocado </th></tr></thead><tbody><tr><td>  Randomtest </td><td>  59,33 ms </td><td>  1.148 ms </td><td>  0,9585 ms </td><td>  1,53 KB </td></tr><tr><td>  Ascendanttest </td><td>  74,87 ms </td><td>  1.479 ms </td><td>  1,9748 ms </td><td>  1,53 KB </td></tr><tr><td>  DescendantTest </td><td>  119,46 ms </td><td>  2.321 ms </td><td>  2.8509 ms </td><td>  1,53 KB </td></tr></tbody></table></div><br><p>  Impressionante. <br>  N√£o conhe√ßo as maneiras que podem acelerar significativamente o <code>MeasureSimilarity</code> e, ao mesmo tempo, n√£o prejudicar muito a legibilidade.  Eu acho que voc√™ pode terminar esse m√©todo. </p><br><h1 id="struktury-dannyh">  Estruturas de dados </h1><br><p>  Agora, <code>GetFiftyMostSimilarGroups</code> com o corpo do loop no m√©todo <code>GetFiftyMostSimilarGroups</code> : </p><br><div class="spoiler">  <b class="spoiler_title">GetFiftyMostSimilarGroups</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroups</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; List&lt;TagsSimilarityInfo&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TagsSimilarityInfo&gt;(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; groupIndex &lt; Groups.Length; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityValue = TagsGroup.MeasureSimilarity(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, tagsGroup); TagsSimilarityInfo newInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsSimilarityInfo(groupIndex, similarityValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count == resultLength &amp;&amp; list[resultLength - <span class="hljs-number"><span class="hljs-number">1</span></span>].CompareTo(newInfo) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count &gt; resultLength) { list.RemoveAt(resultLength); } } TagsGroup[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsGroup[resultLength]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; resultLength; i++) { result[i] = Groups[list[i].Index]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><p>  Permitam-me relembrar brevemente o que est√° acontecendo aqui: </p><br><ul><li>  dentro da lista, uma lista classificada dos cinquenta grupos de tags mais adequados √© armazenada, de menor para maior, se voc√™ comparar <code>TagsSimilarityInfo</code> ; </li><li>  insira o novo grupo em quest√£o na lista enquanto preserva a classifica√ß√£o; </li><li>  se houver mais de cinquenta elementos na lista, exclua o grupo menos semelhante (seu objeto de informa√ß√£o ser√° o maior e estar√° no final da <code>list</code> ); </li></ul><br><p>  I.e.  acontece que precisamos encontrar rapidamente o maior elemento da cole√ß√£o, poder inserir e excluir rapidamente.  Para resolver esses problemas, existem estruturas de dados especiais.  A primeira coisa que vem √† mente √© um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">monte</a> .  Sua inser√ß√£o √© realizada em O (log N), obtendo o m√°ximo em O (1), removendo um elemento em O (log N).  O √∫nico problema √© que o heap n√£o pode ser iterado pelos elementos crescentes sem modific√°-lo.  N√£o h√° heap bin√°rio no BCL, ent√£o eu mesmo escrevi: </p><br><div class="spoiler">  <b class="spoiler_title">Binaryheap</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BinaryHeap</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;:<span class="hljs-title"><span class="hljs-title">IEnumerable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span> : <span class="hljs-title"><span class="hljs-title">IComparable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;T&gt; innerList; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryHeap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity</span></span></span><span class="hljs-function">)</span></span> { innerList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;T&gt;(capacity); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count =&gt; innerList.Count; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Max =&gt; innerList[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { innerList.Add(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parent = (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; innerList[parent].CompareTo(innerList[i]) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { Swap(i, parent); i = parent; parent = (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { T temp = innerList[a]; innerList[a] = innerList[b]; innerList[b] = temp; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Heapify</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> leftChild = (i &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) | <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rightChild = (i + <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> largestChild = i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftChild &lt; Count &amp;&amp; innerList[leftChild].CompareTo(innerList[largestChild]) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { largestChild = leftChild; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightChild &lt; Count &amp;&amp; innerList[rightChild].CompareTo(innerList[largestChild]) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { largestChild = rightChild; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (largestChild == i) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Swap(i, largestChild); i = largestChild; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveMax</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { innerList[<span class="hljs-number"><span class="hljs-number">0</span></span>] = innerList[Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; innerList.RemoveAt(Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); Heapify(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> innerList.GetEnumerator(); } IEnumerator IEnumerable.GetEnumerator() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((IEnumerable) innerList).GetEnumerator(); } }</code> </pre> </div></div><br><p>  a implementa√ß√£o correspondente do m√©todo <code>GetFiftyMostSimilarGroups</code> pode ser encontrada no c√≥digo-fonte do artigo (link abaixo). <br>  Al√©m da pilha, uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rvore de pesquisa bin√°ria</a> pode aparecer.  Uma √°rvore de pesquisa bin√°ria equilibrada pode fornecer inser√ß√£o para O (log N), obtendo um m√°ximo para O (log N), removendo um elemento para O (log N).  A vantagem dessa estrutura √© que ela pode ser iterada em ordem crescente e, al√©m disso, a √°rvore de pesquisa vermelho-preto na BCL √© implementada no SortedSet (em uma grande estrutura, a obten√ß√£o de um m√°ximo √© muito mais lenta que no .netcore 3.0 e aloca mem√≥ria).  A implementa√ß√£o do <code>GetFiftyMostSimilarGroups</code> para SortedSet pode ser encontrada no c√≥digo-fonte do artigo. <br>  Resultados de benchmark para todas as tr√™s implementa√ß√µes <code>GetFiftyMostSimilarGroups</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  Algoritmo de classifica√ß√£o </th><th>  Mean </th><th>  Alocado </th></tr></thead><tbody><tr><td>  Randomtest </td><td>  Lista </td><td>  60,06 ms </td><td>  1704 B </td></tr><tr><td>  Randomtest </td><td>  Sortedset </td><td>  65,46 ms </td><td>  24384 B </td></tr><tr><td>  Randomtest </td><td>  Mont√£o </td><td>  60,55 ms </td><td>  2912 B </td></tr><tr><td>  Ascendanttest </td><td>  Lista </td><td>  75,42 ms </td><td>  1704 B </td></tr><tr><td>  Ascendanttest </td><td>  Sortedset </td><td>  161,12 ms </td><td>  9833424 B </td></tr><tr><td>  Ascendanttest </td><td>  Mont√£o </td><td>  86,87 ms </td><td>  2912 B </td></tr><tr><td>  DescendantTest </td><td>  Lista </td><td>  119,23 ms </td><td>  880 B </td></tr><tr><td>  DescendantTest </td><td>  Sortedset </td><td>  125,03 ms </td><td>  3024 B </td></tr><tr><td>  DescendantTest </td><td>  Mont√£o </td><td>  118,62 ms </td><td>  2088 B </td></tr></tbody></table></div><br><p>  A implementa√ß√£o original com uma folha vence quase todos os lugares no tempo, e certamente todos os lugares na mem√≥ria.  Isso ocorre devido ao fato de que para um algoritmo com uma planilha, a inser√ß√£o √© realizada em O (log N) para a pesquisa e quase O (1) para a inser√ß√£o, porque  copiar um n√∫mero t√£o pequeno de elementos ocorre muito rapidamente, obtendo um m√°ximo para O (1), excluindo um elemento tamb√©m para O (1), porque  no .net, a exclus√£o do √∫ltimo elemento da planilha √© substitu√≠da por escrever no √∫ltimo elemento um valor vazio (no n√∫cleo .net, nada √© gravado nas estruturas).  Se fosse necess√°rio fornecer n√£o 50, mas digamos 1000 dos grupos mais semelhantes, provavelmente um algoritmo com uma planilha n√£o funcionaria.  De fato, tudo isso √© um pouco de racioc√≠nio especulativo, porque  Voc√™ ainda pode ajustar cada um dos algoritmos. </p><br><h1 id="mnogopotochnost">  Multithreading </h1><br><p>  Agora resta tentar melhorar o pr√≥prio loop no <code>GetFiftyMostSimilarGroups</code> .  Somente multithreading vem √† mente.  A id√©ia √© dividir a lista inteira de grupos em v√°rios pacotes.  Em cada pacote, encontre os 50 grupos de tags mais semelhantes e, entre eles, encontre os 50 finais mais semelhantes. <br>  A vers√£o multithread do <code>GetFiftyMostSimilarGroups</code> √© assim: </p><br><div class="spoiler">  <b class="spoiler_title">GetFiftyMostSimilarGroupsMultiThread</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroupsMultiThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,     const int threadsCount = 4; //   int bucketSize = Groups.Length / threadsCount; var tasks = new Task&lt;List&lt;TagsSimilarityInfo&gt;&gt;[threadsCount]; for (int i = 0; i &lt; threadsCount; i++) { int leftIndex = i * bucketSize; //    int rightIndex = (i + 1) * bucketSize; //    //    tasks[i] = Task&lt;List&lt;TagsSimilarityInfo&gt;&gt;.Factory.StartNew(() =&gt; GetFiftyMostSimilarGroupsMultiThreadCore(value, leftIndex, rightIndex)); } Task.WaitAll(tasks); //    var taskResults = new List&lt;TagsSimilarityInfo&gt;[threadsCount]; for (int i = 0; i &lt; threadsCount; i++) { taskResults[i] = tasks[i].Result; } //      return MergeTaskResults(resultLength, threadsCount, taskResults); }</span></span></code> </pre> </div></div><br><p>  <code>GetFiftyMostSimilarGroupsMultiThreadCore</code>       <code>GetFiftyMostSimilarGroups</code> : </p><br><div class="spoiler"> <b class="spoiler_title">GetFiftyMostSimilarGroupsMultiThreadCore</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">List&lt;TagsSimilarityInfo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroupsMultiThreadCore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leftIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rightIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; List&lt;TagsSimilarityInfo&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TagsSimilarityInfo&gt;(resultLength); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = leftIndex; groupIndex &lt; rightIndex; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityValue = TagsGroup.MeasureSimilarity(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, tagsGroup); TagsSimilarityInfo newInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsSimilarityInfo(groupIndex, similarityValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count == resultLength &amp;&amp; list[resultLength - <span class="hljs-number"><span class="hljs-number">1</span></span>].CompareTo(newInfo) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count &gt; resultLength) { list.RemoveAt(resultLength); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; }</code> </pre> </div></div><br><p>     <code>MergeTaskResults</code> .   -    taskResults    . ,  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> .     ,  <code>threadsCount</code> ,     :         ,     ,    ,    : </p><br><div class="spoiler"> <b class="spoiler_title">MergeTaskResults</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MergeTaskResults</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resultLength, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> threadsCount, List&lt;TagsSimilarityInfo&gt;[] taskResults</span></span></span><span class="hljs-function">)</span></span> { TagsGroup[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsGroup[resultLength]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[threadsCount]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; resultLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; TagsSimilarityInfo currentBest = taskResults[minIndex][indices[minIndex]]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; threadsCount; j++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current = taskResults[j][indices[j]]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.CompareTo(currentBest) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { minIndex = j; currentBest = taskResults[minIndex][indices[minIndex]]; } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = currentBest.Index; result[i] = Groups[groupIndex]; indices[minIndex]++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><ul><li>  <code>indices</code>      <code>taskResults</code> ; </li><li> <code>minIndex</code> ‚Äî   <code>taskResults</code> ,         ; </li><li> <code>currentBest</code> ‚Äî -      ; </li><li> <code>current</code> ‚Äî -    ; </li></ul><br><p>    : </p><br><div class="scrollable-table"><table><thead><tr><th> Method </th><th> Mean </th><th> Error </th><th> StdDev </th><th> Allocated </th></tr></thead><tbody><tr><td> RandomTest </td><td> 28.76 ms </td><td> 0.5677 ms </td><td> 1.414 ms </td><td> 1.4 KB </td></tr><tr><td> AscendantTest </td><td> 32.36 ms </td><td> 0.8930 ms </td><td> 2.591 ms </td><td> 1.4 KB </td></tr><tr><td> DescendantTest </td><td> 41.36 ms </td><td> 0.8908 ms </td><td> 2.626 ms </td><td> 1.4 KB </td></tr></tbody></table></div><br><div class="spoiler"> <b class="spoiler_title">     :</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th> Method </th><th> Mean </th><th> Error </th><th> StdDev </th><th> Allocated </th></tr></thead><tbody><tr><td> RandomTest </td><td> 25054 ms </td><td> 1786 ms </td><td> 1670 ms </td><td> 1.53 KB </td></tr><tr><td> AscendantTest </td><td> 4180 ms </td><td> 174 ms </td><td> 162 ms </td><td> 1.53 KB </td></tr><tr><td> DescendantTest </td><td> 4147 ms </td><td> 118 ms </td><td> 104 ms </td><td> 1.53 KB </td></tr></tbody></table></div></div></div><br><p>            .   .    ,    ,       4  50. , ,   . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    </a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454850/">https://habr.com/ru/post/pt454850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454830/index.html">3 principais qualidades para um gerente de produto de sucesso: Alexander Belyaev</a></li>
<li><a href="../pt454832/index.html">Por que uma semana de trabalho de quatro dias √© um p√©ssimo conto</a></li>
<li><a href="../pt454834/index.html">Os termos reais do estudo da digita√ß√£o por toque com baixa motiva√ß√£o</a></li>
<li><a href="../pt454840/index.html">Mudan√ßa cuidadosa para a Holanda com sua esposa e hipoteca. Parte 2: preparando documentos e movendo</a></li>
<li><a href="../pt454844/index.html">Odigest: interessante para designers da semana</a></li>
<li><a href="../pt454856/index.html">Analisamos vulnerabilidades de valida√ß√£o de certificado SSL / TLS em software que n√£o √© de navegador</a></li>
<li><a href="../pt454860/index.html">Vamos ajudar o QueryProvider a lidar com seq√º√™ncias de caracteres interpoladas</a></li>
<li><a href="../pt454864/index.html">Como est√£o os processos de desenvolvimento em v√°rias empresas</a></li>
<li><a href="../pt454868/index.html">Compilando C no WebAssembly sem Emscripten</a></li>
<li><a href="../pt454872/index.html">Invasores do espa√ßo: agora em 512 bytes (Assembler x86)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>