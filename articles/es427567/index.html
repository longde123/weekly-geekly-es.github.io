<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçü§ù‚Äçüë®üèº üìâ üñáÔ∏è Mapas hexagonales en Unity: ciclo del agua, erosi√≥n, biomas, mapa cil√≠ndrico üë©üèº‚Äçüé® üîù üë©üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partes 1-3: malla, colores y alturas de celda 

 Partes 4-7: baches, r√≠os y caminos 

 Partes 8-11: agua, accidentes geogr√°ficos y murallas 

 Partes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapas hexagonales en Unity: ciclo del agua, erosi√≥n, biomas, mapa cil√≠ndrico</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427567/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 1-3: malla, colores y alturas de celda</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 4-7: baches, r√≠os y caminos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 8-11: agua, accidentes geogr√°ficos y murallas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 12-15: guardar y cargar, texturas, distancias</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 16-19: encontrar el camino, escuadrones de jugadores, animaciones</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 20-23: niebla de guerra, investigaci√≥n de mapas, generaci√≥n de procedimientos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 24-27: ciclo del agua, erosi√≥n, biomas, mapa cil√≠ndrico</a> <br><br><h1>  Parte 24: regiones y erosi√≥n </h1><br><ul><li>  Agrega un borde de agua alrededor del mapa. </li><li>  Dividimos el mapa en varias regiones. </li><li>  Usamos la erosi√≥n para cortar los acantilados. </li><li>  Movimos la tierra para suavizar el alivio. </li></ul><br>  En la parte anterior, sentamos las bases para la generaci√≥n de mapas de procedimientos.  Esta vez limitaremos los lugares de posible ocurrencia de tierras y actuaremos sobre ellas con erosi√≥n. <br><br>  Este tutorial fue creado en Unity 2017.1.0. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ac/6a5/30c/5ac6a530cef3718f9031abe862364093.jpg"></div><br>  <i>Separar y suavizar la tierra.</i> <br><a name="habracut"></a><br><h2>  Borde del mapa </h2><br>  Dado que levantamos √°reas de tierra al azar, puede suceder que la tierra toque el borde del mapa.  Esto puede ser indeseable.  El mapa con l√≠mite de agua contiene una barrera natural que impide que los jugadores se acerquen al borde.  Por lo tanto, ser√≠a bueno si prohibi√©ramos que la tierra se eleve por encima del nivel del agua cerca del borde del mapa. <br><br><h3>  Tama√±o del borde </h3><br>  ¬øQu√© tan cerca debe estar la tierra del borde del mapa?  No hay una respuesta correcta a esta pregunta, por lo que haremos que este par√°metro sea personalizable.  <code>HexMapGenerator</code> dos controles deslizantes al componente <code>HexMapGenerator</code> , uno para los bordes a lo largo de los bordes a lo largo del eje X, el otro para los bordes a lo largo del eje Z. Por lo tanto, podemos usar un borde m√°s ancho en una de las dimensiones, o incluso crear un borde en una sola dimensi√≥n.  Usemos un intervalo de 0 a 10 con un valor predeterminado de 5. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderX = <span class="hljs-number"><span class="hljs-number">5</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderZ = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/8ab/c74/6948abc743e881596bdea5656e562943.png"></div><br>  <i>Mapa de bordes deslizantes.</i> <br><br><h3>  Limitamos los centros de las √°reas terrestres. </h3><br>  Sin bordes, todas las celdas son v√°lidas.  Cuando hay l√≠mites, las coordenadas m√≠nimas de desplazamiento permitidas aumentan y las coordenadas m√°ximas permitidas disminuyen.  Dado que para generar las parcelas necesitaremos conocer el intervalo permitido, rastreemos usando cuatro campos enteros. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xMin, xMax, zMin, zMax;</code> </pre> <br>  Inicializamos las restricciones en <code>GenerateMap</code> antes de crear sushi.  Utilizamos estos valores como par√°metros para <code>Random.Range</code> llamadas <code>Random.Range</code> , por lo que los m√°ximos son realmente excepcionales.  Sin un borde, son iguales al n√∫mero de celdas de medici√≥n, por lo tanto, no menos 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = waterLevel; } xMin = mapBorderX; xMax = x - mapBorderX; zMin = mapBorderZ; zMax = z - mapBorderZ; CreateLand(); ‚Ä¶ }</code> </pre> <br>  No prohibiremos estrictamente la aparici√≥n de tierra m√°s all√° del borde de la frontera, ya que esto crear√≠a bordes muy cortados.  En cambio, limitaremos solo las celdas utilizadas para comenzar la generaci√≥n de gr√°ficos.  Es decir, los centros aproximados de los sitios ser√°n limitados, pero partes de los sitios podr√°n ir m√°s all√° del √°rea fronteriza.  Esto se puede hacer modificando <code>GetRandomCell</code> para que seleccione una celda en el rango de desplazamientos permitidos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return grid.GetCell(Random.Range(0, cellCount)); return grid.GetCell(Random.Range(xMin, xMax), Random.Range(zMin, zMax)); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/bbf/24b/7a8bbf24b1d46d9b97e8e9c01652fdfd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/0cf/aa2/a310cfaa2bec1cbe019a08c14218c7fd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f1/799/f50/7f1799f5058c0d1e435bfc3c42133b9c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/c4b/1b7/93ac4b1b771eaa896b6c494b69c18b92.jpg"></div><br>  <i>Los bordes del mapa son 0 √ó 0, 5 √ó 5, 10 √ó 10 y 0 √ó 10.</i> <br><br>  Cuando todos los par√°metros del mapa se establecen en sus valores predeterminados, un borde de tama√±o 5 proteger√° de manera confiable el borde del mapa de tocar tierra.  Sin embargo, esto no est√° garantizado.  La tierra a veces puede acercarse al borde y, a veces, tocarla en varios lugares. <br><br>  La probabilidad de que la tierra cruce la frontera entera depende del tama√±o de la frontera y del tama√±o m√°ximo del sitio.  Sin dudarlo, las secciones siguen siendo hex√°gonos.  Hex√°gono completo con radio <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>r</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.049ex" height="1.455ex" viewBox="0 -520.7 451.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> r </script>  contiene <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.32ex" height="2.539ex" viewBox="0 -935.7 5304.3 1093.4" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-33" x="0" y="0"></use><g transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-32" x="638" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="1628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-33" x="2628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="3129" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="3803" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="4803" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 3r ^ 2 + 3r + 1 </script>  c√©lulas  Si hay hex√°gonos con un radio igual al tama√±o del borde, entonces pueden cruzarlo.  Un hex√°gono completo con un radio de 5 contiene 91 celdas.  Como por defecto el m√°ximo es de 100 celdas por secci√≥n, esto significa que la tierra podr√° tender un puente a trav√©s de 5 celdas, especialmente si hay vibraciones.  Para evitar que esto suceda, reduzca el tama√±o m√°ximo de la trama o aumente el tama√±o del borde. <br><br><div class="spoiler">  <b class="spoiler_title">¬øC√≥mo se deriva la f√≥rmula para el n√∫mero de celdas en la regi√≥n hexagonal?</b> <div class="spoiler_text">  Con un radio de 0, estamos tratando con una sola celda.  Vino de 1. Con un radio de 1 alrededor del centro, hay seis celdas adicionales, es decir <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.165ex" height="2.211ex" viewBox="0 -772.3 2223.9 952" role="img" focusable="false" style="vertical-align: -0.417ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="722" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="1723" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> 6 + 1 </script>  .  Estas seis celdas pueden considerarse los extremos de seis tri√°ngulos que tocan el centro.  Con un radio de 2, se agrega una segunda fila a estos tri√°ngulos, es decir, se obtienen dos celdas m√°s en el tri√°ngulo, y en total <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.14ex" height="2.762ex" viewBox="0 -831.5 5226.9 1189" role="img" focusable="false" style="vertical-align: -0.83ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="1612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-32" x="2613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-29" x="3113" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="3725" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="4726" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> 6 (1 + 2) + 1 </script>  .  Con un radio de 3, se agrega una tercera fila, es decir, tres celdas m√°s por tri√°ngulo, y en total <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.143ex" height="2.762ex" viewBox="0 -831.5 6950.3 1189" role="img" focusable="false" style="vertical-align: -0.83ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="1612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-32" x="2613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="3336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-33" x="4336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-29" x="4837" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="5449" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="6449" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-5"> 6 (1 + 2 + 3) + 1 </script>  .  Y as√≠ sucesivamente.  Es decir, en t√©rminos generales, la f√≥rmula se ve como <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mi>u</mi><mi>m</mi><msub><mi>a</mi><mo stretchy=&quot;false&quot;>(</mo></msub><mi>i</mi><mo>=</mo><mn>1</mn><msup><mo stretchy=&quot;false&quot;>)</mo><mi>r</mi></msup><mi>i</mi><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>2</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="74.989ex" height="3.312ex" viewBox="0 -950 32286.9 1426" role="img" focusable="false" style="vertical-align: -1.106ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-73" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-75" x="1359" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-6D" x="1932" y="0"></use><g transform="translate(2810,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-28" x="748" y="-264"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-69" x="3715" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-3D" x="4338" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="5394" y="0"></use><g transform="translate(5895,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="550" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-69" x="6704" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-29" x="7049" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="7661" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="8662" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-3D" x="9440" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-36" x="10496" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-28" x="10997" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-28" x="11386" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="11776" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-28" x="12227" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="12617" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="13290" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="14291" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-29" x="14792" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-29" x="15181" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2F" x="15571" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-32" x="16071" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-29" x="16572" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="17183" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="18184" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-3D" x="18962" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-33" x="20019" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="20519" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-28" x="20971" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="21360" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="22034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="23035" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-29" x="23535" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="24147" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="25148" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-3D" x="25926" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-33" x="26982" y="0"></use><g transform="translate(27483,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-32" x="638" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="28610" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-33" x="29611" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="30111" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="30785" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="31786" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mi>s</mi><mi>u</mi><mi>m</mi><msub><mi>a</mi><mo stretchy="false">(</mo></msub><mi>i</mi><mo>=</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>r</mi></msup><mi>i</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>6</mn><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><mi>r</mi><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-6"> 6 (suma_ (i = 1) ^ r i) +1 = 6 ((r (r + 1)) / 2) +1 = 3r (r + 1) + 1 = 3r ^ 2 + 3r + 1 </script>  . </div></div><br>  Para ver esto m√°s claramente, podemos establecer el tama√±o del borde en 200. Dado que un hex√°gono completo con un radio de 8 contiene 217 celdas, es probable que la tierra toque el borde del mapa.  Al menos si usa el valor de tama√±o de borde predeterminado (5).  Si aumenta el borde a 10, la probabilidad disminuir√° considerablemente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/75d/eb0/74b75deb060d9bdae2f74c1db4de287e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffa/7ce/e96/ffa7cee967f81ba9fe4ddc6718519d9a.jpg"></div><br>  <i>La parcela tiene un tama√±o constante de 200, los bordes del mapa son 5 y 10.</i> <br><br><h3>  Pangea </h3><br>  Tenga en cuenta que cuando aumenta el borde del mapa y mantiene el mismo porcentaje de tierra, forzamos la tierra a formar un √°rea m√°s peque√±a.  Como resultado de esto, un mapa grande por defecto es muy probable que cree una gran masa de tierra, el supercontinente Pangea, posiblemente con varias islas peque√±as.  Con un aumento en el tama√±o del borde, la probabilidad de que esto ocurra aumenta y, a ciertos valores, casi estamos garantizados de obtener un supercontinente.  Sin embargo, cuando el porcentaje de tierra es demasiado grande, la mayor√≠a de las √°reas disponibles se llenan y como resultado obtenemos una masa de tierra casi rectangular.  Para evitar que esto suceda, debe reducir el porcentaje de tierra. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/d84/209/e1bd8420915ccc74cd3470409b9a4236.jpg"></div><br>  <i>40% de sushi con borde de tarjeta 10.</i> <br><br><div class="spoiler">  <b class="spoiler_title">¬øDe d√≥nde viene el nombre Pangea?</b> <div class="spoiler_text">  Ese era el nombre del √∫ltimo supercontinente conocido que existi√≥ en la Tierra hace muchos a√±os.  El nombre se compone de las palabras griegas pan y Gaia, que significa algo as√≠ como "toda la naturaleza" o "toda la tierra". </div></div><br><br><h3>  Protegemos de cartas imposibles </h3><br>  Generamos la cantidad correcta de tierra simplemente continuando elevando la tierra hasta que alcancemos la masa de tierra deseada.  Esto funciona porque tarde o temprano elevaremos cada celda al nivel del agua.  Sin embargo, cuando usamos el borde del mapa, no podemos llegar a cada celda.  Cuando se requiere un porcentaje demasiado alto de tierra, esto conducir√° a interminables "intentos y fallas" del generador para obtener m√°s tierra, y se quedar√° estancado en un ciclo interminable.  En este caso, la aplicaci√≥n se congelar√°, pero esto no deber√≠a suceder. <br><br>  No podemos encontrar de manera confiable configuraciones imposibles de antemano, pero podemos protegernos de ciclos interminables.  Simplemente realizaremos un seguimiento del n√∫mero de ciclos ejecutados en <code>CreateLand</code> .  Si hay demasiadas iteraciones, lo m√°s probable es que estemos atascados y debamos parar. <br><br>  Para un mapa grande, mil iteraciones parecen aceptables, y diez mil iteraciones ya parecen absurdas.  Entonces usemos este valor como punto de terminaci√≥n. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// while (landBudget &gt; 0) { for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); ‚Ä¶ } }</span></span></code> </pre> <br>  Si obtenemos un mapa da√±ado, 10,000 iteraciones no tomar√°n mucho tiempo, porque muchas celdas alcanzar√°n r√°pidamente la altura m√°xima, lo que evitar√° que crezcan nuevas √°reas. <br><br>  Incluso despu√©s de romper el ciclo, todav√≠a obtenemos el mapa correcto.  Simplemente no tiene la cantidad correcta de sushi y no se ver√° muy interesante.  Muestremos una notificaci√≥n sobre esto en la consola, inform√°ndonos qu√© tierras restantes no pudimos gastar. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab5/87f/f4f/ab587ff4f560fe6c1c0d7d5a547ae2b7.jpg"></div><br>  <i>El 95% de la tierra con un borde de tarjeta de 10 no podr√≠a gastar la cantidad total.</i> <br><br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© una carta fallida todav√≠a tiene variaci√≥n?</b> <div class="spoiler_text">  La costa tiene variabilidad, porque cuando las alturas dentro del √°rea de creaci√≥n se vuelven demasiado altas, las nuevas √°reas no les permiten crecer hacia afuera.  El mismo principio no permite que las parcelas crezcan en peque√±as √°reas de tierra, hasta que alcancen la altura m√°xima y simplemente se pierdan.  Adem√°s, la variabilidad aumenta al bajar las parcelas. </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  Particionar una tarjeta </h2><br>  Ahora que tenemos el borde del mapa, esencialmente dividimos el mapa en dos regiones separadas: la regi√≥n del borde y la regi√≥n donde se crearon las parcelas.  Como solo la regi√≥n de la creaci√≥n es importante para nosotros, podemos considerar este caso como una situaci√≥n en una regi√≥n.  La regi√≥n simplemente no cubre todo el mapa.  Pero si esto es imposible, entonces nada nos impide dividir el mapa en varias regiones no conectadas de creaci√≥n de tierras.  Esto permitir√° que las masas de tierra se formen independientemente entre s√≠, designando diferentes continentes. <br><br><h3>  Regi√≥n del mapa </h3><br>  Comencemos describiendo una regi√≥n del mapa como una estructura.  Esto simplificar√° nuestro trabajo con varias regiones.  <code>MapRegion</code> una estructura <code>MapRegion</code> para esto, que simplemente contiene los campos de borde de la regi√≥n.  Como no utilizaremos esta estructura fuera de <code>HexMapGenerator</code> , podemos definirla dentro de esta clase como una estructura interna privada.  Luego, cuatro campos enteros se pueden reemplazar por un campo <code>MapRegion</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int xMin, xMax, zMin, zMax; struct MapRegion { public int xMin, xMax, zMin, zMax; } MapRegion region;</span></span></code> </pre> <br>  Para que todo funcione, debemos agregar el prefijo de <code>region.</code> a los campos m√≠nimo-m√°ximo en <code>GenerateMap</code> <code>region.</code>  . <br><br><pre> <code class="cs hljs"> region.xMin = mapBorderX; region.xMax = x - mapBorderX; region.zMin = mapBorderZ; region.zMax = z - mapBorderZ;</code> </pre> <br>  Y tambi√©n en <code>GetRandomCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br><h3>  Varias regiones </h3><br>  Para admitir varias regiones, reemplace un campo <code>MapRegion</code> lista de regiones. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// MapRegion region; List&lt;MapRegion&gt; regions;</span></span></code> </pre> <br>  En este punto, ser√≠a bueno agregar un m√©todo separado para crear regiones.  Debe crear la lista deseada o borrarla si ya existe.  Despu√©s de eso, determinar√° una regi√≥n, como lo hicimos antes, y la agregar√° a la lista. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRegions</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regions == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { regions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MapRegion&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { regions.Clear(); } MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br>  Llamaremos a este m√©todo en <code>GenerateMap</code> y no crearemos la regi√≥n directamente. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// region.xMin = mapBorderX; // region.xMax = x - mapBorderX; // region.zMin = mapBorderZ; // region.zMax = z - mapBorderZ; CreateRegions(); CreateLand();</span></span></code> </pre> <br>  Para que <code>GetRandomCell</code> pueda trabajar con una regi√≥n arbitraria, dele el par√°metro <code>MapRegion</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MapRegion region</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br>  Ahora los <code>SinkTerrain</code> <code>RaiseTerraion</code> y <code>SinkTerrain</code> deber√≠an pasar la regi√≥n correspondiente a <code>GetRandomCell</code> .  Para hacer esto, cada uno de ellos tambi√©n necesita un par√°metro de regi√≥n. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SinkTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); ‚Ä¶ }</code> </pre> <br>  El m√©todo <code>CreateLand</code> debe determinar para cada regi√≥n subir o bajar las secciones.  Para equilibrar la tierra entre las regiones, simplemente recorreremos repetidamente la lista de regiones en el ciclo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability) { landBudget = SinkTerrain(chunkSize, landBudget, region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br>  Sin embargo, todav√≠a tenemos que hacer que la reducci√≥n de las parcelas se distribuya uniformemente.  Esto se puede hacer al decidir para todas las regiones si se deben omitir. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> sink = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if (Random.value &lt; sinkProbability) { if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } }</span></span></code> </pre> <br>  Finalmente, para usar exactamente la cantidad total de tierra, necesitamos detener el proceso tan pronto como la cantidad llegue a cero.  Esto puede suceder en cualquier etapa del ciclo de la regi√≥n.  Por lo tanto, movemos la verificaci√≥n de suma cero al bucle interno.  De hecho, solo podemos realizar esta verificaci√≥n despu√©s de levantar la tierra, porque al bajar, la cantidad nunca se gasta.  Si hemos terminado, podemos salir inmediatamente del m√©todo <code>CreateLand</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { for (int guard = 0; guard &lt; 10000; guard++) { bool sink = Random.value &lt; sinkProbability; for (int i = 0; i &lt; regions.Count; i++) { MapRegion region = regions[i]; int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); if (landBudget == 0) { return; } } } }</span></span></code> </pre> <br><h3>  Dos regiones </h3><br>  Aunque ahora contamos con el apoyo de varias regiones, todav√≠a solicitamos solo una.  Cambiemos <code>CreateRegions</code> para que divida el mapa a la mitad verticalmente.  Para hacer esto, <code>xMax</code> la mitad el valor <code>xMax</code> de la regi√≥n agregada.  Luego usamos el mismo valor para <code>xMin</code> y nuevamente usamos el valor original para <code>xMax</code> , us√°ndolo como la segunda regi√≥n. <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br>  Generar cartas en esta etapa no har√° ninguna diferencia.  Aunque hemos identificado dos regiones, ocupan la misma regi√≥n que una regi√≥n antigua.  Para separarlos, debe dejar un espacio vac√≠o entre ellos.  Esto se puede hacer agregando un control deslizante al borde de la regi√≥n, usando el mismo intervalo y valor predeterminado que para los bordes del mapa. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionBorder = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/cd2/cd0/9ffcd2cd0f4068caf622e433c503715d.png"></div><br>  <i>Control deslizante de borde de regi√≥n.</i> <br><br>  Dado que se puede formar tierra a ambos lados del espacio entre regiones, aumentar√° la probabilidad de crear puentes terrestres en los bordes del mapa.  Para evitar esto, usamos el borde de la regi√≥n para definir una zona libre de tierra entre la l√≠nea divisoria y la regi√≥n en la que pueden comenzar las parcelas.  Esto significa que la distancia entre las regiones vecinas es dos veces mayor que el tama√±o del borde de la regi√≥n. <br><br>  Para aplicar este l√≠mite de regi√≥n, restarlo del <code>xMax</code> primera regi√≥n y agregar la segunda regi√≥n a <code>xMin</code> . <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/1f6/476/1e51f6476894662d55f7ca9748dc7fa5.jpg"></div><br>  <i>El mapa se divide verticalmente en dos regiones.</i> <br><br>  Con la configuraci√≥n predeterminada, se crear√°n dos regiones notablemente separadas, sin embargo, como en el caso de una regi√≥n y un borde de mapa grande, no se garantiza que recibamos exactamente dos masas de tierra.  Muy a menudo ser√°n dos grandes continentes, posiblemente con varias islas.  Pero a veces se pueden crear dos o m√°s islas grandes en una regi√≥n.  Y a veces dos continentes pueden estar conectados por un istmo. <br><br>  Por supuesto, tambi√©n podemos dividir el mapa horizontalmente, cambiando los enfoques para medir X y Z. Elija al azar una de las dos orientaciones posibles. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/970/c91/f23970c91cdd9c539ebdc8c7fdbba05f.jpg"></div><br>  <i>Mapa horizontalmente dividido en dos regiones.</i> <br><br>  Como usamos un mapa ancho, se crear√°n regiones m√°s anchas y m√°s delgadas con separaci√≥n horizontal.  Como resultado, es m√°s probable que estas regiones formen varias masas de tierra divididas. <br><br><h3>  Cuatro regiones </h3><br>  Hagamos que el n√∫mero de regiones sea personalizable, creemos soporte de 1 a 4 regiones. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(1, 4)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionCount = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/918/49e/2a4/91849e2a4ffe6091b8d4fdf0d78b0c45.png"></div><br>  <i>Control deslizante para el n√∫mero de regiones.</i> <br><br>  Podemos usar la <code>switch</code> para seleccionar la ejecuci√≥n del c√≥digo de regi√≥n correspondiente.  Comenzamos repitiendo el c√≥digo de una regi√≥n, que se usar√° por defecto, y dejamos el c√≥digo de dos regiones para el caso 2. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øCu√°l es la declaraci√≥n de cambio?</b> <div class="spoiler_text">  Esta es una alternativa a escribir una secuencia de declaraciones if-else-if-else.  El interruptor se aplica a la variable y las etiquetas se usan para indicar qu√© c√≥digo debe ejecutarse.  Tambi√©n hay una etiqueta <code>default</code> , que se usa como el √∫ltimo bloque <code>else</code> .  Cada opci√≥n debe terminar con una declaraci√≥n de <code>break</code> o una <code>return</code> . <br><br>  Para mantener legible el bloque de <code>switch</code> , generalmente es mejor mantener todos los casos cortos, idealmente con una sola declaraci√≥n o llamada al m√©todo.  No har√© esto como un ejemplo de c√≥digo de regi√≥n, pero si desea crear regiones m√°s interesantes, le recomiendo que utilice m√©todos separados.  Por ejemplo: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: CreateOneRegion(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: CreateTwoRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: CreateThreeRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: CreateFourRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> </div></div><br>  Tres regiones son similares a dos, solo se utilizan tercios en lugar de la mitad.  En este caso, la divisi√≥n horizontal crear√° regiones demasiado estrechas, por lo que creamos soporte solo para la divisi√≥n vertical.  Tenga en cuenta que, como resultado, hemos duplicado el √°rea del borde de la regi√≥n, por lo que el espacio para crear nuevas secciones es menor que en el caso de dos regiones. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/234/2e7/cc8/2342e7cc8cb524f4f9db803d5359a78e.jpg"></div><br>  <i>Tres regiones</i> <br><br>  Se pueden crear cuatro regiones combinando la separaci√≥n horizontal y vertical y agregando una regi√≥n a cada esquina del mapa. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/551/b72/a0c/551b72a0ca2f12a5636828faa4c3febc.jpg"></div><br>  <i>Cuatro regiones</i> <br><br>  El enfoque utilizado aqu√≠ es la forma m√°s sencilla de dividir un mapa.  Genera aproximadamente las mismas regiones por masa de tierra, y su variabilidad est√° controlada por otros par√°metros de generaci√≥n de mapas.  Sin embargo, siempre ser√° bastante obvio que la tarjeta se dividi√≥ en l√≠neas rectas.  Cuanto m√°s control necesitemos, menos org√°nico se ver√° el resultado.  Por lo tanto, esto es normal si necesita regiones aproximadamente iguales para el juego.  Pero si necesita la tierra m√°s variada e ilimitada, tendr√° que hacerlo con la ayuda de una regi√≥n. <br><br>  Adem√°s, hay otras formas de dividir el mapa.  No podemos limitarnos solo a l√≠neas rectas.  Ni siquiera tenemos que usar regiones del mismo tama√±o, as√≠ como cubrir todo el mapa con ellas.  Podemos dejar agujeros.  Tambi√©n puede permitir intersecciones de regiones o cambiar la distribuci√≥n de la tierra entre regiones.  Incluso puede establecer sus propios par√°metros de generador para cada regi√≥n (aunque esto es m√°s complicado), por ejemplo, para tener un continente grande y un archipi√©lago en el mapa. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  Erosi√≥n </h2><br>  Hasta ahora, todas las cartas que hemos generado parec√≠an bastante groseras y rotas.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un alivio real puede verse as√≠, pero con el tiempo se vuelve m√°s y m√°s suave, sus partes afiladas se opacan debido a la erosi√≥n. </font><font style="vertical-align: inherit;">Para mejorar los mapas, podemos aplicar este proceso de erosi√≥n. </font><font style="vertical-align: inherit;">Haremos esto despu√©s de crear un terreno accidentado, en un m√©todo separado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateRegions(); CreateLand(); ErodeLand(); SetTerrainType(); ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Porcentaje de erosi√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuanto m√°s tiempo pasa, m√°s erosi√≥n aparece. </font><font style="vertical-align: inherit;">Por lo tanto, queremos que la erosi√≥n no sea permanente, sino personalizable. </font><font style="vertical-align: inherit;">Como m√≠nimo, la erosi√≥n es cero, lo que corresponde a los mapas creados anteriormente. </font><font style="vertical-align: inherit;">Al m√°ximo, la erosi√≥n es integral, es decir, la aplicaci√≥n adicional de las fuerzas de erosi√≥n ya no cambiar√° el terreno. </font><font style="vertical-align: inherit;">Es decir, el par√°metro de erosi√≥n debe ser un porcentaje de 0 a 100, y por defecto tomaremos 50.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 100)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erosionPercentage = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/efe/e5e/c4eefee5e18aeee36f16e6aee98a27fe.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante de erosi√≥n.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buscar c√©lulas destructoras de la erosi√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La erosi√≥n hace que el alivio sea m√°s suave. En nuestro caso, las √∫nicas partes afiladas son los acantilados. Por lo tanto, ser√°n el objetivo del proceso de erosi√≥n. Si existe un acantilado, la erosi√≥n deber√≠a reducirlo hasta que finalmente se convierta en una pendiente. No suavizaremos las pendientes, ya que esto conducir√° a un terreno aburrido. Para hacer esto, necesitamos determinar qu√© celdas est√°n en la parte superior de los acantilados y bajar su altura. Estas ser√°n c√©lulas propensas a la erosi√≥n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creemos un m√©todo que determine si una c√©lula puede ser propensa a la erosi√≥n. </font><font style="vertical-align: inherit;">√âl determina esto comprobando a los vecinos de la celda hasta que encuentre una diferencia de altura suficientemente grande. </font><font style="vertical-align: inherit;">Dado que los acantilados requieren una diferencia de al menos uno o dos niveles de altura, la celda est√° sujeta a erosi√≥n si uno o m√°s de sus vecinos est√°n al menos dos pasos debajo de ella. </font><font style="vertical-align: inherit;">Si no existe tal vecino, entonces la c√©lula no puede sufrir erosi√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsErodible</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar este m√©todo </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para recorrer todas las celdas y escribir todas las celdas propensas a la erosi√≥n en una lista temporal.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(cell)) { erodibleCells.Add(cell); } } ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una vez que conocemos el n√∫mero total de c√©lulas propensas a la erosi√≥n, podemos usar el porcentaje de erosi√≥n para determinar el n√∫mero de c√©lulas restantes propensas a la erosi√≥n. </font><font style="vertical-align: inherit;">Por ejemplo, si el porcentaje es 50, entonces debemos erosionar las c√©lulas hasta que quede la mitad de la cantidad original. </font><font style="vertical-align: inherit;">Si el porcentaje es 100, entonces no nos detendremos hasta que destruyamos todas las c√©lulas propensas a la erosi√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNo deber√≠amos considerar solo las c√©lulas propensas a la erosi√≥n de la tierra?</font></font></b> <div class="spoiler_text">     .    ,       ,     . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reducci√≥n celular </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos con un enfoque ingenuo y supongamos que una simple reducci√≥n en la altura de las c√©lulas destruidas por erosi√≥n har√° que ya no sea m√°s propenso a la erosi√≥n. </font><font style="vertical-align: inherit;">Si esto fuera cierto, entonces podr√≠amos tomar celdas aleatorias de la lista, reducir su altura y luego eliminarlas de la lista. </font><font style="vertical-align: inherit;">Repetir√≠amos esta operaci√≥n hasta alcanzar el n√∫mero deseado de c√©lulas susceptibles a la erosi√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (erodibleCells.Count &gt; targetErodibleCount) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, erodibleCells.Count); HexCell cell = erodibleCells[index]; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; erodibleCells.Remove(cell); } ListPool&lt;HexCell&gt;.Add(erodibleCells);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar la b√∫squeda requerida </font></font><code>erodibleCells.Remove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sobrescribiremos la √∫ltima celda actual de la lista y luego eliminaremos el √∫ltimo elemento. </font><font style="vertical-align: inherit;">Todav√≠a no nos importa su orden.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// erodibleCells.Remove(cell); erodibleCells[index] = erodibleCells[erodibleCells.Count - 1]; erodibleCells.RemoveAt(erodibleCells.Count - 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/050/66c/50e05066c444e6854c622b865fde2726.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14d/fca/6b4/14dfca6b41ce23cdeb3e5fc4d5307eba.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disminuci√≥n ingenua de 0% y 100% de c√©lulas propensas a la erosi√≥n, mapa de semillas 1957632474.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seguimiento de la erosi√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestro enfoque ingenuo nos permite aplicar erosi√≥n, pero no en el grado correcto. </font><font style="vertical-align: inherit;">Esto sucede porque la c√©lula despu√©s de una disminuci√≥n en la altura puede seguir siendo propensa a la erosi√≥n. </font><font style="vertical-align: inherit;">Por lo tanto, eliminaremos una celda de la lista solo cuando ya no est√© sujeta a erosi√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/281/0a9/779/2810a9779b056865ad4490f9b00fa50f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% de erosi√≥n mientras se mantienen las c√©lulas propensas a la erosi√≥n en la lista. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, tenemos una erosi√≥n mucho m√°s fuerte, pero cuando usamos el 100% todav√≠a no nos deshacemos de todos los acantilados. </font><font style="vertical-align: inherit;">La raz√≥n es que despu√©s de reducir la altura de la celda, uno de sus vecinos puede volverse propenso a la erosi√≥n. </font><font style="vertical-align: inherit;">Por lo tanto, como resultado, podemos tener m√°s c√©lulas propensas a la erosi√≥n de lo que era originalmente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de bajar la celda, debemos verificar todos sus vecinos. </font><font style="vertical-align: inherit;">Si ahora son propensos a la erosi√≥n, pero a√∫n no est√°n en la lista, entonces debe agregarlos all√≠.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/894/ed5/b2a894ed5274286b00046050963388f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se omiten todas las c√©lulas erosionadas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahorramos mucha tierra </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora el proceso de erosi√≥n puede continuar hasta que desaparezcan todos los acantilados. Esto afecta mucho la tierra. La mayor parte de la masa de tierra desapareci√≥ y obtuvimos mucho menos que el porcentaje de tierra necesaria. Sucedi√≥ porque estamos eliminando tierras del mapa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La verdadera erosi√≥n no destruye la materia. Ella lo toma de un lugar y lo coloca en otro lugar. Nosotros podemos hacer lo mismo. Con una disminuci√≥n en una celda, debemos criar a uno de sus vecinos. De hecho, un nivel de altura se transfiere a una celda inferior. Esto ahorra la cantidad total de alturas del mapa, mientras que simplemente lo suaviza.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para darnos cuenta de esto, debemos decidir d√≥nde transferir los productos de erosi√≥n. </font><font style="vertical-align: inherit;">Este ser√° nuestro objetivo de erosi√≥n. </font><font style="vertical-align: inherit;">Creemos un m√©todo para determinar el punto objetivo de una celda que se erosionar√°. </font><font style="vertical-align: inherit;">Dado que esta celda contiene un salto, ser√≠a l√≥gico seleccionar la celda ubicada debajo de este salto como el objetivo. </font><font style="vertical-align: inherit;">Pero una celda propensa a la erosi√≥n puede tener varios descansos, por lo que verificaremos a todos los vecinos y colocaremos a todos los candidatos en una lista temporal, y luego elegiremos uno de ellos al azar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetErosionTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; candidates = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { candidates.Add(neighbor); } } HexCell target = candidates[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, candidates.Count)]; ListPool&lt;HexCell&gt;.Add(candidates); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definimos la celda objetivo inmediatamente despu√©s de seleccionar la celda de erosi√≥n. </font><font style="vertical-align: inherit;">Luego disminuimos y aumentamos las alturas de las c√©lulas inmediatamente una tras otra. </font><font style="vertical-align: inherit;">En este caso, la celda objetivo en s√≠ misma puede volverse susceptible a la erosi√≥n, pero esta situaci√≥n se resuelve cuando verificamos a los vecinos de la celda reci√©n erosionada.</font></font><br><br><pre> <code class="cs hljs"> HexCell cell = erodibleCells[index]; HexCell targetCell = GetErosionTarget(cell); cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; targetCell.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde que elevamos la celda objetivo, parte de los vecinos de esta celda ya no pueden estar sujetos a la erosi√≥n. </font><font style="vertical-align: inherit;">Es necesario rodearlos y verificar si son propensos a la erosi√≥n. </font><font style="vertical-align: inherit;">Si no, pero est√°n en la lista, debe eliminarlos de ella.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d71/84f/0b4/d7184f0b4a2dd34853b56e0024ef2b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% de erosi√≥n mientras se mantiene la masa de la tierra. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La erosi√≥n ahora puede suavizar el terreno mucho mejor, bajando algunas √°reas y elevando otras. </font><font style="vertical-align: inherit;">Como resultado, la masa de tierra puede aumentar y reducirse. </font><font style="vertical-align: inherit;">Esto puede cambiar el porcentaje de tierra en varios por ciento en una direcci√≥n u otra, pero rara vez se producen desviaciones graves. </font><font style="vertical-align: inherit;">Es decir, cuanto m√°s erosi√≥n apliquemos, menos control tendremos sobre el porcentaje resultante de tierra.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erosi√≥n acelerada </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque no necesitamos preocuparnos realmente por la efectividad del algoritmo de erosi√≥n, podemos hacer mejoras simples. </font><font style="vertical-align: inherit;">Primero, tenga en cuenta que verificamos expl√≠citamente si la celda que erosionamos puede ser erosionada. </font><font style="vertical-align: inherit;">Si no, esencialmente lo eliminamos de la lista. </font><font style="vertical-align: inherit;">Por lo tanto, puede omitir la comprobaci√≥n de esta celda al atravesar los vecinos de la celda de destino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En segundo lugar, necesit√°bamos verificar a los vecinos de la celda objetivo solo cuando hab√≠a una ruptura entre ellos, pero ahora esto no es necesario. </font><font style="vertical-align: inherit;">Esto solo ocurre cuando el vecino ahora est√° un paso m√°s arriba que la celda objetivo. </font><font style="vertical-align: inherit;">Si es as√≠, se garantiza que el vecino estar√° en la lista, por lo que no necesitamos verificar esto, es decir, podemos omitir la b√∫squeda innecesaria.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; neighbor.Elevation == targetCell.Elevation + <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !IsErodible(neighbor) <span class="hljs-comment"><span class="hljs-comment">// &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En tercer lugar, podemos usar un truco similar al verificar a los vecinos de una c√©lula propensa a la erosi√≥n. </font><font style="vertical-align: inherit;">Si ahora hay un acantilado entre ellos, entonces el vecino es propenso a la erosi√≥n. </font><font style="vertical-align: inherit;">Para averiguarlo, no necesitamos llamar </font></font><code>IsErodible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor.Elevation == cell.Elevation + <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, a√∫n debemos verificar si la celda objetivo es susceptible a la erosi√≥n, pero el ciclo que se muestra arriba ya no lo hace. </font><font style="vertical-align: inherit;">Por lo tanto, realizamos esto expl√≠citamente para la celda objetivo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(targetCell) &amp;&amp; !erodibleCells.Contains(targetCell)) { erodibleCells.Add(targetCell); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos aplicar la erosi√≥n lo suficientemente r√°pido y al porcentaje deseado en relaci√≥n con el n√∫mero inicial de acantilados generados. </font><font style="vertical-align: inherit;">Tenga en cuenta que debido al hecho de que cambiamos ligeramente el lugar donde se agrega la celda objetivo a la lista propensa a la erosi√≥n, el resultado ha cambiado ligeramente del resultado antes de las optimizaciones.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/a0d/71e/4a6a0d71eea3d1ef119b2f4f984a9b99.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28d/979/289/28d9792899367fdccb50f36b79801935.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7af/921/6af/7af9216af64111dbe0c15898db4560ce.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31b/7d9/ae5/31b7d9ae505297269bbd5442fdff17c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25%, 50%, 75% y 100% de erosi√≥n. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n tenga en cuenta que a pesar de la forma cambiada de la costa, la topolog√≠a no ha cambiado fundamentalmente. </font><font style="vertical-align: inherit;">Las masas de tierra generalmente permanecen conectadas o separadas. </font><font style="vertical-align: inherit;">Solo las islas peque√±as pueden ahogarse por completo. </font><font style="vertical-align: inherit;">Los detalles en relieve se suavizan, pero las formas generales siguen siendo las mismas. </font><font style="vertical-align: inherit;">Una articulaci√≥n estrecha puede desaparecer o crecer un poco. </font><font style="vertical-align: inherit;">Un peque√±o espacio puede llenarse o expandirse ligeramente. </font><font style="vertical-align: inherit;">Por lo tanto, la erosi√≥n no se adherir√° fuertemente a las regiones divididas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cd/c53/824/2cdc53824832438c924e2832d9759b06.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuatro regiones completamente erosionadas a√∫n permanecen separadas. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 25: El ciclo del agua </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mostrar datos de mapa sin procesar. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Formamos un clima de c√©lulas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crea una simulaci√≥n parcial del ciclo del agua. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta parte agregaremos humedad en tierra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este tutorial fue creado en Unity 2017.3.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/fbe/dae/2aefbedae7b2c65cd86bbd2b4ccc3050.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos el ciclo del agua para determinar los biomas.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Las nubes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta este punto, el algoritmo de generaci√≥n de mapas cambi√≥ solo la altura de la celda. </font><font style="vertical-align: inherit;">La mayor diferencia entre las c√©lulas era si estaban encima o debajo del agua. </font><font style="vertical-align: inherit;">Aunque podemos definir diferentes tipos de terreno, esto es solo una simple visualizaci√≥n de la altura. </font><font style="vertical-align: inherit;">Ser√° mejor especificar los tipos de alivio, dado el clima local. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El clima de la Tierra es un sistema muy complejo. </font><font style="vertical-align: inherit;">Afortunadamente, no necesitamos crear simulaciones clim√°ticas realistas. </font><font style="vertical-align: inherit;">Necesitaremos algo que parezca lo suficientemente natural. </font><font style="vertical-align: inherit;">El aspecto m√°s importante del clima es el ciclo del agua, porque la flora y la fauna necesitan agua l√≠quida para sobrevivir. </font><font style="vertical-align: inherit;">La temperatura tambi√©n es muy importante, pero por ahora, nos enfocamos en el agua, esencialmente dejando la temperatura global constante y cambiando solo la humedad.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El ciclo del agua describe el movimiento del agua en el medio ambiente. </font><font style="vertical-align: inherit;">En pocas palabras, los estanques se evaporan, lo que conduce a la creaci√≥n de nubes que llueven, que nuevamente fluye hacia los estanques. </font><font style="vertical-align: inherit;">Hay muchos m√°s aspectos del sistema, pero simular estos pasos ya puede ser suficiente para crear una distribuci√≥n natural del agua en el mapa.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualizaci√≥n de datos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de entrar en esta simulaci√≥n, ser√° √∫til ver directamente los datos relevantes. </font><font style="vertical-align: inherit;">Para hacer esto, cambiaremos el sombreador de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Le agregamos una propiedad conmutable, que se puede cambiar al modo de visualizaci√≥n de datos, que muestra datos de mapas sin procesar en lugar de las texturas de relieve habituales. </font><font style="vertical-align: inherit;">Esto se puede implementar utilizando una propiedad flotante con un atributo conmutable que define la palabra clave. </font><font style="vertical-align: inherit;">Debido a esto, aparecer√° en el inspector de materiales como una bandera que controla la definici√≥n de una palabra clave. </font><font style="vertical-align: inherit;">El nombre de la propiedad en s√≠ no es importante, solo nos interesa la palabra clave. </font><font style="vertical-align: inherit;">Estamos utilizando </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHOW_MAP_DATA</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) _BackgroundColor (<span class="hljs-string"><span class="hljs-string">"Background Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) [Toggle(SHOW_MAP_DATA)] _ShowMapData (<span class="hljs-string"><span class="hljs-string">"Show Map Data"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/32b/3e0/45232b3e0a72da1320457492c006613c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambie para mostrar los datos del mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue una funci√≥n de sombreador para habilitar el soporte de palabras clave.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ GRID_ON #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ HEX_MAP_EDIT_MODE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> shader_feature SHOW_MAP_DATA</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haremos que muestre un √∫nico flotador, como es el caso con el resto de los datos de alivio. </font><font style="vertical-align: inherit;">Para implementar esto, agregaremos un </font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo </font><font style="vertical-align: inherit;">a la estructura </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando se defina la palabra clave.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">struct</span></span> Input { <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> color : COLOR; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> worldPos; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> terrain; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> visibility; <span class="hljs-comment"><span class="hljs-comment">#if defined(SHOW_MAP_DATA) float mapData; #endif };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el programa de v√©rtices, usamos el canal Z de estas celdas para completar </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como siempre interpolado entre celdas.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inout appdata_full v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Input data</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(SHOW_MAP_DATA) data.mapData = cell0.z * v.color.x + cell1.z * v.color.y + cell2.z * v.color.z; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando necesite mostrar datos de celdas, √∫selos directamente como un fragmento de albedo en lugar del color habitual. </font><font style="vertical-align: inherit;">Multipl√≠quelo por la cuadr√≠cula para que la cuadr√≠cula todav√≠a est√© activada al representar los datos.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { ‚Ä¶ o.Albedo = c.rgb * grid * _Color * explored; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(SHOW_MAP_DATA) o.Albedo = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.mapData * grid; #endif ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para transferir datos a un sombreador. </font><font style="vertical-align: inherit;">necesitamos agregar al </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo que escribe algo en el canal de datos de textura azul. </font><font style="vertical-align: inherit;">Los datos son un valor flotante √∫nico limitado a 0-1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">255f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span>); enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, esta decisi√≥n afecta el sistema de investigaci√≥n. </font><font style="vertical-align: inherit;">Se utiliza un valor de datos de canal azul 255 para indicar que la visibilidad de la celda est√° en transici√≥n. </font><font style="vertical-align: inherit;">Para que este sistema contin√∫e funcionando, necesitamos utilizar el valor de byte 254 como m√°ximo. Tenga en cuenta que el movimiento del destacamento borrar√° todos los datos de la tarjeta, pero esto nos conviene, ya que se utilizan para depurar la generaci√≥n de tarjetas.</font></font><br><br><pre> <code class="cs hljs"> cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">254f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">254</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un m√©todo con el mismo nombre y en </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Transferir√° la solicitud a sus datos de sombreador.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { ShaderData.SetMapData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para verificar el funcionamiento del c√≥digo, c√°mbielo </font></font><code>HexMapGenerator.SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que establezca los datos de cada celda del mapa. </font><font style="vertical-align: inherit;">Visualicemos la altura convertida de entero a flotante en el intervalo 0-1. </font><font style="vertical-align: inherit;">Esto se hace restando la altura m√≠nima de la altura de la celda, seguido de dividir por la altura m√°xima menos el m√≠nimo. </font><font style="vertical-align: inherit;">Hagamos la divisi√≥n en coma flotante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ cell.SetMapData( (cell.Elevation - elevationMinimum) / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(elevationMaximum - elevationMinimum) ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos cambiar entre el terreno normal y la visualizaci√≥n de datos utilizando la </font><font style="vertical-align: inherit;">casilla de verificaci√≥n </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mostrar datos del mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del activo de material del </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/577/473/f28/577473f28d08f986124e6459a13a3714.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/c8a/85a/d60c8a85ae315fd509a4f6451629d8dc.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa 1208905299, terreno normal y visualizaci√≥n de alturas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creaci√≥n del clima </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para simular el clima, necesitamos rastrear los datos clim√°ticos. </font><font style="vertical-align: inherit;">Dado que el mapa consta de celdas discretas, cada una de ellas tiene su propio clima local. </font><font style="vertical-align: inherit;">Cree una estructura </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para almacenar todos los datos relevantes. </font><font style="vertical-align: inherit;">Por supuesto, puede agregar datos a las celdas, pero los usaremos solo cuando generemos el mapa. </font><font style="vertical-align: inherit;">Por lo tanto, los guardaremos por separado. </font><font style="vertical-align: inherit;">Esto significa que podemos definir esta estructura internamente </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como </font></font><code>MapRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Comenzaremos solo rastreando nubes, que pueden implementarse usando un solo campo flotante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregue una lista para rastrear los datos clim√°ticos de todas las celdas. </font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora necesitamos un m√©todo para crear un mapa clim√°tico. </font><font style="vertical-align: inherit;">Deber√≠a comenzar borrando la lista de zonas clim√°ticas y luego agregar un elemento para cada celda. </font><font style="vertical-align: inherit;">Los datos clim√°ticos iniciales son simplemente cero, esto se puede lograr utilizando un constructor est√°ndar </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El clima debe crearse despu√©s de la exposici√≥n a la erosi√≥n de la tierra antes de establecer los tipos de alivio. </font><font style="vertical-align: inherit;">En realidad, la erosi√≥n es causada principalmente por el movimiento del aire y el agua, que son parte del clima, pero no simularemos esto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); SetTerrainType(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambie </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que podamos ver los datos de la nube en lugar de la altura de la celda. </font><font style="vertical-align: inherit;">Inicialmente, se ver√° como una tarjeta negra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ cell.SetMapData(climate[i].clouds); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Clima cambiante </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primer paso en la simulaci√≥n clim√°tica es la evaporaci√≥n. </font><font style="vertical-align: inherit;">¬øCu√°nta agua debe evaporarse? </font><font style="vertical-align: inherit;">Controlemos este valor usando el control deslizante. </font><font style="vertical-align: inherit;">Un valor de 0 significa que no hay evaporaci√≥n, 1 - evaporaci√≥n m√°xima. </font><font style="vertical-align: inherit;">Por defecto, usamos 0.5.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6af/d8e/ae8/6afd8eae8a1bbb6be361c29d32cc5b99.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante de evaporaci√≥n. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creemos otro m√©todo espec√≠ficamente para dar forma al clima de una celda. </font><font style="vertical-align: inherit;">Le damos el √≠ndice de celda como par√°metro y lo usamos para obtener la celda correspondiente y sus datos clim√°ticos. </font><font style="vertical-align: inherit;">Si la celda est√° bajo el agua, entonces estamos tratando con un dep√≥sito que debe evaporarse. </font><font style="vertical-align: inherit;">Inmediatamente convertimos el vapor en nubes (ignorando los puntos de roc√≠o y la condensaci√≥n), por lo que agregaremos directamente la evaporaci√≥n al valor de las nubes celulares. </font><font style="vertical-align: inherit;">Cuando haya terminado con esto, copie los datos clim√°ticos nuevamente a la lista.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvolveClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellIndex</span></span></span><span class="hljs-function">)</span></span> { HexCell cell = grid.GetCell(cellIndex); ClimateData cellClimate = climate[cellIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } climate[cellIndex] = cellClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llame a este m√©todo para cada celda en </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero esto no es suficiente. </font><font style="vertical-align: inherit;">Para crear una simulaci√≥n compleja, necesitamos dar forma al clima de las c√©lulas varias veces. </font><font style="vertical-align: inherit;">Cuanto m√°s lo hagamos, mejor ser√° el resultado. </font><font style="vertical-align: inherit;">Simplemente elijamos un valor constante. </font><font style="vertical-align: inherit;">Yo uso 40 ciclos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dado que solo aumentamos el valor de las nubes sobre las celdas inundadas con agua, como resultado obtenemos tierra negra y dep√≥sitos blancos. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/e1c/5dc/3e7e1c5dc9ce75197a94e8ffcd6d8275.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evaporaci√≥n sobre el agua.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dispersi√≥n de nubes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las nubes no est√°n constantemente en un lugar, especialmente cuando se evapora m√°s y m√°s agua. </font><font style="vertical-align: inherit;">La diferencia de presi√≥n hace que el aire se mueva, lo que se manifiesta en forma de viento, lo que tambi√©n hace que las nubes se muevan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si no hay una direcci√≥n dominante del viento, entonces, en promedio, las nubes de las c√©lulas se dispersar√°n uniformemente en todas las direcciones, apareciendo en las c√©lulas vecinas. </font><font style="vertical-align: inherit;">Al generar nuevas nubes en el pr√≥ximo ciclo, distribuyamos todas las nubes en la celda en sus vecinos. </font><font style="vertical-align: inherit;">Es decir, cada vecino recibe un sexto de las nubes celulares, despu√©s de lo cual hay una disminuci√≥n local a cero.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>; climate[cellIndex] = cellClimate;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para agregar nubes a sus vecinos, debe rodearlos en un bucle, obtener sus datos clim√°ticos, aumentar el valor de las nubes y copiarlos nuevamente en la lista. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; climate[neighbor.Index] = neighborClimate; } cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6a/0e3/437/e6a0e34379d984582c020fde8f1db546.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nubes dispersas.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esto crea un mapa casi blanco, porque en cada ciclo, las c√©lulas submarinas agregan m√°s y m√°s nubes al clima global. Despu√©s del primer ciclo, las c√©lulas terrestres pr√≥ximas al agua tambi√©n tendr√°n nubes que deben dispersarse. Este proceso contin√∫a hasta que la mayor parte del mapa est√° cubierto de nubes. En el caso del mapa 1208905299 con los par√°metros predeterminados, solo la parte interior de la gran masa de tierra en el noreste permaneci√≥ completamente descubierta.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que los estanques pueden generar un n√∫mero infinito de nubes. </font><font style="vertical-align: inherit;">El nivel del agua no es parte de la simulaci√≥n clim√°tica. </font><font style="vertical-align: inherit;">En realidad, los reservorios se conservan solo porque el agua fluye hacia ellos aproximadamente a la velocidad de evaporaci√≥n. </font><font style="vertical-align: inherit;">Es decir, solo simulamos un ciclo parcial del agua. </font><font style="vertical-align: inherit;">Esto es normal, pero debemos entender que cuanto m√°s tiempo tenga lugar la simulaci√≥n, m√°s agua se agrega al clima. </font><font style="vertical-align: inherit;">Hasta ahora, la p√©rdida de agua ocurre solo en los bordes del mapa, donde las nubes dispersas se pierden debido a la falta de vecinos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede ver la p√©rdida de agua en la parte superior del mapa, especialmente en las celdas en la parte superior derecha. </font><font style="vertical-align: inherit;">En la √∫ltima celda no hay nubes en absoluto, porque sigue siendo la √∫ltima en la que se forma el clima. </font><font style="vertical-align: inherit;">Todav√≠a no ha recibido nubes de un vecino.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNo deber√≠a formarse el clima de todas las c√©lulas en paralelo?</font></font></b> <div class="spoiler_text"> ,        .    -              ,         .   40    . -      ,       . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Precipitaci√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El agua no permanece fr√≠a para siempre. En alg√∫n momento, deber√≠a caer al suelo otra vez. Esto generalmente ocurre en forma de lluvia, pero a veces puede ser nieve, granizo o nieve h√∫meda. Todo esto generalmente se llama precipitaci√≥n. La magnitud y la tasa de desaparici√≥n de las nubes var√≠an mucho, pero solo usamos una tasa de lluvia global personalizada. Un valor de 0 significa que no hay precipitaci√≥n, un valor de 1 significa que todas las nubes desaparecen instant√°neamente. El valor predeterminado es 0.25. Esto significa que en cada ciclo desaparecer√° una cuarta parte de las nubes.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitationFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/762/37d/f9076237d0673301af34c32f5cd6688a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante del coeficiente de precipitaci√≥n. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simularemos precipitaci√≥n despu√©s de la evaporaci√≥n y antes de la dispersi√≥n de las nubes. </font><font style="vertical-align: inherit;">Esto significar√° que parte del agua evaporada de los dep√≥sitos precipita inmediatamente, por lo que disminuye el n√∫mero de nubes dispersas. </font><font style="vertical-align: inherit;">Sobre la tierra, la precipitaci√≥n conducir√° a la desaparici√≥n de las nubes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e3/f11/46a/4e3f1146a761d1525e6a9349ff715bbb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nubes que desaparecen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, cuando destruimos el 25% de las nubes en cada ciclo, la tierra vuelve a ser casi negra. </font><font style="vertical-align: inherit;">Las nubes logran moverse tierra adentro solo unos pocos pasos, despu√©s de lo cual se vuelven invisibles. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Humedad </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque la lluvia destruye las nubes, no deber√≠an eliminar el agua del clima. </font><font style="vertical-align: inherit;">Despu√©s de caer al suelo, el agua se guarda, solo en un estado diferente. </font><font style="vertical-align: inherit;">Puede existir en muchas formas, que generalmente consideraremos humedad.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seguimiento de la humedad </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos a mejorar el modelo clim√°tico mediante el seguimiento de dos condiciones del agua: nubes y humedad. </font><font style="vertical-align: inherit;">Para implementar esto, agregue en el </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo </font></font><code>moisture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds, moisture; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En su forma m√°s generalizada, la evaporaci√≥n es el proceso de convertir la humedad en nubes, al menos en nuestro modelo clim√°tico simple. </font><font style="vertical-align: inherit;">Esto significa que la evaporaci√≥n no debe ser un valor constante, sino otro factor. </font><font style="vertical-align: inherit;">Por lo tanto, realizamos refactorizaci√≥n-cambio de nombre </font></font><code>evaporation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>evaporationFactor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporationFactor = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando la celda est√° bajo el agua, simplemente anunciamos que el nivel de humedad es 1. Esto significa que la evaporaci√≥n es igual al coeficiente de evaporaci√≥n. </font><font style="vertical-align: inherit;">Pero ahora tambi√©n podemos evaporarnos de las celdas de sushi. </font><font style="vertical-align: inherit;">En este caso, necesitamos calcular la evaporaci√≥n, restarla de la humedad y agregar el resultado a las nubes. </font><font style="vertical-align: inherit;">Despu√©s de eso, la precipitaci√≥n se agrega a la humedad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; cellClimate.clouds += evaporationFactor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = cellClimate.moisture * evaporationFactor; cellClimate.moisture -= evaporation; cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que las nubes ahora est√°n respaldadas por la evaporaci√≥n desde la tierra, podemos moverlas m√°s tierra adentro. </font><font style="vertical-align: inherit;">Ahora la mayor parte de la tierra se ha vuelto gris.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/94f/c71/a0b94fc71728a012254059d760bf47f3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nubes con evaporaci√≥n de humedad. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambi√©moslo </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que muestre humedad en lugar de nubes, porque lo usaremos para determinar los tipos de alivio.</font></font><br><br><pre> <code class="cs hljs"> cell.SetMapData(climate[i].moisture);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cf/78f/d30/3cf78fd3099cf1b3a75befb8ebb0893d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pantalla de humedad. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este punto, la humedad se ve bastante similar a las nubes (excepto que todas las c√©lulas submarinas son blancas), pero eso cambiar√° pronto.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escorrent√≠a de lluvia </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La evaporaci√≥n no es la √∫nica forma en que la humedad puede salir de la c√©lula. </font><font style="vertical-align: inherit;">El ciclo del agua nos dice que la mayor parte de la humedad agregada a la tierra de alguna manera termina en el agua. </font><font style="vertical-align: inherit;">El proceso m√°s notable es el flujo de agua sobre la tierra bajo la influencia de la gravedad. </font><font style="vertical-align: inherit;">No simularemos r√≠os reales, pero usaremos un coeficiente de escorrent√≠a de lluvia personalizado. </font><font style="vertical-align: inherit;">Indicar√° el porcentaje de agua que drena a las √°reas m√°s bajas. </font><font style="vertical-align: inherit;">Por defecto, el stock ser√° igual al 25%.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoffFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c85/e81/648/c85e8164833b60299f80bba99c11be81.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante de drenaje.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNo vamos a generar r√≠os?</font></font></b> <div class="spoiler_text">          . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La escorrent√≠a del agua act√∫a como una dispersi√≥n de nubes, pero con tres diferencias. En primer lugar, no se elimina toda la humedad de la c√©lula. En segundo lugar, lleva humedad, no nubes. En tercer lugar, baja, es decir, solo a los vecinos con una altura m√°s baja. El coeficiente de escorrent√≠a describe la cantidad de humedad que se derramar√≠a de la celda si todos los vecinos fueran m√°s bajos, pero a menudo son menos. Esto significa que reduciremos la humedad de la celda solo cuando encontremos un vecino debajo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a25/c41/00b/a25c4100bde5139415ebbf0a45068d0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agua que drena a una altura m√°s baja. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, tenemos una distribuci√≥n de humedad m√°s diversa, porque las c√©lulas altas transmiten su humedad a las bajas. </font><font style="vertical-align: inherit;">Tambi√©n vemos mucha menos humedad en las c√©lulas costeras, porque drenan la humedad en las c√©lulas submarinas. </font><font style="vertical-align: inherit;">Para debilitar este efecto, tambi√©n necesitamos usar el nivel del agua para determinar si la celda es m√°s baja, es decir, tomar la altura aparente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/ee9/64d/651ee964da5a422bfaa94f27609a5dcd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usa la altura visible.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Filtraci√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El agua no solo fluye hacia abajo, se extiende, se filtra a trav√©s de la topograf√≠a llana, y es absorbida por la tierra adyacente a los cuerpos de agua. </font><font style="vertical-align: inherit;">Este efecto puede tener poco efecto, pero es √∫til para suavizar la distribuci√≥n de humedad, as√≠ que vamos a agregarlo a la simulaci√≥n. </font><font style="vertical-align: inherit;">Creemos su propio coeficiente personalizado, por defecto igual a 0.125.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepageFactor = <span class="hljs-number"><span class="hljs-number">0.125f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/495/855/b73/495855b73d4601ab3de00b3561285491.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante de fugas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La filtraci√≥n es similar a un drenaje, excepto que se usa cuando el vecino tiene la misma altura visible que la celda misma.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepage = cellClimate.moisture * seepageFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= seepage; neighborClimate.moisture += seepage; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d39/7b2/b01/d397b2b01ad8e71137b9e5fa03fcf5a5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se agreg√≥ una peque√±a fuga. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombras de lluvia </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque ya hemos creado una simulaci√≥n digna del ciclo del agua, no parece muy interesante, ya que no tiene sombras de lluvia, lo que demuestra claramente las diferencias clim√°ticas. </font><font style="vertical-align: inherit;">Las sombras de lluvia son √°reas en las que hay una falta significativa de lluvia en comparaci√≥n con las √°reas vecinas. </font><font style="vertical-align: inherit;">Tales √°reas existen porque las monta√±as evitan que las nubes las alcancen. </font><font style="vertical-align: inherit;">Su creaci√≥n requiere altas monta√±as y una direcci√≥n dominante del viento.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El viento </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos agregando una direcci√≥n dominante del viento a la simulaci√≥n. </font><font style="vertical-align: inherit;">Aunque las direcciones dominantes del viento var√≠an mucho en la superficie de la Tierra, nos las arreglaremos con una direcci√≥n del viento global personalizable. </font><font style="vertical-align: inherit;">Usemos el noroeste por defecto. </font><font style="vertical-align: inherit;">Adem√°s, hagamos que la fuerza del viento sea ajustable de 1 a 10 con un valor predeterminado de 4.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection windDirection = HexDirection.NW; [Range(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> windStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/4a1/49c/f324a149c360bbfde72e98b4877afb37.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La direcci√≥n y la fuerza del viento. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fuerza del viento dominante se expresa en relaci√≥n con la dispersi√≥n total de las nubes. </font><font style="vertical-align: inherit;">Si la fuerza del viento es 1, la dispersi√≥n es la misma en todas las direcciones. </font><font style="vertical-align: inherit;">Cuando es 2, la dispersi√≥n es dos m√°s alta en la direcci√≥n del viento que en otras direcciones, y as√≠ sucesivamente. </font><font style="vertical-align: inherit;">Podemos hacer esto cambiando el divisor en la f√≥rmula de dispersi√≥n de la nube. </font><font style="vertical-align: inherit;">En lugar de seis, ser√° igual a cinco m√°s energ√≠a e√≥lica.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, la direcci√≥n del viento determina la direcci√≥n desde la cual sopla el viento. </font><font style="vertical-align: inherit;">Por lo tanto, necesitamos usar la direcci√≥n opuesta como la direcci√≥n principal de dispersi√≥n.</font></font><br><br><pre> <code class="cs hljs"> HexDirection mainDispersalDirection = windDirection.Opposite(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos verificar si el vecino est√° en la direcci√≥n principal de dispersi√≥n. </font><font style="vertical-align: inherit;">Si es as√≠, entonces debemos multiplicar la dispersi√≥n de las nubes por la fuerza del viento.</font></font><br><br><pre> <code class="cs hljs"> ClimateData neighborClimate = climate[neighbor.Index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d == mainDispersalDirection) { neighborClimate.clouds += cloudDispersal * windStrength; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { neighborClimate.clouds += cloudDispersal; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/874/2d5/e7e8742d53033ee4ee89f68e60871426.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viento del noroeste, fuerza 4.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El viento dominante agrega direccionalidad a la distribuci√≥n de humedad sobre la tierra. </font><font style="vertical-align: inherit;">Cuanto m√°s fuerte es el viento, m√°s poderoso se vuelve el efecto.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Altura absoluta </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El segundo ingrediente para obtener sombras de lluvia son las monta√±as. No tenemos una clasificaci√≥n estricta de lo que es una monta√±a, as√≠ como la naturaleza tampoco la tiene. Solo la altura absoluta es importante. De hecho, cuando el aire se mueve sobre la monta√±a, se ve obligado a elevarse, se enfr√≠a y puede contener menos agua, lo que conduce a la precipitaci√≥n antes de que el aire pase sobre la monta√±a. Como resultado, del otro lado obtenemos aire seco, es decir, una sombra de lluvia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo m√°s importante, cuanto m√°s alto sube el aire, menos agua puede contener. </font><font style="vertical-align: inherit;">En nuestra simulaci√≥n, podemos imaginar esto como una restricci√≥n forzada del valor m√°ximo de nube para cada celda. </font><font style="vertical-align: inherit;">Cuanto mayor sea la altura de la celda visible, menor deber√≠a ser este m√°ximo. </font><font style="vertical-align: inherit;">La forma m√°s f√°cil de hacer esto es establecer el m√°ximo en 1 menos la altura aparente, dividido por la altura m√°xima. </font><font style="vertical-align: inherit;">Pero, de hecho, dividamos por un m√°ximo de menos 1. Esto permitir√° que una peque√±a fracci√≥n de las nubes atraviese incluso las celdas m√°s altas. </font><font style="vertical-align: inherit;">Asignamos este m√°ximo despu√©s de calcular la precipitaci√≥n y antes de la dispersi√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); HexDirection mainDispersalDirection = windDirection.Opposite();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si como resultado obtenemos m√°s nubes de lo aceptable, simplemente convertimos el exceso de nubes en humedad. </font><font style="vertical-align: inherit;">De hecho, as√≠ es como agregamos precipitaciones adicionales, como sucede en monta√±as reales.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellClimate.clouds &gt; cloudMaximum) { cellClimate.moisture += cellClimate.clouds - cloudMaximum; cellClimate.clouds = cloudMaximum; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/998/c36/403998c36a6d85250f837766a4f33147.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sombras de lluvia causadas por la gran altitud. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Completamos la simulaci√≥n </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta etapa, ya tenemos una simulaci√≥n parcial de muy alta calidad del ciclo del agua. </font><font style="vertical-align: inherit;">Vamos a ponerlo en orden un poco y luego aplicarlo para determinar el tipo de alivio de las c√©lulas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Computaci√≥n paralela </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como se mencion√≥ anteriormente bajo el spoiler, el orden en que se forman las celdas afecta el resultado de la simulaci√≥n. </font><font style="vertical-align: inherit;">Idealmente, esto no deber√≠a ser y, en esencia, formamos todas las c√©lulas en paralelo. </font><font style="vertical-align: inherit;">Esto se puede hacer aplicando todos los cambios de la etapa actual de formaci√≥n a la segunda lista de clima </font></font><code>nextClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;(); List&lt;ClimateData&gt; nextClimate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Borre e inicialice esta lista, como todos los dem√°s. </font><font style="vertical-align: inherit;">Luego intercambiaremos listas en cada ciclo. </font><font style="vertical-align: inherit;">En este caso, la simulaci√≥n utilizar√° alternativamente las dos listas y aplicar√° los datos clim√°ticos actuales y futuros.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); nextClimate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(initialData); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } List&lt;ClimateData&gt; swap = climate; climate = nextClimate; nextClimate = swap; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cuando una c√©lula afecta el clima de su vecino, debemos cambiar los siguientes datos clim√°ticos, no el actual. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = nextClimate[neighbor.Index]; ‚Ä¶ nextClimate[neighbor.Index] = neighborClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y en lugar de copiar los siguientes datos clim√°ticos a la lista clim√°tica actual, obtenemos los siguientes datos clim√°ticos, les agregamos la humedad actual y los copiamos a la siguiente lista. </font><font style="vertical-align: inherit;">Despu√©s de eso, restablecemos los datos en la lista actual para que se actualicen para el pr√≥ximo ciclo.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// cellClimate.clouds = 0f; ClimateData nextCellClimate = nextClimate[cellIndex]; nextCellClimate.moisture += cellClimate.moisture; nextClimate[cellIndex] = nextCellClimate; climate[cellIndex] = new ClimateData();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mientras hacemos esto, tambi√©n establezcamos el nivel de humedad en un m√°ximo de 1 para que las c√©lulas terrestres no puedan estar m√°s h√∫medas que bajo el agua. </font></font><br><br><pre> <code class="cs hljs"> nextCellClimate.moisture += cellClimate.moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextCellClimate.moisture &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { nextCellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } nextClimate[cellIndex] = nextCellClimate;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a8/709/87b/6a870987bfad51e91eaa1ff405be539d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computaci√≥n paralela.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Humedad original </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existe la posibilidad de que la simulaci√≥n produzca demasiada tierra seca, especialmente con un alto porcentaje de tierra. </font><font style="vertical-align: inherit;">Para mejorar la imagen, podemos agregar un nivel de humedad inicial personalizado con un valor predeterminado de 0.1.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startingMoisture = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/69b/3a2/db869b3a24627d695d9ec8bf2ba1f4ae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arriba est√° el control deslizante de la humedad original. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizamos este valor para la humedad de la lista clim√°tica inicial, pero no para lo siguiente.</font></font><br><br><pre> <code class="cs hljs"> ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); initialData.moisture = startingMoisture; ClimateData clearData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(clearData); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a74/138/649/a74138649fc141c088a631bce956a31a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con humedad original.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Definiendo biomas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concluimos usando humedad en lugar de altura para especificar el tipo de alivio celular. </font><font style="vertical-align: inherit;">Usemos nieve para tierras completamente secas, para regiones √°ridas usamos nieve, luego hay piedra, pasto para lo suficientemente h√∫medo y tierra para c√©lulas saturadas de agua y bajo el agua. </font><font style="vertical-align: inherit;">La forma m√°s f√°cil es usar cinco intervalos en incrementos de 0.2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.2f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.4f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.6f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.SetMapData(moisture); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/123/c53/e4f/123c53e4f3f79aa50437a553e0eb6761.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomas </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando se usa una distribuci√≥n uniforme, el resultado no es muy bueno y no parece natural. </font><font style="vertical-align: inherit;">Es mejor usar otros umbrales, por ejemplo 0.05, 0.12, 0.28 y 0.85.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.05f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.12f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.28f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.85f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ad/8cf/7c7/6ad8cf7c7becf357d16157ae28999a14.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomas modificados. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 26: biomas y r√≠os </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creamos los r√≠os que se originan a partir de celdas altas con humedad. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creamos un modelo de temperatura simple. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usamos la matriz de bioma para las c√©lulas y luego la cambiamos. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta parte, complementaremos el ciclo del agua con r√≠os y temperatura, as√≠ como asignaremos biomas m√°s interesantes a las c√©lulas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El tutorial fue creado usando Unity 2017.3.0p3.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/0b2/d11/3050b2d115d1ec49e2b6c945ab9ed4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El calor y el agua animan el mapa.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generaci√≥n fluvial </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los r√≠os son consecuencia del ciclo del agua. </font><font style="vertical-align: inherit;">De hecho, est√°n formados por escorrent√≠as que se rompen con la ayuda de la erosi√≥n del canal. </font><font style="vertical-align: inherit;">Esto implica que puede agregar r√≠os seg√∫n el valor de los drenajes celulares. </font><font style="vertical-align: inherit;">Sin embargo, esto no garantiza que obtendremos algo que se asemeje a r√≠os reales. </font><font style="vertical-align: inherit;">Cuando comencemos el r√≠o, tendr√° que fluir lo m√°s lejos posible, potencialmente a trav√©s de muchas celdas. </font><font style="vertical-align: inherit;">Esto no es consistente con nuestra simulaci√≥n del ciclo del agua, que procesa las c√©lulas en paralelo. </font><font style="vertical-align: inherit;">Adem√°s, generalmente es necesario controlar la cantidad de r√≠os en un mapa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como los r√≠os son muy diferentes, los generaremos por separado. </font><font style="vertical-align: inherit;">Utilizamos los resultados de la simulaci√≥n del ciclo del agua para determinar la ubicaci√≥n de los r√≠os, pero los r√≠os, a su vez, no afectar√°n la simulaci√≥n.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© el flujo del r√≠o a veces es incorrecto?</font></font></b> <div class="spoiler_text">    <code>TriangulateWaterShore</code>  ,    .      ,    .   ,    ,       .      ,  .    ,  ,       .         (¬´¬ª). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary( e1, e2, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction, indices ); } ‚Ä¶ }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Celdas de alta humedad </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En nuestros mapas, una celda puede o no tener un r√≠o. Adem√°s, pueden ramificarse o conectarse. En realidad, los r√≠os son mucho m√°s flexibles, pero tenemos que pasar con esta aproximaci√≥n, que crea solo r√≠os grandes. Lo m√°s importante, necesitamos determinar la ubicaci√≥n del comienzo de un r√≠o grande, que se elige al azar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como los r√≠os requieren agua, la fuente del r√≠o debe estar en una celda con alta humedad. Pero esto no es suficiente. Los r√≠os fluyen por las laderas, por lo que idealmente la fuente deber√≠a tener una gran altura. Cuanto mayor sea la celda por encima del nivel del agua, mejor candidato es para el papel de la fuente del r√≠o. Podemos visualizar esto como datos del mapa dividiendo la altura de la celda por la altura m√°xima. Para que el resultado se obtenga en relaci√≥n con el nivel del agua, lo restaremos de ambas alturas antes de dividirlo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f9/d80/2de/6f9d802de155c2b1e051be5d360dc3c1.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/e8f/6a2/f5ce8f6a20d7336dc94b89812c123827.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Humedad y altitud. Gran n√∫mero de mapa 1208905299 con la configuraci√≥n predeterminada.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los mejores candidatos son aquellas c√©lulas que tienen alta humedad y altura. Podemos combinar estos criterios multiplic√°ndolos. El resultado ser√° el valor de la condici√≥n f√≠sica o el peso de las fuentes de los r√≠os.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec2/31f/445/ec231f445d785c24c6cd9f191ed6c24a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesos para las fuentes de los r√≠os.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Idealmente, usar√≠amos estos pesos para rechazar la selecci√≥n aleatoria de la celda fuente. Aunque podemos crear una lista con los pesos correctos y elegir, este es un enfoque no trivial y ralentiza el proceso de generaci√≥n. Una clasificaci√≥n m√°s simple de importancia dividida en cuatro niveles ser√° suficiente para nosotros. Los primeros candidatos ser√°n pesos con valores superiores a 0,75. Los buenos candidatos tienen pesos de 0.5. Los candidatos elegibles son mayores que 0.25. Todas las dem√°s c√©lulas se descartan. Vamos a mostrar c√≥mo se ve gr√°ficamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">1f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(data);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/056/5ba/3b7/0565ba3b7a51499bfe1d389ecd270910.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Categor√≠as de pesos de las fuentes fluviales. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con este esquema de clasificaci√≥n, es probable que obtengamos r√≠os con fuentes en las √°reas m√°s altas y h√∫medas del mapa. </font><font style="vertical-align: inherit;">Sin embargo, la probabilidad de crear r√≠os en √°reas relativamente secas o bajas permanece, lo que aumenta la variabilidad. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un m√©todo </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que llene una lista de celdas seg√∫n estos criterios. </font><font style="vertical-align: inherit;">Las celdas elegibles se agregan a esta lista una vez, las buenas dos veces y las principales candidatas cuatro veces. </font><font style="vertical-align: inherit;">Las celdas submarinas siempre se descartan, por lo que no puede verificarlas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData data = climate[i]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> weight = data.moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { riverOrigins.Add(cell); riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { riverOrigins.Add(cell); } } ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este m√©todo debe llamarse despu√©s </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que los datos de humedad est√©n disponibles para nosotros.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); CreateRivers(); SetTerrainType(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Una vez completada la clasificaci√≥n, puede deshacerse de la visualizaci√≥n de sus datos en el mapa. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// float data = // moisture * (cell.Elevation - waterLevel) / // (elevationMaximum - waterLevel); // if (data &gt; 0.6f) { // cell.SetMapData(1f); // } // else if (data &gt; 0.4f) { // cell.SetMapData(0.5f); // } // else if (data &gt; 0.2f) { // cell.SetMapData(0.25f); // } } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puntos de r√≠o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°ntos r√≠os necesitamos? </font><font style="vertical-align: inherit;">Este par√°metro debe ser personalizable. </font><font style="vertical-align: inherit;">Dado que la longitud de los r√≠os var√≠a, ser√° m√°s l√≥gico controlarlo con la ayuda de puntos fluviales, que determinan la cantidad de celdas terrestres en las que deben estar contenidos los r√≠os. </font><font style="vertical-align: inherit;">Expres√©moslos como un porcentaje con un m√°ximo del 20% y un valor predeterminado del 10%. </font><font style="vertical-align: inherit;">Al igual que el porcentaje de sushi, este es un valor objetivo, no garantizado. </font><font style="vertical-align: inherit;">Como resultado, podemos tener muy pocos candidatos o r√≠os que sean demasiado cortos para cubrir la cantidad de tierra requerida. </font><font style="vertical-align: inherit;">Es por eso que el porcentaje m√°ximo no debe ser demasiado grande.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 20)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverPercentage = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/793/1c6/4cd/7931c64cd7bdffbb17f83a94aed1bbc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante por ciento de r√≠os. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para determinar los puntos de los r√≠os, expresados ‚Äã‚Äãcomo el n√∫mero de celdas, debemos recordar cu√°ntas celdas terrestres se generaron </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCount, landCells; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); landCells = landBudget; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); landCells -= landBudget; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el interior, la </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cantidad de puntos de r√≠o ahora se puede calcular de la misma manera que nosotros </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, continuaremos tomando y eliminando celdas aleatorias de la lista original, mientras todav√≠a tengamos puntos y celdas de origen. </font><font style="vertical-align: inherit;">En caso de completar el n√∫mero de puntos, mostraremos una advertencia en la consola.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up river budget."</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, agregamos un m√©todo para crear r√≠os directamente. </font><font style="vertical-align: inherit;">Como par√°metro, necesita una celda inicial y, una vez finalizado, debe devolver la longitud del r√≠o. </font><font style="vertical-align: inherit;">Comenzamos almacenando un m√©todo que devuelve longitud cero.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamaremos a este m√©todo al final del ciclo que acabamos de agregar </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, utilizando para reducir el n√∫mero de puntos restantes. </font><font style="vertical-align: inherit;">Nos aseguramos de que se cree un nuevo r√≠o solo si la celda seleccionada no tiene un r√≠o que fluya a trav√©s de √©l.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√≠os actuales </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es l√≥gico crear r√≠os que fluyan hacia el mar u otro cuerpo de agua. </font><font style="vertical-align: inherit;">Cuando comenzamos desde la fuente, obtenemos inmediatamente la longitud 1. Despu√©s de eso, seleccionamos un vecino aleatorio y aumentamos la longitud. </font><font style="vertical-align: inherit;">Continuamos movi√©ndonos hasta llegar a la celda submarina.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { HexDirection direction = (HexDirection)Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); cell.SetOutgoingRiver(direction); length += <span class="hljs-number"><span class="hljs-number">1</span></span>; cell = cell.GetNeighbor(direction); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/359/7cf/7a7/3597cf7a7ae263721b381534185e7645.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√≠os al azar. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado de un enfoque tan ingenuo, obtenemos fragmentos de r√≠os dispersos al azar, principalmente debido al reemplazo de r√≠os generados previamente. </font><font style="vertical-align: inherit;">Esto incluso puede conducir a errores, porque no verificamos si el vecino realmente existe. </font><font style="vertical-align: inherit;">Necesitamos verificar todas las direcciones en el bucle y asegurarnos de que haya un vecino all√≠. </font><font style="vertical-align: inherit;">Si es as√≠, entonces agregamos esta direcci√≥n a la lista de posibles direcciones de flujo, pero solo si el r√≠o a√∫n no fluye a trav√©s de este vecino. </font><font style="vertical-align: inherit;">Luego seleccione un valor aleatorio de esta lista.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexDirection&gt; flowDirections = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexDirection&gt;(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d); } HexDirection direction = <span class="hljs-comment"><span class="hljs-comment">// (HexDirection)Random.Range(0, 6); flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con este nuevo enfoque, podemos tener cero direcciones de flujo disponibles. </font><font style="vertical-align: inherit;">Cuando esto sucede, el r√≠o ya no puede fluir m√°s y debe terminar. </font><font style="vertical-align: inherit;">Si en este momento la longitud es 1, esto significa que no podr√≠amos escapar de la celda original, es decir, no puede haber ning√∫n r√≠o. </font><font style="vertical-align: inherit;">En este caso, la longitud del r√≠o es cero.</font></font><br><br><pre> <code class="cs hljs"> flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/5bd/05d/e6f5bd05d8d5a976d6fff9fa14397a25.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rios preservados.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Correr hacia abajo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora salvamos los r√≠os ya creados, pero a√∫n podemos obtener fragmentos aislados de los r√≠os. </font><font style="vertical-align: inherit;">Esto sucede porque mientras ignoramos las alturas. </font><font style="vertical-align: inherit;">Cada vez que forzamos el flujo del r√≠o a una altura mayor, </font></font><code>HexCell.SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interrumpimos este intento, lo que provoc√≥ rupturas en los r√≠os. </font><font style="vertical-align: inherit;">Por lo tanto, tambi√©n debemos omitir las direcciones que hacen que los r√≠os fluyan hacia arriba.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae6/cf7/696/ae6cf76968d64228e88378749939f1f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√≠os que fluyen hacia abajo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ que nos deshacemos de muchos fragmentos de r√≠os, pero a√∫n quedan algunos. </font><font style="vertical-align: inherit;">A partir de este momento, deshacerse de los r√≠os m√°s feos se convierte en una cuesti√≥n de refinamiento. </font><font style="vertical-align: inherit;">Para empezar, los r√≠os prefieren descender lo m√°s r√°pido posible. </font><font style="vertical-align: inherit;">No elegir√°n necesariamente la ruta m√°s corta posible, pero la probabilidad de que esto sea grande. </font><font style="vertical-align: inherit;">Para simular esto, agregaremos instrucciones tres veces a la lista.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } flowDirections.Add(d);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evite giros bruscos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s de fluir hacia abajo, el agua tambi√©n tiene inercia. </font><font style="vertical-align: inherit;">Es m√°s probable que un r√≠o fluya en l√≠nea recta o se doble ligeramente que en un giro brusco repentino. </font><font style="vertical-align: inherit;">Podemos agregar esta distorsi√≥n rastreando la √∫ltima direcci√≥n del r√≠o. </font><font style="vertical-align: inherit;">Si la direcci√≥n potencial de la corriente no se desv√≠a demasiado de esta direcci√≥n, agr√©guela nuevamente a la lista. </font><font style="vertical-align: inherit;">Esto no es un problema para la fuente, por lo que siempre lo agregaremos nuevamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; HexDirection direction = HexDirection.NE; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( length == <span class="hljs-number"><span class="hljs-number">1</span></span> || (d != direction.Next2() &amp;&amp; d != direction.Previous2()) ) { flowDirections.Add(d); } flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// HexDirection direction = direction = flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esto reduce en gran medida la probabilidad de que los r√≠os zigzagueen con un aspecto feo. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/83b/ce7/67483bce79b287f3cc451e381dc686d2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menos giros bruscos.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Confluencia fluvial </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A veces resulta que el r√≠o fluye justo al lado de la fuente del r√≠o creado anteriormente. </font><font style="vertical-align: inherit;">Si la fuente de este r√≠o no est√° a una altitud m√°s alta, entonces podemos decidir que el nuevo r√≠o desemboca en el antiguo. </font><font style="vertical-align: inherit;">Como resultado, obtenemos un r√≠o largo, y no dos vecinos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para hacer esto, dejaremos pasar al vecino solo si hay un r√≠o entrante o si es la fuente del r√≠o actual. </font><font style="vertical-align: inherit;">Habiendo determinado que esta direcci√≥n no est√° arriba, verificamos si hay un r√≠o saliente. </font><font style="vertical-align: inherit;">Si lo hay, encontramos nuevamente el viejo r√≠o. </font><font style="vertical-align: inherit;">Dado que esto ocurre con bastante poca frecuencia, no participaremos en la verificaci√≥n de otras fuentes vecinas e inmediatamente combinaremos los r√≠os.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor.HasRiver) { // continue; // } if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } if (neighbor.HasOutgoingRiver) { cell.SetOutgoingRiver(d); return length; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb3/820/ee6/bb3820ee6271b8bc7b32e901b39c906a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ba/d8f/08d/3bad8f08d23cfe3844ec259a1c2475d6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√≠os antes y despu√©s de la agrupaci√≥n.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mantener distancia </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que los buenos candidatos para el rol fuente generalmente se agrupan, obtendremos grupos de r√≠os. </font><font style="vertical-align: inherit;">Adem√°s, podemos tener r√≠os que toman la fuente justo al lado del embalse, lo que da como resultado r√≠os de longitud 1. Podemos distribuir las fuentes, descartando las que est√°n cerca del r√≠o o embalse. </font><font style="vertical-align: inherit;">Hacemos esto sin pasar por los vecinos de la fuente seleccionada en un bucle dentro </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si encontramos un vecino que viola las reglas, entonces la fuente no nos conviene y debemos omitirla.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = origin.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; (neighbor.HasRiver || neighbor.IsUnderwater)) { isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isValidOrigin) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y aunque los r√≠os seguir√°n fluyendo uno al lado del otro, tienden a cubrir un √°rea m√°s grande. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/bed/3a6/887bed3a6032b4bea508ee6ceda4a228.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/b85/428/f53b85428840118895d74f62b1c2d1a6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin distancia y con ello.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terminamos el rio con un lago </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No todos los r√≠os llegan al embalse, algunos quedan atrapados en los valles o son bloqueados por otros r√≠os. Este no es un problema particular, porque a menudo los r√≠os reales tambi√©n parecen desaparecer. Esto puede suceder, por ejemplo, si fluyen bajo tierra, se dispersan en un √°rea pantanosa o se secan. Nuestros r√≠os no pueden visualizar esto, por lo que simplemente terminan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, podemos intentar minimizar el n√∫mero de tales casos. Aunque no podemos unir los r√≠os o hacer que fluyan hacia arriba, podemos hacer que terminen en lagos, que a menudo se encuentran en la realidad y se ven bien. Para esto</font></font><code>CreateRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deber√≠a elevar el nivel del agua en la celda si se atasca. </font><font style="vertical-align: inherit;">La posibilidad de esto depende de la altura m√≠nima de los vecinos de esta celda. </font><font style="vertical-align: inherit;">Por lo tanto, para rastrear esto cuando se estudian vecinos, se requiere una peque√±a alteraci√≥n del c√≥digo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minNeighborElevation = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { // continue; // } if (!neighbor) { continue; } if (neighbor.Elevation &lt; minNeighborElevation) { minNeighborElevation = neighbor.Elevation; } if (neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } ‚Ä¶ } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si estamos atascados, primero debemos comprobar si todav√≠a estamos en la fuente. </font><font style="vertical-align: inherit;">En caso afirmativo, simplemente cancele el r√≠o. </font><font style="vertical-align: inherit;">De lo contrario, verificamos si todos los vecinos son al menos tan altos como la celda actual. </font><font style="vertical-align: inherit;">Si es as√≠, entonces podemos elevar el agua a este nivel. </font><font style="vertical-align: inherit;">Esto crear√° un lago a partir de una celda, a menos que la altura de la celda permanezca en el mismo nivel. </font><font style="vertical-align: inherit;">Si es as√≠, simplemente asigne la altura un nivel por debajo del nivel del agua.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// return length &gt; 1 ? length : 0; if (length == 1) { return 0; } if (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = minNeighborElevation; if (minNeighborElevation == cell.Elevation) { cell.Elevation = minNeighborElevation - 1; } } break; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/7da/964/d607da964da18b71cd022c997661695c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee8/ab1/000/ee8ab10002cd3e36cefbcfe3980a8fbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los extremos de r√≠os sin lagos y con lagos. </font><font style="vertical-align: inherit;">En este caso, el porcentaje de r√≠os es 20.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tenga en cuenta que ahora podemos tener c√©lulas submarinas por encima del nivel de agua utilizado para generar el mapa. </font><font style="vertical-align: inherit;">Denotar√°n lagos sobre el nivel del mar.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lagos adicionales </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n podemos crear lagos, incluso si no estamos atascados. </font><font style="vertical-align: inherit;">Esto puede resultar en un r√≠o que fluye dentro y fuera del lago. </font><font style="vertical-align: inherit;">Si no estamos atascados, se puede crear un lago elevando el nivel del agua y luego la altura actual de la celda, y luego reduciendo la altura de la celda. </font><font style="vertical-align: inherit;">Esto se aplica solo cuando la altura m√≠nima del vecino es al menos igual a la altura de la celda actual. </font><font style="vertical-align: inherit;">Hacemos esto al final del ciclo del r√≠o y antes de pasar a la siguiente celda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell = cell.GetNeighbor(direction); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/945/5bb/2b6/9455bb2b6547a8b1342e179f15eb5925.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f84/516/4b7/f845164b7a543b9549cd9f07d273e67f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin lagos adicionales y con ellos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Varios lagos son hermosos, pero sin l√≠mites podemos crear demasiados lagos. </font><font style="vertical-align: inherit;">Por lo tanto, agreguemos una probabilidad personalizada para lagos adicionales, con un valor predeterminado de 0.25.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> extraLakeProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ella controlar√° la probabilidad de generar un lago adicional, si es posible. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( minNeighborElevation &gt;= cell.Elevation &amp;&amp; Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; extraLakeProbability ) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa5/d04/bc3/fa5d04bc3f7475ec2baab7b6e7dac38f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/118/bb4/364/118bb4364acb0646efb54a031d3ac356.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lagos adicionales.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© hay de crear lagos con m√°s de una celda?</font></font></b> <div class="spoiler_text">     ,       ,  ,      .      .      :          .       ,       .  ,      ,     ,   . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2>  Temperatura </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El agua es solo uno de los factores que pueden determinar el bioma de una c√©lula. </font><font style="vertical-align: inherit;">Otro factor importante es la temperatura. </font><font style="vertical-align: inherit;">Aunque podemos simular el flujo y la difusi√≥n de temperaturas como la simulaci√≥n del agua, para crear un clima interesante, solo necesitamos un factor complejo. </font><font style="vertical-align: inherit;">Por lo tanto, mantengamos la temperatura simple y configur√©mosla para cada celda.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temperatura y latitud </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mayor influencia en la temperatura es la latitud. </font><font style="vertical-align: inherit;">Hace calor en el ecuador, fr√≠o en los polos y hay una transici√≥n suave entre ellos. </font><font style="vertical-align: inherit;">Creemos un m√©todo </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que devuelva la temperatura de una celda determinada. </font><font style="vertical-align: inherit;">Para comenzar, simplemente usamos la coordenada Z de la celda dividida por la dimensi√≥n Z como la latitud, y luego usamos este valor como la temperatura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> latitude; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definimos la temperatura en </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la usamos como datos del mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); cell.SetMapData(temperature); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/789/7f6/334/7897f63347b08fdb02ee5794f3ab28e3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latitud como temperatura, hemisferio sur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenemos un gradiente de temperatura lineal que aumenta de abajo hacia arriba. </font><font style="vertical-align: inherit;">Puede usarlo para simular el hemisferio sur, con un polo en la parte inferior y un ecuador en la parte superior. </font><font style="vertical-align: inherit;">Pero no necesitamos describir todo el hemisferio. </font><font style="vertical-align: inherit;">Con una diferencia de temperatura m√°s peque√±a o ninguna diferencia, podemos describir un √°rea m√°s peque√±a. </font><font style="vertical-align: inherit;">Para hacer esto, haremos que las temperaturas bajas y altas sean personalizables. </font><font style="vertical-align: inherit;">Estableceremos estas temperaturas en el rango 0-1, y utilizaremos los valores extremos como valores predeterminados.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lowTemperature = <span class="hljs-number"><span class="hljs-number">0f</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> highTemperature = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b1/8cf/805/3b18cf805a56a0dbbeabb03b69a00496.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deslizadores de temperatura. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplicamos el rango de temperatura usando interpolaci√≥n lineal, usando la latitud como interpolador. </font><font style="vertical-align: inherit;">Como expresamos la latitud como un valor de 0 a 1, podemos usarlo </font></font><code>Mathf.LerpUnclamped</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que las bajas temperaturas no son necesariamente m√°s bajas que las altas. </font><font style="vertical-align: inherit;">Si lo desea, puede entregarlos.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hemisferio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos simular el hemisferio sur, y posiblemente el hemisferio norte, si tomamos las temperaturas primero. </font><font style="vertical-align: inherit;">Pero es mucho m√°s conveniente usar una opci√≥n de configuraci√≥n separada para cambiar entre hemisferios. </font><font style="vertical-align: inherit;">Vamos a crear una enumeraci√≥n y un campo para ello. </font><font style="vertical-align: inherit;">Por lo tanto, tambi√©n agregaremos la opci√≥n de crear ambos hemisferios, que es aplicable por defecto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HemisphereMode { Both, North, South } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HemisphereMode hemisphere;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/c67/03f/be8c6703f51cd7c62535a96a3035a284.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La elecci√≥n del hemisferio. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si necesitamos el hemisferio norte, entonces simplemente podemos voltear la latitud, rest√°ndola de 1. Para simular ambos hemisferios, los polos deben estar debajo y encima del mapa, y el ecuador debe estar en el medio. </font><font style="vertical-align: inherit;">Puede hacer esto duplicando la latitud, mientras que el hemisferio inferior se procesar√° correctamente, y el superior tendr√° una latitud de 1 a 2. Para arreglar esto, restamos la latitud de 2 cuando excede 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.Both) { latitude *= <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latitude &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { latitude = <span class="hljs-number"><span class="hljs-number">2f</span></span> - latitude; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.North) { latitude = <span class="hljs-number"><span class="hljs-number">1f</span></span> - latitude; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c7/871/ede/9c7871ede0c56a393bc603ec888c65bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambos hemisferios. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vale la pena se√±alar que esto crea la posibilidad de crear un mapa ex√≥tico en el que el ecuador est√° fr√≠o y los polos est√°n calientes.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cuanto m√°s alto es el m√°s fr√≠o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s de la latitud, la temperatura tambi√©n se ve significativamente afectada por la altitud. </font><font style="vertical-align: inherit;">En promedio, cuanto m√°s subimos, m√°s fr√≠o se pone. </font><font style="vertical-align: inherit;">Podemos convertir esto en un factor, como hicimos con los candidatos del river. </font><font style="vertical-align: inherit;">En este caso, usamos la altura de la celda. </font><font style="vertical-align: inherit;">Adem√°s, este indicador disminuye con la altura, es decir, igual a 1 menos la altura dividida por el m√°ximo relativo al nivel del agua. </font><font style="vertical-align: inherit;">Para que el indicador en el nivel m√°s alto no caiga a cero, agregamos al divisor. </font><font style="vertical-align: inherit;">Luego use este indicador para escalar la temperatura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75e/a24/550/75ea24550d4325e2af45a1a9627cc53c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La altura afecta la temperatura.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fluctuaciones de temperatura </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos hacer que la simplicidad del gradiente de temperatura sea menos notable agregando fluctuaciones aleatorias de temperatura. </font><font style="vertical-align: inherit;">Una peque√±a posibilidad de hacerlo m√°s realista, pero con demasiada fluctuaci√≥n, se ver√°n arbitrarios. </font><font style="vertical-align: inherit;">Hagamos que el poder de las fluctuaciones de temperatura sea personalizable y expres√©moslo como la desviaci√≥n de temperatura m√°xima con un valor predeterminado de 0.1.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperatureJitter = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/e21/83f/27de2183fc453ded3c2902d4705cd1eb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante de fluctuaci√≥n de temperatura. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tales fluctuaciones deber√≠an ser suaves con ligeros cambios locales. </font><font style="vertical-align: inherit;">Puedes usar nuestra textura de ruido para esto. </font><font style="vertical-align: inherit;">Llamaremos </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y usaremos como argumento la posici√≥n de la celda, escalada en 0.1. </font><font style="vertical-align: inherit;">Tomemos el canal W, centremos y escalemos por el coeficiente de oscilaci√≥n. </font><font style="vertical-align: inherit;">Luego agregamos este valor a la temperatura calculada previamente.</font></font><br><br><pre> <code class="cs hljs"> temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); temperature += (HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>).w * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/490/92c/2c8/49092c2c88aaad00d5c54835c6511a74.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/7d9/3cd/dac7d93cdb115574c748269ffebb3d8d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluctuaciones de temperatura con valores de 0.1 y 1.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podemos agregar una ligera variabilidad a las fluctuaciones en cada mapa, eligiendo aleatoriamente de los cuatro canales de ruido. </font><font style="vertical-align: inherit;">Establezca el canal una vez </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y luego indexe los canales de color </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temperatureJitterChannel; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> jitter = HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>)[temperatureJitterChannel]; temperature += (jitter * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/e82/084/30ce820847299346ec8dfaf2bb6cf1a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferentes fluctuaciones de temperatura con fuerza m√°xima. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que tenemos datos sobre humedad y temperatura, podemos crear una matriz de bioma. </font><font style="vertical-align: inherit;">Al indexar esta matriz, podemos asignar biomas a todas las celdas, creando un paisaje m√°s complejo que usar solo una dimensi√≥n de datos.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matriz de bioma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existen muchos modelos clim√°ticos, pero no utilizaremos ninguno de ellos. Lo haremos muy simple, solo nos interesa la l√≥gica. Seco significa desierto (fr√≠o o calor), para ello utilizamos arena. Fr√≠o y h√∫medo significa nieve. Caliente y h√∫medo significa mucha vegetaci√≥n, es decir, hierba. Entre ellos tendremos una taiga o tundra, que designaremos como una textura gris√°cea de la tierra. Una matriz 4 √ó 4 ser√° suficiente para crear transiciones entre estos biomas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente, asignamos tipos de elevaci√≥n basados ‚Äã‚Äãen cinco intervalos de humedad. Simplemente bajamos la tira m√°s seca a 0.05 y guardamos el resto. Para las bandas de temperatura usamos 0.1, 0.3, 0.6 y m√°s. Por conveniencia, estableceremos estos valores en matrices est√°ticas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] temperatureBands = { <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] moistureBands = { <span class="hljs-number"><span class="hljs-number">0.12f</span></span>, <span class="hljs-number"><span class="hljs-number">0.28f</span></span>, <span class="hljs-number"><span class="hljs-number">0.85f</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque especificamos solo el tipo de relieve en funci√≥n del bioma, podemos usarlo para determinar otros par√°metros. </font><font style="vertical-align: inherit;">Por lo tanto, definamos en una </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estructura </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que describa la configuraci√≥n de un bioma individual. </font><font style="vertical-align: inherit;">Hasta ahora, contiene solo el √≠ndice de relieve m√°s el m√©todo del constructor correspondiente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizamos esta estructura para crear una matriz est√°tica que contiene datos de matriz. </font><font style="vertical-align: inherit;">Usamos la humedad como la coordenada X y la temperatura como Y. Llenamos la l√≠nea con la temperatura m√°s baja con nieve, la segunda l√≠nea con tundra y las otras dos con hierba. </font><font style="vertical-align: inherit;">Luego reemplazamos la columna m√°s seca con el desierto, redefiniendo la elecci√≥n de temperatura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/969/859/bd5/969859bd51e51cce1f7fe63d9eacd55a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matriz de biomas con √≠ndices de una matriz unidimensional.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Definici√≥n de bioma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para determinar las </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√©lulas </font><font style="vertical-align: inherit;">en el </font><font style="vertical-align: inherit;">bioma, recorreremos los rangos de temperatura y humedad en el ciclo para determinar los √≠ndices de matriz que necesitamos. </font><font style="vertical-align: inherit;">Los usamos para obtener el bioma deseado y especificar el tipo de topograf√≠a celular.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(temperature); float moisture = climate[i].moisture; if (!cell.IsUnderwater) { // if (moisture &lt; 0.05f) { // cell.TerrainTypeIndex = 4; // } // ‚Ä¶ // else { // cell.TerrainTypeIndex = 2; // } int t = 0; for (; t &lt; temperatureBands.Length; t++) { if (temperature &lt; temperatureBands[t]) { break; } } int m = 0; for (; m &lt; moistureBands.Length; m++) { if (moisture &lt; moistureBands[m]) { break; } } Biome cellBiome = biomes[t * 4 + m]; cell.TerrainTypeIndex = cellBiome.terrain; } else { cell.TerrainTypeIndex = 2; } } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00d/d32/4f5/00dd324f5b421811f49ca157e5217e43.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alivio basado en una matriz de bioma.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Configuraci√≥n de bioma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos ir m√°s all√° de los biomas definidos en la matriz. Por ejemplo, en la matriz, todos los biomas secos se definen como desiertos de arena, pero no todos los desiertos secos est√°n llenos de arena. Hay muchos desiertos rocosos que se ven muy diferentes. Por lo tanto, reemplacemos algunas de las c√©lulas del desierto con piedras. Haremos esto simplemente en funci√≥n de la altura: la arena se encuentra a baja altitud, y las rocas desnudas generalmente se encuentran arriba. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponga que la arena se convierte en piedra cuando la altura de la celda est√° m√°s cerca de la altura m√°xima que del nivel del agua. Esta es la l√≠nea de altura de los desiertos rocosos que podemos calcular al principio </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cuando nos encontramos con una celda con arena, y su altura es lo suficientemente grande, cambiamos el relieve del bioma a piedra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rockDesertElevation = elevationMaximum - (elevationMaximum - waterLevel) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { ‚Ä¶ Biome cellBiome = biomes[t * <span class="hljs-number"><span class="hljs-number">4</span></span> + m]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } cell.TerrainTypeIndex = cellBiome.terrain; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/812/13e/1e481213eb2c9b5cf5216b9bfa9546aa.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desiertos arenosos y rocosos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro cambio basado en la altura es forzar a las celdas a la altura m√°xima a convertirse en picos de nieve, independientemente de su temperatura, solo si no est√°n demasiado secas. </font><font style="vertical-align: inherit;">Esto aumentar√° la probabilidad de picos de nieve cerca del ecuador c√°lido y h√∫medo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == elevationMaximum) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/06e/35b/9c406e35b681819072db7a3006151e6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorros de nieve a la altura m√°xima.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plantas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora hagamos que los biomas determinen el nivel de c√©lulas vegetales. </font><font style="vertical-align: inherit;">Para hacer esto, agregue al </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo de plantas e incl√∫yalo en el constructor.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain, plant; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> plant</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.plant = plant; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En los biomas m√°s fr√≠os y secos no habr√° plantas. </font><font style="vertical-align: inherit;">En todos los dem√°s aspectos, cuanto m√°s c√°lido y h√∫medo sea el clima, m√°s plantas. </font><font style="vertical-align: inherit;">La segunda columna de humedad recibe solo el primer nivel de plantas para la hilera m√°s caliente, por lo tanto [0, 0, 0, 1]. </font><font style="vertical-align: inherit;">La tercera columna aumenta los niveles en uno, con la excepci√≥n de la nieve, es decir, [0, 1, 1, 2]. </font><font style="vertical-align: inherit;">Y la columna m√°s h√∫meda los vuelve a aumentar, es decir, resulta [0, 2, 2, 3]. </font><font style="vertical-align: inherit;">Cambie la matriz </font></font><code>biomes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregando la configuraci√≥n de la planta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f94/bad/c72/f94badc7211d1891415dda94019bf041.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matriz de biomas con niveles de plantas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos establecer el nivel de plantas para la c√©lula.</font></font><br><br><pre> <code class="cs hljs"> cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/2c6/7f8/ed92c67f8322c4b0c9967c0f394507bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomas con plantas.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øLas plantas ahora se ven diferentes?</font></font></b> <div class="spoiler_text">       ,      .       (1, 2, 1)  (0.75, 1, 0.75).     (1.5, 3, 1.5)  (2, 1.5, 2).    ‚Äî (2, 4.5, 2)  (2.5, 3, 2.5). <br><br>        ,      : (13, 114, 0). </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos cambiar el nivel de plantas para biomas. </font><font style="vertical-align: inherit;">Primero debemos asegurarnos de que no aparezcan en el terreno nevado, que ya podr√≠amos configurar. </font><font style="vertical-align: inherit;">En segundo lugar, aumentemos el nivel de las plantas a lo largo de los r√≠os, si a√∫n no est√° al m√°ximo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">4</span></span>) { cellBiome.plant = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.plant &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> &amp;&amp; cell.HasRiver) { cellBiome.plant += <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/012/7e4/bd10127e45593cc5f8ce09faa783b10c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plantas modificadas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomas submarinos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ese momento, ignoramos por completo las c√©lulas submarinas. </font><font style="vertical-align: inherit;">Agreguemos una peque√±a variaci√≥n a ellos, y no usaremos la textura de la tierra para todos ellos. </font><font style="vertical-align: inherit;">Una soluci√≥n simple basada en la altura ya ser√° suficiente para crear una imagen m√°s interesante. </font><font style="vertical-align: inherit;">Por ejemplo, usemos pasto para las celdas un paso por debajo del nivel del agua. </font><font style="vertical-align: inherit;">Tambi√©n usemos pasto para celdas sobre el nivel del agua, es decir, para lagos creados por r√≠os. </font><font style="vertical-align: inherit;">Las celdas con una altura negativa son √°reas de aguas profundas, por lo que usamos piedra para ellas. </font><font style="vertical-align: inherit;">Todas las dem√°s c√©lulas permanecen molidas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= waterLevel) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a62/bb5/5c7/a62bb55c7e4023a4590dbfe73bafe10f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabilidad submarina.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agreguemos algunos detalles m√°s para las c√©lulas submarinas a lo largo de la costa. Estas son c√©lulas con al menos un vecino sobre el agua. Si dicha celda es poco profunda, crearemos una playa. Y si est√° al lado del acantilado, ser√° el detalle visual dominante, y usaremos la piedra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para determinar esto, verificaremos los vecinos de las celdas ubicadas un paso por debajo del nivel del agua. Cuentemos el n√∫mero de conexiones por acantilados y pendientes con celdas terrestres vecinas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.WaterLevel; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { slopes += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cliffs += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos usar esta informaci√≥n para clasificar las celdas. </font><font style="vertical-align: inherit;">En primer lugar, si m√°s de la mitad de los vecinos son terrestres, entonces estamos tratando con un lago o una bah√≠a. </font><font style="vertical-align: inherit;">Para estas c√©lulas usamos una textura de hierba. </font><font style="vertical-align: inherit;">De lo contrario, si tenemos acantilados, entonces usamos piedra. </font><font style="vertical-align: inherit;">De lo contrario, si tenemos pendientes, entonces usamos arena para crear una playa. </font><font style="vertical-align: inherit;">La √∫nica opci√≥n restante es un √°rea poco profunda frente a la costa, para la cual todav√≠a usamos c√©sped.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs + slopes &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (slopes &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/8d6/2ed/0eb8d62ed0ec66f7814bd839c9ca32fb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e34/976/0bc/e349760bc545e3063718b892a9ccbd89.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabilidad de la costa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como toque final, verifiquemos que no tengamos c√©lulas verdes bajo el agua en el rango de temperatura m√°s fr√≠o. </font><font style="vertical-align: inherit;">Para tales c√©lulas usamos la tierra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrain == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; temperature &lt; temperatureBands[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tuvimos la oportunidad de generar tarjetas aleatorias que parecen bastante interesantes y naturales, con muchas opciones de configuraci√≥n. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 27: doblar una tarjeta </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dividimos las tarjetas en columnas que se pueden mover. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Centre la tarjeta en la c√°mara. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Derrumbamos todo. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta √∫ltima parte, agregaremos soporte para minimizar el mapa, conectando los bordes este y oeste. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El tutorial fue creado usando Unity 2017.3.0p3.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/96a/49d/f2996a49dab361c70ce643cc9f2d648b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El plegado hace que el mundo gire.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tarjetas plegables </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestros mapas se pueden usar para modelar √°reas de diferentes tama√±os, pero siempre se limitan a una forma rectangular. Podemos crear un mapa de una isla o un continente entero, pero no todo el planeta. Los planetas son esf√©ricos, no tienen l√≠mites r√≠gidos que impidan el movimiento en su superficie. Si contin√∫a movi√©ndose en una direcci√≥n, tarde o temprano volver√° al punto de partida. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No podemos envolver una cuadr√≠cula de hex√°gonos alrededor de una esfera; tal superposici√≥n es imposible. En las mejores aproximaciones, se utiliza la topolog√≠a icosa√©drica, en la que las doce c√©lulas deben ser pent√°gonos. Sin embargo, sin ninguna distorsi√≥n o excepci√≥n, la malla se puede enrollar alrededor del cilindro. Para hacer esto, solo conecta los bordes este y oeste del mapa. Con la excepci√≥n de la l√≥gica de ajuste, todo lo dem√°s permanece igual.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un cilindro es una aproximaci√≥n pobre de una esfera, porque no podemos modelar polos. </font><font style="vertical-align: inherit;">Pero esto no impidi√≥ que los desarrolladores de muchos juegos usaran el plegado de este a oeste para modelar mapas planetarios. </font><font style="vertical-align: inherit;">Las regiones polares simplemente no son parte de la zona de juego.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© hay de girar hacia el norte y el sur?</font></font></b> <div class="spoiler_text">          ,     .       ,    ,       .        -,            -.         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay dos formas de implementar el plegado cil√≠ndrico. </font><font style="vertical-align: inherit;">La primera es hacer que el mapa sea cil√≠ndrico doblando su superficie y todo lo que est√° sobre √©l para que los bordes este y oeste est√©n en contacto. </font><font style="vertical-align: inherit;">Ahora jugar√°s no en una superficie plana, sino en un cilindro real. </font><font style="vertical-align: inherit;">El segundo enfoque es guardar un mapa plano y usar teletransportaci√≥n o duplicaci√≥n para colapsar. </font><font style="vertical-align: inherit;">La mayor√≠a de los juegos usan el segundo enfoque, as√≠ que lo tomaremos.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plegable opcional </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La necesidad de colapsar el mapa depende de su escala: local o planetaria. </font><font style="vertical-align: inherit;">Podemos usar el soporte de ambos haciendo que el plegado sea opcional. </font><font style="vertical-align: inherit;">Para hacer esto, agregue un </font><font style="vertical-align: inherit;">nuevo interruptor al </font><font style="vertical-align: inherit;">men√∫ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crear nuevo mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con el colapso activado de forma predeterminada.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b07/17d/3ef/b0717d3ef8000555a454de943e4e387a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El men√∫ del nuevo mapa con la opci√≥n de colapsar. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue al </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo para rastrear la selecci√≥n, as√≠ como un m√©todo para cambiarla. </font><font style="vertical-align: inherit;">Hagamos que se invoque este m√©todo cuando cambie el estado del interruptor.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWrapping</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { wrapping = toggle; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cuando se solicita un nuevo mapa, pasamos el valor de la opci√≥n minimizar. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generateMaps) { mapGenerator.GenerateMap(x, z, wrapping); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.CreateMap(x, z, wrapping); } HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√°mbielo </font></font><code>HexMapGenerator.GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que acepte este nuevo argumento y luego lo pase a </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ grid.CreateMap(x, z, wrapping); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code&gt; HexGrid deber√≠a saber si estamos colapsando, as√≠ que agr√©guele un campo y config√∫relo </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Otras clases deber√≠an cambiar su l√≥gica dependiendo de si la cuadr√≠cula est√° minimizada, por lo que haremos que el campo sea general. </font><font style="vertical-align: inherit;">Adem√°s, le permite establecer el valor predeterminado a trav√©s del inspector.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCountX = <span class="hljs-number"><span class="hljs-number">20</span></span>, cellCountZ = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cellCountX = x; cellCountZ = z; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; ‚Ä¶ }</code> </pre> <br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamadas propias </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en dos lugares. </font><font style="vertical-align: inherit;">Simplemente podemos usar su propio campo para el argumento de colapso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ CreateMap(cellCountX, cellCountZ, wrapping); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d57/fc1/36ad57fc1ff8967bbd8282808f762241.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El interruptor de rejilla plegable est√° activado de forma predeterminada.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Guardar y cargar </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como el plegado est√° configurado para cada tarjeta, debe guardarse y cargarse. </font><font style="vertical-align: inherit;">Esto significa que debe cambiar el formato de guardado del archivo, as√≠ que aumente la versi√≥n constante en </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al guardar, deje </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que escriba el valor de plegado booleano despu√©s del tama√±o del mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); writer.Write(wrapping); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al cargar, lo leeremos solo con la versi√≥n correcta del archivo. </font><font style="vertical-align: inherit;">Si es diferente, entonces esta es una tarjeta vieja y no debe minimizarse. </font><font style="vertical-align: inherit;">Guarde esta informaci√≥n en una variable local y comp√°rela con el estado actual de plegado. </font><font style="vertical-align: inherit;">Si es diferente, entonces no podemos reutilizar la topolog√≠a de mapa existente de la misma manera que lo har√≠a al cargar un mapa con otros tama√±os.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = header &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ? reader.ReadBoolean() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping != wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√©tricas plegables </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimizar el mapa requerir√° cambios importantes en la l√≥gica, por ejemplo, al calcular distancias. </font><font style="vertical-align: inherit;">Por lo tanto, pueden tocar el c√≥digo que no tiene un enlace directo a la cuadr√≠cula. </font><font style="vertical-align: inherit;">En lugar de pasar esta informaci√≥n como argumentos, a√±√°dala a </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Agregue un n√∫mero entero est√°tico que contenga el tama√±o de plegado que coincida con el ancho del mapa. </font><font style="vertical-align: inherit;">Si es mayor que cero, entonces estamos tratando con una tarjeta plegable. </font><font style="vertical-align: inherit;">Para verificar esto, agregue una propiedad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Wrapping { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wrapSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitamos establecer el tama√±o de plegado para cada llamada </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que estos datos no sobrevivir√°n a la compilaci√≥n en el modo Play, lo configuraremos </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; ResetVisibility(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ancho de la celda </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando trabajamos con tarjetas plegables, a menudo tenemos que lidiar con posiciones a lo largo del eje X, medidas en el ancho de las celdas. </font><font style="vertical-align: inherit;">Aunque se puede usar para esto </font></font><code>HexMetrics.innerRadius * 2f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ser√≠a m√°s conveniente si no tuvi√©ramos que multiplicar cada vez. </font><font style="vertical-align: inherit;">Entonces agreguemos una constante </font></font><code>HexMetrics.innerDiameter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * outerToInner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerDiameter = innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya podemos usar el di√°metro en tres lugares. </font><font style="vertical-align: inherit;">En primer lugar, </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al posicionar una nueva celda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Vector3 position; position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> - z / <span class="hljs-number"><span class="hljs-number">2</span></span>) * HexMetrics.innerDiameter; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En segundo lugar, en </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limitar la posici√≥n de la c√°mara.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y tambi√©n en la </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conversi√≥n de posici√≥n a coordenadas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = position.x / HexMetrics.innerDiameter; ‚Ä¶ }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Centrado de tarjeta </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando el mapa no colapsa, tiene claramente definidos los bordes este y oeste, y por lo tanto un centro horizontal claro. </font><font style="vertical-align: inherit;">Pero en el caso de una tarjeta plegable, todo es diferente. </font><font style="vertical-align: inherit;">No tiene el borde oriental ni occidental ni el centro. </font><font style="vertical-align: inherit;">Como alternativa, podemos suponer que el centro est√° donde est√° la c√°mara. </font><font style="vertical-align: inherit;">Esto ser√° √∫til porque queremos que el mapa siempre est√© centrado en nuestro punto de vista. </font><font style="vertical-align: inherit;">Entonces, donde sea que estemos, no veremos los bordes este u oeste del mapa.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Columnas de fragmentos de mapa </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que la visualizaci√≥n del mapa se centre en relaci√≥n con la c√°mara, debemos cambiar la ubicaci√≥n de los elementos seg√∫n el movimiento de la c√°mara. Si se mueve hacia el oeste, entonces debemos tomar lo que est√° actualmente en el borde de la parte oriental y moverlo al borde de la parte occidental. Lo mismo se aplica a la direcci√≥n opuesta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealmente, tan pronto como la c√°mara se mueva a la columna de celdas vecina, debemos mover inmediatamente la columna de celdas m√°s alejada al otro lado. Sin embargo, no necesitamos ser tan precisos. En cambio, podemos transferir fragmentos de mapas completos. Esto nos permite mover partes del mapa sin tener que modificar las mallas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como estamos moviendo columnas enteras de fragmentos al mismo tiempo, agrup√©moslas creando un objeto de columna principal para cada grupo. </font><font style="vertical-align: inherit;">Agregue una matriz para estos objetos </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la inicializaremos </font></font><code>CreateChunks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Los usaremos solo como contenedores, por lo que solo necesitamos rastrear el enlace a sus componentes </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como en el caso de los fragmentos, sus posiciones iniciales se ubican en el origen local de las coordenadas de la cuadr√≠cula.</font></font><br><br><pre> <code class="cs hljs"> Transform[] columns; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { columns = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Transform[chunkCountX]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { columns[x] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>).transform; columns[x].SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora el fragmento deber√≠a convertirse en hijo de la columna correspondiente, no de la cuadr√≠cula. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ chunks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexGridChunk[chunkCountX * chunkCountZ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; chunkCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab); chunk.transform.SetParent(columns[x], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/415/920/bb2/415920bb2e4e2e002793aaebee8e04e2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmentos agrupados en columnas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que todos los fragmentos se han convertido en hijos de las columnas, </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es suficiente que destruyamos directamente todas las columnas, no los fragmentos. </font><font style="vertical-align: inherit;">Entonces nos desharemos de los fragmentos de hija.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columns != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { Destroy(columns[i].gameObject); } } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Columnas de teletransporte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue al </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuevo m√©todo </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con la posici√≥n X como par√°metro. </font><font style="vertical-align: inherit;">Convierta la posici√≥n al √≠ndice de la columna, dividi√©ndola por el ancho del fragmento en unidades Unity. </font><font style="vertical-align: inherit;">Este ser√° el √≠ndice de la columna en la que se encuentra actualmente la c√°mara, es decir, ser√° la columna central del mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es suficiente para nosotros cambiar la visualizaci√≥n del mapa solo cuando cambia el √≠ndice de la columna central. </font><font style="vertical-align: inherit;">As√≠ que vamos a seguirlo en el campo. </font><font style="vertical-align: inherit;">Usamos el valor predeterminado ‚àí1 cuando creamos un mapa para que los nuevos mapas siempre est√©n centrados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centerColumnIndex == currentCenterColumnIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } currentCenterColumnIndex = centerColumnIndex; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que conocemos el √≠ndice de la columna central, podemos determinar los √≠ndices m√≠nimo y m√°ximo simplemente restando y sumando la mitad del n√∫mero de columnas. Como utilizamos valores enteros, con un n√∫mero impar de columnas, esto funciona perfectamente. En el caso de un n√∫mero par, no puede haber una columna perfectamente centrada, por lo que uno de los √≠ndices estar√° un paso m√°s all√° de lo necesario. Esto crea un desplazamiento de una columna en la direcci√≥n del borde m√°s alejado del mapa, pero para nosotros esto no es un problema.</font></font><br><br><pre> <code class="cs hljs"> currentCenterColumnIndex = centerColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que estos √≠ndices pueden ser negativos o mayores que el √≠ndice de columna m√°ximo natural. </font><font style="vertical-align: inherit;">El m√≠nimo es cero solo cuando la c√°mara est√° cerca del centro natural del mapa. </font><font style="vertical-align: inherit;">Nuestra tarea es mover las columnas para que se correspondan con estos √≠ndices relativos. </font><font style="vertical-align: inherit;">Esto se puede hacer cambiando la coordenada X local de cada columna en el bucle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; Vector3 position; position.y = position.z = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; columns[i].localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para cada columna, verificamos si el √≠ndice del √≠ndice m√≠nimo es menor. </font><font style="vertical-align: inherit;">Si es as√≠, entonces est√° demasiado lejos a la izquierda del centro. </font><font style="vertical-align: inherit;">Debe teletransportarse al otro lado del mapa. </font><font style="vertical-align: inherit;">Esto se puede hacer haciendo que su coordenada X sea igual al ancho del mapa. </font><font style="vertical-align: inherit;">Del mismo modo, si el √≠ndice de la columna es mayor que el √≠ndice m√°ximo, entonces est√° demasiado lejos a la derecha del centro y deber√≠a teletransportarse al otro lado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; minColumnIndex) { position.x = chunkCountX * (HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; maxColumnIndex) { position.x = chunkCountX * -(HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; } columns[i].localPosition = position; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimiento de la c√°mara </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambie </font></font><code>HexMapCamera.AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que cuando trabaje con una tarjeta plegable, en lugar de eso, </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llame </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primero, simplemente haga que el nuevo m√©todo sea un </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">duplicado </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero con la √∫nica diferencia: al final, llamar√° </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ transform.localPosition = grid.wrapping ? WrapPosition(position) : ClampPosition(position); } ‚Ä¶ <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); grid.CenterMap(position.x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que la tarjeta se centre inmediatamente, llamamos al </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; ValidatePosition(); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mu√©vase hacia la izquierda y hacia la derecha al centrar la c√°mara. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque todav√≠a restringimos el movimiento de la c√°mara, el mapa ahora intenta centrarse en relaci√≥n con la c√°mara, teletransportando columnas de fragmentos de mapa si es necesario. </font><font style="vertical-align: inherit;">Con un mapa peque√±o y una c√°mara remota, esto es claramente visible, pero en un mapa grande, los fragmentos teletransportados est√°n fuera del alcance de visi√≥n de la c√°mara. </font><font style="vertical-align: inherit;">Obviamente, solo los bordes iniciales este y oeste del mapa son notables, porque todav√≠a no hay triangulaci√≥n entre ellos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Eliminar la restricci√≥n de su coordenada X con el fin de reducir al m√≠nimo y la c√°mara </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En cambio, continuaremos aumentando la coordenada X en el ancho del mapa mientras est√© por debajo de cero, y la reduciremos mientras sea m√°s grande que el ancho del mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// float xMax = (grid.cellCountX - 0.5f) * HexMetrics.innerDiameter; // position.x = Mathf.Clamp(position.x, 0f, xMax); float width = grid.cellCountX * HexMetrics.innerDiameter; while (position.x &lt; 0f) { position.x += width; } while (position.x &gt; width) { position.x -= width; } float zMax = (grid.cellCountZ - 1) * (1.5f * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, 0f, zMax); grid.CenterMap(position.x); return position; }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La c√°mara enrollable se mueve a lo largo del mapa.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texturas de sombreador plegables </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con la excepci√≥n del espacio de triangulaci√≥n, minimizar la c√°mara en el modo de juego deber√≠a ser imperceptible. Sin embargo, cuando esto sucede, se produce un cambio visual en la mitad de la topograf√≠a y el agua. Esto sucede porque usamos una posici√≥n en el mundo para muestrear estas texturas. Una teletransportaci√≥n aguda del fragmento cambia la ubicaci√≥n de las texturas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos resolver este problema haciendo que las texturas aparezcan en mosaicos que son m√∫ltiplos del tama√±o del fragmento. El tama√±o del fragmento se calcula a partir de las constantes en </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as√≠ que </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creemos el</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> archivo de inclusi√≥n del sombreador </font><em><font style="vertical-align: inherit;">HexMetrics.cginc</font></em><font style="vertical-align: inherit;"> y </font><em><font style="vertical-align: inherit;">peguemos</font></em><font style="vertical-align: inherit;"> las definiciones correspondientes en √©l. La escala de mosaico b√°sica se calcula a partir del tama√±o del fragmento y el radio exterior de la celda. Si utiliza otras m√©tricas, deber√° modificar el archivo en consecuencia.</font></font><br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_TO_INNER 0.866025404 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_RADIUS 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHUNK_SIZE_X 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TILING_SCALE (1 / (CHUNK_SIZE_X * 2 * OUTER_RADIUS / OUTER_TO_INNER))</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto nos da una escala de mosaico de 0.00866025404. </font><font style="vertical-align: inherit;">Si usamos un m√∫ltiplo entero de este valor, la textura no se ver√° afectada por la teletransportaci√≥n de fragmentos. </font><font style="vertical-align: inherit;">Adem√°s, las texturas en los bordes este y oeste del mapa se unir√°n perfectamente despu√©s de que triangulemos correctamente su conexi√≥n. </font><font style="vertical-align: inherit;">Usamos 0.02 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como la escala UV en el sombreador de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En cambio, podemos usar la escala de mosaico duplicado, que es 0.01732050808. </font><font style="vertical-align: inherit;">La escala se obtiene un poco menos de lo que era, y la escala de la textura ha aumentado ligeramente, pero visualmente es invisible.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexCellData.cginc" ‚Ä¶ <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3( <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE), <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] ); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el sombreador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roads</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para ruido UV, utilizamos una escala de 0.025. </font><font style="vertical-align: inherit;">En su lugar, puede usar la escala de mosaico triple. </font><font style="vertical-align: inherit;">Esto nos da 0.02598076212, que est√° bastante cerca.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water.cginc</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilizamos 0.015 para espuma y 0.025 para olas. </font><font style="vertical-align: inherit;">Aqu√≠ podemos reemplazar nuevamente estos valores con una escala de mosaico duplicada y triplicada.</font></font><br><br><pre> <code class="hljs mel">#include <span class="hljs-string"><span class="hljs-string">"HexMetrics.cginc"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Foam (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shore, float2 worldXZ, sampler2D noiseTex) { shore = <span class="hljs-keyword"><span class="hljs-keyword">sqrt</span></span>(shore) * <span class="hljs-number"><span class="hljs-number">0.9</span></span>; float2 noiseUV = worldXZ + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; float4 <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span> = tex2D(noiseTex, noiseUV * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE)); ‚Ä¶ } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Waves (float2 worldXZ, sampler2D noiseTex) { float2 uv1 = worldXZ; uv1.y += _Time.y; float4 noise1 = tex2D(noiseTex, uv1 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); float2 uv2 = worldXZ; uv2.x += _Time.y; float4 noise2 = tex2D(noiseTex, uv2 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); ‚Ä¶ }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La uni√≥n de oriente y occidente </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta etapa, la √∫nica evidencia visual de minimizar el mapa es una peque√±a brecha entre las columnas m√°s orientales y m√°s occidentales. </font><font style="vertical-align: inherit;">Esta brecha ocurre porque todav√≠a no hemos triangulado las conexiones de bordes y √°ngulos entre celdas en lados opuestos del mapa sin plegar.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/85f/e79/24085fe7986100674854b9c9a79c349c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espacio en el borde.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vecinos plegables </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para triangular la conexi√≥n este-oeste, necesitamos hacer que las celdas en lados opuestos sean vecinas entre s√≠. </font><font style="vertical-align: inherit;">Hasta ahora no estamos haciendo esto, porque la </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conexi√≥n E - W se establece con la celda anterior solo si su √≠ndice en X es mayor que cero. </font><font style="vertical-align: inherit;">Para contraer esta conexi√≥n, debemos conectar la √∫ltima celda de la fila con la primera celda de la misma fila cuando se pliega el mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping &amp;&amp; x == cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.E, cells[i - x]); } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una vez establecida la conexi√≥n de los vecinos E - W, obtenemos una triangulaci√≥n parcial de la brecha. </font><font style="vertical-align: inherit;">La conexi√≥n de bordes no es ideal, porque la distorsi√≥n est√° oculta incorrectamente. </font><font style="vertical-align: inherit;">Nos ocuparemos de esto m√°s tarde.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/68a/6b6/ce568a6b639801e47804eb35a62493c6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compuestos E - W. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n necesitamos colapsar los enlaces NE - SW. </font><font style="vertical-align: inherit;">Esto se puede hacer conectando la primera celda de cada fila par con las √∫ltimas celdas de la fila anterior. </font><font style="vertical-align: inherit;">Ser√° solo la celda anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor(HexDirection.SW, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/239/66f/c3c/23966fc3c616ea9338a3a14d187dcc7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NE - Conexiones SW. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, las conexiones SE - NW se establecen al final de cada l√≠nea impar debajo de la primera. </font><font style="vertical-align: inherit;">Estas celdas deben estar conectadas a la primera celda de la fila anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor( HexDirection.SE, cells[i - cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e8/df4/62e/3e8df462e076bbdf93396f6cec525cc4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compuestos SE - NO.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ruido plegable </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ocultar perfectamente la brecha, debemos asegurarnos de que los bordes este y oeste del mapa coincidan con el ruido que se usa perfectamente para distorsionar las posiciones de los v√©rtices. </font><font style="vertical-align: inherit;">Podemos usar el mismo truco que se us√≥ para los sombreadores, pero se us√≥ una escala de ruido de 0.003 para la distorsi√≥n. </font><font style="vertical-align: inherit;">Para garantizar el mosaico, debe aumentar significativamente la escala, lo que conducir√° a una distorsi√≥n m√°s ca√≥tica de los v√©rtices. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una soluci√≥n alternativa no es el ruido tayl, sino hacer una atenuaci√≥n suave del ruido en los bordes del mapa. </font><font style="vertical-align: inherit;">Si realiza una atenuaci√≥n suave a lo largo del ancho de una celda, la distorsi√≥n crear√° una transici√≥n suave sin espacios. </font><font style="vertical-align: inherit;">El ruido en esta √°rea se suavizar√° ligeramente, y desde una larga distancia el cambio parecer√° agudo, pero esto no es tan obvio cuando se usa una ligera distorsi√≥n de los v√©rtices.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© pasa con las fluctuaciones de temperatura?</font></font></b> <div class="spoiler_text">           .      ,      .         ,   .     ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si no colapsamos la tarjeta, podemos pasar con una </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sola muestra. </font><font style="vertical-align: inherit;">Pero al plegar es necesario agregar atenuaci√≥n. </font><font style="vertical-align: inherit;">Por lo tanto, antes de devolver la muestra, gu√°rdela en una variable.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sample; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al minimizar, necesitamos mezclar con la segunda muestra. </font><font style="vertical-align: inherit;">Realizaremos la transici√≥n en la parte este del mapa, por lo que la segunda muestra debe moverse hacia el oeste.</font></font><br><br><pre> <code class="cs hljs"> Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La atenuaci√≥n se realiza utilizando una interpolaci√≥n lineal simple de la parte occidental a la oriental, sobre el ancho de una celda. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/84f/75d/c4e84f75dd0260efb18a9d3d66647c55.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mezcla de ruido, una soluci√≥n imperfecta</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como resultado, no obtenemos una coincidencia exacta, porque algunas de las celdas en el lado este tienen coordenadas X negativas. Para no acercarnos a esta √°rea, muevamos la regi√≥n de transici√≥n a la mitad oeste del ancho de la celda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) - <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/af4/1fb/04faf41fb669427487a2dbb6855cd5bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atenuaci√≥n correcta.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edici√≥n de celda </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que la triangulaci√≥n parece correcta, asegur√©monos de que podemos editar todo en el mapa y en la costura de plegado. Resulta que, en fragmentos teletransportados, las coordenadas son err√≥neas y grandes pinceles est√°n cortados por una costura.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/18b/5ce/a1f18b5ce7b87b38a7a58d47e341d4f1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El cepillo est√° recortado.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para solucionar esto, debemos informar el </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plegamiento. Podemos hacer esto haciendo coincidir la coordenada X en el m√©todo del constructor. Sabemos que la coordenada axial X se obtiene de la coordenada X del desplazamiento restando la mitad de la coordenada Z. Puede usar esta informaci√≥n para realizar la transformaci√≥n inversa y verificar si la coordenada cero es menor que cero. Si es as√≠, entonces tenemos la coordenada m√°s all√° del lado este del mapa desplegado. Como en cada direcci√≥n teletransportamos no m√°s de la mitad del mapa, ser√° suficiente para nosotros agregar el tama√±o de plegado a X una vez. Y cuando la coordenada de desplazamiento es mayor que el tama√±o de plegado, debemos realizar una resta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oX = x + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &gt;= HexMetrics.wrapSize) { x -= HexMetrics.wrapSize; } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.z = z; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A veces, al editar la parte inferior o superior del mapa, obtengo errores. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto sucede cuando, debido a la distorsi√≥n de los v√©rtices, el cursor aparece en la fila de celdas fuera del mapa. </font><font style="vertical-align: inherit;">Este es un error que ocurre porque no hacemos coincidir las coordenadas </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con el par√°metro vectorial. </font><font style="vertical-align: inherit;">Esto se puede solucionar aplicando un m√©todo </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con coordenadas como par√°metros que realizar√°n las verificaciones necesarias.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-comment"><span class="hljs-comment">// int index = // coordinates.X + coordinates.Z * cellCountX + coordinates.Z / 2; // return cells[index]; return GetCell(coordinates); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plegamiento costero </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La triangulaci√≥n funciona bien para el terreno, pero a lo largo de la costura este-oeste no hay bordes de la costa del agua. </font><font style="vertical-align: inherit;">De hecho, lo son, simplemente no colapsan. </font><font style="vertical-align: inherit;">Se voltean y se estiran al otro lado del mapa.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/20a/ed3/6fe20aed3cb0dea0a9e47ef08caa10f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falta el borde del agua. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto sucede, porque al triangular el agua de la costa, usamos la posici√≥n de un vecino. </font><font style="vertical-align: inherit;">Para solucionar esto, necesitamos determinar a qu√© nos enfrentamos, ubicado en el otro lado de la tarjeta. </font><font style="vertical-align: inherit;">Para simplificar la tarea, agregaremos una </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">columna de celda </font><font style="vertical-align: inherit;">a la </font><font style="vertical-align: inherit;">propiedad para el √≠ndice.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ColumnIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asigne este √≠ndice a </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es simplemente igual a la coordenada de desplazamiento X dividida por el tama√±o del fragmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.Index = i; cell.ColumnIndex = x / HexMetrics.chunkSizeX; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos </font></font><code>HexGridChunk.TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determinar qu√© se minimiza comparando el √≠ndice de columna de la celda actual y su vecino. </font><font style="vertical-align: inherit;">Si el √≠ndice de la columna del vecino es menos de un paso menos, entonces estamos en el lado occidental y el vecino est√° en el lado este. </font><font style="vertical-align: inherit;">Por lo tanto, necesitamos girar a nuestro vecino hacia el oeste. </font><font style="vertical-align: inherit;">Lo mismo y en la direcci√≥n opuesta.</font></font><br><br><pre> <code class="cs hljs"> Vector3 center2 = neighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/308/3ec/f133083ec9172168e5302d737fd0ce27.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Costillas de la costa, pero sin rincones. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ que nos ocupamos de las costillas de la costa, pero hasta ahora no nos ocupamos de los rincones. </font><font style="vertical-align: inherit;">Necesitamos hacer lo mismo con el pr√≥ximo vecino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 center3 = nextNeighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; } Vector3 v3 = center3 + (nextNeighbor.IsUnderwater ? HexMetrics.GetFirstWaterCorner(direction.Previous()) : HexMetrics.GetFirstSolidCorner(direction.Previous())); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d02/c0d/751/d02c0d7510fba8b3707b89f146b71837.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Costa bien acortada.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generaci√≥n de tarjeta </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La opci√≥n de conectar los lados este y oeste afecta la generaci√≥n de mapas. </font><font style="vertical-align: inherit;">Al minimizar el mapa, el algoritmo de generaci√≥n tambi√©n debe minimizarse. </font><font style="vertical-align: inherit;">Esto conducir√° a la creaci√≥n de otro mapa, pero cuando se utiliza un borde de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mapa X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> distinto de cero </font><em><font style="vertical-align: inherit;">, el</font></em><font style="vertical-align: inherit;"> plegado no es obvio.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/01f/f90/54001ff900386d5f389850de0a1d0034.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/428/859/ecb/428859ecb5c5bf9a68b277675110e44b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa grande 1208905299 con la configuraci√≥n predeterminada. Con plegado y sin √©l.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cuando est√° minimizado no tiene sentido usar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el mapa de la frontera de la X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pero no podemos deshacernos de √©l, porque al mismo tiempo las regiones se fusionar√°n. Al minimizar, en su lugar, podemos usar un </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RegionBorder</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambiamos </font></font><code>HexMapGenerator.CreateRegions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, reemplazando en todos los casos </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esta nueva variable ser√° igual o </font></font><code>regionBorder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dependiendo del valor de la opci√≥n de colapso. A continuaci√≥n mostr√© los cambios solo para el primer caso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> borderX = grid.wrapping ? regionBorder : mapBorderX; MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al mismo tiempo, las regiones permanecen separadas, pero esto es necesario solo si hay diferentes regiones en los lados este y oeste del mapa. </font><font style="vertical-align: inherit;">Hay dos casos en que esto no se respeta. </font><font style="vertical-align: inherit;">La primera es cuando tenemos solo una regi√≥n. </font><font style="vertical-align: inherit;">El segundo es cuando hay dos regiones que dividen el mapa horizontalmente. </font><font style="vertical-align: inherit;">En estos casos, podemos asignar un </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor de cero, lo que permitir√° que las masas de tierra crucen la costura este-oeste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/4d4/c9e/db84d4c9e40c9e35ad29af69314f73e1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una regi√≥n est√° colapsando. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primera vista, parece que todo funciona correctamente, pero en realidad hay una brecha a lo largo de la costura. </font><font style="vertical-align: inherit;">Esto se vuelve m√°s notable si establece el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">porcentaje de erosi√≥n en</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cero.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/a4e/572/ef5a4e5722dbbb8af91e770220d7d141.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/f75/fce/6b3f75fce35d6be9c8a66c445c4dc9cd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando se deshabilita la erosi√≥n, se nota una costura en el relieve.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La brecha ocurre porque la costura evita el crecimiento de fragmentos en relieve. Para determinar qu√© se agrega primero, se usa la distancia desde la celda hasta el centro del fragmento, y las celdas en el otro lado del mapa pueden estar muy lejos, por lo que casi nunca se encienden. Por supuesto, esto est√° mal. Necesitamos asegurarnos de que </font></font><code>HexCoordinates.DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conocemos el mapa minimizado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculamos la distancia entre </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sumando las distancias absolutas a lo largo de cada uno de los tres ejes y reduciendo a la mitad el resultado. La distancia a lo largo de Z siempre es verdadera, pero plegarla puede afectar las distancias X e Y. Entonces, comencemos con un c√°lculo separado de X + Y.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return // ((x &lt; other.x ? other.x - x : x - other.x) + // (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + // (z &lt; other.z ? other.z - z : z - other.z)) / 2; int xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); return (xy + (z &lt; other.z ? other.z - z : z - other.z)) / 2; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Determinar si el plegado crea una distancia m√°s corta para las celdas arbitrarias no es una tarea f√°cil, as√≠ que calculemos X + Y para los casos en los que estamos plegando otra coordenada hacia el lado oeste. </font><font style="vertical-align: inherit;">Si el valor es menor que el X + Y original, √∫selo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si esto no conduce a una distancia m√°s corta, entonces es posible doblar en la otra direcci√≥n, por lo que lo revisaremos. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { other.x -= <span class="hljs-number"><span class="hljs-number">2</span></span> * HexMetrics.wrapSize; xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora siempre obtenemos la distancia m√°s corta en el mapa plegable. </font><font style="vertical-align: inherit;">Los fragmentos de terreno ya no est√°n bloqueados por una costura, lo que permite que las masas de tierra se enrosquen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/fb7/3b8/65cfb73b8107d7744ff8cdcabaf48083.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/149/e6f/717/149e6f717defe9288565f37f7efcdf56.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relieve plegado correctamente sin erosi√≥n y erosi√≥n. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Viajando por el mundo </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despu√©s de considerar la generaci√≥n de mapas y la triangulaci√≥n, pasemos ahora a revisar escuadrones, exploraci√≥n y visibilidad. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prueba de costura </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El primer obst√°culo que encontramos al mover un escuadr√≥n alrededor del mundo es el borde del mapa, que no se puede explorar. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/4f4/748/4524f4748d2c4e3cb983ec5ecbf064c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La costura de la tarjeta no puede ser examinada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las celdas a lo largo del borde del mapa se hacen inexploradas para ocultar la finalizaci√≥n abrupta del mapa. </font><font style="vertical-align: inherit;">Pero cuando el mapa se minimiza, solo se deben marcar las celdas norte y sur, pero no el este y el oeste. </font><font style="vertical-align: inherit;">Cambie </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para tener esto en cuenta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.Explorable = z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.Explorable = x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilidad de las caracter√≠sticas de relieve. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora verifiquemos si la visibilidad funciona a lo largo de la costura. </font><font style="vertical-align: inherit;">Funciona para terreno, pero no para objetos de terreno. </font><font style="vertical-align: inherit;">Parece que los objetos que colapsan obtienen la visibilidad de la √∫ltima celda que no se colaps√≥.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/ac1/811/631ac18111ba1eb8dfcf74a39fb2ffbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visibilidad incorrecta de los objetos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto sucede porque el modo de </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sujeci√≥n est√° configurado </font><font style="vertical-align: inherit;">para el modo de plegado de textura utilizado </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para resolver el problema, simplemente cambie su modo de sujeci√≥n para repetir. </font><font style="vertical-align: inherit;">Pero necesitamos hacer esto solo para las coordenadas de U, por lo </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que lo configuraremos </font></font><code>wrapModeU</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>wrapModeV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTexture) { cellTexture.Resize(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; <span class="hljs-comment"><span class="hljs-comment">// cellTexture.wrapMode = TextureWrapMode.Clamp; cellTexture.wrapModeU = TextureWrapMode.Repeat; cellTexture.wrapModeV = TextureWrapMode.Clamp; Shader.SetGlobalTexture("_HexCellData", cellTexture); } ‚Ä¶ }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escuadrones y columnas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro problema es que las unidades a√∫n no est√°n colapsando. </font><font style="vertical-align: inherit;">Despu√©s de mover la columna en la que se encuentran, las unidades permanecen en el mismo lugar.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/29b/827/c5029b8273d7b53a3ddac2da03d9987f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La unidad no se transfiere y est√° en el lado equivocado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este problema se puede resolver haciendo que los escuadrones sean elementos secundarios de las columnas, como hicimos con los fragmentos. </font><font style="vertical-align: inherit;">Primero, ya no los convertiremos en los hijos inmediatos de la cuadr√≠cula </font></font><code>HexGrid.AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// unit.transform.SetParent(transform, false); unit.Location = location; unit.Orientation = orientation; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como las unidades se est√°n moviendo, pueden aparecer en otra columna, es decir, ser√° necesario cambiar sus padres. </font><font style="vertical-align: inherit;">Para hacer esto posible, agregamos al </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo general </font></font><code>MakeChildOfColumn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y, como par√°metros, le pasamos el componente del </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemento secundario y el √≠ndice de la columna.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeChildOfColumn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> columnIndex</span></span></span><span class="hljs-function">)</span></span> { child.SetParent(columns[columnIndex], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamaremos a este m√©todo cuando se establezca la propiedad </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ Grid.MakeChildOfColumn(transform, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.ColumnIndex); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto resuelve el problema de crear unidades. </font><font style="vertical-align: inherit;">Pero tambi√©n debemos hacer que se muevan a la columna deseada cuando se mueven. </font><font style="vertical-align: inherit;">Para hacer esto, debe rastrear </font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la columna actual </font><font style="vertical-align: inherit;">en el </font><font style="vertical-align: inherit;">√≠ndice. </font><font style="vertical-align: inherit;">Al comienzo de este m√©todo, este es el √≠ndice de la columna de celda al comienzo de la ruta, o la actual si el movimiento fue interrumpido por la compilaci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Grid.DecreaseVisibility( // currentTravelLocation ? currentTravelLocation : pathToTravel[0], // VisionRange // ); if (!currentTravelLocation) { currentTravelLocation = pathToTravel[0]; } Grid.DecreaseVisibility(currentTravelLocation, VisionRange); int currentColumn = currentTravelLocation.ColumnIndex; ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durante cada iteraci√≥n del movimiento, verificaremos si el √≠ndice de la siguiente columna es diferente, y si es as√≠, cambiaremos el padre del orden. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { ‚Ä¶ Grid.IncreaseVisibility(pathToTravel[i], VisionRange); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentColumn != nextColumn) { Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto permitir√° que las unidades se muevan de manera similar a los fragmentos. </font><font style="vertical-align: inherit;">Sin embargo, cuando se mueven a trav√©s de la costura de la tarjeta, las unidades a√∫n no colapsan. </font><font style="vertical-align: inherit;">En cambio, de repente comienzan a moverse en la direcci√≥n equivocada. </font><font style="vertical-align: inherit;">Esto sucede independientemente de la ubicaci√≥n de la costura, pero m√°s notablemente cuando saltan por todo el mapa.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carreras de caballos en el mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ podemos usar el mismo enfoque que se us√≥ para la costa, solo que esta vez giraremos la curva a lo largo de la cual se mueve el desprendimiento. </font><font style="vertical-align: inherit;">Si la siguiente columna se gira hacia el este, entonces teletransportaremos la curva tambi√©n hacia el este, de manera similar para la otra direcci√≥n. </font><font style="vertical-align: inherit;">Debe cambiar los puntos de control de la curva </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que tambi√©n afectar√° el punto de control </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { currentTravelLocation = pathToTravel[i]; a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-comment"><span class="hljs-comment">// c = (b + currentTravelLocation.Position) * 0.5f; // Grid.IncreaseVisibility(pathToTravel[i], VisionRange); int nextColumn = currentTravelLocation.ColumnIndex; if (currentColumn != nextColumn) { if (nextColumn &lt; currentColumn - 1) { ax -= HexMetrics.innerDiameter * HexMetrics.wrapSize; bx -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } else if (nextColumn &gt; currentColumn + 1) { ax += HexMetrics.innerDiameter * HexMetrics.wrapSize; bx += HexMetrics.innerDiameter * HexMetrics.wrapSize; } Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } c = (b + currentTravelLocation.Position) * 0.5f; Grid.IncreaseVisibility(pathToTravel[i], VisionRange); ‚Ä¶ }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movimiento con plegado.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lo √∫ltimo que debe hacer es cambiar el turno inicial del escuadr√≥n cuando mira la primera celda a la que se mover√°. Si esta celda est√° al otro lado de la costura este-oeste, la unidad mirar√° en la direcci√≥n incorrecta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al minimizar un mapa, hay dos formas de mirar un punto que no est√° exactamente en el norte o el sur. Puedes mirar hacia el este o el oeste. Ser√° l√≥gico mirar en la direcci√≥n correspondiente a la distancia m√°s cercana al punto, porque tambi√©n es la direcci√≥n del movimiento, as√≠ que utilic√©moslo </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al minimizar, verificaremos la distancia relativa a lo largo del eje X. Si es menor que la mitad negativa del ancho del mapa, entonces debemos mirar hacia el oeste, lo que se puede hacer girando el punto hacia el oeste. </font><font style="vertical-align: inherit;">De lo contrario, si la distancia es m√°s de la mitad del ancho del mapa, entonces debemos colapsar hacia el este.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDistance = point.x - transform.localPosition.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &lt; -HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x += HexMetrics.innerDiameter * HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &gt; HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, tenemos un mapa minimizado completamente funcional. </font><font style="vertical-align: inherit;">Y esto concluye la serie de tutoriales sobre mapas hexagonales. </font><font style="vertical-align: inherit;">Como se mencion√≥ en las secciones anteriores, se pueden considerar otros temas, pero no son espec√≠ficos de los mapas hexagonales. </font><font style="vertical-align: inherit;">Quiz√°s los considerar√© en futuras series de tutoriales.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargu√© el √∫ltimo paquete y recibo errores de turno en el modo Play</font></font></b> <div class="spoiler_text">  ,       <em>Rotation</em> .    .  .   5. </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargu√© el √∫ltimo paquete y los gr√°ficos no son tan hermosos como en las capturas de pantalla</font></font></b> <div class="spoiler_text">        . -    . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargu√© el √∫ltimo paquete y genera constantemente la misma tarjeta</font></font></b> <div class="spoiler_text">      seed (1208905299),      .    ,  <em>Use Fixed Seed</em> . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427567/">https://habr.com/ru/post/es427567/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427555/index.html">Animales que los humanos han aprendido a rastrear utilizando la tecnolog√≠a de reconocimiento facial</a></li>
<li><a href="../es427557/index.html">Resumen de eventos de TI en noviembre (primera parte)</a></li>
<li><a href="../es427561/index.html">Derecho a reparar: los primeros pasos en la direcci√≥n correcta de Motorola</a></li>
<li><a href="../es427563/index.html">Est√°ndar SNI cifrado implementado en Firefox Nightly</a></li>
<li><a href="../es427565/index.html">"Mi logro fue que generalmente volv√≠ a la profesi√≥n" - 10 preguntas para el programador, n√∫mero 10</a></li>
<li><a href="../es427569/index.html">Ajuste fino OpenStack bajo alta carga</a></li>
<li><a href="../es427571/index.html">La uni√≥n de R y PostgreSQL. Analizamos el trabajo de los aeropuertos, calculamos las pensiones.</a></li>
<li><a href="../es427573/index.html">Candy or Life: Halloween como una raz√≥n para atraer a tu hijo a la ciencia</a></li>
<li><a href="../es427575/index.html">Por qu√© el Wi-Fi no funcionar√° seg√∫n lo planeado y por qu√© saber qu√© tel√©fono usa el empleado</a></li>
<li><a href="../es427577/index.html">Aprendizaje autom√°tico versus an√°lisis de firma al detectar ataques en una aplicaci√≥n web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>