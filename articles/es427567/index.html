<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏼 📉 🖇️ Mapas hexagonales en Unity: ciclo del agua, erosión, biomas, mapa cilíndrico 👩🏼‍🎨 🔝 👩🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partes 1-3: malla, colores y alturas de celda 

 Partes 4-7: baches, ríos y caminos 

 Partes 8-11: agua, accidentes geográficos y murallas 

 Partes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapas hexagonales en Unity: ciclo del agua, erosión, biomas, mapa cilíndrico</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427567/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 1-3: malla, colores y alturas de celda</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 4-7: baches, ríos y caminos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 8-11: agua, accidentes geográficos y murallas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 12-15: guardar y cargar, texturas, distancias</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 16-19: encontrar el camino, escuadrones de jugadores, animaciones</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 20-23: niebla de guerra, investigación de mapas, generación de procedimientos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 24-27: ciclo del agua, erosión, biomas, mapa cilíndrico</a> <br><br><h1>  Parte 24: regiones y erosión </h1><br><ul><li>  Agrega un borde de agua alrededor del mapa. </li><li>  Dividimos el mapa en varias regiones. </li><li>  Usamos la erosión para cortar los acantilados. </li><li>  Movimos la tierra para suavizar el alivio. </li></ul><br>  En la parte anterior, sentamos las bases para la generación de mapas de procedimientos.  Esta vez limitaremos los lugares de posible ocurrencia de tierras y actuaremos sobre ellas con erosión. <br><br>  Este tutorial fue creado en Unity 2017.1.0. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ac/6a5/30c/5ac6a530cef3718f9031abe862364093.jpg"></div><br>  <i>Separar y suavizar la tierra.</i> <br><a name="habracut"></a><br><h2>  Borde del mapa </h2><br>  Dado que levantamos áreas de tierra al azar, puede suceder que la tierra toque el borde del mapa.  Esto puede ser indeseable.  El mapa con límite de agua contiene una barrera natural que impide que los jugadores se acerquen al borde.  Por lo tanto, sería bueno si prohibiéramos que la tierra se eleve por encima del nivel del agua cerca del borde del mapa. <br><br><h3>  Tamaño del borde </h3><br>  ¿Qué tan cerca debe estar la tierra del borde del mapa?  No hay una respuesta correcta a esta pregunta, por lo que haremos que este parámetro sea personalizable.  <code>HexMapGenerator</code> dos controles deslizantes al componente <code>HexMapGenerator</code> , uno para los bordes a lo largo de los bordes a lo largo del eje X, el otro para los bordes a lo largo del eje Z. Por lo tanto, podemos usar un borde más ancho en una de las dimensiones, o incluso crear un borde en una sola dimensión.  Usemos un intervalo de 0 a 10 con un valor predeterminado de 5. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderX = <span class="hljs-number"><span class="hljs-number">5</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapBorderZ = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/8ab/c74/6948abc743e881596bdea5656e562943.png"></div><br>  <i>Mapa de bordes deslizantes.</i> <br><br><h3>  Limitamos los centros de las áreas terrestres. </h3><br>  Sin bordes, todas las celdas son válidas.  Cuando hay límites, las coordenadas mínimas de desplazamiento permitidas aumentan y las coordenadas máximas permitidas disminuyen.  Dado que para generar las parcelas necesitaremos conocer el intervalo permitido, rastreemos usando cuatro campos enteros. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xMin, xMax, zMin, zMax;</code> </pre> <br>  Inicializamos las restricciones en <code>GenerateMap</code> antes de crear sushi.  Utilizamos estos valores como parámetros para <code>Random.Range</code> llamadas <code>Random.Range</code> , por lo que los máximos son realmente excepcionales.  Sin un borde, son iguales al número de celdas de medición, por lo tanto, no menos 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = waterLevel; } xMin = mapBorderX; xMax = x - mapBorderX; zMin = mapBorderZ; zMax = z - mapBorderZ; CreateLand(); … }</code> </pre> <br>  No prohibiremos estrictamente la aparición de tierra más allá del borde de la frontera, ya que esto crearía bordes muy cortados.  En cambio, limitaremos solo las celdas utilizadas para comenzar la generación de gráficos.  Es decir, los centros aproximados de los sitios serán limitados, pero partes de los sitios podrán ir más allá del área fronteriza.  Esto se puede hacer modificando <code>GetRandomCell</code> para que seleccione una celda en el rango de desplazamientos permitidos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return grid.GetCell(Random.Range(0, cellCount)); return grid.GetCell(Random.Range(xMin, xMax), Random.Range(zMin, zMax)); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/bbf/24b/7a8bbf24b1d46d9b97e8e9c01652fdfd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/0cf/aa2/a310cfaa2bec1cbe019a08c14218c7fd.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f1/799/f50/7f1799f5058c0d1e435bfc3c42133b9c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/c4b/1b7/93ac4b1b771eaa896b6c494b69c18b92.jpg"></div><br>  <i>Los bordes del mapa son 0 × 0, 5 × 5, 10 × 10 y 0 × 10.</i> <br><br>  Cuando todos los parámetros del mapa se establecen en sus valores predeterminados, un borde de tamaño 5 protegerá de manera confiable el borde del mapa de tocar tierra.  Sin embargo, esto no está garantizado.  La tierra a veces puede acercarse al borde y, a veces, tocarla en varios lugares. <br><br>  La probabilidad de que la tierra cruce la frontera entera depende del tamaño de la frontera y del tamaño máximo del sitio.  Sin dudarlo, las secciones siguen siendo hexágonos.  Hexágono completo con radio <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>r</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.049ex" height="1.455ex" viewBox="0 -520.7 451.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> r </script>  contiene <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.32ex" height="2.539ex" viewBox="0 -935.7 5304.3 1093.4" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-33" x="0" y="0"></use><g transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-32" x="638" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="1628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-33" x="2628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="3129" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="3803" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="4803" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 3r ^ 2 + 3r + 1 </script>  células  Si hay hexágonos con un radio igual al tamaño del borde, entonces pueden cruzarlo.  Un hexágono completo con un radio de 5 contiene 91 celdas.  Como por defecto el máximo es de 100 celdas por sección, esto significa que la tierra podrá tender un puente a través de 5 celdas, especialmente si hay vibraciones.  Para evitar que esto suceda, reduzca el tamaño máximo de la trama o aumente el tamaño del borde. <br><br><div class="spoiler">  <b class="spoiler_title">¿Cómo se deriva la fórmula para el número de celdas en la región hexagonal?</b> <div class="spoiler_text">  Con un radio de 0, estamos tratando con una sola celda.  Vino de 1. Con un radio de 1 alrededor del centro, hay seis celdas adicionales, es decir <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.165ex" height="2.211ex" viewBox="0 -772.3 2223.9 952" role="img" focusable="false" style="vertical-align: -0.417ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="722" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="1723" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> 6 + 1 </script>  .  Estas seis celdas pueden considerarse los extremos de seis triángulos que tocan el centro.  Con un radio de 2, se agrega una segunda fila a estos triángulos, es decir, se obtienen dos celdas más en el triángulo, y en total <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.14ex" height="2.762ex" viewBox="0 -831.5 5226.9 1189" role="img" focusable="false" style="vertical-align: -0.83ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="1612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-32" x="2613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-29" x="3113" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="3725" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="4726" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> 6 (1 + 2) + 1 </script>  .  Con un radio de 3, se agrega una tercera fila, es decir, tres celdas más por triángulo, y en total <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.143ex" height="2.762ex" viewBox="0 -831.5 6950.3 1189" role="img" focusable="false" style="vertical-align: -0.83ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="1612" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-32" x="2613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="3336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-33" x="4336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-29" x="4837" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="5449" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="6449" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-5"> 6 (1 + 2 + 3) + 1 </script>  .  Y así sucesivamente.  Es decir, en términos generales, la fórmula se ve como <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mi>u</mi><mi>m</mi><msub><mi>a</mi><mo stretchy=&quot;false&quot;>(</mo></msub><mi>i</mi><mo>=</mo><mn>1</mn><msup><mo stretchy=&quot;false&quot;>)</mo><mi>r</mi></msup><mi>i</mi><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>6</mn><mo stretchy=&quot;false&quot;>(</mo><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>2</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="74.989ex" height="3.312ex" viewBox="0 -950 32286.9 1426" role="img" focusable="false" style="vertical-align: -1.106ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-36" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-28" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-73" x="890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-75" x="1359" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-6D" x="1932" y="0"></use><g transform="translate(2810,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-28" x="748" y="-264"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-69" x="3715" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-3D" x="4338" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="5394" y="0"></use><g transform="translate(5895,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="550" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-69" x="6704" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-29" x="7049" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="7661" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="8662" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-3D" x="9440" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-36" x="10496" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-28" x="10997" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-28" x="11386" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="11776" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-28" x="12227" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="12617" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="13290" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="14291" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-29" x="14792" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-29" x="15181" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2F" x="15571" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-32" x="16071" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-29" x="16572" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="17183" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="18184" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-3D" x="18962" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-33" x="20019" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="20519" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-28" x="20971" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="21360" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="22034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="23035" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-29" x="23535" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="24147" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="25148" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-3D" x="25926" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-33" x="26982" y="0"></use><g transform="translate(27483,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-32" x="638" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="28610" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-33" x="29611" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMATHI-72" x="30111" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-2B" x="30785" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/427567/&amp;usg=ALkJrhhsskvyGk7N9Snq6yX54SLcoFDVaw#MJMAIN-31" x="31786" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>6</mn><mo stretchy="false">(</mo><mi>s</mi><mi>u</mi><mi>m</mi><msub><mi>a</mi><mo stretchy="false">(</mo></msub><mi>i</mi><mo>=</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>r</mi></msup><mi>i</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>6</mn><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><mi>r</mi><mo stretchy="false">(</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mn>3</mn><mi>r</mi><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-6"> 6 (suma_ (i = 1) ^ r i) +1 = 6 ((r (r + 1)) / 2) +1 = 3r (r + 1) + 1 = 3r ^ 2 + 3r + 1 </script>  . </div></div><br>  Para ver esto más claramente, podemos establecer el tamaño del borde en 200. Dado que un hexágono completo con un radio de 8 contiene 217 celdas, es probable que la tierra toque el borde del mapa.  Al menos si usa el valor de tamaño de borde predeterminado (5).  Si aumenta el borde a 10, la probabilidad disminuirá considerablemente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/75d/eb0/74b75deb060d9bdae2f74c1db4de287e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffa/7ce/e96/ffa7cee967f81ba9fe4ddc6718519d9a.jpg"></div><br>  <i>La parcela tiene un tamaño constante de 200, los bordes del mapa son 5 y 10.</i> <br><br><h3>  Pangea </h3><br>  Tenga en cuenta que cuando aumenta el borde del mapa y mantiene el mismo porcentaje de tierra, forzamos la tierra a formar un área más pequeña.  Como resultado de esto, un mapa grande por defecto es muy probable que cree una gran masa de tierra, el supercontinente Pangea, posiblemente con varias islas pequeñas.  Con un aumento en el tamaño del borde, la probabilidad de que esto ocurra aumenta y, a ciertos valores, casi estamos garantizados de obtener un supercontinente.  Sin embargo, cuando el porcentaje de tierra es demasiado grande, la mayoría de las áreas disponibles se llenan y como resultado obtenemos una masa de tierra casi rectangular.  Para evitar que esto suceda, debe reducir el porcentaje de tierra. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/d84/209/e1bd8420915ccc74cd3470409b9a4236.jpg"></div><br>  <i>40% de sushi con borde de tarjeta 10.</i> <br><br><div class="spoiler">  <b class="spoiler_title">¿De dónde viene el nombre Pangea?</b> <div class="spoiler_text">  Ese era el nombre del último supercontinente conocido que existió en la Tierra hace muchos años.  El nombre se compone de las palabras griegas pan y Gaia, que significa algo así como "toda la naturaleza" o "toda la tierra". </div></div><br><br><h3>  Protegemos de cartas imposibles </h3><br>  Generamos la cantidad correcta de tierra simplemente continuando elevando la tierra hasta que alcancemos la masa de tierra deseada.  Esto funciona porque tarde o temprano elevaremos cada celda al nivel del agua.  Sin embargo, cuando usamos el borde del mapa, no podemos llegar a cada celda.  Cuando se requiere un porcentaje demasiado alto de tierra, esto conducirá a interminables "intentos y fallas" del generador para obtener más tierra, y se quedará estancado en un ciclo interminable.  En este caso, la aplicación se congelará, pero esto no debería suceder. <br><br>  No podemos encontrar de manera confiable configuraciones imposibles de antemano, pero podemos protegernos de ciclos interminables.  Simplemente realizaremos un seguimiento del número de ciclos ejecutados en <code>CreateLand</code> .  Si hay demasiadas iteraciones, lo más probable es que estemos atascados y debamos parar. <br><br>  Para un mapa grande, mil iteraciones parecen aceptables, y diez mil iteraciones ya parecen absurdas.  Entonces usemos este valor como punto de terminación. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// while (landBudget &gt; 0) { for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); … } }</span></span></code> </pre> <br>  Si obtenemos un mapa dañado, 10,000 iteraciones no tomarán mucho tiempo, porque muchas celdas alcanzarán rápidamente la altura máxima, lo que evitará que crezcan nuevas áreas. <br><br>  Incluso después de romper el ciclo, todavía obtenemos el mapa correcto.  Simplemente no tiene la cantidad correcta de sushi y no se verá muy interesante.  Muestremos una notificación sobre esto en la consola, informándonos qué tierras restantes no pudimos gastar. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab5/87f/f4f/ab587ff4f560fe6c1c0d7d5a547ae2b7.jpg"></div><br>  <i>El 95% de la tierra con un borde de tarjeta de 10 no podría gastar la cantidad total.</i> <br><br><div class="spoiler">  <b class="spoiler_title">¿Por qué una carta fallida todavía tiene variación?</b> <div class="spoiler_text">  La costa tiene variabilidad, porque cuando las alturas dentro del área de creación se vuelven demasiado altas, las nuevas áreas no les permiten crecer hacia afuera.  El mismo principio no permite que las parcelas crezcan en pequeñas áreas de tierra, hasta que alcancen la altura máxima y simplemente se pierdan.  Además, la variabilidad aumenta al bajar las parcelas. </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  Particionar una tarjeta </h2><br>  Ahora que tenemos el borde del mapa, esencialmente dividimos el mapa en dos regiones separadas: la región del borde y la región donde se crearon las parcelas.  Como solo la región de la creación es importante para nosotros, podemos considerar este caso como una situación en una región.  La región simplemente no cubre todo el mapa.  Pero si esto es imposible, entonces nada nos impide dividir el mapa en varias regiones no conectadas de creación de tierras.  Esto permitirá que las masas de tierra se formen independientemente entre sí, designando diferentes continentes. <br><br><h3>  Región del mapa </h3><br>  Comencemos describiendo una región del mapa como una estructura.  Esto simplificará nuestro trabajo con varias regiones.  <code>MapRegion</code> una estructura <code>MapRegion</code> para esto, que simplemente contiene los campos de borde de la región.  Como no utilizaremos esta estructura fuera de <code>HexMapGenerator</code> , podemos definirla dentro de esta clase como una estructura interna privada.  Luego, cuatro campos enteros se pueden reemplazar por un campo <code>MapRegion</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// int xMin, xMax, zMin, zMax; struct MapRegion { public int xMin, xMax, zMin, zMax; } MapRegion region;</span></span></code> </pre> <br>  Para que todo funcione, debemos agregar el prefijo de <code>region.</code> a los campos mínimo-máximo en <code>GenerateMap</code> <code>region.</code>  . <br><br><pre> <code class="cs hljs"> region.xMin = mapBorderX; region.xMax = x - mapBorderX; region.zMin = mapBorderZ; region.zMax = z - mapBorderZ;</code> </pre> <br>  Y también en <code>GetRandomCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br><h3>  Varias regiones </h3><br>  Para admitir varias regiones, reemplace un campo <code>MapRegion</code> lista de regiones. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// MapRegion region; List&lt;MapRegion&gt; regions;</span></span></code> </pre> <br>  En este punto, sería bueno agregar un método separado para crear regiones.  Debe crear la lista deseada o borrarla si ya existe.  Después de eso, determinará una región, como lo hicimos antes, y la agregará a la lista. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRegions</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regions == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { regions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MapRegion&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { regions.Clear(); } MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br>  Llamaremos a este método en <code>GenerateMap</code> y no crearemos la región directamente. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// region.xMin = mapBorderX; // region.xMax = x - mapBorderX; // region.zMin = mapBorderZ; // region.zMax = z - mapBorderZ; CreateRegions(); CreateLand();</span></span></code> </pre> <br>  Para que <code>GetRandomCell</code> pueda trabajar con una región arbitraria, dele el parámetro <code>MapRegion</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MapRegion region</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell( Random.Range(region.xMin, region.xMax), Random.Range(region.zMin, region.zMax) ); }</code> </pre> <br>  Ahora los <code>SinkTerrain</code> <code>RaiseTerraion</code> y <code>SinkTerrain</code> deberían pasar la región correspondiente a <code>GetRandomCell</code> .  Para hacer esto, cada uno de ellos también necesita un parámetro de región. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SinkTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget, MapRegion region</span></span></span><span class="hljs-function">)</span></span> { searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell firstCell = GetRandomCell(region); … }</code> </pre> <br>  El método <code>CreateLand</code> debe determinar para cada región subir o bajar las secciones.  Para equilibrar la tierra entre las regiones, simplemente recorreremos repetidamente la lista de regiones en el ciclo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability) { landBudget = SinkTerrain(chunkSize, landBudget, region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); } }</code> </pre> <br>  Sin embargo, todavía tenemos que hacer que la reducción de las parcelas se distribuya uniformemente.  Esto se puede hacer al decidir para todas las regiones si se deben omitir. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> sink = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; regions.Count; i++) { MapRegion region = regions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if (Random.value &lt; sinkProbability) { if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); } } }</span></span></code> </pre> <br>  Finalmente, para usar exactamente la cantidad total de tierra, necesitamos detener el proceso tan pronto como la cantidad llegue a cero.  Esto puede suceder en cualquier etapa del ciclo de la región.  Por lo tanto, movemos la verificación de suma cero al bucle interno.  De hecho, solo podemos realizar esta verificación después de levantar la tierra, porque al bajar, la cantidad nunca se gasta.  Si hemos terminado, podemos salir inmediatamente del método <code>CreateLand</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// for (int guard = 0; landBudget &gt; 0 &amp;&amp; guard &lt; 10000; guard++) { for (int guard = 0; guard &lt; 10000; guard++) { bool sink = Random.value &lt; sinkProbability; for (int i = 0; i &lt; regions.Count; i++) { MapRegion region = regions[i]; int chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - 1); if (sink) { landBudget = SinkTerrain(chunkSize, landBudget, region); } else { landBudget = RaiseTerrain(chunkSize, landBudget, region); if (landBudget == 0) { return; } } } }</span></span></code> </pre> <br><h3>  Dos regiones </h3><br>  Aunque ahora contamos con el apoyo de varias regiones, todavía solicitamos solo una.  Cambiemos <code>CreateRegions</code> para que divida el mapa a la mitad verticalmente.  Para hacer esto, <code>xMax</code> la mitad el valor <code>xMax</code> de la región agregada.  Luego usamos el mismo valor para <code>xMin</code> y nuevamente usamos el valor original para <code>xMax</code> , usándolo como la segunda región. <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br>  Generar cartas en esta etapa no hará ninguna diferencia.  Aunque hemos identificado dos regiones, ocupan la misma región que una región antigua.  Para separarlos, debe dejar un espacio vacío entre ellos.  Esto se puede hacer agregando un control deslizante al borde de la región, usando el mismo intervalo y valor predeterminado que para los bordes del mapa. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionBorder = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/cd2/cd0/9ffcd2cd0f4068caf622e433c503715d.png"></div><br>  <i>Control deslizante de borde de región.</i> <br><br>  Dado que se puede formar tierra a ambos lados del espacio entre regiones, aumentará la probabilidad de crear puentes terrestres en los bordes del mapa.  Para evitar esto, usamos el borde de la región para definir una zona libre de tierra entre la línea divisoria y la región en la que pueden comenzar las parcelas.  Esto significa que la distancia entre las regiones vecinas es dos veces mayor que el tamaño del borde de la región. <br><br>  Para aplicar este límite de región, restarlo del <code>xMax</code> primera región y agregar la segunda región a <code>xMin</code> . <br><br><pre> <code class="cs hljs"> MapRegion region; region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/1f6/476/1e51f6476894662d55f7ca9748dc7fa5.jpg"></div><br>  <i>El mapa se divide verticalmente en dos regiones.</i> <br><br>  Con la configuración predeterminada, se crearán dos regiones notablemente separadas, sin embargo, como en el caso de una región y un borde de mapa grande, no se garantiza que recibamos exactamente dos masas de tierra.  Muy a menudo serán dos grandes continentes, posiblemente con varias islas.  Pero a veces se pueden crear dos o más islas grandes en una región.  Y a veces dos continentes pueden estar conectados por un istmo. <br><br>  Por supuesto, también podemos dividir el mapa horizontalmente, cambiando los enfoques para medir X y Z. Elija al azar una de las dos orientaciones posibles. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/970/c91/f23970c91cdd9c539ebdc8c7fdbba05f.jpg"></div><br>  <i>Mapa horizontalmente dividido en dos regiones.</i> <br><br>  Como usamos un mapa ancho, se crearán regiones más anchas y más delgadas con separación horizontal.  Como resultado, es más probable que estas regiones formen varias masas de tierra divididas. <br><br><h3>  Cuatro regiones </h3><br>  Hagamos que el número de regiones sea personalizable, creemos soporte de 1 a 4 regiones. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(1, 4)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> regionCount = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/918/49e/2a4/91849e2a4ffe6091b8d4fdf0d78b0c45.png"></div><br>  <i>Control deslizante para el número de regiones.</i> <br><br>  Podemos usar la <code>switch</code> para seleccionar la ejecución del código de región correspondiente.  Comenzamos repitiendo el código de una región, que se usará por defecto, y dejamos el código de dos regiones para el caso 2. <br><br><pre> <code class="cs hljs"> MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { region.xMin = mapBorderX; region.xMax = grid.cellCountX - mapBorderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¿Cuál es la declaración de cambio?</b> <div class="spoiler_text">  Esta es una alternativa a escribir una secuencia de declaraciones if-else-if-else.  El interruptor se aplica a la variable y las etiquetas se usan para indicar qué código debe ejecutarse.  También hay una etiqueta <code>default</code> , que se usa como el último bloque <code>else</code> .  Cada opción debe terminar con una declaración de <code>break</code> o una <code>return</code> . <br><br>  Para mantener legible el bloque de <code>switch</code> , generalmente es mejor mantener todos los casos cortos, idealmente con una sola declaración o llamada al método.  No haré esto como un ejemplo de código de región, pero si desea crear regiones más interesantes, le recomiendo que utilice métodos separados.  Por ejemplo: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: CreateOneRegion(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: CreateTwoRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: CreateThreeRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: CreateFourRegions(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> </div></div><br>  Tres regiones son similares a dos, solo se utilizan tercios en lugar de la mitad.  En este caso, la división horizontal creará regiones demasiado estrechas, por lo que creamos soporte solo para la división vertical.  Tenga en cuenta que, como resultado, hemos duplicado el área del borde de la región, por lo que el espacio para crear nuevas secciones es menor que en el caso de dos regiones. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: … <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: … <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">3</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/234/2e7/cc8/2342e7cc8cb524f4f9db803d5359a78e.jpg"></div><br>  <i>Tres regiones</i> <br><br>  Se pueden crear cuatro regiones combinando la separación horizontal y vertical y agregando una región a cada esquina del mapa. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { … <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.xMin = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.xMax = grid.cellCountX - mapBorderX; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); region.xMin = mapBorderX; region.xMax = grid.cellCountX / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/551/b72/a0c/551b72a0ca2f12a5636828faa4c3febc.jpg"></div><br>  <i>Cuatro regiones</i> <br><br>  El enfoque utilizado aquí es la forma más sencilla de dividir un mapa.  Genera aproximadamente las mismas regiones por masa de tierra, y su variabilidad está controlada por otros parámetros de generación de mapas.  Sin embargo, siempre será bastante obvio que la tarjeta se dividió en líneas rectas.  Cuanto más control necesitemos, menos orgánico se verá el resultado.  Por lo tanto, esto es normal si necesita regiones aproximadamente iguales para el juego.  Pero si necesita la tierra más variada e ilimitada, tendrá que hacerlo con la ayuda de una región. <br><br>  Además, hay otras formas de dividir el mapa.  No podemos limitarnos solo a líneas rectas.  Ni siquiera tenemos que usar regiones del mismo tamaño, así como cubrir todo el mapa con ellas.  Podemos dejar agujeros.  También puede permitir intersecciones de regiones o cambiar la distribución de la tierra entre regiones.  Incluso puede establecer sus propios parámetros de generador para cada región (aunque esto es más complicado), por ejemplo, para tener un continente grande y un archipiélago en el mapa. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  Erosión </h2><br>  Hasta ahora, todas las cartas que hemos generado parecían bastante groseras y rotas.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un alivio real puede verse así, pero con el tiempo se vuelve más y más suave, sus partes afiladas se opacan debido a la erosión. </font><font style="vertical-align: inherit;">Para mejorar los mapas, podemos aplicar este proceso de erosión. </font><font style="vertical-align: inherit;">Haremos esto después de crear un terreno accidentado, en un método separado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateRegions(); CreateLand(); ErodeLand(); SetTerrainType(); … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Porcentaje de erosión </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuanto más tiempo pasa, más erosión aparece. </font><font style="vertical-align: inherit;">Por lo tanto, queremos que la erosión no sea permanente, sino personalizable. </font><font style="vertical-align: inherit;">Como mínimo, la erosión es cero, lo que corresponde a los mapas creados anteriormente. </font><font style="vertical-align: inherit;">Al máximo, la erosión es integral, es decir, la aplicación adicional de las fuerzas de erosión ya no cambiará el terreno. </font><font style="vertical-align: inherit;">Es decir, el parámetro de erosión debe ser un porcentaje de 0 a 100, y por defecto tomaremos 50.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 100)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erosionPercentage = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/efe/e5e/c4eefee5e18aeee36f16e6aee98a27fe.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante de erosión.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buscar células destructoras de la erosión </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La erosión hace que el alivio sea más suave. En nuestro caso, las únicas partes afiladas son los acantilados. Por lo tanto, serán el objetivo del proceso de erosión. Si existe un acantilado, la erosión debería reducirlo hasta que finalmente se convierta en una pendiente. No suavizaremos las pendientes, ya que esto conducirá a un terreno aburrido. Para hacer esto, necesitamos determinar qué celdas están en la parte superior de los acantilados y bajar su altura. Estas serán células propensas a la erosión.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creemos un método que determine si una célula puede ser propensa a la erosión. </font><font style="vertical-align: inherit;">Él determina esto comprobando a los vecinos de la celda hasta que encuentre una diferencia de altura suficientemente grande. </font><font style="vertical-align: inherit;">Dado que los acantilados requieren una diferencia de al menos uno o dos niveles de altura, la celda está sujeta a erosión si uno o más de sus vecinos están al menos dos pasos debajo de ella. </font><font style="vertical-align: inherit;">Si no existe tal vecino, entonces la célula no puede sufrir erosión.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsErodible</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar este método </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para recorrer todas las celdas y escribir todas las celdas propensas a la erosión en una lista temporal.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(cell)) { erodibleCells.Add(cell); } } ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una vez que conocemos el número total de células propensas a la erosión, podemos usar el porcentaje de erosión para determinar el número de células restantes propensas a la erosión. </font><font style="vertical-align: inherit;">Por ejemplo, si el porcentaje es 50, entonces debemos erosionar las células hasta que quede la mitad de la cantidad original. </font><font style="vertical-align: inherit;">Si el porcentaje es 100, entonces no nos detendremos hasta que destruyamos todas las células propensas a la erosión.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErodeLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; erodibleCells = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(erodibleCells); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿No deberíamos considerar solo las células propensas a la erosión de la tierra?</font></font></b> <div class="spoiler_text">     .    ,       ,     . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reducción celular </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos con un enfoque ingenuo y supongamos que una simple reducción en la altura de las células destruidas por erosión hará que ya no sea más propenso a la erosión. </font><font style="vertical-align: inherit;">Si esto fuera cierto, entonces podríamos tomar celdas aleatorias de la lista, reducir su altura y luego eliminarlas de la lista. </font><font style="vertical-align: inherit;">Repetiríamos esta operación hasta alcanzar el número deseado de células susceptibles a la erosión.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetErodibleCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(erodibleCells.Count * (<span class="hljs-number"><span class="hljs-number">100</span></span> - erosionPercentage) * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (erodibleCells.Count &gt; targetErodibleCount) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, erodibleCells.Count); HexCell cell = erodibleCells[index]; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; erodibleCells.Remove(cell); } ListPool&lt;HexCell&gt;.Add(erodibleCells);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar la búsqueda requerida </font></font><code>erodibleCells.Remove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sobrescribiremos la última celda actual de la lista y luego eliminaremos el último elemento. </font><font style="vertical-align: inherit;">Todavía no nos importa su orden.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// erodibleCells.Remove(cell); erodibleCells[index] = erodibleCells[erodibleCells.Count - 1]; erodibleCells.RemoveAt(erodibleCells.Count - 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/050/66c/50e05066c444e6854c622b865fde2726.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14d/fca/6b4/14dfca6b41ce23cdeb3e5fc4d5307eba.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disminución ingenua de 0% y 100% de células propensas a la erosión, mapa de semillas 1957632474.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seguimiento de la erosión </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestro enfoque ingenuo nos permite aplicar erosión, pero no en el grado correcto. </font><font style="vertical-align: inherit;">Esto sucede porque la célula después de una disminución en la altura puede seguir siendo propensa a la erosión. </font><font style="vertical-align: inherit;">Por lo tanto, eliminaremos una celda de la lista solo cuando ya no esté sujeta a erosión.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/281/0a9/779/2810a9779b056865ad4490f9b00fa50f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% de erosión mientras se mantienen las células propensas a la erosión en la lista. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, tenemos una erosión mucho más fuerte, pero cuando usamos el 100% todavía no nos deshacemos de todos los acantilados. </font><font style="vertical-align: inherit;">La razón es que después de reducir la altura de la celda, uno de sus vecinos puede volverse propenso a la erosión. </font><font style="vertical-align: inherit;">Por lo tanto, como resultado, podemos tener más células propensas a la erosión de lo que era originalmente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Después de bajar la celda, debemos verificar todos sus vecinos. </font><font style="vertical-align: inherit;">Si ahora son propensos a la erosión, pero aún no están en la lista, entonces debe agregarlos allí.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/894/ed5/b2a894ed5274286b00046050963388f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se omiten todas las células erosionadas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahorramos mucha tierra </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora el proceso de erosión puede continuar hasta que desaparezcan todos los acantilados. Esto afecta mucho la tierra. La mayor parte de la masa de tierra desapareció y obtuvimos mucho menos que el porcentaje de tierra necesaria. Sucedió porque estamos eliminando tierras del mapa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La verdadera erosión no destruye la materia. Ella lo toma de un lugar y lo coloca en otro lugar. Nosotros podemos hacer lo mismo. Con una disminución en una celda, debemos criar a uno de sus vecinos. De hecho, un nivel de altura se transfiere a una celda inferior. Esto ahorra la cantidad total de alturas del mapa, mientras que simplemente lo suaviza.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para darnos cuenta de esto, debemos decidir dónde transferir los productos de erosión. </font><font style="vertical-align: inherit;">Este será nuestro objetivo de erosión. </font><font style="vertical-align: inherit;">Creemos un método para determinar el punto objetivo de una celda que se erosionará. </font><font style="vertical-align: inherit;">Dado que esta celda contiene un salto, sería lógico seleccionar la celda ubicada debajo de este salto como el objetivo. </font><font style="vertical-align: inherit;">Pero una celda propensa a la erosión puede tener varios descansos, por lo que verificaremos a todos los vecinos y colocaremos a todos los candidatos en una lista temporal, y luego elegiremos uno de ellos al azar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetErosionTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; candidates = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> erodibleElevation = cell.Elevation - <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.Elevation &lt;= erodibleElevation) { candidates.Add(neighbor); } } HexCell target = candidates[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, candidates.Count)]; ListPool&lt;HexCell&gt;.Add(candidates); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><code>ErodeLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definimos la celda objetivo inmediatamente después de seleccionar la celda de erosión. </font><font style="vertical-align: inherit;">Luego disminuimos y aumentamos las alturas de las células inmediatamente una tras otra. </font><font style="vertical-align: inherit;">En este caso, la celda objetivo en sí misma puede volverse susceptible a la erosión, pero esta situación se resuelve cuando verificamos a los vecinos de la celda recién erosionada.</font></font><br><br><pre> <code class="cs hljs"> HexCell cell = erodibleCells[index]; HexCell targetCell = GetErosionTarget(cell); cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; targetCell.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde que elevamos la celda objetivo, parte de los vecinos de esta celda ya no pueden estar sujetos a la erosión. </font><font style="vertical-align: inherit;">Es necesario rodearlos y verificar si son propensos a la erosión. </font><font style="vertical-align: inherit;">Si no, pero están en la lista, debe eliminarlos de ella.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); … } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d71/84f/0b4/d7184f0b4a2dd34853b56e0024ef2b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100% de erosión mientras se mantiene la masa de la tierra. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La erosión ahora puede suavizar el terreno mucho mejor, bajando algunas áreas y elevando otras. </font><font style="vertical-align: inherit;">Como resultado, la masa de tierra puede aumentar y reducirse. </font><font style="vertical-align: inherit;">Esto puede cambiar el porcentaje de tierra en varios por ciento en una dirección u otra, pero rara vez se producen desviaciones graves. </font><font style="vertical-align: inherit;">Es decir, cuanto más erosión apliquemos, menos control tendremos sobre el porcentaje resultante de tierra.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erosión acelerada </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque no necesitamos preocuparnos realmente por la efectividad del algoritmo de erosión, podemos hacer mejoras simples. </font><font style="vertical-align: inherit;">Primero, tenga en cuenta que verificamos explícitamente si la celda que erosionamos puede ser erosionada. </font><font style="vertical-align: inherit;">Si no, esencialmente lo eliminamos de la lista. </font><font style="vertical-align: inherit;">Por lo tanto, puede omitir la comprobación de esta celda al atravesar los vecinos de la celda de destino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; !IsErodible(neighbor) &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En segundo lugar, necesitábamos verificar a los vecinos de la celda objetivo solo cuando había una ruptura entre ellos, pero ahora esto no es necesario. </font><font style="vertical-align: inherit;">Esto solo ocurre cuando el vecino ahora está un paso más arriba que la celda objetivo. </font><font style="vertical-align: inherit;">Si es así, se garantiza que el vecino estará en la lista, por lo que no necesitamos verificar esto, es decir, podemos omitir la búsqueda innecesaria.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = targetCell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor != cell &amp;&amp; neighbor.Elevation == targetCell.Elevation + <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; !IsErodible(neighbor) <span class="hljs-comment"><span class="hljs-comment">// &amp;&amp; erodibleCells.Contains(neighbor) ) { erodibleCells.Remove(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En tercer lugar, podemos usar un truco similar al verificar a los vecinos de una célula propensa a la erosión. </font><font style="vertical-align: inherit;">Si ahora hay un acantilado entre ellos, entonces el vecino es propenso a la erosión. </font><font style="vertical-align: inherit;">Para averiguarlo, no necesitamos llamar </font></font><code>IsErodible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor &amp;&amp; neighbor.Elevation == cell.Elevation + <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// IsErodible(neighbor) &amp;&amp; !erodibleCells.Contains(neighbor) ) { erodibleCells.Add(neighbor); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, aún debemos verificar si la celda objetivo es susceptible a la erosión, pero el ciclo que se muestra arriba ya no lo hace. </font><font style="vertical-align: inherit;">Por lo tanto, realizamos esto explícitamente para la celda objetivo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsErodible(cell)) { erodibleCells[index] = erodibleCells[erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; erodibleCells.RemoveAt(erodibleCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsErodible(targetCell) &amp;&amp; !erodibleCells.Contains(targetCell)) { erodibleCells.Add(targetCell); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos aplicar la erosión lo suficientemente rápido y al porcentaje deseado en relación con el número inicial de acantilados generados. </font><font style="vertical-align: inherit;">Tenga en cuenta que debido al hecho de que cambiamos ligeramente el lugar donde se agrega la celda objetivo a la lista propensa a la erosión, el resultado ha cambiado ligeramente del resultado antes de las optimizaciones.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/a0d/71e/4a6a0d71eea3d1ef119b2f4f984a9b99.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28d/979/289/28d9792899367fdccb50f36b79801935.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7af/921/6af/7af9216af64111dbe0c15898db4560ce.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31b/7d9/ae5/31b7d9ae505297269bbd5442fdff17c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25%, 50%, 75% y 100% de erosión. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">También tenga en cuenta que a pesar de la forma cambiada de la costa, la topología no ha cambiado fundamentalmente. </font><font style="vertical-align: inherit;">Las masas de tierra generalmente permanecen conectadas o separadas. </font><font style="vertical-align: inherit;">Solo las islas pequeñas pueden ahogarse por completo. </font><font style="vertical-align: inherit;">Los detalles en relieve se suavizan, pero las formas generales siguen siendo las mismas. </font><font style="vertical-align: inherit;">Una articulación estrecha puede desaparecer o crecer un poco. </font><font style="vertical-align: inherit;">Un pequeño espacio puede llenarse o expandirse ligeramente. </font><font style="vertical-align: inherit;">Por lo tanto, la erosión no se adherirá fuertemente a las regiones divididas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cd/c53/824/2cdc53824832438c924e2832d9759b06.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuatro regiones completamente erosionadas aún permanecen separadas. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 25: El ciclo del agua </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mostrar datos de mapa sin procesar. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Formamos un clima de células. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crea una simulación parcial del ciclo del agua. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta parte agregaremos humedad en tierra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este tutorial fue creado en Unity 2017.3.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ae/fbe/dae/2aefbedae7b2c65cd86bbd2b4ccc3050.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos el ciclo del agua para determinar los biomas.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Las nubes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta este punto, el algoritmo de generación de mapas cambió solo la altura de la celda. </font><font style="vertical-align: inherit;">La mayor diferencia entre las células era si estaban encima o debajo del agua. </font><font style="vertical-align: inherit;">Aunque podemos definir diferentes tipos de terreno, esto es solo una simple visualización de la altura. </font><font style="vertical-align: inherit;">Será mejor especificar los tipos de alivio, dado el clima local. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El clima de la Tierra es un sistema muy complejo. </font><font style="vertical-align: inherit;">Afortunadamente, no necesitamos crear simulaciones climáticas realistas. </font><font style="vertical-align: inherit;">Necesitaremos algo que parezca lo suficientemente natural. </font><font style="vertical-align: inherit;">El aspecto más importante del clima es el ciclo del agua, porque la flora y la fauna necesitan agua líquida para sobrevivir. </font><font style="vertical-align: inherit;">La temperatura también es muy importante, pero por ahora, nos enfocamos en el agua, esencialmente dejando la temperatura global constante y cambiando solo la humedad.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El ciclo del agua describe el movimiento del agua en el medio ambiente. </font><font style="vertical-align: inherit;">En pocas palabras, los estanques se evaporan, lo que conduce a la creación de nubes que llueven, que nuevamente fluye hacia los estanques. </font><font style="vertical-align: inherit;">Hay muchos más aspectos del sistema, pero simular estos pasos ya puede ser suficiente para crear una distribución natural del agua en el mapa.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualización de datos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de entrar en esta simulación, será útil ver directamente los datos relevantes. </font><font style="vertical-align: inherit;">Para hacer esto, cambiaremos el sombreador de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Le agregamos una propiedad conmutable, que se puede cambiar al modo de visualización de datos, que muestra datos de mapas sin procesar en lugar de las texturas de relieve habituales. </font><font style="vertical-align: inherit;">Esto se puede implementar utilizando una propiedad flotante con un atributo conmutable que define la palabra clave. </font><font style="vertical-align: inherit;">Debido a esto, aparecerá en el inspector de materiales como una bandera que controla la definición de una palabra clave. </font><font style="vertical-align: inherit;">El nombre de la propiedad en sí no es importante, solo nos interesa la palabra clave. </font><font style="vertical-align: inherit;">Estamos utilizando </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHOW_MAP_DATA</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) _BackgroundColor (<span class="hljs-string"><span class="hljs-string">"Background Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) [Toggle(SHOW_MAP_DATA)] _ShowMapData (<span class="hljs-string"><span class="hljs-string">"Show Map Data"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/32b/3e0/45232b3e0a72da1320457492c006613c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambie para mostrar los datos del mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue una función de sombreador para habilitar el soporte de palabras clave.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ GRID_ON #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ HEX_MAP_EDIT_MODE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> shader_feature SHOW_MAP_DATA</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haremos que muestre un único flotador, como es el caso con el resto de los datos de alivio. </font><font style="vertical-align: inherit;">Para implementar esto, agregaremos un </font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo </font><font style="vertical-align: inherit;">a la estructura </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando se defina la palabra clave.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">struct</span></span> Input { <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> color : COLOR; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> worldPos; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> terrain; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> visibility; <span class="hljs-comment"><span class="hljs-comment">#if defined(SHOW_MAP_DATA) float mapData; #endif };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el programa de vértices, usamos el canal Z de estas celdas para completar </font></font><code>mapData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como siempre interpolado entre celdas.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">inout appdata_full v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Input data</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(SHOW_MAP_DATA) data.mapData = cell0.z * v.color.x + cell1.z * v.color.y + cell2.z * v.color.z; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando necesite mostrar datos de celdas, úselos directamente como un fragmento de albedo en lugar del color habitual. </font><font style="vertical-align: inherit;">Multiplíquelo por la cuadrícula para que la cuadrícula todavía esté activada al representar los datos.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … o.Albedo = c.rgb * grid * _Color * explored; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(SHOW_MAP_DATA) o.Albedo = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.mapData * grid; #endif … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para transferir datos a un sombreador. </font><font style="vertical-align: inherit;">necesitamos agregar al </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método que escribe algo en el canal de datos de textura azul. </font><font style="vertical-align: inherit;">Los datos son un valor flotante único limitado a 0-1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">255f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span>); enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, esta decisión afecta el sistema de investigación. </font><font style="vertical-align: inherit;">Se utiliza un valor de datos de canal azul 255 para indicar que la visibilidad de la celda está en transición. </font><font style="vertical-align: inherit;">Para que este sistema continúe funcionando, necesitamos utilizar el valor de byte 254 como máximo. Tenga en cuenta que el movimiento del destacamento borrará todos los datos de la tarjeta, pero esto nos conviene, ya que se utilizan para depurar la generación de tarjetas.</font></font><br><br><pre> <code class="cs hljs"> cellTextureData[cell.Index].b = data &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (data &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(data * <span class="hljs-number"><span class="hljs-number">254f</span></span>) : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">254</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un método con el mismo nombre y en </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Transferirá la solicitud a sus datos de sombreador.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMapData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span> { ShaderData.SetMapData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, data); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para verificar el funcionamiento del código, cámbielo </font></font><code>HexMapGenerator.SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que establezca los datos de cada celda del mapa. </font><font style="vertical-align: inherit;">Visualicemos la altura convertida de entero a flotante en el intervalo 0-1. </font><font style="vertical-align: inherit;">Esto se hace restando la altura mínima de la altura de la celda, seguido de dividir por la altura máxima menos el mínimo. </font><font style="vertical-align: inherit;">Hagamos la división en coma flotante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … cell.SetMapData( (cell.Elevation - elevationMinimum) / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(elevationMaximum - elevationMinimum) ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos cambiar entre el terreno normal y la visualización de datos utilizando la </font><font style="vertical-align: inherit;">casilla de verificación </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mostrar datos del mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del activo de material del </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/577/473/f28/577473f28d08f986124e6459a13a3714.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/c8a/85a/d60c8a85ae315fd509a4f6451629d8dc.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa 1208905299, terreno normal y visualización de alturas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creación del clima </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para simular el clima, necesitamos rastrear los datos climáticos. </font><font style="vertical-align: inherit;">Dado que el mapa consta de celdas discretas, cada una de ellas tiene su propio clima local. </font><font style="vertical-align: inherit;">Cree una estructura </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para almacenar todos los datos relevantes. </font><font style="vertical-align: inherit;">Por supuesto, puede agregar datos a las celdas, pero los usaremos solo cuando generemos el mapa. </font><font style="vertical-align: inherit;">Por lo tanto, los guardaremos por separado. </font><font style="vertical-align: inherit;">Esto significa que podemos definir esta estructura internamente </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como </font></font><code>MapRegion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Comenzaremos solo rastreando nubes, que pueden implementarse usando un solo campo flotante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregue una lista para rastrear los datos climáticos de todas las celdas. </font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora necesitamos un método para crear un mapa climático. </font><font style="vertical-align: inherit;">Debería comenzar borrando la lista de zonas climáticas y luego agregar un elemento para cada celda. </font><font style="vertical-align: inherit;">Los datos climáticos iniciales son simplemente cero, esto se puede lograr utilizando un constructor estándar </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El clima debe crearse después de la exposición a la erosión de la tierra antes de establecer los tipos de alivio. </font><font style="vertical-align: inherit;">En realidad, la erosión es causada principalmente por el movimiento del aire y el agua, que son parte del clima, pero no simularemos esto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); SetTerrainType(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambie </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que podamos ver los datos de la nube en lugar de la altura de la celda. </font><font style="vertical-align: inherit;">Inicialmente, se verá como una tarjeta negra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … cell.SetMapData(climate[i].clouds); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Clima cambiante </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primer paso en la simulación climática es la evaporación. </font><font style="vertical-align: inherit;">¿Cuánta agua debe evaporarse? </font><font style="vertical-align: inherit;">Controlemos este valor usando el control deslizante. </font><font style="vertical-align: inherit;">Un valor de 0 significa que no hay evaporación, 1 - evaporación máxima. </font><font style="vertical-align: inherit;">Por defecto, usamos 0.5.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6af/d8e/ae8/6afd8eae8a1bbb6be361c29d32cc5b99.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante de evaporación. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creemos otro método específicamente para dar forma al clima de una celda. </font><font style="vertical-align: inherit;">Le damos el índice de celda como parámetro y lo usamos para obtener la celda correspondiente y sus datos climáticos. </font><font style="vertical-align: inherit;">Si la celda está bajo el agua, entonces estamos tratando con un depósito que debe evaporarse. </font><font style="vertical-align: inherit;">Inmediatamente convertimos el vapor en nubes (ignorando los puntos de rocío y la condensación), por lo que agregaremos directamente la evaporación al valor de las nubes celulares. </font><font style="vertical-align: inherit;">Cuando haya terminado con esto, copie los datos climáticos nuevamente a la lista.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EvolveClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellIndex</span></span></span><span class="hljs-function">)</span></span> { HexCell cell = grid.GetCell(cellIndex); ClimateData cellClimate = climate[cellIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } climate[cellIndex] = cellClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llame a este método para cada celda en </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero esto no es suficiente. </font><font style="vertical-align: inherit;">Para crear una simulación compleja, necesitamos dar forma al clima de las células varias veces. </font><font style="vertical-align: inherit;">Cuanto más lo hagamos, mejor será el resultado. </font><font style="vertical-align: inherit;">Simplemente elijamos un valor constante. </font><font style="vertical-align: inherit;">Yo uso 40 ciclos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dado que solo aumentamos el valor de las nubes sobre las celdas inundadas con agua, como resultado obtenemos tierra negra y depósitos blancos. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e7/e1c/5dc/3e7e1c5dc9ce75197a94e8ffcd6d8275.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evaporación sobre el agua.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dispersión de nubes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las nubes no están constantemente en un lugar, especialmente cuando se evapora más y más agua. </font><font style="vertical-align: inherit;">La diferencia de presión hace que el aire se mueva, lo que se manifiesta en forma de viento, lo que también hace que las nubes se muevan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si no hay una dirección dominante del viento, entonces, en promedio, las nubes de las células se dispersarán uniformemente en todas las direcciones, apareciendo en las células vecinas. </font><font style="vertical-align: inherit;">Al generar nuevas nubes en el próximo ciclo, distribuyamos todas las nubes en la celda en sus vecinos. </font><font style="vertical-align: inherit;">Es decir, cada vecino recibe un sexto de las nubes celulares, después de lo cual hay una disminución local a cero.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>; climate[cellIndex] = cellClimate;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para agregar nubes a sus vecinos, debe rodearlos en un bucle, obtener sus datos climáticos, aumentar el valor de las nubes y copiarlos nuevamente en la lista. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; climate[neighbor.Index] = neighborClimate; } cellClimate.clouds = <span class="hljs-number"><span class="hljs-number">0f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6a/0e3/437/e6a0e34379d984582c020fde8f1db546.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nubes dispersas.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esto crea un mapa casi blanco, porque en cada ciclo, las células submarinas agregan más y más nubes al clima global. Después del primer ciclo, las células terrestres próximas al agua también tendrán nubes que deben dispersarse. Este proceso continúa hasta que la mayor parte del mapa está cubierto de nubes. En el caso del mapa 1208905299 con los parámetros predeterminados, solo la parte interior de la gran masa de tierra en el noreste permaneció completamente descubierta.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que los estanques pueden generar un número infinito de nubes. </font><font style="vertical-align: inherit;">El nivel del agua no es parte de la simulación climática. </font><font style="vertical-align: inherit;">En realidad, los reservorios se conservan solo porque el agua fluye hacia ellos aproximadamente a la velocidad de evaporación. </font><font style="vertical-align: inherit;">Es decir, solo simulamos un ciclo parcial del agua. </font><font style="vertical-align: inherit;">Esto es normal, pero debemos entender que cuanto más tiempo tenga lugar la simulación, más agua se agrega al clima. </font><font style="vertical-align: inherit;">Hasta ahora, la pérdida de agua ocurre solo en los bordes del mapa, donde las nubes dispersas se pierden debido a la falta de vecinos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede ver la pérdida de agua en la parte superior del mapa, especialmente en las celdas en la parte superior derecha. </font><font style="vertical-align: inherit;">En la última celda no hay nubes en absoluto, porque sigue siendo la última en la que se forma el clima. </font><font style="vertical-align: inherit;">Todavía no ha recibido nubes de un vecino.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿No debería formarse el clima de todas las células en paralelo?</font></font></b> <div class="spoiler_text"> ,        .    -              ,         .   40    . -      ,       . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Precipitación </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El agua no permanece fría para siempre. En algún momento, debería caer al suelo otra vez. Esto generalmente ocurre en forma de lluvia, pero a veces puede ser nieve, granizo o nieve húmeda. Todo esto generalmente se llama precipitación. La magnitud y la tasa de desaparición de las nubes varían mucho, pero solo usamos una tasa de lluvia global personalizada. Un valor de 0 significa que no hay precipitación, un valor de 1 significa que todas las nubes desaparecen instantáneamente. El valor predeterminado es 0.25. Esto significa que en cada ciclo desaparecerá una cuarta parte de las nubes.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitationFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/762/37d/f9076237d0673301af34c32f5cd6688a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante del coeficiente de precipitación. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simularemos precipitación después de la evaporación y antes de la dispersión de las nubes. </font><font style="vertical-align: inherit;">Esto significará que parte del agua evaporada de los depósitos precipita inmediatamente, por lo que disminuye el número de nubes dispersas. </font><font style="vertical-align: inherit;">Sobre la tierra, la precipitación conducirá a la desaparición de las nubes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e3/f11/46a/4e3f1146a761d1525e6a9349ff715bbb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nubes que desaparecen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, cuando destruimos el 25% de las nubes en cada ciclo, la tierra vuelve a ser casi negra. </font><font style="vertical-align: inherit;">Las nubes logran moverse tierra adentro solo unos pocos pasos, después de lo cual se vuelven invisibles. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Humedad </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque la lluvia destruye las nubes, no deberían eliminar el agua del clima. </font><font style="vertical-align: inherit;">Después de caer al suelo, el agua se guarda, solo en un estado diferente. </font><font style="vertical-align: inherit;">Puede existir en muchas formas, que generalmente consideraremos humedad.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seguimiento de la humedad </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos a mejorar el modelo climático mediante el seguimiento de dos condiciones del agua: nubes y humedad. </font><font style="vertical-align: inherit;">Para implementar esto, agregue en el </font></font><code>ClimateData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo </font></font><code>moisture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClimateData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> clouds, moisture; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En su forma más generalizada, la evaporación es el proceso de convertir la humedad en nubes, al menos en nuestro modelo climático simple. </font><font style="vertical-align: inherit;">Esto significa que la evaporación no debe ser un valor constante, sino otro factor. </font><font style="vertical-align: inherit;">Por lo tanto, realizamos refactorización-cambio de nombre </font></font><code>evaporation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>evaporationFactor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporationFactor = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando la celda está bajo el agua, simplemente anunciamos que el nivel de humedad es 1. Esto significa que la evaporación es igual al coeficiente de evaporación. </font><font style="vertical-align: inherit;">Pero ahora también podemos evaporarnos de las celdas de sushi. </font><font style="vertical-align: inherit;">En este caso, necesitamos calcular la evaporación, restarla de la humedad y agregar el resultado a las nubes. </font><font style="vertical-align: inherit;">Después de eso, la precipitación se agrega a la humedad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { cellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; cellClimate.clouds += evaporationFactor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> evaporation = cellClimate.moisture * evaporationFactor; cellClimate.moisture -= evaporation; cellClimate.clouds += evaporation; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que las nubes ahora están respaldadas por la evaporación desde la tierra, podemos moverlas más tierra adentro. </font><font style="vertical-align: inherit;">Ahora la mayor parte de la tierra se ha vuelto gris.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/94f/c71/a0b94fc71728a012254059d760bf47f3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nubes con evaporación de humedad. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambiémoslo </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que muestre humedad en lugar de nubes, porque lo usaremos para determinar los tipos de alivio.</font></font><br><br><pre> <code class="cs hljs"> cell.SetMapData(climate[i].moisture);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cf/78f/d30/3cf78fd3099cf1b3a75befb8ebb0893d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pantalla de humedad. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este punto, la humedad se ve bastante similar a las nubes (excepto que todas las células submarinas son blancas), pero eso cambiará pronto.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escorrentía de lluvia </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La evaporación no es la única forma en que la humedad puede salir de la célula. </font><font style="vertical-align: inherit;">El ciclo del agua nos dice que la mayor parte de la humedad agregada a la tierra de alguna manera termina en el agua. </font><font style="vertical-align: inherit;">El proceso más notable es el flujo de agua sobre la tierra bajo la influencia de la gravedad. </font><font style="vertical-align: inherit;">No simularemos ríos reales, pero usaremos un coeficiente de escorrentía de lluvia personalizado. </font><font style="vertical-align: inherit;">Indicará el porcentaje de agua que drena a las áreas más bajas. </font><font style="vertical-align: inherit;">Por defecto, el stock será igual al 25%.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoffFactor = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c85/e81/648/c85e8164833b60299f80bba99c11be81.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante de drenaje.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿No vamos a generar ríos?</font></font></b> <div class="spoiler_text">          . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La escorrentía del agua actúa como una dispersión de nubes, pero con tres diferencias. En primer lugar, no se elimina toda la humedad de la célula. En segundo lugar, lleva humedad, no nubes. En tercer lugar, baja, es decir, solo a los vecinos con una altura más baja. El coeficiente de escorrentía describe la cantidad de humedad que se derramaría de la celda si todos los vecinos fueran más bajos, pero a menudo son menos. Esto significa que reduciremos la humedad de la celda solo cuando encontremos un vecino debajo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = climate[neighbor.Index]; neighborClimate.clouds += cloudDispersal; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a25/c41/00b/a25c4100bde5139415ebbf0a45068d0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agua que drena a una altura más baja. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, tenemos una distribución de humedad más diversa, porque las células altas transmiten su humedad a las bajas. </font><font style="vertical-align: inherit;">También vemos mucha menos humedad en las células costeras, porque drenan la humedad en las células submarinas. </font><font style="vertical-align: inherit;">Para debilitar este efecto, también necesitamos usar el nivel del agua para determinar si la celda es más baja, es decir, tomar la altura aparente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/ee9/64d/651ee964da5a422bfaa94f27609a5dcd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usa la altura visible.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Filtración </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El agua no solo fluye hacia abajo, se extiende, se filtra a través de la topografía llana, y es absorbida por la tierra adyacente a los cuerpos de agua. </font><font style="vertical-align: inherit;">Este efecto puede tener poco efecto, pero es útil para suavizar la distribución de humedad, así que vamos a agregarlo a la simulación. </font><font style="vertical-align: inherit;">Creemos su propio coeficiente personalizado, por defecto igual a 0.125.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepageFactor = <span class="hljs-number"><span class="hljs-number">0.125f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/495/855/b73/495855b73d4601ab3de00b3561285491.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante de fugas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La filtración es similar a un drenaje, excepto que se usa cuando el vecino tiene la misma altura visible que la celda misma.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> runoff = cellClimate.moisture * runoffFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> seepage = cellClimate.moisture * seepageFactor * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationDelta = neighbor.ViewElevation - cell.ViewElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= runoff; neighborClimate.moisture += runoff; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevationDelta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cellClimate.moisture -= seepage; neighborClimate.moisture += seepage; } climate[neighbor.Index] = neighborClimate; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d39/7b2/b01/d397b2b01ad8e71137b9e5fa03fcf5a5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se agregó una pequeña fuga. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sombras de lluvia </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque ya hemos creado una simulación digna del ciclo del agua, no parece muy interesante, ya que no tiene sombras de lluvia, lo que demuestra claramente las diferencias climáticas. </font><font style="vertical-align: inherit;">Las sombras de lluvia son áreas en las que hay una falta significativa de lluvia en comparación con las áreas vecinas. </font><font style="vertical-align: inherit;">Tales áreas existen porque las montañas evitan que las nubes las alcancen. </font><font style="vertical-align: inherit;">Su creación requiere altas montañas y una dirección dominante del viento.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El viento </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos agregando una dirección dominante del viento a la simulación. </font><font style="vertical-align: inherit;">Aunque las direcciones dominantes del viento varían mucho en la superficie de la Tierra, nos las arreglaremos con una dirección del viento global personalizable. </font><font style="vertical-align: inherit;">Usemos el noroeste por defecto. </font><font style="vertical-align: inherit;">Además, hagamos que la fuerza del viento sea ajustable de 1 a 10 con un valor predeterminado de 4.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection windDirection = HexDirection.NW; [Range(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> windStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/4a1/49c/f324a149c360bbfde72e98b4877afb37.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La dirección y la fuerza del viento. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fuerza del viento dominante se expresa en relación con la dispersión total de las nubes. </font><font style="vertical-align: inherit;">Si la fuerza del viento es 1, la dispersión es la misma en todas las direcciones. </font><font style="vertical-align: inherit;">Cuando es 2, la dispersión es dos más alta en la dirección del viento que en otras direcciones, y así sucesivamente. </font><font style="vertical-align: inherit;">Podemos hacer esto cambiando el divisor en la fórmula de dispersión de la nube. </font><font style="vertical-align: inherit;">En lugar de seis, será igual a cinco más energía eólica.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además, la dirección del viento determina la dirección desde la cual sopla el viento. </font><font style="vertical-align: inherit;">Por lo tanto, necesitamos usar la dirección opuesta como la dirección principal de dispersión.</font></font><br><br><pre> <code class="cs hljs"> HexDirection mainDispersalDirection = windDirection.Opposite(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudDispersal = cellClimate.clouds * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / (<span class="hljs-number"><span class="hljs-number">5f</span></span> + windStrength));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos verificar si el vecino está en la dirección principal de dispersión. </font><font style="vertical-align: inherit;">Si es así, entonces debemos multiplicar la dispersión de las nubes por la fuerza del viento.</font></font><br><br><pre> <code class="cs hljs"> ClimateData neighborClimate = climate[neighbor.Index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d == mainDispersalDirection) { neighborClimate.clouds += cloudDispersal * windStrength; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { neighborClimate.clouds += cloudDispersal; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/874/2d5/e7e8742d53033ee4ee89f68e60871426.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viento del noroeste, fuerza 4.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El viento dominante agrega direccionalidad a la distribución de humedad sobre la tierra. </font><font style="vertical-align: inherit;">Cuanto más fuerte es el viento, más poderoso se vuelve el efecto.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Altura absoluta </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El segundo ingrediente para obtener sombras de lluvia son las montañas. No tenemos una clasificación estricta de lo que es una montaña, así como la naturaleza tampoco la tiene. Solo la altura absoluta es importante. De hecho, cuando el aire se mueve sobre la montaña, se ve obligado a elevarse, se enfría y puede contener menos agua, lo que conduce a la precipitación antes de que el aire pase sobre la montaña. Como resultado, del otro lado obtenemos aire seco, es decir, una sombra de lluvia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo más importante, cuanto más alto sube el aire, menos agua puede contener. </font><font style="vertical-align: inherit;">En nuestra simulación, podemos imaginar esto como una restricción forzada del valor máximo de nube para cada celda. </font><font style="vertical-align: inherit;">Cuanto mayor sea la altura de la celda visible, menor debería ser este máximo. </font><font style="vertical-align: inherit;">La forma más fácil de hacer esto es establecer el máximo en 1 menos la altura aparente, dividido por la altura máxima. </font><font style="vertical-align: inherit;">Pero, de hecho, dividamos por un máximo de menos 1. Esto permitirá que una pequeña fracción de las nubes atraviese incluso las celdas más altas. </font><font style="vertical-align: inherit;">Asignamos este máximo después de calcular la precipitación y antes de la dispersión.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> precipitation = cellClimate.clouds * precipitationFactor; cellClimate.clouds -= precipitation; cellClimate.moisture += precipitation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); HexDirection mainDispersalDirection = windDirection.Opposite();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si como resultado obtenemos más nubes de lo aceptable, simplemente convertimos el exceso de nubes en humedad. </font><font style="vertical-align: inherit;">De hecho, así es como agregamos precipitaciones adicionales, como sucede en montañas reales.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cloudMaximum = <span class="hljs-number"><span class="hljs-number">1f</span></span> - cell.ViewElevation / (elevationMaximum + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellClimate.clouds &gt; cloudMaximum) { cellClimate.moisture += cellClimate.clouds - cloudMaximum; cellClimate.clouds = cloudMaximum; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/403/998/c36/403998c36a6d85250f837766a4f33147.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sombras de lluvia causadas por la gran altitud. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Completamos la simulación </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta etapa, ya tenemos una simulación parcial de muy alta calidad del ciclo del agua. </font><font style="vertical-align: inherit;">Vamos a ponerlo en orden un poco y luego aplicarlo para determinar el tipo de alivio de las células.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Computación paralela </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como se mencionó anteriormente bajo el spoiler, el orden en que se forman las celdas afecta el resultado de la simulación. </font><font style="vertical-align: inherit;">Idealmente, esto no debería ser y, en esencia, formamos todas las células en paralelo. </font><font style="vertical-align: inherit;">Esto se puede hacer aplicando todos los cambios de la etapa actual de formación a la segunda lista de clima </font></font><code>nextClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;ClimateData&gt; climate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;(); List&lt;ClimateData&gt; nextClimate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ClimateData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Borre e inicialice esta lista, como todos los demás. </font><font style="vertical-align: inherit;">Luego intercambiaremos listas en cada ciclo. </font><font style="vertical-align: inherit;">En este caso, la simulación utilizará alternativamente las dos listas y aplicará los datos climáticos actuales y futuros.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateClimate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { climate.Clear(); nextClimate.Clear(); ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(initialData); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; cycle &lt; <span class="hljs-number"><span class="hljs-number">40</span></span>; cycle++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { EvolveClimate(i); } List&lt;ClimateData&gt; swap = climate; climate = nextClimate; nextClimate = swap; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cuando una célula afecta el clima de su vecino, debemos cambiar los siguientes datos climáticos, no el actual. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData neighborClimate = nextClimate[neighbor.Index]; … nextClimate[neighbor.Index] = neighborClimate; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y en lugar de copiar los siguientes datos climáticos a la lista climática actual, obtenemos los siguientes datos climáticos, les agregamos la humedad actual y los copiamos a la siguiente lista. </font><font style="vertical-align: inherit;">Después de eso, restablecemos los datos en la lista actual para que se actualicen para el próximo ciclo.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// cellClimate.clouds = 0f; ClimateData nextCellClimate = nextClimate[cellIndex]; nextCellClimate.moisture += cellClimate.moisture; nextClimate[cellIndex] = nextCellClimate; climate[cellIndex] = new ClimateData();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mientras hacemos esto, también establezcamos el nivel de humedad en un máximo de 1 para que las células terrestres no puedan estar más húmedas que bajo el agua. </font></font><br><br><pre> <code class="cs hljs"> nextCellClimate.moisture += cellClimate.moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextCellClimate.moisture &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { nextCellClimate.moisture = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } nextClimate[cellIndex] = nextCellClimate;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a8/709/87b/6a870987bfad51e91eaa1ff405be539d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computación paralela.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Humedad original </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existe la posibilidad de que la simulación produzca demasiada tierra seca, especialmente con un alto porcentaje de tierra. </font><font style="vertical-align: inherit;">Para mejorar la imagen, podemos agregar un nivel de humedad inicial personalizado con un valor predeterminado de 0.1.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startingMoisture = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/69b/3a2/db869b3a24627d695d9ec8bf2ba1f4ae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arriba está el control deslizante de la humedad original. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizamos este valor para la humedad de la lista climática inicial, pero no para lo siguiente.</font></font><br><br><pre> <code class="cs hljs"> ClimateData initialData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); initialData.moisture = startingMoisture; ClimateData clearData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClimateData(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { climate.Add(initialData); nextClimate.Add(clearData); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a74/138/649/a74138649fc141c088a631bce956a31a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con humedad original.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Definiendo biomas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concluimos usando humedad en lugar de altura para especificar el tipo de alivio celular. </font><font style="vertical-align: inherit;">Usemos nieve para tierras completamente secas, para regiones áridas usamos nieve, luego hay piedra, pasto para lo suficientemente húmedo y tierra para células saturadas de agua y bajo el agua. </font><font style="vertical-align: inherit;">La forma más fácil es usar cinco intervalos en incrementos de 0.2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.2f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.4f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.6f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.SetMapData(moisture); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/123/c53/e4f/123c53e4f3f79aa50437a553e0eb6761.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomas </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando se usa una distribución uniforme, el resultado no es muy bueno y no parece natural. </font><font style="vertical-align: inherit;">Es mejor usar otros umbrales, por ejemplo 0.05, 0.12, 0.28 y 0.85.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.05f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.12f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.28f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moisture &lt; <span class="hljs-number"><span class="hljs-number">0.85f</span></span>) { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ad/8cf/7c7/6ad8cf7c7becf357d16157ae28999a14.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomas modificados. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 26: biomas y ríos </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creamos los ríos que se originan a partir de celdas altas con humedad. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creamos un modelo de temperatura simple. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usamos la matriz de bioma para las células y luego la cambiamos. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta parte, complementaremos el ciclo del agua con ríos y temperatura, así como asignaremos biomas más interesantes a las células. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El tutorial fue creado usando Unity 2017.3.0p3.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/0b2/d11/3050b2d115d1ec49e2b6c945ab9ed4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El calor y el agua animan el mapa.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generación fluvial </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los ríos son consecuencia del ciclo del agua. </font><font style="vertical-align: inherit;">De hecho, están formados por escorrentías que se rompen con la ayuda de la erosión del canal. </font><font style="vertical-align: inherit;">Esto implica que puede agregar ríos según el valor de los drenajes celulares. </font><font style="vertical-align: inherit;">Sin embargo, esto no garantiza que obtendremos algo que se asemeje a ríos reales. </font><font style="vertical-align: inherit;">Cuando comencemos el río, tendrá que fluir lo más lejos posible, potencialmente a través de muchas celdas. </font><font style="vertical-align: inherit;">Esto no es consistente con nuestra simulación del ciclo del agua, que procesa las células en paralelo. </font><font style="vertical-align: inherit;">Además, generalmente es necesario controlar la cantidad de ríos en un mapa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como los ríos son muy diferentes, los generaremos por separado. </font><font style="vertical-align: inherit;">Utilizamos los resultados de la simulación del ciclo del agua para determinar la ubicación de los ríos, pero los ríos, a su vez, no afectarán la simulación.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Por qué el flujo del río a veces es incorrecto?</font></font></b> <div class="spoiler_text">    <code>TriangulateWaterShore</code>  ,    .      ,    .   ,    ,       .      ,  .    ,  ,       .         («»). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary( e1, e2, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction, indices ); } … }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Celdas de alta humedad </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En nuestros mapas, una celda puede o no tener un río. Además, pueden ramificarse o conectarse. En realidad, los ríos son mucho más flexibles, pero tenemos que pasar con esta aproximación, que crea solo ríos grandes. Lo más importante, necesitamos determinar la ubicación del comienzo de un río grande, que se elige al azar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como los ríos requieren agua, la fuente del río debe estar en una celda con alta humedad. Pero esto no es suficiente. Los ríos fluyen por las laderas, por lo que idealmente la fuente debería tener una gran altura. Cuanto mayor sea la celda por encima del nivel del agua, mejor candidato es para el papel de la fuente del río. Podemos visualizar esto como datos del mapa dividiendo la altura de la celda por la altura máxima. Para que el resultado se obtenga en relación con el nivel del agua, lo restaremos de ambas alturas antes de dividirlo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f9/d80/2de/6f9d802de155c2b1e051be5d360dc3c1.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/e8f/6a2/f5ce8f6a20d7336dc94b89812c123827.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Humedad y altitud. Gran número de mapa 1208905299 con la configuración predeterminada.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los mejores candidatos son aquellas células que tienen alta humedad y altura. Podemos combinar estos criterios multiplicándolos. El resultado será el valor de la condición física o el peso de las fuentes de los ríos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); cell.SetMapData(data);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec2/31f/445/ec231f445d785c24c6cd9f191ed6c24a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesos para las fuentes de los ríos.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Idealmente, usaríamos estos pesos para rechazar la selección aleatoria de la celda fuente. Aunque podemos crear una lista con los pesos correctos y elegir, este es un enfoque no trivial y ralentiza el proceso de generación. Una clasificación más simple de importancia dividida en cuatro niveles será suficiente para nosotros. Los primeros candidatos serán pesos con valores superiores a 0,75. Los buenos candidatos tienen pesos de 0.5. Los candidatos elegibles son mayores que 0.25. Todas las demás células se descartan. Vamos a mostrar cómo se ve gráficamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data = moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">1f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { cell.SetMapData(<span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(data);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/056/5ba/3b7/0565ba3b7a51499bfe1d389ecd270910.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Categorías de pesos de las fuentes fluviales. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con este esquema de clasificación, es probable que obtengamos ríos con fuentes en las áreas más altas y húmedas del mapa. </font><font style="vertical-align: inherit;">Sin embargo, la probabilidad de crear ríos en áreas relativamente secas o bajas permanece, lo que aumenta la variabilidad. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un método </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que llene una lista de celdas según estos criterios. </font><font style="vertical-align: inherit;">Las celdas elegibles se agregan a esta lista una vez, las buenas dos veces y las principales candidatas cuatro veces. </font><font style="vertical-align: inherit;">Las celdas submarinas siempre se descartan, por lo que no puede verificarlas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ClimateData data = climate[i]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> weight = data.moisture * (cell.Elevation - waterLevel) / (elevationMaximum - waterLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.75f</span></span>) { riverOrigins.Add(cell); riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { riverOrigins.Add(cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (weight &gt; <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { riverOrigins.Add(cell); } } ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este método debe llamarse después </font></font><code>CreateClimate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que los datos de humedad estén disponibles para nosotros.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateRegions(); CreateLand(); ErodeLand(); CreateClimate(); CreateRivers(); SetTerrainType(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Una vez completada la clasificación, puede deshacerse de la visualización de sus datos en el mapa. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … <span class="hljs-comment"><span class="hljs-comment">// float data = // moisture * (cell.Elevation - waterLevel) / // (elevationMaximum - waterLevel); // if (data &gt; 0.6f) { // cell.SetMapData(1f); // } // else if (data &gt; 0.4f) { // cell.SetMapData(0.5f); // } // else if (data &gt; 0.2f) { // cell.SetMapData(0.25f); // } } }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puntos de río </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cuántos ríos necesitamos? </font><font style="vertical-align: inherit;">Este parámetro debe ser personalizable. </font><font style="vertical-align: inherit;">Dado que la longitud de los ríos varía, será más lógico controlarlo con la ayuda de puntos fluviales, que determinan la cantidad de celdas terrestres en las que deben estar contenidos los ríos. </font><font style="vertical-align: inherit;">Expresémoslos como un porcentaje con un máximo del 20% y un valor predeterminado del 10%. </font><font style="vertical-align: inherit;">Al igual que el porcentaje de sushi, este es un valor objetivo, no garantizado. </font><font style="vertical-align: inherit;">Como resultado, podemos tener muy pocos candidatos o ríos que sean demasiado cortos para cubrir la cantidad de tierra requerida. </font><font style="vertical-align: inherit;">Es por eso que el porcentaje máximo no debe ser demasiado grande.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0, 20)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverPercentage = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/793/1c6/4cd/7931c64cd7bdffbb17f83a94aed1bbc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante por ciento de ríos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para determinar los puntos de los ríos, expresados ​​como el número de celdas, debemos recordar cuántas celdas terrestres se generaron </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCount, landCells; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); landCells = landBudget; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guard = <span class="hljs-number"><span class="hljs-number">0</span></span>; guard &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span>; guard++) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up "</span></span> + landBudget + <span class="hljs-string"><span class="hljs-string">" land budget."</span></span>); landCells -= landBudget; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el interior, la </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cantidad de puntos de río ahora se puede calcular de la misma manera que nosotros </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { List&lt;HexCell&gt; riverOrigins = ListPool&lt;HexCell&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); ListPool&lt;HexCell&gt;.Add(riverOrigins); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además, continuaremos tomando y eliminando celdas aleatorias de la lista original, mientras todavía tengamos puntos y celdas de origen. </font><font style="vertical-align: inherit;">En caso de completar el número de puntos, mostraremos una advertencia en la consola.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> riverBudget = Mathf.RoundToInt(landCells * riverPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Failed to use up river budget."</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además, agregamos un método para crear ríos directamente. </font><font style="vertical-align: inherit;">Como parámetro, necesita una celda inicial y, una vez finalizado, debe devolver la longitud del río. </font><font style="vertical-align: inherit;">Comenzamos almacenando un método que devuelve longitud cero.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamaremos a este método al final del ciclo que acabamos de agregar </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, utilizando para reducir el número de puntos restantes. </font><font style="vertical-align: inherit;">Nos aseguramos de que se cree un nuevo río solo si la celda seleccionada no tiene un río que fluya a través de él.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ríos actuales </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es lógico crear ríos que fluyan hacia el mar u otro cuerpo de agua. </font><font style="vertical-align: inherit;">Cuando comenzamos desde la fuente, obtenemos inmediatamente la longitud 1. Después de eso, seleccionamos un vecino aleatorio y aumentamos la longitud. </font><font style="vertical-align: inherit;">Continuamos moviéndonos hasta llegar a la celda submarina.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { HexDirection direction = (HexDirection)Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); cell.SetOutgoingRiver(direction); length += <span class="hljs-number"><span class="hljs-number">1</span></span>; cell = cell.GetNeighbor(direction); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/359/7cf/7a7/3597cf7a7ae263721b381534185e7645.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ríos al azar. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado de un enfoque tan ingenuo, obtenemos fragmentos de ríos dispersos al azar, principalmente debido al reemplazo de ríos generados previamente. </font><font style="vertical-align: inherit;">Esto incluso puede conducir a errores, porque no verificamos si el vecino realmente existe. </font><font style="vertical-align: inherit;">Necesitamos verificar todas las direcciones en el bucle y asegurarnos de que haya un vecino allí. </font><font style="vertical-align: inherit;">Si es así, entonces agregamos esta dirección a la lista de posibles direcciones de flujo, pero solo si el río aún no fluye a través de este vecino. </font><font style="vertical-align: inherit;">Luego seleccione un valor aleatorio de esta lista.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexDirection&gt; flowDirections = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexDirection&gt;(); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d); } HexDirection direction = <span class="hljs-comment"><span class="hljs-comment">// (HexDirection)Random.Range(0, 6); flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con este nuevo enfoque, podemos tener cero direcciones de flujo disponibles. </font><font style="vertical-align: inherit;">Cuando esto sucede, el río ya no puede fluir más y debe terminar. </font><font style="vertical-align: inherit;">Si en este momento la longitud es 1, esto significa que no podríamos escapar de la celda original, es decir, no puede haber ningún río. </font><font style="vertical-align: inherit;">En este caso, la longitud del río es cero.</font></font><br><br><pre> <code class="cs hljs"> flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/5bd/05d/e6f5bd05d8d5a976d6fff9fa14397a25.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rios preservados.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Correr hacia abajo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora salvamos los ríos ya creados, pero aún podemos obtener fragmentos aislados de los ríos. </font><font style="vertical-align: inherit;">Esto sucede porque mientras ignoramos las alturas. </font><font style="vertical-align: inherit;">Cada vez que forzamos el flujo del río a una altura mayor, </font></font><code>HexCell.SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interrumpimos este intento, lo que provocó rupturas en los ríos. </font><font style="vertical-align: inherit;">Por lo tanto, también debemos omitir las direcciones que hacen que los ríos fluyan hacia arriba.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || neighbor.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } flowDirections.Add(d);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae6/cf7/696/ae6cf76968d64228e88378749939f1f2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ríos que fluyen hacia abajo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Así que nos deshacemos de muchos fragmentos de ríos, pero aún quedan algunos. </font><font style="vertical-align: inherit;">A partir de este momento, deshacerse de los ríos más feos se convierte en una cuestión de refinamiento. </font><font style="vertical-align: inherit;">Para empezar, los ríos prefieren descender lo más rápido posible. </font><font style="vertical-align: inherit;">No elegirán necesariamente la ruta más corta posible, pero la probabilidad de que esto sea grande. </font><font style="vertical-align: inherit;">Para simular esto, agregaremos instrucciones tres veces a la lista.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } flowDirections.Add(d);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evite giros bruscos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además de fluir hacia abajo, el agua también tiene inercia. </font><font style="vertical-align: inherit;">Es más probable que un río fluya en línea recta o se doble ligeramente que en un giro brusco repentino. </font><font style="vertical-align: inherit;">Podemos agregar esta distorsión rastreando la última dirección del río. </font><font style="vertical-align: inherit;">Si la dirección potencial de la corriente no se desvía demasiado de esta dirección, agréguela nuevamente a la lista. </font><font style="vertical-align: inherit;">Esto no es un problema para la fuente, por lo que siempre lo agregaremos nuevamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell cell = origin; HexDirection direction = HexDirection.NE; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { flowDirections.Add(d); flowDirections.Add(d); flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( length == <span class="hljs-number"><span class="hljs-number">1</span></span> || (d != direction.Next2() &amp;&amp; d != direction.Previous2()) ) { flowDirections.Add(d); } flowDirections.Add(d); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? length : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// HexDirection direction = direction = flowDirections[Random.Range(0, flowDirections.Count)]; cell.SetOutgoingRiver(direction); length += 1; cell = cell.GetNeighbor(direction); } return length; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esto reduce en gran medida la probabilidad de que los ríos zigzagueen con un aspecto feo. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/83b/ce7/67483bce79b287f3cc451e381dc686d2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menos giros bruscos.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Confluencia fluvial </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A veces resulta que el río fluye justo al lado de la fuente del río creado anteriormente. </font><font style="vertical-align: inherit;">Si la fuente de este río no está a una altitud más alta, entonces podemos decidir que el nuevo río desemboca en el antiguo. </font><font style="vertical-align: inherit;">Como resultado, obtenemos un río largo, y no dos vecinos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para hacer esto, dejaremos pasar al vecino solo si hay un río entrante o si es la fuente del río actual. </font><font style="vertical-align: inherit;">Habiendo determinado que esta dirección no está arriba, verificamos si hay un río saliente. </font><font style="vertical-align: inherit;">Si lo hay, encontramos nuevamente el viejo río. </font><font style="vertical-align: inherit;">Dado que esto ocurre con bastante poca frecuencia, no participaremos en la verificación de otras fuentes vecinas e inmediatamente combinaremos los ríos.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor.HasRiver) { // continue; // } if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } if (neighbor.HasOutgoingRiver) { cell.SetOutgoingRiver(d); return length; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb3/820/ee6/bb3820ee6271b8bc7b32e901b39c906a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ba/d8f/08d/3bad8f08d23cfe3844ec259a1c2475d6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ríos antes y después de la agrupación.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mantener distancia </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que los buenos candidatos para el rol fuente generalmente se agrupan, obtendremos grupos de ríos. </font><font style="vertical-align: inherit;">Además, podemos tener ríos que toman la fuente justo al lado del embalse, lo que da como resultado ríos de longitud 1. Podemos distribuir las fuentes, descartando las que están cerca del río o embalse. </font><font style="vertical-align: inherit;">Hacemos esto sin pasar por los vecinos de la fuente seleccionada en un bucle dentro </font></font><code>CreateRivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si encontramos un vecino que viola las reglas, entonces la fuente no nos conviene y debemos omitirla.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (riverBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; riverOrigins.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, riverOrigins.Count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = riverOrigins.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; HexCell origin = riverOrigins[index]; riverOrigins[index] = riverOrigins[lastIndex]; riverOrigins.RemoveAt(lastIndex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!origin.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = origin.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; (neighbor.HasRiver || neighbor.IsUnderwater)) { isValidOrigin = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isValidOrigin) { riverBudget -= CreateRiver(origin); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y aunque los ríos seguirán fluyendo uno al lado del otro, tienden a cubrir un área más grande. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/bed/3a6/887bed3a6032b4bea508ee6ceda4a228.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/b85/428/f53b85428840118895d74f62b1c2d1a6.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin distancia y con ello.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terminamos el rio con un lago </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No todos los ríos llegan al embalse, algunos quedan atrapados en los valles o son bloqueados por otros ríos. Este no es un problema particular, porque a menudo los ríos reales también parecen desaparecer. Esto puede suceder, por ejemplo, si fluyen bajo tierra, se dispersan en un área pantanosa o se secan. Nuestros ríos no pueden visualizar esto, por lo que simplemente terminan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, podemos intentar minimizar el número de tales casos. Aunque no podemos unir los ríos o hacer que fluyan hacia arriba, podemos hacer que terminen en lagos, que a menudo se encuentran en la realidad y se ven bien. Para esto</font></font><code>CreateRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debería elevar el nivel del agua en la celda si se atasca. </font><font style="vertical-align: inherit;">La posibilidad de esto depende de la altura mínima de los vecinos de esta celda. </font><font style="vertical-align: inherit;">Por lo tanto, para rastrear esto cuando se estudian vecinos, se requiere una pequeña alteración del código.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minNeighborElevation = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; flowDirections.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || neighbor == origin || neighbor.HasIncomingRiver) { // continue; // } if (!neighbor) { continue; } if (neighbor.Elevation &lt; minNeighborElevation) { minNeighborElevation = neighbor.Elevation; } if (neighbor == origin || neighbor.HasIncomingRiver) { continue; } int delta = neighbor.Elevation - cell.Elevation; if (delta &gt; 0) { continue; } … } … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si estamos atascados, primero debemos comprobar si todavía estamos en la fuente. </font><font style="vertical-align: inherit;">En caso afirmativo, simplemente cancele el río. </font><font style="vertical-align: inherit;">De lo contrario, verificamos si todos los vecinos son al menos tan altos como la celda actual. </font><font style="vertical-align: inherit;">Si es así, entonces podemos elevar el agua a este nivel. </font><font style="vertical-align: inherit;">Esto creará un lago a partir de una celda, a menos que la altura de la celda permanezca en el mismo nivel. </font><font style="vertical-align: inherit;">Si es así, simplemente asigne la altura un nivel por debajo del nivel del agua.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flowDirections.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// return length &gt; 1 ? length : 0; if (length == 1) { return 0; } if (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = minNeighborElevation; if (minNeighborElevation == cell.Elevation) { cell.Elevation = minNeighborElevation - 1; } } break; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/7da/964/d607da964da18b71cd022c997661695c.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee8/ab1/000/ee8ab10002cd3e36cefbcfe3980a8fbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los extremos de ríos sin lagos y con lagos. </font><font style="vertical-align: inherit;">En este caso, el porcentaje de ríos es 20.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tenga en cuenta que ahora podemos tener células submarinas por encima del nivel de agua utilizado para generar el mapa. </font><font style="vertical-align: inherit;">Denotarán lagos sobre el nivel del mar.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lagos adicionales </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">También podemos crear lagos, incluso si no estamos atascados. </font><font style="vertical-align: inherit;">Esto puede resultar en un río que fluye dentro y fuera del lago. </font><font style="vertical-align: inherit;">Si no estamos atascados, se puede crear un lago elevando el nivel del agua y luego la altura actual de la celda, y luego reduciendo la altura de la celda. </font><font style="vertical-align: inherit;">Esto se aplica solo cuando la altura mínima del vecino es al menos igual a la altura de la celda actual. </font><font style="vertical-align: inherit;">Hacemos esto al final del ciclo del río y antes de pasar a la siguiente celda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cell.IsUnderwater) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minNeighborElevation &gt;= cell.Elevation) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell = cell.GetNeighbor(direction); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/945/5bb/2b6/9455bb2b6547a8b1342e179f15eb5925.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f84/516/4b7/f845164b7a543b9549cd9f07d273e67f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin lagos adicionales y con ellos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Varios lagos son hermosos, pero sin límites podemos crear demasiados lagos. </font><font style="vertical-align: inherit;">Por lo tanto, agreguemos una probabilidad personalizada para lagos adicionales, con un valor predeterminado de 0.25.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> extraLakeProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ella controlará la probabilidad de generar un lago adicional, si es posible. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( minNeighborElevation &gt;= cell.Elevation &amp;&amp; Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; extraLakeProbability ) { cell.WaterLevel = cell.Elevation; cell.Elevation -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa5/d04/bc3/fa5d04bc3f7475ec2baab7b6e7dac38f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/118/bb4/364/118bb4364acb0646efb54a031d3ac356.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lagos adicionales.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué hay de crear lagos con más de una celda?</font></font></b> <div class="spoiler_text">     ,       ,  ,      .      .      :          .       ,       .  ,      ,     ,   . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2>  Temperatura </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El agua es solo uno de los factores que pueden determinar el bioma de una célula. </font><font style="vertical-align: inherit;">Otro factor importante es la temperatura. </font><font style="vertical-align: inherit;">Aunque podemos simular el flujo y la difusión de temperaturas como la simulación del agua, para crear un clima interesante, solo necesitamos un factor complejo. </font><font style="vertical-align: inherit;">Por lo tanto, mantengamos la temperatura simple y configurémosla para cada celda.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temperatura y latitud </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mayor influencia en la temperatura es la latitud. </font><font style="vertical-align: inherit;">Hace calor en el ecuador, frío en los polos y hay una transición suave entre ellos. </font><font style="vertical-align: inherit;">Creemos un método </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que devuelva la temperatura de una celda determinada. </font><font style="vertical-align: inherit;">Para comenzar, simplemente usamos la coordenada Z de la celda dividida por la dimensión Z como la latitud, y luego usamos este valor como la temperatura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> latitude; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definimos la temperatura en </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la usamos como datos del mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); cell.SetMapData(temperature); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moisture = climate[i].moisture; … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/789/7f6/334/7897f63347b08fdb02ee5794f3ab28e3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latitud como temperatura, hemisferio sur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenemos un gradiente de temperatura lineal que aumenta de abajo hacia arriba. </font><font style="vertical-align: inherit;">Puede usarlo para simular el hemisferio sur, con un polo en la parte inferior y un ecuador en la parte superior. </font><font style="vertical-align: inherit;">Pero no necesitamos describir todo el hemisferio. </font><font style="vertical-align: inherit;">Con una diferencia de temperatura más pequeña o ninguna diferencia, podemos describir un área más pequeña. </font><font style="vertical-align: inherit;">Para hacer esto, haremos que las temperaturas bajas y altas sean personalizables. </font><font style="vertical-align: inherit;">Estableceremos estas temperaturas en el rango 0-1, y utilizaremos los valores extremos como valores predeterminados.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lowTemperature = <span class="hljs-number"><span class="hljs-number">0f</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> highTemperature = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b1/8cf/805/3b18cf805a56a0dbbeabb03b69a00496.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deslizadores de temperatura. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplicamos el rango de temperatura usando interpolación lineal, usando la latitud como interpolador. </font><font style="vertical-align: inherit;">Como expresamos la latitud como un valor de 0 a 1, podemos usarlo </font></font><code>Mathf.LerpUnclamped</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que las bajas temperaturas no son necesariamente más bajas que las altas. </font><font style="vertical-align: inherit;">Si lo desea, puede entregarlos.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hemisferio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos simular el hemisferio sur, y posiblemente el hemisferio norte, si tomamos las temperaturas primero. </font><font style="vertical-align: inherit;">Pero es mucho más conveniente usar una opción de configuración separada para cambiar entre hemisferios. </font><font style="vertical-align: inherit;">Vamos a crear una enumeración y un campo para ello. </font><font style="vertical-align: inherit;">Por lo tanto, también agregaremos la opción de crear ambos hemisferios, que es aplicable por defecto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HemisphereMode { Both, North, South } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HemisphereMode hemisphere;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/c67/03f/be8c6703f51cd7c62535a96a3035a284.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La elección del hemisferio. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si necesitamos el hemisferio norte, entonces simplemente podemos voltear la latitud, restándola de 1. Para simular ambos hemisferios, los polos deben estar debajo y encima del mapa, y el ecuador debe estar en el medio. </font><font style="vertical-align: inherit;">Puede hacer esto duplicando la latitud, mientras que el hemisferio inferior se procesará correctamente, y el superior tendrá una latitud de 1 a 2. Para arreglar esto, restamos la latitud de 2 cuando excede 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> latitude = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)cell.coordinates.Z / grid.cellCountZ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.Both) { latitude *= <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latitude &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) { latitude = <span class="hljs-number"><span class="hljs-number">2f</span></span> - latitude; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hemisphere == HemisphereMode.North) { latitude = <span class="hljs-number"><span class="hljs-number">1f</span></span> - latitude; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c7/871/ede/9c7871ede0c56a393bc603ec888c65bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambos hemisferios. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vale la pena señalar que esto crea la posibilidad de crear un mapa exótico en el que el ecuador está frío y los polos están calientes.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cuanto más alto es el más frío </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además de la latitud, la temperatura también se ve significativamente afectada por la altitud. </font><font style="vertical-align: inherit;">En promedio, cuanto más subimos, más frío se pone. </font><font style="vertical-align: inherit;">Podemos convertir esto en un factor, como hicimos con los candidatos del river. </font><font style="vertical-align: inherit;">En este caso, usamos la altura de la celda. </font><font style="vertical-align: inherit;">Además, este indicador disminuye con la altura, es decir, igual a 1 menos la altura dividida por el máximo relativo al nivel del agua. </font><font style="vertical-align: inherit;">Para que el indicador en el nivel más alto no caiga a cero, agregamos al divisor. </font><font style="vertical-align: inherit;">Luego use este indicador para escalar la temperatura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = Mathf.LerpUnclamped(lowTemperature, highTemperature, latitude); temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75e/a24/550/75ea24550d4325e2af45a1a9627cc53c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La altura afecta la temperatura.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fluctuaciones de temperatura </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos hacer que la simplicidad del gradiente de temperatura sea menos notable agregando fluctuaciones aleatorias de temperatura. </font><font style="vertical-align: inherit;">Una pequeña posibilidad de hacerlo más realista, pero con demasiada fluctuación, se verán arbitrarios. </font><font style="vertical-align: inherit;">Hagamos que el poder de las fluctuaciones de temperatura sea personalizable y expresémoslo como la desviación de temperatura máxima con un valor predeterminado de 0.1.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperatureJitter = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/e21/83f/27de2183fc453ded3c2902d4705cd1eb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante de fluctuación de temperatura. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tales fluctuaciones deberían ser suaves con ligeros cambios locales. </font><font style="vertical-align: inherit;">Puedes usar nuestra textura de ruido para esto. </font><font style="vertical-align: inherit;">Llamaremos </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y usaremos como argumento la posición de la celda, escalada en 0.1. </font><font style="vertical-align: inherit;">Tomemos el canal W, centremos y escalemos por el coeficiente de oscilación. </font><font style="vertical-align: inherit;">Luego agregamos este valor a la temperatura calculada previamente.</font></font><br><br><pre> <code class="cs hljs"> temperature *= <span class="hljs-number"><span class="hljs-number">1f</span></span> - (cell.ViewElevation - waterLevel) / (elevationMaximum - waterLevel + <span class="hljs-number"><span class="hljs-number">1f</span></span>); temperature += (HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>).w * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/490/92c/2c8/49092c2c88aaad00d5c54835c6511a74.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dac/7d9/3cd/dac7d93cdb115574c748269ffebb3d8d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluctuaciones de temperatura con valores de 0.1 y 1.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podemos agregar una ligera variabilidad a las fluctuaciones en cada mapa, eligiendo aleatoriamente de los cuatro canales de ruido. </font><font style="vertical-align: inherit;">Establezca el canal una vez </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y luego indexe los canales de color </font></font><code>DetermineTemperature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temperatureJitterChannel; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetermineTemperature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> jitter = HexMetrics.SampleNoise(cell.Position * <span class="hljs-number"><span class="hljs-number">0.1f</span></span>)[temperatureJitterChannel]; temperature += (jitter * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * temperatureJitter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temperature; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/e82/084/30ce820847299346ec8dfaf2bb6cf1a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferentes fluctuaciones de temperatura con fuerza máxima. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que tenemos datos sobre humedad y temperatura, podemos crear una matriz de bioma. </font><font style="vertical-align: inherit;">Al indexar esta matriz, podemos asignar biomas a todas las celdas, creando un paisaje más complejo que usar solo una dimensión de datos.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matriz de bioma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existen muchos modelos climáticos, pero no utilizaremos ninguno de ellos. Lo haremos muy simple, solo nos interesa la lógica. Seco significa desierto (frío o calor), para ello utilizamos arena. Frío y húmedo significa nieve. Caliente y húmedo significa mucha vegetación, es decir, hierba. Entre ellos tendremos una taiga o tundra, que designaremos como una textura grisácea de la tierra. Una matriz 4 × 4 será suficiente para crear transiciones entre estos biomas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente, asignamos tipos de elevación basados ​​en cinco intervalos de humedad. Simplemente bajamos la tira más seca a 0.05 y guardamos el resto. Para las bandas de temperatura usamos 0.1, 0.3, 0.6 y más. Por conveniencia, estableceremos estos valores en matrices estáticas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] temperatureBands = { <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] moistureBands = { <span class="hljs-number"><span class="hljs-number">0.12f</span></span>, <span class="hljs-number"><span class="hljs-number">0.28f</span></span>, <span class="hljs-number"><span class="hljs-number">0.85f</span></span> };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque especificamos solo el tipo de relieve en función del bioma, podemos usarlo para determinar otros parámetros. </font><font style="vertical-align: inherit;">Por lo tanto, definamos en una </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estructura </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que describa la configuración de un bioma individual. </font><font style="vertical-align: inherit;">Hasta ahora, contiene solo el índice de relieve más el método del constructor correspondiente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizamos esta estructura para crear una matriz estática que contiene datos de matriz. </font><font style="vertical-align: inherit;">Usamos la humedad como la coordenada X y la temperatura como Y. Llenamos la línea con la temperatura más baja con nieve, la segunda línea con tundra y las otras dos con hierba. </font><font style="vertical-align: inherit;">Luego reemplazamos la columna más seca con el desierto, redefiniendo la elección de temperatura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/969/859/bd5/969859bd51e51cce1f7fe63d9eacd55a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matriz de biomas con índices de una matriz unidimensional.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Definición de bioma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para determinar las </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">células </font><font style="vertical-align: inherit;">en el </font><font style="vertical-align: inherit;">bioma, recorreremos los rangos de temperatura y humedad en el ciclo para determinar los índices de matriz que necesitamos. </font><font style="vertical-align: inherit;">Los usamos para obtener el bioma deseado y especificar el tipo de topografía celular.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temperature = DetermineTemperature(cell); <span class="hljs-comment"><span class="hljs-comment">// cell.SetMapData(temperature); float moisture = climate[i].moisture; if (!cell.IsUnderwater) { // if (moisture &lt; 0.05f) { // cell.TerrainTypeIndex = 4; // } // … // else { // cell.TerrainTypeIndex = 2; // } int t = 0; for (; t &lt; temperatureBands.Length; t++) { if (temperature &lt; temperatureBands[t]) { break; } } int m = 0; for (; m &lt; moistureBands.Length; m++) { if (moisture &lt; moistureBands[m]) { break; } } Biome cellBiome = biomes[t * 4 + m]; cell.TerrainTypeIndex = cellBiome.terrain; } else { cell.TerrainTypeIndex = 2; } } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00d/d32/4f5/00dd324f5b421811f49ca157e5217e43.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alivio basado en una matriz de bioma.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Configuración de bioma </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos ir más allá de los biomas definidos en la matriz. Por ejemplo, en la matriz, todos los biomas secos se definen como desiertos de arena, pero no todos los desiertos secos están llenos de arena. Hay muchos desiertos rocosos que se ven muy diferentes. Por lo tanto, reemplacemos algunas de las células del desierto con piedras. Haremos esto simplemente en función de la altura: la arena se encuentra a baja altitud, y las rocas desnudas generalmente se encuentran arriba. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponga que la arena se convierte en piedra cuando la altura de la celda está más cerca de la altura máxima que del nivel del agua. Esta es la línea de altura de los desiertos rocosos que podemos calcular al principio </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cuando nos encontramos con una celda con arena, y su altura es lo suficientemente grande, cambiamos el relieve del bioma a piedra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { temperatureJitterChannel = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rockDesertElevation = elevationMaximum - (elevationMaximum - waterLevel) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { … Biome cellBiome = biomes[t * <span class="hljs-number"><span class="hljs-number">4</span></span> + m]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } cell.TerrainTypeIndex = cellBiome.terrain; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">2</span></span>; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/812/13e/1e481213eb2c9b5cf5216b9bfa9546aa.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desiertos arenosos y rocosos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro cambio basado en la altura es forzar a las celdas a la altura máxima a convertirse en picos de nieve, independientemente de su temperatura, solo si no están demasiado secas. </font><font style="vertical-align: inherit;">Esto aumentará la probabilidad de picos de nieve cerca del ecuador cálido y húmedo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= rockDesertElevation) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == elevationMaximum) { cellBiome.terrain = <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/06e/35b/9c406e35b681819072db7a3006151e6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorros de nieve a la altura máxima.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plantas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora hagamos que los biomas determinen el nivel de células vegetales. </font><font style="vertical-align: inherit;">Para hacer esto, agregue al </font></font><code>Biome</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo de plantas e inclúyalo en el constructor.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Biome { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain, plant; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Biome</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> terrain, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> plant</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.terrain = terrain; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.plant = plant; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En los biomas más fríos y secos no habrá plantas. </font><font style="vertical-align: inherit;">En todos los demás aspectos, cuanto más cálido y húmedo sea el clima, más plantas. </font><font style="vertical-align: inherit;">La segunda columna de humedad recibe solo el primer nivel de plantas para la hilera más caliente, por lo tanto [0, 0, 0, 1]. </font><font style="vertical-align: inherit;">La tercera columna aumenta los niveles en uno, con la excepción de la nieve, es decir, [0, 1, 1, 2]. </font><font style="vertical-align: inherit;">Y la columna más húmeda los vuelve a aumentar, es decir, resulta [0, 2, 2, 3]. </font><font style="vertical-align: inherit;">Cambie la matriz </font></font><code>biomes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregando la configuración de la planta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Biome[] biomes = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Biome(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f94/bad/c72/f94badc7211d1891415dda94019bf041.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matriz de biomas con niveles de plantas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos establecer el nivel de plantas para la célula.</font></font><br><br><pre> <code class="cs hljs"> cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/2c6/7f8/ed92c67f8322c4b0c9967c0f394507bf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biomas con plantas.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Las plantas ahora se ven diferentes?</font></font></b> <div class="spoiler_text">       ,      .       (1, 2, 1)  (0.75, 1, 0.75).     (1.5, 3, 1.5)  (2, 1.5, 2).    — (2, 4.5, 2)  (2.5, 3, 2.5). <br><br>        ,      : (13, 114, 0). </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos cambiar el nivel de plantas para biomas. </font><font style="vertical-align: inherit;">Primero debemos asegurarnos de que no aparezcan en el terreno nevado, que ya podríamos configurar. </font><font style="vertical-align: inherit;">En segundo lugar, aumentemos el nivel de las plantas a lo largo de los ríos, si aún no está al máximo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.terrain == <span class="hljs-number"><span class="hljs-number">4</span></span>) { cellBiome.plant = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellBiome.plant &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> &amp;&amp; cell.HasRiver) { cellBiome.plant += <span class="hljs-number"><span class="hljs-number">1</span></span>; } cell.TerrainTypeIndex = cellBiome.terrain; cell.PlantLevel = cellBiome.plant;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/012/7e4/bd10127e45593cc5f8ce09faa783b10c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plantas modificadas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biomas submarinos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ese momento, ignoramos por completo las células submarinas. </font><font style="vertical-align: inherit;">Agreguemos una pequeña variación a ellos, y no usaremos la textura de la tierra para todos ellos. </font><font style="vertical-align: inherit;">Una solución simple basada en la altura ya será suficiente para crear una imagen más interesante. </font><font style="vertical-align: inherit;">Por ejemplo, usemos pasto para las celdas un paso por debajo del nivel del agua. </font><font style="vertical-align: inherit;">También usemos pasto para celdas sobre el nivel del agua, es decir, para lagos creados por ríos. </font><font style="vertical-align: inherit;">Las celdas con una altura negativa son áreas de aguas profundas, por lo que usamos piedra para ellas. </font><font style="vertical-align: inherit;">Todas las demás células permanecen molidas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terrain; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt;= waterLevel) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a62/bb5/5c7/a62bb55c7e4023a4590dbfe73bafe10f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabilidad submarina.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agreguemos algunos detalles más para las células submarinas a lo largo de la costa. Estas son células con al menos un vecino sobre el agua. Si dicha celda es poco profunda, crearemos una playa. Y si está al lado del acantilado, será el detalle visual dominante, y usaremos la piedra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para determinar esto, verificaremos los vecinos de las celdas ubicadas un paso por debajo del nivel del agua. Cuentemos el número de conexiones por acantilados y pendientes con celdas terrestres vecinas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { HexCell neighbor = cell.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = neighbor.Elevation - cell.WaterLevel; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { slopes += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cliffs += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos usar esta información para clasificar las celdas. </font><font style="vertical-align: inherit;">En primer lugar, si más de la mitad de los vecinos son terrestres, entonces estamos tratando con un lago o una bahía. </font><font style="vertical-align: inherit;">Para estas células usamos una textura de hierba. </font><font style="vertical-align: inherit;">De lo contrario, si tenemos acantilados, entonces usamos piedra. </font><font style="vertical-align: inherit;">De lo contrario, si tenemos pendientes, entonces usamos arena para crear una playa. </font><font style="vertical-align: inherit;">La única opción restante es un área poco profunda frente a la costa, para la cual todavía usamos césped.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation == waterLevel - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cliffs = <span class="hljs-number"><span class="hljs-number">0</span></span>, slopes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++ ) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs + slopes &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cliffs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (slopes &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { terrain = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/8d6/2ed/0eb8d62ed0ec66f7814bd839c9ca32fb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e34/976/0bc/e349760bc545e3063718b892a9ccbd89.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabilidad de la costa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como toque final, verifiquemos que no tengamos células verdes bajo el agua en el rango de temperatura más frío. </font><font style="vertical-align: inherit;">Para tales células usamos la tierra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrain == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; temperature &lt; temperatureBands[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { terrain = <span class="hljs-number"><span class="hljs-number">2</span></span>; } cell.TerrainTypeIndex = terrain;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tuvimos la oportunidad de generar tarjetas aleatorias que parecen bastante interesantes y naturales, con muchas opciones de configuración. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 27: doblar una tarjeta </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dividimos las tarjetas en columnas que se pueden mover. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Centre la tarjeta en la cámara. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Derrumbamos todo. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta última parte, agregaremos soporte para minimizar el mapa, conectando los bordes este y oeste. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El tutorial fue creado usando Unity 2017.3.0p3.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/96a/49d/f2996a49dab361c70ce643cc9f2d648b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El plegado hace que el mundo gire.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tarjetas plegables </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestros mapas se pueden usar para modelar áreas de diferentes tamaños, pero siempre se limitan a una forma rectangular. Podemos crear un mapa de una isla o un continente entero, pero no todo el planeta. Los planetas son esféricos, no tienen límites rígidos que impidan el movimiento en su superficie. Si continúa moviéndose en una dirección, tarde o temprano volverá al punto de partida. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No podemos envolver una cuadrícula de hexágonos alrededor de una esfera; tal superposición es imposible. En las mejores aproximaciones, se utiliza la topología icosaédrica, en la que las doce células deben ser pentágonos. Sin embargo, sin ninguna distorsión o excepción, la malla se puede enrollar alrededor del cilindro. Para hacer esto, solo conecta los bordes este y oeste del mapa. Con la excepción de la lógica de ajuste, todo lo demás permanece igual.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un cilindro es una aproximación pobre de una esfera, porque no podemos modelar polos. </font><font style="vertical-align: inherit;">Pero esto no impidió que los desarrolladores de muchos juegos usaran el plegado de este a oeste para modelar mapas planetarios. </font><font style="vertical-align: inherit;">Las regiones polares simplemente no son parte de la zona de juego.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué hay de girar hacia el norte y el sur?</font></font></b> <div class="spoiler_text">          ,     .       ,    ,       .        -,            -.         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay dos formas de implementar el plegado cilíndrico. </font><font style="vertical-align: inherit;">La primera es hacer que el mapa sea cilíndrico doblando su superficie y todo lo que está sobre él para que los bordes este y oeste estén en contacto. </font><font style="vertical-align: inherit;">Ahora jugarás no en una superficie plana, sino en un cilindro real. </font><font style="vertical-align: inherit;">El segundo enfoque es guardar un mapa plano y usar teletransportación o duplicación para colapsar. </font><font style="vertical-align: inherit;">La mayoría de los juegos usan el segundo enfoque, así que lo tomaremos.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plegable opcional </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La necesidad de colapsar el mapa depende de su escala: local o planetaria. </font><font style="vertical-align: inherit;">Podemos usar el soporte de ambos haciendo que el plegado sea opcional. </font><font style="vertical-align: inherit;">Para hacer esto, agregue un </font><font style="vertical-align: inherit;">nuevo interruptor al </font><font style="vertical-align: inherit;">menú </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crear nuevo mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con el colapso activado de forma predeterminada.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b07/17d/3ef/b0717d3ef8000555a454de943e4e387a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El menú del nuevo mapa con la opción de colapsar. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue al </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo para rastrear la selección, así como un método para cambiarla. </font><font style="vertical-align: inherit;">Hagamos que se invoque este método cuando cambie el estado del interruptor.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWrapping</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { wrapping = toggle; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cuando se solicita un nuevo mapa, pasamos el valor de la opción minimizar. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generateMaps) { mapGenerator.GenerateMap(x, z, wrapping); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.CreateMap(x, z, wrapping); } HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cámbielo </font></font><code>HexMapGenerator.GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que acepte este nuevo argumento y luego lo pase a </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … grid.CreateMap(x, z, wrapping); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code&gt; HexGrid debería saber si estamos colapsando, así que agréguele un campo y configúrelo </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Otras clases deberían cambiar su lógica dependiendo de si la cuadrícula está minimizada, por lo que haremos que el campo sea general. </font><font style="vertical-align: inherit;">Además, le permite establecer el valor predeterminado a través del inspector.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCountX = <span class="hljs-number"><span class="hljs-number">20</span></span>, cellCountZ = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … cellCountX = x; cellCountZ = z; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; … }</code> </pre> <br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamadas propias </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en dos lugares. </font><font style="vertical-align: inherit;">Simplemente podemos usar su propio campo para el argumento de colapso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … CreateMap(cellCountX, cellCountZ, wrapping); } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d57/fc1/36ad57fc1ff8967bbd8282808f762241.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El interruptor de rejilla plegable está activado de forma predeterminada.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Guardar y cargar </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como el plegado está configurado para cada tarjeta, debe guardarse y cargarse. </font><font style="vertical-align: inherit;">Esto significa que debe cambiar el formato de guardado del archivo, así que aumente la versión constante en </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al guardar, deje </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que escriba el valor de plegado booleano después del tamaño del mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); writer.Write(wrapping); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al cargar, lo leeremos solo con la versión correcta del archivo. </font><font style="vertical-align: inherit;">Si es diferente, entonces esta es una tarjeta vieja y no debe minimizarse. </font><font style="vertical-align: inherit;">Guarde esta información en una variable local y compárela con el estado actual de plegado. </font><font style="vertical-align: inherit;">Si es diferente, entonces no podemos reutilizar la topología de mapa existente de la misma manera que lo haría al cargar un mapa con otros tamaños.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); ClearUnits(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wrapping = header &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ? reader.ReadBoolean() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping != wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z, wrapping)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Métricas plegables </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimizar el mapa requerirá cambios importantes en la lógica, por ejemplo, al calcular distancias. </font><font style="vertical-align: inherit;">Por lo tanto, pueden tocar el código que no tiene un enlace directo a la cuadrícula. </font><font style="vertical-align: inherit;">En lugar de pasar esta información como argumentos, añádala a </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Agregue un número entero estático que contenga el tamaño de plegado que coincida con el ancho del mapa. </font><font style="vertical-align: inherit;">Si es mayor que cero, entonces estamos tratando con una tarjeta plegable. </font><font style="vertical-align: inherit;">Para verificar esto, agregue una propiedad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Wrapping { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wrapSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitamos establecer el tamaño de plegado para cada llamada </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que estos datos no sobrevivirán a la compilación en el modo Play, lo configuraremos </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; HexMetrics.wrapSize = wrapping ? cellCountX : <span class="hljs-number"><span class="hljs-number">0</span></span>; ResetVisibility(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ancho de la celda </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando trabajamos con tarjetas plegables, a menudo tenemos que lidiar con posiciones a lo largo del eje X, medidas en el ancho de las celdas. </font><font style="vertical-align: inherit;">Aunque se puede usar para esto </font></font><code>HexMetrics.innerRadius * 2f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sería más conveniente si no tuviéramos que multiplicar cada vez. </font><font style="vertical-align: inherit;">Entonces agreguemos una constante </font></font><code>HexMetrics.innerDiameter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * outerToInner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerDiameter = innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya podemos usar el diámetro en tres lugares. </font><font style="vertical-align: inherit;">En primer lugar, </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al posicionar una nueva celda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Vector3 position; position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> - z / <span class="hljs-number"><span class="hljs-number">2</span></span>) * HexMetrics.innerDiameter; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En segundo lugar, en </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limitar la posición de la cámara.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y también en la </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conversión de posición a coordenadas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = position.x / HexMetrics.innerDiameter; … }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Centrado de tarjeta </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando el mapa no colapsa, tiene claramente definidos los bordes este y oeste, y por lo tanto un centro horizontal claro. </font><font style="vertical-align: inherit;">Pero en el caso de una tarjeta plegable, todo es diferente. </font><font style="vertical-align: inherit;">No tiene el borde oriental ni occidental ni el centro. </font><font style="vertical-align: inherit;">Como alternativa, podemos suponer que el centro está donde está la cámara. </font><font style="vertical-align: inherit;">Esto será útil porque queremos que el mapa siempre esté centrado en nuestro punto de vista. </font><font style="vertical-align: inherit;">Entonces, donde sea que estemos, no veremos los bordes este u oeste del mapa.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Columnas de fragmentos de mapa </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que la visualización del mapa se centre en relación con la cámara, debemos cambiar la ubicación de los elementos según el movimiento de la cámara. Si se mueve hacia el oeste, entonces debemos tomar lo que está actualmente en el borde de la parte oriental y moverlo al borde de la parte occidental. Lo mismo se aplica a la dirección opuesta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealmente, tan pronto como la cámara se mueva a la columna de celdas vecina, debemos mover inmediatamente la columna de celdas más alejada al otro lado. Sin embargo, no necesitamos ser tan precisos. En cambio, podemos transferir fragmentos de mapas completos. Esto nos permite mover partes del mapa sin tener que modificar las mallas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como estamos moviendo columnas enteras de fragmentos al mismo tiempo, agrupémoslas creando un objeto de columna principal para cada grupo. </font><font style="vertical-align: inherit;">Agregue una matriz para estos objetos </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la inicializaremos </font></font><code>CreateChunks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Los usaremos solo como contenedores, por lo que solo necesitamos rastrear el enlace a sus componentes </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como en el caso de los fragmentos, sus posiciones iniciales se ubican en el origen local de las coordenadas de la cuadrícula.</font></font><br><br><pre> <code class="cs hljs"> Transform[] columns; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { columns = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Transform[chunkCountX]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { columns[x] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>).transform; columns[x].SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora el fragmento debería convertirse en hijo de la columna correspondiente, no de la cuadrícula. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … chunks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexGridChunk[chunkCountX * chunkCountZ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; chunkCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab); chunk.transform.SetParent(columns[x], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/415/920/bb2/415920bb2e4e2e002793aaebee8e04e2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmentos agrupados en columnas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que todos los fragmentos se han convertido en hijos de las columnas, </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es suficiente que destruyamos directamente todas las columnas, no los fragmentos. </font><font style="vertical-align: inherit;">Entonces nos desharemos de los fragmentos de hija.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columns != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { Destroy(columns[i].gameObject); } } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Columnas de teletransporte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue al </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuevo método </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con la posición X como parámetro. </font><font style="vertical-align: inherit;">Convierta la posición al índice de la columna, dividiéndola por el ancho del fragmento en unidades Unity. </font><font style="vertical-align: inherit;">Este será el índice de la columna en la que se encuentra actualmente la cámara, es decir, será la columna central del mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es suficiente para nosotros cambiar la visualización del mapa solo cuando cambia el índice de la columna central. </font><font style="vertical-align: inherit;">Así que vamos a seguirlo en el campo. </font><font style="vertical-align: inherit;">Usamos el valor predeterminado −1 cuando creamos un mapa para que los nuevos mapas siempre estén centrados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrapping</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapping = wrapping; currentCenterColumnIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CenterMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xPosition</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerColumnIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (xPosition / (HexMetrics.innerDiameter * HexMetrics.chunkSizeX)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centerColumnIndex == currentCenterColumnIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } currentCenterColumnIndex = centerColumnIndex; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que conocemos el índice de la columna central, podemos determinar los índices mínimo y máximo simplemente restando y sumando la mitad del número de columnas. Como utilizamos valores enteros, con un número impar de columnas, esto funciona perfectamente. En el caso de un número par, no puede haber una columna perfectamente centrada, por lo que uno de los índices estará un paso más allá de lo necesario. Esto crea un desplazamiento de una columna en la dirección del borde más alejado del mapa, pero para nosotros esto no es un problema.</font></font><br><br><pre> <code class="cs hljs"> currentCenterColumnIndex = centerColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que estos índices pueden ser negativos o mayores que el índice de columna máximo natural. </font><font style="vertical-align: inherit;">El mínimo es cero solo cuando la cámara está cerca del centro natural del mapa. </font><font style="vertical-align: inherit;">Nuestra tarea es mover las columnas para que se correspondan con estos índices relativos. </font><font style="vertical-align: inherit;">Esto se puede hacer cambiando la coordenada X local de cada columna en el bucle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minColumnIndex = centerColumnIndex - chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxColumnIndex = centerColumnIndex + chunkCountX / <span class="hljs-number"><span class="hljs-number">2</span></span>; Vector3 position; position.y = position.z = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; columns[i].localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para cada columna, verificamos si el índice del índice mínimo es menor. </font><font style="vertical-align: inherit;">Si es así, entonces está demasiado lejos a la izquierda del centro. </font><font style="vertical-align: inherit;">Debe teletransportarse al otro lado del mapa. </font><font style="vertical-align: inherit;">Esto se puede hacer haciendo que su coordenada X sea igual al ancho del mapa. </font><font style="vertical-align: inherit;">Del mismo modo, si el índice de la columna es mayor que el índice máximo, entonces está demasiado lejos a la derecha del centro y debería teletransportarse al otro lado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; columns.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; minColumnIndex) { position.x = chunkCountX * (HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt; maxColumnIndex) { position.x = chunkCountX * -(HexMetrics.innerDiameter * HexMetrics.chunkSizeX); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { position.x = <span class="hljs-number"><span class="hljs-number">0f</span></span>; } columns[i].localPosition = position; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movimiento de la cámara </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambie </font></font><code>HexMapCamera.AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que cuando trabaje con una tarjeta plegable, en lugar de eso, </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llame </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primero, simplemente haga que el nuevo método sea un </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">duplicado </font></font><code>ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero con la única diferencia: al final, llamará </font></font><code>CenterMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { … transform.localPosition = grid.wrapping ? WrapPosition(position) : ClampPosition(position); } … <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * HexMetrics.innerDiameter; position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); grid.CenterMap(position.x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que la tarjeta se centre inmediatamente, llamamos al </font></font><code>OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; ValidatePosition(); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muévase hacia la izquierda y hacia la derecha al centrar la cámara. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque todavía restringimos el movimiento de la cámara, el mapa ahora intenta centrarse en relación con la cámara, teletransportando columnas de fragmentos de mapa si es necesario. </font><font style="vertical-align: inherit;">Con un mapa pequeño y una cámara remota, esto es claramente visible, pero en un mapa grande, los fragmentos teletransportados están fuera del alcance de visión de la cámara. </font><font style="vertical-align: inherit;">Obviamente, solo los bordes iniciales este y oeste del mapa son notables, porque todavía no hay triangulación entre ellos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Eliminar la restricción de su coordenada X con el fin de reducir al mínimo y la cámara </font></font><code>WrapPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En cambio, continuaremos aumentando la coordenada X en el ancho del mapa mientras esté por debajo de cero, y la reduciremos mientras sea más grande que el ancho del mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WrapPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// float xMax = (grid.cellCountX - 0.5f) * HexMetrics.innerDiameter; // position.x = Mathf.Clamp(position.x, 0f, xMax); float width = grid.cellCountX * HexMetrics.innerDiameter; while (position.x &lt; 0f) { position.x += width; } while (position.x &gt; width) { position.x -= width; } float zMax = (grid.cellCountZ - 1) * (1.5f * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, 0f, zMax); grid.CenterMap(position.x); return position; }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cámara enrollable se mueve a lo largo del mapa.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texturas de sombreador plegables </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con la excepción del espacio de triangulación, minimizar la cámara en el modo de juego debería ser imperceptible. Sin embargo, cuando esto sucede, se produce un cambio visual en la mitad de la topografía y el agua. Esto sucede porque usamos una posición en el mundo para muestrear estas texturas. Una teletransportación aguda del fragmento cambia la ubicación de las texturas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos resolver este problema haciendo que las texturas aparezcan en mosaicos que son múltiplos del tamaño del fragmento. El tamaño del fragmento se calcula a partir de las constantes en </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, así que </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creemos el</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> archivo de inclusión del sombreador </font><em><font style="vertical-align: inherit;">HexMetrics.cginc</font></em><font style="vertical-align: inherit;"> y </font><em><font style="vertical-align: inherit;">peguemos</font></em><font style="vertical-align: inherit;"> las definiciones correspondientes en él. La escala de mosaico básica se calcula a partir del tamaño del fragmento y el radio exterior de la celda. Si utiliza otras métricas, deberá modificar el archivo en consecuencia.</font></font><br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_TO_INNER 0.866025404 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OUTER_RADIUS 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHUNK_SIZE_X 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TILING_SCALE (1 / (CHUNK_SIZE_X * 2 * OUTER_RADIUS / OUTER_TO_INNER))</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto nos da una escala de mosaico de 0.00866025404. </font><font style="vertical-align: inherit;">Si usamos un múltiplo entero de este valor, la textura no se verá afectada por la teletransportación de fragmentos. </font><font style="vertical-align: inherit;">Además, las texturas en los bordes este y oeste del mapa se unirán perfectamente después de que triangulemos correctamente su conexión. </font><font style="vertical-align: inherit;">Usamos 0.02 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como la escala UV en el sombreador de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En cambio, podemos usar la escala de mosaico duplicado, que es 0.01732050808. </font><font style="vertical-align: inherit;">La escala se obtiene un poco menos de lo que era, y la escala de la textura ha aumentado ligeramente, pero visualmente es invisible.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexCellData.cginc" … <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3( <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE), <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] ); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el sombreador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roads</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para ruido UV, utilizamos una escala de 0.025. </font><font style="vertical-align: inherit;">En su lugar, puede usar la escala de mosaico triple. </font><font style="vertical-align: inherit;">Esto nos da 0.02598076212, que está bastante cerca.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexMetrics.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water.cginc</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilizamos 0.015 para espuma y 0.025 para olas. </font><font style="vertical-align: inherit;">Aquí podemos reemplazar nuevamente estos valores con una escala de mosaico duplicada y triplicada.</font></font><br><br><pre> <code class="hljs mel">#include <span class="hljs-string"><span class="hljs-string">"HexMetrics.cginc"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Foam (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shore, float2 worldXZ, sampler2D noiseTex) { shore = <span class="hljs-keyword"><span class="hljs-keyword">sqrt</span></span>(shore) * <span class="hljs-number"><span class="hljs-number">0.9</span></span>; float2 noiseUV = worldXZ + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; float4 <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span> = tex2D(noiseTex, noiseUV * (<span class="hljs-number"><span class="hljs-number">2</span></span> * TILING_SCALE)); … } … <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Waves (float2 worldXZ, sampler2D noiseTex) { float2 uv1 = worldXZ; uv1.y += _Time.y; float4 noise1 = tex2D(noiseTex, uv1 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); float2 uv2 = worldXZ; uv2.x += _Time.y; float4 noise2 = tex2D(noiseTex, uv2 * (<span class="hljs-number"><span class="hljs-number">3</span></span> * TILING_SCALE)); … }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La unión de oriente y occidente </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta etapa, la única evidencia visual de minimizar el mapa es una pequeña brecha entre las columnas más orientales y más occidentales. </font><font style="vertical-align: inherit;">Esta brecha ocurre porque todavía no hemos triangulado las conexiones de bordes y ángulos entre celdas en lados opuestos del mapa sin plegar.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/85f/e79/24085fe7986100674854b9c9a79c349c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espacio en el borde.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vecinos plegables </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para triangular la conexión este-oeste, necesitamos hacer que las celdas en lados opuestos sean vecinas entre sí. </font><font style="vertical-align: inherit;">Hasta ahora no estamos haciendo esto, porque la </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conexión E - W se establece con la celda anterior solo si su índice en X es mayor que cero. </font><font style="vertical-align: inherit;">Para contraer esta conexión, debemos conectar la última celda de la fila con la primera celda de la misma fila cuando se pliega el mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping &amp;&amp; x == cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.E, cells[i - x]); } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una vez establecida la conexión de los vecinos E - W, obtenemos una triangulación parcial de la brecha. </font><font style="vertical-align: inherit;">La conexión de bordes no es ideal, porque la distorsión está oculta incorrectamente. </font><font style="vertical-align: inherit;">Nos ocuparemos de esto más tarde.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/68a/6b6/ce568a6b639801e47804eb35a62493c6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compuestos E - W. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">También necesitamos colapsar los enlaces NE - SW. </font><font style="vertical-align: inherit;">Esto se puede hacer conectando la primera celda de cada fila par con las últimas celdas de la fila anterior. </font><font style="vertical-align: inherit;">Será solo la celda anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor(HexDirection.SW, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/239/66f/c3c/23966fc3c616ea9338a3a14d187dcc7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NE - Conexiones SW. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, las conexiones SE - NW se establecen al final de cada línea impar debajo de la primera. </font><font style="vertical-align: inherit;">Estas celdas deben estar conectadas a la primera celda de la fila anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.SetNeighbor(HexDirection.SW, cells[i - cellCountX]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - cellCountX + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.SetNeighbor( HexDirection.SE, cells[i - cellCountX * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e8/df4/62e/3e8df462e076bbdf93396f6cec525cc4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compuestos SE - NO.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ruido plegable </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ocultar perfectamente la brecha, debemos asegurarnos de que los bordes este y oeste del mapa coincidan con el ruido que se usa perfectamente para distorsionar las posiciones de los vértices. </font><font style="vertical-align: inherit;">Podemos usar el mismo truco que se usó para los sombreadores, pero se usó una escala de ruido de 0.003 para la distorsión. </font><font style="vertical-align: inherit;">Para garantizar el mosaico, debe aumentar significativamente la escala, lo que conducirá a una distorsión más caótica de los vértices. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una solución alternativa no es el ruido tayl, sino hacer una atenuación suave del ruido en los bordes del mapa. </font><font style="vertical-align: inherit;">Si realiza una atenuación suave a lo largo del ancho de una celda, la distorsión creará una transición suave sin espacios. </font><font style="vertical-align: inherit;">El ruido en esta área se suavizará ligeramente, y desde una larga distancia el cambio parecerá agudo, pero esto no es tan obvio cuando se usa una ligera distorsión de los vértices.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué pasa con las fluctuaciones de temperatura?</font></font></b> <div class="spoiler_text">           .      ,      .         ,   .     ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si no colapsamos la tarjeta, podemos pasar con una </font></font><code>HexMetrics.SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sola muestra. </font><font style="vertical-align: inherit;">Pero al plegar es necesario agregar atenuación. </font><font style="vertical-align: inherit;">Por lo tanto, antes de devolver la muestra, guárdela en una variable.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sample; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al minimizar, necesitamos mezclar con la segunda muestra. </font><font style="vertical-align: inherit;">Realizaremos la transición en la parte este del mapa, por lo que la segunda muestra debe moverse hacia el oeste.</font></font><br><br><pre> <code class="cs hljs"> Vector4 sample = noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La atenuación se realiza utilizando una interpolación lineal simple de la parte occidental a la oriental, sobre el ancho de una celda. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/84f/75d/c4e84f75dd0260efb18a9d3d66647c55.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mezcla de ruido, una solución imperfecta</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como resultado, no obtenemos una coincidencia exacta, porque algunas de las celdas en el lado este tienen coordenadas X negativas. Para no acercarnos a esta área, muevamos la región de transición a la mitad oeste del ancho de la celda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Wrapping &amp;&amp; position.x &lt; innerDiameter * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>) { Vector4 sample2 = noiseSource.GetPixelBilinear( (position.x + wrapSize * innerDiameter) * noiseScale, position.z * noiseScale ); sample = Vector4.Lerp( sample2, sample, position.x * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / innerDiameter) - <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/af4/1fb/04faf41fb669427487a2dbb6855cd5bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atenuación correcta.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edición de celda </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que la triangulación parece correcta, asegurémonos de que podemos editar todo en el mapa y en la costura de plegado. Resulta que, en fragmentos teletransportados, las coordenadas son erróneas y grandes pinceles están cortados por una costura.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/18b/5ce/a1f18b5ce7b87b38a7a58d47e341d4f1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El cepillo está recortado.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para solucionar esto, debemos informar el </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plegamiento. Podemos hacer esto haciendo coincidir la coordenada X en el método del constructor. Sabemos que la coordenada axial X se obtiene de la coordenada X del desplazamiento restando la mitad de la coordenada Z. Puede usar esta información para realizar la transformación inversa y verificar si la coordenada cero es menor que cero. Si es así, entonces tenemos la coordenada más allá del lado este del mapa desplegado. Como en cada dirección teletransportamos no más de la mitad del mapa, será suficiente para nosotros agregar el tamaño de plegado a X una vez. Y cuando la coordenada de desplazamiento es mayor que el tamaño de plegado, debemos realizar una resta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oX = x + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oX &gt;= HexMetrics.wrapSize) { x -= HexMetrics.wrapSize; } } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.z = z; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A veces, al editar la parte inferior o superior del mapa, obtengo errores. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto sucede cuando, debido a la distorsión de los vértices, el cursor aparece en la fila de celdas fuera del mapa. </font><font style="vertical-align: inherit;">Este es un error que ocurre porque no hacemos coincidir las coordenadas </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con el parámetro vectorial. </font><font style="vertical-align: inherit;">Esto se puede solucionar aplicando un método </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con coordenadas como parámetros que realizarán las verificaciones necesarias.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-comment"><span class="hljs-comment">// int index = // coordinates.X + coordinates.Z * cellCountX + coordinates.Z / 2; // return cells[index]; return GetCell(coordinates); }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plegamiento costero </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La triangulación funciona bien para el terreno, pero a lo largo de la costura este-oeste no hay bordes de la costa del agua. </font><font style="vertical-align: inherit;">De hecho, lo son, simplemente no colapsan. </font><font style="vertical-align: inherit;">Se voltean y se estiran al otro lado del mapa.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/20a/ed3/6fe20aed3cb0dea0a9e47ef08caa10f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falta el borde del agua. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto sucede, porque al triangular el agua de la costa, usamos la posición de un vecino. </font><font style="vertical-align: inherit;">Para solucionar esto, necesitamos determinar a qué nos enfrentamos, ubicado en el otro lado de la tarjeta. </font><font style="vertical-align: inherit;">Para simplificar la tarea, agregaremos una </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">columna de celda </font><font style="vertical-align: inherit;">a la </font><font style="vertical-align: inherit;">propiedad para el índice.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ColumnIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asigne este índice a </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es simplemente igual a la coordenada de desplazamiento X dividida por el tamaño del fragmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … cell.Index = i; cell.ColumnIndex = x / HexMetrics.chunkSizeX; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos </font></font><code>HexGridChunk.TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determinar qué se minimiza comparando el índice de columna de la celda actual y su vecino. </font><font style="vertical-align: inherit;">Si el índice de la columna del vecino es menos de un paso menos, entonces estamos en el lado occidental y el vecino está en el lado este. </font><font style="vertical-align: inherit;">Por lo tanto, necesitamos girar a nuestro vecino hacia el oeste. </font><font style="vertical-align: inherit;">Lo mismo y en la dirección opuesta.</font></font><br><br><pre> <code class="cs hljs"> Vector3 center2 = neighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center2.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/308/3ec/f133083ec9172168e5302d737fd0ce27.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Costillas de la costa, pero sin rincones. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Así que nos ocupamos de las costillas de la costa, pero hasta ahora no nos ocupamos de los rincones. </font><font style="vertical-align: inherit;">Necesitamos hacer lo mismo con el próximo vecino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 center3 = nextNeighbor.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &lt; cell.ColumnIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x += HexMetrics.wrapSize * HexMetrics.innerDiameter; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor.ColumnIndex &gt; cell.ColumnIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) { center3.x -= HexMetrics.wrapSize * HexMetrics.innerDiameter; } Vector3 v3 = center3 + (nextNeighbor.IsUnderwater ? HexMetrics.GetFirstWaterCorner(direction.Previous()) : HexMetrics.GetFirstSolidCorner(direction.Previous())); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d02/c0d/751/d02c0d7510fba8b3707b89f146b71837.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Costa bien acortada.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generación de tarjeta </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La opción de conectar los lados este y oeste afecta la generación de mapas. </font><font style="vertical-align: inherit;">Al minimizar el mapa, el algoritmo de generación también debe minimizarse. </font><font style="vertical-align: inherit;">Esto conducirá a la creación de otro mapa, pero cuando se utiliza un borde de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mapa X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> distinto de cero </font><em><font style="vertical-align: inherit;">, el</font></em><font style="vertical-align: inherit;"> plegado no es obvio.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/01f/f90/54001ff900386d5f389850de0a1d0034.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/428/859/ecb/428859ecb5c5bf9a68b277675110e44b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa grande 1208905299 con la configuración predeterminada. Con plegado y sin él.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cuando está minimizado no tiene sentido usar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el mapa de la frontera de la X</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pero no podemos deshacernos de él, porque al mismo tiempo las regiones se fusionarán. Al minimizar, en su lugar, podemos usar un </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RegionBorder</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambiamos </font></font><code>HexMapGenerator.CreateRegions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, reemplazando en todos los casos </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esta nueva variable será igual o </font></font><code>regionBorder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o </font></font><code>mapBorderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dependiendo del valor de la opción de colapso. A continuación mostré los cambios solo para el primer caso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> borderX = grid.wrapping ? regionBorder : mapBorderX; MapRegion region; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al mismo tiempo, las regiones permanecen separadas, pero esto es necesario solo si hay diferentes regiones en los lados este y oeste del mapa. </font><font style="vertical-align: inherit;">Hay dos casos en que esto no se respeta. </font><font style="vertical-align: inherit;">La primera es cuando tenemos solo una región. </font><font style="vertical-align: inherit;">El segundo es cuando hay dos regiones que dividen el mapa horizontalmente. </font><font style="vertical-align: inherit;">En estos casos, podemos asignar un </font></font><code>borderX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor de cero, lo que permitirá que las masas de tierra crucen la costura este-oeste.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (regionCount) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (grid.wrapping) { borderX = <span class="hljs-number"><span class="hljs-number">0</span></span>; } region.xMin = borderX; region.xMax = grid.cellCountX - borderX; region.zMin = mapBorderZ; region.zMax = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> - regionBorder; regions.Add(region); region.zMin = grid.cellCountZ / <span class="hljs-number"><span class="hljs-number">2</span></span> + regionBorder; region.zMax = grid.cellCountZ - mapBorderZ; regions.Add(region); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/4d4/c9e/db84d4c9e40c9e35ad29af69314f73e1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una región está colapsando. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primera vista, parece que todo funciona correctamente, pero en realidad hay una brecha a lo largo de la costura. </font><font style="vertical-align: inherit;">Esto se vuelve más notable si establece el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">porcentaje de erosión en</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cero.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/a4e/572/ef5a4e5722dbbb8af91e770220d7d141.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/f75/fce/6b3f75fce35d6be9c8a66c445c4dc9cd.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando se deshabilita la erosión, se nota una costura en el relieve.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La brecha ocurre porque la costura evita el crecimiento de fragmentos en relieve. Para determinar qué se agrega primero, se usa la distancia desde la celda hasta el centro del fragmento, y las celdas en el otro lado del mapa pueden estar muy lejos, por lo que casi nunca se encienden. Por supuesto, esto está mal. Necesitamos asegurarnos de que </font></font><code>HexCoordinates.DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conocemos el mapa minimizado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculamos la distancia entre </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sumando las distancias absolutas a lo largo de cada uno de los tres ejes y reduciendo a la mitad el resultado. La distancia a lo largo de Z siempre es verdadera, pero plegarla puede afectar las distancias X e Y. Entonces, comencemos con un cálculo separado de X + Y.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// return // ((x &lt; other.x ? other.x - x : x - other.x) + // (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + // (z &lt; other.z ? other.z - z : z - other.z)) / 2; int xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); return (xy + (z &lt; other.z ? other.z - z : z - other.z)) / 2; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Determinar si el plegado crea una distancia más corta para las celdas arbitrarias no es una tarea fácil, así que calculemos X + Y para los casos en los que estamos plegando otra coordenada hacia el lado oeste. </font><font style="vertical-align: inherit;">Si el valor es menor que el X + Y original, úselo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xy = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si esto no conduce a una distancia más corta, entonces es posible doblar en la otra dirección, por lo que lo revisaremos. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { other.x += HexMetrics.wrapSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { other.x -= <span class="hljs-number"><span class="hljs-number">2</span></span> * HexMetrics.wrapSize; xyWrapped = (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xyWrapped &lt; xy) { xy = xyWrapped; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora siempre obtenemos la distancia más corta en el mapa plegable. </font><font style="vertical-align: inherit;">Los fragmentos de terreno ya no están bloqueados por una costura, lo que permite que las masas de tierra se enrosquen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/fb7/3b8/65cfb73b8107d7744ff8cdcabaf48083.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/149/e6f/717/149e6f717defe9288565f37f7efcdf56.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relieve plegado correctamente sin erosión y erosión. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Viajando por el mundo </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Después de considerar la generación de mapas y la triangulación, pasemos ahora a revisar escuadrones, exploración y visibilidad. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prueba de costura </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El primer obstáculo que encontramos al mover un escuadrón alrededor del mundo es el borde del mapa, que no se puede explorar. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/4f4/748/4524f4748d2c4e3cb983ec5ecbf064c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La costura de la tarjeta no puede ser examinada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las celdas a lo largo del borde del mapa se hacen inexploradas para ocultar la finalización abrupta del mapa. </font><font style="vertical-align: inherit;">Pero cuando el mapa se minimiza, solo se deben marcar las celdas norte y sur, pero no el este y el oeste. </font><font style="vertical-align: inherit;">Cambie </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para tener esto en cuenta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapping) { cell.Explorable = z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.Explorable = x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilidad de las características de relieve. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora verifiquemos si la visibilidad funciona a lo largo de la costura. </font><font style="vertical-align: inherit;">Funciona para terreno, pero no para objetos de terreno. </font><font style="vertical-align: inherit;">Parece que los objetos que colapsan obtienen la visibilidad de la última celda que no se colapsó.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/ac1/811/631ac18111ba1eb8dfcf74a39fb2ffbe.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visibilidad incorrecta de los objetos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto sucede porque el modo de </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sujeción está configurado </font><font style="vertical-align: inherit;">para el modo de plegado de textura utilizado </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para resolver el problema, simplemente cambie su modo de sujeción para repetir. </font><font style="vertical-align: inherit;">Pero necesitamos hacer esto solo para las coordenadas de U, por lo </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que lo configuraremos </font></font><code>wrapModeU</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><code>wrapModeV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTexture) { cellTexture.Resize(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; <span class="hljs-comment"><span class="hljs-comment">// cellTexture.wrapMode = TextureWrapMode.Clamp; cellTexture.wrapModeU = TextureWrapMode.Repeat; cellTexture.wrapModeV = TextureWrapMode.Clamp; Shader.SetGlobalTexture("_HexCellData", cellTexture); } … }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escuadrones y columnas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro problema es que las unidades aún no están colapsando. </font><font style="vertical-align: inherit;">Después de mover la columna en la que se encuentran, las unidades permanecen en el mismo lugar.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/29b/827/c5029b8273d7b53a3ddac2da03d9987f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La unidad no se transfiere y está en el lado equivocado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este problema se puede resolver haciendo que los escuadrones sean elementos secundarios de las columnas, como hicimos con los fragmentos. </font><font style="vertical-align: inherit;">Primero, ya no los convertiremos en los hijos inmediatos de la cuadrícula </font></font><code>HexGrid.AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// unit.transform.SetParent(transform, false); unit.Location = location; unit.Orientation = orientation; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como las unidades se están moviendo, pueden aparecer en otra columna, es decir, será necesario cambiar sus padres. </font><font style="vertical-align: inherit;">Para hacer esto posible, agregamos al </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método general </font></font><code>MakeChildOfColumn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y, como parámetros, le pasamos el componente del </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemento secundario y el índice de la columna.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeChildOfColumn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> columnIndex</span></span></span><span class="hljs-function">)</span></span> { child.SetParent(columns[columnIndex], <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llamaremos a este método cuando se establezca la propiedad </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { … Grid.MakeChildOfColumn(transform, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.ColumnIndex); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto resuelve el problema de crear unidades. </font><font style="vertical-align: inherit;">Pero también debemos hacer que se muevan a la columna deseada cuando se mueven. </font><font style="vertical-align: inherit;">Para hacer esto, debe rastrear </font></font><code>HexUnit.TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la columna actual </font><font style="vertical-align: inherit;">en el </font><font style="vertical-align: inherit;">índice. </font><font style="vertical-align: inherit;">Al comienzo de este método, este es el índice de la columna de celda al comienzo de la ruta, o la actual si el movimiento fue interrumpido por la compilación.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Grid.DecreaseVisibility( // currentTravelLocation ? currentTravelLocation : pathToTravel[0], // VisionRange // ); if (!currentTravelLocation) { currentTravelLocation = pathToTravel[0]; } Grid.DecreaseVisibility(currentTravelLocation, VisionRange); int currentColumn = currentTravelLocation.ColumnIndex; … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durante cada iteración del movimiento, verificaremos si el índice de la siguiente columna es diferente, y si es así, cambiaremos el padre del orden. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = Time.deltaTime * travelSpeed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { … Grid.IncreaseVisibility(pathToTravel[i], VisionRange); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextColumn = currentTravelLocation.ColumnIndex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentColumn != nextColumn) { Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto permitirá que las unidades se muevan de manera similar a los fragmentos. </font><font style="vertical-align: inherit;">Sin embargo, cuando se mueven a través de la costura de la tarjeta, las unidades aún no colapsan. </font><font style="vertical-align: inherit;">En cambio, de repente comienzan a moverse en la dirección equivocada. </font><font style="vertical-align: inherit;">Esto sucede independientemente de la ubicación de la costura, pero más notablemente cuando saltan por todo el mapa.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carreras de caballos en el mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí podemos usar el mismo enfoque que se usó para la costa, solo que esta vez giraremos la curva a lo largo de la cual se mueve el desprendimiento. </font><font style="vertical-align: inherit;">Si la siguiente columna se gira hacia el este, entonces teletransportaremos la curva también hacia el este, de manera similar para la otra dirección. </font><font style="vertical-align: inherit;">Debe cambiar los puntos de control de la curva </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que también afectará el punto de control </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { currentTravelLocation = pathToTravel[i]; a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; <span class="hljs-comment"><span class="hljs-comment">// c = (b + currentTravelLocation.Position) * 0.5f; // Grid.IncreaseVisibility(pathToTravel[i], VisionRange); int nextColumn = currentTravelLocation.ColumnIndex; if (currentColumn != nextColumn) { if (nextColumn &lt; currentColumn - 1) { ax -= HexMetrics.innerDiameter * HexMetrics.wrapSize; bx -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } else if (nextColumn &gt; currentColumn + 1) { ax += HexMetrics.innerDiameter * HexMetrics.wrapSize; bx += HexMetrics.innerDiameter * HexMetrics.wrapSize; } Grid.MakeChildOfColumn(transform, nextColumn); currentColumn = nextColumn; } c = (b + currentTravelLocation.Position) * 0.5f; Grid.IncreaseVisibility(pathToTravel[i], VisionRange); … }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movimiento con plegado.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lo último que debe hacer es cambiar el turno inicial del escuadrón cuando mira la primera celda a la que se moverá. Si esta celda está al otro lado de la costura este-oeste, la unidad mirará en la dirección incorrecta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al minimizar un mapa, hay dos formas de mirar un punto que no está exactamente en el norte o el sur. Puedes mirar hacia el este o el oeste. Será lógico mirar en la dirección correspondiente a la distancia más cercana al punto, porque también es la dirección del movimiento, así que utilicémoslo </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al minimizar, verificaremos la distancia relativa a lo largo del eje X. Si es menor que la mitad negativa del ancho del mapa, entonces debemos mirar hacia el oeste, lo que se puede hacer girando el punto hacia el oeste. </font><font style="vertical-align: inherit;">De lo contrario, si la distancia es más de la mitad del ancho del mapa, entonces debemos colapsar hacia el este.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HexMetrics.Wrapping) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDistance = point.x - transform.localPosition.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &lt; -HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x += HexMetrics.innerDiameter * HexMetrics.wrapSize; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDistance &gt; HexMetrics.innerRadius * HexMetrics.wrapSize) { point.x -= HexMetrics.innerDiameter * HexMetrics.wrapSize; } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, tenemos un mapa minimizado completamente funcional. </font><font style="vertical-align: inherit;">Y esto concluye la serie de tutoriales sobre mapas hexagonales. </font><font style="vertical-align: inherit;">Como se mencionó en las secciones anteriores, se pueden considerar otros temas, pero no son específicos de los mapas hexagonales. </font><font style="vertical-align: inherit;">Quizás los consideraré en futuras series de tutoriales.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargué el último paquete y recibo errores de turno en el modo Play</font></font></b> <div class="spoiler_text">  ,       <em>Rotation</em> .    .  .   5. </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargué el último paquete y los gráficos no son tan hermosos como en las capturas de pantalla</font></font></b> <div class="spoiler_text">        . -    . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargué el último paquete y genera constantemente la misma tarjeta</font></font></b> <div class="spoiler_text">      seed (1208905299),      .    ,  <em>Use Fixed Seed</em> . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427567/">https://habr.com/ru/post/es427567/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427555/index.html">Animales que los humanos han aprendido a rastrear utilizando la tecnología de reconocimiento facial</a></li>
<li><a href="../es427557/index.html">Resumen de eventos de TI en noviembre (primera parte)</a></li>
<li><a href="../es427561/index.html">Derecho a reparar: los primeros pasos en la dirección correcta de Motorola</a></li>
<li><a href="../es427563/index.html">Estándar SNI cifrado implementado en Firefox Nightly</a></li>
<li><a href="../es427565/index.html">"Mi logro fue que generalmente volví a la profesión" - 10 preguntas para el programador, número 10</a></li>
<li><a href="../es427569/index.html">Ajuste fino OpenStack bajo alta carga</a></li>
<li><a href="../es427571/index.html">La unión de R y PostgreSQL. Analizamos el trabajo de los aeropuertos, calculamos las pensiones.</a></li>
<li><a href="../es427573/index.html">Candy or Life: Halloween como una razón para atraer a tu hijo a la ciencia</a></li>
<li><a href="../es427575/index.html">Por qué el Wi-Fi no funcionará según lo planeado y por qué saber qué teléfono usa el empleado</a></li>
<li><a href="../es427577/index.html">Aprendizaje automático versus análisis de firma al detectar ataques en una aplicación web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>