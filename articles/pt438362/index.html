<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêá üöµüèø üë®üèΩ‚Äç‚öñÔ∏è Como traduzimos a configura√ß√£o de nossos servi√ßos de XML para YAML üîî üíé üóúÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Antecedentes 
 Nossa empresa, entre outras coisas, desenvolveu v√°rios servi√ßos (mais precisamente - 12) que funcionam como o back-end de nossos sistem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como traduzimos a configura√ß√£o de nossos servi√ßos de XML para YAML</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/utex/blog/438362/"><h2>  Antecedentes </h2><br>  Nossa empresa, entre outras coisas, desenvolveu v√°rios servi√ßos (mais precisamente - 12) que funcionam como o back-end de nossos sistemas.  Cada um dos servi√ßos √© um servi√ßo do Windows e executa suas tarefas espec√≠ficas. <br><br>  Eu gostaria de transferir todos esses servi√ßos para o * nix-OS.  Para fazer isso, abandone o wrapper na forma de servi√ßos do Windows e alterne do .NET Framework para o .NET Standard. <br><br>  O √∫ltimo requisito leva √† necessidade de se livrar de algum c√≥digo herdado, que n√£o √© suportado no .NET Standard, incluindo  do suporte √† configura√ß√£o de nossos servidores via XML, implementado usando as classes do System.Configuration.  Ao mesmo tempo, isso resolve o problema de longa data relacionado ao fato de que, nas configura√ß√µes de XML, cometemos erros de tempos em tempos ao alterar as configura√ß√µes (por exemplo, √†s vezes colocamos a tag de fechamento no lugar errado ou esquecemos de tudo), mas um maravilhoso leitor de configura√ß√µes de System.Xml XML. XmlDocument silenciosamente engole essas configura√ß√µes, produzindo um resultado completamente imprevis√≠vel. <br><br>  Decidiu-se mudar para a configura√ß√£o atrav√©s da moderna YAML.  Que problemas enfrentamos e como os resolvemos? Neste artigo. <br><a name="habracut"></a><br><h2>  O que temos </h2><br><h3>  Como lemos a configura√ß√£o do XML </h3><br>  Lemos XML de maneira padr√£o para a maioria dos outros projetos. <br><br>  Cada servi√ßo possui um arquivo de configura√ß√µes para projetos .NET, chamado AppSettings.cs, que cont√©m todas as configura√ß√µes exigidas pelo servi√ßo.  Algo assim: <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Configuration.SettingsProvider(typeof(PortableSettingsProvider))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AppSettings</span></span> : <span class="hljs-title"><span class="hljs-title">IServerManagerConfigStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IWebSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IServerSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IGraphiteAddressStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IDatabaseConfigStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IBlackListStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IKeyCloackConfigFilePathProvider</span></span>, <span class="hljs-title"><span class="hljs-title">IPrometheusSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IMetricsConfig</span></span> { }</code> </pre> <br><br>  Uma t√©cnica semelhante para separar configura√ß√µes em interfaces torna conveniente us√°-las posteriormente atrav√©s de um cont√™iner de DI. <br><br>  Toda a m√°gica principal de armazenar configura√ß√µes est√° realmente oculta no PortableSettingsProvider (consulte o atributo de classe), bem como no arquivo de designer AppSettings.Designer.cs: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()</span></span>] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.CodeDom.Compiler.GeneratedCodeAttribute(<span class="hljs-string"><span class="hljs-string">"Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator"</span></span>, <span class="hljs-string"><span class="hljs-string">"14.0.0.0"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AppSettings</span></span> : <span class="hljs-title"><span class="hljs-title">global</span></span>::<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Configuration</span></span>.<span class="hljs-title"><span class="hljs-title">ApplicationSettingsBase</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings defaultInstance = ((AppSettings)(<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.ApplicationSettingsBase.Synchronized(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AppSettings()))); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings Default { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultInstance; } } [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.UserScopedSettingAttribute()] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Diagnostics.DebuggerNonUserCodeAttribute()] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.DefaultSettingValueAttribute(<span class="hljs-string"><span class="hljs-string">"35016"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ListenPort { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">"ListenPort"</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">"ListenPort"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } ...</code> </pre><br>  Como voc√™ pode ver, ‚Äúnos bastidores‚Äù est√£o ocultas todas as propriedades que adicionamos √† configura√ß√£o do servidor quando a editamos atrav√©s do designer de configura√ß√µes no Visual Studio. <br><br>  Nossa classe PortableSettingsProvider, mencionada acima, l√™ diretamente o arquivo XML, e o resultado da leitura j√° √© usado no SettingsProvider para gravar configura√ß√µes nas propriedades do AppSettings. <br><br>  Um exemplo da configura√ß√£o XML que estamos lendo (a maioria das configura√ß√µes est√° oculta por motivos de seguran√ßa): <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configSections</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sectionGroup</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"userSettings"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"System.Configuration.UserSettingsGroup"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">section</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MetricServer.Properties.Settings"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"System.Configuration.ClientSettingsSection"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sectionGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configSections</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">userSettings</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">MetricServer.Properties.Settings</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MCXSettings"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">serializeAs</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"String"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>Inactive, ChartLen: 1000, PrintLen: 50, UseProxy: False<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"KickUnknownAfter"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">serializeAs</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"String"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>00:00:10<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">MetricServer.Properties.Settings</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">userSettings</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">configuration</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><h3>  Quais arquivos YAML eu gostaria de ler </h3><br>  Algo assim: <br><br><pre> <code class="plaintext hljs">VirtualFeed: MaxChartHistoryLength: 10 Port: 35016 UseThrottling: True ThrottlingIntervalMs: 50000 UseHistoryBroadcast: True CalendarName: "EmptyCalendar" UsMarketFeed: UseImbalances: True</code> </pre><br><h3>  Problemas de transi√ß√£o </h3><br>  <b>Primeiramente, as</b> configura√ß√µes em XML s√£o "simples", mas em YAML elas n√£o s√£o (se√ß√µes e subse√ß√µes s√£o suportadas).  Isso √© claramente visto nos exemplos acima.  Usando XML, resolvemos o problema de configura√ß√µes simples introduzindo nossos pr√≥prios analisadores que podem converter cadeias de caracteres de um determinado tipo em nossas classes mais complexas.  Um exemplo de uma cadeia t√£o complexa: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MCXSettings"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">serializeAs</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"String"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span>Inactive, ChartLen: 1000, PrintLen: 50, UseProxy: False<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">setting</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  N√£o tenho vontade de fazer essas transforma√ß√µes ao trabalhar com o YAML.  Mas, ao mesmo tempo, somos limitados pela estrutura "plana" existente da classe AppSettings: todas as propriedades das configura√ß√µes nela s√£o empilhadas em uma pilha. <br><br>  <b>Em segundo lugar, as</b> configura√ß√µes de nossos servidores n√£o s√£o um mon√≥lito est√°tico, n√≥s as alteramos de tempos em tempos, no decorrer do trabalho do servidor, ou seja,  essas mudan√ßas precisam ser ativadas em tempo real.  Para fazer isso, na implementa√ß√£o XML, herdamos nosso AppSettings de INotifyPropertyChanged (de fato, toda interface que implementa o AppSettings √© herdada dele) e nos inscrevemos para atualizar eventos de configura√ß√µes de propriedades.  Essa abordagem funciona porque a classe base System.Configuration.ApplicationSettingsBase pronto para uso implementa INotifyPropertyChanged.  Um comportamento semelhante deve ser mantido ap√≥s a transi√ß√£o para o YAML. <br><br>  <b>Em terceiro lugar,</b> na verdade, n√£o temos um arquivo de configura√ß√£o para cada servidor, mas dois como: um com configura√ß√µes padr√£o e outro com configura√ß√µes substitu√≠das.  Isso √© necess√°rio para que, em cada uma das v√°rias inst√¢ncias de servidores do mesmo tipo, escute portas diferentes e tenha configura√ß√µes ligeiramente diferentes, voc√™ n√£o precise copiar completamente todo o conjunto de configura√ß√µes. <br><br>  <b>E mais um problema</b> : o acesso √†s configura√ß√µes passa n√£o apenas pelas interfaces, mas tamb√©m pelo acesso direto ao AppSettings.Default.  Deixe-me lembr√°-lo de como √© declarado nos AppSettings.Designer.cs nos bastidores: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings defaultInstance = ((AppSettings)(<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.ApplicationSettingsBase.Synchronized(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AppSettings()))); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings Default { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultInstance; } }</code> </pre><br>  Com base no exposto, foi necess√°rio criar uma nova abordagem para armazenar configura√ß√µes no AppSettings. <br><br><h2>  Solu√ß√£o </h2><br><h3>  Toolkit </h3><br>  Para leitura direta, o YAML decidiu usar bibliotecas prontas dispon√≠veis no NuGet: <br><br><ul><li>  YamlDotNet - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/aaubry/YamlDotNet</a> .  Na descri√ß√£o da biblioteca (tradu√ß√£o): <br><blockquote>  YamlDotNet √© a biblioteca .NET para YAML.  O YamlDotNet fornece um analisador de baixo n√≠vel e um gerador YAML, al√©m de um modelo de objeto de alto n√≠vel semelhante ao XmlDocument.  Tamb√©m est√° inclu√≠da uma biblioteca de serializa√ß√£o que permite ler e gravar objetos de / para fluxos YAML. </blockquote><br></li><li>  NetEscapades.Configuration - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/andrewlock/NetEscapades.Configuration</a> .  Esse √© o pr√≥prio provedor de configura√ß√£o (no sentido de Microsoft.Extensions.Configuration.IConfigurationSource, que √© usado ativamente nos aplicativos ASP.NET Core), que l√™ arquivos YAML usando apenas o mencionado acima no YamlDotNet. <br></li></ul><br>  Leia mais sobre como usar essas bibliotecas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h3>  Transi√ß√£o para YAML </h3><br>  A transi√ß√£o em si foi realizada em dois est√°gios: no in√≠cio, simplesmente mudamos de XML para YAML, mas mantendo uma hierarquia plana de arquivos de configura√ß√£o e, em seguida, inserimos se√ß√µes nos arquivos YAML.  Esses est√°gios podem, em princ√≠pio, ser combinados em um e, para simplificar a apresenta√ß√£o, farei exatamente isso.  Todas as a√ß√µes descritas abaixo foram aplicadas seq√ºencialmente a cada servi√ßo. <br><br><h3>  Preparando um arquivo YML </h3><br>  Primeiro, voc√™ precisa preparar o arquivo YAML.  N√≥s o chamamos de nome do projeto (√∫til para testes de integra√ß√£o futuros, que devem poder trabalhar com servidores diferentes e distinguir entre suas configura√ß√µes), colocar o arquivo na raiz do projeto, ao lado de AppSettings: <br><br><img src="https://habrastorage.org/webt/es/2h/jo/es2hjofltziwk8fbqj3f5faxte0.png"><br><br>  No arquivo YML, para iniciantes, vamos salvar uma estrutura "plana": <br><br><pre> <code class="plaintext hljs">VirtualFeed: "MaxChartHistoryLength: 10, UseThrottling: True, ThrottlingIntervalMs: 50000, UseHistoryBroadcast: True, CalendarName: EmptyCalendar" VirtualFeedPort: 35016 UsMarketFeedUseImbalances: True</code> </pre><br><h3>  Preenchendo configura√ß√µes de aplicativos com propriedades de configura√ß√µes </h3><br>  Transferimos todas as propriedades de AppSettings.Designer.cs para AppSettings.cs, eliminando simultaneamente os atributos sup√©rfluos do designer e o pr√≥prio c√≥digo em get / set-parts. <br><br>  Foi: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">global::System.Configuration.UserScopedSettingAttribute()</span></span>] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Diagnostics.DebuggerNonUserCodeAttribute()] [<span class="hljs-keyword"><span class="hljs-keyword">global</span></span>::System.Configuration.DefaultSettingValueAttribute(<span class="hljs-string"><span class="hljs-string">"35016"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VirtualFeedPort{ <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">"VirtualFeedPort"</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">"VirtualFeedPort"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre><br>  Tornou-se: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VirtualFeedPort { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br>  Removeremos completamente o AppSettings <b>.Designer</b> .cs como desnecess√°rio.  Agora, a prop√≥sito, voc√™ pode se livrar completamente da se√ß√£o userSettings no arquivo app.config, se estiver no projeto - as mesmas configura√ß√µes padr√£o s√£o armazenadas l√°, que especificamos atrav√©s do designer de configura√ß√µes. <br>  V√° em frente. <br><br><h3>  Controlar as configura√ß√µes em tempo real </h3><br>  Como precisamos conseguir atualiza√ß√µes de nossas configura√ß√µes em tempo de execu√ß√£o, precisamos implementar INotifyPropertyChanged em nossas AppSettings.  A base System.Configuration.ApplicationSettingsBase n√£o est√° mais l√°, respectivamente, voc√™ n√£o pode contar com nenhuma m√°gica. <br><br>  Voc√™ pode implement√°-lo ‚Äúna testa‚Äù: adicionando uma implementa√ß√£o de um m√©todo que lan√ßa o evento desejado e o chama no setter de cada propriedade.  Mas essas s√£o linhas de c√≥digo extras, que al√©m disso precisar√£o ser copiadas em todos os servi√ßos. <br><br>  Vamos fazer o melhor: introduza o AutoNotifier da classe base auxiliar, que na verdade faz a mesma coisa, mas nos bastidores, assim como System.Configuration.ApplicationSettingsBase fez antes: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Implements </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;see cref="INotifyPropertyChanged"/&gt;</span></span></span><span class="hljs-comment"> for classes with a lot of public properties (ie AppSettings). </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> This implementation is: </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> - fairly slow, so don't use it for classes where getting/setting of properties is often operation; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> - not for properties described in inherited classes of 2nd level (bad idea: Inherit2 -&gt; Inherit1 -&gt; AutoNotifier; good idea: sealed Inherit -&gt; AutoNotifier) </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public abstract class AutoNotifier : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; private readonly ConcurrentDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, object&gt;</span></span></span><span class="hljs-comment"> _wrappedValues = new ConcurrentDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, object&gt;</span></span></span><span class="hljs-comment">(); //just to avoid manual writing a lot of fields protected T Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">([CallerMemberName] string propertyName = null) { return (T)_wrappedValues.GetValueOrDefault(propertyName, () =&gt; default(T)); } protected void Set</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">(T value, [CallerMemberName] string propertyName = null) { // ReSharper disable once AssignNullToNotNullAttribute _wrappedValues.AddOrUpdate(propertyName, value, (s, o) =&gt; value); OnPropertyChanged(propertyName); } public object this[string propertyName] { get { return Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;object&gt;</span></span></span><span class="hljs-comment">(propertyName); } set { Set(value, propertyName); } } protected void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } }</span></span></code> </pre><br>  Aqui, o atributo [CallerMemberName] permite obter automaticamente o nome da propriedade do objeto que est√° chamando, ou seja,  AppSettings <br><br>  Agora podemos herdar nosso AppSettings dessa AutoNotifier de classe base e, em seguida, cada propriedade √© ligeiramente modificada: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VirtualFeedPort { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Set(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } }</code> </pre><br>  Com essa abordagem, nossas classes AppSettings, mesmo contendo muitas configura√ß√µes, parecem compactas e, ao mesmo tempo, implementam completamente INotifyPropertyChanged. <br><br>  Sim, eu sei que seria poss√≠vel introduzir um pouco mais de m√°gica, usando, por exemplo, o Castle.DynamicProxy.IInterceptor, interceptando altera√ß√µes nas propriedades necess√°rias e gerando eventos l√°.  Mas essa decis√£o me pareceu muito sobrecarregada. <br><br><h3>  Lendo configura√ß√µes de um arquivo YAML </h3><br>  A pr√≥xima etapa √© adicionar o leitor da pr√≥pria configura√ß√£o YAML.  Isso acontece em algum lugar mais pr√≥ximo do in√≠cio do servi√ßo.  Ocultando detalhes desnecess√°rios que n√£o est√£o relacionados ao t√≥pico em discuss√£o, obtemos algo semelhante: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IServerConfigurationProvider </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadServerConfiguration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IReadOnlyDictionary&lt;Type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; allSections</span></span></span><span class="hljs-function">)</span></span> { IConfigurationBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConfigurationBuilder().SetBasePath(ConfigFiles.BasePath); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> configFile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> configFiles) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> directory = Path.GetDirectoryName(configFile); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(directory)) <span class="hljs-comment"><span class="hljs-comment">//can be empty if relative path is used { Directory.CreateDirectory(directory); } builder = builder.AddYamlFile(configFile, optional: true, reloadOnChange: true); } IConfigurationRoot config = builder.Build(); // load prepared files and merge them return new ServerConfigurationProvider&lt;TAppSettings&gt;(config, allSections); }</span></span></code> </pre><br>  No c√≥digo apresentado, o ConfigurationBuilder provavelmente n√£o √© de interesse especial - todo o trabalho com ele √© semelhante ao trabalho com configura√ß√µes no ASP.NET Core.  Mas os seguintes pontos s√£o de interesse.  Primeiro, ‚Äúpronto para usar‚Äù tamb√©m tivemos a oportunidade de combinar configura√ß√µes de v√°rios arquivos.  Isso fornece o requisito de ter pelo menos dois arquivos de configura√ß√£o por servidor, como mencionei acima.  Em segundo lugar, passamos toda a configura√ß√£o de leitura para um determinado ServerConfigurationProvider.  Porque <br><br><h3>  Se√ß√µes no arquivo YAML </h3><br>  Responderemos a essa pergunta mais tarde e agora voltamos ao requisito de armazenar configura√ß√µes estruturadas hierarquicamente em um arquivo YML. <br><br>  Em princ√≠pio, implementar isso √© bastante simples.  Primeiro, no arquivo YML, apresentamos a estrutura de que precisamos: <br><br><pre> <code class="plaintext hljs">VirtualFeed: MaxChartHistoryLength: 10 Port: 35016 UseThrottling: True ThrottlingIntervalMs: 50000 UseHistoryBroadcast: True CalendarName: "EmptyCalendar" UsMarketFeed: UseImbalances: True</code> </pre><br>  Agora vamos para AppSettings e ensin√°-lo a dividir nossas propriedades em se√ß√µes.  Algo assim: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AppSettings</span></span> : <span class="hljs-title"><span class="hljs-title">AutoNotifier</span></span>, <span class="hljs-title"><span class="hljs-title">IWebSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IServerSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IServerManagerAddressStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IGlobalCredentialsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IGraphiteAddressStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IDatabaseConfigStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IBlackListStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IKeyCloackConfigFilePathProvider</span></span>, <span class="hljs-title"><span class="hljs-title">IPrometheusSettingsStorage</span></span>, <span class="hljs-title"><span class="hljs-title">IHeartBeatConfig</span></span>, <span class="hljs-title"><span class="hljs-title">IConcurrentAcceptorProperties</span></span>, <span class="hljs-title"><span class="hljs-title">IMetricsConfig</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IReadOnlyDictionary&lt;Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; Sections { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; { {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IDatabaseConfigStorage), <span class="hljs-string"><span class="hljs-string">"Database"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IWebSettingsStorage), <span class="hljs-string"><span class="hljs-string">"Web"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IServerSettingsStorage), <span class="hljs-string"><span class="hljs-string">"Server"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IConcurrentAcceptorProperties), <span class="hljs-string"><span class="hljs-string">"ConcurrentAcceptor"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IGraphiteAddressStorage), <span class="hljs-string"><span class="hljs-string">"Graphite"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IKeyCloackConfigFilePathProvider), <span class="hljs-string"><span class="hljs-string">"Keycloak"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IPrometheusSettingsStorage), <span class="hljs-string"><span class="hljs-string">"Prometheus"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IHeartBeatConfig), <span class="hljs-string"><span class="hljs-string">"Heartbeat"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IServerManagerAddressStorage), <span class="hljs-string"><span class="hljs-string">"ServerManager"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IGlobalCredentialsStorage), <span class="hljs-string"><span class="hljs-string">"GlobalCredentials"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IBlackListStorage), <span class="hljs-string"><span class="hljs-string">"Blacklist"</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IMetricsConfig), <span class="hljs-string"><span class="hljs-string">"Metrics"</span></span>} }; ...</code> </pre><br>  Como voc√™ pode ver, adicionamos um dicion√°rio diretamente ao AppSettings, onde as chaves s√£o os tipos de interfaces que a classe AppSettings implementa e os valores s√£o os cabe√ßalhos das se√ß√µes correspondentes.  Agora podemos comparar a hierarquia no arquivo YML com a hierarquia de propriedades no AppSettings (embora n√£o seja mais profunda que um n√≠vel de aninhamento, mas, no nosso caso, isso foi suficiente). <br><br>  Por que estamos fazendo isso aqui - no AppSettings?  Porque, dessa maneira, n√£o divulgamos as informa√ß√µes sobre as configura√ß√µes para diferentes entidades e, al√©m disso, este √© o local mais natural, porque  em cada servi√ßo e, consequentemente, em cada AppSettings, sua pr√≥pria se√ß√£o de configura√ß√µes. <br><br><h3>  Se voc√™ n√£o precisa de uma hierarquia nas configura√ß√µes? </h3><br>  Em princ√≠pio, √© um caso estranho, mas o tivemos exatamente no primeiro est√°gio, quando simplesmente mudamos de XML para YAML, sem usar as vantagens do YAML. <br><br>  Nesse caso, toda a lista de se√ß√µes n√£o pode ser armazenada e o ServerConfigurationProvider ser√° muito mais simples (discutido posteriormente). <br><br>  Mas o ponto importante √© que, se decidirmos deixar uma hierarquia simples, podemos apenas cumprir o requisito de manter a capacidade de acessar configura√ß√µes por meio do AppSettings.Default.  Para fazer isso, adicione aqui um construtor p√∫blico t√£o simples no AppSettings: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AppSettings Default { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AppSettings</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Default = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  Agora, podemos continuar acessando a classe de configura√ß√µes em qualquer lugar atrav√©s do AppSettings.Default (desde que as configura√ß√µes j√° tenham sido lidas atrav√©s de IConfigurationRoot no ServerConfigurationProvider e, consequentemente, o AppSettings foi instanciado). <br><br>  Se uma hierarquia plana √© inaceit√°vel, voc√™ precisa se livrar do AppSettings.Default em todos os lugares por c√≥digo e trabalhar com as configura√ß√µes apenas por meio de interfaces (o que √© bom em princ√≠pio).  Por que isso - ficar√° mais claro. <br><br><h3>  ServerConfigurationProvider </h3><br>  A classe ServerConfigurationProvider especial mencionada anteriormente lida com a pr√≥pria magia que permite trabalhar totalmente com a nova configura√ß√£o hier√°rquica do YAML com apenas um AppSettings simples. <br><br>  Se voc√™ n√£o pode esperar, aqui est√°. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo completo do ServerConfigurationProvider</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Provides different configurations for current server </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public class ServerConfigurationProvider</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TAppSettings&gt;</span></span></span><span class="hljs-comment"> : IServerConfigurationProvider where TAppSettings : new() { private static readonly Logger Logger = LogManager.GetCurrentClassLogger(); private readonly IConfigurationRoot _configuration; private readonly IReadOnlyDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type, string&gt;</span></span></span><span class="hljs-comment"> _sectionsByInterface; private readonly IReadOnlyDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, Type&gt;</span></span></span><span class="hljs-comment"> _interfacesBySections; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Section name -&gt; config </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private readonly ConcurrentDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, TAppSettings&gt;</span></span></span><span class="hljs-comment"> _cachedSections; public ServerConfigurationProvider(IConfigurationRoot configuration, IReadOnlyDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type, string&gt;</span></span></span><span class="hljs-comment"> allSections) { _configuration = configuration; _cachedSections = new ConcurrentDictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, TAppSettings&gt;</span></span></span><span class="hljs-comment">(); _sectionsByInterface = allSections; var interfacesBySections = new Dictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string, Type&gt;</span></span></span><span class="hljs-comment">(); foreach (KeyValuePair</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type, string&gt;</span></span></span><span class="hljs-comment"> interfaceAndSection in _sectionsByInterface) { //section names must be unique interfacesBySections.Add(interfaceAndSection.Value, interfaceAndSection.Key); } _interfacesBySections = interfacesBySections; _configuration.GetReloadToken()?.RegisterChangeCallback(OnConfigurationFileChanged, null); } private void OnConfigurationFileChanged(object _) { UpdateCache(); } private void UpdateCache() { foreach (string sectionName in _cachedSections.Keys) { Type sectionInterface = _interfacesBySections[sectionName]; TAppSettings newSection = ReadSection(sectionName, sectionInterface); TAppSettings oldSection; if (_cachedSections.TryGetValue(sectionName, out oldSection)) { UpdateSection(oldSection, newSection); } } } private void UpdateSection(TAppSettings oldConfig, TAppSettings newConfig) { foreach (PropertyInfo propertyInfo in typeof(TAppSettings).GetProperties().Where(p =&gt; p.GetMethod != null &amp;&amp; p.SetMethod != null)) { propertyInfo.SetValue(newConfig, propertyInfo.GetValue(oldConfig)); } } public IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment"> AllSections =&gt; _sectionsByInterface.Keys; public TSettingsSectionInterface FindSection</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TSettingsSectionInterface&gt;</span></span></span><span class="hljs-comment">() where TSettingsSectionInterface : class { return (TSettingsSectionInterface)FindSection(typeof(TSettingsSectionInterface)); } [CanBeNull] public object FindSection(Type sectionInterface) { string sectionName = FindSectionName(sectionInterface); if (sectionName == null) { return null; } //we must return same instance of settings for same requested section (otherwise changing of settings will lead to inconsistent state) return _cachedSections.GetOrAdd(sectionName, typeName =&gt; ReadSection(sectionName, sectionInterface)); } private string FindSectionName(Type sectionInterface) { string sectionName; if (!_sectionsByInterface.TryGetValue(sectionInterface, out sectionName)) { Logger.Debug("This server doesn't contain settings for {0}", sectionInterface.FullName); return null; } return sectionName; } private TAppSettings ReadSection(string sectionName, Type sectionInterface) { TAppSettings parsed; try { IConfigurationSection section = _configuration.GetSection(sectionName); CheckSection(section, sectionName, sectionInterface); parsed = section.Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TAppSettings&gt;</span></span></span><span class="hljs-comment">(); if (parsed == null) { //means that this section is empty or all its properties are empty return new TAppSettings(); } ReadArrays(parsed, section); } catch (Exception ex) { Logger.Fatal(ex, "Something wrong during reading section {0} in config", sectionName.SafeSurround()); throw; } return parsed; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Manual reading of array properties in config </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void ReadArrays(TAppSettings settings, IConfigurationSection section) { foreach (PropertyInfo propertyInfo in GetPublicProperties(typeof(TAppSettings), needSetters: true).Where(p =&gt; typeof(IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment">).IsAssignableFrom(p.PropertyType))) { ClearDefaultArrayIfOverridenExists(section.Key, propertyInfo.Name); IConfigurationSection enumerableProperty = section.GetSection(propertyInfo.Name); propertyInfo.SetValue(settings, enumerableProperty.Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IEnumerable&lt;string&gt;</span></span></span><span class="hljs-comment">&gt;()); } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Clears array property from default config to use overriden one. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Standard implementation merges default and overriden array by indexes - this is not what we need </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void ClearDefaultArrayIfOverridenExists(string sectionName, string propertyName) { List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IConfigurationProvider&gt;</span></span></span><span class="hljs-comment"> providers = _configuration.Providers.ToList(); if (providers.Count == 0) { return; } string propertyTemplate = $"{sectionName}:{propertyName}:"; if (!providers[providers.Count - 1].TryGet($"{propertyTemplate}{0}", out _)) { //we should use array from default config, because overriden config has no overriden array return; } foreach (IConfigurationProvider provider in providers.Take(providers.Count - 1)) { for (int i = 0; ; i++) { string propertyInnerName = $"{propertyTemplate}{i}"; if (!provider.TryGet(propertyInnerName, out _)) { break; } provider.Set(propertyInnerName, null); } } } private void CheckSection(IConfigurationSection section, string sectionName, Type sectionInterface) { ICollection</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PropertyInfo&gt;</span></span></span><span class="hljs-comment"> properties = GetPublicProperties(sectionInterface, needSetters: false); var configProperties = new HashSet</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment">(section.GetChildren().Select(c =&gt; c.Key)); foreach (PropertyInfo propertyInfo in properties) { if (!configProperties.Remove(propertyInfo.Name)) { if (propertyInfo.PropertyType != typeof(string) &amp;&amp; typeof(IEnumerable).IsAssignableFrom(propertyInfo.PropertyType)) { //no way to distinguish absent array and empty array :( Logger.Debug("Property {0} has no valuable items in configs section {1}", propertyInfo.Name, sectionName.SafeSurround()); } else { Logger.Fatal("Property {0} not found in configs section {1}", propertyInfo.Name, sectionName.SafeSurround()); } } } if (configProperties.Any()) { Logger.Fatal("Unexpected config properties {0} in configs section {1}", configProperties.SafeSurroundAndJoin(), sectionName.SafeSurround()); } } private static ICollection</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PropertyInfo&gt;</span></span></span><span class="hljs-comment"> GetPublicProperties(Type type, bool needSetters) { if (!type.IsInterface) { return type.GetProperties().Where(x =&gt; x.GetMethod != null &amp;&amp; (!needSetters || x.SetMethod != null)).ToArray(); } var propertyInfos = new List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PropertyInfo&gt;</span></span></span><span class="hljs-comment">(); var considered = new List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment">(); var queue = new Queue</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment">(); considered.Add(type); queue.Enqueue(type); while (queue.Count &gt; 0) { Type subType = queue.Dequeue(); foreach (Type subInterface in subType.GetInterfaces()) { if (considered.Contains(subInterface)) { continue; } considered.Add(subInterface); queue.Enqueue(subInterface); } PropertyInfo[] typeProperties = subType.GetProperties(BindingFlags.FlattenHierarchy | BindingFlags.Public | BindingFlags.Instance); IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PropertyInfo&gt;</span></span></span><span class="hljs-comment"> newPropertyInfos = typeProperties.Where(x =&gt; x.GetMethod != null &amp;&amp; (!needSetters || x.SetMethod != null) &amp;&amp; !propertyInfos.Contains(x)); propertyInfos.InsertRange(0, newPropertyInfos); } return propertyInfos; } }</span></span></code> </pre><br></div></div><br>  ServerConfigurationProvider √© parametrizado pela classe de configura√ß√µes AppSettings: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ServerConfigurationProvider</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TAppSettings</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IServerConfigurationProvider</span></span> <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">TAppSettings</span></span> : <span class="hljs-title"><span class="hljs-title">new</span></span>()</code> </pre><br>  Isso, como voc√™ pode imaginar, permite us√°-lo imediatamente em todos os servi√ßos. <br><br>  A pr√≥pria configura√ß√£o de leitura (IConfigurationRoot), bem como o dicion√°rio de se√ß√£o mencionado acima (AppSettings.Sections), s√£o passados ‚Äã‚Äãpara o construtor.  H√° uma assinatura para atualiza√ß√µes de arquivo (queremos extrair imediatamente essas altera√ß√µes para n√≥s em caso de altera√ß√£o no arquivo YML?): <br><br><pre> <code class="cs hljs">_configuration.GetReloadToken()?.RegisterChangeCallback(OnConfigurationFileChanged, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnConfigurationFileChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> sectionName <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _cachedSections.Keys) { Type sectionInterface = _interfacesBySections[sectionName]; TAppSettings newSection = ReadSection(sectionName, sectionInterface); TAppSettings oldSection; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_cachedSections.TryGetValue(sectionName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> oldSection)) { UpdateSection(oldSection, newSection); } } }</code> </pre><br>  Como voc√™ pode ver aqui, no caso de atualizar o arquivo YML, examinamos todas as se√ß√µes que conhecemos e lemos cada uma.  Ent√£o, se a se√ß√£o j√° foi lida anteriormente no cache (ou seja, j√° foi solicitada em algum lugar do c√≥digo por alguma classe), reescrevemos os valores antigos no cache por novos. <br><br>  Parece - por que ler cada se√ß√£o, por que n√£o ler apenas aqueles que est√£o no cache (ou seja, exigidos)?  Porque, ao ler a se√ß√£o, implementamos uma verifica√ß√£o para a configura√ß√£o correta.  E, no caso de configura√ß√µes incorretas, os alertas correspondentes s√£o lan√ßados, os problemas s√£o registrados.  √â melhor aprender sobre os problemas nas altera√ß√µes de configura√ß√£o o mais r√°pido poss√≠vel, a partir das quais lemos todas as se√ß√µes imediatamente. <br><br>  Atualizar valores antigos no cache com novos valores √© bastante trivial: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TAppSettings oldConfig, TAppSettings newConfig</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-function"><span class="hljs-function">PropertyInfo propertyInfo </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typeof</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TAppSettings</span></span></span><span class="hljs-function">).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProperties</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Where</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p =&gt; p.GetMethod != </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;&amp; p.SetMethod != </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">))</span></span> { propertyInfo.SetValue(newConfig, propertyInfo.GetValue(oldConfig)); } }</code> </pre><br>  Mas ler se√ß√µes n√£o √© t√£o simples: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TAppSettings </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sectionName, Type sectionInterface</span></span></span><span class="hljs-function">)</span></span> { TAppSettings parsed; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { IConfigurationSection section = _configuration.GetSection(sectionName); CheckSection(section, sectionName, sectionInterface); parsed = section.Get&lt;TAppSettings&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsed == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//means that this section is empty or all its properties are empty return new TAppSettings(); } ReadArrays(parsed, section); } catch (Exception ex) { Logger.Fatal(ex, "Something wrong during reading section {0} in config", sectionName.SafeSurround()); throw; } return parsed; }</span></span></code> </pre><br>  Aqui, em primeiro lugar, lemos a pr√≥pria se√ß√£o usando o IConfigurationRoot.GetSection padr√£o.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, basta verificar a exatid√£o da se√ß√£o de leitura. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, lemos a se√ß√£o bindim para o tipo de nossas configura√ß√µes: section.Get Aqui encontramos um recurso do analisador YAML - ele n√£o faz distin√ß√£o entre uma se√ß√£o vazia (sem par√¢metros, ou seja, ausente) de uma se√ß√£o na qual todos os par√¢metros est√£o vazios. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√° um caso semelhante:</font></font><br><br><pre> <code class="plaintext hljs">VirtualFeed: Names: []</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui na se√ß√£o VirtualFeed, h√° um par√¢metro Names com uma lista vazia de valores, mas o analisador YAML, infelizmente, dir√° que a se√ß√£o VirtualFeed geralmente est√° completamente vazia. </font></font> Isso √© triste <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E, finalmente, nesse m√©todo, um pouco de magia de rua √© implementada para dar suporte √†s propriedades IEnumerable nas configura√ß√µes. </font><font style="vertical-align: inherit;">N√£o conseguimos obter uma leitura normal das listas "prontas para uso".</font></font><br><br><pre> <code class="cs hljs">ReadArrays(parsed, section); ... <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Manual reading of array properties in config </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void ReadArrays(TAppSettings settings, IConfigurationSection section) { foreach (PropertyInfo propertyInfo in GetPublicProperties(typeof(TAppSettings), needSetters: true).Where(p =&gt; typeof(IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;string&gt;</span></span></span><span class="hljs-comment">).IsAssignableFrom(p.PropertyType))) { ClearDefaultArrayIfOverridenExists(section.Key, propertyInfo.Name); IConfigurationSection enumerableProperty = section.GetSection(propertyInfo.Name); propertyInfo.SetValue(settings, enumerableProperty.Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IEnumerable&lt;string&gt;</span></span></span><span class="hljs-comment">&gt;()); } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Clears array property from default config to use overriden one. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Standard implementation merges default and overriden array by indexes - this is not what we need </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void ClearDefaultArrayIfOverridenExists(string sectionName, string propertyName) { List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IConfigurationProvider&gt;</span></span></span><span class="hljs-comment"> providers = _configuration.Providers.ToList(); if (providers.Count == 0) { return; } string propertyTemplate = $"{sectionName}:{propertyName}:"; if (!providers[providers.Count - 1].TryGet($"{propertyTemplate}{0}", out _)) { //we should use array from default config, because overriden config has no overriden array return; } foreach (IConfigurationProvider provider in providers.Take(providers.Count - 1)) { for (int i = 0; ; i++) { string propertyInnerName = $"{propertyTemplate}{i}"; if (!provider.TryGet(propertyInnerName, out _)) { break; } provider.Set(propertyInnerName, null); } } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como voc√™ pode ver, encontramos todas as propriedades cujo tipo √© herdado de IEnumerable e atribu√≠mos valores a elas na "se√ß√£o" fict√≠cia, tamb√©m chamada de configura√ß√£o em que estamos interessados. Mas antes disso, n√£o se esque√ßa de verificar: existe um valor substitu√≠do dessa propriedade enumerada no segundo arquivo de configura√ß√£o? Se houver, n√≥s apenas o aceitamos e limpamos as configura√ß√µes lidas no arquivo de configura√ß√£o base. Se isso n√£o for feito, as duas propriedades (do arquivo base e do substitu√≠do) ser√£o automaticamente mescladas em uma matriz no n√≠vel IConfigurationSection, e os √≠ndices da matriz servir√£o como chaves para a combina√ß√£o. Isso resultar√° em algum tipo de hash em vez do valor normal substitu√≠do. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O m√©todo ReadSection mostrado √© finalmente utilizado no m√©todo principal da classe: FindSection.</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CanBeNull</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type sectionInterface</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> sectionName = FindSectionName(sectionInterface); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sectionName == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//we must return same instance of settings for same requested section (otherwise changing of settings will lead to inconsistent state) return _cachedSections.GetOrAdd(sectionName, typeName =&gt; ReadSection(sectionName, sectionInterface)); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em princ√≠pio, fica claro por que, com o suporte das se√ß√µes, n√£o podemos oferecer suporte a AppSettings.Default de qualquer maneira: todo acesso a uma nova se√ß√£o de configura√ß√µes (n√£o lida anteriormente) atrav√©s do FindSection nos fornecer√° uma nova inst√¢ncia da classe AppSettings, embora anexada √† interface desejada e, portanto, se us√°ssemos AppSettings.Default, ela seria redefinida toda vez que uma nova se√ß√£o fosse lida e conteria apenas as configura√ß√µes que pertencem √† √∫ltima se√ß√£o de leitura (o restante teria valores padr√£o - NULL e 0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A valida√ß√£o das configura√ß√µes na se√ß√£o √© implementada da seguinte maneira:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IConfigurationSection section, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sectionName, Type sectionInterface</span></span></span><span class="hljs-function">)</span></span> { ICollection&lt;PropertyInfo&gt; properties = GetPublicProperties(sectionInterface, needSetters: <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> configProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(section.GetChildren().Select(c =&gt; c.Key)); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (PropertyInfo propertyInfo <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> properties) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!configProperties.Remove(propertyInfo.Name)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (propertyInfo.PropertyType != <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IEnumerable).IsAssignableFrom(propertyInfo.PropertyType)) { <span class="hljs-comment"><span class="hljs-comment">//no way to distinguish absent array and empty array :( Logger.Debug("Property {0} has no valuable items in configs section {1}", propertyInfo.Name, sectionName.SafeSurround()); } else { Logger.Fatal("Property {0} not found in configs section {1}", propertyInfo.Name, sectionName.SafeSurround()); } } } if (configProperties.Any()) { Logger.Fatal("Unexpected config properties {0} in configs section {1}", configProperties.SafeSurroundAndJoin(), sectionName.SafeSurround()); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui, primeiro, todas as propriedades p√∫blicas da interface em que estamos interessados ‚Äã‚Äãs√£o extra√≠das (se√ß√µes de configura√ß√µes de leitura). E para cada uma dessas propriedades, uma correspond√™ncia √© encontrada nas configura√ß√µes de leitura: se nenhuma correspond√™ncia for encontrada, o problema correspondente ser√° registrado, porque isso significa que falta alguma configura√ß√£o no arquivo de configura√ß√£o. No final, √© verificado adicionalmente se alguma das configura√ß√µes de leitura permaneceu incompar√°vel com a interface. Se houver, o problema ser√° registrado novamente, porque isso significa que as propriedades que n√£o s√£o descritas na interface foram encontradas no arquivo de configura√ß√£o, o que tamb√©m n√£o deve estar em uma situa√ß√£o normal.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surge a pergunta - de onde vem o requisito, que no arquivo de leitura todas as configura√ß√µes correspondam √†s dispon√≠veis na interface individualmente? O fato √© que, como mencionado acima, naquele momento, nenhum arquivo foi lido, mas dois de uma vez - um com as configura√ß√µes padr√£o e outro com os substitu√≠dos, e ambos s√£o cont√≠guos. Portanto, de fato, n√£o estamos analisando as configura√ß√µes de um arquivo, mas as completas. E, nesse caso, √© claro, seu conjunto deve corresponder √†s configura√ß√µes esperadas um a um.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preste aten√ß√£o tamb√©m nas fontes acima ao m√©todo GetPublicProperties, que, ao que parece, retorna apenas todas as propriedades p√∫blicas da interface. </font><font style="vertical-align: inherit;">Mas n√£o √© t√£o simples quanto poderia ser, porque √†s vezes temos uma interface que descreve as configura√ß√µes do servidor que s√£o herdadas de outra interface e, portanto, √© necess√°rio examinar toda a hierarquia de interfaces para encontrar todas as propriedades p√∫blicas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obtendo configura√ß√µes do servidor </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Com base no exposto, para obter as configura√ß√µes do servidor em qualquer lugar por c√≥digo, passamos √† seguinte interface: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Provides different configurations for current server </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public interface IServerConfigurationProvider { TSettingsSectionInterface FindSection</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;TSettingsSectionInterface&gt;</span></span></span><span class="hljs-comment">() where TSettingsSectionInterface : class; object FindSection(Type sectionInterface); IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment"> AllSections { get; } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O primeiro m√©todo dessa interface - FindSection - permite acessar a se√ß√£o de configura√ß√µes de seu interesse. </font></font> Algo assim: <br><br><pre> <code class="cs hljs">IThreadPoolProperties threadPoolProperties = ConfigurationProvider.FindSection&lt;IThreadPoolProperties&gt;();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por que o segundo e o terceiro m√©todo s√£o necess√°rios - explicarei mais adiante. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Registro de interfaces de configura√ß√µes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em nosso projeto, o Castle Windsor √© usado como um cont√™iner de IoC. √â ele quem fornece, incluindo as interfaces de configura√ß√£o do servidor. Portanto, essas interfaces devem ser registradas nele. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para esse prop√≥sito, uma classe Extension simples foi escrita, o que simplifica esse procedimento para n√£o gravar o registro de todo o conjunto de interfaces em cada servidor:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ServerConfigurationProviderExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterAllConfigurationSections</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IWindsorContainer container, IServerConfigurationProvider configurationProvider</span></span></span><span class="hljs-function">)</span></span> { Register(container, configurationProvider, configurationProvider.AllSections.ToArray()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Register</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IWindsorContainer container, IServerConfigurationProvider configurationProvider, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Type[] configSections</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> registrations = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IRegistration[configSections.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; registrations.Length; i++) { Type configSection = configSections[i]; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> section = configurationProvider.FindSection(configSection); registrations[i] = Component.For(configSection).Instance(section).Named(configSection.FullName); } container.Register(registrations); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O primeiro m√©todo permite registrar todas as se√ß√µes das configura√ß√µes (para isso, voc√™ precisa da propriedade AllSections na interface IServerConfigurationProvider). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E o segundo m√©todo √© usado no primeiro, e ele l√™ automaticamente a se√ß√£o de configura√ß√µes especificadas usando nosso ServerConfigurationProvider, gravando-o imediatamente no cache ServerConfigurationProvider e registrando-o em Windsor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â aqui que o segundo m√©todo FindSection, n√£o parametrizado, de IServerConfigurationProvider √© usado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resta apenas chamar nosso m√©todo de extens√£o no c√≥digo de registro de cont√™iner de Windsor:</font></font><br><br><pre> <code class="cs hljs">container.RegisterAllConfigurationSections(configProvider);</code> </pre><br><h2>  Conclus√£o </h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O que aconteceu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da maneira apresentada, foi poss√≠vel transferir sem esfor√ßo todas as configura√ß√µes de nossos servidores de XML para YAML, enquanto fazia um m√≠nimo de altera√ß√µes no c√≥digo do servidor existente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As configura√ß√µes de YAML, diferentemente do XML, acabaram sendo mais leg√≠veis devido n√£o apenas √† maior concis√£o, mas tamb√©m ao suporte ao particionamento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o inventamos nossas pr√≥prias bicicletas para analisar o YAML, mas usamos solu√ß√µes prontas. No entanto, para integr√°-los √†s realidades do nosso projeto, foram necess√°rios alguns dos truques descritos neste artigo. Espero que sejam √∫teis para os leitores.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foi poss√≠vel manter a capacidade de detectar altera√ß√µes nas configura√ß√µes nos focinhos da web de nossos servidores em tempo real. </font><font style="vertical-align: inherit;">Al√©m disso, como b√¥nus, tamb√©m foi poss√≠vel capturar altera√ß√µes no arquivo YAML em tempo real (anteriormente, era necess√°rio reiniciar o servidor para quaisquer altera√ß√µes nos arquivos de configura√ß√£o). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mantivemos a capacidade de mesclar dois arquivos de configura√ß√£o - as configura√ß√µes padr√£o e substitu√≠das, e fizemos isso usando solu√ß√µes de terceiros prontas para uso.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O que n√£o deu muito certo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu tive que abandonar a capacidade dispon√≠vel anteriormente para salvar as altera√ß√µes aplicadas das faces da web de nossos servidores nos arquivos de configura√ß√£o, porque </font><font style="vertical-align: inherit;">o suporte a essa funcionalidade exigiria grandes gestos, e a tarefa comercial diante de n√≥s em geral n√£o era essa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bem, eu tamb√©m tive que recusar o acesso √†s configura√ß√µes por meio do AppSettings.Default, mas isso √© mais um plus que um menos.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438362/">https://habr.com/ru/post/pt438362/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438350/index.html">Guia completo para pesquisa profissional de c√¢meras ocultas e dispositivos espi√µes</a></li>
<li><a href="../pt438352/index.html">V√≠deo da descida do ve√≠culo espacial "Yutu-2", seus primeiros metros na superf√≠cie da lua. O sono de duas semanas na lua acabou</a></li>
<li><a href="../pt438354/index.html">Vue, Storybook, TypeScript - iniciando um novo projeto com as melhores pr√°ticas em mente</a></li>
<li><a href="../pt438356/index.html">Arquitetura certificada Fast Track (DWFT) do SQL Server Data Warehouse: o que significa e como funciona</a></li>
<li><a href="../pt438358/index.html">Ex-agentes da NSA espionando iPhones das v√≠timas encomendados pelos Emirados √Årabes Unidos</a></li>
<li><a href="../pt438364/index.html">Replica√ß√£o do primeiro embaralhador de voz digital do mundo</a></li>
<li><a href="../pt438366/index.html">Mais uma an√°lise dos tokens de hardware OATH no Azure Cloud MFA</a></li>
<li><a href="../pt438368/index.html">L√¢mpadas inteligentes jogadas no lixo s√£o uma fonte valiosa de informa√ß√µes pessoais.</a></li>
<li><a href="../pt438370/index.html">Cibercrime como servi√ßo: servi√ßos e pre√ßos</a></li>
<li><a href="../pt438372/index.html">NASA continua tentando entrar em contato com a oportunidade</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>