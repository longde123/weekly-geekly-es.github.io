<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦂 🤴🏻 🥚 Lisp用Pascal或8501st编程语言调味 🙎🏽 🕓 🎙️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前一段时间（大约三年），我决定读一本有关Lisp的教科书。 没有任何特定的目的，只是为了总体发展，并且是为了使对话者感到异国情调（一旦看起来，甚至可以解决）。 

 但是经过仔细检查，Lisp确实非常强大，灵活并且在日常生活中有用。 所有次要的自动化任务都迅速迁移到Lisp中的脚本，并且还有机会实现...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lisp用Pascal或8501st编程语言调味</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424447/"> 前一段时间（大约三年），我决定读一本有关Lisp的教科书。 没有任何特定的目的，只是为了总体发展，并且是为了使对话者感到异国情调（一旦看起来，甚至可以解决）。 <br><br> 但是经过仔细检查，Lisp确实非常强大，灵活并且在日常生活中有用。 所有次要的自动化任务都迅速迁移到Lisp中的脚本，并且还有机会实现更复杂的自动化。 <br><br> 这里应该指出的是，“自动化能力”是指这样一种情况，即编写和调试程序的总时间少于手动解决同一任务所花费的时间。 <br><br> 保罗·格雷厄姆（Paul Graham）写了不止一篇文章，甚至写了一本有关Lisp好处的书。 在撰写本文时，Lisp在TOIBE排名中排名第33（死亡人数比死掉的Delphi高三倍）。 问题出现了：如果方便的话，为什么语言这么小？ 大约两年的使用说明了一些原因。 <br><a name="habracut"></a><br><h3> 缺点 </h3><br>  <i>1.共享数据结构</i> <br> 这个概念使您可以优化功能程序，但是在命令中却充满了微妙的错误。 如果修改的变量与结构之间没有可见的联系，则可能会意外损坏外部数据结构，这要求程序员不断监视幕后发生的事情，并了解所使用的每个功能（系统和用户）的内部实现。 最令人惊奇的事情是通过修改函数的返回值来破坏函数主体的能力。 <br><br>  <i>2.缺乏封装</i> <br> 尽管存在软件包的概念，但它与Ada中的<b>软件包</b>或Delphi中的<b>unit</b>无关。 任何代码都可以将任何东西添加到任何包中（系统包除外）。 任何代码都可以使用<b>::</b>运算符从任何包中提取任何内容。 <br><br>  <i>3. Hapazar的缩写</i> <br>  MAPCAN和MAPCON有什么区别？ 为什么在SETQ中最后一个字母Q？ 鉴于该语言的年代久远，您可以理解这种情况的原因，但是我希望该语言更加简洁。 <br><br>  <i>4.多线程</i> <br> 这个缺点与Lisp间接相关，主要与我使用的实现有关-SteelBank Common Lisp。  Common Lisp不支持多线程。 尝试使用SBCL提供的实现失败。 <br><br> 遗憾的是拒绝了这种方便的工具，但不满情绪逐渐累积。 <br><br><h3> 寻找解决方案 </h3><br> 首先，您可以在Lisp页面上转到Wikipedia。 检查“方言”部分。 阅读每个的简要介绍。 并意识到所有标记的味道和颜色是不同的。 <br><blockquote> 如果您想做某事，您需要自己做 <br>  -Jean Baptiste Emmanuel Sorg </blockquote> 让我们尝试通过添加一些Ada，很多Delphi和一滴Oberon来创建我们自己的正确Lisp。 我们称这种混合物为福克斯。 <br><br><h3> 基本概念 </h3><br>  <i>1.没有指针</i> <br> 在与PROBLEM-1的斗争中，必须通过复制值来执行所有操作。 根据代码中或打印时数据结构的类型，其所有属性，外部和内部连接都应完全可见。 <br><br>  <i>2.添加模块</i> <br> 作为解决问题2的一部分，我们<b>使用</b> Ada导入<b>package</b> <b>和</b>并<b>使用</b>语句。 在此过程中，我们丢弃了Lisp符号过于复杂的导入/阴影方案。 <br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">package</span></span> - (  ) () ())</code> </pre> <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">with</span></span> -) <span class="hljs-comment"><span class="hljs-comment">;  «-.lisya»   </span></span></code> </pre> <br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">use</span></span> -) <span class="hljs-comment"><span class="hljs-comment">;,      </span></span></code> </pre> <br><br>  <i>3.缩写少</i> <br> 最常见和常见的字符仍将被缩写，但最明显的最常见的字符是： <b>const</b> ， <b>var</b> 。 格式化输出函数-FMT需要缩减，因为它经常在表达式中找到。  <b>Elt-</b>占领了一个元素-从Common Lisp泄漏并扎根，尽管没有必要减少它。 <br><br>  <i>4.不区分大小写的标识符</i> <br> 我认为正确的语言（和文件系统）{$ HOLYWAR +}应该不区分大小写{$ HOLYWAR-}，以免再次绞尽脑汁。 <br><br>  <i>5.俄语键盘布局易于使用</i> <br> 语法Lisi尽可能避免使用其中一种布局中不可用的字符。 没有方括号或花括号。 否＃，〜，＆，&lt;，&gt;，|。 读取数字文字时，逗号和句点都被视为十进制分隔符。 <br><br>  <i>6.扩展字母</i> <br>  SBCL的优点之一是代码中的UTF-8。 声明常量BEAR，VODKA和BALALAYKA的能​​力大大简化了应用程序代码的编写。 插入Ω，Ψ和Σ的能力使代码中的公式更加直观。 尽管从理论上讲可以使用任何Unicode字符，但是很难保证使用它们的正确性（而不是懒惰而不是困难）。 我们只限于西里尔文，拉丁文和希腊文。 <br><br>  <i>7.数字文字</i> <br> 对我来说，这是最有用的语言扩展。 <br><br><pre> <code class="lisp hljs"><span class="hljs-number"><span class="hljs-number">10</span></span>_000 <span class="hljs-comment"><span class="hljs-comment">;    10k ;       10 ;       10° 10pi 10deg 10 ;   10π ; pi     10+i10 ;   10+10 ;    1010deg ;         </span></span></code> </pre> <br> 在我看来，后一种选择最不美观，但最受欢迎。 <br><br>  <i>8.周期</i> <br>  Lisp中的循环是非标准的并且非常混乱。 简化到最低标准设置。 <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">for</span></span> i <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-comment"><span class="hljs-comment">;   i = 0..4 ) (for i 1..6 ;   i = 1..5 ) (for i  ;     ;      ) (for i (subseq  2) ;           )</span></span></code> </pre> <br> 循环变量在外部不可见。 <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">while</span></span>  )</code> </pre> <br>  <i>9.转到</i> <br> 这不是一个非常必要的运算符，但是没有它，很难证明对结构化编程规则的忽视。 <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">block</span></span> : (<span class="hljs-name"><span class="hljs-name">goto</span></span> :)) <span class="hljs-comment"><span class="hljs-comment">;    </span></span></code> </pre> <br>  <i>10.范围的统一</i> <br>  Lisp中有两种不同的作用域类型：TOPLEVEL和本地。 因此，有两种不同的声明变量的方法。 <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defvar</span></span> A <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">a</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>)) …)</code> </pre> <br> 在Fox中，在脚本的顶层和局部区域（包括软件包）都只使用一种方法。 <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">var</span></span> A <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br> 如果要限制范围，请使用运算符 <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">block</span></span> (<span class="hljs-name"><span class="hljs-name">var</span></span> A <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">set</span></span> A <span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-name"><span class="hljs-name">fmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> A))</code> </pre> <br> 循环的主体包含在隐式BLOCK语句中（类似于函数/过程的主体）。 循环结束时声明的所有变量都在迭代结束时销毁。 <br><br>  <i>11.单槽字符</i> <br> 在Lisp中，函数是特殊对象，并存储在特殊符号槽中。 一个字符可以同时存储变量，函数和属性列表。 在狐狸中，每个字符仅具有一个含义。 <br><br>  <i>12.便捷的ELT</i> <br> 对Lisp中复杂结构的元素的典型访问如下所示 <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">elt</span></span> (<span class="hljs-name"><span class="hljs-name">slot-value</span></span> (<span class="hljs-name"><span class="hljs-name">elt</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span>) '<span class="hljs-number"><span class="hljs-number">-2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Fox实现了一个统一的ELT运算符，该运算符提供对任何复合类型的元素（列表，字符串，记录，字节数组，哈希表）的访问。 <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">elt</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> \<span class="hljs-number"><span class="hljs-number">-2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br> 也可以使用Lisp中的宏获得相同的功能 <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmacro</span></span> field (<span class="hljs-name"><span class="hljs-name">object</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;rest</span></span> f) <span class="hljs-string"><span class="hljs-string">"       . (field *object* 0 :keyword symbol \"string\")       .        plist.   ( )    .        ."</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> f (<span class="hljs-name"><span class="hljs-name">symbol-macrolet</span></span> ((<span class="hljs-name"><span class="hljs-name">f0</span></span> (<span class="hljs-name"><span class="hljs-name">elt</span></span> f <span class="hljs-number"><span class="hljs-number">0</span></span>))(<span class="hljs-name"><span class="hljs-name">rest</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> f <span class="hljs-number"><span class="hljs-number">1</span></span>))) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">numberp</span></span> f0) `(field (elt ,object ,f0) ,@rest)) ((<span class="hljs-name"><span class="hljs-name">keywordp</span></span> f0) `(field (getf ,object ,f0) ,@rest)) ((<span class="hljs-name"><span class="hljs-name">stringp</span></span> f0) `(field (cdr (assoc ,f0 ,object :test 'equal)) ,@rest)) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">listp</span></span> f0) (<span class="hljs-name"><span class="hljs-name">=</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-name"><span class="hljs-name">length</span></span> f0))) `(field (,(car f0) ,(cadr f0) ,object) ,@rest)) ((<span class="hljs-name"><span class="hljs-name">symbolp</span></span> f0) `(field (,f0 ,object) ,@rest)) (<span class="hljs-name"><span class="hljs-name">t</span></span> `(error <span class="hljs-string"><span class="hljs-string">"   "</span></span>)))) object))</code> </pre> <br>  <i>13.子程序参数传输模式的限制</i> <br>  Lisp中至少有五种参数传递模式：强制性， <i>＆可选</i> ， <i>＆rest</i> ， <i>＆key</i> <i>和＆整体，</i>并允许其任意组合。 实际上，大多数组合都会产生奇怪的效果。 <br> 在Fox中，仅允许使用必需参数和以下模式之一的组合，以从以下各项中进行选择<i>：键</i> <i>，：可选，：</i> <i>标志</i> <i>，：其余</i> 。 <br><br>  <i>14.多线程</i> <br> 为了最大程度地简化多线程程序的编写，采用了内存分离的概念。 生成线程时，将复制新线程可用的所有变量。 对这些变量的所有引用均由对副本的引用替换。 流之间的信息传递只有通过受保护的对象或流完成时返回的结果才有可能。 <br><br> 受保护的对象始终包含关键部分以确保原子操作。 登录关键部分是自动的-语言没有单独的操作符。 受保护的对象包括：消息队列，控制台和文件描述符。 <br><br> 使用多线程显示功能可以创建线程 <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">map-th</span></span> (<span class="hljs-name"><span class="hljs-name">function</span></span> (<span class="hljs-name"><span class="hljs-name">x</span></span>) …) --)</code> </pre> <br>  Map-th自动启动等于系统中处理器数量的线程数（如果内部装有Intel，则为两倍）。 在递归调用中，后续的第map个调用在单个线程中工作。 <br><br> 此外，还有一个内置的线程函数可以在单独的线程中执行过程/函数。 <br><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;   (var  (thread --1)) (+ (--2) (wait ))</span></span></code> </pre> <br>  <i>15.命令代码中的功能清洁</i> <br>  Fox具有用于函数式编程和程序过程的功能。 使用function关键字声明的例程必须满足以下要求：没有副作用，并且结果不受外界因素影响。 <br><br><h3> 未实现 </h3><br> 由于优先级较低，Lisp的一些有趣功能仍未实现。 <br><br>  <i>1.广义方法</i> <br> 能够使用defgeneric / defmethod重载函数。 <br><br>  <i>2.继承</i> <br><br>  <i>3.内置调试器</i> <br> 发生异常时，Lisp解释器将切换到调试模式。 <br><br>  <i>4.超滤</i> <br> 用于连接以其他语言编写的模块的接口。 <br><br>  <i>5.大数字</i> <br> 任意位深度支持 <br><br>  <b>舍弃</b> <br><br>  Lisp的某些功能已被考虑为无用/有害。 <br><br>  <i>1.方法的指导性结合</i> <br> 当为类调用方法时，将执行父方法的组合，并且可以更改组合规则。 该方法的最终行为似乎难以预测。 <br><br>  <i>2.重新启动</i> <br> 异常处理程序可以更改程序的状态，并将重新启动命令发送到生成异常的代码。 该应用程序的效果类似于使用GOTO运算符从一个功能切换到另一个功能。 <br><br>  <i>3.罗马帐</i> <br>  Lisp支持数字系统，该数字系统在出现之前不久已经过时。 <br><br><h3> 使用方法 </h3><br> 这是一些简单的代码示例。 <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">function</span></span> crc8 (<span class="hljs-name"><span class="hljs-name">data</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:optional</span></span> seed) (<span class="hljs-name"><span class="hljs-name">var</span></span> result (<span class="hljs-name"><span class="hljs-name">if-nil</span></span> seed <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">var</span></span> s_data data) (<span class="hljs-name"><span class="hljs-name">for</span></span> bit <span class="hljs-number"><span class="hljs-number">8</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">bit-and</span></span> (<span class="hljs-name"><span class="hljs-name">bit-xor</span></span> result s_data) $<span class="hljs-number"><span class="hljs-number">01</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">set</span></span> result (<span class="hljs-name"><span class="hljs-name">shift</span></span> result <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>)) (<span class="hljs-name"><span class="hljs-name">else</span></span> (<span class="hljs-name"><span class="hljs-name">set</span></span> result (<span class="hljs-name"><span class="hljs-name">bit-xor</span></span> result $<span class="hljs-number"><span class="hljs-number">18</span></span>)) (<span class="hljs-name"><span class="hljs-name">set</span></span> result (<span class="hljs-name"><span class="hljs-name">shift</span></span> result <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>)) (<span class="hljs-name"><span class="hljs-name">set</span></span> result (<span class="hljs-name"><span class="hljs-name">bit-or</span></span> result $<span class="hljs-number"><span class="hljs-number">80</span></span>)))) (<span class="hljs-name"><span class="hljs-name">set</span></span> s_data (<span class="hljs-name"><span class="hljs-name">shift</span></span> s_data <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>))) result)</code> </pre> <br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;     (map (function (x) (** x 2)) \(1 2 3))</span></span></code> </pre> <br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;   ,   qwe      (filter (function (x) (regexp:match x «^qwe...»)) -) ;   ,   ,    (filter-th (function (x) (regexp:match x «^qwe...»)) -)</span></span></code> </pre> <br><h3> 实作 </h3><br> 解释器是用Delphi（兼容模式下的FreePascal）编写的。 它是在Windows和Linux 32位和64位操作系统下的Lazarus 1.6.2和更高版本中构建的。 在外部依赖项中，需要libmysql.dll。 包含约15_000..20_000行。 大约有200种内置函数可用于各种用途（其中一些过载八次）。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">存放在这里</a> <br><br> 对动态类型的支持以简单的方式执行-所有处理的数据类型均由相同TValue类的继承人表示。 <br><br> 对于Lisp来说，最重要的类型-列表是Delphi惯用的，它是一个包含TValue类型的动态对象数组的类。 对于这种类型，将实现CopyOnWrite机制。 <br><br> 内存管理是基于引用计数自动进行的。 对于递归结构，将同时计算结构中的所有链接。 当变量退出作用域时，内存释放立即开始。 没有用于延迟启动垃圾收集器的机制。 <br><br> 异常处理基于Delphi中内置的机制。 因此，可以通过Fox上的可执行代码来处理解释器代码中发生的错误。 <br><br> 每个运算符或内置Lisi函数都作为解释器代码中的方法或函数实现。 该脚本是通过实现的相互递归调用来执行的。 解释器代码和脚本具有公共调用堆栈。 <br><br> 脚本变量独立存储在动态内存中。 每个用户定义的函数都有自己的堆栈，用于存储变量引用，而与顶级堆栈或父函数的堆栈无关。 <br><br> 特别困难的是结构元素的赋值运算符（集合）的实现。 直接计算指向所需元素的指针会导致悬挂链接的风险，因为Lisi语法不会在计算所需元素时禁止修改结构。 作为一种折衷解决方案，实现了“链指针”-一个对象，该对象包含对变量的引用和数字索引数组，以指示结构内的路径。 这样的指针也容易出现悬空链接的问题，但是在失败的情况下，它会生成有意义的错误消息。 <br><br><h3> 开发工具 </h3><br>  <i>1.控制台</i> <br><br>  <i>2.文字编辑器</i> <br> 配备了语法突出显示功能以及在F9中运行可编辑脚本的功能。 <br><img src="https://habrastorage.org/webt/1c/q9/yo/1cq9yo4edbezhjgav_mjby393rs.png"><br><br><h3> 结论 </h3><br> 在当前状态下，该项目解决了其设想的问题，并且不需要进一步的积极开发。 当前存在的许多缺陷对工作没有明显影响。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424447/">https://habr.com/ru/post/zh-CN424447/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424435/index.html">石油钻探动物园：整理事物</a></li>
<li><a href="../zh-CN424437/index.html">榆树 舒适而笨拙。 Json.Encoder和Json.Decoder</a></li>
<li><a href="../zh-CN424441/index.html">SQL Server 2019的第一个CTP中的新增功能</a></li>
<li><a href="../zh-CN424443/index.html">Vivaldi 2.0对我们有利</a></li>
<li><a href="../zh-CN424445/index.html">尼尔·福特（Neil Ford）将微服务翻译为进化架构</a></li>
<li><a href="../zh-CN424453/index.html">学习OpenGL。 第6.2课-基于物理的渲染。 分析光源</a></li>
<li><a href="../zh-CN424455/index.html">英特尔傲腾-现在1.5 TB</a></li>
<li><a href="../zh-CN424457/index.html">升级IDA Pro。 学习用Python编写引导加载程序</a></li>
<li><a href="../zh-CN424459/index.html">成功案例，或DEV + DEVOPS + OPS</a></li>
<li><a href="../zh-CN424461/index.html">为什么要学习不受欢迎的语言。 社区示例F＃</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>