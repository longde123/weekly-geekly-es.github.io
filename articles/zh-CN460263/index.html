<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🚒 👨🏽‍⚕️ ☝🏾 进行真正的智能搜索：分步指南 🤙🏻 🧑🏻 ☄️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在公司信息系统中进行搜索 -已经从该短语本身中获取信息。 如果您只有一个，那就太好了，甚至不必考虑正面的用户体验。 如何扭转被搜索引擎宠坏的用户的态度，并创建一种快速，准确，可完全理解的产品？ 我们需要学习很多Elasticsearch和一些智能服务，并将其与本指南相结合。 


 关于如何将基于E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>进行真正的智能搜索：分步指南</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/460263/"><p>  <em>在公司信息系统中进行搜索</em> -已经从该短语本身中获取信息。 如果您只有一个，那就太好了，甚至不必考虑正面的用户体验。 如何扭转被搜索引擎宠坏的用户的态度，并创建一种快速，准确，可完全理解的产品？ 我们需要学习很多Elasticsearch和一些智能服务，并将其与本指南相结合。 </p><br><p> 关于如何将基于Elasticsearch的全文搜索固定到现有数据库的文章很多。 但是显然没有足够的文章介绍如何进行真正的智能搜索。 </p><br><blockquote> 同时，“智能搜索”一词本身已成为流行语，并不习惯于该地点。 那么，为了被视为聪明的搜索引擎应该做什么？ 最终，这可以描述为给出用户实际需要的结果，即使该结果与请求的文本不完全匹配。 诸如Google和Yandex之类的流行搜索引擎走得更远，不仅找到所需信息，还直接回答用户问题。 </blockquote><p> 好的，我们不会立即做出最后通decision的决定，但是如何使<em>常规的</em>全文本搜索更接近<em>明智的选择</em>呢？ </p><a name="habracut"></a><br><h2 id="elementy-intellektualnosti"> 智力要素 </h2><br><p> 智能搜索-这种情况就是数量可以转化为质量，而许多小的和相当简单的功能可以形成一种魔幻的感觉。 </p><br><ul><li> 纠正用户错误-是错别字，布局错误还是结果数量可疑的请求，但类似于具有更多信息的请求。 </li><li> 对于 <del> 日 </del>  NLP聊天（自然语言处理，不是您想的那样）-如果用户输入<em><strong>了去年的商业报价，那么</strong></em>他是否真的想在所有文档的文本中搜索这些单词，还是仅在去年才真正需要商业报价？ ？ </li><li> 根据先前的查询或常用文档预测输入。 </li><li>结果的呈现是找到的片段的通常亮点，其他信息取决于您要寻找的内容。 由于在上一段中需要商业提案，因此立即显示提案的主题以及它来自哪个组织的做法也许有意义。 </li><li> 轻松钻取-使用其他过滤器，构面来优化搜索查询的能力。 </li></ul><br><h2 id="vvodnaya"> 介绍性 </h2><br><p> 有一个ECM目录，其中包含许多文档。 该文档由一张带有元信息的卡和一个正文组成，正文可以有多个版本。 </p><br><p> 目标是以常规方式为搜索引擎用户快速方便地搜索这些文档中的信息。 </p><br><h2 id="indeksirovanie"> 索引编制 </h2><br><blockquote> 为了寻找合适的东西，您需要首先对其进行索引。 </blockquote><p>  ECM中的文档不是静态的，用户可以修改文本，创建新版本，更改卡中的数据； 新文档不断创建，旧文档有时被删除。 <br> 为了在Elasticsearch中保持最新信息，文档需要不断地重新索引。 幸运的是，ECM已经拥有自己的异步事件队列，因此当您更改文档时，只需将其添加到队列中以进行索引。 </p><br><h3 id="otobrazhenie-dokumentov-ecm-na-dokumenty-elasticsearch"> 将ECM文档映射到Elasticsearch文档 </h3><br><p>  ECM中的文档正文可以具有多个版本。 在Elasticsearch中，这可能被认为是嵌套对象的数组，但是使用它们却变得不便-编写查询变得更加困难，当更改其中一个版本时，您需要重新索引所有内容，同一文档的不同版本无法存储在不同的索引中（为什么需要-在下一节中）。 因此，我们将从一张ECM中将一个文档反规范化为具有相同卡但主体不同的多个Elasticsearch文档。 </p><br><p> 除了卡和主体之外，Elasticsearch文档中还添加了各种服务信息，值得一提： </p><br><ul><li> 有权使用该文档的组和用户的ID列表-用于进行权利搜索； </li><li> 调用文档的次数-用于调整相关性； </li><li> 最后索引的时间。 </li></ul><br><h3 id="sostav-indeksov"> 指数构成 </h3><br><p> 是的，复数索引。 通常，仅当此信息是不可变的并且与某种时间段（例如，日志）相关联时，才使用几个索引来存储在Elasticsearch中含义相似的信息。 然后，每个月/天或更频繁地根据负载强度创建索引。 在我们的情况下，任何文档都可以更改，并且可以将所有内容存储在一个索引中。 </p><br><p> 但是-系统中的文档可以使用不同的语言，并且在Elasticsearch中存储多语言数据会带来两个问题： </p><br><ul><li> 错误的词干。 对于某些单词，将正确找到基数，对于某些单词-错误地（索引中将存在另一个单词），对于某些单词-根本将找不到（索引将被单词形式阻塞）。 对于来自不同语言，具有不同含义的某些单词，依据将是相同的，然后单词的含义将丢失。 连续使用多个茎杆可能会导致对已经计算出的茎杆进行额外的计算。 </li></ul><br><blockquote> 扼杀-寻找单词的基础。 词根不必是单词的词根或其正常形式。 通常，将相关词投射到一个框架中就足够了。 <br> 词法化是词干的一种类型，其中单词的正常（词汇）形式被认为是基础。 </blockquote><br><ul><li> 字频不正确。  ES中的某些相关性确定机制会考虑文档中搜索到的单词的频率（频率越高，相关性越高）和索引中搜索到的单词的频率（频率越高，相关性越低）。 因此，当索引主要是英语文档时，在英语文档中少量传播俄语语音将具有较高的权重，但是值得在索引中混合使用英语和俄语文档，并且权重会降低。 </li></ul><br><p> 当不同的语言使用不同的字符集（俄语-英语文档使用西里尔字母和拉丁字母）时，第一个问题可以解决-语言提取器仅处理“其”字符。 </p><br><p> 为了解决第二个问题，我们使用了每种语言都有单独索引的方法。 </p><br><p> 结合这两种方法，我们获得了语言索引，但仍包含针对不与字符集相交的多种语言的分析器：俄语-英语（以及英语-俄语），波兰语-俄语，德语-俄语，乌克兰语-英语等。 。 </p><br><p> 为了不预先创建所有可能的索引，我们使用了索引模板-Elasticsearch允许您指定一个包含设置和映射的模板，并指定索引名称模式。 当您尝试将文档编入不存在的索引（其名称与模板的一种模式匹配）时，不仅会创建一个新索引，而且还会将来自相应模板的设置和映射应用于该索引。 </p><br><h3 id="struktura-indeksov"> 索引结构 </h3><br><p> 为了建立索引，我们一次（通过多字段）使用两个分析器：默认用于按精确短语搜索，而自定义则用于其他所有内容： </p><br><pre><code class="json hljs"><span class="hljs-string"><span class="hljs-string">"ru_en_analyzer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"lowercase"</span></span>, <span class="hljs-string"><span class="hljs-string">"russian_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"english_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru_en_stopwords"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"char_filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"custom"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tokenizer"</span></span>: <span class="hljs-string"><span class="hljs-string">"standard"</span></span>}</code> </pre> <br><p> 使用小写过滤器，一切都变得清楚了，其余的我将告诉您。 </p><br><p> 过滤器Russian_morphology和english_morphology分别用于俄语和英语文本的形态分析。 它们不是Elasticsearch的一部分，而是作为单独的分析形态插件包含的一部分。 这些lemmatizer将词汇方法与一些启发式方法结合使用，并且比相应语言的内置过滤器更好地工作，MUCH。 </p><br><pre> <code class="json hljs">POST _analyze { <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"russian"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> } &gt;&gt;   </code> </pre> <br><p> 并且： </p><br><pre> <code class="json hljs">POST _analyze { <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru_en_analyzer"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> } &gt;&gt;   </code> </pre> <br><p> 非常好奇的word_delimiter过滤器。 例如，当点后没有空格时，它有助于消除错别字。 我们使用以下配置： </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"catenate_all"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_original"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }</code> </pre> <br><p>  yo_filter允许您忽略E和E之间的区别： </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"mapping"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"mappings"</span></span>: [ <span class="hljs-string"><span class="hljs-string">" =&gt; "</span></span>, <span class="hljs-string"><span class="hljs-string">" =&gt; "</span></span> ] }</code> </pre> <br><p>  ru_en_stopwords过滤器类型stop-我们的停用词词典。 </p><br><h3 id="process-indeksirovaniya"> 索引过程 </h3><br><p> 通常，ECM中的文档主体是Office格式的文件：.docx，.pdf等。 要提取文本，将“摄取附件”插件与以下管道一起使用： </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"document_version"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"processors"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"attachment"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target_field"</span></span>: <span class="hljs-string"><span class="hljs-string">"attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-string"><span class="hljs-string">"content_length"</span></span>, <span class="hljs-string"><span class="hljs-string">"content_type"</span></span>, <span class="hljs-string"><span class="hljs-string">"language"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"indexed_chars"</span></span>: <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"remove"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"script"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"lang"</span></span>: <span class="hljs-string"><span class="hljs-string">"painless"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"params"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"languages"</span></span>: [<span class="hljs-string"><span class="hljs-string">"ru"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"language_delimeter"</span></span>: <span class="hljs-string"><span class="hljs-string">"_"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"remove"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } ] } }</code> </pre> <br><p> 从管道中的异常情况开始，忽略主体不存在的错误（这种情况发生在加密文档中），并根据文本的语言确定目标索引。 后者是用一种轻松的脚本完成的，我将单独介绍其内容，因为 由于JSON限制，它必须写在一行上。 再加上调试困难（建议的方法是到处抛出异常），这完全变成了痛苦的事情。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.languages.contains(ctx.attachment.language)) ctx._index = ctx._index + <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.language_delimeter + ctx.attachment.language; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content = ctx.attachment.content; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content_length != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content_length = ctx.attachment.content_length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content_type != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content_type = ctx.attachment.content_type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.language != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.language = ctx.attachment.language; }</code> </pre> <br><p> 因此，我们总是将文档发送到<em>index_name</em> 。 如果未定义语言或不支持该语言，则文档将位于此索引中，否则它将属于<em>index_name_language</em> 。 </p><br><p> 我们不存储文件的原始正文，但是启用了_source字段，因为 需要部分更新文档并突出显示找到的文档。 </p><br><p> 如果自上次建立索引以来仅卡已更改，则我们使用不带管道的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更新按查询API对其</a>进行更新。 首先，这不会使可能沉重的文档正文从ECM中拖出；其次，它显着加快了Elasticsearch方面的更新-您不必从办公格式中提取文档文本，这是非常耗费资源的。 </p><br><blockquote> 因此，Elasticsearch中根本没有文档的更新，从技术上讲，从索引进行更新时，旧文档被取出，更改并再次完全索引。 </blockquote><p> 但是，如果正文更改，则通常会删除旧文档并从头开始建立索引。 这允许文档从一种语言索引移至另一种语言索引。 </p><br><h2 id="poisk"> 搜寻 </h2><br><p> 为了便于描述，我将给出最终结果的屏幕截图 </p><br><p><img src="https://habrastorage.org/webt/ni/l4/xm/nil4xm-qrg7meikrjbd16mt_ziq.png"></p><br><h3 id="polnotekst"> 全文 </h3><br><p> 我们拥有的主要查询类型是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">简单查询字符串查询</a> ： </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"simple_query_string"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"card.d*.*_text"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.d*.*_text.exact"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name^2"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name.exact^2"</span></span>, <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-string"><span class="hljs-string">"content.exact"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"default_operator"</span></span>: <span class="hljs-string"><span class="hljs-string">"or"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"analyze_wildcard"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"minimum_should_match"</span></span>: <span class="hljs-string"><span class="hljs-string">"-35%"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"quote_field_suffix"</span></span>: <span class="hljs-string"><span class="hljs-string">".exact"</span></span> }</code> </pre> <br><p> 其中<em>.exact</em>是<em>默认</em>解析器索引的字段。 文档名称的重要性是其他字段的两倍。  <code>"default_operator": "or"</code>和<code>"minimum_should_match": "-35%"</code>可让您查找不超过35％的搜索词的文档。 </p><br><h3 id="sinonimy"> 同义字 </h3><br><p> 通常，使用不同的分析器进行索引和搜索，但是它们之间的唯一区别是添加了一个过滤器，以将同义词添加到搜索查询中： </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"search_analyzer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"lowercase"</span></span>, <span class="hljs-string"><span class="hljs-string">"russian_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"english_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"synonym_filter"</span></span>, <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru_en_stopwords"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"char_filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"tokenizer"</span></span>: <span class="hljs-string"><span class="hljs-string">"standard"</span></span> }</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"synonym_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"synonym_graph"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"synonyms_path"</span></span>: <span class="hljs-string"><span class="hljs-string">"synonyms.txt"</span></span> }</code> </pre> <br><h3 id="uchyot-prav"> 会计权 </h3><br><p> 对于基于权限的搜索，主查询嵌入在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Bool Query中</a> ，并添加了过滤器： </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"must"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"simple_query_string"</span></span>: {...} } ], <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"rights"</span></span>: [           ] } } ] }</code> </pre> <br><p> 我们在索引部分中还记得，索引有一个字段，该字段具有对文档拥有权限的用户和组的ID。 如果此字段与传递的数组有交集，则有权限。 </p><br><h3 id="tyuning-relevantnosti"> 相关性调整 </h3><br><p> 默认情况下，Elasticsearch使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BM25</a>算法使用查询和文档文本来评估结果的相关性。 我们决定再考虑三个因素来影响对预期结果和实际结果的符合性评估： </p><br><ul><li> 上次编辑文档的时间-越远，需要此文档的可能性就越小； </li><li> 对该文档的调用次数-越多，则需要该文档的可能性就越大； </li><li><p>  ECM正文版本具有几种可能的状态：开发，运行和不推荐使用。 理所当然的是，表演比其他表演更重要。 </p><br><p> 您可以借助<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">功能得分查询</a>来达到此效果： </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"function_score"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"functions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"gauss"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"modified_date"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">"now"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"1095d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"offset"</span></span>: <span class="hljs-string"><span class="hljs-string">"31d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"decay"</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span> } } }, { <span class="hljs-attr"><span class="hljs-attr">"field_value_factor"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"access_count"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"modifier"</span></span>: <span class="hljs-string"><span class="hljs-string">"log2p"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"term"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"life_stage_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } }, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">1.1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bool"</span></span>: {...} } }</code> </pre> <br><p> 结果，对于ceteris paribus来说，我们得到的结果评级修饰语大约依赖于其最后更改日期X和命中次数Y： </p><br></li></ul><br><p></p><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/wa/wz/td/wawztd9zvlz-fetkplnfrjw8ddy.png"></a> </div><p></p><br><h3 id="vneshniy-intellekt"> 外部情报 </h3><br><p> 对于智能搜索功能的一部分，我们需要从搜索查询中提取各种<em>事实</em> ：日期及其应用（创建，修改，批准等），组织名称，所搜索文档的类型等。 </p><br><p> 还希望将请求分类为特定类别，例如，按组织，员工，法规等的文档。 </p><br><p> 这两个操作由ECM智能模块<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DIRECTUM Ario执行</a> 。 </p><br><h3 id="process-umnogo-poiska"> 智能搜索过程 </h3><br><p> 现在是时候更详细地考虑哪些机制是实施情报要素了。 </p><br><h4 id="ispravlenie-oshibok-polzovatelya"> 用户错误纠正 </h4><br><p> 布局的正确性是根据Trigram语言模型确定的-对于一条线，它会计算在英语和俄语文本中满足其三个字符序列的可能性。 如果认为当前布局不太可能，则首先显示具有正确布局的提示： </p><br><p><img src="https://habrastorage.org/webt/ek/ow/c5/ekowc5ikjiwx1xe87b5wewhoohm.png"></p><br><p> 其次，以正确的布局执行搜索的其他步骤： </p><br><p><img src="https://habrastorage.org/webt/ug/dr/tc/ugdrtchejvx024datttkc_zcxxw.png"></p><br><p> 而且，如果使用正确的布局找不到任何内容，则搜索将从原始行开始。 </p><br><p> 拼写校正是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">短语提示</a>器实现的。 它有一个问题-如果您同时对多个索引执行查询，则建议可能不会返回任何内容，而如果仅对一个索引执行，则会产生结果。  <em>可以通过</em>将置信度设置为0来解决此问题，但随后建议建议以正常形式替换单词。 同意，当您搜索“字母<strong>a</strong> ”以得到答案时会很奇怪： <em>也许您正在寻找有关的信？</em> </p><br><p> 可以通过在请求中使用两个提示来规避此问题： </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"content_suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"phrase"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"collate"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {         {{suggestion}} } }, } }, <span class="hljs-string"><span class="hljs-string">"check_suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"phrase"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"collate"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {         {{suggestion}} - ({{source_query}}) }, <span class="hljs-string"><span class="hljs-string">"params"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source_query"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } }, } } }</code> </pre> <br><p> 使用的常用参数 </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"confidence"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-string"><span class="hljs-string">"max_errors"</span></span>: <span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span class="hljs-string"><span class="hljs-string">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p> 如果前一个返回正确的结果，但第二个没有返回结果，则该结果是原始字符串本身，可能带有其他形式的单词，因此无需显示提示。 如果仍然需要提示，则原始搜索短语将与提示合并。 通过仅替换更正的单词和拼写检查程序（使用Hunspell）认为不正确的单词，可以实现此目的。 </p><br><p> 如果对源字符串的搜索返回了0个结果，则将其替换为通过合并获得的字符串，然后再次执行搜索： </p><br><p><img src="https://habrastorage.org/webt/up/r3/wx/upr3wxky4mkbeyy3exjocbwzocy.png"></p><br><p> 否则，返回的提示字符串仅作为搜索提示返回： </p><br><p><img src="https://habrastorage.org/webt/qv/ts/4t/qvts4tauspo9yspwy_itbzcdttq.png"></p><br><h4 id="klassifikaciya-zaprosov-i-izvlechenie-faktov"> 查询分类和事实提取 </h4><br><p> 如前所述，我们使用DIRECTUM Ario，即文本分类服务和事实提取服务。 为此，我们为分析师提供了匿名搜索查询以及我们感兴趣的事实列表。 基于查询和对系统中包含哪些文档的了解，分析人员确定了几个类别，并训练了分类服务以根据查询文本确定类别。 根据结果​​类别和事实列表，我们制定了使用这些事实的规则。 例如，在“ <strong>每个人</strong> ”类别中<em><strong>，最后一年</strong></em>的短语被视为文档的创建日期，而在“ <strong>按组织</strong> ”类别中，该短语被视为注册日期。 同时， <em><strong>去年创建的</strong></em>类别应在创建日期之内。 </p><br><p> 从搜索方面来看，他们进行了配置，在其中注册了类别，将哪些事实应用于哪一个方面过滤器。 </p><br><h4 id="avtodopolnenie-vvoda"> 输入完成 </h4><br><p> 除了已经提到的布局更正之外，用户和公共文档的先前搜索属于自动完成。 </p><br><p><img src="https://habrastorage.org/webt/zc/52/yo/zc52yohihrkkrnny6ekla80-mro.png"></p><br><p> 它们是使用另一种类型的“建议者”- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">完成建议者来实现的</a> ，但是每个人都有自己的细微差别。 </p><br><h5 id="avtodopolnenie-istoriya-poiskov"> 自动补全：搜索记录 </h5><br><p> 与搜索引擎相比，ECM中的用户数量要少得多，并且可以为其分配足够的常见查询 <del> 为什么列宁蘑菇 </del> 不可能的。 出于隐私考虑，连续显示所有内容也不值得。 通常的完成建议器只能在索引中搜索整个文档集，但是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上下文建议器</a>可以帮助您-一种为每个提示设置上下文并通过这些上下文进行过滤的方法。 如果将用户名用作上下文，则只有他的历史记录可以显示给所有人。 </p><br><p> 您还需要给用户机会删除他感到羞耻的提示。 作为删除键，我们使用了用户名和工具提示文本。 结果，对于带有提示的索引，我们得到了一个稍微重复的映射： </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"mappings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"document"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"keyword"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"completion"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"simple"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_separators"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_position_increments"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max_input_length"</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-attr"><span class="hljs-attr">"contexts"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"CATEGORY"</span></span> } ] }, <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"keyword"</span></span> } } } }</code> </pre> <br><p> 每个新提示的权重都设置为1，并且每次使用非常简单的<code>ctx._source.suggest.weight++</code>脚本使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Update By Query API</a>重新输入提示时，权重都会增加。 </p><br><h5 id="avtodopolnenie-dokumenty"> 自动完成：文档 </h5><br><p> 但是可能会有很多文件以及权利的可能组合。 因此，与此相反，我们决定在自动完成时不按权限进行过滤，而只对公共文档编制索引。 是的，您不需要从该索引中删除单个提示。 似乎在所有方面的实现都比上一个更容易，即使不是两点： </p><br><p> 第一个-完成建议程序仅支持前缀搜索，客户喜欢为所有内容分配商品编号，还有一些<code>.01.01   </code>键入查询时<code>.01.01   </code> 。 在这里，连同全名一样，您还可以索引从其派生的n-gram： </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"extension"</span></span>: <span class="hljs-string"><span class="hljs-string">"pdf"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">".01.01   "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"suggest"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">70</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">90</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">".01.01   "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } ] }</code> </pre> <br><p> 对于故事来说，这并不是很关键，但是如果同一位用户再次搜索某内容，则输入的内容大致相同。  <em>大概吧</em> 。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bi/rc/dv/bircdvzu2hvcblxhrryvauzajf0.png"></div><br><p> 第二个-默认情况下，所有提示都是相等的，但是我们希望使其中的一些更相等，并且最好使它们与搜索结果的排名一致。 为此，请大致重复使用“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">功能分数查询”中</a>的gauss和field_value_factor函数。 </p><br><p> 事实证明，这是一条管道： </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"dir_public_documents_pipeline"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"processors"</span></span>: [ ... { <span class="hljs-attr"><span class="hljs-attr">"set"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"terms_array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{name}}"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"split"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"terms_array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"separator"</span></span>: <span class="hljs-string"><span class="hljs-string">"\\s+|$"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"script"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> } } ] } }</code> </pre> <br><p> 使用以下脚本： </p><br><pre> <code class="cs hljs">Date modified = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.modified_date != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) modified = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">'dd.MM.yyyy'</span></span>).parse(ctx.modified_date); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> dayCount = (System.currentTimeMillis() - modified.getTime())/(<span class="hljs-number"><span class="hljs-number">1000</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> score = Math.exp((<span class="hljs-number"><span class="hljs-number">-0.7</span></span>*Math.max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dayCount - <span class="hljs-number"><span class="hljs-number">31</span></span>))/<span class="hljs-number"><span class="hljs-number">1095</span></span>) * Math.log10(ctx.access_count + <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = ctx.terms_array.length; ctx.suggest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); ctx.suggest.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([ <span class="hljs-string"><span class="hljs-string">'input'</span></span>: ctx.terms_array[count - <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'weight'</span></span>: Math.round(score * (<span class="hljs-number"><span class="hljs-number">255</span></span> - count + <span class="hljs-number"><span class="hljs-number">1</span></span>)) ]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = count - <span class="hljs-number"><span class="hljs-number">2</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ; --i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.terms_array[i].trim() != <span class="hljs-string"><span class="hljs-string">""</span></span>) { ctx.suggest.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([ <span class="hljs-string"><span class="hljs-string">"input"</span></span>: ctx.terms_array[i] + <span class="hljs-string"><span class="hljs-string">" "</span></span> + ctx.suggest[ctx.suggest.length - <span class="hljs-number"><span class="hljs-number">1</span></span>].input, <span class="hljs-string"><span class="hljs-string">"weight"</span></span>: Math.round(score * (<span class="hljs-number"><span class="hljs-number">255</span></span> - i))]); } } ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'terms_array'</span></span>); ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'access_count'</span></span>); ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'modified_date'</span></span>);</code> </pre> <br><p> 为什么不花很多钱去麻烦管道，而不用更方便的语言编写管道？ 因为现在，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Reindex API</a> ，您可以仅用一条命令<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">就将</a>搜索索引的内容<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">覆盖</a>到提示索引中（当然，只需指定必要的字段即可）。 </p><br><p> 真正需要的公共文档的组成通常不会更新，因此可以手动启动此命令。 </p><br><h3 id="otobrazhenie-rezultatov"> 显示结果 </h3><br><h4 id="kategorii"> 分类目录 </h4><br><p> 类别确定可用的构面以及摘要的外观。 它可以通过<em>外部情报</em>自动检测，也可以在搜索栏上方手动选择。 </p><br><h4 id="fasety"> 刻面 </h4><br><p> 对于每个人的行为而言，方面都是如此直观的事情，但是，行为由非常平凡的规则来描述。 以下是其中一些： </p><br><ol><li><p> 构面值取决于搜索结果，但是，搜索结果取决于所选构面。 如何避免递归？ </p><br></li><li><p> 在一个构面内选择值不会影响此构面的其他值，但会在其他构面中影响值： </p><br></li></ol><br><p><img src="https://habrastorage.org/webt/60/ei/g6/60eig601ltskcwvcesh5zno8crc.png"></p><br><ol><li> 用户选择的构面值不应消失，即使另一个构面中的选择将其<em>消灭</em>为0或它们不再位于顶部也是如此： </li></ol><br><p><img src="https://habrastorage.org/webt/mu/6u/e-/mu6ue-ybxh3sa9h6ymkj1idn_ti.png"></p><br><p> 在弹性方面，小面是通过聚集机制实现的，但是为了遵守所描述的规则，这些聚集必须相互投资并相互过滤。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/jt/zu/zdjtzudyw9iei8x-tjarja-a5tm.jpeg"></div><br><p> 考虑负责此操作的请求片段： </p><br><div class="spoiler">  <b class="spoiler_title">代码太大</b> <div class="spoiler_text"><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"post_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"must"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ] } }, { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ] } } ] } }, <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} <span class="hljs-string"><span class="hljs-string">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"card.author_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id_selected"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"card.author_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } } }, ... <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"editor_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"editor_value_id_selected"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"editor_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } } }, ... } }</code> </pre> </div></div><br><p> 这是什么： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">post_filter</a>允许<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您</a>对已经完成的查询的结果施加附加条件，并且不影响聚合的结果。 同样的递归间隙。 包括所有构面的所有选定值。 </li><li> 顶级聚合，在示例<em>card.author_value_id</em>和<em>editor_value_id中</em> 。 每个都有： <br><ul><li> 按除您自己之外的所有其他方面的值过滤； </li><li> 选定构面值的嵌套聚合- <em>防止ni灭</em> ; </li><li> 其他构面值的嵌套聚合。 我们显示前10名，并请求前11名-确定是否显示“ <strong>显示全部”</strong>按钮。 </li></ul></li></ul><br><h4 id="snippety"> 片段 </h4><br><p> 根据所选类别的不同，代码段的外观可能会有所不同，例如，在类别中进行搜索时，同一文档 </p><br><p>  <strong>全部</strong> ： </p><br><p><img src="https://habrastorage.org/webt/ka/_b/ia/ka_biaaygfgbsk2msyfhu-bnkse.png"></p><br><p> 和<strong>员工</strong> ： </p><br><p><img src="https://habrastorage.org/webt/5i/po/k_/5ipok_qgkc9170ucyidespnnitc.png"></p><br><p> 还是记得，我们想看看商业报价的主题以及它来自谁？ </p><br><p><img src="https://habrastorage.org/webt/-i/7z/g7/-i7zg7dwh7kbs9e9_2yk3fnxc6k.png"></p><br><p> 为了不从弹性卡上拖出整个卡（这会减慢搜索速度），使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">源过滤</a> ： </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"_source"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"includes"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"id"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.card_type_value_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.life_stage_value_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"extension"</span></span>, ... ] }, <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} ... }</code> </pre> <br><p> 为了突出显示文档文本中的单词，使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">快速矢量荧光笔</a> -为大型文本生成最合适的代码片段，并为名称- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">统一荧光笔</a> -作为对资源和索引结构的最低要求： </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"highlight"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"pre_tags"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"&lt;strong&gt;"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"post_tags"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"&lt;/strong&gt;"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"encoder"</span></span>: <span class="hljs-string"><span class="hljs-string">"html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.name"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"number_of_fragments"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"content"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fragment_size"</span></span>: <span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-attr"><span class="hljs-attr">"number_of_fragments"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"fvh"</span></span> } } },</code> </pre> <br><p> 在这种情况下，名称将全部突出显示，并且从文本中我们可以得到最多300个字符的3个片段。  Fast Vector荧光笔返回的文本通过权宜算法进一步压缩以获得最小化的代码段状态。 </p><br><h3 id="kollaps"> 倒塌 </h3><br><p> 从历史上看，此ECM的用户习惯于搜索将<em>文档</em>返回<em>给</em>他们，但实际上Elasticsearch在<em>文档的各个版本中进行</em>搜索。 可能会发现在同一查询中会找到几个几乎相同的版本。 这会使结果混乱并使用户感到困惑。 幸运的是，可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Field Collapsing</a>机制避免这种行为-某些轻量级的聚合已经可以在完成的结果上使用（在这种情况下，它类似于post_filter， <em>两个拐杖是一对</em> ）。  <em>崩溃</em>将导致最相关的崩溃对象。 </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} ... <span class="hljs-string"><span class="hljs-string">"collapse"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"id"</span></span> } }</code> </pre> <br><p> 不幸的是，崩溃具有许多令人不愉快的影响，例如，搜索结果的各种数值特征继续返回，就好像没有崩溃一样。 也就是说，结果的数量，构面值的数量-都会<em>有些</em>许不正确，但是用户通常不会注意到这一点，就像疲倦的读者一样，后者以前不太可能阅读过此建议。 </p><br><p> 结束了。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN460263/">https://habr.com/ru/post/zh-CN460263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN460253/index.html">提高语音助手技能的10个理由</a></li>
<li><a href="../zh-CN460255/index.html">Node.js上的后门程序：为什么，为什么以及如何工作</a></li>
<li><a href="../zh-CN460257/index.html">世界您好！ 深入浸入终端</a></li>
<li><a href="../zh-CN460259/index.html">什么是UI和UX设计？ 有什么共同点和不同点？</a></li>
<li><a href="../zh-CN460261/index.html">亚马逊：电子商务成功25年</a></li>
<li><a href="../zh-CN460265/index.html">创建一个Xcode项目模板</a></li>
<li><a href="../zh-CN460273/index.html">Apple Pay中最小的授权</a></li>
<li><a href="../zh-CN460275/index.html">您为什么不需要完美的解决方案</a></li>
<li><a href="../zh-CN460279/index.html">100亿美元合同：谁将为五角大楼应对云</a></li>
<li><a href="../zh-CN460281/index.html">UX Writer如何帮助改善产品</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>