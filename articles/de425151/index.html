<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏻 ⛅️ 🕒 Lauschen Sie einem Telegramm-Chat mit Ihrem Client 👨🏻‍🔬 👩🏾‍🤝‍👩🏻 ☕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich wollte einmal Nachrichten von einem der Telegramm-Chats auf meiner Festplatte speichern (ohne einen normalen Client zu starten). Ich werde meine M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lauschen Sie einem Telegramm-Chat mit Ihrem Client</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425151/"><p>  Ich wollte einmal Nachrichten von einem der Telegramm-Chats auf meiner Festplatte speichern (ohne einen normalen Client zu starten).  Ich werde meine Motive nicht preisgeben, aber diese Gelegenheit erschien mir notwendig und nützlich. </p><br><p>  Dafür gibt es Bots im Telegramm.  Auf Habré gibt es mehrere Artikel, die Bots gewidmet sind, zum Beispiel: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chat-Assistent der Site</a> ". </p><br><p>  Mit dem Bot können Sie Nachrichten lesen und senden, Sie benötigen kein Telefon, um einen Bot zu registrieren, und die Anzahl der Bots kann beliebig sein.  Der Name des Bots enthält jedoch das Wort "Bot", was zu unnötigen Fragen des Chat-Hosts führen kann. </p><br><p>  Aber wie sie sagen, ist eine richtig gestellte Frage die halbe Antwort. </p><a name="habracut"></a><br><p>  Es stellt sich heraus, dass es zusätzlich zur "Telegramm-Bot-API" auch die "Telegramm-Client-API" gibt, d.h.  API zum Erstellen eigener Clients. </p><br><p>  Der Client kann auch Nachrichten senden und lesen, jedoch nur von einem registrierten (an das Telefon gebundenen) Benutzer, was nur zu mir passt (ich bin bereits im Chat registriert). </p><br><p> Die Telegramm-Website enthält eine Liste von APIs für verschiedene Plattformen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://telegram.org/apps#source-code</a> </p><br><p>  Die am einfachsten zu verwendende Bibliothek stellte sich jedoch als Python heraus: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pure Python 3 MTProto API-Telegramm-Clientbibliothek mit dem</a> Namen <strong>"telethon"</strong> </p><br><p>  Nur hier liegt das Problem.  Ich kenne Python nicht.  Es gibt Grund, Sie kennenzulernen. <br>  Laut Teleton-Handbuch ist die Installation sehr einfach.  Führen Sie einfach den Befehl in der Befehlszeile aus: </p><br><pre><code class="bash hljs">pip3 install telethon</code> </pre> <br><p>  Fallstricke, die ich während der Installation kennengelernt habe: </p><br><ul><li>  pip3 ist nicht installiert (Installationsprogramm für Python). </li></ul><br><p>  sudo apt-get -y installiere python3-pip </p><br><ul><li>  Die Bibliothek funktioniert nur mit Python-Versionen&gt; 3.5.  Möglicherweise müssen Sie es aktualisieren. </li></ul><br><p>  Alles wurde eingerichtet.  Scrollen Sie weiter in readme.txt. </p><br><p>  Der nächste Punkt ist die Erstellung eines Telegrammclients ... Wie schon?  Ja, alles ist einfach.  Richtig, zuerst müssen Sie sich als Schöpfer des Kunden registrieren. </p><br><p>  Wir gehen zur Telegramm-Website: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://my.telegram.org</a> <br>  Wir geben das Telefon ein und warten auf den Bestätigungscode auf dem nativen Client des Telegramms.  Es ist ziemlich lang (12 Zeichen) und für die Eingabe unpraktisch. </p><br><p>  Wir gehen zum Punkt " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API</a> ".  Wir suchen nach der "Telegramm-API" und gehen zu "Erstellen einer Anwendung" ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://my.telegram.org/apps</a> ). </p><br><p>  Füllen Sie die Felder <strong>App-Titel</strong> und <strong>Kurzname aus</strong> , klicken Sie auf <strong>„Anwendung erstellen“</strong> und merken Sie sich zwei Variablen: <strong>api_id</strong> und <strong>api_hash</strong> . </p><br><p>  Es ist Zeit, einen Kunden zu machen. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telethon <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TelegramClient, sync #  api_id  api_hash api_id = <span class="hljs-number"><span class="hljs-number">12345</span></span> api_hash = <span class="hljs-string"><span class="hljs-string">'0123456789abcdef0123456789abcdef'</span></span> client = TelegramClient(<span class="hljs-string"><span class="hljs-string">'session_name'</span></span>, api_id, api_hash) client.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>()</code> </pre> <br><p>  Sitzungsname - Sie können einen beliebigen Namen einfügen.  Sie werden aufgefordert, das Telefon einzugeben, und es wird ein Bestätigungscode gesendet.  Danach arbeitet der Client, ohne das Telefon anzurufen (bis Sie den Sitzungsnamen ändern).  Die Datei <strong>session_name.session</strong> wird neben Ihrem Programm <strong>angezeigt</strong> . </p><br><p>  Wenn keine Fehler vorliegen, ist der Client bereit.  Erst jetzt wird nichts angezeigt.  Versuchen wir, nützliche Informationen zu erhalten. </p><br><p>  Lerne ein wenig über dich selbst: </p><br><pre> <code class="python hljs">print(client.get_me().stringify())</code> </pre> <br><p>  Das Ergebnis wird in folgender Form angegeben: </p><br><pre> <code class="python hljs">User( photo=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, last_name=<span class="hljs-string"><span class="hljs-string">'Pupkin'</span></span>, first_name=<span class="hljs-string"><span class="hljs-string">'Vasya'</span></span>, id=<span class="hljs-number"><span class="hljs-number">123456789</span></span>, phone=<span class="hljs-string"><span class="hljs-string">'79041234567'</span></span>, .... - - ... )</code> </pre> <br><p>  Wir können eine Nachricht von uns selbst senden: </p><br><pre> <code class="python hljs">client.send_message(<span class="hljs-string"><span class="hljs-string">'username'</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello! Talking to you from Telethon'</span></span>)</code> </pre> <br><p>  Sie können und ein Bild </p><br><pre> <code class="python hljs">client.send_file(<span class="hljs-string"><span class="hljs-string">'username'</span></span>, <span class="hljs-string"><span class="hljs-string">'/home/myself/Pictures/holidays.jpg'</span></span>)</code> </pre> <br><p>  Wie andere mich sehen: </p><br><pre> <code class="python hljs">client.download_profile_photo(<span class="hljs-string"><span class="hljs-string">'me'</span></span>)</code> </pre> <br><p>  Wir schauen uns an, welche Chats wir abonniert haben: </p><br><pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span> all chats name <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> dialog <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> client.iter_dialogs(): <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(dialog.<span class="hljs-built_in"><span class="hljs-built_in">title</span></span>)</code> </pre> <br><p>  Wir lesen alle Chat-Nachrichten "Chat-Name" (sorgfältig kann es viele Nachrichten geben) </p><br><pre> <code class="python hljs">messages = client.get_entity(<span class="hljs-string"><span class="hljs-string">'chat_name'</span></span>) print(messages)</code> </pre> <br><p>  Alle Chat-Benutzer anzeigen </p><br><pre> <code class="python hljs">participants = client.get_participants(<span class="hljs-string"><span class="hljs-string">'chat_name'</span></span>) print(participants)</code> </pre> <br><p>  Gönnen Sie sich? <br>  Tatsächlich tun wir jetzt das, wofür wir alle damit begonnen haben ... </p><br><p>  Wir brauchen ein Programm, das neue Nachrichten in einem bestimmten Kanal überwacht. </p><br><p>  Um zu verhindern, dass der Client die Arbeit beendet, fügen wir nach client.start () die folgende Zeile ein: </p><br><pre> <code class="python hljs">client.run_until_disconnected()</code> </pre> <br><p>  Dieses Konstrukt (eingefügt vor client.start ()) zeigt nur neue Nachrichten an: </p><br><pre> <code class="hljs mel">@client.on(events.NewMessage(chats=(<span class="hljs-string"><span class="hljs-string">'chat_name'</span></span>))) async def normal_handler(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>): # <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.message) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.message.to_dict()[<span class="hljs-string"><span class="hljs-string">'message'</span></span>])</code> </pre> <br><p>  Lass es uns herausfinden. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@client.on(events.NewMessage(chats=('chat_name')))</span></span></code> </pre> <br><p>  Erstellt ein Ereignis, das ausgelöst wird, wenn eine neue Nachricht angezeigt wird </p><br><pre> <code class="python hljs"> print(event.message)</code> </pre> <br><p>  zeigt eine Nachricht in dieser Form an: </p><br><pre> <code class="python hljs">Message(edit_date=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, views=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, reply_markup=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, fwd_from=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, id=<span class="hljs-number"><span class="hljs-number">187</span></span>, entities=[], post=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, mentioned=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, via_bot_id=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, media_unread=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, out=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, media=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, date=datetime.datetime(<span class="hljs-number"><span class="hljs-number">2018</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">26</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>, tzinfo=datetime.timezone.utc), to_id=PeerChannel(channel_id=<span class="hljs-number"><span class="hljs-number">123456789</span></span>), reply_to_msg_id=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, from_id=<span class="hljs-number"><span class="hljs-number">123456789</span></span>, silent=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, grouped_id=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, post_author=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, message=<span class="hljs-string"><span class="hljs-string">'hello telegram'</span></span>)</code> </pre> <br><p>  Von all dem brauchen wir ein Feld: "message = 'Hallo Telegramm'": </p><br><pre> <code class="python hljs"> print(event.message.to_dict()[<span class="hljs-string"><span class="hljs-string">'message'</span></span>])</code> </pre> <br><p>  Die Nachricht wurde empfangen, aber von wem es ist, ist nicht klar, weil  Nur Benutzer-ID pro Nachricht.  Um die ID und den Benutzernamen abzugleichen, laden Sie alle Chat-Benutzer herunter und fügen Sie sie in der Form d [id] = "Vorname Nachname" in das Wörterbuch (Hash) ein. </p><br><pre> <code class="hljs axapta">participants = <span class="hljs-keyword"><span class="hljs-keyword">client</span></span>.get_participants(<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>) users={} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> partic in <span class="hljs-keyword"><span class="hljs-keyword">client</span></span>.iter_participants(<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>): lastname=<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> partic.last_name: lastname=partic.last_name users[partic.id]=partic.first_name+<span class="hljs-string"><span class="hljs-string">" "</span></span>+lastname</code> </pre> <br><p>  Jetzt können wir herausfinden, wer die Nachricht gesendet hat: </p><br><pre> <code class="hljs cs">s_user_id=<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.message.to_dict()[<span class="hljs-string"><span class="hljs-string">'from_id'</span></span>] user_id=<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(s_user_id) user=d.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(user_id)</code> </pre> <br><p>  Grundsätzlich können Sie den Benutzernamen direkt aus dem Telegramm abrufen. Wenn jedoch nur wenige Benutzer vorhanden sind, ist dies mit einem Wörterbuch einfacher. </p><br><p>  Das Versanddatum erhalten wir aus der Nachricht: </p><br><pre> <code class="python hljs">mess_date=event.message.to_dict()[<span class="hljs-string"><span class="hljs-string">'date'</span></span>]</code> </pre> <br><p>  Alles, alle Daten, die wir haben.  Es bleibt, sie in eine Datei zu schreiben. <br>  Öffnen Sie dazu zunächst die Datei zum Schreiben: </p><br><pre> <code class="python hljs">f=open(<span class="hljs-string"><span class="hljs-string">'messages_from_chat'</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>)</code> </pre> <br><p>  Und schreibe die Nachricht: </p><br><pre> <code class="hljs perl">f.write(mess_date.strftime(<span class="hljs-string"><span class="hljs-string">"%d-%m-%Y %H:%M"</span></span>)+<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) f.write(user+<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) f.write(user_mess+<span class="hljs-string"><span class="hljs-string">"\n\n"</span></span>) f.flush()</code> </pre> <br><p>  Das ist alles!  Alles was ich brauchte, macht das Programm.  Das Dienstprogramm ist natürlich feucht, aber es erfüllt seine Aufgabe. </p><br><p>  Python war nicht so kompliziert <strike>wie es gemalt ist</strike> , zumal die Beschreibung verschiedener Bibliotheken im Internet vollständig ist.  Um ein paar weitere Dienstprogramme zu schreiben und sich daran zu gewöhnen, können Sie es als Skriptsprache anstelle von Bash verwenden. </p><br><div class="spoiler">  <b class="spoiler_title">Der gesamte Text des Dienstprogramms:</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> telethon <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TelegramClient, sync, events api_id = <span class="hljs-number"><span class="hljs-number">12345</span></span> api_hash = <span class="hljs-string"><span class="hljs-string">'0123456789abcdef0123456789abcdef'</span></span> client = TelegramClient(<span class="hljs-string"><span class="hljs-string">'session_name'</span></span>, api_id, api_hash) @client.<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(events.NewMessage(chats=(<span class="hljs-string"><span class="hljs-string">'chat_name'</span></span>))) async def normal_handler(event): # print(event.message) user_mess=event.message.to_dict()[<span class="hljs-string"><span class="hljs-string">'message'</span></span>] s_user_id=event.message.to_dict()[<span class="hljs-string"><span class="hljs-string">'from_id'</span></span>] user_id=<span class="hljs-type"><span class="hljs-type">int</span></span>(s_user_id) <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>=d.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(user_id) mess_date=event.message.to_dict()[<span class="hljs-string"><span class="hljs-string">'date'</span></span>] f.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(mess_date.strftime("%d-%m-%Y %H:%M")+"\n") f.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>+"\n") f.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(user_mess+"\n\n") f.flush() client.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>=<span class="hljs-string"><span class="hljs-string">'group_name'</span></span> participants = client.get_participants(<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>) users={} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> partic <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> client.iter_participants(<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>): lastname="" <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> partic.last_name: lastname=partic.last_name users[partic.id]=partic.first_name+" "+lastname f=<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">'messages_from_chat'</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>) client.run_until_disconnected() f.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>()</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollständige Beschreibung der Bibliothek</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425151/">https://habr.com/ru/post/de425151/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425139/index.html">Popstars unter der Linse künstlicher Intelligenz</a></li>
<li><a href="../de425141/index.html">"Guido gegenüberstehen, was du ihm sagst" oder Python-Gespräche mit Bobuk</a></li>
<li><a href="../de425143/index.html">Die Higher School of Economics lehnt Vorlesungen zugunsten von Online-Kursen ab</a></li>
<li><a href="../de425145/index.html">So ein außergewöhnlicher Go</a></li>
<li><a href="../de425149/index.html">Zwischen Himmel und Erde</a></li>
<li><a href="../de425153/index.html">Die drei beliebtesten Missverständnisse in Bezug auf Emotionen in Affective Computing</a></li>
<li><a href="../de425155/index.html">Faszinierende Kryptographie oder Forschung zur reversiblen Verschlüsselung in PHP</a></li>
<li><a href="../de425157/index.html">Treffen Sie die .Net-Community auf CLRium # 4 + online. Wohin CoreCLR und C # gehen. Jeder ist eingeladen</a></li>
<li><a href="../de425159/index.html">OFFZONE 2018 begrüßt Rekruten</a></li>
<li><a href="../de425161/index.html">Übersicht über Free 2D CAD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>