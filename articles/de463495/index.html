<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚁 🕛 👨‍✈️ Laravel-Caching: Grundlagen sowie Tipps und Tricks 👨‍👦‍👦 👩🏻‍🌾 😾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit der Caching-Technik können Sie skalierbarere Anwendungen erstellen und die Ergebnisse einiger Abfragen in einem schnellen In-Memory-Speicher speic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Laravel-Caching: Grundlagen sowie Tipps und Tricks</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463495/"><p>  Mit der Caching-Technik können Sie skalierbarere Anwendungen erstellen und die Ergebnisse einiger Abfragen in einem schnellen In-Memory-Speicher speichern.  Falsch implementiertes Caching kann jedoch den Eindruck des Benutzers von Ihrer Anwendung erheblich beeinträchtigen.  Dieser Artikel enthält einige grundlegende Konzepte zum Caching, verschiedene Regeln und Tabus, die ich aus mehreren früheren Projekten gelernt habe. </p><br><h2 id="ne-ispolzuyte-keshirovanie">  Verwenden Sie kein Caching. </h2><br><p>  Ist Ihr Projekt schnell und hat keine Leistungsprobleme? <br>  Vergessen Sie das Caching.  Ernsthaft :) </p><br><p>  Dies wird die Lesevorgänge aus der Datenbank ohne Vorteile erheblich verkomplizieren. </p><br><p> Es stimmt, Mohamed Said am Anfang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">dieses Artikels</a> führt einige Berechnungen durch und beweist, dass in einigen Fällen durch die Optimierung der Anwendung für Millisekunden eine Menge Geld in Ihrem AWS-Konto gespart werden kann.  Wenn die projizierten Einsparungen für Ihr Projekt mehr als 1,86 US-Dollar betragen, ist Caching möglicherweise eine gute Idee. </p><a name="habracut"></a><br><h2 id="kak-eto-rabotaet">  Wie funktioniert es </h2><br><p> Wenn eine Anwendung einige Daten aus der Datenbank <code>'post_' . $id</code> möchte, z. B. die Post-Entität anhand ihrer ID, generiert sie einen eindeutigen Caching-Schlüssel für diesen Fall ( <code>'post_' . $id</code> ist durchaus geeignet) und versucht, den Wert anhand dieses Schlüssels im schnellen Schlüsselwertspeicher (memcache, Redis oder eine andere).  Wenn der Wert vorhanden ist, wird er von der Anwendung verwendet.  Wenn nicht, nimmt es es aus der Datenbank und speichert es mit diesem Schlüssel für die zukünftige Verwendung im Cache. </p><br><p><img src="https://habrastorage.org/webt/vd/9i/kj/vd9ikjg-gji5lauz1atmq9bkdpq.png"></p><br><p>  Es ist keine gute Idee, diesen Wert für immer im Cache zu belassen, da diese Post-Entität aktualisiert werden kann, die Anwendung jedoch immer den alten zwischengespeicherten Wert erhält. <br>  Daher fragen Caching-Funktionen normalerweise, wann dieser Wert gespeichert werden soll. </p><br><p>  Nach Ablauf dieser Zeit „vergessen“ Memcache oder Redis dies und die Anwendung übernimmt einen neuen Wert aus der Datenbank. </p><br><p>  Ein Beispiel: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ $key = <span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id; $post = \Cache::get($key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($post === <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { $post = Post::findOrFail($id); \Cache::put($key, $post, <span class="hljs-number"><span class="hljs-number">900</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post; }</code> </pre> <br><p>  Hier habe ich die Post-Entität für 15 Minuten in den Cache gestellt (seit Version 5.8 verwendet Laravel Sekunden in diesem Parameter, bevor es Minuten gab).  Die <code>Cache</code> Fassade verfügt auch über eine praktische <code>remember</code> für diesen Fall.  Dieser Code macht genau das Gleiche wie der vorherige: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::findOrFail($id); }); }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">In der</a> Laravel-Dokumentation finden Sie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Cache-Kapitel, in dem</a> erläutert wird, wie Sie die erforderlichen Treiber für Ihre Anwendung und die Hauptfunktionen installieren. </p><br><h2 id="dannye-v-keshe">  Zwischengespeicherte Daten </h2><br><p>  Alle Standard-Laravel-Treiber speichern Daten als Zeichenfolgen.  Wenn Sie aufgefordert werden, eine Instanz des Eloquent-Modells zwischenzuspeichern, wird die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">serialize</a> verwendet, um die Zeichenfolge vom Objekt abzurufen.  Die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">unserialize</a> stellt den Status eines Objekts wieder her, wenn es aus dem Cache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">abgerufen wird</a> . </p><br><p>  Fast alle Daten können zwischengespeichert werden.  Zahlen, Zeichenfolgen, Arrays, Objekte (wenn sie korrekt serialisiert werden können, lesen Sie die Funktionsbeschreibungen unter den vorherigen Links). </p><br><p>  Eloquente Entitäten und Sammlungen können einfach zwischengespeichert werden und sind die beliebtesten Werte im Laravel-Anwendungscache.  Die Verwendung anderer Typen ist jedoch ebenfalls weit verbreitet.  Die <code>Cache::increment</code> Methode ist beliebt für die Implementierung verschiedener Zähler.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Atomic Locks sind auch</a> sehr nützlich, wenn Entwickler unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Rennbedingungen</a> kämpfen. </p><br><h2 id="chto-keshirovat">  Was soll zwischengespeichert werden? </h2><br><p>  Die ersten Kandidaten für das Caching sind Anforderungen, die sehr oft ausgeführt werden, aber ihr Ausführungsplan ist nicht der einfachste.  Das beste Beispiel sind die Top 5 Artikel auf der Hauptseite oder die neuesten Nachrichten.  Das Zwischenspeichern solcher Werte kann die Leistung der Hauptseite erheblich verbessern. </p><br><p>  Normalerweise ist das Abrufen von Entitäten anhand der ID mithilfe von <code>Model::find($id)</code> sehr schnell. Wenn diese Tabelle jedoch stark mit zahlreichen Aktualisierungs-, Einfüge- und Löschabfragen belastet ist, bietet die Reduzierung der Anzahl ausgewählter Abfragen eine gute Frist für die Datenbank.  Entitäten mit <code>hasMany</code> Beziehungen, die jedes Mal geladen werden, sind ebenfalls gute Kandidaten für das Caching.  Als ich an einem Projekt mit mehr als 10 Millionen Besuchern pro Tag arbeitete, haben wir fast jede ausgewählte Anfrage zwischengespeichert. </p><br><h2 id="invalidaciya-kesha">  Cache-Ungültigmachung </h2><br><p>  Der Schlüsselabfall nach einer bestimmten Zeit hilft beim Aktualisieren der Daten im Cache, dies geschieht jedoch nicht sofort.  Der Benutzer kann die Daten ändern, aber für einige Zeit wird er weiterhin die alte Version davon in der Anwendung sehen.  Der übliche Dialog zu einem meiner vergangenen Projekte: </p><br><pre> <code class="plaintext hljs">:   ,     ! : ,  15 ( ,  )...</code> </pre> <br><p>  Dieses Verhalten ist für Benutzer sehr unpraktisch, und die offensichtliche Entscheidung, alte Daten aus dem Cache zu löschen, wenn wir sie aktualisieren, fällt mir schnell ein.  Dieser Vorgang wird als Behinderung bezeichnet.  Für einfache Schlüssel wie <code>"post_%id%"</code> ist die <code>"post_%id%"</code> nicht sehr schwierig. </p><br><p>  Beredte Ereignisse können helfen, oder wenn Ihre Anwendung spezielle Ereignisse wie <code>PostPublished</code> oder <code>UserBanned</code> , kann dies noch einfacher sein.  Beispiel mit eloquenten Ereignissen.  Zuerst müssen Sie Ereignisklassen erstellen.  Der Einfachheit halber werde ich für sie eine abstrakte Klasse verwenden: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> Post */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $post; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Post $post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post = $post; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post; } } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostSaved</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostDeleted</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span></span>{}</code> </pre> <br><p>  Natürlich muss sich laut PSR-4 jede Klasse in einer eigenen Datei befinden.  Richten Sie die Post Eloquent-Klasse ein (mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Dokumentation</a> ): </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $dispatchesEvents = [ <span class="hljs-string"><span class="hljs-string">'saved'</span></span> =&gt; PostSaved::class, <span class="hljs-string"><span class="hljs-string">'deleted'</span></span> =&gt; PostDeleted::class, ]; }</code> </pre> <br><p>  Erstellen Sie einen Listener für diese Ereignisse: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventServiceProvider</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $listen = [ PostSaved::class =&gt; [ ClearPostCache::class, ], PostDeleted::class =&gt; [ ClearPostCache::class, ], ]; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClearPostCache</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PostEvent $event)</span></span></span><span class="hljs-function"> </span></span>{ \Cache::forget(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $event-&gt;getPost()-&gt;id); } }</code> </pre> <br><p>  Dieser Code entfernt die zwischengespeicherten Werte nach jeder Aktualisierung oder Löschung von Post-Entitäten.  Das Ungültigmachen von Entitätslisten wie Top-5-Artikeln oder aktuellen Nachrichten wird etwas komplizierter.  Ich habe drei Strategien gesehen: </p><br><h3 id="strategiya-ne-invalidiruem">  Strategie nicht deaktivieren </h3><br><p>  Berühren Sie diese Werte einfach nicht.  Normalerweise bringt dies keine Probleme mit sich.  Es ist in Ordnung, dass die neuen Nachrichten etwas später in der Liste der letzteren erscheinen (natürlich, wenn dies kein großes Nachrichtenportal ist).  Für einige Projekte ist es jedoch sehr wichtig, dass diese Listen neue Daten enthalten. </p><br><h3 id="strategiya-nayti-i-obezvredit">  Strategie finden und entschärfen </h3><br><p>  Jedes Mal, wenn Sie eine Publikation aktualisieren, können Sie versuchen, sie in den zwischengespeicherten Listen zu finden. Wenn diese vorhanden ist, löschen Sie diesen zwischengespeicherten Wert. </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTopPosts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::<span class="hljs-comment"><span class="hljs-comment">/*   top-5*/</span></span>()-&gt;get(); }); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CheckAndClearTopPostsCache</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PostEvent $event)</span></span></span><span class="hljs-function"> </span></span>{ $updatedPost = $event-&gt;getPost(); $posts = \Cache::get(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>, []); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($posts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $post) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($updatedPost-&gt;id == $post-&gt;id) { \Cache::forget(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } }</code> </pre> <br><p>  Es sieht hässlich aus, aber es funktioniert. </p><br><h3 id="strategiya-hranit-id">  Strategie "Geschäfts-ID" </h3><br><p>  Wenn die Reihenfolge der Elemente in der Liste unwichtig ist, können Sie im Cache nur ID-Einträge speichern.  Nach Erhalt der ID können Sie eine Liste der Schlüssel der Form <code>'post_'.$id</code> erstellen und alle Werte mit der <code>Cache::many</code> Methode <code>Cache::many</code> , die in einer Anforderung viele Werte aus dem Cache abruft (dies wird auch als Multi-Get bezeichnet). </p><br><p>  Die Ungültigmachung des Cache wird nicht umsonst als eine der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">beiden Schwierigkeiten bei der Programmierung bezeichnet</a> und ist in einigen Fällen sehr schwierig. </p><br><h2 id="keshirovanie-otnosheniy">  Beziehungs-Caching </h2><br><p>  Das Zwischenspeichern von Entitäten mit Beziehungen erfordert eine erhöhte Aufmerksamkeit. </p><br><pre> <code class="php hljs">$post = Post::findOrFail($id); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($post-&gt;comments...)</code> </pre> <br><p>  Dieser Code führt zwei <code>SELECT</code> Abfragen aus.  Entität nach <code>id</code> und Kommentare nach <code>post_id</code> .  Wir implementieren Caching: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::findOrFail($id); }); } $post = getPost($id); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($post-&gt;comments...)</code> </pre> <br><p>  Die erste Anfrage wurde zwischengespeichert und die zweite nicht.  Wenn der Cache-Treiber Post in den Cache schreibt, werden noch keine <code>comments</code> geladen.  Wenn wir sie auch zwischenspeichern möchten, müssen wir sie manuell laden: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ $post = Post::findOrFail($id); $post-&gt;load(<span class="hljs-string"><span class="hljs-string">'comments'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post; }); }</code> </pre> <br><p>  Beide Anforderungen werden jetzt zwischengespeichert, aber wir müssen die Werte von <code>'post_'.$id</code> ungültig machen <code>'post_'.$id</code> jedes Mal, wenn ein Kommentar hinzugefügt wird.  Es ist nicht sehr effizient, daher ist es besser, den Kommentar-Cache separat zu speichern: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPostComments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Post $post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_comments_'</span></span> . $post-&gt;id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post-&gt;comments; }); } $post = getPost($id); $comments = getPostComments($post); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($comments...)</code> </pre> <br><p>  Manchmal sind Essenz und Einstellung stark miteinander verbunden und werden immer zusammen verwendet (Reihenfolge mit Details, Veröffentlichung mit Übersetzung in die gewünschte Sprache).  In diesem Fall ist das Speichern in einem Cache ganz normal. </p><br><h2 id="single-source-of-truth-dlya-klyuchey-keshirovaniya">  Eine einzige Wahrheitsquelle für Cache-Schlüssel </h2><br><p>  Wenn das Projekt eine Ungültigmachung implementiert, werden Cache-Schlüssel an mindestens zwei Stellen generiert: zum Aufrufen von <code>Cache::get</code> / <code>Cache::remember</code> und zum Aufrufen von <code>Cache::forget</code> .  Ich bin bereits auf Situationen gestoßen, in denen dieser Schlüssel an einem Ort geändert wurde, aber nicht an einem anderen, und die Behinderung brach.  Der übliche Rat für solche Fälle sind Konstanten, aber Cache-Schlüssel werden dynamisch generiert, daher verwende ich spezielle Klassen, die Schlüssel generieren: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheKeys</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($postId)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $postId; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postComments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($postId)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'post_comments'</span></span> . $postId; } } \Cache::remember(CacheKeys::postById($id), <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ $post = Post::findOrFail($id); }); <span class="hljs-comment"><span class="hljs-comment">// .... \Cache::forget(CacheKeys::postById($id));</span></span></code> </pre> <br><p>  Schlüssellebensdauern können zur besseren Lesbarkeit auch in Konstanten dargestellt werden.  Diese 900 oder 15 * 60 erhöhen die kognitive Belastung beim Lesen von Code. </p><br><h2 id="ne-ispolzuyte-kesh-v-operaciyah-zapisi">  Verwenden Sie den Cache nicht für Schreibvorgänge </h2><br><p>  Bei der Implementierung von Schreibvorgängen, z. B. beim Ändern des Titels oder des Textes einer Veröffentlichung, ist es verlockend, die <code>getPost</code> geschriebene Methode <code>getPost</code> verwenden: </p><br><pre> <code class="php hljs">$post = getPost($id); $post-&gt;title = $newTitle; $post-&gt;save();</code> </pre> <br><p>  Bitte nicht.  Der Wert im Cache ist möglicherweise veraltet, auch wenn die Ungültigmachung korrekt durchgeführt wurde.  Eine kleine Racebedingung und Veröffentlichung verlieren die von einem anderen Benutzer vorgenommenen Änderungen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Optimistische Sperren</a> helfen zumindest dabei, Änderungen nicht zu verlieren, aber die Anzahl fehlerhafter Anforderungen kann erheblich zunehmen. </p><br><p>  Die beste Lösung besteht darin, für Lese- und Schreibvorgänge eine völlig andere Entitätsauswahllogik zu verwenden (Hallo, CQRS).  Bei Schreibvorgängen müssen Sie immer den neuesten Wert aus der Datenbank auswählen.  Und vergessen Sie nicht die Sperren (optimistisch oder pessimistisch) für wichtige Daten. </p><br><p>  Ich denke, das reicht für einen einleitenden Artikel.  Caching ist ein sehr komplexes und langwieriges Thema mit Fallen für Entwickler, aber der Leistungsgewinn überwiegt manchmal alle Schwierigkeiten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463495/">https://habr.com/ru/post/de463495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463481/index.html">Diskrete Mathematik für WMS: Algorithmus zum Komprimieren von Waren in Zellen (Teil 1)</a></li>
<li><a href="../de463483/index.html">Dokumentenkollaboration, aktualisierter Unternehmenschat und mobile App: Was ist neu in Zextras Suite 3.0?</a></li>
<li><a href="../de463489/index.html">Heavy Metal hat gelogen: Tatsächlich wirkt sich Heavy Music positiv auf die Gesundheit seiner Fans aus</a></li>
<li><a href="../de463491/index.html">Die bizarre englische Übersetzungsgeschichte von Metal Gear Solid</a></li>
<li><a href="../de463493/index.html">Weitere Site-Statistiken in Ihrem kleinen Repository</a></li>
<li><a href="../de463497/index.html">Aktieneffizienzrechner und 5 Gründe, warum etwas schief geht</a></li>
<li><a href="../de463499/index.html">Komfortables Büro - hilft bei der Arbeit oder stört und lenkt ab? Sidenis, Alternativa Games und FunBox werden antworten</a></li>
<li><a href="../de463503/index.html">Warum ist moderne Webentwicklung so kompliziert? Teil 1</a></li>
<li><a href="../de463505/index.html">Warum Systemadministratoren DevOps-Ingenieure werden sollten</a></li>
<li><a href="../de463507/index.html">Die Nieren sind der Ausweg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>