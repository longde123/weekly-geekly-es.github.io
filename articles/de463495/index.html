<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÅ üïõ üë®‚Äç‚úàÔ∏è Laravel-Caching: Grundlagen sowie Tipps und Tricks üë®‚Äçüë¶‚Äçüë¶ üë©üèª‚Äçüåæ üòæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit der Caching-Technik k√∂nnen Sie skalierbarere Anwendungen erstellen und die Ergebnisse einiger Abfragen in einem schnellen In-Memory-Speicher speic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Laravel-Caching: Grundlagen sowie Tipps und Tricks</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463495/"><p>  Mit der Caching-Technik k√∂nnen Sie skalierbarere Anwendungen erstellen und die Ergebnisse einiger Abfragen in einem schnellen In-Memory-Speicher speichern.  Falsch implementiertes Caching kann jedoch den Eindruck des Benutzers von Ihrer Anwendung erheblich beeintr√§chtigen.  Dieser Artikel enth√§lt einige grundlegende Konzepte zum Caching, verschiedene Regeln und Tabus, die ich aus mehreren fr√ºheren Projekten gelernt habe. </p><br><h2 id="ne-ispolzuyte-keshirovanie">  Verwenden Sie kein Caching. </h2><br><p>  Ist Ihr Projekt schnell und hat keine Leistungsprobleme? <br>  Vergessen Sie das Caching.  Ernsthaft :) </p><br><p>  Dies wird die Lesevorg√§nge aus der Datenbank ohne Vorteile erheblich verkomplizieren. </p><br><p> Es stimmt, Mohamed Said am Anfang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">dieses Artikels</a> f√ºhrt einige Berechnungen durch und beweist, dass in einigen F√§llen durch die Optimierung der Anwendung f√ºr Millisekunden eine Menge Geld in Ihrem AWS-Konto gespart werden kann.  Wenn die projizierten Einsparungen f√ºr Ihr Projekt mehr als 1,86 US-Dollar betragen, ist Caching m√∂glicherweise eine gute Idee. </p><a name="habracut"></a><br><h2 id="kak-eto-rabotaet">  Wie funktioniert es </h2><br><p> Wenn eine Anwendung einige Daten aus der Datenbank <code>'post_' . $id</code> m√∂chte, z. B. die Post-Entit√§t anhand ihrer ID, generiert sie einen eindeutigen Caching-Schl√ºssel f√ºr diesen Fall ( <code>'post_' . $id</code> ist durchaus geeignet) und versucht, den Wert anhand dieses Schl√ºssels im schnellen Schl√ºsselwertspeicher (memcache, Redis oder eine andere).  Wenn der Wert vorhanden ist, wird er von der Anwendung verwendet.  Wenn nicht, nimmt es es aus der Datenbank und speichert es mit diesem Schl√ºssel f√ºr die zuk√ºnftige Verwendung im Cache. </p><br><p><img src="https://habrastorage.org/webt/vd/9i/kj/vd9ikjg-gji5lauz1atmq9bkdpq.png"></p><br><p>  Es ist keine gute Idee, diesen Wert f√ºr immer im Cache zu belassen, da diese Post-Entit√§t aktualisiert werden kann, die Anwendung jedoch immer den alten zwischengespeicherten Wert erh√§lt. <br>  Daher fragen Caching-Funktionen normalerweise, wann dieser Wert gespeichert werden soll. </p><br><p>  Nach Ablauf dieser Zeit ‚Äûvergessen‚Äú Memcache oder Redis dies und die Anwendung √ºbernimmt einen neuen Wert aus der Datenbank. </p><br><p>  Ein Beispiel: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ $key = <span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id; $post = \Cache::get($key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($post === <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { $post = Post::findOrFail($id); \Cache::put($key, $post, <span class="hljs-number"><span class="hljs-number">900</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post; }</code> </pre> <br><p>  Hier habe ich die Post-Entit√§t f√ºr 15 Minuten in den Cache gestellt (seit Version 5.8 verwendet Laravel Sekunden in diesem Parameter, bevor es Minuten gab).  Die <code>Cache</code> Fassade verf√ºgt auch √ºber eine praktische <code>remember</code> f√ºr diesen Fall.  Dieser Code macht genau das Gleiche wie der vorherige: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::findOrFail($id); }); }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">In der</a> Laravel-Dokumentation finden Sie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Cache-Kapitel, in dem</a> erl√§utert wird, wie Sie die erforderlichen Treiber f√ºr Ihre Anwendung und die Hauptfunktionen installieren. </p><br><h2 id="dannye-v-keshe">  Zwischengespeicherte Daten </h2><br><p>  Alle Standard-Laravel-Treiber speichern Daten als Zeichenfolgen.  Wenn Sie aufgefordert werden, eine Instanz des Eloquent-Modells zwischenzuspeichern, wird die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">serialize</a> verwendet, um die Zeichenfolge vom Objekt abzurufen.  Die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">unserialize</a> stellt den Status eines Objekts wieder her, wenn es aus dem Cache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">abgerufen wird</a> . </p><br><p>  Fast alle Daten k√∂nnen zwischengespeichert werden.  Zahlen, Zeichenfolgen, Arrays, Objekte (wenn sie korrekt serialisiert werden k√∂nnen, lesen Sie die Funktionsbeschreibungen unter den vorherigen Links). </p><br><p>  Eloquente Entit√§ten und Sammlungen k√∂nnen einfach zwischengespeichert werden und sind die beliebtesten Werte im Laravel-Anwendungscache.  Die Verwendung anderer Typen ist jedoch ebenfalls weit verbreitet.  Die <code>Cache::increment</code> Methode ist beliebt f√ºr die Implementierung verschiedener Z√§hler.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Atomic Locks sind auch</a> sehr n√ºtzlich, wenn Entwickler unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Rennbedingungen</a> k√§mpfen. </p><br><h2 id="chto-keshirovat">  Was soll zwischengespeichert werden? </h2><br><p>  Die ersten Kandidaten f√ºr das Caching sind Anforderungen, die sehr oft ausgef√ºhrt werden, aber ihr Ausf√ºhrungsplan ist nicht der einfachste.  Das beste Beispiel sind die Top 5 Artikel auf der Hauptseite oder die neuesten Nachrichten.  Das Zwischenspeichern solcher Werte kann die Leistung der Hauptseite erheblich verbessern. </p><br><p>  Normalerweise ist das Abrufen von Entit√§ten anhand der ID mithilfe von <code>Model::find($id)</code> sehr schnell. Wenn diese Tabelle jedoch stark mit zahlreichen Aktualisierungs-, Einf√ºge- und L√∂schabfragen belastet ist, bietet die Reduzierung der Anzahl ausgew√§hlter Abfragen eine gute Frist f√ºr die Datenbank.  Entit√§ten mit <code>hasMany</code> Beziehungen, die jedes Mal geladen werden, sind ebenfalls gute Kandidaten f√ºr das Caching.  Als ich an einem Projekt mit mehr als 10 Millionen Besuchern pro Tag arbeitete, haben wir fast jede ausgew√§hlte Anfrage zwischengespeichert. </p><br><h2 id="invalidaciya-kesha">  Cache-Ung√ºltigmachung </h2><br><p>  Der Schl√ºsselabfall nach einer bestimmten Zeit hilft beim Aktualisieren der Daten im Cache, dies geschieht jedoch nicht sofort.  Der Benutzer kann die Daten √§ndern, aber f√ºr einige Zeit wird er weiterhin die alte Version davon in der Anwendung sehen.  Der √ºbliche Dialog zu einem meiner vergangenen Projekte: </p><br><pre> <code class="plaintext hljs">:   ,     ! : ,  15 ( ,  )...</code> </pre> <br><p>  Dieses Verhalten ist f√ºr Benutzer sehr unpraktisch, und die offensichtliche Entscheidung, alte Daten aus dem Cache zu l√∂schen, wenn wir sie aktualisieren, f√§llt mir schnell ein.  Dieser Vorgang wird als Behinderung bezeichnet.  F√ºr einfache Schl√ºssel wie <code>"post_%id%"</code> ist die <code>"post_%id%"</code> nicht sehr schwierig. </p><br><p>  Beredte Ereignisse k√∂nnen helfen, oder wenn Ihre Anwendung spezielle Ereignisse wie <code>PostPublished</code> oder <code>UserBanned</code> , kann dies noch einfacher sein.  Beispiel mit eloquenten Ereignissen.  Zuerst m√ºssen Sie Ereignisklassen erstellen.  Der Einfachheit halber werde ich f√ºr sie eine abstrakte Klasse verwenden: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> Post */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $post; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Post $post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post = $post; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post; } } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostSaved</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostDeleted</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span></span>{}</code> </pre> <br><p>  Nat√ºrlich muss sich laut PSR-4 jede Klasse in einer eigenen Datei befinden.  Richten Sie die Post Eloquent-Klasse ein (mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Dokumentation</a> ): </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $dispatchesEvents = [ <span class="hljs-string"><span class="hljs-string">'saved'</span></span> =&gt; PostSaved::class, <span class="hljs-string"><span class="hljs-string">'deleted'</span></span> =&gt; PostDeleted::class, ]; }</code> </pre> <br><p>  Erstellen Sie einen Listener f√ºr diese Ereignisse: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventServiceProvider</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $listen = [ PostSaved::class =&gt; [ ClearPostCache::class, ], PostDeleted::class =&gt; [ ClearPostCache::class, ], ]; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClearPostCache</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PostEvent $event)</span></span></span><span class="hljs-function"> </span></span>{ \Cache::forget(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $event-&gt;getPost()-&gt;id); } }</code> </pre> <br><p>  Dieser Code entfernt die zwischengespeicherten Werte nach jeder Aktualisierung oder L√∂schung von Post-Entit√§ten.  Das Ung√ºltigmachen von Entit√§tslisten wie Top-5-Artikeln oder aktuellen Nachrichten wird etwas komplizierter.  Ich habe drei Strategien gesehen: </p><br><h3 id="strategiya-ne-invalidiruem">  Strategie nicht deaktivieren </h3><br><p>  Ber√ºhren Sie diese Werte einfach nicht.  Normalerweise bringt dies keine Probleme mit sich.  Es ist in Ordnung, dass die neuen Nachrichten etwas sp√§ter in der Liste der letzteren erscheinen (nat√ºrlich, wenn dies kein gro√ües Nachrichtenportal ist).  F√ºr einige Projekte ist es jedoch sehr wichtig, dass diese Listen neue Daten enthalten. </p><br><h3 id="strategiya-nayti-i-obezvredit">  Strategie finden und entsch√§rfen </h3><br><p>  Jedes Mal, wenn Sie eine Publikation aktualisieren, k√∂nnen Sie versuchen, sie in den zwischengespeicherten Listen zu finden. Wenn diese vorhanden ist, l√∂schen Sie diesen zwischengespeicherten Wert. </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTopPosts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::<span class="hljs-comment"><span class="hljs-comment">/*   top-5*/</span></span>()-&gt;get(); }); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CheckAndClearTopPostsCache</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PostEvent $event)</span></span></span><span class="hljs-function"> </span></span>{ $updatedPost = $event-&gt;getPost(); $posts = \Cache::get(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>, []); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($posts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $post) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($updatedPost-&gt;id == $post-&gt;id) { \Cache::forget(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } }</code> </pre> <br><p>  Es sieht h√§sslich aus, aber es funktioniert. </p><br><h3 id="strategiya-hranit-id">  Strategie "Gesch√§fts-ID" </h3><br><p>  Wenn die Reihenfolge der Elemente in der Liste unwichtig ist, k√∂nnen Sie im Cache nur ID-Eintr√§ge speichern.  Nach Erhalt der ID k√∂nnen Sie eine Liste der Schl√ºssel der Form <code>'post_'.$id</code> erstellen und alle Werte mit der <code>Cache::many</code> Methode <code>Cache::many</code> , die in einer Anforderung viele Werte aus dem Cache abruft (dies wird auch als Multi-Get bezeichnet). </p><br><p>  Die Ung√ºltigmachung des Cache wird nicht umsonst als eine der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">beiden Schwierigkeiten bei der Programmierung bezeichnet</a> und ist in einigen F√§llen sehr schwierig. </p><br><h2 id="keshirovanie-otnosheniy">  Beziehungs-Caching </h2><br><p>  Das Zwischenspeichern von Entit√§ten mit Beziehungen erfordert eine erh√∂hte Aufmerksamkeit. </p><br><pre> <code class="php hljs">$post = Post::findOrFail($id); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($post-&gt;comments...)</code> </pre> <br><p>  Dieser Code f√ºhrt zwei <code>SELECT</code> Abfragen aus.  Entit√§t nach <code>id</code> und Kommentare nach <code>post_id</code> .  Wir implementieren Caching: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::findOrFail($id); }); } $post = getPost($id); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($post-&gt;comments...)</code> </pre> <br><p>  Die erste Anfrage wurde zwischengespeichert und die zweite nicht.  Wenn der Cache-Treiber Post in den Cache schreibt, werden noch keine <code>comments</code> geladen.  Wenn wir sie auch zwischenspeichern m√∂chten, m√ºssen wir sie manuell laden: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ $post = Post::findOrFail($id); $post-&gt;load(<span class="hljs-string"><span class="hljs-string">'comments'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post; }); }</code> </pre> <br><p>  Beide Anforderungen werden jetzt zwischengespeichert, aber wir m√ºssen die Werte von <code>'post_'.$id</code> ung√ºltig machen <code>'post_'.$id</code> jedes Mal, wenn ein Kommentar hinzugef√ºgt wird.  Es ist nicht sehr effizient, daher ist es besser, den Kommentar-Cache separat zu speichern: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPostComments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Post $post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_comments_'</span></span> . $post-&gt;id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post-&gt;comments; }); } $post = getPost($id); $comments = getPostComments($post); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($comments...)</code> </pre> <br><p>  Manchmal sind Essenz und Einstellung stark miteinander verbunden und werden immer zusammen verwendet (Reihenfolge mit Details, Ver√∂ffentlichung mit √úbersetzung in die gew√ºnschte Sprache).  In diesem Fall ist das Speichern in einem Cache ganz normal. </p><br><h2 id="single-source-of-truth-dlya-klyuchey-keshirovaniya">  Eine einzige Wahrheitsquelle f√ºr Cache-Schl√ºssel </h2><br><p>  Wenn das Projekt eine Ung√ºltigmachung implementiert, werden Cache-Schl√ºssel an mindestens zwei Stellen generiert: zum Aufrufen von <code>Cache::get</code> / <code>Cache::remember</code> und zum Aufrufen von <code>Cache::forget</code> .  Ich bin bereits auf Situationen gesto√üen, in denen dieser Schl√ºssel an einem Ort ge√§ndert wurde, aber nicht an einem anderen, und die Behinderung brach.  Der √ºbliche Rat f√ºr solche F√§lle sind Konstanten, aber Cache-Schl√ºssel werden dynamisch generiert, daher verwende ich spezielle Klassen, die Schl√ºssel generieren: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheKeys</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($postId)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $postId; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postComments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($postId)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'post_comments'</span></span> . $postId; } } \Cache::remember(CacheKeys::postById($id), <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ $post = Post::findOrFail($id); }); <span class="hljs-comment"><span class="hljs-comment">// .... \Cache::forget(CacheKeys::postById($id));</span></span></code> </pre> <br><p>  Schl√ºssellebensdauern k√∂nnen zur besseren Lesbarkeit auch in Konstanten dargestellt werden.  Diese 900 oder 15 * 60 erh√∂hen die kognitive Belastung beim Lesen von Code. </p><br><h2 id="ne-ispolzuyte-kesh-v-operaciyah-zapisi">  Verwenden Sie den Cache nicht f√ºr Schreibvorg√§nge </h2><br><p>  Bei der Implementierung von Schreibvorg√§ngen, z. B. beim √Ñndern des Titels oder des Textes einer Ver√∂ffentlichung, ist es verlockend, die <code>getPost</code> geschriebene Methode <code>getPost</code> verwenden: </p><br><pre> <code class="php hljs">$post = getPost($id); $post-&gt;title = $newTitle; $post-&gt;save();</code> </pre> <br><p>  Bitte nicht.  Der Wert im Cache ist m√∂glicherweise veraltet, auch wenn die Ung√ºltigmachung korrekt durchgef√ºhrt wurde.  Eine kleine Racebedingung und Ver√∂ffentlichung verlieren die von einem anderen Benutzer vorgenommenen √Ñnderungen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Optimistische Sperren</a> helfen zumindest dabei, √Ñnderungen nicht zu verlieren, aber die Anzahl fehlerhafter Anforderungen kann erheblich zunehmen. </p><br><p>  Die beste L√∂sung besteht darin, f√ºr Lese- und Schreibvorg√§nge eine v√∂llig andere Entit√§tsauswahllogik zu verwenden (Hallo, CQRS).  Bei Schreibvorg√§ngen m√ºssen Sie immer den neuesten Wert aus der Datenbank ausw√§hlen.  Und vergessen Sie nicht die Sperren (optimistisch oder pessimistisch) f√ºr wichtige Daten. </p><br><p>  Ich denke, das reicht f√ºr einen einleitenden Artikel.  Caching ist ein sehr komplexes und langwieriges Thema mit Fallen f√ºr Entwickler, aber der Leistungsgewinn √ºberwiegt manchmal alle Schwierigkeiten. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463495/">https://habr.com/ru/post/de463495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463481/index.html">Diskrete Mathematik f√ºr WMS: Algorithmus zum Komprimieren von Waren in Zellen (Teil 1)</a></li>
<li><a href="../de463483/index.html">Dokumentenkollaboration, aktualisierter Unternehmenschat und mobile App: Was ist neu in Zextras Suite 3.0?</a></li>
<li><a href="../de463489/index.html">Heavy Metal hat gelogen: Tats√§chlich wirkt sich Heavy Music positiv auf die Gesundheit seiner Fans aus</a></li>
<li><a href="../de463491/index.html">Die bizarre englische √úbersetzungsgeschichte von Metal Gear Solid</a></li>
<li><a href="../de463493/index.html">Weitere Site-Statistiken in Ihrem kleinen Repository</a></li>
<li><a href="../de463497/index.html">Aktieneffizienzrechner und 5 Gr√ºnde, warum etwas schief geht</a></li>
<li><a href="../de463499/index.html">Komfortables B√ºro - hilft bei der Arbeit oder st√∂rt und lenkt ab? Sidenis, Alternativa Games und FunBox werden antworten</a></li>
<li><a href="../de463503/index.html">Warum ist moderne Webentwicklung so kompliziert? Teil 1</a></li>
<li><a href="../de463505/index.html">Warum Systemadministratoren DevOps-Ingenieure werden sollten</a></li>
<li><a href="../de463507/index.html">Die Nieren sind der Ausweg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>