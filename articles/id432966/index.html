<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßìüèº üò® üé© Bootloader terenkripsi untuk STM32 üì≠ ‚úàÔ∏è üë®‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini saya ingin menulis tentang pengalaman saya dalam membuat bootloader untuk STM32 dengan enkripsi firmware. Saya seorang pengembang ind...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bootloader terenkripsi untuk STM32</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432966/">  Pada artikel ini saya ingin menulis tentang pengalaman saya dalam membuat bootloader untuk STM32 dengan enkripsi firmware.  Saya seorang pengembang individu, jadi kode di bawah ini mungkin tidak mematuhi standar perusahaan apa pun <br><br>  Dalam proses, tugas-tugas berikut ditetapkan: <br><br><ul><li>  Berikan pembaruan firmware untuk pengguna perangkat dari kartu SD. </li><li>  Pastikan kontrol integritas firmware dan kecualikan rekaman firmware yang salah dalam memori pengontrol. </li><li>  Berikan enkripsi firmware untuk mencegah kloning perangkat. </li></ul><br>  Kode ini ditulis dalam Keil uVision menggunakan perpustakaan stdperiph, fatFS, dan tinyAES.  Mikrokontroler eksperimental adalah STM32F103VET6, tetapi kode dapat dengan mudah disesuaikan dengan pengontrol STM lainnya.  Kontrol integritas disediakan oleh algoritma CRC32, checksum terletak di 4 byte terakhir dari file firmware. <br><br>  Artikel ini tidak menjelaskan pembuatan proyek, menghubungkan perpustakaan, menginisialisasi periferal dan langkah-langkah sepele lainnya. <br><a name="habracut"></a><br>  Pertama, Anda perlu memutuskan apa itu bootloader.  Arsitektur STM32 menyiratkan pengalamatan datar dari memori ketika dalam satu ruang alamat terdapat memori Flash, RAM, register periferal dan yang lainnya.  Bootloader adalah program yang dimulai ketika mikrokontroler mulai, memeriksa apakah perlu memperbarui firmware, jika perlu, menjalankannya, dan meluncurkan program utama perangkat.  Artikel ini akan menjelaskan mekanisme pembaruan dari kartu SD, tetapi Anda dapat menggunakan sumber lainnya. <br><br>  Enkripsi firmware dilakukan oleh algoritma AES128 dan diimplementasikan menggunakan perpustakaan tinyAES.  Ini terdiri dari hanya dua file, satu dengan ekstensi .c, yang lain dengan ekstensi .h, jadi seharusnya tidak ada masalah dengan koneksinya. <br><br>  Setelah membuat proyek, Anda harus menentukan ukuran loader dan program utama.  Untuk kenyamanan, ukuran harus dipilih dalam beberapa ukuran halaman memori mikrokontroler.  Dalam contoh ini, bootloader akan menempati 64 Kb, dan program utama akan menempati sisa 448 Kb.  Bootloader akan berlokasi di awal memori flash, dan program utama segera setelah bootloader.  Ini harus ditentukan dalam pengaturan proyek di Keil.  Bootloader dimulai dengan alamat 0x80000000 (itu darinya STM32 mulai mengeksekusi kode setelah peluncuran) dan memiliki ukuran 0x10000, kami menunjukkan ini dalam pengaturan. <br><br><img src="https://habrastorage.org/webt/ol/pp/vx/olppvx6lq6yafgjd8wnbkclxxbi.png"><br><br>  Program utama akan mulai dengan 0x08010000 dan diakhiri dengan 0x08080000 untuk kenyamanan, kami akan mendefinisikan dengan semua alamat: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_PROGRAM_START_ADDRESS 0x08010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_PROGRAM_END_ADDRESS 0x08080000</span></span></code> </pre> <br>  Kami juga menambahkan kunci enkripsi dan vektor inisialisasi AES ke program.  Kunci-kunci ini dihasilkan secara acak. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> AES_FW_KEY[] = {<span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> AES_IV[] = {<span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>};</code> </pre><br>  Dalam contoh ini, seluruh prosedur pembaruan firmware dibangun sebagai mesin keadaan.  Ini memungkinkan proses pembaruan untuk menampilkan sesuatu di layar, mengatur ulang Watchdog dan melakukan tindakan lain apa pun.  Untuk kenyamanan, kami akan mendefinisikan dengan status dasar otomat, agar tidak menjadi bingung dalam angka: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FW_START 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FW_READ 1000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FW_WRITE 2000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FW_FINISH 10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FW_ERROR 100000</span></span></code> </pre> <br>  Setelah menginisialisasi periferal, Anda perlu memeriksa kebutuhan untuk pembaruan firmware.  Dalam keadaan pertama, upaya dilakukan untuk membaca kartu SD dan memeriksa keberadaan file di dalamnya. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> fw_step; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> fw_buf[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> aes_buf[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     Flash-*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> idx; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tbuf[<span class="hljs-number"><span class="hljs-number">64</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*    sprintf */</span></span> FATFS FS; <span class="hljs-comment"><span class="hljs-comment">/*   fatFS -   */</span></span> FIL F; <span class="hljs-comment"><span class="hljs-comment">/*   fatFS -  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_READ: <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(f_mount(&amp;FS, <span class="hljs-string"><span class="hljs-string">""</span></span> , <span class="hljs-number"><span class="hljs-number">0</span></span>) == FR_OK) <span class="hljs-comment"><span class="hljs-comment">/*   SD-*/</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ,     . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(f_open(&amp;F, <span class="hljs-string"><span class="hljs-string">"FIRMWARE.BIN"</span></span>, FA_READ | FA_OPEN_EXISTING) == FR_OK) { f_lseek(&amp;F, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> CRC_ResetDR(); <span class="hljs-comment"><span class="hljs-comment">/*    CRC */</span></span> lcd_putstr(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> idx = MAIN_PROGRAM_START_ADDRESS; fw_step = FW_READ + <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {fw_step = FW_FINISH;} <span class="hljs-comment"><span class="hljs-comment">/*    -   */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {fw_step = FW_FINISH;} <span class="hljs-comment"><span class="hljs-comment">/*   SD- -   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br>  Sekarang kita perlu memeriksa kebenaran firmware.  Di sini, pertama datang kode verifikasi checksum, dieksekusi ketika file selesai membaca, dan kemudian membaca itu sendiri.  Mungkin Anda tidak boleh menulis seperti itu, tulis di komentar apa pendapat Anda tentang hal itu.  Membaca dilakukan pada 2 KB untuk kenyamanan bekerja dengan memori Flash, karena  STM32F103VET6 memiliki ukuran halaman memori 2 Kb. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_READ + <span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*     ,    */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(tbuf, <span class="hljs-string"><span class="hljs-string">": %d"</span></span>, idx - MAIN_PROGRAM_START_ADDRESS); lcd_putstr(tbuf, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx &gt; MAIN_PROGRAM_END_ADDRESS) <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> { f_read(&amp;F, &amp;t, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(t), &amp;idx); <span class="hljs-comment"><span class="hljs-comment">/*  4    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   4       CRC */</span></span> CRC_CalcCRC(t); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CRC_GetCRC() == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">/*   0,     */</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*         */</span></span> idx = MAIN_PROGRAM_START_ADDRESS; f_lseek(&amp;F, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> fw_step = FW_READ + <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lcd_putstr(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> fw_step = FW_ERROR; <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } f_read(&amp;F, &amp;fw_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf), &amp;t); <span class="hljs-comment"><span class="hljs-comment">/*  2      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(t != <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf)) <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> { lcd_putstr(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); fw_step = FW_ERROR; <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> AES_CBC_decrypt_buffer((<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)&amp;aes_buf, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)&amp;fw_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf), AES_FW_KEY, AES_IV); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(t=<span class="hljs-number"><span class="hljs-number">0</span></span>;t&lt;NELEMS(aes_buf);t++) <span class="hljs-comment"><span class="hljs-comment">/*     CRC */</span></span> { CRC_CalcCRC(aes_buf[t]); <span class="hljs-comment"><span class="hljs-comment">/*    4  */</span></span> } idx+=<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf); <span class="hljs-comment"><span class="hljs-comment">/*     2  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Sekarang, jika firmware tidak rusak, maka Anda perlu membacanya lagi, tetapi kali ini tulis ke memori Flash. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_READ + <span class="hljs-number"><span class="hljs-number">20</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Flash Firmware { /*     ,    */ sprintf(tbuf, ": %d", idx - MAIN_PROGRAM_START_ADDRESS); lcd_putstr(tbuf, 4, 2); if (idx &gt; MAIN_PROGRAM_END_ADDRESS) /*     */ { lcd_putstr("", 7, 3); /*     */ f_unlink("FIRMWARE.BIN"); /*     SD- */ fw_step = FW_FINISH; /*   */ break; } f_read(&amp;F, &amp;fw_buf, sizeof(fw_buf), &amp;t); /*   2  */ if(t != sizeof(fw_buf)) /*     */ { lcd_putstr(" ", 3, 3); /*     */ fw_step = FW_ERROR; /*       */ break; } /*     */ AES_CBC_decrypt_buffer((uint8_t*)&amp;aes_buf, (uint8_t *)&amp;fw_buf, sizeof(fw_buf), AES_FW_KEY, AES_IV); FLASH_Unlock(); /*  FLash-   */ FLASH_ErasePage(idx); /*    */ for(t=0;t&lt;sizeof(aes_buf);t+=4) /*    4  */ { FLASH_ProgramWord(idx+t, aes_buf[t/4]); } FLASH_Lock(); /*     */ idx+=sizeof(fw_buf); /*     */ break; }</span></span></code> </pre><br>  Sekarang untuk kecantikan, kami akan membuat status untuk penanganan kesalahan dan pembaruan yang berhasil: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_ERROR: { <span class="hljs-comment"><span class="hljs-comment">/*  -     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_FINISH: { ExecMainFW(); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Fungsi meluncurkan program utama ExecMainFW () patut dipertimbangkan secara lebih rinci.  Ini dia: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecMainFW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    ,     */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* +4  ,          */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> jumpAddress = *(__IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*) (MAIN_PROGRAM_START_ADDRESS + <span class="hljs-number"><span class="hljs-number">4</span></span>); pFunction Jump_To_Application = (pFunction) jumpAddress; <span class="hljs-comment"><span class="hljs-comment">/*    APB1 */</span></span> RCC-&gt;APB1RSTR = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>; RCC-&gt;APB1RSTR = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    APB2 */</span></span> RCC-&gt;APB2RSTR = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>; RCC-&gt;APB2RSTR = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; RCC-&gt;APB1ENR = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     APB1 */</span></span> RCC-&gt;APB2ENR = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     APB2 */</span></span> RCC-&gt;AHBENR = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     AHB */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      ,   HSI*/</span></span> RCC_DeInit(); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> __disable_irq(); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> NVIC_SetVectorTable(NVIC_VectTab_FLASH, MAIN_PROGRAM_START_ADDRESS); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> __set_MSP(*(__IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*) MAIN_PROGRAM_START_ADDRESS); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> Jump_To_Application(); }</code> </pre> <br>  Segera setelah memulai file startup, ia menginisialisasi ulang semuanya, sehingga program utama harus mengatur kembali pointer ke vektor interupsi di dalam ruang alamatnya: <br><br><pre> <code class="cpp hljs">__disable_irq(); NVIC_SetVectorTable(NVIC_VectTab_FLASH, MAIN_PROGRAM_START_ADDRESS); __enable_irq();</code> </pre><br>  Dalam proyek program utama, Anda perlu menentukan alamat yang benar: <br><br><img src="https://habrastorage.org/webt/xc/o5/41/xco541o-b7_wgzrdvoovdqtpqvu.png"><br><br>  Di sini, pada kenyataannya, seluruh prosedur pembaruan.  Firmware diperiksa untuk kebenaran dan dienkripsi, semua tugas selesai.  Jika terjadi kehilangan daya selama proses pembaruan, perangkat tentu saja akan rusak, tetapi bootloader akan tetap tidak tersentuh dan prosedur pembaruan dapat diulang.  Untuk situasi yang sangat kritis, Anda dapat mengunci halaman di mana loader berada melalui Option bytes untuk ditulis. <br><br>  Namun, dalam kasus kartu SD, Anda dapat mengatur sendiri di bootloader satu kenyamanan yang menyenangkan.  Ketika pengujian dan debugging versi firmware baru selesai, Anda dapat memaksa perangkat itu sendiri untuk mengenkripsi dan mengunggah firmware yang sudah selesai ke kartu SD untuk beberapa kondisi khusus (misalnya, tombol atau pelompat di dalam).  Dalam hal ini, tetap hanya menghapus kartu-SD dari perangkat, memasukkannya ke komputer dan meletakkan firmware di Internet untuk menyenangkan pengguna.  Kami akan melakukan ini dalam bentuk dua keadaan lagi dari mesin keadaan terbatas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_WRITE: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(f_mount(&amp;FS, <span class="hljs-string"><span class="hljs-string">""</span></span> , <span class="hljs-number"><span class="hljs-number">0</span></span>) == FR_OK) <span class="hljs-comment"><span class="hljs-comment">/*   SD-*/</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(f_open(&amp;F, <span class="hljs-string"><span class="hljs-string">"FIRMWARE.BIN"</span></span>, FA_WRITE | FA_CREATE_ALWAYS) == FR_OK) { CRC_ResetDR(); <span class="hljs-comment"><span class="hljs-comment">/*   CRC */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> idx = MAIN_PROGRAM_START_ADDRESS; fw_step = FW_WRITE + <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {fw_step = FW_ERROR;} <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {fw_step = FW_ERROR;} <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_WRITE + <span class="hljs-number"><span class="hljs-number">10</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx &gt; MAIN_PROGRAM_END_ADDRESS) <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> { t = CRC_GetCRC(); f_write(&amp;F, &amp;t, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(t), &amp;idx); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> f_close(&amp;F); <span class="hljs-comment"><span class="hljs-comment">/*  ,   */</span></span> fw_step = FW_FINISH; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*  2    Flash-   */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;fw_buf, (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *)idx, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(t=<span class="hljs-number"><span class="hljs-number">0</span></span>;t&lt;NELEMS(fw_buf);t++) <span class="hljs-comment"><span class="hljs-comment">/*  CRC    */</span></span> { CRC_CalcCRC(fw_buf[t]); } <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> AES_CBC_encrypt_buffer((<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)&amp;aes_buf, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)&amp;fw_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf), AES_FW_KEY, AES_IV); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> f_write(&amp;F, &amp;aes_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(aes_buf), &amp;t); idx+=<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Sebenarnya, itulah yang ingin saya sampaikan.  Di akhir artikel, saya ingin mengucapkan selamat kepada Anda setelah membuat bootloader seperti itu agar tidak lupa menyertakan perlindungan terhadap pembacaan memori mikrokontroler dalam Opsi byte. <br><br><h4>  Referensi </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tinyAES</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FatFS</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432966/">https://habr.com/ru/post/id432966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432954/index.html">Dan lagi ke luar angkasa: bagaimana unicorn Stellarium dikunjungi</a></li>
<li><a href="../id432956/index.html">Monster dari Id: bagaimana Doom dibuat</a></li>
<li><a href="../id432958/index.html">Paradoks kuantum baru mengklarifikasi bahwa ide-ide kita tentang kenyataan ternyata salah</a></li>
<li><a href="../id432960/index.html">Mengapa konsumen tidak takut pencurian identitas</a></li>
<li><a href="../id432964/index.html">Tentang kekuasaan baik atau tidak sama sekali: inisiatif legislatif baru di Federasi Rusia</a></li>
<li><a href="../id432968/index.html">6 masalah umum ketika menerapkan solusi manajemen proyek</a></li>
<li><a href="../id432972/index.html">Sumber: "Hukum Conway"</a></li>
<li><a href="../id432978/index.html">John Romero: Refleksi DOOM</a></li>
<li><a href="../id432980/index.html">VMware NSX untuk yang terkecil. Bagian 1</a></li>
<li><a href="../id432982/index.html">Pengantar terpendek untuk pembuatan kompiler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>