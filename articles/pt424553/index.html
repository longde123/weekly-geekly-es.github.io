<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¶ üïµüèæ üë®üèæ‚Äçüîß Guia do Node.js, parte 6: loop de eventos, pilha de chamadas, temporizadores üë§ ü§±üèø üöΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje, na sexta parte da tradu√ß√£o do manual Node.js., falaremos sobre o loop de eventos, a pilha de chamadas, a fun√ß√£o process.nextTick() e os timers. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia do Node.js, parte 6: loop de eventos, pilha de chamadas, temporizadores</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424553/"> Hoje, na sexta parte da tradu√ß√£o do manual Node.js., falaremos sobre o loop de eventos, a pilha de chamadas, a fun√ß√£o <code>process.nextTick()</code> e os timers.  Compreender esses e outros mecanismos do Node.js. √© uma das pedras angulares do desenvolvimento bem-sucedido de aplicativos para esta plataforma. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Aconselhamos a ler] Outras partes do ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Informa√ß√µes gerais e introdu√ß√£o</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JavaScript, V8, alguns truques de desenvolvimento</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hospedagem, REPL, trabalho com o console, m√≥dulos</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arquivos npm, package.json e package-lock.json</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">npm e npx</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">loop de eventos, pilha de chamadas, temporizadores</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Programa√ß√£o ass√≠ncrona</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia Node.js, Parte 8: Protocolos HTTP e WebSocket</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia Node.js, parte 9: trabalhando com o sistema de arquivos</a> <br>  Parte 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia do Node.js, Parte 10: M√≥dulos padr√£o, fluxos, bancos de dados, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PDF completo do Guia Node.js.</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Loop de eventos</font> </h2><br>  Se voc√™ deseja entender como o c√≥digo JavaScript √© executado, o Loop de Eventos √© um dos conceitos mais importantes que voc√™ precisa entender.  Aqui, falaremos sobre como o JavaScript funciona no modo de thread √∫nico e como s√£o tratadas as fun√ß√µes ass√≠ncronas. <br><br>  Desenvolvo JavaScript h√° muitos anos, mas n√£o posso dizer que entendi completamente como tudo funciona, por assim dizer, "sob o cap√¥".  O programador pode n√£o estar ciente das complexidades do dispositivo dos subsistemas internos do ambiente em que trabalha.  Mas geralmente √© √∫til ter pelo menos uma id√©ia geral de tais coisas. <br><br>  O c√≥digo JavaScript que voc√™ escreve √© ‚Äã‚Äãexecutado no modo de thread √∫nico.  Em um determinado momento, apenas uma a√ß√£o √© executada.  Essa limita√ß√£o, de fato, √© muito √∫til.  Isso simplifica bastante a maneira como os programas funcionam, eliminando a necessidade de programadores resolverem problemas espec√≠ficos para ambientes com v√°rios threads. <br><br>  De fato, um programador de JS precisa prestar aten√ß√£o apenas exatamente a quais a√ß√µes seu c√≥digo executa e tentar evitar situa√ß√µes que causam o bloqueio do encadeamento principal.  Por exemplo - fazer chamadas de rede no modo s√≠ncrono e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ciclos</a> infinitos. <br><br>  Normalmente, os navegadores, em cada guia aberta, t√™m seu pr√≥prio loop de eventos.  Isso permite que voc√™ execute o c√≥digo de cada p√°gina em um ambiente isolado e evite situa√ß√µes em que uma determinada p√°gina, no c√≥digo em que h√° um loop infinito ou em c√°lculos pesados, seja capaz de "suspender" todo o navegador.  O navegador suporta o trabalho de muitos loops de eventos existentes simultaneamente, usados, por exemplo, para processar chamadas para v√°rias APIs.  Al√©m disso, um loop de eventos propriet√°rio √© usado para dar suporte aos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">trabalhadores da Web</a> . <br><br>  A coisa mais importante que um programador JavaScript deve lembrar constantemente √© que seu c√≥digo usa seu pr√≥prio loop de eventos, portanto, o c√≥digo deve ser escrito para que esse loop de eventos n√£o seja bloqueado. <br><br><h2>  <font color="#3AC1EF">Bloqueio de loop de eventos</font> </h2><br>  Qualquer c√≥digo JavaScript que leva muito tempo para ser executado, ou seja, c√≥digo que n√£o assume o controle do loop de eventos por muito tempo, bloqueia a execu√ß√£o de qualquer outro c√≥digo de p√°gina.  Isso leva ao bloqueio do processamento de eventos da interface do usu√°rio, o que se reflete no fato de que o usu√°rio n√£o pode interagir com os elementos da p√°gina e trabalhar normalmente com ele, por exemplo, rolagem. <br><br>  Quase todos os mecanismos b√°sicos de E / S JavaScript n√£o s√£o bloqueados.  Isso se aplica ao navegador e ao Node.js.  Entre esses mecanismos, por exemplo, podemos mencionar as ferramentas para executar solicita√ß√µes de rede usadas nos ambientes cliente e servidor e ferramentas para trabalhar com arquivos Node.js.  Existem m√©todos s√≠ncronos para executar essas opera√ß√µes, mas eles s√£o usados ‚Äã‚Äãapenas em casos especiais.  √â por isso que retornos de chamada tradicionais e mecanismos mais recentes - promessas e constru√ß√£o ass√≠ncrona / aguardada - s√£o de grande import√¢ncia no JavaScript. <br><br><h2>  <font color="#3AC1EF">Pilha de chamadas</font> </h2><br>  A pilha de chamadas JavaScript √© baseada no princ√≠pio LIFO (√∫ltimo a entrar, primeiro a sair - √∫ltimo a entrar, primeiro a sair).  O loop de eventos verifica constantemente a pilha de chamadas para ver se ela possui uma fun√ß√£o que precisa ser executada.  Se, ao executar o c√≥digo, uma fun√ß√£o √© chamada nele, informa√ß√µes sobre ele s√£o adicionadas √† pilha de chamadas e essa fun√ß√£o √© executada. <br><br>  Se antes mesmo de voc√™ n√£o estar interessado no conceito de ‚Äúpilha de chamadas‚Äù, se voc√™ encontrou mensagens de erro que incluem um rastreamento de pilha, voc√™ j√° imagina como √©.  Aqui, por exemplo, se parece com isso em um navegador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/b9d/9fe/e6fb9d9fe2d481ab7178cb5bcb022454.png"></div><br>  <i><font color="#999999">Mensagem de erro do navegador</font></i> <br><br>  O navegador, quando ocorre um erro, relata a sequ√™ncia de chamadas para fun√ß√µes, informa√ß√µes sobre as quais est√£o armazenadas na pilha de chamadas, o que permite encontrar a fonte do erro e entender quais chamadas para quais fun√ß√µes levaram √† situa√ß√£o. <br><br>  Agora que falamos sobre o loop de eventos e a pilha de chamadas em termos gerais, considere um exemplo que ilustra a execu√ß√£o de um fragmento de c√≥digo e como esse processo se parece em termos de loop de eventos e pilha de chamadas. <br><br><h2>  <font color="#3AC1EF">Loop de eventos e pilha de chamadas</font> </h2><br>  Aqui est√° o c√≥digo com o qual experimentaremos: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) bar() baz() } foo()</code> </pre> <br>  Se esse c√≥digo for executado, o seguinte chegar√° ao console: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> bar baz</code> </pre> <br>  Tal resultado √© bastante esperado.  Ou seja, quando esse c√≥digo √© executado, a fun√ß√£o <code>foo()</code> √© chamada primeiro.  Dentro dessa fun√ß√£o, chamamos primeiro a fun√ß√£o <code>bar()</code> e depois a fun√ß√£o <code>baz()</code> .  Ao mesmo tempo, a pilha de chamadas durante a execu√ß√£o desse c√≥digo sofre as altera√ß√µes mostradas na figura a seguir. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/6ea/763/c2e6ea7631946a6d0f141416fbdba077.png"></div><br>  <i><font color="#999999">Alterando o status da pilha de chamadas ao executar o c√≥digo sob investiga√ß√£o</font></i> <br><br>  O loop de eventos, a cada itera√ß√£o, verifica se h√° algo na pilha de chamadas e, se houver, o faz at√© que a pilha de chamadas esteja vazia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">Itera√ß√µes de loop de eventos</font></i> <br><br><h2>  <font color="#3AC1EF">Enfileirando uma fun√ß√£o</font> </h2><br>  O exemplo acima parece bastante comum, n√£o h√° nada de especial nisso: o JavaScript encontra o c√≥digo que precisa ser executado e o executa em ordem.  Falaremos sobre como adiar a execu√ß√£o das fun√ß√µes at√© que a pilha de chamadas seja limpa.  Para fazer isso, a seguinte constru√ß√£o √© usada: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {}), <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Permite executar a fun√ß√£o passada para a fun√ß√£o <code>setTimeout()</code> ap√≥s a execu√ß√£o de todas as outras fun√ß√µes chamadas no c√≥digo do programa. <br><br>  Considere um exemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) baz() } foo()</code> </pre> <br>  O que esse c√≥digo imprime pode parecer inesperado: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> baz bar</code> </pre> <br>  Quando executamos este exemplo, a fun√ß√£o <code>foo()</code> √© chamada primeiro.  Nele, chamamos <code>setTimeout()</code> , passando essa fun√ß√£o, como o primeiro argumento, <code>bar</code> .  Ao passar <code>0</code> como o segundo argumento, informamos ao sistema que essa fun√ß√£o deve ser executada o mais r√°pido poss√≠vel.  Ent√£o chamamos a fun√ß√£o <code>baz()</code> . <br><br>  √â assim que a pilha de chamadas ficar√° agora. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a23/8fd/d45/a238fdd4515c24e61f2e297f3c5b9d17.png"></div><br>  <i><font color="#999999">Alterando o status da pilha de chamadas ao executar o c√≥digo sob investiga√ß√£o</font></i> <br><br>  Aqui est√° a ordem em que as fun√ß√µes em nosso programa ser√£o executadas agora. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">Itera√ß√µes de loop de eventos</font></i> <br><br>  Por que isso est√° acontecendo assim? <br><br><h2>  <font color="#3AC1EF">Fila de eventos</font> </h2><br>  Quando a fun√ß√£o <code>setTimeout()</code> √© chamada, o navegador ou a plataforma Node.js. inicia um timer.  Depois que o timer funciona (no nosso caso, isso acontece imediatamente, j√° que o definimos como 0), a fun√ß√£o de retorno de chamada passada para <code>setTimeout()</code> entra na Fila de Eventos. <br><br>  A fila de eventos, quando se trata do navegador, inclui eventos iniciados pelo usu√°rio - eventos causados ‚Äã‚Äãpor cliques do mouse nos elementos da p√°gina, eventos que s√£o acionados quando os dados s√£o inseridos pelo teclado.  Os manipuladores de <code>onload</code> DOM <code>onload</code> como <code>onload</code> , fun√ß√µes chamadas ao receber respostas para solicita√ß√µes ass√≠ncronas para carregar dados, est√£o imediatamente l√°.  Aqui eles est√£o esperando sua vez de processar. <br><br>  O loop de eventos d√° prioridade ao que est√° na pilha de chamadas.  Primeiro, ele faz tudo o que consegue encontrar na pilha e, depois que a pilha est√° vazia, continua processando o que est√° na fila de eventos. <br><br>  N√£o precisamos esperar at√© que uma fun√ß√£o como <code>setTimeout()</code> termine de funcionar, pois fun√ß√µes semelhantes s√£o fornecidas pelo navegador e elas usam seus pr√≥prios fluxos.  Assim, por exemplo, definindo o timer para 2 segundos usando a fun√ß√£o <code>setTimeout()</code> , voc√™ n√£o deve, depois de interromper a execu√ß√£o de outro c√≥digo, aguardar esses 2 segundos, pois o timer funciona fora do seu c√≥digo. <br><br><h2>  <font color="#3AC1EF">Fila de tarefas do ES6</font> </h2><br>  O ECMAScript 2015 (ES6) introduziu o conceito de fila de tarefas, que √© usado por promessas (elas tamb√©m apareceram no ES6).  Gra√ßas √† fila de tarefas, o resultado da execu√ß√£o da fun√ß√£o ass√≠ncrona pode ser usado o mais r√°pido poss√≠vel, sem a necessidade de aguardar a limpeza da pilha de chamadas. <br><br>  Se uma promessa for resolvida antes do final da fun√ß√£o atual, o c√≥digo correspondente ser√° executado imediatamente ap√≥s a conclus√£o da fun√ß√£o atual. <br><br>  Eu encontrei uma analogia interessante para o que estamos falando.  Isso pode ser comparado a uma montanha-russa em um parque de divers√µes.  Depois de subir a colina e querer faz√™-lo novamente, voc√™ pega um ingresso e entra no final da fila.  √â assim que a fila de eventos funciona.  Mas a fila de trabalhos parece diferente.  Esse conceito √© semelhante a um bilhete com desconto, que lhe d√° o direito de fazer a pr√≥xima viagem imediatamente depois de terminar a anterior. <br><br>  Considere o seguinte exemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span>   resolve(<span class="hljs-string"><span class="hljs-string">'should be right after baz, before bar'</span></span>) ).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(resolve)) baz() } foo()</code> </pre> <br>  Aqui est√° o que ser√° produzido ap√≥s sua execu√ß√£o: <br><br><pre> <code class="hljs pgsql">foo baz should be right <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> baz, <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> bar bar</code> </pre> <br>  O que voc√™ pode ver aqui demonstra uma diferen√ßa s√©ria entre promessas (e a constru√ß√£o ass√≠ncrona / aguardada, que √© baseada nelas) e fun√ß√µes ass√≠ncronas tradicionais, cuja execu√ß√£o √© organizada usando <code>setTimeout()</code> ou outras APIs da plataforma usada. <br><br><h2>  <font color="#3AC1EF">process.nextTick ()</font> </h2><br>  O m√©todo <code>process.nextTick()</code> interage com o loop de eventos de uma maneira especial.  Um tick √© um √∫nico ciclo completo de eventos.  Passando a fun√ß√£o para o m√©todo <code>process.nextTick()</code> , informamos ao sistema que essa fun√ß√£o precisa ser chamada ap√≥s a conclus√£o da itera√ß√£o atual do loop de eventos, antes do in√≠cio da pr√≥xima.  O uso desse m√©todo se parece com o seguinte: <br><br><pre> <code class="hljs javascript">process.nextTick(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// -  })</span></span></code> </pre> <br>  Suponha que um loop de eventos esteja ocupado executando c√≥digo para a fun√ß√£o atual.  Quando essa opera√ß√£o for conclu√≠da, o mecanismo JavaScript executar√° todas as fun√ß√µes passadas para <code>process.nextTick()</code> durante a opera√ß√£o anterior.  Usando esse mecanismo, nos esfor√ßamos para garantir que uma determinada fun√ß√£o seja executada de forma ass√≠ncrona (ap√≥s a fun√ß√£o atual), mas o mais r√°pido poss√≠vel, sem coloc√°-la na fila. <br><br>  Por exemplo, se voc√™ usar a constru√ß√£o <code>setTimeout(() =&gt; {}, 0)</code> , a fun√ß√£o ser√° executada na pr√≥xima itera√ß√£o do loop de eventos, ou seja, muito mais tarde do que ao usar <code>process.nextTick()</code> na mesma situa√ß√£o.  Esse m√©todo deve ser usado quando for necess√°rio garantir a execu√ß√£o de algum c√≥digo no in√≠cio da pr√≥xima itera√ß√£o do loop de eventos. <br><br><h2>  <font color="#3AC1EF">setImmediate ()</font> </h2><br>  Outra fun√ß√£o fornecida pelo Node.js para execu√ß√£o ass√≠ncrona de c√≥digo √© <code>setImmediate()</code> .  Veja como us√°-lo: <br><br><pre> <code class="hljs javascript">setImmediate(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   })</span></span></code> </pre> <br>  A fun√ß√£o de retorno de chamada passada para <code>setImmediate()</code> ser√° executada na pr√≥xima itera√ß√£o do loop de eventos. <br><br>  Qual a diferen√ßa entre <code>setImmediate()</code> e <code>setTimeout(() =&gt; {}, 0)</code> (ou seja, de um timer que deve funcionar o mais r√°pido poss√≠vel) e de <code>process.nextTick()</code> ? <br><br>  A fun√ß√£o passada para <code>process.nextTick()</code> ser√° executada ap√≥s a itera√ß√£o atual do loop de eventos ser conclu√≠da.  Ou seja, essa fun√ß√£o sempre ser√° executada antes da fun√ß√£o cuja execu√ß√£o √© agendada usando <code>setTimeout()</code> ou <code>setImmediate()</code> . <br><br>  Chamar a fun√ß√£o <code>setTimeout()</code> com um atraso definido de 0 ms √© muito semelhante a chamar <code>setImmediate()</code> .  A ordem de execu√ß√£o das fun√ß√µes transferidas para elas depende de v√°rios fatores, mas em ambos os casos, os retornos de chamada ser√£o chamados na pr√≥xima itera√ß√£o do loop de eventos. <br><br><h2>  <font color="#3AC1EF">Temporizadores</font> </h2><br>  J√° falamos sobre a fun√ß√£o <code>setTimeout()</code> , que permite agendar chamadas para os retornos de chamada passados ‚Äã‚Äãpara ela.  Vamos demorar um pouco para descrever mais detalhadamente seus recursos e considerar outra fun√ß√£o, <code>setInterval()</code> , semelhante a ela.  No Node.js, as fun√ß√µes para trabalhar com cron√¥metros est√£o inclu√≠das no m√≥dulo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cron√¥metro</a> , mas voc√™ pode us√°-las sem conectar esse m√≥dulo no c√≥digo, pois s√£o globais. <br><br><h3>  <font color="#3AC1EF">‚ñç fun√ß√£o setTimeout ()</font> </h3><br>  Lembre-se de que, quando voc√™ chama a fun√ß√£o <code>setTimeout()</code> , ela recebe um retorno de chamada e o tempo, em milissegundos, ap√≥s o qual o retorno de chamada ser√° chamado.  Considere um exemplo: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">50</span></span>  }, <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br>  Aqui passamos <code>setTimeout()</code> nova fun√ß√£o que √© imediatamente descrita, mas aqui podemos usar a fun√ß√£o existente passando <code>setTimeout()</code> seu nome e um conjunto de par√¢metros para execut√°-la.  √â assim: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstParam, secondParam</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } //   2  setTimeout(myFunction, 2000, firstParam, secondParam)</span></span></code> </pre> <br>  A fun√ß√£o <code>setTimeout()</code> retorna um identificador de timer.  Geralmente, ele n√£o √© usado, mas voc√™ pode salv√°-lo e, se necess√°rio, excluir o cron√¥metro se o retorno de chamada agendado n√£o for mais necess√°rio: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> id = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      2  }, 2000) //  ,       clearTimeout(id)</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">Delay Atraso zero</font> </h3><br>  Nas se√ß√µes anteriores, usamos <code>setTimeout()</code> , passando-o como o tempo ap√≥s o qual √© necess√°rio chamar o retorno de chamada, <code>0</code> .  Isso significava que o retorno de chamada seria chamado o mais r√°pido poss√≠vel, mas ap√≥s a conclus√£o da fun√ß√£o atual: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'after '</span></span>) }, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">' before '</span></span>)</code> </pre> <br>  Esse c√≥digo produzir√° o seguinte: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">after</span></span></code> </pre> <br>  Essa t√©cnica √© especialmente √∫til em situa√ß√µes em que, ao executar tarefas computacionais pesadas, eu n√£o gostaria de bloquear o thread principal, permitindo que outras fun√ß√µes sejam executadas, dividindo essas tarefas em v√°rios est√°gios, executadas como chamadas <code>setTimeout()</code> . <br><br>  Se <code>setImmediate()</code> fun√ß√£o <code>setImmediate()</code> acima, ela √© padr√£o no Node.js, o que n√£o pode ser dito sobre navegadores (√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implementada</a> no IE e Edge, mas n√£o em outros). <br><br><h3>  <font color="#3AC1EF">‚ñç fun√ß√£o setInterval ()</font> </h3><br>  A fun√ß√£o <code>setInterval()</code> √© semelhante a <code>setTimeout()</code> , mas h√° diferen√ßas entre eles.  Em vez de executar o retorno de chamada passado a ele uma vez, <code>setInterval()</code> periodicamente, com o intervalo especificado, chamar√° esse retorno de chamada.  Idealmente, isso continuar√° at√© o momento em que o programador interromper explicitamente esse processo.  Veja como usar esse recurso: <br><br><pre> <code class="hljs javascript">setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  Um retorno de chamada passado para a fun√ß√£o mostrada acima ser√° chamado a cada 2 segundos.  Para fornecer a possibilidade de interromper esse processo, voc√™ precisa obter o identificador de timer retornado por <code>setInterval()</code> e usar o comando <code>clearInterval()</code> : <br><br><pre> <code class="hljs lisp">const id = setInterval(() =&gt; { //   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) clearInterval(<span class="hljs-name"><span class="hljs-name">id</span></span>)</code> </pre> <br>  Uma t√©cnica comum √© chamar <code>clearInterval()</code> dentro do retorno de chamada passado para <code>setInterval()</code> quando uma determinada condi√ß√£o for atendida.  Por exemplo, o c√≥digo a seguir ser√° executado periodicamente at√© que a propriedade <code>App.somethingIWait</code> esteja <code>App.somethingIWait</code> para <code>arrived</code> : <br><br><pre> <code class="hljs lisp">const interval = setInterval(<span class="hljs-name"><span class="hljs-name">function</span></span>() { if (<span class="hljs-name"><span class="hljs-name">App</span></span>.somethingIWait === 'arrived') {   clearInterval(<span class="hljs-name"><span class="hljs-name">interval</span></span>)   //    -  ,   -    } }, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">Setting Configura√ß√£o recursiva setTimeout ()</font> </h3><br>  A fun√ß√£o <code>setInterval()</code> chamar√° o retorno de chamada passado a cada <code>n</code> milissegundos, sem se preocupar se esse retorno de chamada foi conclu√≠do ap√≥s a chamada anterior. <br><br>  Se cada chamada para esse retorno de chamada sempre exigir o mesmo tempo menor que <code>n</code> , n√£o haver√° problemas aqui. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f0/66d/192/2f066d192a047c90e90f45d69a66002e.png"></div><br>  <i><font color="#999999">Chamada de retorno periodicamente, cada sess√£o de execu√ß√£o leva o mesmo tempo, dentro do intervalo entre as chamadas</font></i> <br><br>  Talvez seja necess√°rio um tempo diferente para concluir um retorno de chamada, que ainda √© menor que <code>n</code> .  Se, por exemplo, estamos falando sobre executar determinadas opera√ß√µes de rede, essa situa√ß√£o √© bastante esperada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/7e7/fb2/73c7e7fb2a0a687c0f84707e5f1e13e1.png"></div><br>  <i><font color="#999999">Chamada de retorno de chamada peri√≥dica, cada sess√£o de execu√ß√£o leva um tempo diferente, caindo entre as chamadas</font></i> <br><br>  Ao usar <code>setInterval()</code> , uma situa√ß√£o pode surgir quando o retorno de chamada leva mais de <code>n</code> , o que leva √† conclus√£o da pr√≥xima chamada antes da conclus√£o da anterior. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41a/007/220/41a00722099daaf6012792aeeb1ccd93.png"></div><br>  <i><font color="#999999">Chamada de retorno periodicamente, cada sess√£o leva um tempo diferente, que √†s vezes n√£o se encaixa no intervalo entre as chamadas</font></i> <br><br>  Para evitar essa situa√ß√£o, voc√™ pode usar a t√©cnica de configura√ß√£o do timer recursivo usando <code>setTimeout()</code> .  O ponto √© que a pr√≥xima chamada de retorno de chamada √© planejada ap√≥s a conclus√£o da chamada anterior: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    setTimeout(myFunction, 1000) } setTimeout( myFunction() }, 1000)</span></span></code> </pre> <br>  Com essa abordagem, o seguinte cen√°rio pode ser implementado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3dc/4ec/442/3dc4ec4427764f48e8d68e00f409cebd.png"></div><br>  <i><font color="#999999">Uma chamada recursiva para setTimeout () para agendar a execu√ß√£o de retorno de chamada</font></i> <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Hoje falamos sobre os mecanismos internos do Node.js, como o loop de eventos, a pilha de chamadas e discutimos o trabalho com cron√¥metros que permitem agendar a execu√ß√£o do c√≥digo.  Da pr√≥xima vez, vamos nos aprofundar no t√≥pico de programa√ß√£o ass√≠ncrona. <br><br>  <b>Caros leitores!</b>  Voc√™ encontrou situa√ß√µes em que teve que usar process.nextTick ()? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt424553/">https://habr.com/ru/post/pt424553/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt424537/index.html">Sberbank lan√ßou seu pr√≥prio operador, SberMobile</a></li>
<li><a href="../pt424539/index.html">Java 11: novo em String</a></li>
<li><a href="../pt424541/index.html">Hist√≥ria do fiasco do UGJ 2018: como fazer um jogo que ningu√©m gosta (n√£o fa√ßa isso!)</a></li>
<li><a href="../pt424543/index.html">Java 11 / JDK 11: Disponibilidade Geral</a></li>
<li><a href="../pt424551/index.html">Quente e tubo: cinco balalaikas sobre a tecnologia de √°udio magn√©tico</a></li>
<li><a href="../pt424555/index.html">Manual do Node.js., Parte 7: Programa√ß√£o ass√≠ncrona</a></li>
<li><a href="../pt424557/index.html">Guia do Node.js, parte 8: protocolos HTTP e WebSocket</a></li>
<li><a href="../pt424559/index.html">Resist√™ncia ao Big Data 1 ou Joe indescrit√≠vel. Anonimato na Internet, anti-detec√ß√£o, anti-rastreamento para anti-voc√™ e anti-n√≥s</a></li>
<li><a href="../pt424563/index.html">Beeline envia detalhes de conversas para estranhos</a></li>
<li><a href="../pt424565/index.html">Vis√£o geral: digitaliza√ß√£o 3D de instala√ß√µes imobili√°rias</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>