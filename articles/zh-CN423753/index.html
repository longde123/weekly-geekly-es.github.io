<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦄 👩🏾‍🚀 🎉 确保授权令牌的安全 👩🏽‍🔧 🧝🏿 🤚🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi％用户名％。 无论报告的主题是什么，在会议上都不断问我同样的问题-“如何在用户的设备上安全存储令牌？”。 通常，我会尝试回答，但时间不允许充分揭示主题。 通过这篇文章，我想完全解决这个问题。 

 我分析了十几个应用程序，以了解它们如何与令牌一起使用。 我分析的所有应用程序都处理了关键数据，并允...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>确保授权令牌的安全</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423753/">  Hi％用户名％。 无论报告的主题是什么，在会议上都不断问我同样的问题-“如何在用户的设备上安全存储令牌？”。 通常，我会尝试回答，但时间不允许充分揭示主题。 通过这篇文章，我想完全解决这个问题。 <br><a name="habracut"></a><br> 我分析了十几个应用程序，以了解它们如何与令牌一起使用。 我分析的所有应用程序都处理了关键数据，并允许我设置输入的个人识别码作为附加保护。 让我们看一下最常见的错误： <br><br><ul><li> 将PIN码与RefreshToken一起发送到API，以确认身份验证并接收新令牌。  -不好，RefreshToken在本地存储中不安全，可以物理访问设备或备份，可以将其删除，而恶意软件也可以做到这一点。 </li><li>使用RefreshToken将Pin代码保存在消息中，然后对Pin代码进行本地验证，然后将RefreshToken发送到API。  -一场噩梦，RefreshToken和图钉不安全，这使得它们无法被提取，此外，另一个矢量出现，提示绕过本地身份验证。 </li><li> 带有密码的错误的RefreshToken加密，这使您可以从密文恢复密码和RefreshToken。  -先前错误的特殊情况，利用起来稍微复杂一些。 但是请注意，这是正确的方法。 </li></ul><br> 在查看了常见错误之后，您可以继续思考在应用程序中安全存储令牌的逻辑。 值得从应用程序运行期间与身份验证/授权关联的基本资产入手，并提出一些要求： <br><br>  <b>凭据</b> （（用户名+密码））用于验证系统中的用户。 <br>  +密码永远不会存储在设备上，发送到API后应立即从RAM中清除 <br>  +不会在HTTP请求的查询参数中通过GET方法传输，而是使用POST请求 <br>  +键盘缓存已禁用，无法使用密码处理文本字段 <br>  +剪贴板被禁用，用于包含密码的文本字段 <br>  +密码不会通过用户界面公开（使用星号），并且密码不会进入屏幕截图 <br><br>  <b>AccessToken-</b>用于确认用户授权。 <br>  +从不存储在长期存储器中，仅存储在RAM中 <br>  +不会在HTTP请求的查询参数中通过GET方法传输，而是使用POST请求 <br><br>  <b>RefreshToken-</b>用于获取新的AccessToken + RefreshToken捆绑包。 <br>  +不会以任何形式存储在RAM中，在从API接收并保存到长期存储器中或从长期存储器接收并使用后，应立即将+从存储器中删除+ <br>  +仅以加密形式存储在长期内存中 <br>  +使用魔术和某些规则用销子加密（规则将在下面描述），如果未设置销子，则根本不保存 <br>  +不会在HTTP请求的查询参数中通过GET方法传输，而是使用POST请求 <br><br>  <b>PIN</b> （通常是4或6位数字）-用于加密/解密RefreshToken。 <br>  +从未存储在设备上的任何位置，使用后应立即从RAM中清除 <br>  +永远不会离开应用程序限制，这些限制不会在任何地方传输 <br>  +仅用于加密/解密RefreshToken <br><br>  <b>OTP</b>是2FA的一次性代码。 <br>  + OTP永远不会存储在设备上，发送到API后应立即从RAM中清除 <br>  +不会在HTTP请求的查询参数中通过GET方法传输，而是使用POST请求 <br>  +禁用键盘缓存以处理OTP的文本字段 <br>  +剪贴板已禁用，用于包含OTP的文本字段 <br>  + OTP不会进入屏幕截图 <br>  +应用程序在进入后台时从屏幕上删除OTP <br><br> 现在让我们继续进行密码学的<s>魔力</s> 。 主要要求是，在任何情况下都不应允许实施这样的RefreshToken加密机制，在该机制中可以在本地验证解密结果。 就是说，如果攻击者拥有密文，则他应该不能领取密钥。 唯一的验证者应该是API。 这是在发生蛮力攻击时限制密钥选择尝试和使令牌失效的唯一方法。 <br><br> 我将举一个很好的例子，假设我们要加密UUID <br><blockquote>  aec27f0f-b8a3-43cb-b076-e075a095abfe </blockquote> 使用这组AES / CBC / PKCS5Padding，并使用PIN作为密钥。 看起来算法不错，一切都基于准则，但是有一个关键点-关键包含很少的熵。 让我们看看这会导致什么： <br><br><ol><li> 填充-由于我们的令牌占用36个字节，并且AES是具有128位块的块加密模式，因此该算法需要将令牌最多完成48个字节（128位的倍数）。 在我们的版本中，将根据PKCS5Padding标准添加尾部，即 每个添加的字节的值等于添加的字节数 <br><blockquote>  01 <br>  02 02 <br>  03 03 03 <br>  04 04 04 04 <br>  05 05 05 05 05 <br>  06 06 06 06 06 06 <br> 等 </blockquote> 我们的最后一块看起来像这样： <br><blockquote>  ... |  61 62 66 65 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C | </blockquote> 还有一个问题，看看这个填充，我们可以过滤掉由错误密钥解密的数据（通过无效的最后一个块），从而从扭曲的堆中确定有效的RefreshToken。 </li><li> 令牌的可预测格式-即使我们将令牌设为128位的倍数（例如，删除连字符）以避免添加填充，我们也会遇到以下问题。 问题在于我们可以收集所有相同的扭曲堆，并确定哪一行属于UUID格式。 规范文本形式的UUID是十六进制格式的32位数字，由连字符分隔为5组8-4-4-4-12 <br>  xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx <br> 其中M是版本，N是选项。 所有这些都足以过滤出使用错误密钥解密的令牌，从而留下合适的UUID RefreshToken格式。 </li></ol><br> 鉴于以上所有内容，您可以继续实施，我选择了一个简单的选项来生成64个随机字节并将它们包装在base64中： <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createRefreshToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] refreshToken = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">64</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); secureRandom.nextBytes(refreshToken); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Base64.getUrlEncoder().withoutPadding() .encodeToString(refreshToken); }</code> </pre> 这是此类令牌的示例： <br><blockquote>  YmI8rF9pwB1KjJAZKY9JzqsCu3kFz4xt4GkRCzXS9-FS_kbN3-CF9RGiRuuGqwqMo-VxFDhgQNmgjlQFD2GvbA </blockquote> 现在让我们看看它的算法外观（在Android和iOS上，算法是相同的）： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String ALGORITHM = <span class="hljs-string"><span class="hljs-string">"AES"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String CIPHER_SUITE = <span class="hljs-string"><span class="hljs-string">"AES/CBC/NoPadding"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> AES_KEY_SIZE = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> AES_BLOCK_SIZE = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encryptToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String token, String pin)</span></span></span><span class="hljs-function"> </span></span>{ decodedToken = decodeToken(token); <span class="hljs-comment"><span class="hljs-comment">//   rawPin = pin.getBytes(); byte[] iv = generate(AES_BLOCK_SIZE); //      CBC byte[] salt = generate(AES_KEY_SIZE); //       byte[] key = kdf.deriveKey(rawPin, salt, AES_KEY_SIZE); //  -    Cipher cipher = Cipher.getInstance(CIPHER_SUITE); //    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, ALGORITHM), new IvParameterSpec(iv)); return cipher.doFinal(token); } public byte[] decodeToken(String token) { byte[] rawToken = token.getBytes(); return Base64.getUrlDecoder().decode(rawToken); } public final byte[] generate(int size) { byte[] random = new byte[size]; (new SecureRandom()).nextBytes(random); return random; }</span></span></code> </pre><br> 哪些行值得关注： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String CIPHER_SUITE = <span class="hljs-string"><span class="hljs-string">"AES/CBC/NoPadding"</span></span>;</code> </pre><br> 记住，没有填充。 <br><br><pre> <code class="java hljs">decodedToken = decodeToken(token); <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br> 您不能仅以base64表示形式获取并加密令牌，因为该表示形式具有某种格式（请记住，请记住）。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] key = kdf.deriveKey(rawPin, salt, AES_KEY_SIZE); <span class="hljs-comment"><span class="hljs-comment">//  -   </span></span></code> </pre><br> 在输出中，我们得到一个大小为AES_KEY_SIZE的密钥，适用于AES算法。 如果pbkdf2寿命很短（在FPGA上并行性很好），则Argon2，SHA-3，Scrypt推荐的任何密钥派生函数都可以用作kdf。 <br><br> 最终的加密令牌可以安全地存储在设备上，而不必担心有人可以窃取它，无论是恶意软件还是不受道德原则影响的实体。 <br><br> 其他一些建议： <br><br><ul><li> 从备份中排除令牌。 </li><li> 在iOS上，使用kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly属性将令牌存储在钥匙串中。 </li><li> 不要在整个应用程序中分散本文中讨论的资产（键，密码，密码等）。 </li><li> 一旦资产变得不必要，就将其覆盖，不要将它们在内存中的保留时间超过必需的时间。 </li><li> 在Android上使用SecureRandom，在iOS上使用SecRandomCopyBytes在加密上下文中生成随机字节。 </li></ul><br> 在存储令牌时，我们检查了一定数量的陷阱，在我看来，开发使用关键数据的应用程序的每个人都应该知道这些陷阱。 如果您有任何疑问，可以在本主题中随时混淆，在评论中提问。 也欢迎对文本发表评论。 <br><br> 参考文献： <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-311：缺少敏感数据的加密</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-327：使用损坏的或有风险的密码算法</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-327：CWE-338：使用加密弱伪随机数生成器（PRNG）</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-598：通过GET请求中的查询字符串进行信息公开</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN423753/">https://habr.com/ru/post/zh-CN423753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN423743/index.html">受控制：VDS服务器磁盘监视工具</a></li>
<li><a href="../zh-CN423745/index.html">使用Python分析开发人员中所需的相关技能</a></li>
<li><a href="../zh-CN423747/index.html">乐高教育提供的新开发工具-来自Microsoft，MIT和其他公司</a></li>
<li><a href="../zh-CN423749/index.html">使新手开发经理失败的8个简单步骤</a></li>
<li><a href="../zh-CN423751/index.html">Java for Playstation 2-可以吗？</a></li>
<li><a href="../zh-CN423759/index.html">金融科技摘要：俄罗斯联邦公民的个人数据，中央银行市场，CloudFlare的一项新服务</a></li>
<li><a href="../zh-CN423763/index.html">Uber Cash教给创新者的是什么</a></li>
<li><a href="../zh-CN423765/index.html">我们正在编写一个RetroOrangePi的MPV播放器的远程控制应用程序</a></li>
<li><a href="../zh-CN423767/index.html">黑客袭击英国航空公司：380,000张客户银行卡被盗</a></li>
<li><a href="../zh-CN423769/index.html">将OpenSSL连接到Mono</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>