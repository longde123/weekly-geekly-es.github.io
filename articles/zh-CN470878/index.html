<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🏭 🕓 🏿 使用Babel创建自定义JavaScript语法结构。 第二部分 🧢 👩🏻‍🤝‍👨🏾 🚣🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，我们将发布使用Babel进行JavaScript语法扩展的翻译的第二部分。 

  

 →头晕目眩 

 解析方式 
 解析器从代码令牌化系统接收令牌列表，并一次检查一个令牌，以构建一个AST。 为了决定如何使用标记，并理解接下来可以使用哪个标记，解析器引用了语言语法的规范。 

 语法规范...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用Babel创建自定义JavaScript语法结构。 第二部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/470878/"> 今天，我们将发布使用Babel进行JavaScript语法扩展的翻译的第二部分。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/i-/ll/wz/i-llwz7io9q0spj7eijn8hokkqe.jpeg"></a> <br><br>  →头晕目眩 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">解析方式</font> </h2><br> 解析器从代码令牌化系统接收令牌列表，并一次检查一个令牌，以构建一个AST。 为了决定如何使用标记，并理解接下来可以使用哪个标记，解析器引用了语言语法的规范。 <br><br> 语法规范如下所示： <br><br><pre><code class="javascript hljs">... ExponentiationExpression -&gt; UnaryExpression                             UpdateExpression ** ExponentiationExpression MultiplicativeExpression -&gt; ExponentiationExpression                             MultiplicativeExpression (<span class="hljs-string"><span class="hljs-string">"*"</span></span> or <span class="hljs-string"><span class="hljs-string">"/"</span></span> or <span class="hljs-string"><span class="hljs-string">"%"</span></span>) ExponentiationExpression AdditiveExpression    -&gt; MultiplicativeExpression                             AdditiveExpression + MultiplicativeExpression                             AdditiveExpression - MultiplicativeExpression ...</code> </pre> <br> 它描述了执行表达式或语句的优先级。 例如，一个<code>AdditiveExpression</code>表达式可以代表以下构造之一： <br><br><ul><li> 表达<code>MultiplicativeExpression</code>表达。 </li><li>  <code>AdditiveExpression</code>表达式，后跟<code>+</code>标记运算符，然后是<code>MultiplicativeExpression</code>表达式。 </li><li>  <code>AdditiveExpression</code>表达式，后跟“ <code>-</code> ”标记，然后是<code>MultiplicativeExpression</code>表达式。 </li></ul><br> 结果，如果我们有表达式<code>1 + 2 * 3</code> ，那么它将看起来像这样： <br><br><pre> <code class="javascript hljs">(AdditiveExpression <span class="hljs-string"><span class="hljs-string">"+"</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (MultiplicativeExpression <span class="hljs-string"><span class="hljs-string">"*"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre> <br> 但事实并非如此： <br><br><pre> <code class="javascript hljs">(MultiplicativeExpression <span class="hljs-string"><span class="hljs-string">"*"</span></span> (AdditiveExpression <span class="hljs-string"><span class="hljs-string">"+"</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br> 使用这些规则的程序将转换为解析器发出的代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-comment"><span class="hljs-comment">// ...  parseAdditiveExpression() {    const left = this.parseMultiplicativeExpression();    //    -  `+`  `-`    if (this.match(tt.plus) || this.match(tt.minus)) {      const operator = this.state.type;      //          this.nextToken();      const right = this.parseMultiplicativeExpression();      //        this.finishNode(        {          operator,          left,          right,        },        'BinaryExpression'      );    } else {      //  MultiplicativeExpression      return left;    }  } }</span></span></code> </pre> <br> 请注意，这是Babel中实际存在的极其简化的版本。 但是我希望这段代码可以使我们说明正在发生的事情的本质。 <br><br> 如您所见，解析器本质上是递归的。 它从最低优先级设计过渡到最高优先级设计。 例如， <code>parseAdditiveExpression</code>调用<code>parseMultiplicativeExpression</code> ，而此构造调用<code>parseExponentiationExpression</code>依此类推。 此递归过程称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">递归下降解析</a> 。 <br><br><h2>  <font color="#3AC1EF">功能this.eat，this.match，this.next</font> </h2><br> 您可能已经注意到，在前面的示例中，使用了一些辅助功能，例如<code>this.eat</code> ， <code>this.match</code> ， <code>this.next</code>等。 这些是Babel解析器的内部功能。 但是，这些功能并非Babel独有；它们通常存在于其他解析器中。 <br><br><ul><li>  <code>this.match</code>函数返回一个布尔值，该布尔值指示当前令牌是否满足指定条件。 </li><li>  <code>this.next</code>函数在令牌列表中向前<code>this.next</code>到下一个令牌。 </li><li>  <code>this.eat</code>函数返回的内容与<code>this.eat</code>函数相同；如果<code>this.match</code>返回<code>true</code> ，则<code>this.match</code>将在返回<code>true</code>之前执行对<code>this.next</code>的调用。 </li><li>  <code>this.lookahead</code>函数使您无需前进即可获取下一个令牌，这有助于对当前节点进行决策。 </li></ul><br> 如果再次查看我们更改的解析器代码，您会发现阅读它变得更加容易： <br><br><pre> <code class="javascript hljs">packages/babel-parser/src/parser/statement.js <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatementParser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionParser</span></span></span><span class="hljs-class"> </span></span>{  parseStatementContent(<span class="hljs-comment"><span class="hljs-comment">/* ...*/</span></span>) {    <span class="hljs-comment"><span class="hljs-comment">// ...    // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment">   match        if (this.match(tt._function)) {      this.next();      // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment">     ,          this.parseFunction();    }  }  // ...  parseFunction(/* ... */) {    // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment">   eat         node.generator = this.eat(tt.star);    node.curry = this.eat(tt.atat);    node.id = this.parseFunctionId();  } }</span></span></code> </pre> <br> 我知道我没有深入解释解析器的功能。 因此， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">到处都是</a> -关于此主题的一些有用资源。 我学到了很多，可以向您推荐。 <br><br> 当我展示出现在AST中的新“ <code>curry</code> ”属性时，您可能对学习如何可视化在Babel AST Explorer中创建的语法感兴趣。 <br><br> 由于我在Babel AST Explorer中添加了一项新功能，使您可以将自己的解析器加载到此AST研究工具中，因此这成为可能。 <br><br> 如果沿着路径<code>packages/babel-parser/lib</code> ，您可以找到解析器的编译版本和代码映射。 在<code>Babel AST Explorer</code>面板中，您可以看到用于加载自己的解析器的按钮。 通过下载<code>packages/babel-parser/lib/index.js</code>您可以可视化使用自己的解析器生成的AST。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/965/5bf/2b7/9655bf2b7ba72e0c61e31a63a29e3f22.gif"></div><br>  <i><font color="#999999">AST可视化</font></i> <br><br><h2>  <font color="#3AC1EF">我们的Babel插件</font> </h2><br> 现在解析器已经完成，让我们为Babel编写一个插件。 <br><br> 但是，也许现在您对我们将如何使用我们自己的Babel解析器有一些疑问，尤其是考虑到我们使用哪种技术堆栈来构建项目。 <br><br> 没错，没有什么可担心的。  Babel插件可以提供解析器功能。 相关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a>可在Babel网站上找到。 <br><br><pre> <code class="javascript hljs">babel-plugin-transformation-curry-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">js</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">import</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">customParser</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> './</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">custom</span></span></span><span class="hljs-function">-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser</span></span></span><span class="hljs-function">'; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">export</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ourBabelPlugin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {    parserOverride(code, opts) {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> customParser.parse(code, opts);    },  }; }</code> </pre> <br> 由于我们创建了Babel解析器的分支，这意味着所有现有的解析器功能以及内置插件将继续正常运行。 <br><br> 消除这些疑虑后，让我们看一下如何制作一个支持currying的函数。 <br><br> 如果您不能满足期望并且已经尝试将我们的插件添加到项目构建系统中，则可能会注意到支持currying的功能已编译为常规功能。 <br><br> 发生这种情况的原因是，在解析和转换代码后，Babel使用<code>@babel/generator</code>从转换后的AST生成代码。 由于<code>@babel/generator</code>对新的<code>curry</code>属性一无所知，因此它只会忽略它。 <br><br> 如果某天支持currying的函数进入了JavaScript标准，那么您可能想做一个PR在<a href="">此处</a>添加新代码。 <br><br> 为了使该函数支持currying，可以将其包装在一个高阶函数<code>currying</code> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">currying</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numParamsRequired = fn.length;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curryFactory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">params</span></span></span><span class="hljs-function">) </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newParams = params.concat(args);      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newParams.length &gt;= numParamsRequired) {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...newParams);      }      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> curryFactory(newParams);    }  }  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> curryFactory([]); }</code> </pre> <br> 如果您对JS中的currying函数机制的实现功能感兴趣，请阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此</a>材料。 <br><br> 结果，我们通过转换支持currying的函数可以做到这一点： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   function @@ foo(a, b, c) {  return a + b + c; } //    const foo = currying(function foo(a, b, c) {  return a + b + c; })</span></span></code> </pre> <br> 目前，我们将不关注JavaScript中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引发函数</a>的机制，该机制使您可以在定义函数之前调用<code>foo</code> 。 <br><br> 转换代码如下所示： <br><br><pre> <code class="javascript hljs">babel-plugin-transformation-curry-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">js</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">export</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ourBabelPlugin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {    <span class="hljs-comment"><span class="hljs-comment">// ... &lt;i&gt;    visitor: {      FunctionDeclaration(path) {        if (path.get('curry').node) {          // const foo = curry(function () { ... });          path.node.curry = false;          path.replaceWith(            t.variableDeclaration('const', [              t.variableDeclarator(                t.identifier(path.get('id.name').node),                t.callExpression(t.identifier('currying'), [                  t.toExpression(path.node),                ])              ),            ])          );        }      },    },&lt;/i&gt;  }; }</span></span></code> </pre> <br> 如果您阅读了有关Babel转换的材料，您将更容易弄清楚。 <br><br> 现在，我们面临着如何为该机制提供对<code>currying</code>函数的访问权的问题。 在这里，您可以使用以下两种方法之一。 <br><br><h3>  <font color="#3AC1EF">▍方法1：可以假设在全局范围内声明了currying函数</font> </h3><br> 如果是这样，则该工作已经完成。 <br><br> 如果在执行编译后的代码时发现未定义<code>currying</code>函数，那么我们将遇到一条错误消息，看起来像“ <code>currying is not defined</code> ”。 它与消息“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">未定义regeneratorRuntime</a> ”非常相似。 <br><br> 因此，如果有人使用您的<code>babel-plugin-transformation-curry-function</code> ，则可能需要通知他，他需要安装<code>currying</code> polyfill以确保此插件正常工作。 <br><br><h3>  <font color="#3AC1EF">▍方法2：可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">babel</a> / helpers</font> </h3><br> 您可以在<code>@babel/helpers</code>添加新的辅助函数。 这种发展不太可能与官方的<code>@babel/helpers</code>结合使用。 结果，您将必须找到一种方法来显示<code>@babel/core</code> <code>@babel/helpers</code> ： <br><br><pre> <code class="javascript hljs">package.json {  <span class="hljs-string"><span class="hljs-string">"resolutions"</span></span>: {    <span class="hljs-string"><span class="hljs-string">"@babel/helpers"</span></span>: <span class="hljs-string"><span class="hljs-string">"7.6.0--your-custom-forked-version"</span></span>,  }</code> </pre> <br> 我自己还没有尝试过，但是我相信这种机制会起作用。 如果您尝试它并遇到问题，我将很乐意<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讨论</a> 。 <br><br>  <code>@babel/helpers</code>新的helper函数非常简单。 <br><br> 首先，转到<a href="">packages / babel-helpers / src / helpers.js文件，</a>并添加一个新条目： <br><br><pre> <code class="javascript hljs">helpers.currying = helper(<span class="hljs-string"><span class="hljs-string">"7.6.0"</span></span>)<span class="hljs-string"><span class="hljs-string">`  export default function currying(fn) {    const numParamsRequired = fn.length;    function curryFactory(params) {      return function (...args) {        const newParams = params.concat(args);        if (newParams.length &gt;= numParamsRequired) {          return fn(...newParams);        }        return curryFactory(newParams);      }    }    return curryFactory([]);  } `</span></span>;</code> </pre> <br> 描述辅助功能时，会指出所需的版本<code>@babel/core</code> 。 这里的一些困难可能是由于<code>currying</code>函数的<code>export default</code>引起的。 <br><br> 要使用一个辅助函数，只需调用<code>this.addHelper()</code> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ... path.replaceWith(  t.variableDeclaration('const', [    t.variableDeclarator(      t.identifier(path.get('id.name').node),      t.callExpression(this.addHelper("currying"), [        t.toExpression(path.node),      ])    ),  ]) );</span></span></code> </pre> <br> 如有必要， <code>this.addHelper</code>命令将在文件顶部嵌入帮助程序功能，并返回一个<code>Identifier</code>已实现功能的<code>Identifier</code> 。 <br><br><h2>  <font color="#3AC1EF">注意事项</font> </h2><br> 我参与Babel的研究已经有一段时间了，但是我还没有为解析器添加支持新JavaScript语法的功能。 我主要致力于修复错误和改进与官方语言功能有关的内容。 <br><br> 但是，一段时间以来，我一直沉迷于向该语言添加新的语法构造的想法。 结果，我决定编写有关它的材料并尝试。 令人欣喜的是，它们都能按预期运行。 <br><br> 控制您使用的语言的语法的能力是强大的灵感来源。 通过实现一些复杂的结构，这使得编写比以前更少的代码或编写更简单的代码成为可能。 将简单代码转换为复杂结构的机制是自动化的，并已转移到编译阶段。 这让人想起<code>async/await</code>如何解决地狱回调和承诺长链的问题。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 在这里，我们讨论了如何修改Babel解析器的功能，编写了自己的代码转换插件，简要讨论了<code>@babel/generator</code>和使用<code>@babel/helpers</code>创建帮助器函数。 关于代码转换的信息仅示意性给出。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关它们的更多信息。 <br><br> 在此过程中，我们谈到了解析器的某些功能。 如果您对这个主题感兴趣- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">那里</a> -对您有用的资源。 <br><br> 我们执行的操作序列与将新的JavaScript功能提交给TC39时所执行的过程的一部分非常相似。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a> TC39存储库页面，您可以在其中找到有关当前报价的信息。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里，</a>您可以找到有关如何使用类似优惠的更多详细信息。 当提出一项新的JavaScript功能时，提供此功能的人通常会编写polyfill或通过分叉Babel进行演示以证明该句子有效。 如您所见，创建新的JS功能过程中，创建解析器的分叉或编写polyfill并不是最困难的部分。 很难确定创新的主题领域，难以计划和思考使用创新的方案和边界案例； 很难收集JavaScript程序员社区成员的意见和建议。 因此，我要感谢所有能够提供TC39新JavaScript功能从而开发这种语言的人。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a> GitHub上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>页面，可让您大致了解我们在这里所做的事情。 <br><br>  <b>亲爱的读者们！</b> 您是否曾经想扩展JavaScript的语法？ <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN470878/">https://habr.com/ru/post/zh-CN470878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN470868/index.html">第一个字节的时间：这是什么，为什么重要</a></li>
<li><a href="../zh-CN470870/index.html">预加载字体</a></li>
<li><a href="../zh-CN470872/index.html">用于研究难以置信的快速Web应用程序的性能指标</a></li>
<li><a href="../zh-CN470874/index.html">优化Wikipedia上的JavaScript加载</a></li>
<li><a href="../zh-CN470876/index.html">使用Babel创建自定义JavaScript语法结构。 第一部分</a></li>
<li><a href="../zh-CN470880/index.html">游戏机制。 冒险，零和引人注目的言语治疗概念</a></li>
<li><a href="../zh-CN470882/index.html">您为什么要抓住我的鼠标或将棋盘游戏作为社交互动的典范</a></li>
<li><a href="../zh-CN470884/index.html">在比特币区块链中写入和读取数据</a></li>
<li><a href="../zh-CN470888/index.html">个人数据保护领域的俄罗斯和国际法规</a></li>
<li><a href="../zh-CN470892/index.html">在FPGA上轻松实现小型CAM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>