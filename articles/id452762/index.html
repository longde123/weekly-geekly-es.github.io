<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧖🏾 💵 🍺 MVCC-7. Pembersihan otomatis 👱 ✌🏻 🧜🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Biarkan saya mengingatkan Anda bahwa kami mulai dengan masalah yang berkaitan dengan isolasi , melakukan penyimpangan tentang pengorganisasian data pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-7. Pembersihan otomatis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452762/">  Biarkan saya mengingatkan Anda bahwa kami mulai dengan masalah yang berkaitan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">isolasi</a> , melakukan penyimpangan tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengorganisasian data pada tingkat rendah</a> , berbicara secara rinci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang versi baris</a> dan bagaimana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">snapshot</a> diperoleh dari versi. <br><br>  Kemudian kami melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembersihan dalam halaman</a> (dan pembaruan HOT), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembersihan rutin</a> , tetapi hari ini kami melihat pembersihan otomatis. <br><br><h1>  Pembersihan otomatis (autovacuum) </h1><br>  Kami telah mengatakan bahwa pembersihan biasa dalam kondisi normal (ketika tidak ada yang memegang cakrawala transaksi untuk waktu yang lama) harus mengatasi pekerjaannya.  Pertanyaannya adalah seberapa sering menyebutnya. <br><br>  Jika Anda membersihkan meja ganti terlalu jarang, itu akan tumbuh lebih besar dari yang Anda inginkan.  Selain itu, untuk pembersihan berikutnya, mungkin diperlukan beberapa kali melewati indeks jika terlalu banyak perubahan telah terakumulasi. <br><br>  Jika Anda membersihkan tabel terlalu sering, maka alih-alih pekerjaan yang bermanfaat, server akan terus terlibat dalam pemeliharaan - juga tidak baik. <br><br>  Perhatikan bahwa memulai pembersihan terjadwal secara teratur tidak menyelesaikan masalah, karena beban dapat berubah seiring waktu.  Jika meja mulai diperbarui lebih aktif, maka itu harus dibersihkan lebih sering. <br><br>  Pembersihan otomatis hanyalah mekanisme yang memungkinkan Anda untuk mulai membersihkan, tergantung pada aktivitas perubahan dalam tabel. <br><a name="habracut"></a><br>  Ketika <em>pembersihan otomatis</em> diaktifkan (parameter konfigurasi <em>autovacuum</em> ), proses peluncur autovacuum selalu ada dalam sistem, yang berencana untuk bekerja, dan proses kerja pekerja autovacuum terlibat dalam pembersihan nyata, beberapa contoh yang dapat bekerja secara paralel. <br><br>  Proses peluncur autovacuum menyusun daftar database di mana ada aktivitas apa pun.  Aktivitas ditentukan oleh statistik, dan untuk itu dikumpulkan, parameter <em>track_counts</em> harus ditetapkan.  Jangan pernah mematikan <em>autovacuum</em> dan <em>track_counts</em> , jika tidak <em>pembersihan</em> <em>otomatis</em> tidak akan berfungsi. <br><br>  Setelah di <em>autovacuum_naptime,</em> proses peluncur autovacuum dimulai (menggunakan proses postmaster) alur kerja untuk setiap database dalam daftar.  Dengan kata lain, jika ada aktivitas dalam database, maka alur kerja akan masuk ke dalamnya dengan interval <em>autovacuum_naptime</em> .  Untuk melakukan ini, jika ada beberapa database aktif (potongan N), maka proses kerja diluncurkan N kali lebih sering daripada <em>autovacuum_naptime</em> .  Tetapi pada saat yang sama, jumlah total alur kerja yang bekerja secara bersamaan dibatasi oleh parameter <em>autovacuum_max_workers</em> . <br><br>  Setelah dimulai, alur kerja terhubung ke database yang ditentukan olehnya dan mulai dengan membangun daftar: <br><br><ul><li>  semua tabel, tampilan terwujud, dan tabel roti panggang yang perlu dibersihkan, </li><li>  semua tabel dan representasi terwujud yang memerlukan analisis (tabel roti tidak dianalisis, karena mereka selalu diakses oleh indeks). </li></ul><br>  Selanjutnya, alur kerja pada gilirannya membersihkan dan / atau menganalisis objek yang dipilih dan berakhir ketika pembersihan selesai. <br><br>  Jika proses belum menyelesaikan semua pekerjaan yang dimaksudkan untuk <em>autovacuum_naptime</em> , proses peluncur autovacuum akan mengirim alur kerja lain ke database yang sama dan mereka akan bekerja bersama.  "Bersama" berarti bahwa proses kedua akan membangun daftar tabel dan mengikutinya.  Dengan demikian, tabel yang berbeda akan diproses secara paralel, tetapi pada tingkat satu tabel tidak ada paralelisme - jika salah satu proses kerja sudah bekerja di atas meja, yang lain akan melewatkannya dan melanjutkan. <br><br><blockquote>  Telah ada diskusi tentang perlunya pemrosesan paralel untuk waktu yang lama, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tambalan</a> belum diadopsi. <br></blockquote><br>  Sekarang mari kita melihat lebih dekat apa yang “perlu dibersihkan” dan “membutuhkan analisis”. <br><br><h1>  Meja mana yang perlu dibersihkan </h1><br>  Dipercayai bahwa pembersihan diperlukan jika jumlah versi "mati", yaitu, tidak relevan, melebihi nilai ambang batas yang ditetapkan.  Jumlah versi mati secara konstan dikumpulkan oleh pengumpul statistik dan disimpan di tabel pg_stat_all_tables.  Dan ambangnya diatur oleh dua parameter: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> mendefinisikan nilai absolut (dalam potongan), </li><li>  <em>autovacuum_vacuum_scale_factor</em> menentukan proporsi baris dalam tabel. </li></ul><br>  Rumus terakhir adalah: pembersihan diperlukan jika pg_stat_all_tables.n_dead_tup&gt; = <em>autovacuum_vacuum_threshold</em> + <em>autovacuum_vacuum_valeum_scale_factor</em> * pg_class.reltupes. <br><br>  Pengaturan default ditetapkan <em>autovacuum_vacuum_threshold</em> = 50 dan <br>  <em>autovacuum_vacuum_scale_factor</em> = 0.2.  Parameter utama di sini, tentu saja, adalah <em>autovacuum_vacuum_scale_factor</em> - itu yang penting untuk tabel besar (yaitu, kemungkinan masalah terkait dengan mereka).  Nilai 20% tampaknya sangat berlebihan, kemungkinan besar perlu dikurangi secara signifikan. <br><br>  Nilai parameter optimal dapat bervariasi untuk tabel yang berbeda tergantung pada ukuran dan sifat perubahannya.  Masuk akal untuk menetapkan, secara keseluruhan, nilai-nilai yang memadai, dan - jika perlu - untuk secara khusus mengkonfigurasi parameter di tingkat beberapa tabel menggunakan parameter penyimpanan: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> dan <em>bersulang.autovacuum_vacuum_threshold</em> , </li><li>  <em>autovacuum_vacuum_scale_factor</em> dan <em>bersulang.autovacuum_vacuum_scale_factor</em> . </li></ul><br>  Agar tidak bingung, ini harus dilakukan hanya untuk sejumlah kecil tabel yang menonjol antara lain oleh volume atau intensitas perubahan, dan hanya jika nilai yang ditetapkan secara global tidak cocok. <br><br>  Selain itu, pembersihan otomatis dapat dinonaktifkan di tingkat meja (meskipun sulit untuk memikirkan alasan mengapa ini diperlukan): <br><br><ul><li>  <em>autovacuum_enabled</em> dan <em>bersulang.autovacuum_enabled</em> . </li></ul><br>  Misalnya, terakhir kali kami membuat tabel vakum dengan pembersihan otomatis dinonaktifkan, untuk - untuk tujuan demonstrasi - untuk mengelola pembersihan manual.  Parameter penyimpanan dapat diubah sebagai berikut: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre> <br>  Untuk memformalkan semua hal di atas, kami akan membuat tampilan yang menunjukkan tabel mana yang saat ini perlu dibersihkan.  Ini akan menggunakan fungsi yang mengembalikan nilai parameter saat ini, mengingat bahwa itu dapat diganti pada level tabel: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_value(param <span class="hljs-type"><span class="hljs-type">text</span></span>, reloptions <span class="hljs-type"><span class="hljs-type">text</span></span>[], relkind "char") <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="ruby"><span class="ruby"> SELECT coalesce( --    ,    (SELECT option_value FROM pg_options_to_table(reloptions) WHERE option_name = CASE --  toast-    WHEN relkind = </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'t'</span></span></span><span class="ruby"> THEN </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'toast.'</span></span></span><span class="ruby"> ELSE </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">''</span></span></span><span class="ruby"> </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">END</span></span></span><span class="ruby"> </span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby"> param ), --      current_setting(param) )</span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:</span></span></span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:float</span></span></span><span class="ruby">; $$</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Dan inilah tampilan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_dead_tup dead_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_dead_tup, st.last_autovacuum <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>,<span class="hljs-string"><span class="hljs-string">'t'</span></span>);</code> </pre><br><h1>  Tabel apa yang perlu analisis </h1><br>  Dengan analisis otomatis, situasinya hampir sama.  Dipercaya bahwa analisis diperlukan untuk tabel-tabel yang jumlah baris (sejak analisis terakhir) yang diubah melebihi nilai ambang yang ditentukan oleh dua parameter yang serupa: pg_stat_all_tables.n_mod_since_analyze&gt; = <em>autovacuum_analyze_threshold</em> + <em>autovacuum_analyze_scale_faktor.faktor</em> . <br><br>  Pengaturan analisis otomatis default sedikit berbeda: <em>autovacuum_analyze_threshold</em> = 50 dan <em>autovacuum_analyze_scale_factor</em> = 0,1.  Mereka juga dapat didefinisikan pada tingkat parameter penyimpanan untuk masing-masing tabel: <br><br><ul><li>  <em>autovacuum_analyze_threshold</em> , </li><li>  <em>autovacuum_analyze_scale_factor</em> </li></ul><br>  Karena tabel roti bakar tidak dianalisis, tidak ada parameter yang sesuai untuk mereka. <br><br>  Mari kita buat tampilan untuk analisis: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_mod_since_analyze mod_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_mod_tup, st.last_autoanalyze <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>);</code> </pre><br><h1>  Contoh </h1><br>  Untuk percobaan, kami menetapkan nilai parameter berikut: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> autovacuum_naptime = <span class="hljs-string"><span class="hljs-string">'1s'</span></span>; <span class="hljs-comment"><span class="hljs-comment">--     =&gt; ALTER SYSTEM SET autovacuum_vacuum_scale_factor = 0.03; -- 3% =&gt; ALTER SYSTEM SET autovacuum_vacuum_threshold = 0; =&gt; ALTER SYSTEM SET autovacuum_analyze_scale_factor = 0.02; -- 2% =&gt; ALTER SYSTEM SET autovacuum_analyze_threshold = 0;</span></span></code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br>  Sekarang buat tabel yang mirip dengan yang kita gunakan terakhir kali dan masukkan seribu baris ke dalamnya.  Pembersihan otomatis dinonaktifkan di tingkat meja, dan kami akan menyalakannya sendiri.  Jika ini tidak dilakukan, maka contohnya tidak akan dapat direproduksi, karena pembersihan otomatis dapat bekerja pada waktu yang salah. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id,<span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>) g(id);</code> </pre><br>  Berikut tampilan yang akan kami tampilkan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 0 | (1 row)</code> </pre><br>  Ada dua hal yang harus Anda perhatikan.  Pertama, max_dead_tup = 0, meskipun 3% dari 1000 baris adalah 30 baris.  Faktanya adalah kita belum memiliki statistik di atas meja, karena INSERT sendiri tidak memperbaruinya.  Sampai tabel kita dianalisis, nol akan tetap ada, karena pg_class.reltuples = 0. Namun, mari kita lihat tampilan kedua untuk analisis: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------ public.autovac | 1000 | 0 | (1 row)</code> </pre><br>  Karena tabel telah berubah (ditambahkan) 1000 baris, dan ini lebih dari nol, analisis otomatis akan berfungsi.  Lihat ini: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>);</code> </pre><br>  Setelah jeda singkat, kita melihat bahwa tabel dianalisis dan bukannya nol di max_mod_tup kita melihat 20 baris yang benar: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------------------- public.autovac | 0 | 20 | 2019-05-21 11:59:48.465987+03 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltuples, relpages <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> reltuples | relpages -----------+---------- 1000 | 17 (1 row)</code> </pre><br>  Mari kita kembali ke pembersihan otomatis: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 30 | (1 row)</code> </pre><br>  Max_dead_tup, seperti yang kita lihat, sudah diperbaiki.  Poin kedua yang perlu diperhatikan adalah dead_tup = 0. Statistik menunjukkan bahwa tidak ada versi mati baris dalam tabel ... dan ini benar.  Belum ada yang dibersihkan di meja kami.  Jadi setiap tabel yang digunakan hanya dalam mode append-only tidak akan dihapus dan, oleh karena itu, peta visibilitas tidak akan diperbarui untuk itu.  Dan ini membuat tidak mungkin untuk menggunakan pemindaian indeks secara eksklusif (hanya indeks scan). <br><br>  (Lain kali kita akan melihat bahwa membersihkan cepat atau lambat akan datang ke meja append-only, tetapi ini akan sangat jarang terjadi.) <br><br>  Kesimpulan praktis: jika penting hanya menggunakan pemindaian indeks, Anda mungkin perlu meminta pembersihan manual. <br><br>  Sekarang matikan pembersihan-otomatis lagi dan perbarui 31 baris - satu lebih dari nilai ambang batas. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 31 | 30 | (1 row)</code> </pre><br>  Sekarang kondisi untuk memicu pembersihan otomatis terpenuhi.  Nyalakan pembersihan otomatis dan setelah jeda singkat kita akan melihat bahwa tabel telah diproses: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+------------------------------- public.autovac | 0 | 30 | 2019-05-21 11:59:52.554571+03 (1 row)</code> </pre><br><h1>  Regulasi beban </h1><br>  Pembersihan tidak menghalangi proses lain, karena ia bekerja berdasarkan halaman demi halaman, tetapi tetap menciptakan beban pada sistem dan dapat memiliki efek yang nyata pada kinerja. <br><br><h2>  Regulasi untuk pembersihan rutin </h2><br>  Agar dapat mengontrol intensitas pembersihan dan, akibatnya, pengaruhnya pada sistem, proses bergantian antara pekerjaan dan harapan.  Pembersihan melakukan sekitar <em>vacuum_cost_limit</em> unit kerja konvensional, dan kemudian tertidur pada ms <em>vacuum_cost_delay</em> . <br><br>  Pengaturan default yang ditetapkan <em>vacuum_cost_limit</em> = 200, <em>vacuum_cost_delay</em> = 0. Nol terakhir sebenarnya berarti bahwa pembersihan (normal) tidak tertidur, sehingga nilai spesifik dari <em>vacuum_cost_limit</em> tidak memainkan peran apa pun.  Ini dilakukan dengan alasan bahwa jika administrator harus memulai VACUUM secara manual, maka ia mungkin ingin melakukan pembersihan secepat mungkin. <br><br>  Namun demikian, jika Anda masih mengatur waktu tidur, maka jumlah pekerjaan yang ditentukan dalam <em>vacuum_cost_limit</em> akan terdiri dari biaya bekerja dengan halaman dalam cache buffer.  Setiap akses halaman dievaluasi sebagai berikut: <br><br><ul><li>  jika halaman ditemukan dalam cache buffer, maka <em>vacuum_cost_page_hit</em> = 1; </li><li>  jika tidak ditemukan, maka <em>vacuum_cost_page_miss</em> = 10; </li><li>  jika Anda tidak dapat menemukannya, dan Anda harus mendorong halaman kotor keluar dari buffer, kemudian <em>vacuum_cost_page_dirty</em> = 20. </li></ul><br>  Yaitu, dengan pengaturan <em>vacuum_cost_limit</em> secara default, 200 halaman dari cache, atau 20 halaman dari disk, atau 10 halaman dengan ekstrusi dapat diproses dalam satu duduk.  Jelas bahwa angka-angka ini agak sewenang-wenang, tetapi tidak masuk akal untuk memilihnya lebih tepat. <br><br><h2>  Regulasi untuk pembersihan otomatis </h2><br>  Kontrol beban selama pembersihan otomatis berfungsi sama seperti untuk pembersihan biasa.  Tetapi agar <em>pembersihan</em> manual dan <em>pembersihan</em> <em>otomatis</em> dapat bekerja dengan intensitas berbeda, autoproses memiliki parameter sendiri: <em>autovacuum_vacuum_cost_limit</em> dan <em>autovacuum_vacuum_cost_delay</em> .  Jika parameter ini mengambil nilai -1, maka nilai dari <em>vacuum_cost_limit</em> dan / atau <em>vacuum_cost_delay digunakan</em> . <br><br>  Secara default, <em>autovacuum_vacuum_cost_limit</em> = -1 (yaitu, nilai <em>vacuum_cost_limit</em> = 200 digunakan) dan <em>autovacuum_vacuum_cost_delay</em> = 20ms.  Pada peralatan modern dengan angka-angka ini, pembersihan otomatis akan bekerja sangat, sangat lambat. <br><br>  Dalam versi 12, nilai <em>autovacuum_vacuum_cost_delay</em> akan dikurangi menjadi 2ms, yang dapat dianggap sebagai perkiraan pertama yang lebih tepat. <br><br>  Selain itu, perlu dicatat bahwa batas yang ditetapkan oleh parameter ini adalah umum untuk semua proses kerja.  Dengan kata lain, ketika jumlah proses kerja bersamaan berubah, total beban akan tetap konstan.  Karena itu, jika tugasnya adalah meningkatkan kinerja <em>pembersihan otomatis</em> , maka saat menambahkan alur kerja, ada baiknya meningkatkan <em>autovacuum_vacuum_cost_limit</em> . <br><br><h2>  Penggunaan dan pemantauan memori </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terakhir kali,</a> kami melihat bagaimana pembersihan menggunakan memori RAM dengan ukuran <em>maintenance_work_mem</em> untuk menyimpan pengenal versi dari baris yang akan dibersihkan. <br><br>  Pembersihan otomatis tidak persis sama.  Tetapi ada banyak proses bersamaan jika Anda mengatur <em>autovacuum_max_workers</em> ke nilai yang besar.  Selain itu, semua memori dialokasikan segera dan sepenuhnya, dan bukan karena kebutuhan.  Oleh karena itu, untuk alur kerja <em>pembersihan-otomatis</em> , Anda dapat mengatur batasan Anda sendiri menggunakan parameter <em>autovacuum_work_mem</em> .  Secara default, parameter ini -1, yaitu tidak digunakan. <br><br>  Seperti yang telah disebutkan, pembersihan dapat bekerja dengan jumlah memori minimum.  Tetapi jika indeks dibuat di atas meja, maka nilai <em>maintenance_work_mem</em> kecil dapat menyebabkan pemindaian indeks berulang.  Hal yang sama berlaku untuk pembersihan otomatis.  Idealnya, Anda harus memilih nilai minimum <em>autovacuum_work_mem</em> di mana pemindaian berulang tidak terjadi. <br><br>  Kami melihat bahwa untuk memantau pembersihan Anda dapat menggunakan parameter VERBOSE (tetapi tidak dapat ditentukan untuk pembersihan otomatis) atau tampilan pg_stat_progress_vacuum (tetapi hanya menampilkan informasi saat ini).  Oleh karena itu, cara utama untuk memantau <em>pembersihan otomatis</em> adalah parameter <em>log_autovacuum_min_duration</em> , yang menampilkan informasi dalam log pesan server.  Secara default tidak aktif (diatur ke -1).  Ada alasan untuk mengaktifkan parameter ini (pada nilai 0, informasi tentang semua awal pembersihan otomatis akan ditampilkan) dan amati angkanya. <br><br>  Seperti inilah hasilnya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_autovacuum_min_duration = <span class="hljs-number"><span class="hljs-number">0</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-05-21 11:59:55.675 MSK [9737] LOG: automatic vacuum of table "test.public.autovac": index scans: 0 pages: 0 removed, 18 remain, 0 skipped due to pins, 0 skipped frozen tuples: 31 removed, 1000 remain, 0 are dead but not yet removable, oldest xmin: 4040 buffer usage: 78 hits, 0 misses, 0 dirtied avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s 2019-05-21 11:59:55.676 MSK [9737] LOG: automatic analyze of table "test.public.autovac" system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s</code> </pre><br>  Semua informasi yang diperlukan ada di sini. <br><br>  Ingatlah bahwa seringkali Anda seharusnya tidak menambah ukuran memori, tetapi kurangi ambang batas untuk pembersihan sehingga lebih sedikit data yang diproses pada satu waktu. <br><br>  Mungkin juga masuk akal untuk memantau panjang daftar tabel yang perlu dibersihkan menggunakan tampilan di atas.  Peningkatan panjang daftar akan menunjukkan bahwa pembersihan otomatis tidak punya waktu untuk melakukan tugasnya dan bahwa pengaturan perlu diubah. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Untuk dilanjutkan</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452762/">https://habr.com/ru/post/id452762/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452750/index.html">Nextcloud di dalam dan di luar OpenLiteSpeed: konfigurasikan proxy terbalik</a></li>
<li><a href="../id452752/index.html">BigData buatan rumah. Bagian 1. Praktek Spark Streaming pada gugus AWS</a></li>
<li><a href="../id452754/index.html">19% dari gambar Docker paling populer tidak memiliki kata sandi root</a></li>
<li><a href="../id452756/index.html">Menciptakan Tower Defense in Unity: Enemies</a></li>
<li><a href="../id452760/index.html">Vitamin D. Untuk minum atau tidak minum, itulah pertanyaannya. (Atau cerita tentang bagaimana saya melewati analisis yang tidak saya resepkan)</a></li>
<li><a href="../id452764/index.html">[Peter] Bertemu JUG.ru dengan Sergei Melnikov - Profiling dengan kecepatan superluminal: teori dan praktik</a></li>
<li><a href="../id452766/index.html">Teknologi Streaming progresif, atau cara menonton video 4k melalui jaringan, tanpa friez</a></li>
<li><a href="../id452768/index.html">Cara mendesain produk jika Anda memutuskan untuk memasuki pasar luar negeri</a></li>
<li><a href="../id452772/index.html">5 Teknik Pengujian Lanjut</a></li>
<li><a href="../id452774/index.html">Dell XPS 13 9380: laptop andal dan sangat ringkas untuk bisnis yang serius</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>