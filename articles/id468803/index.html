<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤¶ğŸ½ ğŸ‘¨ğŸ¿ ğŸ‰ Bagaimana Kami Membuat Mesin Workflow Kami â„¹ï¸ ğŸ›¶ ğŸ¦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di DIRECTUM, kami sedang mengembangkan sistem DirectumRX ECM. Elemen inti dari modul Workflow untuk sistem ECM adalah engine. Dia bertanggung jawab un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana Kami Membuat Mesin Workflow Kami</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/468803/">  Di DIRECTUM, kami sedang mengembangkan sistem DirectumRX ECM.  Elemen inti dari modul Workflow untuk sistem ECM adalah engine.  Dia bertanggung jawab untuk mengubah keadaan proses instance (instance) selama siklus hidup.  Sebelum Anda mulai mengembangkan modul Workflow, Anda harus memutuskan: ambil mesin yang sudah jadi atau tulis sendiri.  Awalnya, kami memilih opsi pertama.  Kami mengambil mesin Windows Workflow Foundation (WF), dan secara keseluruhan cocok untuk kami.  Namun seiring waktu, kami menyadari bahwa kami membutuhkan mesin kami sendiri.  Bagaimana ini terjadi, dan apa yang terjadi, saya akan ceritakan di bawah ini. <br><a name="habracut"></a><br><h2>  Mesin tua </h2><br><h3>  Mengapa wf </h3><br>  Kembali pada tahun 2013, ketika tiba saatnya untuk mengembangkan modul Workflow untuk DirectumRX, kami memutuskan untuk mengambil mesin yang sudah jadi.  Dilihat dari Windows Workflow Foundation (WF), ActiveFlow, K2.NET, WorkflowEngine.NET, cDevWorkflow, NetBpm.  Beberapa tidak senang dengan nilai, ada yang mentah, beberapa, pada saat itu, belum didukung untuk waktu yang lama. <br>  Akibatnya, pilihan jatuh pada WF.  Kami kemudian secara aktif menggunakan tumpukan Microsoft (WCF, WPF) dan memutuskan bahwa W lain tidak akan menyakiti kami.  Keuntungan lain adalah status kami sebagai Mitra Pengembangan Aplikasi Microsoft Gold, yang memungkinkan untuk mengembangkan produk menggunakan teknologi Microsoft.  Nah, secara umum, kemampuan mesin cocok untuk kami dan mencakup hampir semua kasus kami. <br><br><h3>  Apa yang salah dengan WF? </h3><br>  Setelah 6 tahun menggunakan WF, kami telah mengakumulasikan sejumlah masalah, dan biaya untuk menyelesaikan masalah ini terlalu tinggi.  Kami mulai berpikir untuk mengembangkan mesin kami sendiri.  Saya akan memberi tahu Anda tentang beberapa di antaranya. <br><br><h4>  Diagnostik mahal dan perbaikan bug </h4><br>  Tahun-tahun berlalu, jumlah instalasi produk dan beban bertambah.  Bug mulai muncul, diagnosis dan koreksi yang membutuhkan banyak sumber daya.  Ini difasilitasi oleh alasan yang kompleks: kurangnya kompetensi, kesalahan desain ketika menanamkan mesin sebelumnya, dan fitur WF. <br>  Kami memiliki cukup kompetensi dasar untuk dibangun di WF DirectumRX, tingkat yang sama sudah cukup untuk menangani bug sederhana.  Untuk kasus yang kompleks, kompetensi menjadi kurang - analisis log, analisis keadaan contoh, dan sebagainya, sulit. <br>  Dimungkinkan untuk mengirim seseorang ke kursus tentang WF, tetapi mereka hampir tidak diajari cara menganalisis keadaan instance dan mengaitkan perubahannya dengan log.  Dan terus terang, tidak ada yang memiliki keinginan khusus untuk meningkatkan keterampilan mereka dengan teknologi yang hampir mati. <br>  Cara lain adalah dengan merekrut seseorang dengan kompetensi yang sesuai.  Tetapi menemukan satu di Izhevsk bukanlah tugas sepele, dan bukan fakta bahwa levelnya cukup untuk menyelesaikan masalah kita. <br>  Bahkan, kita dihadapkan dengan ambang masuk yang tinggi untuk mendukung WF.  Dengan satu atau lain cara, saya pikir kita akan menangani masalah ini, jika bukan karena sejumlah alasan lain. <br>  Masalah lain adalah ketika membuat diagram proses, kami menggunakan notasi kami sendiri.  Lebih visual dan lebih mudah dikembangkan.  Misalnya, WF tidak memungkinkan untuk mengimplementasikan grafik penuh, Anda tidak dapat menggambar buntu, ada fitur menggambar cabang paralel.  Pengembalian untuk ini adalah konversi sirkuit kami ke sirkuit WF, yang tidak begitu sederhana dan memaksakan sejumlah batasan.  Ketika debugging, saya harus menganalisis keadaan sirkuit WF, karena ini, visibilitas hilang, saya harus membandingkan blok dan wajah satu sama lain untuk memahami apa langkah instance itu. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/db/7p/fo/db7pfo4ik9gbjjpge475jbnn8zo.png" alt="gambar"></div><br>  <i><font color="99999">Representasi rangkaian dalam DirectumRX</font></i> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e8/40/o7/e840o7sz-zleiogtdvyzhownh2o.png" alt="gambar"></div><br>  <i><font color="99999">Representasi rangkaian dalam WF</font></i> <br>  Juga, kami dihadapkan dengan fakta bahwa dokumentasi WF menggambarkan repositori instance dengan buruk.  Seperti yang saya tulis di atas, ini diperlukan ketika menganalisis bug untuk memahami keadaan proses contoh.  Selain itu, bagian dari data dienkripsi, yang juga mengganggu analisis. <br><br><h4>  Postgres sebagai DBMS </h4><br>  Selama bertahun-tahun sekarang, ada kecenderungan di Rusia untuk substitusi impor, dan semakin sering salah satu persyaratan untuk platform tersebut adalah dukungan sistem manajemen basis data sumber terbuka (DBMS) atau DBMS produksi dalam negeri.  Paling sering itu Postgres.  Di luar kotak, WF hanya mendukung MS SQL.  Untuk bekerja dengan database lain, Anda bisa menggunakan penyedia pihak ketiga.  Kami memilih dotConnect dari DevArt. <br>  Sementara bebannya ringan, semuanya bekerja dengan baik.  Tapi begitu kami mengendarai sistem di bawah beban, masalah muncul.  WF tiba-tiba bisa berhenti dan berhenti memproses contoh (transaksi selesai), atau semua pesan masuk ke MSMQ Poisoned Queue, dll.  Kami menangani semua masalah ini, tetapi menghabiskan banyak waktu untuk itu.  Tidak ada jaminan bahwa yang baru tidak akan muncul, solusinya harus menghabiskan jumlah yang sama. <br><br><h4>  Peduli pada inti bersih </h4><br>  Setelah Microsoft mengumumkan .Net Core, kami memutuskan bahwa kami secara bertahap akan menuju untuk mencapai cross-platform untuk solusi kami.  Microsoft memutuskan untuk tidak menggunakan WF, yang memblokir cara kami mentransfer modul Workflow ke .Net Core dalam bentuk yang ada.  Kami menyadari bahwa ada port WF tidak resmi di .Net Core, dan di antara mereka bahkan ada dari pengembang WF, tetapi semuanya tidak 100% kompatibel.  Faktor lain adalah penolakan Microsoft untuk mengembangkan .Net.  mendukung .Net Core. <br><br><h2>  Mesin baru </h2><br>  Mengambil semua tumpukan masalah ini, opsi solusi, kompleksitas refactoring dan koreksi, menimbang semua pro dan kontra, kami memutuskan untuk beralih ke mesin baru.  Kami mulai dengan menganalisis yang sudah ada. <br><br><h3>  Pilihan </h3><br>  Persyaratan utama saat memilih mesin adalah: <br><ul><li>  bekerja pada .Net Core; </li><li>  skalabilitas </li><li>  konversi instance proses yang ada, dengan kemampuan untuk melanjutkan eksekusi setelah konversi </li><li>  biaya yang wajar untuk menganalisis masalah yang ada </li><li>  bekerja dengan DBMS berbeda </li></ul><br>  Selain itu, diperlukan bahwa Kegiatan (Aktivitas) dapat mengeksekusi kode aplikasi dalam C #, dimungkinkan untuk men-debug blok, dll. <br>  Sebagai bagian dari analisis mesin yang ada, kami melihat: <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Inti wf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flowwright</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alur kerja K2</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Inti alur kerja</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zeebe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin alur kerja</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kerangka Kerja Tahan Lama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Camunda</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kegiatan Orleans</a> </li></ol><br>  Setelah memberlakukan semua persyaratan pada solusi yang ditinjau dan menambahkan biaya solusi berbayar, kami menganggap bahwa mesin kami tidak terlalu mahal, sementara itu akan 100% cocok untuk permintaan kami dan akan mudah disempurnakan. <br><br><h3>  Implementasi / Arsitektur </h3><br>  Dalam implementasi sebelumnya, modul WF adalah layanan WCF yang terhubung dengan perpustakaan WF.  Dia mampu membuat instance proses, memulai proses, menjalankan blok, termasuk logika bisnis (kode yang ditulis oleh pengembang).  Semua ini di-host di aplikasi IIS. <br>  Dalam implementasi baru, mengikuti tren arsitektur layanan mikro, kami memutuskan untuk segera membagi layanan menjadi dua: Workflow Process Service (WPS) dan Workflow Block Service (WBS), yang dapat di-host secara terpisah.  Tautan lain dalam rantai ini adalah Layanan Aplikasi, yang mengimplementasikan sistem DirectumRX dan logika bisnis, dan klien bekerja dengannya. <br>  WPS "berjalan" sesuai dengan skema, WBS memproses blok dan menjalankan logika bisnis di setiap langkah.  Perintah untuk memulai proses berasal dari Server Aplikasi.  Interaksi antara layanan dilakukan menggunakan RabbitMQ.  Di bawah ini saya akan bercerita lebih banyak tentang mereka masing-masing. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/-u/ae/lh-uaeasg_8-9xjjtoif5ff1ycg.png"></div><br><br><h4>  Wps </h4><br>  Workflow Process Service adalah layanan microser yang bertanggung jawab untuk memulai proses dan melewati diagram proses. <br>  Repositori layanan berisi diagram proses dengan dukungan untuk versi dan keadaan serial proses serial.  Anda dapat menggunakan MS SQL dan Postgres sebagai penyimpanan. <br>  Layanan ini dapat memproses pesan yang diterima dari layanan lain melalui RabbitMQ.  Pada dasarnya, pesan adalah API layanan.  Jenis pesan yang dapat diterima layanan: <br><ul><li>  StartProcess - membuat instance proses baru dan mulai merangkak di atasnya; </li><li>  CompleteBlock - penyelesaian blok, setelah pesan ini, layanan memindahkan instance proses lebih jauh di sepanjang skema; </li><li>  Tangguhkan / Lanjutkan Proses - menangguhkan eksekusi instance proses, misalnya, karena kesalahan saat memproses blok, dan melanjutkan eksekusi setelah kesalahan diperbaiki; </li><li>  Abort / RestartProcess - hentikan eksekusi proses instance dan mulai lagi; </li><li>  DeleteProcess - hapus instance proses. </li></ul><br>  Skema ini terdiri dari blok dan koneksi di antara mereka (wajah).  Setiap wajah memiliki pengenal, yang disebut "Hasil Eksekusi".  Ada 5 jenis blok: <br><ul><li>  StartBlock </li><li>  Blokir </li><li>  OrBlock; </li><li>  AndBlock; </li><li>  FinishBlock. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nu/xw/16/nuxw16yktjqodwjbaxmevmogcgk.png" alt="gambar"></div><br>  <i><font color="99999">Tampilan skema WPS</font></i> <br>  Ketika sebuah pesan tiba di awal proses, layanan menciptakan sebuah instance dan mulai "berjalan" sesuai dengan skema.  Kelas yang bertanggung jawab untuk "berjalan" sesuai dengan skema, kami bercanda menyebut "Stepator".  Sirkuit selalu dimulai dengan StartBlock.  Kemudian strider mengambil semua wajah keluar dan mengaktifkannya.  Setiap blok bekerja berdasarkan prinsip blok "DAN", mis.  semua wajah yang masuk harus aktif sehingga blok dapat diaktifkan.  Algoritme kemudian memutuskan blok mana yang dapat diaktifkan dan mengirim pesan WBS untuk mengaktifkan blok ini.  WBS memproses blok dan mengembalikan hasil WPS.  Bergantung pada hasil eksekusi, strider memilih wajah yang sesuai yang keluar dari blok untuk aktivasi, dan proses berlanjut. <br>  Selama pengembangan, kami menemukan situasi menarik terkait dengan koneksi siklik antar blok, yang menambahkan logika saat memutuskan blok mana yang akan diaktifkan / dihentikan. <br>  Layanan bersifat otonom, mis.  cukup sampaikan skema dalam format Json, tulis block handler Anda sendiri, dan Anda dapat bertukar pesan. <br><br><h4>  Wbs </h4><br>  Layanan Block Workflow adalah layanan yang memproses diagram blok.  Layanan tahu tentang esensi logika bisnis, seperti tugas, tugas, dll.  Entitas ini dapat ditambahkan ke lingkungan pengembangan DirectumRX Development Studio (DDS).  Misalnya, blok kami memiliki acara untuk memulai blok.  Kode untuk pengendali acara ini ditulis oleh pengembang di DDS, dan WBS mengeksekusi kode ini.  Sebenarnya, ini adalah implementasi kami dari handler blok, Anda dapat menggantinya dengan Anda sendiri. <br>  Layanan menyimpan status blok.  Selain sifat dasar (Id, Negara), blok dapat berisi informasi lain yang diperlukan untuk eksekusi / penghentian / penangguhan blok. <br>  Blok mungkin dalam keadaan: <br><ul><li>  Selesai - masuk ke kondisi ini setelah berhasil menyelesaikan pekerjaan di blok; </li><li>  Tertunda - dalam keadaan menunggu ketika beberapa pekerjaan dilakukan di dalam blok, misalnya, beberapa jenis respons diperlukan dari pengguna; </li><li>  Dibatalkan - masuk ke kondisi ini ketika proses dihentikan; </li><li>  Ditangguhkan - masuk ke status ini saat proses berhenti saat terjadi kesalahan. </li></ul><br>  Ketika sebuah pesan tiba pada eksekusi blok, blok dieksekusi, dan WBS mengirim pesan dengan hasil eksekusi blok. <br><br><h4>  Skalabilitas </h4><br>  WPS dan WBS dapat digunakan dalam banyak hal.  Pada satu titik waktu, hanya satu layanan WPS yang dapat memproses satu proses instance.  Hal yang sama berlaku untuk blok pemrosesan - contoh proses satu dapat memproses hanya satu blok pada suatu waktu.  Ini dibantu oleh kunci yang diletakkan pada proses selama pemrosesan.  Jika ada beberapa pesan dalam antrian untuk memproses suatu proses / blok dalam satu proses, maka pesan tersebut ditunda selama beberapa waktu.  Pada saat yang sama, setiap layanan dapat secara bersamaan melakukan pekerjaan pada beberapa proses proses. <br>  Situasi mungkin muncul ketika beberapa pesan datang dalam satu proses demi proses untuk memproses blok (cabang paralel).  Untuk mengurangi jumlah situasi ketika Anda harus menunda pesan, WBS mengambil beberapa pesan sekaligus dan mengeksekusi mereka satu demi satu, melewati pengiriman ke antrian untuk eksekusi berulang karena memblokir proses. <br><br><h3>  Konversi </h3><br>  Setelah transisi ke mesin baru, muncul pertanyaan, apa yang harus dilakukan dengan mesin virtual yang ada?  Pilihan yang lebih disukai adalah konversi mereka, sehingga mereka terus bekerja pada mesin baru.  Keuntungannya jelas: kami hanya mendukung satu mesin, masalah mendukung mesin lama hilang (lihat di atas).  Tetapi ada risiko bahwa kami tidak akan dapat sepenuhnya mengetahui cara mendapatkan data yang kami butuhkan dari proses serial.  Ada juga fallback: untuk memberikan contoh yang ada diselesaikan pada mesin lama, dan meluncurkan yang baru pada yang baru.  Kelemahan dari opsi ini berasal dari keunggulan yang sebelumnya, ditambah sumber daya tambahan yang diperlukan untuk memutar kedua mesin. <br>  Untuk konversi, kami perlu mengambil status proses yang lama dalam format WF dan menghasilkan status proses dan blok.  Kami menulis sebuah utilitas yang mengambil keadaan serial dari instance proses dalam database, menarik darinya daftar blok aktif, hasil eksekusi untuk wajah, dan hampir mengeksekusi proses.  Akibatnya, kami mendapatkan status instance pada saat konversi. <br>  Kesulitan muncul dalam cara deserialize data contoh proses dengan benar di WF.  Keadaan proses (instance) contoh WF disimpan dalam database sebagai xaml.  Kami tidak dapat menemukan deskripsi yang jelas tentang struktur xaml ini, kami harus melakukan semuanya secara empiris.  Mengurai data secara manual dan mengeluarkan informasi yang kami butuhkan.  Sebagai bagian dari tugas ini, kami membuat pilihan lain - menggunakan alat WF untuk menghilangkan status keadaan instance dan mencoba untuk mendapatkan informasi dari objek.  Tetapi karena fakta bahwa struktur benda-benda seperti itu sangat kompleks, kami meninggalkan ide ini dan memilih xaml parsing "manual". <br>  Akibatnya, konversi berhasil, dan semua proses contoh mulai diproses oleh mesin baru. <br><br><h2>  Kesimpulan </h2><br>  Jadi apa yang diberikan oleh mesin Workflow?  Sebenarnya, kami berhasil mengalahkan semua masalah yang disuarakan di awal artikel: <br><ul><li>  Mesinnya ditulis dalam .NET Core; </li><li>  ini adalah layanan self-host independen dari IIS; </li><li>  sebagai operasi pengujian, kami secara aktif menggunakan mesin baru dalam sistem perusahaan dan berhasil memastikan bahwa analisis bug membutuhkan waktu lebih sedikit; </li><li>  melakukan pengujian beban pada Postgres, menurut data awal, bundel WPS + WBS mengatasi beban dari 5000 pengguna secara bersamaan tanpa masalah; </li><li>  dan tentu saja, seperti karya menarik lainnya, ini merupakan pengalaman yang menarik. </li></ul><br>  Sebagai bonus, kami mendapat kode yang jelas dan didukung yang dapat kami sesuaikan dengan diri kami sendiri. <br>  Biaya mesin ternyata sebanding dengan apa yang harus kami keluarkan untuk pembelian / adaptasi produk pihak ketiga.  Saat ini, kami percaya bahwa keputusan untuk mengembangkan mesin Anda sendiri ternyata dapat dibenarkan. <br>  Kami juga menunggu pengujian beban untuk lebih dari 10.000 pengguna secara bersamaan.  Mungkin beberapa optimasi akan diperlukan, atau mungkin akan lepas landas?  ;-) <br>  Kami baru-baru ini merilis DirectumRX 3.2, yang termasuk Workflow baru.  Mari kita lihat bagaimana mesin akan menampilkan dirinya kepada pelanggan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468803/">https://habr.com/ru/post/id468803/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468779/index.html">Apa hasil migrasi dari ClickHouse tanpa otorisasi ke ClickHouse dengan otorisasi</a></li>
<li><a href="../id468781/index.html">Bermain dengan bilangan kompleks</a></li>
<li><a href="../id468785/index.html">Intel Stratix 10 DX melengkapi garis Stratix 10 FPGA</a></li>
<li><a href="../id468793/index.html">Kami berurusan dengan Libra cryptocurrency. Detail</a></li>
<li><a href="../id468799/index.html">Antipatterns dalam React atau Bad Tips for Beginners</a></li>
<li><a href="../id468805/index.html">System.Console, Mono dan NCurses</a></li>
<li><a href="../id468811/index.html">Teknologi Yandex Turbo Pages dan Google AMP untuk e-commerce</a></li>
<li><a href="../id468813/index.html">Geolokasi dan geoposisi - mega-alat</a></li>
<li><a href="../id468815/index.html">Apache, ViewState & Deserialisation</a></li>
<li><a href="../id468819/index.html">Telegram Number Disclosure v.2 - Teknik Sosial</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>