<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏼 🗄️ 🏬 以Putut为例的AST树转换的实际应用 🤞🏻 🚉 👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 


 每天在处理代码时，在实现对用户有用的功能的途中，对代码进行强制（不可避免的或仅是理想的）更改就变得越来越重要。 这可以是重构，将库或框架更新到新的主要版本，更新JavaScript语法（最近并不罕见）。 即使该库是一个正在运行的项目的一部分，更改也是不可避免的。 这些更改大多数都是常规...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>以Putut为例的AST树转换的实际应用</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439564/"><h2 id="vvedenie"> 引言 </h2><br><p> 每天在处理代码时，在实现对用户有用的功能的途中，对代码进行强制（不可避免的或仅是理想的）更改就变得越来越重要。 这可以是重构，将库或框架更新到新的主要版本，更新JavaScript语法（最近并不罕见）。 即使该库是一个正在运行的项目的一部分，更改也是不可避免的。 这些更改大多数都是常规性的。 对于开发人员来说，这没有什么有趣的，一方面，它不会给业务带来任何好处，第三，在更新过程中，您需要非常小心，不要破坏柴火和不破坏功能。 因此，我们得出的结论是，最好将这样的例程移到程序的肩膀上，以使程序可以自己完成所有事情，而人又可以控制一切是否正确完成。 这将在今天的文章中讨论。 </p><a name="habracut"></a><br><h2 id="ast">  AST </h2><br><p> 对于程序代码处理，有必要将其转换为特殊的表示形式，这样可以方便程序工作。 存在这种表示形式，称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">抽象语法树</a> （AST）。 <br> 为了获得它，请使用解析器。 可以根据需要转换生成的AST，然后保存结果需要一个代码生成器。 让我们更详细地考虑每个步骤。 让我们从解析器开始。 </p><br><h3 id="parser"> 解析器 </h3><br><p> 这样我们就有了代码： </p><br><pre><code class="javascript hljs">a + b</code> </pre> <br><p> 解析器通常分为两部分： </p><br><ul><li> 词法分析 </li></ul><br><p> 将代码分成令牌，每个令牌都描述了一部分代码： </p><br><pre> <code class="json hljs">[{ <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"Identifier"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"a"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"Punctuator"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"+"</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"Identifier"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"b"</span></span> }]</code> </pre> <br><ul><li> 解析中 </li></ul><br><p> 根据令牌构建语法树： </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"BinaryExpression"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"left"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"Identifier"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"a"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"operator"</span></span>: <span class="hljs-string"><span class="hljs-string">"+"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"right"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"Identifier"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"b"</span></span> } }</code> </pre> <br><p> 现在我们已经有了一个想法，您可以通过它进行编程工作。 值得澄清的是，有大量的<code>JavaScript</code>解析器，其中一些是： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">babel-</a> <code>babel</code>使用<code>babel</code>的解析器； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">espree-</a>使用<code>eslint</code>的解析器； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">橡子</a> -前面两个基于的解析器； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">esprima-</a>在EcmaScript 2017之前支持JavaScript的流行解析器; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cherow</a>是JavaScript解析器中声称是最快的新角色。 </li></ul><br><p> 有一个标准的JavaScript解析器，称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ESTree</a> ，用于定义应解析的节点。 <br> 要更详细地分析解析器（以及转换器和生成器）的实现过程，可以阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">super-tiny-compiler</a> 。 </p><br><h3 id="transformator"> 变形金刚 </h3><br><p> 为了转换AST树，您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Visitor</a>模式，例如，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@ babel /遍历</a>库。 以下代码将从<code>code</code>变量输出所有JavaScript代码标识符的名称。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> parser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@babel/parser"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> traverse <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"@babel/traverse"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> code = <span class="hljs-string"><span class="hljs-string">`function square(n) { return n * n; }`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ast = parser.parse(code); traverse(ast, { Identifier(path) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(path.node.name); } });</code> </pre> <br><h3 id="generator"> 发电机组 </h3><br><p> 您可以使用以下方式生成代码，例如，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@ babel / generator</a> ： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {parse} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@babel/parser'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> generate <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@babel/generator'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> code = <span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ast = parse(code); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> output = generate(ast, code);</code> </pre> <br><p> 因此，在这个阶段，读者应该已经基本了解了转换JavaScript代码所需的内容以及使用哪些工具实现该代码。 </p><br><p> 还值得添加一个在线工具，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">astexplorer</a> ，它将大量的解析器，转换器和生成器结合在一起。 </p><br><h2 id="putout"> 推杆 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Putout</a>是启用了插件的代码转换器。 实际上，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">eslint</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">babel</a>之间的交叉，结合了这两种工具的优点。 </p><br><p>  <code>eslint</code>如何显示代码中的问题区域，但是与<code>eslint</code>不同，它可以更改代码的行为，也就是说，它可以修复所有可发现的错误。 </p><br><p> 像<code>babel</code> <code>putout</code>一样<code>putout</code>转换代码，但尝试对其进行最小的更改，因此可以将其用于存储在存储库中的代码。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更漂亮的</a>还值得一提，它是一种格式化工具，与之根本不同。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jscodeshift</a>的位置离<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">putout</a>不太远，但是它不支持插件，不显示错误消息，并且还使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ast-types</a>而不是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@ babel / types</a> 。 </p><br><h3 id="istoriya-poyavleniya"> 外观故事 </h3><br><p> 在此过程中， <code>eslint</code>提示对我有很大帮助。 但是有时候我想要他更多。 例如，要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">删除调试器</a> ，请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">修复test.only</a> ，并删除未使用的变量。 最后一点构成了<code>putout</code>的基础，在开发过程中，很明显这很困难，许多其他转换也很容易实现。 因此，推出功能从一个功能平稳地增长到插件系统。 现在，删除未使用的变量是最困难的过程，但这并不妨碍我们开发和支持许多其他同样有用的转换。 </p><br><h3 id="kak-putout-ustroen-iznutri"> 推杆如何在内部工作 </h3><br><p>  <code>putout</code>工作可分为两部分：引擎和插件。 这种架构使您在使用引擎时不会因转换而分心，在使用插件时，您将最大程度地专注于其用途。 </p><br><h4 id="vstroennye-plaginy"> 内置插件 </h4><br><p>  <code>putout</code>构建在插件系统上。 每个插件代表一个规则。 使用内置规则，您可以执行以下操作： </p><br><ul><li><p> 查找和删除： </p><br><ul><li> 未使用的变量 </li><li> <code>debugger</code> </li> <li> 打电话给<code>test.only</code> </li><li> 致电<code>test.skip</code> </li><li> 调用<code>console.log</code> </li><li> 呼叫<code>process.exit</code> </li><li> 空块 </li><li> 空模式 </li></ul><br></li><li><p> 查找和拆分变量声明： </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  var one, two; //  var one; var two;</span></span></code> </pre> <br></li><li><p> 将<code>commonjs</code>转换为<code>commonjs</code> ： </p><br></li></ul><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//  import one from 'one'; //  const one = require('one');</span></span></code> </pre> <br><ul><li> 应用解构： </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  const name = user.name; //  const {name} = user;</span></span></code> </pre> <br><ol><li> 结合解构属性： </li></ol><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  const {name} = user; const {password} = user; //  const { name, password } = user;</span></span></code> </pre> <br><p> 每个插件都是根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Unix哲学</a>构建的，也就是说，它们尽可能地简单，每个插件都执行一个动作，使它们易于组合，因为它们实质上是过滤器。 </p><br><p> 例如，具有以下代码： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> password = user.password;</code> </pre> <br><p> 首先使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">apply-destructuring</a>将其转换为： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {name} = user; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {password} = user;</code> </pre> <br><p> 然后，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">merge-destructuring-properties将其</a>转换为： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, password } = user;</code> </pre> <br><p> 因此，插件可以单独工作，也可以一起工作。 在创建自己的插件时，建议遵循此规则，并以最少的功能实现只满足您需求的插件，其余的将由内置和自定义插件来完成。 </p><br><h4 id="primer-ispolzovaniya"> 使用范例 </h4><br><p> 在熟悉了内置规则之后，我们可以考虑使用<code>putout</code>的示例。 <br> 创建一个具有以下内容的<code>example.js</code>文件： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>, y = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> password = user.password; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, password);</code> </pre> <br><p> 现在通过传递<code>example.js</code>作为参数来运行<code>putout</code> ： </p><br><pre> <code class="plaintext hljs">coderaiser@cloudcmd:~/example$ putout example.js /home/coderaiser/example/example.js 1:6 error "x" is defined but never used remove-unused-variables 1:13 error "y" is defined but never used remove-unused-variables 6:0 error Unexpected "console" call remove-console 1:0 error variables should be declared separately split-variable-declarations 3:6 error Object destructuring should be used apply-destructuring 4:6 error Object destructuring should be used apply-destructuring 6 errors in 1 files fixable with the `--fix` option</code> </pre> <br><p> 我们将收到包含6个错误的信息，上面已对其进行了详细介绍，现在我们将对其进行更正，然后看看发生了什么： </p><br><pre> <code class="plaintext hljs">coderaiser@cloudcmd:~/example$ putout example.js --fix coderaiser@cloudcmd:~/example$ cat example.js const { name, password } = user;</code> </pre> <br><p> 作为更正的结果，未使用的变量和<code>console.log</code>调用被删除，并且还应用了分解。 </p><br><h4 id="nastroyki"> 设定值 </h4><br><p> 默认设置可能并不总是适用于所有人，因此<code>.putout.json</code>支持<code>.putout.json</code>配置文件，它由以下部分组成： </p><br><ul><li> 规则 </li><li> 忽略 </li><li> 搭配 </li><li> 外挂程式 </li></ul><br><h5 id="rules"> 规则 </h5><br><p>  <code>rules</code>部分包含规则系统。 默认情况下，规则设置如下： </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"rules"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"remove-unused-variables"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"remove-debugger"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"remove-only"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"remove-skip"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"remove-process-exit"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"remove-console"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"split-variable-declarations"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"remove-empty"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"remove-empty-pattern"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"convert-esm-to-commonjs"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"apply-destructuring"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"merge-destructuring-properties"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><p> 要启用<code>remove-process-exit</code>只需在<code>.putout.json</code>文件中将其设置为<code>true</code> <code>.putout.json</code> ： </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"rules"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"remove-process-exit"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><p> 这将足以报告在代码中找到的所有<code>process.exit</code>调用，并在使用<code>--fix</code>选项时将其删除。 </p><br><h5 id="ignore"> 忽略 </h5><br><p> 如果需要在例外列表中添加一些文件夹，只需添加<code>ignore</code>部分： </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"ignore"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"test/fixture"</span></span> ] }</code> </pre> <br><h5 id="match"> 搭配 </h5><br><p> 例如，如果您需要分支的规则系统，请为<code>bin</code>目录启用<code>process.exit</code> ，只需使用<code>match</code>部分： </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"match"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bin"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"remove-process-exit"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, } } }</code> </pre> <br><h5 id="plugins"> 外挂程式 </h5><br><p> 如果您使用的插件不是内置的，并且前缀<code>putout-plugin-</code> ，则必须在<code>rules</code>部分将其激活之前，将它们包括在<code>plugins</code>部分中。 例如，要连接<code>putout-plugin-add-hello-world</code>并启用<code>add-hello-world</code>规则，只需指定： </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"rules"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"add-hello-world"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"plugins"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"add-hello-world"</span></span> ] }</code> </pre> <br><h4 id="dvizhok-putout"> 推杆引擎 </h4><br><p>  <code>putout</code>引擎是一个命令行工具，可读取设置，解析文件，加载并运行插件，然后写入插件的结果。 </p><br><p> 它使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">重铸</a>库，这有助于执行一项非常重要的任务：解析和转换后，以与上一个状态尽可能相似的状态收集代码。 </p><br><p> 对于解析，使用了与<code>ESTree</code>兼容的解析器（ <code>babel</code>当前与<code>estree</code>插件一起使用，但将来可能会更改），并且使用<code>babel</code>工具进行转换。 为什么是<code>babel</code> ？ 一切都很简单。 事实是，这是一个非常受欢迎的产品，比其他类似工具更受欢迎，并且开发速度更快。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">没有babel插件，EcmaScript标准中的每个新建议都是不完整的</a> 。  <a href="">Babel还有</a>一本书《 <a href="">Babel手册》</a> ，很好地描述了遍历和转换AST树的所有功能和工具。 </p><br><h4 id="svoy-plagin-dlya-putout"> 自定义插件 </h4><br><p>  <code>putout</code>插件系统非常简单，与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">eslint插件</a>以及<a href="">babel插件</a>非常相似。 没错， <code>putout</code> plugin应该导出3，而不是一个函数。这样做是为了增加代码重用性，因为在3个函数中复制功能不是很方便，将它放入单独的函数中并在正确的地方简单调用就容易得多。 </p><br><h5 id="struktura-plagina"> 插件结构 </h5><br><p> 因此， <code>Putout</code>插件包含3个功能： </p><br><ul><li>  <code>report</code> -返回消息； </li><li>  <code>find</code> -搜索有错误的地方并返回它们； </li><li>  <code>fix</code> -修复这些地方； </li></ul><br><p> 为<code>putout</code>创建插件时要记住的主要一点是它的名称，它应该以<code>putout-plugin-</code> 。 接下来可能是该插件执行的操作的名称，例如，应该这样调用<code>remove-wrong</code>插件： <code>putout-plugin-remove-wrong</code> 。 </p><br><p> 您还应该在<code>keywords</code>部分的<code>package.json</code>部分中添加单词： <code>putout</code>和<code>putout-plugin</code> ，并在<code>peerDependencies</code> <code>"putout": "&gt;=3.10"</code>指定<code>"putout": "&gt;=3.10"</code> <code>peerDependencies</code> <code>"putout": "&gt;=3.10"</code> ，或在编写插件时将是最后一个版本。 </p><br><h5 id="primer-plagina-dlya-putout"> 推杆示例插件 </h5><br><p> 让我们编写一个示例插件，该插件将从代码中删除<code>debugger</code>一词。 这样的插件已经存在，它是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@ putout / plugin-remove-debugger</a> ，现在已经足够简单了。 </p><br><p> 看起来像这样： </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        module.exports.report = () =&gt; 'Unexpected "debugger" statement'; //     ,  debugger    Visitor module.exports.find = (ast, {traverse}) =&gt; { const places = []; traverse(ast, { DebuggerStatement(path) { places.push(path); } }); return places; }; //  ,     module.exports.fix = (path) =&gt; { path.remove(); };</span></span></code> </pre> <br><p> 如果<code>.putout.json</code>包含<code>remove-debugger</code>规则，则将加载<code>@putout/plugin-remove-debugger</code> <code>.putout.json</code> <code>@putout/plugin-remove-debugger</code> 。 首先，调用<code>find</code>函数，该函数使用<code>traverse</code>函数绕过AST树的节点并保存所有必要的位置。 </p><br><p> 下一步输出将转向<code>report</code>以获取所需的消息。 </p><br><p> 如果使用<code>--fix</code>标志，则将调用插件<code>fix</code>函数并执行转换，在这种情况下，将删除该节点。 </p><br><h5 id="primer-testa-plagina"> 插件测试示例 </h5><br><p> 为了简化插件的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">测试</a> ，编写了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@ putout /测试</a>工具。 从本质上讲，它不过是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">纸带上</a>的包装纸，并提供了几种方便和简化测试的方法。 </p><br><p>  <code>remove-debugger</code>插件的测试可能如下所示： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> removeDebugger = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'..'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@putout/test'</span></span>)(__dirname, { <span class="hljs-string"><span class="hljs-string">'remove-debugger'</span></span>: removeDebugger, }); <span class="hljs-comment"><span class="hljs-comment">//        test('remove debugger: report', (t) =&gt; { t.reportCode('debugger', 'Unexpected "debugger" statement'); t.end(); }); //    test('remove debugger: transformCode', (t) =&gt; { t.transformCode('debugger', ''); t.end(); });</span></span></code> </pre> <br><h5 id="codemods">  Codemods </h5><br><p> 并非每天都需要使用每个转换，一次转换就足以完成相同的事情，但是，除了将其发布到<code>npm</code>请将其放置在<code>~/.putout</code> 。 启动时， <code>putout</code>将在此文件夹中查找，拾取并开始转换。 </p><br><p> 这是一个示例转换，该转换将<code>tape</code>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">try-to-tape</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">连接替换为supertape</a>调用： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">convert-tape-to-supertape</a> 。 </p><br><h3 id="eslint-plugin-putout">  eslint插件输出 </h3><br><p> 最后，值得一提的是： <code>putout</code>尝试最小地更改代码，但是如果遇到某个朋友违反了某些格式规则，则eslint --fix随时可以提供<code>eslint --fix</code> ，因此有一个特殊的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">eslint-plugin-putout插件</a> 。 它可以消除许多格式错误，当然可以根据开发人员在特定项目上的偏好对其进行自定义。 连接起来很容易： </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"extends"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"plugin:putout/recommended"</span></span>, ], <span class="hljs-attr"><span class="hljs-attr">"plugins"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"putout"</span></span> ] }</code> </pre> <br><p> 到目前为止，其中只有一条规则： <code>one-line-destructuring</code> ，它执行以下操作： </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  const { one } = hello; //  const {one} = hello;</span></span></code> </pre> <br><p> 您还可以包括更多的<code>eslint</code>规则，以使自己<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更加</a>熟悉。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 我要感谢读者对本文的关注。 我衷心希望AST转换的话题将变得更加流行，并且有关此引人入胜的过程的文章也会更多地出现。 对于与<code>putout</code>的进一步发展有关的任何意见和建议，我将不胜感激。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">创建问题</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发送请求池</a> ，进行测试，编写您希望看到的规则以及如何以编程方式编写代码，我们将共同努力以改善AST转换工具。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN439564/">https://habr.com/ru/post/zh-CN439564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN439552/index.html">恶意的Chrome扩展程序</a></li>
<li><a href="../zh-CN439556/index.html">TDMS航道。 PMBOK方法论和俄罗斯设计组织</a></li>
<li><a href="../zh-CN439558/index.html">新旧电话。 重塑PSTN电话</a></li>
<li><a href="../zh-CN439560/index.html">适用于InterSystems IRIS数据平台的以太坊区块链适配器</a></li>
<li><a href="../zh-CN439562/index.html">使用kubeadm在裸机上配置Kubernetes HA集群。 第1/3部分</a></li>
<li><a href="../zh-CN439566/index.html">为什么SRE文档很重要。 第三部分</a></li>
<li><a href="../zh-CN439568/index.html">基于QLC的SSD-硬盘杀手?？ 不是真的</a></li>
<li><a href="../zh-CN439570/index.html">IPython魔术来编辑Jupyter细胞标记</a></li>
<li><a href="../zh-CN439572/index.html">电子设备的计算机辅助设计</a></li>
<li><a href="../zh-CN439574/index.html">SmartCard I2C协议。 通过I2C接口交换APDU命令</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>