<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🎤 ⚾️ 🏍️ iOS应用程序中的应用程序协调器 🧑🏿‍🤝‍🧑🏽 👩🏾‍🤝‍👩🏼 📸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="每年，iOS平台都会发生许多变化，此外，第三方库会定期与网络合作，缓存数据，通过JavaScript渲染UI等。 与所有这些趋势形成鲜明对比的是， Pavel Gurov谈到了体系结构解决方案，无论您现在正在使用或未来几年将使用哪种技术，该解决方案都将是有意义的。 

 ApplicationCoo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>iOS应用程序中的应用程序协调器</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/423299/"> 每年，iOS平台都会发生许多变化，此外，第三方库会定期与网络合作，缓存数据，通过JavaScript渲染UI等。 与所有这些趋势形成鲜明对比的是， <strong>Pavel Gurov</strong>谈到了体系结构解决方案，无论您现在正在使用或未来几年将使用哪种技术，该解决方案都将是有意义的。 <br><br>  ApplicationCoordinator可用于在屏幕之间建立导航，同时解决许多问题。 在cat演示和说明下，可以最快地实现此方法。 <br><br><img src="https://habrastorage.org/webt/xx/ok/ti/xxoktiysvlvnzl1zbhvivxccrry.jpeg"><br><br>  <strong>关于演讲者：</strong> Pavel Gurov正在Avito中开发iOS应用程序。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Pt9TGFzLVzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br><h2> 导览 <br></h2><br><br><img src="https://habrastorage.org/webt/9d/dp/od/9ddpodzty4uclncm046g1ms9nvy.jpeg"><br><br> 在屏幕之间导航是一项任务，无论您做什么，都要100％面对-社交网络，出租车呼叫或在线银行。 这是应用程序甚至在原型阶段就开始的时候，当您甚至不完全了解屏幕的外观，屏幕的动画形式，是否缓存数据时。 这些屏幕可能是空白图片，也可能是静态图片，但是<strong>一旦这些屏幕中的一个以上，导航任务就会出现在应用程序中</strong> 。 即几乎立即。 <br><br><img src="https://habrastorage.org/webt/um/r-/qo/umr-qogrmhhn58yvlaseyxqyrre.jpeg"><br><br> 构建iOS应用程序体系结构的最常见方法：MVc，MVVm和MVp，描述了如何构建单个屏幕模块。 它还说模块可以相互了解，相互通信等。 但是很少关注这些模块之间如何进行转换，由谁来决定这些转换以及如何传输数据的问题。 <br><br><h2>  UlStoryboard + segues <br></h2><br> 开箱即用的iOS提供了几种显示以下屏幕场景的方法： <br><br><ol><li> 当我们在一个图元文件中指定屏幕之间的所有转换，然后调用它们时，众所周知的<strong>UlStoryboard + segues</strong> 。 一切都非常方便而且很棒。 </li><li> 容器-如UINavigationController。  UITabBarController，UIPageController或可能是可自行编写的容器，可以通过编程方式以及与StoryBoards一起使用。 </li><li> 存在的方法（_：动画：完成：）。 这只是UIController类的方法。 </li></ol><br> 这些工具本身没有问题。 问题在于它们通常如何使用。  UINavigationController，performSegue，prepareForSegue，presentViewController方法都是UIViewController类的属性方法。 苹果建议在UIViewController内部使用这些工具。 <br><br><img src="https://habrastorage.org/webt/gy/_n/vb/gy_nvb7uettqb7xdoillr3ud3m4.jpeg"><br><br> 证明如下。 <br><br><img src="https://habrastorage.org/webt/hv/cq/6p/hvcq6prwv2si1cyrpqkiwchlwds.jpeg"><br><br> 如果使用标准模板创建UIViewController的新子类，则这些注释将出现在项目中。 它是直接编写的-如果您使用segues，并且需要根据场景将数据传输到下一个屏幕，则应该： 知道它将是哪种类型； 将其转换为这种类型，然后将数据传递到该类型。 <br><br> 这种解决建筑物导航问题的方法。 <br><br>  <strong>1.屏幕的刚性连接</strong> <br><br> 这意味着屏幕1知道屏幕2的存在。他不仅知道屏幕2的存在，还潜在地创建了屏幕2，或者从序列中获取了屏幕2，知道了屏幕2的类型，并将一些数据传输到屏幕2。 <br><br> 在某些情况下，如果我们需要显示屏幕3而不是屏幕2，那么我们将必须以相同的方式了解新屏幕3才能拼接到屏幕控制器1中。如果可以从多个位置调用控制器2和3，则一切都会变得更加困难。从屏幕1开始。事实证明，必须在这些位置中的每一个地方都缝制屏幕2和3的知识。 <br><br> 要做到这一点又是麻烦的一半，主要问题将在需要更改这些转换或支持所有这些转换时开始。 <br><br><img src="https://habrastorage.org/webt/nx/34/yw/nx34ywvotea8yovx9xuuaxp2lro.jpeg"><br><br>  <strong>2.重新排序脚本控制器</strong> <br><br> 由于连接，这也不是那么简单。 要交换两个ViewController，仅进入UlStoryboard并交换2张图片是不够的。 您将必须打开每个屏幕的代码，将其转移到下一个屏幕的设置，然后更改其位置，这不是很方便。 <br><br><img src="https://habrastorage.org/webt/lz/_g/n6/lz_gn6x_emphixjobmg-cezayqa.jpeg"><br><br>  <strong>3.根据情况传输数据</strong> <br><br> 例如，当选择屏幕3上的某个内容时，我们需要更新屏幕1上的视图。由于最初除了ViewController之外什么都没有，所以我们必须以某种方式连接两个ViewController-无关紧要-通过委托或某种方式还没 如果根据屏幕3上的操作，如果不是必须更新一个屏幕，而是一次更新多个屏幕（例如第一个和第二个屏幕），则将变得更加困难。 <br><br><img src="https://habrastorage.org/webt/wy/gz/gr/wygzgrppqbr4dc6tszklinog714.jpeg"><br><br> 在这种情况下，不能放弃委托，因为委托是一对一的关系。 有人会说，让我们使用通知-通过共享状态。 所有这些使我们难以调试和跟踪应用程序中的数据流。 <br><br> 正如他们所说，看一次比听100次更好。 让我们看一下该Avito Services Pro应用程序中的特定示例。 该应用程序适合服务行业的专业人员，在其中可以方便地跟踪您的订单，与客户沟通，寻找新订单。 <br><br> 场景-在编辑用户个人资料时选择城市。 <br><br><img src="https://habrastorage.org/webt/0j/cd/zn/0jcdznc3-8b7fy9lliaairh1s_u.jpeg"><br><br> 这是配置文件编辑屏幕，在许多应用程序中都是这样。 我们对选择城市感兴趣。 <br><br> 这是怎么回事 <br><br><ul><li> 用户单击带有城市的单元格，然后第一个屏幕确定是时候将以下屏幕添加到导航堆栈中了。 此屏幕显示联邦城市列表（莫斯科和圣彼得堡）和地区列表。 </li><li> 如果用户在第二个屏幕上选择了一个联邦城市，则第二个屏幕将了解脚本已完成，将所选城市转发到第一个屏幕，并且导航堆栈会回滚到第一个屏幕。 该脚本被认为是完整的。 </li><li> 如果用户在第二个屏幕上选择一个区域，则第二个屏幕决定需要准备第三个屏幕，我们将在其中看到该区域中的城市列表。 如果用户选择了一个城市，则该城市将被发送到第一个屏幕，滚动导航堆栈，脚本将被视为完成。 </li></ul><br> 在此图中，我前面提到的连接性问题显示为ViewController之间的箭头。 我们现在将摆脱这些问题。 <br><br>  <strong>我们该怎么做？</strong> <br><br><ol><li> 我们<strong>禁止自己在UIViewController内部访问容器</strong> ，即<strong>访问</strong> self.navigationController，self.tabBarController或您作为属性扩展创建的其他一些自定义容器。 现在，我们无法从屏幕代码中取出容器并要求其执行操作。 <br><br><img src="https://habrastorage.org/webt/av/ci/0x/avci0xx4juu-sitqkcidwmo5woi.jpeg"><br></li><li>  <strong>我们禁止自己在UIViewController内部调用performSegue方法，</strong>并在prepareForSegue方法中编写代码，这将带走脚本之后的屏幕并对其进行配置。 也就是说，我们不再在UIViewController中使用segue（在屏幕之间进行转换）。 <br><br><img src="https://habrastorage.org/webt/xp/lh/kq/xplhkqdhp61csbpdmvaulmonqra.jpeg"><br></li><li> 我们还<strong>禁止在特定控制器内提及其他控制器</strong> ：请勿进行初始化，进行数据传输，仅此而已。 <br><br><img src="https://habrastorage.org/webt/cr/0_/j9/cr0_j999w13tkk8szf2wh1xbjsm.jpeg"><br></li></ol><br><br><h2> 协调员 <br></h2><br> 由于我们从UIViewController中删除了所有这些职责，因此我们需要一个新的实体来执行它们。 创建一个新的对象类，并将其称为协调器。 <br><br><img src="https://habrastorage.org/webt/ta/ub/t6/taubt6cqzz4_lviz88jbgih3jf4.jpeg"><br><br> 协调器只是一个普通对象，我们在NavigationController的开头将其传递给该对象，并调用Start方法。 现在，不考虑它的实现方式，只看这种情况下选择城市的方案将如何变化。 <br><br> 现在，我们并没有开始准备过渡到任何特定NavigationController屏幕的事实，而是在协调器中调用Start方法，然后在NavigationController初始化程序中将其传递给它。 协调员了解到，现在该让NavigationController启动第一个屏幕了，他这样做了。 <br><br> 此外，当用户选择带有城市的小区时，该事件将传递给协调器。 也就是说，屏幕本身什么都不知道-正如他们所说的那样，至少在洪水之后。 他将此消息发送给协调器，然后协调器对此做出响应（因为他有一个NavigationController），该控制器向其发送下一步-这是区域选择。 <br><br> 接下来，用户单击“区域”（完全相同的图片），屏幕本身无法解决任何问题，仅告诉协调员下一个屏幕将打开。 <br><br> 当用户在第三屏幕上选择特定城市时，该城市也通过协调器转移到第一屏幕。 即，向协调员发送一条消息，告知已选择城市。 协调器将此消息发送到第一个屏幕，并将“导航”堆栈滚动到第一个屏幕。 <br><br> 请注意， <strong>控制器不再相互通信</strong> ，从而确定下一个将是谁，并且不会相互传输任何数据。 而且，他们对周围的环境一无所知。 <br><br><img src="https://habrastorage.org/webt/uz/sy/uo/uzsyuorkw837chi1zn8s39hdkw0.jpeg"><br><br> 如果我们在三层体系结构的框架内考虑应用程序，那么ViewController应该理想地完全适合于Presentation层，并尽可能少地携带应用程序逻辑。 <br><br> 在这种情况下，我们使用协调器提取到上一层的转换逻辑，并从ViewController中删除此知识。 <br><br><h2> 演示版 <br></h2><br>  Github上有一个演示和演示<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">项目</a> ，下面是演讲期间的演示。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Pt9TGFzLVzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 这是相同的情况：编辑配置文件并在其中选择城市。 <br><br> 第一个屏幕是用户编辑屏幕。 它显示有关当前用户的信息：名称和所选城市。 有一个按钮“选择城市”。 当我们点击它时，我们进入带有城市列表的屏幕。 如果我们选择一个城市，则第一个屏幕将显示该城市。 <br><br> 现在让我们看看它在代码中如何工作。 让我们从模型开始。 <br><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">City</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> city: <span class="hljs-type"><span class="hljs-type">City?</span></span> }</code> </pre> <br>  <strong>这些模型很</strong>简单： <br><br><ol><li> 具有字段名称，字符串的城市结构； </li><li> 也具有名称和财产城市的用户。 </li></ol><br> 接下来是<strong>StoryBoard</strong> 。 它从NavigationController开始。 原则上，这里是模拟器中的屏幕：带有标签和按钮的用户编辑屏幕，以及带有城市列表的屏幕，其中显示了带有城市的平板电脑。 <br><br><h4> 用户编辑屏幕 <br></h4><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserEditViewController: UIViewController, UpdateableWithUser { // MARK: - <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> - var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>? { didSet { updateView() } } // MARK: - Output - var onSelectCity: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)? @IBOutlet private weak var userLabel: UILabel? @IBAction private func selectCityTap(_ sender: UIButton) { onSelectCity?() } override func viewWillAppear(_ animated: <span class="hljs-type"><span class="hljs-type">Bool</span></span>) { super.viewWillAppear(animated) updateView() } private func updateView() { userLabel?.text = "User: \(user?.name ?? ""), \n" + "City: \(user?.city?.name ?? "")" } }</code> </pre><br> 这里有一个属性User-这是传输到外部的用户-我们将编辑的用户。 此处的Set用户会导致didSet块被调用，从而导致对本地updateView（）方法的调用。 该方法所做的只是将有关该用户的信息放在标签上，即显示其姓名和该用户所居住城市的名称。 <br><br> 同样的事情发生在viewWillAppear（）方法中。 <br><br> 最有趣的地方是单击城市选择按钮selectCityTap（）的处理程序。  <strong>在这里，控制器本身无法解决任何问题</strong> ：它不会创建任何控制器，也不会调用任何segue。 他所做的只是回调-这是ViewController的第二个属性。  onSelectCity回调没有参数。 当用户单击按钮时，这将导致调用此回调。 <br><br><h4> 城市选择画面 <br></h4><br><pre> <code class="hljs powershell">import UIKit final <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CitiesViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableViewController</span></span></span></span> { // MARK: - Output - var onCitySelected: ((City) -&gt; Void)? // MARK: - Private variables - private let cities: [<span class="hljs-type"><span class="hljs-type">City</span></span>] = [<span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Moscow"</span></span>), <span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Ulyanovsk"</span></span>), <span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"New York"</span></span>), <span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Tokyo"</span></span>)] // MARK: - Table - override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cities.count } override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: <span class="hljs-string"><span class="hljs-string">"cell"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: indexPath) cell.textLabel?.text = cities[<span class="hljs-type"><span class="hljs-type">indexPath.row</span></span>].name <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell } override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { onCitySelected?(cities[<span class="hljs-type"><span class="hljs-type">indexPath.row</span></span>]) } }</code> </pre><br> 此屏幕是UITableViewController。 这里的城市列表是固定的，但可能来自其他地方。 进一步的（// MARK：-表-）是一个相当琐碎的表代码，它显示单元格中的城市列表。 <br><br> 这里最有趣的地方是didSelectRowAt IndexPath处理程序，这是众所周知的方法。 屏幕本身再次无法解决任何问题。 选择城市后会发生什么？ 它仅使用单个参数“ city”调用回调。 <br><br> 这样就结束了屏幕本身的代码。 我们看到，他们对环境一无所知。 <br><br><h4> 协调员 <br></h4><br> 让我们转到这些屏幕之间的链接。 <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit protocol UpdateableWithUser: <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>? { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } } final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserEditCoordinator { // MARK: - Properties private var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span> { didSet { updateInterfaces() } } private weak var navigationController: UINavigationController? // MARK: - Init init(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, navigationController: UINavigationController) { self.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> self.navigationController = navigationController } func <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() { showUserEditScreen() } // MARK: - Private implementation private func showUserEditScreen() { let controller = UIStoryboard.makeUserEditController() controller.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> controller.onSelectCity = { [weak self] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self?.showCitiesScreen() } navigationController?.pushViewController(controller, animated: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } private func showCitiesScreen() { let controller = UIStoryboard.makeCitiesController() controller.onCitySelected = { [weak self] city <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self?.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.city = city _ = self?.navigationController?.popViewController(animated: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) } navigationController?.pushViewController(controller, animated: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) } private func updateInterfaces() { navigationController?.viewControllers.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { (<span class="hljs-meta"><span class="hljs-meta">$0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? UpdateableWithUser)?.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> } } }</code> </pre><br> 协调器具有两个属性： <br><br><ol><li> 用户-我们将编辑的用户； </li><li> 启动时要传递给的NavigationController。 </li></ol><br> 有一个简单的init（）填充这些属性。 <br><br> 接下来是start（）方法，该方法将导致<strong>ShowUserEditScreen（）</strong>方法被<strong>调用</strong> 。 让我们更详细地讨论它。 此方法将控制器从UIStoryboard中移出，并将其传递给我们的本地用户。 然后，他放置onSelectCity回调并将该控制器推入Navigation堆栈。 <br><br> 用户单击按钮后，将触发onSelectCity回调，这将导致调用以下私有<strong>ShowCitiesScreen（）</strong>方法。 <br><br> 实际上，它几乎完成了相同的工作-抬起了与UIStoryboard略有不同的控制器，将onCitySelected回调放到了它，并将其推入了导航堆栈-这就是所有的事情。 当用户选择一个特定的城市时，会触发此回调，协调器将更新我们本地用户的“城市”字段，并将导航堆栈滚动到第一个屏幕。 <br><br> 由于User是一种结构，因此更新其中的字段“ city”会导致以下事实：分别调用了didSet块，因此调用了私有方法<strong>updateInterfaces（）</strong> 。 此方法遍历整个Navigation堆栈，并尝试将每个ViewController部署为UpdateableWithUser协议。 这是最简单的协议，只有一个属性-用户。 如果成功，则将其扔给更新的用户。 因此，事实证明，我们在第二个屏幕上选择的用户会自动跳到第一个屏幕。 <br><br> 协调员一切都清楚了，这里唯一要显示的是我们应用程序的入口点。 这就是一切的开始。 在这种情况下，这是AppDelegate的didFinishLaunchingWithOptions方法。 <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit @UIApplicationMain <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AppDelegate: UIResponder, UIApplicationDelegate { var <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>: UIWindow? var coordinator: UserEditCoordinator! func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: <span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>]?) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { guard let navigationController = <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>?.rootViewController <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? UINavigationController <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } let <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Pavel Gurov", city: City(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Moscow")) coordinator = UserEditCoordinator(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, navigationController: navigationController) coordinator.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } }</code> </pre><br> 这里的navigationController取自UIStoryboard，创建了一个用户，我们将对其进行编辑，并带有名称和特定的城市。 接下来，我们使用User和navigationController创建协调器。 它调用start（）方法。 协调员将转移到本地财产-基本上就是全部。 该方案非常简单。 <br><br><h4> 输入和输出 <br></h4><br> 我想更详细地阐述几点。 您可能已经注意到，userEditViewController中的属性带有注释标记为Input，而这些控制器的回调标记为Output。 <br><br><img src="https://habrastorage.org/webt/xs/_v/kr/xs_vkrwlnwgvdyneeeijb2xsrm0.jpeg"><br><br>  <strong>输入</strong>是随时间变化的任何数据，以及可以从外部调用的某些ViewController方法。 例如，在UserEditViewController中，这是一个User属性-用户本身或其City参数可以更改。 <br><br>  <strong>退出</strong>是控制器要与外界进行通信的任何事件。 在UserEditViewController中，这是单击onSelectCity按钮，在城市选择屏幕上，这是单击具有特定城市的单元格。 我再说一次，这里的主要思想是，控制器对这些事件一无所知，也不做任何事。 他委托他人决定做什么。 <br><br> 在Objective-C中，我不喜欢编写保存回调，因为它们的语法很糟糕。 但是在Swift中，这要简单得多。 在这种情况下，使用回调是iOS中众所周知的委托模式的替代方法。 仅在这里，我们无需在协议中指定方法并说协调器与该协议相对应，然后将这些方法分别写在某个地方，我们可以立即非常方便地在一个位置创建一个实体，对其进行回调并完成所有操作。 <br><br> 的确，与委托不同，使用这种方法，协调者的本质和屏幕之间存在紧密的联系，因为协调者知道屏幕具有特定的本质。 <br><br> 您可以使用协议，以与委派相同的方式来消除此问题。 <br><br><img src="https://habrastorage.org/webt/a-/nm/aa/a-nmaaf8uwdvujtzcvhjmfz0k2c.jpeg"><br><br> 为了避免连接，我们可以<strong>使用protocol</strong>来<strong>关闭</strong> <strong>控制器</strong> <strong>的</strong> <strong>输入和</strong> <strong>输出</strong> 。 <br><br> 上面是CitiesOutput协议，它只有一个要求-onCitySelected回调。 左侧是Swift上此方案的类似物。 我们的控制器遵守此协议，确定必要的回调。 我们这样做是为了使协调器不知道CitiesViewController类的存在。 但是在某个时候，他将需要配置该控制器的输出。 为了提高效率，我们向协调员添加了一个工厂。 <br><br><img src="https://habrastorage.org/webt/vx/hl/0v/vxhl0vp5g0pybl5_6pbasirpfby.jpeg"><br><br> 工厂有一个cityOutput（）方法。 事实证明，我们的协调员不会创建控制器，也不会从某个地方获取它。 工厂将它扔给他，它返回该方法中的协议关闭的对象，并且他对该对象是什么类一无所知。 <br><br> 现在最重要的事情-为什么要做所有这一切？  <strong>当没有问题时，为什么我们需要在另一个层次上进行构建？</strong> <br><br> 可以想象这种情况：一位经理会来找我们，要求您对A / B测试这一事实，即我们可以选择城市而不是城市列表。 如果在我们的应用程序中选择的城市不在一个地方，而是在不同的协调员中，在不同的情况下，我们必须在每个地方缝制一个旗帜，扔到外面，在这个旗帜上抬一个或另一个ViewController。 这不是很方便。 <br><br> 我们想从协调员中删除这些知识。 因此，可以在一处做到这一点。 在工厂本身中，我们将创建一个参数，工厂通过该参数返回协议关闭的一个或另一个控制器。 它们都将有一个onCitySelected回调，并且协调器原则上将不在乎要使用哪个屏幕-地图或列表。 <br><br><h2> 组成VS继承 <br></h2><br> 我想讲的下一点是反对继承的构成。 <br><br><img src="https://habrastorage.org/webt/l5/9m/qg/l59mqgla1anz9rqv3sla16adtiw.jpeg"><br><br><ol><li> 完成协调器的第一种方法是在将NavigationController从外部传递给<strong>组合</strong>并作为属性存储在本地时<strong>进行组合</strong> 。 这就像一个合成-我们为其添加了NavigationController作为属性。 </li><li> 另一方面，有一种观点认为UI套件中包含了所有内容，因此我们不需要重新发明轮子。 您只需获取并<strong>继承UI</strong> <strong>NavigationController即可</strong> 。 </li></ol><br> 每个选项都有其优点和缺点，但就我个人而言， <strong>这种情况下</strong>的<strong>组合</strong>比继承<strong>更合适</strong> 。 继承通常是不太灵活的方案。 例如，如果需要将Navigation更改为UIPageController，则在第一种情况下，我们可以简单地使用通用协议（例如“显示下一个屏幕”）将其关闭，并方便地替换所需的容器。 <br><br> 从我的角度来看，最重要的论据是您在合成中向最终用户隐藏了所有不必要的方法。 事实证明，他跌倒的可能性较小。 您<strong>只剩下</strong> <strong>所需</strong> <strong>的</strong> <strong>API</strong> （例如Start方法）， <strong>仅此而已</strong> 。 他无法调用PushViewController，PopViewController方法，也就是说，以某种方式干扰了协调器的活动。 父类的所有方法都是隐藏的。 <br><br><h2> 故事板 <br></h2><br> 我认为，与segues一起应特别注意它们。 就个人而言， <strong>我支持</strong> <strong>segues</strong> ，因为它们可以使您快速熟悉脚本。 当新开发人员到来时，他不需要攀登代码，情节提要可以帮助您。 即使使用代码创建接口，也可以保留空的ViewController，并使用代码组成接口，但至少要保留过渡和整个要点。 情节提要的全部本质在于过渡本身，而不是UI的布局。 <br><br> 幸运的是， <strong>协调器方法并不限制工具的选择</strong> 。 我们可以安全地与Segue一起使用协调器。 但是我们必须记住，现在我们不能在UIViewController中使用segues。 <br><br><img src="https://habrastorage.org/webt/hp/sl/qp/hpslqpf2-het-coms7wczezguo8.jpeg"><br><br> 因此，我们必须在类中重写onPrepareForSegue方法。 我们将通过回调将这些任务再次委派给协调器，而不是在控制器内部做任何事情。 调用onPrepareForSegue方法时，您自己不会做任何事情-您不知道它是什么样的segue，它是什么目标控制器-对您而言无关紧要。 您只需将其全部放入回调中，协调器就会弄清楚。 他有此知识，您不需要此知识。 <br><br> 为了简化一切，您可以在特定的Base类中执行此操作，以免在单独使用的每个控制器中覆盖它。 在这种情况下，协调员处理您的任务将更加方便。 <br><br> 我对Storyboard感到方便的另一件事是，坚持<strong>一个</strong> <strong>Storyboard等于一个协调员</strong>的规则。 然后，您可以大大简化所有内容，大致上讲一个类-StoryboardCoordinator，并在其中生成RootType参数，在Storyboard中创建初始Navigation控制器，然后将整个脚本包装在其中。 <br><br><img src="https://habrastorage.org/webt/sm/v2/wz/smv2wzspn7ykrajsui8npmfvcls.jpeg"><br><br> 如您所见，这里的协调器具有2个属性：navigationController; 我们的RootType的rootViewController是通用的。 在初始化期间，我们将其传递给我们的根导航及其第一个控制器，而不是特定的navigationController，而是一个Storyboard。 这样，我们甚至不必调用任何Start方法。 也就是说，您创建了一个协调器，他立即具有“导航”，并且立即具有“根”。 您可以模态显示“导航”，也可以使用“根目录”推入现有导航并继续工作。 <br><br> 在这种情况下，我们的UserEditCoordinator可以简单地变成typealias，用通用参数替换其RootViewController的类型。 <br><br><h2> 脚本数据传回 <br></h2><br> 让我们谈谈我在开始时概述的最后一个问题。 这是将数据传输回脚本。 <br><br><img src="https://habrastorage.org/webt/i6/i9/el/i6i9el9jdxqnjqp2pe80epk27iy.jpeg"><br><br> 考虑选择城市的相同方案，但是现在可以选择一个城市而不是一个城市。 为了向用户显示他已经选择了同一区域内的多个城市，我们将在屏幕上显示区域列表，该区域列表旁边的区域名称旁边会显示一个小数字，显示该区域内选择的城市数量。 <br><br> 事实证明，对一个控制器（对第三个控制器）的操作应立即导致其他几个控制器的外观发生变化。 也就是说，首先，我们必须在带有城市的单元格中显示，而在第二步中，我们必须更新所选区域中的所有数字。 <br><br> 协调器通过将数据传输回脚本简化了此任务-现在，这就像根据脚本向前传输数据一样简单。 <br><br> 这是怎么回事 用户选择一个城市。 该消息被发送到协调器。 正如我在演示中已展示的那样，协调器遍历整个导航堆栈，并将更新的数据发送给所有感兴趣的各方。 因此，ViewController可以使用此数据更新其View。 <br><br><h2> 重构现有代码 <br></h2><br> 如果要将这种方法嵌入到具有MVc，MVVm或MVp的现有应用程序中，该如何重构现有代码？ <br><br><img src="https://habrastorage.org/webt/dd/_h/ss/dd_hssepys-qb1ybs9tg6qhnlqo.jpeg"><br><br> 您有一堆ViewController。 要做的第一件事是将它们分为参与方案。 在我们的示例中，有3种情况：授权，配置文件编辑，磁带。 <br><br><img src="https://habrastorage.org/webt/nb/gy/yq/nbgyyqm1qsj1jb_nasqr5wdtdnk.jpeg"><br><br> 现在，我们将每个方案包装在协调器中。 实际上，我们应该能够从应用程序中的任何位置启动这些脚本。 这应该是灵活的- <strong>协调者必须完全自给自足</strong> 。 <br><br> 这种开发方法提供了更多的便利。 它包含以下事实：如果您当前正在使用特定方案，则无需在每次启动时都单击它。 您可以从头开始快速启动，编辑其中的内容，然后删除此临时开始。 <br><br> 在确定了协调员之后，我们需要确定哪个方案可以导致另一个方案的开始，并根据这些方案组成一棵树。 <br><br><img src="https://habrastorage.org/webt/ya/y0/dn/yay0dneeqirzezm667lwklnkux0.jpeg"><br><br> 在我们的例子中，树很简单：LoginCoordinator可以启动配置文件编辑协调器。 在这里，几乎所有内容都准备就绪，但仍有一个非常重要的细节-我们的计划缺乏切入点。 <br><br><img src="https://habrastorage.org/webt/38/-0/no/38-0nolfpsqej62yytkzqp-ux6s.jpeg"><br><br> 该入口点将是一个特殊的协调器<strong>-ApplicationCoordinator</strong> 。 它是由<strong>AppDelegate</strong>创建和启动的，然后它已经在应用程序级别控制逻辑，即该协调器现在开始。 <br><br> 我们只是看了一个非常相似的电路，只有它有ViewController而不是协调器，并且做到了这一点，以便ViewController不了解彼此，也不相互传递数据。 原则上，协调员也可以这样做。 我们可以在其中指定某个输入（开始方法）和输出（onFinish回调）。  <strong>协调器变得独立，可重用且易于测试</strong> 。 协调器不再相互了解，并且仅与ApplicationCoordinator通信。 <br><br> 您需要小心，因为如果您的应用程序具有足够的这些脚本，那么ApplicationCoordinator可以变成一个巨大的上帝对象，它将知道所有现有的脚本-这也不是很酷。 在这里，我们必须已经可以看到-也许将协调器划分为子协调器，也就是说，考虑这样的体系结构，以使这些对象不会增长到令人难以置信的大小。  <strong>尽管大小并非始终是重构的原因</strong> 。 <br><br><h3> 从哪里开始 <br></h3><br> 我建议从头开始-首先实施单个脚本。 <br><br><img src="https://habrastorage.org/webt/rw/tw/al/rwtwalrny6uxjzbpfhcjzxybzse.jpeg"><br><br> 解决方法是，可以在UIViewController内部启动它们。 也就是说，只要您没有Root或其他协调器，就可以创建一个协调器，作为临时解决方案，可以从UIViewController启动它，并将其本地保存在属性中（如上nextCoordinator所示）。 当发生事件时，正如我在演示中所展示的，您将创建一个本地属性，在其中放置协调器，并在其上调用Start方法。 一切都非常简单。 <br><br> 然后，当所有这些协调器都已完成时，一个在另一个内部的开始看起来完全相同。 您是否具有本地属性或某种类型的依赖项数组（例如，协调器），请将所有这些内容放在那里，以免其失控，然后调用Start方法。 <br><br><h2> 总结 <br></h2><br><ul><li> 不了解彼此的<strong>独立屏幕和脚本</strong>不会相互通信。 我们试图实现这一目标。 <br></li><li> 在不更改屏幕代码的情况下<strong>，可以轻松更改</strong>应用程序中屏幕<strong>的顺序</strong> 。 如果一切都按计划进行，则脚本更改时应用程序中唯一应更改的不是屏幕代码，而是协调程序代码。 <br></li><li>  <strong>屏幕之间的简化数据传输</strong>以及其他暗示屏幕之间连接的任务。 <br></li><li>      —    ,       <strong>  </strong>     . <br></li></ul><br><blockquote> AppsConf 2018  8  9  —  !   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>  )  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> .      — iOS  Android,      ,       ,     ,      . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN423299/">https://habr.com/ru/post/zh-CN423299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN423285/index.html">社会工程：网络安全世界中难以捉摸的敌人</a></li>
<li><a href="../zh-CN423291/index.html">俄罗斯人创造了记录：每人110部盗版电影</a></li>
<li><a href="../zh-CN423293/index.html">如何不使用状态机射击自己的腿</a></li>
<li><a href="../zh-CN423295/index.html">最有用的移动开发大会</a></li>
<li><a href="../zh-CN423297/index.html">从Android开发人员到DevOps</a></li>
<li><a href="../zh-CN423303/index.html">AI，实践课程。 基于情感的音乐转型</a></li>
<li><a href="../zh-CN423305/index.html">破坏表现</a></li>
<li><a href="../zh-CN423307/index.html">Visual Studio代码中的GitHub提取请求</a></li>
<li><a href="../zh-CN423309/index.html">DBMS交易</a></li>
<li><a href="../zh-CN423311/index.html">伙伴关系Naviaddress和ACTUM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>