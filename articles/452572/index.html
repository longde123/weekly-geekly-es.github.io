<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôâÔ∏è üïù üç™ EFORTH para MK-161: estructuras de datos ü§Ωüèº ü§∂üèΩ üèñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo es el final de una serie de art√≠culos de eForth sobre una calculadora programable. Comience aqu√≠ 

 Los comandos del idioma de entrada "...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EFORTH para MK-161: estructuras de datos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452572/">  <i>Este art√≠culo es el final de una serie de art√≠culos de eForth sobre una calculadora programable.</i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comience aqu√≠</a></i> <br><br>  Los comandos del idioma de entrada "Electr√≥nica MK-161" ocupan solo la mitad del archivo eForth0.mkl.  La segunda mitad est√° ocupada por tablas, cuyo desarrollo no fue menos dif√≠cil que escribir la parte algor√≠tmica del traductor.  Intentemos descubrir c√≥mo se usan estas tablas. <br><img src="https://habrastorage.org/webt/02/fk/fj/02fkfjzcgzqhki9p-xj7mwfmftw.jpeg"><br><a name="habracut"></a><br>  El profesor Wirth ense√±a que "programar en peque√±o" consiste en desarrollar dos componentes igualmente importantes: algoritmos y estructuras de datos. <br><br>  Ya hemos encontrado una estructura de datos eForth.  Este es el cuerpo de VCA (palabras de alto nivel) ubicado en la memoria de bytes.  Cuatro manejadores interpretan los campos de par√°metros de "su propio" VCA de diferentes maneras: <br><br><pre><code class="plaintext hljs">.DB DOVAR ;      .DB ‚Ä¶ ;      .DB DOCON ;    .DW _ ;   .DB DOCONM ;     .DW _ ;   .DB DOLST ;     .DW 1, 2,‚Ä¶ EXITT ;  </code> </pre> <br>  La siguiente estructura de datos relativamente simple est√° asociada con los "mensajes est√°ndar" de TYPE.  <b>Todos los mensajes de eForth est√°n numerados y transferidos a la memoria barata del programa.</b>  Si la palabra TIPO imprime una sola letra, su c√≥digo puede ser el n√∫mero de dicho mensaje, de 0 a 7. <br><br><pre> <code class="plaintext hljs">;   TYPE .BASE tblTYPE: .DBB str7,str6, str5, str4, str3, str2, str1, str0</code> </pre> <br>  En el lenguaje MK extendido, el seudocomando .BASE establece la "base" para el comando .DBB, que coloca secuencialmente los desplazamientos de l√≠nea str7, str6, en bytes, etc.  relativo a la etiqueta base tblTYPE.  Al agregar n√∫meros del 0 al 7 a la direcci√≥n de la tabla, se puede leer este desplazamiento.  Al agregar el desplazamiento encontrado a tblTYPE, obtenemos la direcci√≥n de la l√≠nea deseada. <br><br>  El primer byte de la cadena contiene su longitud.  eForth hace un uso extensivo de tales <i>l√≠neas de conteo</i> . <br><br>  Tambi√©n encontramos la tabla tblTokens, que enumera las direcciones de c√≥digo de las 208 palabras incrustadas.  Si la palabra no es primitiva, la tabla contiene 0. Ir a la direcci√≥n 0 har√° que eForth se reinicie, con un chirrido. <br><br>  Tambi√©n se mencion√≥ la tabla tblNames, en referencia a los nombres de las mismas 208 palabras.  Estos nombres en forma de l√≠neas de conteo se almacenan en la misma memoria de programa "de goma".  La tabla tblNames en s√≠ no estar√° disponible mientras se ejecuta eForth, pero la informaci√≥n contenida en ella no se perder√°.  En tiempo de compilaci√≥n, eForth.f transferir√° la direcci√≥n de los nombres a una estructura de datos m√°s conveniente almacenada en la memoria decimal (ver 2). <br><br>  Tambi√©n habl√© sobre tblCHPUT, una tabla asociativa de c√≥digos de control cuando mostraba una letra en la pantalla de una calculadora.  Otras siete tablas, desde tblKeyNum hasta tblKeyRusF, traducen el c√≥digo de un bot√≥n presionado en diferentes modos de teclado a un c√≥digo de letra de 8 bits.  La direcci√≥n de la subrutina responsable del modo de teclado activo est√° en el registro decimal ptrKbdInt. <br><br>  En total, solo una estructura de datos permaneci√≥ sin ensamblar en el archivo eForth0.mkl, estas son tablas de reconocimiento de nombres.  Dej√©moslos de postre (ver 5) despu√©s del plato principal: dos tablas de encabezados almacenadas en la memoria decimal.  Primero, nos armaremos con herramientas para "rellenar" estos encabezados. <br><br><h3>  1. Trabajar con encabezados: ¬°CABEZA!  y HEAD @ </h3><br><pre> <code class="plaintext hljs">HEAD! ( xt nfa r -- )     r,  xt  nfa. HEAD@ ( r -- xt nfa lex )     r,  xt, nfa  .</code> </pre><br>  Un registro decimal MK-161 puede memorizar 12 lugares decimales.  eForth utiliza este registro para almacenar tres n√∫meros peque√±os, cada uno de 0 a 9999. Los <b>tres "campos" para almacenar estos n√∫meros se denominan A, B y C: AAAABBBBCCCC.</b>  El signo decimal se refiere solo al campo A. <br><br>  La primitiva HEAD @ obtiene el n√∫mero de registro y divide el n√∫mero desde all√≠ en campos, y HEAD!  recopila campos en un n√∫mero largo y escribe el "monstruo" resultante en el registro especificado.  Pero hay matices. <br><br>  El "encabezado decimal" de la palabra contiene en el campo A la direcci√≥n de su nombre (nfa).  Si esta direcci√≥n es negativa, el nombre se almacena en la memoria del programa.  El campo B contiene la palabra token (xt).  El campo C se llama l√©xico.  Almacena el bit INMEDIATO y una se√±al de que la palabra est√° destinada solo para compilaci√≥n. <br><br>  HEAD @ divide el encabezado en partes.  En la parte superior de la pila est√° el campo del l√©xico C, debajo est√° el campo de nombre A. El campo B, en el que generalmente se almacena el token, est√° en la parte inferior. <br><br>  CABEZA!  restablece el campo C. <br><br><h3>  2. Encabezados en l√≠nea </h3><br><img src="https://habrastorage.org/webt/ny/_t/g7/ny_tg7mxwoqm9h65nlq4ybfcazu.png"><br><br>  Los encabezados de cada una de las 208 palabras incorporadas (0 a 207) van en orden, comenzando con R44.  El campo A siempre contiene un n√∫mero negativo, ya que los nombres de estas palabras est√°n codificados en la memoria del programa. <br><br>  Los campos B y C son editables.  Por lo tanto, el usuario puede redefinir las palabras incorporadas y hacer lo INMEDIATO que necesita de ellas (ver 4). <br><br><h3>  3. Encabezados de usuario </h3><br><img src="https://habrastorage.org/webt/gh/lw/3v/ghlw3v8ajgu1dhgfiyoughzpngm.png"><br><br>  Trabajar con solo 208 nombres predefinidos ahorra bytes de memoria, pero es inusualmente aburrido.  Por lo tanto, desarroll√© otra estructura de datos donde la fantas√≠a al elegir un nombre se limita a solo 32 letras.  Esta estructura consta de 32 <i>listas</i> , cada una de las cuales es responsable de las palabras del usuario de cierta longitud.  Cada una de estas 32 listas tiene un t√≠tulo personal.  Las listas mismas saltan sobre la memoria decimal, pero sus encabezados siempre se almacenan en R301 ... R332. <br><br>  <b>Ordenar palabras por longitud de nombre es un punto destacado importante de 161eForth.</b>  La ordenaci√≥n reduce en gran medida el n√∫mero de comparaciones cuando busca una palabra por su nombre, lo que acelera la compilaci√≥n.  ¬øQui√©n necesita funciones hash si cada nombre tiene una longitud conocida? <br><br>  Para simplificar, el <i>encabezado de la lista</i> tiene la misma estructura con los campos A, B y C que el encabezado de la palabra.  El prop√≥sito de estos campos es diferente.  El campo A contiene el n√∫mero del primer registro en la lista.  El campo B contiene el n√∫mero de registros proporcionados a la lista.  El campo C almacena el n√∫mero de palabras cuyos encabezados ya est√°n en la lista. <br><br>  Al comienzo del trabajo, los campos C son iguales a cero; las palabras est√°n ausentes en todas las listas.  Los campos B son 2, cada lista tiene un par de registros para comenzar.  Los campos A indican bloques de 2 registros que comienzan con R333. <br><br>  Cada lista contiene encabezados de palabras.  Ya los hemos desmontado (ver. 1).  Aqu√≠, tal vez, la direcci√≥n del nombre (nfa) ser√° positiva y apuntar√° a la l√≠nea de conteo, tradicionalmente almacenada frente al cuerpo del VCA.  Adem√°s, el token en el campo B es la direcci√≥n del campo de c√≥digo (cfa) que entra en la memoria binaria inmediatamente despu√©s de este nombre.  Hay una excepci√≥n: <b>si la palabra ya se ha determinado, el campo A apuntar√° al nombre anterior.</b>  ¬øPor qu√© guardar la cuerda de nuevo?  La memoria binaria es cara. <br><br>  Cuando todos los registros de la lista est√°n llenos (B = C), la palabra PUBLICAR proporciona 5 lugares m√°s libres, empujando esta estructura de datos en el lugar correcto y ajustando los enlaces (A) en los encabezados de la lista. <br><br><h3>  4. Publicaci√≥n de una nueva palabra: TRABAJAR y PUBLICAR </h3><br><pre> <code class="plaintext hljs">LAST ( -- a )      . WORK ( -- a )     . PUBLISH ( -- )     . $,n ( nfa -- )     ,    nfa. ?UNIQUE ( a -- a )  ,    .</code> </pre><br>  La estructura de datos desarrollada para el MK-161 para almacenar t√≠tulos de palabras result√≥ ser pr√°ctica y f√°cil de integrar en eForth.  Cuando CREAR, CONSTANTE o: crea una nueva palabra, acceden a la palabra del sistema $, n para crear un t√≠tulo para la palabra con el nombre dado.  $, n se refiere a? √öNICO para la verificaci√≥n: ¬øcreamos una nueva palabra o redefinimos la antigua? <br><br>  Si ya existe una palabra con el mismo nombre, √öNICO advierte al usuario sobre esto.  Al mismo tiempo, la direcci√≥n del encabezado redefinido se ingresa en la √öLTIMA variable del sistema.  Para una nueva palabra, LAST se restablece a cero. <br><br>  En cualquier caso, $, n crea un nuevo encabezado en la variable TRABAJO: es un registro decimal que puede almacenar 12 bits del encabezado.  Si no se encontr√≥ el nombre, se incluye en el diccionario antes del campo de c√≥digo, como sucede en 86eForth y muchos otros Forts.  <b>El MK-161 logr√≥ prescindir de un "campo de comunicaci√≥n"</b> , lo que tambi√©n ahorra memoria binaria. <br><br>  La primitiva PUBLICAR completa la definici√≥n de una palabra.  Al compilar palabras de dos puntos, PUBLISH se llama desde ;; como resultado, no se requiri√≥ el bit SMUDGE.  La √∫ltima variable determina el lugar donde se copia el encabezado de WORK.  Si LAST es cero, se crea un nuevo encabezado en la lista correspondiente (ver 3).  ¬øEst√° completa la lista?  Luego PUBLISH agregar√° 5 registros m√°s, cuatro de ellos para el futuro. <br><br>  Despu√©s de ejecutar PUBLISH, la variable LAST siempre apunta al t√≠tulo de la √∫ltima palabra.  Esto ayuda a INMEDIATO a hacer su trabajo cambiando el campo del l√©xico. <br><br><h3>  5. (ENCONTRAR) y tablas de reconocimiento de nombre </h3><br><pre> <code class="plaintext hljs">(FIND) ( a -- r T | a F )    r,        a. FIND ( a -- a F | xt 1 | xt -1)    .  1,  IMMEDIATE.</code> </pre><br>  Un primitivo (ENCONTRAR) gestiona la b√∫squeda de una palabra por su nombre.  Primero, busca un nombre entre las palabras incorporadas con nombres previamente conocidos, luego verifica la lista de palabras de usuario con la longitud de nombre deseada (ver 3).  Las tablas de reconocimiento de nombres aceleran enormemente este "primero".  As√≠ es como funcionan. <br><br>  Al principio (ENCONTRAR) encuentra en la matriz tblLen la direcci√≥n de la tabla asociativa principal, en la que los nombres conocidos de la longitud requerida est√°n "preparados".  En esta tabla (ENCONTRAR) busca el primer car√°cter del nombre.  En la mayor√≠a de los casos, esto le permite averiguar de inmediato el <i>n√∫mero de registro de t√≠tulo de la</i> palabra buscada, por la primera letra y la longitud. <br><br>  Sucede que varias palabras de la misma longitud tienen las mismas primeras letras.  Luego, en lugar del n√∫mero de registro (FIND), se topa con la direcci√≥n de la siguiente tabla asociativa (el n√∫mero de lectura es 300 o m√°s) y la b√∫squeda contin√∫a en la segunda letra.  Y as√≠ sucesivamente, hasta que se encuentre la palabra o se establezca que no existe dicha palabra. <br><br>  Por supuesto, despu√©s de una coincidencia para las primeras letras (ENCONTRAR), se verifica el nombre completo.  Pero las <b>tablas de reconocimiento hicieron que eForth sea r√°pido</b> .  Esta primavera, invert√≠ mucho de mi tiempo en ellos, y ahora ahorran tiempo de b√∫squeda.  Las "claves" en ellas est√°n incluso ordenadas alfab√©ticamente.  Lo sentimos, el firmware MK-161 lo escupe. <br><br>  En aras de la compatibilidad, implement√© la palabra ENCONTRAR de Fort ANS [4], que conf√≠a en la primitiva "trabajo negro" (ENCONTRAR).  La palabra ya considerada? √öNICO tambi√©n est√° buscando su argumento a trav√©s de (ENCONTRAR). <br><br><h3>  6. Int√©rprete externo </h3><br>  El libro [1] contiene una descripci√≥n exhaustiva de eForth, que incluye un int√©rprete externo de "texto".  Es √©l quien ejecuta o compila el texto fuente en el idioma Fort.  Las diferencias con los int√©rpretes textuales de otros dialectos de Fort ([2], [3]) han aparecido en las √∫ltimas d√©cadas, pero hay pocas. <br><br>  A continuaci√≥n se muestra un diagrama de bloques de un int√©rprete de texto tomado de [1].  Tenga cuidado: ¬°este "int√©rprete" tiene un modo de compilaci√≥n!  La palabra $ COMPILE es responsable de compilar el texto de Forte en "c√≥digo cosido", cuya ejecuci√≥n examinamos con tanto detalle en el primer art√≠culo.  Cuando se ejecuta $ INTERPRET, las palabras ingresadas se ejecutan inmediatamente - modo de interpretaci√≥n.  EVAL "calcula" toda la cadena ingresada, invocando una de estas dos palabras para cada palabra ingresada. <br><br><img src="https://habrastorage.org/webt/fw/p0/lh/fwp0lhb3kpioz07jrwbrpz4-md8.jpeg"><br><br>  Despu√©s del diagrama de bloques, el autor descifra cu√°l de los bloques lo hace.  Aqu√≠ est√° su traducci√≥n.  Los nombres de bloque generalmente coinciden con los nombres de palabras de eForth.  La palabra NOMBRE?  est√° ausente en mi implementaci√≥n, se reemplaz√≥ con √©xito por r√°pido (ENCONTRAR) (ver. 5). <br><br><div class="scrollable-table"><table><tbody><tr><td>  PRINCIPAL </td><td>  Configurar un motor Fort virtual </td></tr><tr><td>  FR√çO </td><td>  Inicializar variables del sistema </td></tr><tr><td>  Abortar </td><td>  Vaciar pila de datos.  Controlador de errores </td></tr><tr><td>  SALIR </td><td>  Restablezca la pila de retorno e ingrese al bucle de int√©rprete </td></tr><tr><td>  Consulta </td><td>  Aceptar entrada de texto desde terminal </td></tr><tr><td>  EVAL </td><td>  Calcular o interpretar una cadena de texto </td></tr><tr><td>  PARSE </td><td>  Seleccione una palabra del texto ingresado </td></tr><tr><td>  $ INTERPRETACI√ìN </td><td>  Interpreta la palabra </td></tr><tr><td>  $ COMPILAR </td><td>  Compilar palabra </td></tr><tr><td>  NOMBRE </td><td>  Busca una palabra en un diccionario </td></tr><tr><td>  N√öMERO? </td><td>  Convertir cadena de texto a entero </td></tr><tr><td>  EJECUTAR </td><td>  Ejecutar palabra </td></tr><tr><td>  ¬øInmediato? </td><td>  ¬øEs esta palabra una orden inmediata? </td></tr><tr><td>  Literal </td><td>  Compilar un literal completo </td></tr><tr><td>  Compilar </td><td>  Compilar token </td></tr></tbody></table></div><br><br>  El libro tambi√©n proporciona el c√≥digo fuente para cada palabra eForth en la versi√≥n de Windows, con breves explicaciones.  ¬øCu√°l es la versi√≥n para MK-161 diferente? Ya te lo dije.  El c√≥digo fuente para mi implementaci√≥n est√° en el archivo: <a href="">the-hacker.ru/2019/161eforth0.5b.zip</a> <br><br>  Finalmente, mencionar√© la implementaci√≥n de la palabra <b>(PARSE) en el lenguaje MK-161</b> : en Windows es VCA.  La depuraci√≥n tom√≥ una semana, pero <b>aceler√≥ la compilaci√≥n a la mitad</b> .  La palabra (PARSE) hace todo el "trabajo sucio" para que PARSE a√≠sle palabras individuales del flujo de texto de entrada. <br><br>  Mis adiciones al int√©rprete externo son dos palabras, adem√°s del ciclo habitual de SALIDA: el TLOAD ya mencionado y tomado de versiones anteriores de ARCHIVO.  La palabra ARCHIVO traduce E / S a la consola, pero lee l√≠neas para interpretaci√≥n desde el puerto RS-232.  Despu√©s del procesamiento exitoso de cada l√≠nea, se env√≠a al puerto una carta con el c√≥digo 11. El archivo descargado de la computadora debe terminar con la palabra QUIT. <br><br>  Todav√≠a no he depurado la palabra ARCHIVO.  Si alguien lo necesita, comparta sus impresiones. <br><br>  La revisi√≥n 161eForth de los lugares dif√≠ciles ha terminado, pero Fort es una herramienta incre√≠blemente flexible que cada propietario puede personalizar.  Incluso cuando hayas descubierto todo a fondo, alguien en alg√∫n lugar del planeta inventar√° otro truco que puede sorprenderte. <br><br>  Aqu√≠ est√°n las palabras finales del autor eForth de [1]: <br><br><blockquote>  Durante 26 a√±os, he reescrito eForth muchas, muchas veces.  En cada doblaje, trat√© de hacerlo m√°s simple y claro.  Ahora en 86eForth v5.2, creo que he logrado la correcci√≥n y, por lo tanto, estoy muy feliz. <br><br>  Como dijo Einstein: <br>  <b>Todo debe hacerse lo m√°s simple posible, pero no m√°s simple.</b> <br><br>  Hacer 86eForth v5.2 a√∫n m√°s f√°cil, quiz√°s romperlo o no ser √∫til como herramienta de programaci√≥n. </blockquote><h3>  Literatura </h3><br><ol><li>  Dr.  Chen-Hanson Ting.  eForth and Zen - 3rd Edition, 2017. Disponible en Amazon Kindle. </li><li>  Baranov S.N., Nozdrunov N.R.  Fuerte lenguaje y su implementaci√≥n.  - L .: Ingenier√≠a mec√°nica.  Leningrado  Departamento, 1988. </li><li>  Semenov Yu.A.  Programaci√≥n en el lenguaje FORT.  - M .: Radio y comunicaciones, 1991. </li><li>  ANS Cuarto est√°ndar.  X3.215-1994.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Traducci√≥n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentaci√≥n SP-Forth</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Offete Enterprises (Dr. Chen-Hanson Ting)</a> , autor de 86eForth v5.2, est√° en ingl√©s. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La historia de Mikhail Pukhov "True Truth"</a> con el programa "Moonwalker-1", donde obtuve KDPV y me encantan las calculadoras sovi√©ticas. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452572/">https://habr.com/ru/post/452572/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452562/index.html">Escribir c√≥digo JavaScript limpio y escalable: 12 consejos</a></li>
<li><a href="../452564/index.html">Caracter√≠sticas de Python 3 que vale la pena usar</a></li>
<li><a href="../452566/index.html">Node.js para principiantes: los fundamentos de trabajar con archivos</a></li>
<li><a href="../452568/index.html">Un an√°lisis detallado de las nuevas caracter√≠sticas de React 16+, parte 1: informaci√≥n general</a></li>
<li><a href="../452570/index.html">Linux Install Fest - vista lateral</a></li>
<li><a href="../452576/index.html">Acerca de los introvertidos en TI</a></li>
<li><a href="../452580/index.html">20 proyectos, 20 idiomas, fecha l√≠mite ayer. Parte 3</a></li>
<li><a href="../452584/index.html">Conceptos err√≥neos de los programadores sobre el tiempo Unix</a></li>
<li><a href="../452586/index.html">C√≥mo comenzar a programar en Adobe Illustrator. Primera parte</a></li>
<li><a href="../452590/index.html">El estadounidense cre√≥ un aula m√≥vil para ense√±ar a los ni√±os en escuelas de impresi√≥n 3D de bajo presupuesto, el proyecto ya ha recolectado m√°s de 100,000</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>