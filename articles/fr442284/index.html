<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐎 😙 🧑🏾‍🤝‍🧑🏽 NoVerify: le linter pour PHP de l'équipe VKontakte est maintenant dans le domaine public 👎🏽 👩🏽‍🤝‍👨🏻 🕵️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je vais vous dire comment nous avons réussi à écrire un linter qui s'est avéré assez rapide pour vérifier les changements lors de chaque push git et l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NoVerify: le linter pour PHP de l'équipe VKontakte est maintenant dans le domaine public</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/442284/"><img src="https://habrastorage.org/webt/zu/fg/gw/zufggwwy-grc8n2umc_p0_ioskw.png"><br><br>  Je vais vous dire comment nous avons réussi à écrire un linter qui s'est avéré assez rapide pour vérifier les changements lors de chaque push git et le faire en 5-10 secondes avec une base de code de 5 millions de lignes en PHP.  Nous l'avons appelé NoVerify. <br><br>  NoVerify prend en charge des éléments de base tels que la transition vers la définition et la recherche d'utilisations et est capable de fonctionner en mode <a href="">Language Server</a> .  Tout d'abord, notre outil est axé sur la recherche d'erreurs potentielles, mais il peut également vérifier le style.  Aujourd'hui, son code source est apparu en open-source sur GitHub.  Recherchez le lien à la fin de l'article. <br><a name="habracut"></a><br><h2>  Pourquoi avons-nous besoin de notre linter </h2><br>  Mi-2018, nous avons décidé qu'il était temps d'implémenter un linter pour le code PHP.  Il y avait deux objectifs: réduire le nombre d'erreurs visibles par les utilisateurs et surveiller plus strictement la conformité au style de code.  L'accent principal était mis sur la prévention des erreurs typiques: la présence de variables non déclarées et inutilisées dans le code, le code inaccessible et d'autres.  Je souhaitais également que l'analyseur statique fonctionne le plus rapidement possible sur notre base de code (5-6 millions de lignes de code PHP au moment de la rédaction). <br><br>  Comme vous le savez probablement, le code source de la plupart du site est écrit en PHP et compilé en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">KPHP</a> , il serait donc logique d'ajouter ces vérifications au compilateur.  Mais en fait, tout le code n'a pas de sens pour s'exécuter via KPHP - par exemple, le compilateur est faiblement compatible avec les bibliothèques tierces, donc pour certaines parties du site PHP standard est toujours utilisé.  Ils sont également importants et doivent être vérifiés par le linter, donc, malheureusement, il n'y a aucun moyen de l'intégrer dans KPHP. <br><br><h2>  Pourquoi NoVerify </h2><br>  Compte tenu de la quantité de code PHP (je me souviens qu'il s'agit de 5-6 millions de lignes), il n'est pas possible de le "corriger" immédiatement pour qu'il passe nos vérifications dans le linter.  Néanmoins, je veux que le code changeant devienne progressivement plus propre et suive plus strictement les normes de codage, et contienne également moins d'erreurs.  Par conséquent, nous avons décidé que le linter devrait être en mesure de vérifier les modifications que le développeur allait lancer, et ne pas jurer sur le reste. <br><br>  Pour ce faire, le linter doit indexer l'intégralité du projet, analyser complètement les fichiers avant et après les modifications et calculer la différence entre les avertissements générés.  De nouveaux avertissements sont montrés au développeur, et nous exigeons qu'ils soient corrigés avant de pouvoir pousser. <br><br>  Mais il y a des situations où ce comportement est indésirable, et les développeurs peuvent alors pousser sans hook local - en utilisant la commande <code>git push --no-verify</code> .  Option <code>--no-verify</code> et a donné un nom à un linter :) <br><br><h2>  Quelles étaient les alternatives </h2><br>  La base de code dans VK utilise peu de POO et se compose essentiellement de fonctions et de classes avec des méthodes statiques.  Si les classes en PHP prennent en charge le chargement automatique, les fonctions ne le font pas.  Par conséquent, nous ne pouvons pas utiliser d'analyseurs statiques sans modifications importantes, qui fondent leur travail sur le fait que le chargement automatique chargera tout le code manquant.  Ces linters comprennent, par exemple, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">psaume de Vimeo</a> . <br><br>  Nous avons examiné les outils d'analyse statique suivants: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PHPStan</a> - mono-thread, nécessite un chargement automatique, l'analyse de la base de code a atteint 30% en une demi-heure; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Phan</a> - même en mode rapide avec 20 processus, l'analyse a calé de 5% après 20 minutes; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Psaume</a> - nécessite un chargement automatique, l'analyse a pris 10 minutes (je voudrais quand même être beaucoup plus rapide); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PHPCS</a> - vérifie le style, mais pas la logique; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">phpcf</a> - vérifie uniquement le formatage. </li></ul><br>  Comme vous pouvez le deviner d'après le titre de l'article, aucun de ces outils ne répond à nos exigences, nous avons donc rédigé les nôtres. <br><br><h2>  Comment le prototype a-t-il été créé? </h2><br>  Tout d'abord, nous avons décidé de construire un petit prototype afin de comprendre s'il valait la peine d'essayer de fabriquer un linterne à part entière.  Étant donné que l'une des exigences importantes pour le linter est sa vitesse, au lieu de PHP, nous avons choisi Go.  «Rapide» consiste à donner un feedback au développeur le plus rapidement possible, de préférence en 10 à 20 secondes maximum.  Sinon, le cycle "corriger le code, relancer le linter" commence à ralentir considérablement le développement et à gâcher l'humeur des gens :) <br><br>  Puisque Go est sélectionné pour le prototype, vous avez besoin d'un analyseur PHP.  Il y en a plusieurs, mais le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">php-parser nous</a> a semblé le plus abouti.  Cet analyseur n'est pas parfait et est toujours en cours de développement, mais pour nos besoins, il est tout à fait approprié. <br><br>  Pour le prototype, il a été décidé d'essayer de mettre en œuvre l'une des inspections les plus simples, à première vue: l'accès à une variable non définie. <br><br>  L'idée de base pour implémenter une telle inspection semble simple: pour chaque branche (par exemple, pour if), créez une portée imbriquée distincte et combinez les types de variables à la sortie de celle-ci.  Un exemple: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rand()) { $a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  : { $a: int } } else { $b = "test"; $a = "another_test"; //  : { $b: string, $a: string } } //   : { $b: string?, $a: int|string } echo $a, $b; //       , //   $b   </span></span></code> </pre><br>  Ça a l'air simple, non?  Dans le cas des instructions conditionnelles ordinaires, tout fonctionne bien.  Mais nous devons gérer, par exemple, passer sans interruption; <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (rand()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: $a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// { $a: int } case 2: $b = 2; // { $a: int, $b: int } default: $c = 3; // { $a: int, $b: int, $c: int } } // { $a: int?, $b: int?, $c: int }</span></span></code> </pre><br>  Il ne ressort pas immédiatement du code que $ c sera en fait toujours défini.  Plus précisément, cet exemple est fictif, mais il illustre bien ce que sont les moments difficiles pour le linter (et pour la personne dans ce cas aussi). <br><br>  Prenons un exemple plus complexe: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> exec(<span class="hljs-string"><span class="hljs-string">"hostname"</span></span>, $out, $retval); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $out, $retval; <span class="hljs-comment"><span class="hljs-comment">// { $out: ???, $retval: ??? }</span></span></code> </pre><br>  Sans connaître la signature de la fonction exec, on ne peut pas dire si $ out et $ retval seront définis.  Les signatures des fonctions intégrées peuvent être extraites du référentiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/JetBrains/phpstorm-stubs</a> .  Mais les mêmes problèmes se produiront lors de l'appel de fonctions définies par l'utilisateur, et leur signature ne peut être découverte qu'en indexant l'intégralité du projet.  La fonction exec prend les deuxième et troisième arguments par référence, ce qui signifie que les variables $ out et $ retval peuvent être définies.  Ici, l'accès à ces variables n'est pas nécessairement une erreur, et le linter ne doit pas jurer sur un tel code. <br><br>  Des problèmes similaires avec le passage implicite de liens se posent avec les méthodes, mais en même temps, la nécessité de déduire des types de variables est ajoutée: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rand()) { $a = some_func(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $a = other_func(); } $a-&gt;some_method($b); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $b;</code> </pre><br>  Nous devons savoir quels types les fonctions some_func () et other_func () renvoient afin de trouver plus tard une méthode appelée some_method dans ces classes.  Ce n'est qu'alors que nous pourrons dire si la variable $ b sera définie ou non.  La situation est compliquée par le fait que souvent les fonctions et méthodes simples n'ont pas d'annotations phpdoc, vous devez donc toujours être en mesure de calculer les types de fonctions et de méthodes en fonction de leur implémentation. <br><br>  Lors du développement du prototype, j'ai dû implémenter environ la moitié de toutes les fonctionnalités pour que l'inspection la plus simple fonctionne correctement. <br><br><h2>  Travailler comme serveur linguistique </h2><br>  Pour faciliter le débogage de la logique du linter et voir plus facilement les avertissements qu'il émet, nous avons décidé d'ajouter le mode de fonctionnement en tant que <a href="">serveur de langage pour PHP</a> .  En mode d'intégration avec Visual Studio Code, cela ressemble à ceci: <br><br><img src="https://habrastorage.org/webt/dr/ig/vj/drigvj1bhifibymyhcl_vzjq7q8.jpeg"><br><br>  Dans ce mode, il est pratique de tester des hypothèses et de tester des cas complexes (après cela, vous devez bien sûr écrire des tests).  Il est également bon de tester les performances: même sur des fichiers volumineux, l'analyseur php on Go affiche une bonne vitesse. <br><br>  Le support du serveur de langue est loin d'être idéal, car son objectif principal est de déboguer les règles de linter.  Cependant, dans ce mode, il existe plusieurs fonctionnalités supplémentaires: <br><br><ol><li>  Conseils pour les noms de variables, les constantes, les fonctions, les propriétés et les méthodes. </li><li>  Mettez en surbrillance les types de variables dérivés. </li><li>  Allez à la définition. </li><li>  Rechercher des utilisations. </li></ol><br><h2>  Inférence de type "paresseux" </h2><br>  En mode serveur de langue, les éléments suivants sont nécessaires pour fonctionner: vous modifiez le code dans un fichier, puis, lorsque vous passez à un autre, vous devez travailler avec des informations déjà mises à jour sur les types renvoyés dans les fonctions ou les méthodes.  Imaginez les fichiers en cours d'édition dans l'ordre suivant: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//  A.php,  1 class A { /** @var int */ public $prop; } //  B.php,   class B { public static function something() { $obj = new A; return $obj-&gt;prop; } } //  C.php,   $c = B::something(); // $c   int //  A.php,  2 class A { /** @var string &lt;---   string */ public $prop; } //  C.php,   $c = B::something(); // $c   string,   B.php,  C.php  </span></span></code> </pre><br>  Étant donné que nous ne forçons pas les développeurs à toujours écrire PHPDoc (en particulier dans de tels cas simples), nous avons besoin d'un moyen de stocker des informations sur le type de retour de la fonction B :: something ().  De sorte que lorsque le fichier A.php change, les informations de type dans le fichier C.php sont immédiatement à jour. <br><br>  Une solution possible consiste à stocker des "types paresseux".  Par exemple, le type de retour de la méthode B :: something () est en fait un type d'expression (new A) -&gt; prop.  Dans ce formulaire, le linter stocke des informations sur le type, et grâce à cela, vous pouvez mettre en cache toutes les méta-informations pour chaque fichier et les mettre à jour uniquement lorsque ce fichier change.  Cela doit être fait avec soin afin que des informations accidentellement trop spécifiques sur les types ne fuient pas.  Il est également nécessaire de modifier la version du cache lorsque la logique d'inférence de type change.  Néanmoins, un tel cache accélère la phase d'indexation (dont je parlerai plus tard) de 5 à 10 fois par rapport à l'analyse répétée de tous les fichiers. <br><br><h2>  Deux phases de travail: indexation et analyse </h2><br>  Comme nous nous en souvenons, même pour l'analyse de code la plus simple, des informations sont requises au moins sur toutes les fonctions et méthodes du projet.  Cela signifie que vous ne pouvez pas analyser un seul fichier séparément du projet.  Et pourtant - que cela ne peut pas être fait en un seul passage: par exemple, PHP vous permet d'accéder à des fonctions qui sont déclarées plus loin dans le fichier. <br><br>  En raison de ces limitations, le fonctionnement du linter comprend deux phases: l'indexation principale et l'analyse ultérieure des seuls fichiers nécessaires.  Maintenant, plus sur ces deux phases. <br><br><h3>  Phase d'indexation </h3><br>  Dans cette phase, tous les fichiers sont analysés et une analyse locale du code des méthodes et fonctions, ainsi que du code au niveau supérieur est effectuée (par exemple, pour déterminer les types de variables globales).  Les informations sur les variables globales déclarées, les constantes, les fonctions, les classes et leurs méthodes sont collectées et écrites dans le cache.  Pour chaque fichier du projet, le cache est un fichier distinct sur le disque. <br><br>  Un dictionnaire global de toutes les méta-informations sur le projet, qui ne changera pas à l'avenir, * est compilé à partir de pièces individuelles. <br><br>  <i>* En plus du mode de fonctionnement en tant que serveur de langue, lors de l'indexation et de l'analyse du fichier modifié est effectuée pour chaque édition.</i> <br><br><h3>  Phase d'analyse </h3><br>  Dans cette phase, nous pouvons utiliser des méta-informations (sur les fonctions, les classes ...) et déjà analyser directement le code.  Voici une liste de ce que NoVerify peut vérifier par défaut: <br><br><ul><li>  code inaccessible; </li><li>  accès aux objets sous forme de tableau; </li><li>  nombre d'arguments insuffisant lors de l'appel de la fonction; </li><li>  appeler une méthode / fonction non définie; </li><li>  accès à la propriété / constante de classe manquante; </li><li>  manque de classe; </li><li>  PHPDoc non valide </li><li>  accès à une variable non définie; </li><li>  accès à une variable qui n'est pas toujours définie; </li><li>  absence de "pause";  après cas dans les constructions switch / case; </li><li>  erreur de syntaxe </li><li>  variable inutilisée. </li></ul><br>  La liste est assez courte, mais vous pouvez ajouter des contrôles spécifiques à votre projet. <br><br>  Pendant le fonctionnement du linter, il s'est avéré que l'inspection la plus utile n'est que la dernière (variable inutilisée).  Cela se produit souvent lorsque vous refactorisez le code (ou en écrivez un nouveau) et que vous le scellez dans le nom de la variable: ce code est valide du point de vue de PHP, mais erroné en logique. <br><br><h2>  Vitesse de travail </h2><br>  Combien de temps le changement que nous souhaitons pousser est-il vérifié?  Tout dépend du nombre de fichiers.  Avec NoVerify, le processus peut prendre jusqu'à une minute (c'était lorsque j'ai changé 1400 fichiers dans le référentiel), mais s'il y avait peu de modifications, alors généralement toutes les vérifications passent en 4-5 secondes.  Pendant ce temps, le projet est complètement indexé, analysant les nouveaux fichiers, ainsi que leur analyse.  Nous avons réussi à créer un linter pour PHP, qui fonctionne rapidement même avec notre large base de code. <br><br><h2>  Quel est le résultat? </h2><br>  Puisque la solution est écrite en Go, il est nécessaire d'utiliser le référentiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/JetBrains/phpstorm-stubs</a> afin d'avoir des définitions de toutes les fonctions et classes intégrées dans PHP.  En retour, nous avons obtenu une vitesse de travail élevée (indexation de 1 million de lignes par seconde, analyse de 100 000 lignes par seconde) et avons pu ajouter des vérifications avec un linter comme l'une des premières étapes des git push hooks. <br><br>  Une base pratique a été développée pour créer de nouvelles inspections et un niveau de compréhension du code proche de PHPStorm a été atteint.  En raison du fait que le mode de calcul différentiel est pris en charge, il est possible d'améliorer progressivement le code, en évitant de nouvelles constructions potentiellement problématiques dans le nouveau code. <br><br>  Compter diff n'est pas idéal: par exemple, si un gros fichier a été divisé en plusieurs petits, alors git, et donc NoVerify, ne sera pas en mesure de déterminer que le code a été déplacé, et le linter devra résoudre tous les problèmes trouvés.  À cet égard, le calcul de diff empêche le refactoring à grande échelle, donc dans de tels cas, il est souvent désactivé. <br><br>  Écrire un linter sur Go a un autre avantage: non seulement l'analyseur AST est plus rapide et consomme moins de mémoire qu'en PHP, mais l'analyse ultérieure est également très rapide par rapport à tout ce qui pourrait être fait en PHP.  Cela signifie que notre linter peut effectuer une analyse plus complexe et plus approfondie du code, tout en conservant des performances élevées (par exemple, la fonctionnalité "types paresseux" nécessite un nombre assez important de calculs dans le processus). <br><br><h2>  Open source </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NoVerify disponible en open source sur GitHub</a> <br><br>  Profitez de votre utilisation dans votre projet! <br><br>  <b>UPD:</b> J'ai préparé une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">démo qui fonctionne via WebAssembly</a> .  La seule limitation de cette démo est le manque de définitions de fonctions des phpstorm-stubs, donc le linter jurera sur les fonctions intégrées. <br><br>  <i>Yuri Nasretdinov, développeur du département d'infrastructure de VKontakte</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442284/">https://habr.com/ru/post/fr442284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442272/index.html">Aller + = versionner le package</a></li>
<li><a href="../fr442274/index.html">Dart 2. Programmation asynchrone: flux de données</a></li>
<li><a href="../fr442278/index.html">Guide de l'utilisateur Kibana. Visualisation. Partie 6</a></li>
<li><a href="../fr442280/index.html">Apprentissage automatique dans Dodo. Comment lancer une nouvelle direction si vous êtes développeur</a></li>
<li><a href="../fr442282/index.html">Dart 2. Programmation asynchrone: futurs</a></li>
<li><a href="../fr442286/index.html">Les ophtalmologistes russes ont parlé de la vision bionique. La nouvelle application mobile démontre le travail du cyber</a></li>
<li><a href="../fr442288/index.html">Rayonnement: sources</a></li>
<li><a href="../fr442290/index.html">Création de ST-Link V2.1 à partir du chinois ST-Link V2</a></li>
<li><a href="../fr442292/index.html">Stage Sberseasons: Python, UX / UI, Data et bien plus encore pour les étudiants</a></li>
<li><a href="../fr442294/index.html">Ce qu'Oleg Artamonov a légèrement tort</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>