<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥣 🙏🏻 🍣 Flightradar24 - bagaimana cara kerjanya? Bagian 2, Protokol ADS-B 🐤 🍼 ↗️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Habr. Mungkin setiap orang yang pernah bertemu atau menemani kerabat atau teman di pesawat menggunakan layanan Flightradar24 gratis. Ini adalah ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Flightradar24 - bagaimana cara kerjanya? Bagian 2, Protokol ADS-B</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443498/">  Hai Habr.  Mungkin setiap orang yang pernah bertemu atau menemani kerabat atau teman di pesawat menggunakan layanan Flightradar24 gratis.  Ini adalah cara yang sangat nyaman untuk melacak posisi pesawat secara real time. <br><br><img src="https://habrastorage.org/webt/tv/cq/zy/tvcqzyleq96zk-kqmn8p_9cfgey.jpeg" alt="gambar"><br><br>  Bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> menggambarkan prinsip pengoperasian layanan online semacam itu.  Sekarang kita akan melangkah lebih jauh, dan mencari tahu data apa yang dikirimkan dan diterima dari pesawat ke stasiun penerima, dan mendekodekannya sendiri menggunakan Python. <br><a name="habracut"></a><br><h2>  Ceritanya </h2><br>  Jelas, data pesawat tidak ditransmisikan sehingga pengguna dapat melihatnya di smartphone mereka.  Sistem ini disebut ADS-B (Automatic-surveillance-broadcast - broadcast), dan digunakan untuk secara otomatis mengirimkan informasi pesawat ke pusat kendali - pengidentifikasi, koordinat, arah, kecepatan, ketinggian, dan data lainnya dikirimkan.  Sebelumnya, sebelum munculnya sistem seperti itu, operator hanya bisa melihat titik di radar.  Ini tidak cukup ketika ada terlalu banyak pesawat. <br><br>  Secara teknis, ADS-B terdiri dari pemancar di pesawat terbang yang secara berkala mengirimkan paket dengan informasi pada frekuensi yang cukup tinggi 1090 MHz (ada mode lain, tetapi mereka tidak begitu menarik bagi kami, karena koordinatnya hanya dikirimkan di sini).  Tentu saja, selain pemancar, ada juga penerima di suatu tempat di bandara, tetapi bagi kami, seperti bagi pengguna, penerima kami sendiri menarik. <br><br>  Ngomong-ngomong, untuk perbandingan, sistem seperti itu yang pertama, Airnav Radarbox, dirancang untuk pengguna biasa, muncul pada 2007, dan harganya sekitar $ 900, sekitar $ 250 setahun layak berlangganan layanan jaringan. <br><br><img src="https://habrastorage.org/webt/74/dt/np/74dtnpj6jdit1zlt_cr37rq4mju.png"><br><br>  Anda dapat membaca ulasan pemilik Rusia pertama di forum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">radioscanner</a> .  Sekarang penerima RTL-SDR telah tersedia secara luas, perangkat serupa dapat dirakit seharga $ 30, lebih lanjut tentang ini di bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> .  Kami akan melanjutkan ke protokol itu sendiri - mari kita lihat cara kerjanya. <br><br><h2>  Menerima sinyal </h2><br>  Untuk memulai, sinyal perlu direkam.  Seluruh sinyal memiliki durasi hanya 120 mikrodetik, oleh karena itu, untuk dapat membongkar komponennya dengan nyaman, penerima SDR dengan frekuensi pengambilan sampel minimal 5 MHz diperlukan. <br><br><img src="https://habrastorage.org/webt/mu/ig/uj/muigujxudctclwalfdxl5tzzdam.png" alt="gambar"><br><br>  Setelah merekam, kami mendapatkan file WAV dengan frekuensi sampling 5.000.000 sampel / detik, 30 detik dari rekaman "menimbang" sekitar 500 MB.  Mendengarkannya dengan pemutar media tentu saja tidak berguna - file tidak mengandung suara, tetapi sinyal radio yang langsung didigitalkan - ini adalah cara kerja Radio yang Ditentukan Perangkat Lunak. <br><br>  Kami akan membuka dan memproses file menggunakan Python.  Mereka yang ingin bereksperimen sendiri dapat mengunduh rekaman sampel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari tautan</a> . <br><br>  Unduh file dan lihat apa yang ada di dalamnya. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np fs, data = wavfile.read(<span class="hljs-string"><span class="hljs-string">"adsb_20190311_191728Z_1090000kHz_RF.wav"</span></span>) data = data.astype(float) I, Q = data[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], data[:, <span class="hljs-number"><span class="hljs-number">1</span></span>] A = np.sqrt(I*I + Q*Q) plt.plot(A) plt.show()</code> </pre> <br>  Hasil: kita melihat "impuls" yang jelas terhadap latar belakang kebisingan. <br><br><img src="https://habrastorage.org/webt/ko/v5/ra/kov5rakmt1sysd7yncso6372l70.png"><br><br>  Setiap "impuls" adalah sinyal yang strukturnya terlihat jelas jika Anda meningkatkan resolusi pada grafik. <br><br><img src="https://habrastorage.org/webt/7l/oa/y-/7loay-b4xf16kyy--ik_j4rhh4q.png"><br><br>  Seperti yang Anda lihat, gambar konsisten dengan apa yang dijelaskan dalam uraian di atas.  Anda dapat mulai memproses data. <br><br><h2>  Decoding </h2><br>  Pertama, Anda perlu mendapatkan bitstream.  Sinyal itu sendiri dikodekan menggunakan manchester encoding: <br><br><img src="https://habrastorage.org/webt/rh/k3/is/rhk3iskt0btt5s9okaekkaox3w8.png"><br><br>  Dari perbedaan level dalam camilan, mudah untuk mendapatkan "0" dan "1" yang nyata. <br><br><pre> <code class="python hljs"> bits_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>): pos = start_data + bit_len*p p1, p2 = A[pos: pos + bit_len/<span class="hljs-number"><span class="hljs-number">2</span></span>], A[pos + bit_len/<span class="hljs-number"><span class="hljs-number">2</span></span>: pos + bit_len] avg1, avg2 = np.average(p1), np.average(p2) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg1 &lt; avg2: bits_str += <span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> avg1 &gt; avg2: bits_str += <span class="hljs-string"><span class="hljs-string">"1"</span></span></code> </pre><br>  Struktur sinyal itu sendiri adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/cl/_7/ng/cl_7ngs5clpg97zrplnolcajpcq.png"><br><br>  Mari kita perhatikan kolom-kolomnya lebih detail. <br><br>  <b>DF</b> (Downlink Format, 5 bit) - mendefinisikan jenis pesan.  Ada beberapa jenis: <br><br><img src="https://habrastorage.org/webt/li/no/dt/linodtcxx6jtskav1aqar14odew.png"><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber tabel</a> ) <br><br>  Kami hanya tertarik pada tipe DF17, seperti  ini berisi koordinat pesawat. <br><br>  <b>ICAO</b> (24 bit) adalah kode pesawat unik internasional.  Anda dapat memeriksa pesawat dengan kodenya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di situs web</a> (sayangnya, penulis telah berhenti memperbarui database, tetapi masih relevan).  Misalnya, untuk kode 3c5ee2 kami memiliki informasi berikut: <br><br><img src="https://habrastorage.org/webt/i6/gt/8s/i6gt8sgm9n7zv1u7nspnzsitpk4.png"><br><br>  Sunting: dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar pada artikel,</a> deskripsi kode ICAO diberikan secara lebih rinci, saya sarankan Anda membacanya untuk mereka yang tertarik. <br><br>  <b>DATA</b> (56 atau 112 bit) - sebenarnya data yang akan kami dekode.  5 bit pertama data adalah bidang <b>Kode Jenis yang</b> berisi subtipe dari data yang disimpan (jangan dikacaukan dengan DF).  Ada beberapa jenis ini: <br><br><img src="https://habrastorage.org/webt/5v/h1/3h/5vh13htes6_pyungnbzkucvqlji.png"><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber tabel</a> ) <br><br>  Mari kita lihat beberapa paket contoh. <br><br>  <b>Identifikasi pesawat</b> <br><br>  Contoh biner: <br><br>  00100 011 000101 010111 000111 110111 110001 111000 <br><br>  Bidang Data: <br><br><pre> <code class="python hljs">+------+------+------+------+------+------+------+------+------+------+ | TC,<span class="hljs-number"><span class="hljs-number">5</span></span> | EC,<span class="hljs-number"><span class="hljs-number">3</span></span> | C1,<span class="hljs-number"><span class="hljs-number">6</span></span> | C2,<span class="hljs-number"><span class="hljs-number">6</span></span> | C3,<span class="hljs-number"><span class="hljs-number">6</span></span> | C4,<span class="hljs-number"><span class="hljs-number">6</span></span> | C5,<span class="hljs-number"><span class="hljs-number">6</span></span> | C6,<span class="hljs-number"><span class="hljs-number">6</span></span> | C7,<span class="hljs-number"><span class="hljs-number">6</span></span> | C8,<span class="hljs-number"><span class="hljs-number">6</span></span> | +------+------+------+------+------+------+------+------+------+------+</code> </pre><br>  TC = 00100b = 4, setiap karakter C1-C8 berisi kode yang sesuai dengan indeks dalam string: <br>  #ABCDEFGHIJKLMNOPQRSTUVWXYZ ##### _ ################ 0123456789 ###### <br><br>  Setelah memecahkan kode baris, mudah untuk mendapatkan kode pesawat: EWG7184 <br><br><pre> <code class="python hljs">symbols = <span class="hljs-string"><span class="hljs-string">"#ABCDEFGHIJKLMNOPQRSTUVWXYZ#####_###############0123456789######"</span></span> code_str = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>): c = int(bits_str[<span class="hljs-number"><span class="hljs-number">8</span></span> + <span class="hljs-number"><span class="hljs-number">6</span></span>*p:<span class="hljs-number"><span class="hljs-number">8</span></span> + <span class="hljs-number"><span class="hljs-number">6</span></span>*(p + <span class="hljs-number"><span class="hljs-number">1</span></span>)], <span class="hljs-number"><span class="hljs-number">2</span></span>) code_str += symbols[c] print(<span class="hljs-string"><span class="hljs-string">"Aircraft Identification:"</span></span>, code_str.replace(<span class="hljs-string"><span class="hljs-string">'#'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>))</code> </pre><br>  <b>Posisi di udara</b> <br><br>  Jika namanya sederhana, maka koordinatnya lebih rumit.  Mereka ditransmisikan dalam bentuk frame 2x, genap dan ganjil.  Kode bidang TC = 01011b = 11. <br><br><img src="https://habrastorage.org/webt/3i/8h/oj/3i8hojmkecmc0xlnfhkwvf7svk8.png"><br><br>  Contoh paket genap dan ganjil: <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">01011</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span> <span class="hljs-number"><span class="hljs-number">000101110110</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10111000111001000</span></span> <span class="hljs-number"><span class="hljs-number">10000110101111001</span></span> <span class="hljs-number"><span class="hljs-number">01011</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span> <span class="hljs-number"><span class="hljs-number">000110010000</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">10010011110000110</span></span> <span class="hljs-number"><span class="hljs-number">10000011110001000</span></span></code> </pre><br>  Penghitungan koordinat dilakukan berdasarkan rumus yang agak pintar: <br><br><img src="https://habrastorage.org/webt/3i/uf/m0/3iufm0e0758rzbjmxmkazgifsqq.png"><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber</a> ) <br><br>  Saya bukan spesialis GIS, jadi saya tidak tahu dari mana asalnya.  Siapa yang tahu, tulis di komentar. <br><br>  Ketinggian dianggap lebih mudah - tergantung pada bit tertentu, itu dapat muncul sebagai kelipatan 25 atau 100 kaki. <br><br>  <b>Kecepatan udara</b> <br><br>  Paket dengan TC = 19.  Yang menarik di sini adalah bahwa kecepatannya bisa akurat, relatif terhadap ground (Kecepatan Tanah), atau udara, yang diukur dengan sensor pesawat (Kecepatan Udara).  Banyak bidang yang berbeda juga ditransmisikan: <br><br><img src="https://habrastorage.org/webt/hh/yr/bn/hhyrbnk8nh7qauorxuohetys5fi.png"><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber</a> ) <br><br><h2>  Kesimpulan </h2><br>  Seperti yang Anda lihat, teknologi ADS-B telah menjadi simbiosis yang menarik ketika standar berguna tidak hanya untuk para profesional, tetapi juga untuk pengguna biasa.  Tapi tentu saja, peran utama dalam hal ini dimainkan oleh semakin murahnya teknologi penerima SDR digital, yang memungkinkan perangkat untuk menerima sinyal dengan frekuensi yang lebih tinggi daripada gigahertz pada perangkat yang secara harfiah “untuk satu sen”. <br><br>  Dalam standar itu sendiri, tentu saja, lebih dari segalanya.  Mereka yang tertarik dapat melihat PDF di halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ICAO</a> atau mengunjungi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs yang</a> telah disebutkan di atas. <br><br>  Rasanya tidak mungkin banyak hal di atas berguna, tetapi setidaknya gagasan umum tentang cara kerjanya, saya harap, tetap ada. <br><br>  Omong-omong, dekoder siap pakai dengan Python sudah ada, dapat dipelajari di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Dan pemilik penerima SDR dapat merakit dan menjalankan dekoder ADS-B yang telah selesai <a href="">dari halaman</a> , lebih lanjut tentang ini di bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> . <br><br>  Kode sumber parser yang dijelaskan dalam artikel diberikan di bawah potongan.  Ini adalah contoh pengujian yang tidak berpura-pura menjadi produksi, tetapi sesuatu berfungsi di dalamnya, dan Anda dapat mengurai file yang direkam di atas. <br><div class="spoiler">  <b class="spoiler_title">Kode Sumber (Python)</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> print_function <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wavfile <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> signal <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data, start, bit_len)</span></span></span><span class="hljs-function">:</span></span> max_len = bit_len*<span class="hljs-number"><span class="hljs-number">128</span></span> A = data[start:start + max_len] A = signal.resample(A, <span class="hljs-number"><span class="hljs-number">10</span></span>*max_len) bits = np.zeros(<span class="hljs-number"><span class="hljs-number">10</span></span>*max_len) bit_len *= <span class="hljs-number"><span class="hljs-number">10</span></span> start_data = bit_len*<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-comment"><span class="hljs-comment"># Parse first 8 bits bits_str = "" for p in range(8): pos = start_data + bit_len*p p1, p2 = A[pos: pos + bit_len/2], A[pos + bit_len/2: pos + bit_len] avg1, avg2 = np.average(p1), np.average(p2) if avg1 &lt; avg2: bits_str += "0" elif avg1 &gt; avg2: bits_str += "1" df = int(bits_str[0:5], 2) # Aircraft address (db - https://junzis.com/adb/?q=3b1c5c ) bits_str = "" for p in range(8, 32): pos = start_data + bit_len * p p1, p2 = A[pos: pos + bit_len / 2], A[pos + bit_len / 2: pos + bit_len] avg1, avg2 = np.average(p1), np.average(p2) if avg1 &lt; avg2: bits_str += "0" elif avg1 &gt; avg2: bits_str += "1" # print "Aircraft address:", bits_str, hex(int(bits_str, 2)) address = hex(int(bits_str, 2)) # Filter specific aircraft (optional) # if address != "0x3c5ee2": # return if df == 16 or df == 17 or df == 18 or df == 19 or df == 20 or df == 21: # print "Pos:", start, "DF:", msg_type # Data (56bit) bits_str = "" for p in range(32, 88): pos = start_data + bit_len*p p1, p2 = A[pos: pos + bit_len/2], A[pos + bit_len/2: pos + bit_len] avg1, avg2 = np.average(p1), np.average(p2) if avg1 &lt; avg2: bits_str += "0" # bits[pos + bit_len / 2] = 50 elif avg1 &gt; avg2: bits_str += "1" # http://www.lll.lu/~edward/edward/adsb/DecodingADSBposition.html # print "Data:" # print bits_str[:8], bits_str[8:20], bits_str[20:22], bits_str[22:22+17], bits_str[39:39+17] # Type Code: tc, ec = int(bits_str[:5], 2), int(bits_str[5:8], 2) # print("DF:", df, "TC:", tc) # 1 - 4 Aircraft identification # 5 - 8 Surface position # 9 - 18 Airborne position (w/ Baro Altitude) # 19 Airborne velocities if tc &gt;= 1 and tc &lt;= 4: # and (df == 17 or df == 18): print("Aircraft address:", address) print("Data:") print(bits_str[:8], bits_str[8:14], bits_str[14:20], bits_str[20:26], bits_str[26:32], bits_str[32:38], bits_str[38:44]) symbols = "#ABCDEFGHIJKLMNOPQRSTUVWXYZ#####_###############0123456789######" code_str = "" for p in range(8): c = int(bits_str[8 + 6*p:8 + 6*(p + 1)], 2) code_str += symbols[c] print("Aircraft Identification:", code_str.replace('#', '')) print() if tc == 11: print("Aircraft address:", address) print("Data: (11)") print(bits_str[:8], bits_str[8:20], bits_str[20:22], bits_str[22:22+17], bits_str[39:39+17]) # Bit 22 contains the F flag which indicates which CPR format is used (odd or even) # First frame has F flag = 0 so is even and the second frame has F flag = 1 so odd # f = bits_str[21:22] # print("F:", int(f, 2)) # Altitude alt1b = bits_str[8:20] if alt1b[-5] == '1': bits = alt1b[:-5] + alt1b[-4:] n = int(bits, 2) alt_ft = n*25 - 1000 print("Alt (ft)", alt_ft) # lat_dec = int(bits_str[22:22+17], 2) # lon_dec = int(bits_str[39:39+17], 2) # print("Lat/Lon:", lat_dec, lon_dec) # http://airmetar.main.jp/radio/ADS-B%20Decoding%20Guide.pdf print() if tc == 19: print("Aircraft address:", address) print("Data:") # print(bits_str) print(bits_str[:5], bits_str[5:8], bits_str[8:10], bits_str[10:13], bits_str[13] ,bits_str[14:24], bits_str[24], bits_str[25:35], bits_str[35:36], bits_str[36:65]) subtype = int(bits_str[5:8], 2) # https://mode-s.org/decode/adsb/airborne-velocity.html spd, hdg, rocd = -1, -1, -1 if subtype == 1 or subtype == 2: print("Velocity Subtype 1: Ground speed") v_ew_sign = int(bits_str[13], 2) v_ew = int(bits_str[14:24], 2) - 1 # east-west velocity v_ns_sign = int(bits_str[24], 2) v_ns = int(bits_str[25:35], 2) - 1 # north-south velocity v_we = -1*v_ew if v_ew_sign else v_ew v_sn = -1*v_ns if v_ns_sign else v_ns spd = math.sqrt(v_sn*v_sn + v_we*v_we) # unit in kts hdg = math.atan2(v_we, v_sn) hdg = math.degrees(hdg) # convert to degrees hdg = hdg if hdg &gt;= 0 else hdg + 360 # no negative val if subtype == 3: print("Subtype Subtype 3: Airspeed") hdg = int(bits_str[14:24], 2)/1024.0*360.0 spd = int(bits_str[25:35], 2) vr_sign = int(bits_str[36], 2) vr = int(bits_str[36:45], 2) rocd = -1*vr if vr_sign else vr # rate of climb/descend print("Speed (kts):", spd, "Rate:", rocd, "Heading:", hdg) print() # print() def calc_coordinates(): def _cprN(lat, is_odd): nl = _cprNL(lat) - is_odd return nl if nl &gt; 1 else 1 def _cprNL(lat): try: nz = 15 a = 1 - math.cos(math.pi / (2 * nz)) b = math.cos(math.pi / 180.0 * abs(lat)) ** 2 nl = 2 * math.pi / (math.acos(1 - a/b)) return int(math.floor(nl)) except: # happens when latitude is +/-90 degree return 1 def floor_(x): return int(math.floor(x)) lat1b, lon1b, alt1b = "10111000111010011", "10000110111111000", "000101111001" lat2b, lon2b, alt2b = "10010011101011100", "10000011000011011", "000101110111" lat1, lon1, alt1 = int(lat1b, 2), int(lon1b, 2), int(alt1b, 2) lat2, lon2, alt2 = int(lat2b, 2), int(lon2b, 2), int(alt2b, 2) # 131072 is 2^17, since CPR lat and lon are 17 bits each cprlat_even, cprlon_even = lat1/131072.0, lon1/131072.0 cprlat_odd, cprlon_odd = lat2/131072.0, lon2/131072.0 print(cprlat_even, cprlon_even) j = floor_(59*cprlat_even - 60*cprlat_odd) print(j) air_d_lat_even = 360.0 / 60 air_d_lat_odd = 360.0 / 59 # Lat lat_even = float(air_d_lat_even * (j % 60 + cprlat_even)) lat_odd = float(air_d_lat_odd * (j % 59 + cprlat_odd)) if lat_even &gt;= 270: lat_even = lat_even - 360 if lat_odd &gt;= 270: lat_odd = lat_odd - 360 # Lon ni = _cprN(lat_even, 0) m = floor_(cprlon_even * (_cprNL(lat_even)-1) - cprlon_odd * _cprNL(lat_even) + 0.5) lon = (360.0 / ni) * (m % ni + cprlon_even) print("Lat", lat_even, "Lon", lon) # Altitude # Q-bit (bit 48) indicates whether the altitude is encoded in multiples of 25 or 100 ft (0: 100 ft, 1: 25 ft) # The value can represent altitudes from -1000 to +50175 ft. if alt1b[-5] == '1': bits = alt1b[:-5] + alt1b[-4:] n = int(bits, 2) alt_ft = n*25 - 1000 print("Alt (ft)", alt_ft) fs, data = wavfile.read("adsb_20190311_191728Z_1090000kHz_RF.wav") T = 1/fs print("Sample rate %f MS/s" % (fs / 1e6)) print("Cnt samples %d" % len(data)) print("Duration: %fs" % (T * len(data))) data = data.astype(float) cnt = data.shape[0] # Processing only part on file (faster): # cnt = 10000000 # data = data[:cnt] print("Processing I/Q...") I, Q = data[:, 0], data[:, 1] A = np.sqrt(I*I + Q*Q) bits = np.zeros(cnt) # To see scope without any processing, uncomment # plt.plot(A) # plt.show() # sys.exit(0) print("Extracting signals...") pos = 0 avg = 200 msg_start = 0 # Find beginning of each signal while pos &lt; cnt - 16*1024: # P1 - message start while pos &lt; cnt - 16*1024: if A[pos] &lt; avg and A[pos+1] &gt; avg and pos - msg_start &gt; 1000: msg_start = pos bits[pos] = 100 pos += 4 break pos += 1 start1, start2, start3, start4 = msg_start, 0, 0, 0 # P2 while pos &lt; cnt - 16*1024: if A[pos] &lt; avg and A[pos+1] &gt; avg: start2 = pos bits[pos] = 90 pos += 1 break pos += 1 # P3 while pos &lt; cnt - 16*1024: if A[pos] &lt; avg and A[pos+1] &gt; avg: start3 = pos bits[pos] = 80 pos += 1 break pos += 1 # P4 while pos &lt; cnt - 16*1024: if A[pos] &lt; avg and A[pos+1] &gt; avg: start4 = pos bits[pos] = 70 pos += 1 break pos += 1 sig_diff = start4 - start1 if 20 &lt; sig_diff &lt; 25: bits[msg_start] = 500 bit_len = int((start4 - start1) / 4.5) # print(pos, start1, start4, ' - ', bit_len) # start = start1 + 8*bit_len parse_message(A, msg_start, bit_len) pos += 450 # For debugging: check signal start # plt.plot(A) # plt.plot(bits) # plt.show()</span></span></code> </pre><br></div></div><br>  Semoga ada yang tertarik, terima kasih atas perhatiannya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443498/">https://habr.com/ru/post/id443498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443484/index.html">6 pria tak terduga dari Julia</a></li>
<li><a href="../id443486/index.html">ReLEx SMILE: Bagaimana tidak membuat kesalahan dalam perkiraan</a></li>
<li><a href="../id443490/index.html">Mengapa saya membatasi pekerjaan saya pada Debian</a></li>
<li><a href="../id443492/index.html">Gim untuk pecinta dan pakar di Linux</a></li>
<li><a href="../id443494/index.html">Panduan: Cara Meluncurkan Produk SaaS di AppSumo - Keberhasilan dan Beberapa Kesalahan</a></li>
<li><a href="../id443500/index.html">Komponen fungsional dengan React Hooks. Kenapa lebih baik?</a></li>
<li><a href="../id443502/index.html">Mengapa tepatnya 4 tahun yang lalu NASA menembakkan langit malam Cape Canaveral dengan roket Atlas V?</a></li>
<li><a href="../id443504/index.html">World Wide Web berusia tiga puluh tahun - apa yang akan terjadi selanjutnya?</a></li>
<li><a href="../id443506/index.html">Parser sederhana untuk youtube di tabel google</a></li>
<li><a href="../id443508/index.html">Game papan pendidikan untuk programmer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>