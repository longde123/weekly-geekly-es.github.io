<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🏭 👇🏽 🧢 图像轮廓检测算法 🍬 😒 👨‍👩‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文介绍了四种最常见的环路检测算法。 

 前两个算法，即用于追踪正方形和追踪摩尔环境的算法，易于实现，因此经常用于确定给定图案的轮廓。 不幸的是，这两种算法都有一些缺点，由于它们的特殊类型的相邻性，使得无法检测出一大类图案的轮廓。 

 这些算法将忽略模式中的所有“漏洞” 。 例如，如果我们具有与...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>图像轮廓检测算法</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467611/"> 本文介绍了四种最常见的环路检测算法。 <br><br> 前两个算法，即用于追踪正方形和追踪摩尔环境的算法，易于实现，因此经常用于确定给定图案的轮廓。 不幸的是，这两种算法都有一些缺点，由于它们的特殊类型的相邻性，使得<b>无法</b>检测出一大类图案的轮廓。 <br><br> 这些算法将忽略模式中的所有<b><i>“漏洞”</i></b> 。 例如，如果我们具有与<b><i>图1</i></b>所示相似的图案，则算法检测到的电路将与<b><i>图2</i></b>所示相似（轮廓由蓝色像素表示）。 在某些应用领域中，这是完全可以接受的，但是在其他领域，例如，在字符识别中，有必要检测图案的内部部分以找到区分特定字符的所有空格。  （ <b><i>图3</i></b>显示了该模式的“完整”轮廓。） <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e7/d3b/f5b/0e7d3bf5bc9c451588718fe5d909a2fb.gif" alt="图片"></div><br><br> 因此，为了获得完整的轮廓，首先需要使用<b><i>“孔搜索”</i></b>算法确定给定图案中的孔，然后将轮廓检测算法应用于每个孔。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/22c/32f/cb722c32fcc45aeea8d8b097a0d01f84.gif" alt="图片"></div><a name="habracut"></a><br><h2> 什么是连接性？ </h2><br> 在具有二进制值的数字图像中，像素可以具有以下值之一：1-当它是图案的一部分时，或0-当它是背景的一部分时，即 没有灰色渐变。  （我们将假设值为1的像素是黑色，而值为0的像素是白色）。 <br><br> 为了识别数字图案中的<b><i>物体</i></b> ，我们需要找到彼此“连接”的黑色像素组。 换句话说，给定数字模式中的<b><i>对象</i></b>是该模式的<b><i>连接组件</i></b> 。 <br><br> 在一般情况下， <b><i>连接的分量</i></b>是一组黑色像素<b>P</b> ，因此对于<b>P</b>中的每对像素<b>p <sub>i</sub></b>和<b>p <sub>j</sub></b> ，都有一系列像素<b><i>p <sub>i</sub> ，...，p <sub>j</sub></i></b> ，使得： <br><br>  a）序列中的所有像素都在集合<b>P中</b> ，即 是黑色的 <br><br>  b） <b><i>序列中</i></b>彼此相邻的每2个像素为“邻居”。 <br><br> 一个重要的问题出现了： <b><i>我们什么时候可以说2个像素是“邻居”？</i></b> 由于我们使用正方形像素，因此，由于以下原因，上一个问题的答案并非无关紧要：在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">正方形细分中，</a>像素具有相同的边或顶点，或者没有任何共同点。 每个像素共有8个像素。 这样的像素构成了该像素的“摩尔邻域”。 我们是否应该考虑只有一个共同顶点的“邻居”像素？ 还是为了被视为“邻居”，两个像素必须具有相同的边缘？ <br><br> 因此，存在两种连接类型，即：4连接性和8连接性。 <br><br><h4>  4连接 </h4><br> 我们什么时候可以说给定的黑色像素组是<b><i>4个连接的？</i></b> 首先，您需要定义<b><i>4邻居</i></b> （也称为<b><i>直接邻居</i></b> ）的概念： <br><br>  <b>4邻居定义</b> ：如果<b>Q</b>和<b>P</b>具有公共边缘，则像素<b>Q</b>是给定像素<b>P</b>的<b><i>4邻居</i></b> 。 像素<b>P</b>的4个邻居（称为<b>P2，P4，P6</b>和<b>P8</b> ）在下面的<b><i>图2</i></b>中显示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/592/5ef/02b5925eff29a4b14330e63c43714837.gif" height="202" width="177"></div><br>  <b>4连接分量的定义</b> ：如果对于<b>P</b>中的每对像素<b>p <sub>i</sub></b>和<b>p <sub>j</sub></b>都有一系列像素<b><i>p <sub>i</sub> ，...，p <sub>j</sub></i></b> ，则黑色像素<b>P</b>的集合是<b><i>4连接分量</i></b> ： <br><br>  a）序列中的所有像素都在集合<b>P中</b> ，即 是黑色的 <br><br>  b） <b><i>序列</i></b>中<b><i>相邻的</i></b>每两个像素是<b><i>4个</i></b> <b><i>相邻</i></b>像素 <br><br><h4>  4连接模式的示例 </h4><br> 下图显示了4连接模式的示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b71/3c8/b76/b713c8b761d034fc04d486aed3029149.gif" height="216" width="576"></div><br><br><h4>  8连接 </h4><br> 我何时可以说给定的一组黑色像素是<b><i>8位连接的</i></b> ？ 首先，我们需要定义<b><i>8邻居</i></b> （也称为<b><i>间接邻居</i></b> ）的概念： <br><br>  <b>8邻居定义</b> ：如果<b>Q</b>和<b>P</b>具有公共边或顶点，则像素<b>Q</b>是给定像素<b>P</b>的<b><i>8邻居</i></b> （或只是<b><i>邻居</i></b> ）。 给定像素<b>P</b>的8个邻居组成了该像素的摩尔邻域。 <br><br>  <b>8个连接的分量的定义</b> ：如果对于<b>P中的</b>每对像素<b>p <sub>i</sub></b>和<b>p <sub>j</sub></b>都有一系列的像素<b><i>p <sub>i</sub> ，...，p <sub>j</sub></i></b> ，则黑色像素<b>P</b>的集合是<b><i>8个连接的分量</i></b> （或只是一个<b><i>连接的分量</i></b> ） <b><i>。</i></b> ： <br><br>  a）序列中的所有像素都在集合<b>P中</b> ，即 是黑色的 <br><br>  b） <b><i>在此序列</i></b>中<b><i>相邻的</i></b>每两个像素是<b><i>8个</i></b> <b><i>相邻</i></b>像素 <br><br>  <b>注意</b> ：所有4连接模式都是8连接的，即  4连接模式是许多8连接模式的子集。 另一方面，8连接模式可能无法4连接。 <br><br><h4>  8链接模式示例 </h4><br> 下图显示了8连接但不是4连接的模式： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f0/3d4/d90/7f03d4d904e9a4ebd1b7765ee7f4358f.gif" height="180" width="180"></div><br><br><h4> 非8连接模式的示例： </h4><br> 下图显示了未连接8个模式的示例，即 由多个连接的组件组成（该图显示了三个连接的组件）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/768/7bb/f90/7687bbf9070e4e581e4ebfde132a1164.gif" height="180" width="180"></div><br><br><h2> 平方迹线算法 </h2><br><h4> 主意 </h4><br> 平方跟踪算法的思想非常简单。 这可以归因于以下事实：该算法是检测二进制模式轮廓的首批尝试之一。 <br><br> 要了解其工作原理，您需要一点想象力... <br><br> 假设我们有一个数字模式，例如，在白色像素背景上的一组黑色像素，即 在网格上； 找到黑色像素并将其声明为我们的“ <b>初始</b> ”像素。  （查找“ <b>初始</b> ”像素可以用许多不同的方法来实现；我们将从网格的左下角开始，从下至上，从最左列到最右端扫描每列像素，直到遇到黑色像素为止。我们将其声明为“ <b>初始</b> ”。 “。） <br><br> 现在，假设您是一只站在<b>起始</b>像素上的瓢虫，如下<b><i>图1</i></b>所示。 要获取模式的轮廓，您需要执行以下操作： <br><br> <code> ,      ,  ,  <br> <br>  ,      ,  , <br> <br>      <b></b> .</code> <br> <br> 圈出的黑色像素将成为图案的轮廓。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baa/0c2/69e/baa0c269e22368fa231d774f6bf3b062.gif" height="252" width="216"></div><br> 正方形轨迹算法的一个重要方面是“方向感”。 向左和向右旋转是相对于当前位置执行的，这取决于您到达当前像素的方式。 因此，为了采取正确的行动，您需要跟踪自己的方向。 <br><br><h4> 演算法 </h4><br> 以下是平方跟踪算法的正式描述： <br><br> 输入：方形<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">镶嵌</a> <b>T</b> ，其中包含黑细胞的连接成分<b>P。</b> <br><br> 输出：边界像素的行<b>B（b <sub>1</sub> ，b <sub>2</sub> ，...，b <sub>k</sub> ）</b> ，即 轮廓。 <br><br> 开始 <br><br><ul><li> 将<b>B</b>定义为空集。 </li><li> 从下到上，从左到右扫描单元<b>T</b> ，直到<b>找到P</b>的黑色像素<b>s</b>为止。 </li><li> 将<b>s</b>插入<b>B。</b> </li><li> 将当前像素<b>p</b>设为初始像素<b>s</b> 。 </li><li> 向左转，即 转到<b>p</b>左侧的相邻像素。 </li><li> 更新<b>p</b> ，即 它成为当前像素。 </li><li> 当<b>p</b>不等于<b>s时</b> ，执行 <br><br> 如果当前像素<b>p</b>是黑色 <br><ul><li> 将<b>p</b>插入<b>B</b>并向左转（转到<b>p</b>左侧的相邻像素）。 </li><li> 更新<b>p</b> ，即 它成为当前像素。 </li></ul><br> 否则 <br><ul><li> 向右转（转到<b>p</b>右边的下一个像素）。 </li><li> 更新<b>p</b> ，即 它成为当前像素。 </li></ul><br>  “再见”周期结束 </li></ul><br> 结束 <br><br>  <b>注意：</b>不应将“左”和“右” <b>的</b>概念与页面或阅读器相关，而应考虑扫描期间进入“当前”像素的方向。 <br><br><h4> 示范 </h4><br> 以下是方形跟踪算法如何检测图案轮廓的动画演示。 不要忘记瓢虫以像素为单位移动。 请注意左右旋转时方向的变化。 相对于像素中的当前方向执行左转和右转，即 瓢虫的方向。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39c/148/f77/39c148f774519015dc130273d8383dd3.gif" height="360" width="288"></div><br><h4> 分析方法 </h4><br> 事实证明，平方跟踪算法的功能非常有限。 他无法检测出在现实应用中经常出现的大量图案轮廓。 <br><br> 这主要是由于以下事实：左右旋转未考虑“沿 <br> 对角线”。 <br><br> 让我们看一下具有不同连通性的不同模式，并查看为什么方形跟踪算法失败。 此外，我们将研究提高算法性能的方法，即使在具有特殊连接类型的模式下也可以使其工作。 <br><br><h4> 停止标准 </h4><br> 该算法的弱点之一是停止标准的选择。 换句话说，算法什么时候停止执行？ <br><br> 在平方跟踪算法的原始描述中，完成条件是第二次击中<b>初始</b>像素。 事实证明，如果该算法依赖于这样的标准，那么它将无法检测出大量图案的轮廓。 <br><br> 以下是一个动画演示，说明了由于选择了错误的停止标准而导致算法无法检测到图案的精确轮廓的情况： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ef/783/09a/0ef78309a17e9e72b09a28890abb6791.gif" height="252" width="216"></div><br> 如您所见，改善停止条件可以成为改善算法整体性能的良好开端。 现有的关闭条件有两种有效的替代方法： <br><br>  a）仅通过访问<b>起始</b>像素<b><i>n</i></b>次来停止，其中n至少为2，或者 <br><br>  b）第二次击中<b>起始</b>像素后停止，就像我们最初击中它一样。 <br><br> 该标准由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jacob Eliosoff</a>提出，因此我们将其称为<b><i>停止Jacob</i></b>的<b><i>标准</i></b> 。 <br><br> 更改停止条件通常可以提高平方迹线算法的有效性，但不能克服其在具有特殊类型的连接性的情况下所具有的其他缺点。 <br><br> 平方跟踪算法无法检测到连通性为8而不连通性为4的一系列图案的轮廓。 <br><br> 以下是动画演示，演示了方形跟踪算法（使用雅各布的停止准则）如何无法检测到具有连通性8而没有连通性4的模式的正确轮廓： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/c26/238/9bbc26238da41c3fb5c5eac1e44fe507.gif" height="288" width="216"></div><br><h2> 这个算法完全没用吗？ </h2><br> 如果阅读了以上分析，您可能会认为平方迹线算法无法检测到大多数图案的轮廓。 但是事实证明。 有一个特殊的模式系列，其中的路径由平方跟踪算法完全检测到。 <br><br> 令<b>P</b>为网格上具有连通性4的黑色像素集。 让网格的白色像素，即 背景像素<b>W</b>也具有4的连通性。事实证明，在这种图案及其背景的条件下，可以证明平方迹线算法（使用雅各布停止准则）将始终成功地处理轮廓的确定。 <br><br> 以下是在图案和背景像素都连接为4的情况下的证明，使用雅各布停止准则时，正方形迹线算法将正确确定轮廓。 <br><br> 证明 <br>  <b>给定</b> ：图案<b>P</b>使得图案的所有像素（即黑色）和背景像素（即白色）W具有4的连通性。 <br><br>  <b>初次观察</b> <br><br> 由于白色像素组W的连通性为4，这意味着图案中不存在任何“ <b><i>孔</i></b> ”（用非正式术语来说，“ <b><i>孔</i></b> ”是指白色像素组完全被图案的黑色像素包围）。 <br><br> 图案中任何“ <b><i>孔</i></b> ”的存在将导致白色像素组与其余白色像素的分离。 但是，许多白色像素会失去连接性4。 <br><br>  <i>下面的图2</i>和<b><i>图3</i></b>显示了两种类型的“ <b><i>孔</i></b> ”，它们可以在具有连通性4的模式中出现： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/a4e/9b1/8d9a4e9b18b2753038c0abbd11ad7dcd.gif" height="180" width="432"></div><br><br>  <b>第二次观察</b> <br><br> 图案的任何两个黑色像素必须具有一个公共面。 <br><br> 假设两个黑色像素只有一个公共顶点。 然后，为了满足图案的4连接性，必须有一条连接这两个像素的路径，以使该路径上的每两个相邻像素具有4的连通性。但这将提供类似于<b><i>图3</i></b>的图案。 换句话说，这将导致白色像素分离。 下面的<b><i>图4</i></b>示出了典型的图案，该图案满足以下假设：图案和背景中的像素是4连接的，即，像素为4。 没有“ <b><i>洞</i></b> ”，并且每两个黑色像素有一个公共面： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a68/2e0/7e0/a682e07e0732655da35269badcfe6b69.gif" height="216" width="216"></div><br> 如下表示这样的模式很有用： <br><br> 首先我们考虑边界像素，即 模式的轮廓。 然后，如果我们认为每个边界像素具有4个单位长度的边缘，我们将看到其中一些边缘与相邻的白色像素相同。 我们称这种边缘为<b><i>边界边缘</i></b> 。 <br><br> 这样的边界边缘可以被认为是多边形的边缘。 在<b><i>图片中</i></b> <b><i><br></i></b> 在下面的图<b><i>5</i></b>中，通过与上面的<b><i>图4中</i></b>的图案相对应的多边形示例说明了这一想法： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/ebe/5ea/220ebe5ea9383e00a2709117b237248b.gif" height="216" width="216"></div><br> 如果我们考虑可能以这种模式出现的边界像素的所有可能“配置”，我们将看到有两种简单的情况，如下<b><i>图6</i></b>和<b><i>图7</i></b>所示。 <br><br> 边界像素可以是这些情况或其他布置的倍数，即 这两种情况的曲折。 边界肋以蓝色标记为<b>E1，E2，E3</b>和<b>E4</b> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf5/99b/6fa/bf599b6fafebb09a80c32eceb0520270.gif" height="216" width="576"></div><br>  <b>第三观察</b> <br><br> 在上述两种情况下，无论我们选择的初始像素是什么，无论它<b>落入</b>哪个方向，平方跟踪算法都不会<b>“回退”（backtrack）</b> ，也不会两次<b>“穿过”</b> <i>边界边缘</i> （仅当它第二次不跟踪边界时）并且永远不会错过<b><i>边界边</i></b> 。 看看吧！ <br><br> 这里需要澄清两个概念： <br><br>  a）算法<b>“返回”</b> ，在跟踪整个边界之前，它返回访问已经访问过的像素，并且 <br><br>  b）对于每个<b><i>边界肋，</i></b>有两种<b>“穿过它”的方式</b> ，即“向内”和“向外”（其中“向内”是指相应多边形的向内运动，而“向外”是指多边形的向外）。 <br><br> 另外，当算法“向内”穿过边界边缘之一时，它将“向外”穿过下一个边界边缘，即 平方迹线算法不应以相同的方式穿过两个连续的边。 <br><br>  <b>最后观察</b> <br><br> 每个图案都有<b>偶数个</b> <b>边界边</b> 。 <br><br> 如果查看<b><i>图5</i></b>中的多边形，可以看到： <br><br> 如果我们要从图中标记的顶点<b>S</b>开始并遵循边界边缘，直到再次到达<b>S</b> ，那么我们注意到在此过程中，我们会交叉偶数个边界边缘。 我们可以将每个边界边缘视为一个单独方向上的“步骤”。 然后，如果要返回到起始位置，则右侧的每个“步骤”都必须在左侧具有一个相应的“步骤”。 垂直的“步骤”也是如此。 因此，“步骤”必须具有相应的对，这解释了为什么每个这些模式都将具有偶数个边界边。 <br><br> 因此，当用于跟踪正方形的算法第二次通过（初始像素的） <b>初始边界边缘</b>进入时，它将沿与第一次<b>相同的</b>方向进行。 <br><br> 这样做的原因是，由于有两种方式可以穿越边界边缘，并且算法交替地向内和向外移动，并且边界边缘的数量为偶数，因此算法将第二次通过初始边界边缘，方法与第一个。 <br><br><h4> 结论 </h4><br> 在4个连接的图案和背景的情况下，平方迹线算法将检测整个边界，即 轮廓，图案，并且将在单次跟踪后停止工作，即 它不会再次跟踪它，因为当它第二次到达<b>初始边界边缘</b>时，它将以与第一次相同的方式输入。 因此，只要模式和背景都为4位连接，具有Jacob停止准则的平方跟踪算法将正确确定任何模式的计数器。 <br><br><h2> 追踪摩尔的环境 </h2><br><h4> 主意 </h4><br>  Moore-Neighbor跟踪的思想很简单； 但是在解释它之前，我们需要解释一个重要概念：像素<b><i>的摩尔邻域</i></b> 。 <br><br><h4> 摩尔附近 </h4><br> 像素<b>P</b>的Moore邻域是8个像素的集合，这些像素具有与该像素相同的顶点或边缘。 这样的像素，即<b>P1，P2，P3，P4，P5，P6，P7和P8</b>在<b><i>图1</i></b>中示出。 <br><br> 摩尔邻里（也称为<b><i>8邻居</i></b>或<b><i>间接邻居</i></b> ）是文献中经常提到的重要概念。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/863/08c/2ea/86308c2ea8863bc111d206fb5070250f.gif" height="195" width="178"></div><br> 现在，我们准备熟悉摩尔周围环境背后的观念。 <br><br> 让有一个数字模式，即 一组黑色像素，在白色像素的背景上，即 在网格上； 找到黑色像素并将其声明为“ <b>初始</b> ”像素。  （有几种方法可以找到“ <b>初始</b> ”像素，但像以前一样，我们将从左下角开始并按顺序扫描所有像素列，直到找到第一个黑色像素为止，我们将其声明为“ <b>初始</b> ”。） <br><br> 再次假设您是站在<b>起始</b>像素上的瓢虫，如下<b><i>图2</i></b>所示。 不失一般性，我们将通过顺时针旋转图案来检测轮廓。  （无论我们选择哪个方向，最主要的是在算法中不断使用它）。 <br><br> 总体思路是这样的：每次我们到达黑色像素<b>P时</b> ，我们都会返回，也就是回到我们之前站立的白色像素。 然后， <b>我们</b>顺时针旋转像素<b>P</b> ，访问摩尔附近的每个像素，直到到达黑色像素。 当起始像素第二次到达起始像素时，算法终止。 <br><br> 算法访问的那些黑色像素将成为图案的轮廓。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/afb/a2f/43eafba2f0611e11eb82c8ed7159971c.gif" height="252" width="216"></div><br><h4> 演算法 </h4><br> 以下是对摩尔邻域跟踪算法的正式描述： <br><br> 输入：包含黑色单元的相连分量<b>P</b>的方形<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">镶嵌</a> <b>T。</b> <br><br> 输出：边界像素的<b>B</b>行<b>（b <sub>1</sub> ，b <sub>2</sub> ，...，b <sub>k</sub> ）</b> ，即 轮廓。 <br><br> 用<b>M（a）</b>表示像素<b>a</b>的摩尔邻域。 <br><br> 令<b>p</b>为当前边框像素。 <br><br> 令<b>c</b>为正在考虑的当前像素，即  <b>c</b>在<b>M（p）中</b> 。 <br><br> 开始 <br><br><ul><li> 将<b>B</b>定义为空集。 </li><li> 从下到上，从左到右，扫描单元<b>T，</b>直到从<b>P</b>找到一个黑色像素<b>s</b>为止<b>。</b> </li><li> 将<b>s</b>插入<b>B。</b> </li><li> 我们将点<b>s</b>设置为当前边界点<b>p</b> ，即  <b>设</b> </li><li> 让我们回去，即 让我们继续到<b>s</b>的像素。 </li><li> 令<b>c为</b> <b>M（p）中</b> <b>的</b>下一个顺时针像素。 </li><li> 当<b>c</b>不等于<b>s时</b> ，执行 <br><br><ul><li> 如果<b>c</b>是黑色 <br><ul><li> 将<b>c</b>插入<b>B</b> </li><li> 我们设置<b>p = c</b> </li><li> 返回（将当前像素<b>c</b>移到我们从中到达<b>p</b>的像素） </li></ul><br> 否则 <br><ul><li> 将当前像素<b>c</b>移动到<b>M中</b>的下一个顺时针像素<b>（p）</b> </li></ul><br> 再见周期结束 </li></ul></li></ul><br> 结束 <br><br><h4> 示范 </h4><br> 以下是有关Moore邻域迹线如何执行模式轮廓检测的动画演示。  （我们决定顺时针跟踪轮廓。） <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/544/3f0/295/5443f02954a35cf08c7a9e462bfa0f8a.gif" height="360" width="360"></div><br><h4> 分析方法 </h4><br> 追踪Moore周围环境的主要缺点在于选择停止标准。 <br><br> 在用于跟踪摩尔环境的算法的原始描述中，停止标准是第二次击中<b>初始</b>像素。 类似于平方跟踪算法，事实证明，使用此准则跟踪Moore的周围环境无法检测到大量图案的轮廓。 <br><br> 以下是一个动画演示，解释了为什么算法由于选择了错误的停止标准而无法找到模式的准确轮廓： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1c/d5e/7af/a1cd5e7afa1cd1b7312e5770c6cf826c.gif" height="252" width="216"></div><br> 如您所见，改善停止条件可以成为改善跟踪整体性能的良好开端。 有两种有效的关闭准则替代方案，类似于Jacob的关闭准则。 <br><br> 使用Jacob准则显着提高了追踪Moore周围环境的效率，使其成为确定任何图案轮廓的最佳算法，而不论其连通性如何。 <br><br> 其原因主要是因为该算法检查边界像素的整个Moore邻域以搜索下一个边界像素。 不同于仅向左和向右旋转并“对角地”丢失像素的正方形轨迹算法，摩尔的邻域轨迹将始终能够检测任何连接的组件的外边界。 原因是：对于任何<b><i>8个连接</i></b> （或简单<b><i>连接</i></b> ）的图案， <b>下一个</b>边框像素位于当前边框像素的Moore邻域内。 由于Moore的邻域跟踪会检查当前边界像素的Moore邻域中的每个像素，因此它必须检测下一个边界像素。 <br><br> 当Moore邻域的跟踪以与第一次相同的方式第二次到达初始像素时，这意味着已检测到图案的<b>完整</b> <b>外部轮廓</b> ，并且如果算法没有停止，它将再次检测到相同的轮廓。 <br><br><h2> 径向扫描 </h2><br> 径向扫描算法是一些书中讨论的轮廓检测算法。 尽管名称复杂，但基本思想很简单。 实际上，事实证明径向扫描算法<b>与</b>摩尔环境<b>的</b>轨迹<b>相同</b> 。 有人可能会问：“我们为什么要提他呢？” <br><br> 跟踪Moore的周围环境，然后在Moore附近以某个方向（我们选择顺时针方向）搜索当前边界像素，直到找到黑色像素为止。 然后，她将该像素声明为当前边界像素并继续。 <br><br> 径向扫描算法执行相同的操作。 另一方面，它提供了一种有趣的方式来找到给定边界像素的Moore邻域中的下一个黑色像素。 <br><br> 该方法基于以下思想： <br><br> 每次找到新的边界像素时，将其设为当前像素<b>P</b> ，并绘制<b>一条</b>将<b>P</b>与<b>先前的</b>边界像素连接起来<b>的假想线段</b> 。 然后，我们相对于<b>P</b>顺时针<b>旋转</b>线段，直到它遇到像素<b>P</b>的Moore邻域中的黑色像素<b>。</b> 线的旋转与检查Moore <b>P</b>附近的每个像素相同<b>。</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们创建了一个动画演示，演示了径向扫描算法的工作原理以及如何追踪Moore的周围环境。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa1/419/ff6/fa1419ff6b8efc7ef94d978854f99fab.gif" height="360" width="326"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">径向扫描算法何时停止？</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们使用以下停止条件来解释算法的行为...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 停止条件1 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让径向扫描算法</font><font style="vertical-align: inherit;">第二次</font><font style="vertical-align: inherit;">访问</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始像素</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时完成。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下面是一个动画演示，从中可以清楚地了解到为什么会正确更改中断标准。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04c/432/408/04c432408fca093316e950c77bdd5537.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还值得一提的是，当在两种算法中都使用此停止准则时，径向扫描算法的有效性与跟踪摩尔定律是相同的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在平方跟踪算法和摩尔邻域跟踪中，我们发现使用雅各布停止准则可以显着提高两种算法的性能。</font></font><br><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jacob的停止条件</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要求算法在</font><font style="vertical-align: inherit;">第二次以与第一次相同的方向</font><font style="vertical-align: inherit;">访问</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起始</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像素</font><font style="vertical-align: inherit;">时停止执行</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不幸的是，我们不能在径向扫描算法中使用雅各布停止准则。原因是径向扫描算法没有定义概念</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">撞击边界像素的“方向”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">换句话说，尚不清楚算法落入边界像素的“方向”（其定义是不平凡的）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们需要提出另一种停止准则，该准则不依赖于击中特定像素的方向，这可以提高径向扫描算法的有效性。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 停止条件2 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设算法每次检测到新的边界像素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i时</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，都会将其插入</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一系列</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">边界像素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，...，P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">；并声明为当前边框像素。 （</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将考虑</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像素）。这意味着我们知道</font><font style="vertical-align: inherit;">每个当前边界像素</font><b><font style="vertical-align: inherit;">P </font></b><b><sub><font style="vertical-align: inherit;">i</font></sub></b><font style="vertical-align: inherit;">的先前边界像素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 （关于</font><b><font style="vertical-align: inherit;">起始像素</font></b><font style="vertical-align: inherit;">，我们假设</font><b><font style="vertical-align: inherit;">P </font></b><b><sub><font style="vertical-align: inherit;">0</font></sub></b></font><b><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个虚构像素，与面对</font><font style="vertical-align: inherit;">边界像素行中</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像素</font><font style="vertical-align: inherit;">的网格上的任何像素都不等效</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于以上假设，我们可以如下确定停止标准：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font><font style="vertical-align: inherit;">以下情况下</font><font style="vertical-align: inherit;">，算法停止执行：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a）当前边界像素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">先前</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已</font><font style="vertical-align: inherit;">满足作为</font><font style="vertical-align: inherit;">一系列边界像素中</font><font style="vertical-align: inherit;">的像素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（其中</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j &lt;i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），并且</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b）</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i- 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j-1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">换句话说，算法在</font><b><font style="vertical-align: inherit;">第二次</font></b><font style="vertical-align: inherit;">访问边界像素P时完成执行</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次，如果该边界像素P（在一系列边界象素）在所述第二时间是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其是P，当P是由被访问的像素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的第一</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果满足停止条件的条件并且算法没有关闭，则径向扫描算法将</font><font style="vertical-align: inherit;">第二次</font><font style="vertical-align: inherit;">继续检测</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">边界。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用此停止准则的径向扫描算法的性能类似于使用Jacob停止准则跟踪Moore邻域的性能。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Theo Pavlidis算法 </font></font></h2><br><h4> 主意 </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该算法是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Theo Pavlidis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提出的最新的环路检测算法之一</font><font style="vertical-align: inherit;">。他在1982年的《</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图形和图像处理算法》</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（第7章，第5节）中</font><font style="vertical-align: inherit;">对此进行了引用</font><font style="vertical-align: inherit;">。它不像跟踪正方形或跟踪摩尔的算法那样简单，但是却没有那么复杂（这对于大多数边缘检测算法而言都是典型的）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将不会以他的书中介绍的方法来解释该算法。我们的方法更容易理解，并给出了算法基础的总体思路。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在不失一般性的前提下，我们决定顺时针旋转循环以匹配本文介绍的所有其他算法的顺序。另一方面，Pavlidis选择逆时针方向。这不会影响算法的性能。唯一的区别是绕轮廓时我们将进行的相对运动方向。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在让我们继续这个想法... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设我们有一个数字模式，即在白色像素背景上的一组黑色像素，即在网格上；找到黑色像素并将其声明为“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”像素。您可以</font><font style="vertical-align: inherit;">按照多种方式</font><font style="vertical-align: inherit;">搜索“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”像素，例如，如上所述。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">寻找</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首字母</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用此方法的像素是可选的。取而代之的是，我们选择</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的初始</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像素满足规定的初始像素算法Pavlidis的选择以下限制：</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在我们进入初始像素输入方向的一个重要的限制是</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上可以选择在任何黑色边框像素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下：如果您最初站在它上面，左相邻像素不是黑色。换句话说，您需要以</font><font style="vertical-align: inherit;">左相邻像素为白色的方向</font><font style="vertical-align: inherit;">输入</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起始</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像素（此处的“左”是相对于我们输入</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起始像素</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的方向</font><font style="vertical-align: inherit;">）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在想象你是一只站在上面的瓢虫</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起始</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像素，如下</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图1</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所示。在执行算法期间，我们只会对您面前的三个像素感兴趣，即</font><b><i><font style="vertical-align: inherit;">图1</font></i></b><font style="vertical-align: inherit;">所示的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1，P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 （我们将</font><b><font style="vertical-align: inherit;">P2</font></b><font style="vertical-align: inherit;">指定为</font><font style="vertical-align: inherit;">您</font><b><font style="vertical-align: inherit;">前面</font></b><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">像素</font><font style="vertical-align: inherit;">，</font><b><font style="vertical-align: inherit;">P1</font></b><font style="vertical-align: inherit;">是</font><b><font style="vertical-align: inherit;">P2</font></b><font style="vertical-align: inherit;">左侧的像素</font><font style="vertical-align: inherit;">，</font><b><font style="vertical-align: inherit;">P3</font></b><font style="vertical-align: inherit;">是</font><b><font style="vertical-align: inherit;">P2</font></b><font style="vertical-align: inherit;">右侧的像素</font><font style="vertical-align: inherit;">）。</font></font><b><i><font style="vertical-align: inherit;"></font></i></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53e/792/4b1/53e7924b1a7cb6c5e84f70a038d52bc8.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与正方形轨迹算法一样，Pavlidis算法中最重要的是“方向感”。向左和向右转是相对于当前位置的，这取决于您输入当前像素的方式。因此，为了做出正确的动作，跟踪当前方向很重要。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，无论您位于何处，都如上所述确定像素P1，P2和P3。</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有了这些信息，我们就可以解释算法了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每次您站在当前边界像素（首先是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像素）上时，我们都会执行以下操作：</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，检查像素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1为</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">黑色，则声明</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当前边界像素并</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向前移动一步，然后向左</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动</font><b><font style="vertical-align: inherit;">一步以</font></b><font style="vertical-align: inherit;">到达P1（</font><font style="vertical-align: inherit;">移动</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺序</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常重要）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图2</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下面说明了此情况。</font><font style="vertical-align: inherit;">到达</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的路径以</font><font style="vertical-align: inherit;">蓝色显示。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/c32/131/ae9c321310cb5a8902ae4df3dc42cdc9.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且仅当P1为白色时，我们才继续检查P2 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2为</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">黑色，则将</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">声明</font><b><font style="vertical-align: inherit;">为</font></b><font style="vertical-align: inherit;">当前边界像素，并</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向前移动一步</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2上</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这种情况在</font><font style="vertical-align: inherit;">下面的</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图3</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中显示。</font><font style="vertical-align: inherit;">在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上需要遵循的路径</font><font style="vertical-align: inherit;">以蓝色显示。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/7eb/934/b347eb9345873e5ba6aa136ab2fbb406.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅当P1和P2均为白色时，再检查P3 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3为</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">黑色，则将</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">声明</font><b><font style="vertical-align: inherit;">为</font></b><font style="vertical-align: inherit;">当前边框像素，并</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向右移动一级，然后向左移动一级</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如下图4所示。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/bb6/7fa/0adbb67fa67183dec47bb4c1bf3221a7.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅此而已！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三个简单案例的三个简单规则。正如您所看到的，转弯时保持跟踪方向很重要，因为所有移动都是相对于当前方向进行的。但是似乎我们忘记了什么？</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们面前的所有三个像素都是白色怎么办？</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，我们顺时针旋转（位于当前边界像素处）90度，以看到我们前面的一组新的三个像素。然后，对这些新像素进行相同的检查。您可能仍然有一个问题：如果所有</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三个像素都是白色怎么办？然后，我们再次沿顺时针方向旋转90度，站在同一像素上。在检查Moore像素的整个邻域之前，您可以旋转3次（每次顺时针旋转90度）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们旋转了3次却没有找到黑色像素，则意味着我们正站在一个</font><font style="vertical-align: inherit;">未连接到任何其他黑色像素</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">孤立像素</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上。</font><font style="vertical-align: inherit;">这就是为什么该算法允许您旋转三遍，然后完成其执行的原因。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一方面：</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法何时完成执行？</font></font></i></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该算法在两种情况下终止：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a）如上所述。</font><font style="vertical-align: inherit;">该算法允许您旋转3次（每次顺时针旋转90度），完成执行并声明像素隔离后；或</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b）当前边界像素为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像素时，该算法通过“声明”检测到图案轮廓来完成执行。</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 演算法 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下是对Pavlidis算法的正式描述：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入：</font><font style="vertical-align: inherit;">包含</font><font style="vertical-align: inherit;">黑色单元</font><font style="vertical-align: inherit;">连接成分</font><b><font style="vertical-align: inherit;">P的</font></b><font style="vertical-align: inherit;">方形</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">镶嵌</font></font></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输出：</font><font style="vertical-align: inherit;">边界像素的</font><b><font style="vertical-align: inherit;">B</font></b><font style="vertical-align: inherit;">行</font><b><font style="vertical-align: inherit;">（b </font></b><b><sub><font style="vertical-align: inherit;">1</font></sub></b><b><font style="vertical-align: inherit;">，b </font></b><b><sub><font style="vertical-align: inherit;">2</font></sub></b><b><font style="vertical-align: inherit;">，...，b </font></b><b><sub><font style="vertical-align: inherit;">k</font></sub></b><b><font style="vertical-align: inherit;">）</font></b><font style="vertical-align: inherit;">，即 </font><font style="vertical-align: inherit;">轮廓。</font><font style="vertical-align: inherit;">定义：</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示</font><font style="vertical-align: inherit;">当前边界像素，即 </font><font style="vertical-align: inherit;">我们站立的像素。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如下定义</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1，P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：（</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另请参见上面的图1）</font></font></i></b> </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是您前方的像素，与您所站立的像素相邻，即 </font><font style="vertical-align: inherit;">像素为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li><li> <b>P1</b> —  ,   <b>P2</b> . </li><li> <b>P3</b> —  ,   <b>P2</b> . </li><li>  <b>«»</b>            . </li></ul><br> 开始 <br><br><ul><li>  <b>B</b>   . </li><li>   <b>T</b>     ,      <b></b>  <b>s</b>  <b>P</b> <b><i>(.     ,       )</i></b> </li><li>  <b>s</b>  <b>B</b> . </li><li>    <b>p</b>     <b>s</b> . </li><li>  : <br>   <b>P1</b>  <br><ul><li>  <b>P1</b>  <b>B</b> </li><li>  <b>p=P1</b> </li><li>     ,      </li></ul><br>   <b>P2</b>  <br><ul><li>  <b>P2</b>  <b>B</b> </li><li>  <b>p=P2</b> </li><li>      <b><i>(.   3)</i></b> </li></ul><br>   <b>P3</b>  <br><ul><li>  <b>P3</b>  <b>B</b> </li><li>  <b>p=P3</b> </li><li>    ,      <b><i>(.   4)</i></b> </li></ul><br>        90    ,   <b>  p</b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">终止程序并声明</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p为</font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">孤立</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像素</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 否则 </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顺时针旋转90度，站在当前像素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p = s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（结束重复循环）</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 结束 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 示范 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下是有关Pavlidis算法如何检测给定图案轮廓的动画演示。</font><font style="vertical-align: inherit;">不要忘记我们以像素为单位行走；</font><font style="vertical-align: inherit;">注意在向左或向右旋转时方向如何变化。</font><font style="vertical-align: inherit;">为了尽可能详细地解释该算法，我们在其中包括了所有可能的情况。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/f0f/1dd/22af0f1dd39a517bb6097cd0fe3ec99d.gif" height="324" width="288"></div><br><h4> 分析方法 </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您认为Pavlidis算法是检测图案轮廓的理想选择，那么您应该改变主意…… </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此算法实际上比跟踪Moore的环境要复杂一些，在Moore中，没有特殊情况需要单独处理，但是他无法确定较大轮廓的轮廓。具有某种连通性的一系列模式。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该算法在4连接模式下效果很好。跟踪一些不是4连接的8连接的模式时，会发生其问题。下面是一个动画演示，演示了Pavlidis算法如何无法检测到8个连接模式（不是4个连接模式）的正确轮廓-它跳过了大部分边框。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/225/56a/816/22556a816442cf010492cc30b64392eb.gif" height="252" width="247"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有两种简单的方法可以修改算法以显着提高其性能。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a）替换停止条件</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以在算法第三次甚至第四次访问起始像素时结束算法，而不是在算法第二次访问起始像素时完成算法。这将提高算法的整体性能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b）找到问题的根源，即在选择起始像素之前，</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存在对起始像素进行输入的方向的重要限制。本质上，您需要输入起始像素，以便当您站在其上时，左侧的像素为白色。之所以引入这个限制是因为我们总是考虑三个像素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以某种顺序</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在某些模式中，我们将跳过直接位于初始像素左侧的边界像素。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们冒着风险，不仅会丢失初始像素中的左相邻像素，还会丢失其</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正下方</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><b><font style="vertical-align: inherit;">像素</font></b><font style="vertical-align: inherit;">（如分析所示）。此外，在一些模式将被跳过对应像素的像素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图5</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的下方。因此，我们假设需要以</font><font style="vertical-align: inherit;">与</font><font style="vertical-align: inherit;">以下</font><b><i><font style="vertical-align: inherit;">图5</font></i></b><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">所示</font><font style="vertical-align: inherit;">的像素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L，W</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对应的像素</font><font style="vertical-align: inherit;">为白色</font><font style="vertical-align: inherit;">的方向命中起始像素</font><font style="vertical-align: inherit;">。</font></font><b><i><font style="vertical-align: inherit;"></font></i></b><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/a81/359/9c8a81359338b31b6f5c0e016230e629.gif" height="200" width="159"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，可以正确检测到演示中所示的模式，并且Pavlidis算法的有效性将大大提高。</font><font style="vertical-align: inherit;">另一方面，找到满足这些要求的初始像素可能具有挑战性，并且在许多情况下将不可能找到这样的像素。</font><font style="vertical-align: inherit;">在这种情况下，您应该使用另一种方法来改进Pavlidis算法，即第三次访问起点后算法的完成。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN467611/">https://habr.com/ru/post/zh-CN467611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN467597/index.html">使用Vowpal Wabbit个性化大数据产品指南</a></li>
<li><a href="../zh-CN467599/index.html">使用OpenGL进行3D图形渲染</a></li>
<li><a href="../zh-CN467605/index.html">您只需要URL</a></li>
<li><a href="../zh-CN467607/index.html">码头工人的自白</a></li>
<li><a href="../zh-CN467609/index.html">在React Native上创建移动应用程序</a></li>
<li><a href="../zh-CN467615/index.html">如何创建Python包装器而不会发疯</a></li>
<li><a href="../zh-CN467617/index.html">Kaspresso：您正在等待的自动测试框架</a></li>
<li><a href="../zh-CN467619/index.html">Aquafor投手是无法设计用于水处理的过滤器的一个很好的例子</a></li>
<li><a href="../zh-CN467621/index.html">Elasticsearch在Ozon举行的莫斯科聚会</a></li>
<li><a href="../zh-CN467623/index.html">React Native：使用Animated API创建一个动画输入字段</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>