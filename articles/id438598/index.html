<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😊 🍧 🌚 Bereaksi & BEM - kolaborasi resmi. Bagian sejarah 👸🏾 🆕 🤛🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah kisah mengintegrasikan metodologi BEM ke dalam React universe. Materi yang akan Anda baca didasarkan pada pengalaman pengembang Yandex meng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bereaksi & BEM - kolaborasi resmi. Bagian sejarah</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/438598/"><p>  Ini adalah kisah mengintegrasikan metodologi BEM ke dalam React universe.  Materi yang akan Anda baca didasarkan pada pengalaman pengembang Yandex mengembangkan layanan terbesar dan paling banyak dimuat di Rusia - Yandex.Search.  Kami belum pernah berbicara secara terperinci dan mendalam tentang mengapa kami melakukannya, dan bukan sebaliknya, apa yang memotivasi kami dan apa yang sebenarnya kami inginkan.  Orang luar itu mendapat rilis dan ulasan kering di konferensi.  Hanya di sela-sela yang bisa mendengar sesuatu seperti itu.  Sebagai penulis bersama, saya marah karena kelangkaan informasi di luar setiap kali saya berbicara tentang versi perpustakaan baru.  Tapi kali ini kami akan membagikan semua detailnya. </p><br><img src="https://habrastorage.org/webt/wb/mt/xc/wbmtxcvurtd6cdv1aomjrtcyfw8.png"><br><p>  Setiap orang telah mendengar tentang metodologi BEM.  Penyeleksi CSS dengan garis bawah.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendekatan komponen</a> dibicarakan, mengingat cara CSS penyeleksi CSS ditulis.  Tetapi tidak akan ada kata tentang CSS di artikel.  Hanya JS, hanya hardcore! </p><a name="habracut"></a><br><p>  Untuk memahami mengapa metodologi muncul dan masalah apa yang dihadapi Yandex saat itu, saya sarankan Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membiasakan diri dengan sejarah</a> BEM. </p><br><h2 id="prolog">  Prolog </h2><br><p> BEM benar-benar lahir sebagai keselamatan dari konektivitas yang kuat dan bersarang di CSS.  Tetapi membagi lembar <code>style.css</code> ke dalam file untuk setiap blok, elemen atau pengubah mengarah pada penataan kode JavaScript yang serupa. </p><br><p>  Pada tahun 2011, Open Source memperoleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komitmen pertama dari</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>i-bem.js</code></a> , yang bekerja bersama dengan mesin template <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>bem-xjst</code></a> .  Kedua teknologi tersebut tumbuh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">XSLT</a> dan menyajikan gagasan populer saat itu untuk memisahkan logika bisnis dan presentasi komponen.  Di dunia luar, ini adalah masa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">-masa indah dari</a> Setang dan Garis Bawah. </p><br><p>  <code>bem-xjst</code> adalah jenis mesin templat yang berbeda.  Untuk menambah pengetahuan saya tentang arsitektur pendekatan standardisasi, saya sangat merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan Sergei Berezhnoy</a> .  <code>bem-xjst</code> dapat mencoba mesin template <code>bem-xjst</code> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kotak pasir online</a> . </p><br><p>  Karena kekhasan layanan pencarian Yandex, antarmuka pengguna dibangun menggunakan data.  Halaman hasil pencarian unik untuk setiap permintaan. </p><br><p><img src="https://habrastorage.org/webt/6g/af/sc/6gafsczppz4ul8glzeliauwnkjc.png"><br>  <em>Cari kueri berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a></em> </p><br><p><img src="https://habrastorage.org/webt/ni/z5/nc/niz5ncgv3rlci2jfymornobfvcy.png"><br>  <em>Cari kueri berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a></em> </p><br><p><img src="https://habrastorage.org/webt/eb/6q/ws/eb6qws6vwtclkce_jsumewy4jkk.png"><br>  <em>Cari kueri berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a></em> </p><br><p>  Ketika pembagian menjadi blok, elemen, dan pengubah diperluas ke sistem file, ini memungkinkan untuk mengumpulkan hanya kode yang diperlukan secara paling efektif, bahkan untuk setiap halaman, untuk setiap permintaan pengguna.  Tapi bagaimana caranya? </p><br><pre> <code class="plaintext hljs">src/components ├── ComponentName │ ├── _modName │ │ ├── ComponentName_modName.tsx —   │ │ └── ComponentName_modName_modVal.tsx —    │ ├── ElementName │ │ └── ComponentName-ElementName.tsx —   ComponentName │ ├── ComponentName.i18n —   │ │ ├── ru.ts —     │ │ ├── en.ts —     │ │ └── index.ts —    │ ├── ComponentName.test —   │ │ ├── ComponentName.page-object.js — Page Object │ │ ├── ComponentName.hermione.js —   │ │ └── ComponentName.test.tsx — unit- │ ├── ComponentName.tsx —    │ ├── ComponentName.scss —   │ ├── ComponentName.examples.tsx —    Storybook │ └── README.md —  </code> </pre> <br><p>  <em>Struktur direktori komponen modern</em> </p><br><p>  Seperti di beberapa perusahaan lain, di Yandex, pengembang antarmuka bertanggung jawab untuk frontend, yang terdiri dari bagian klien di browser dan bagian server di <code>Node.js</code>  Bagian server memproses data pencarian "besar" dan memaksakan templat pada mereka.  Pemrosesan data primer mengubah JSON ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BEMJSON</a> , struktur data untuk mesin template <code>bem-xjst</code> .  Mesin templat berjalan di sekitar setiap simpul pohon dan memaksakan templat di atasnya.  Karena konversi utama berlangsung di server, dan karena pembagian menjadi entitas kecil, node sesuai dengan file, selama pembuatan template kami mendorong kode ke browser yang akan digunakan hanya pada halaman saat ini. </p><br><p>  Di bawah ini adalah korespondensi node BEMJSON ke file pada sistem file. </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">block</span></span>: <span class="hljs-string"><span class="hljs-string">'Select'</span></span>, <span class="hljs-attr"><span class="hljs-attr">elem</span></span>: <span class="hljs-string"><span class="hljs-string">'Item'</span></span>, <span class="hljs-attr"><span class="hljs-attr">elemMods</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'navigation'</span></span> } };</code> </pre> <br><pre> <code class="plaintext hljs">src/components ├── Select │ ├── Item │ │ _type │ │ ├── Select-Item_type_navigation.js │ │ └── Select-Item_type_navigation.css</code> </pre> <br><p>  Sistem modular <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>YModules</code></a> bertanggung jawab untuk mengisolasi komponen kode JavaScript di browser.  Ini memungkinkan Anda untuk secara sinkron dan asinkron mengirimkan modul ke browser.  Contoh bagaimana komponen bekerja dengan <code>YModules</code> dan <code>i-bem.js</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat ditemukan di sini</a> .  Saat ini, bagi sebagian besar pengembang, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>  webpack</code></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">standar impor dinamis yang</a> belum dirilis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melakukan hal ini</a> . </p><br><p>  Seperangkat metodologi BEM, mesin templat deklaratif, dan kerangka kerja JS dengan sistem modular memungkinkan untuk menyelesaikan masalah apa pun.  Namun seiring berjalannya waktu, dinamika telah sampai pada antarmuka pengguna. </p><br><h2 id="novaya-nadezhda">  Harapan baru </h2><br><p>  Pada 2013, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bereaksi Enchanted the</a> Open Source.  Bahkan, Facebook mulai menggunakannya kembali pada tahun 2011.  James Long, dalam catatannya dari konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JS Conf US</a> , mengatakan: </p><br><blockquote>  Dua sesi terakhir mengejutkan.  Yang pertama diberikan oleh dua pengembang Facebook dan mereka mengumumkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Facebook React</a> .  Saya tidak membuat banyak catatan karena saya agak kaget dengan betapa buruknya ide yang saya pikirkan.  Pada dasarnya, mereka menciptakan bahasa yang disebut JSX yang memungkinkan Anda menanamkan XML dalam JavaScript untuk membuat antarmuka pengguna langsung yang reaktif.  XML  Dalam JavaScript. </blockquote><p>  Bereaksi telah mengubah pendekatan untuk merancang aplikasi web.  Ini menjadi sangat populer sehingga hari ini Anda tidak dapat menemukan pengembang yang belum pernah mendengar Bereaksi.  Tetapi satu hal lagi yang penting: aplikasi menjadi berbeda, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SPA telah</a> masuk ke dalam kehidupan kita. </p><br><p>  Secara umum diterima bahwa pengembang Yandex memiliki rasa keindahan khusus sehubungan dengan teknologi.  Terkadang aneh, yang sulit untuk diperdebatkan, tetapi tidak pernah tanpa alasan.  Ketika React mencetak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bintang di GitHub</a> , banyak orang yang akrab dengan teknologi web Yandex bersikeras: Facebook menang, jatuhkan kerajinanmu dan jalankan tulis ulang semua yang ada di React sebelum terlambat.  Penting untuk memahami dua hal. </p><br><p>  Pertama, tidak ada perang.  Perusahaan tidak bersaing dalam menciptakan kerangka kerja terbaik di Bumi.  Jika sebuah perusahaan mulai menghabiskan lebih sedikit waktu (baca-uang) untuk tugas-tugas infrastruktur dengan produktivitas yang sama, semua orang akan mendapat manfaat dari ini.  Tidak masuk akal untuk menulis kerangka kerja untuk menulis kerangka kerja.  Pengembang terbaik membuat alat yang menyelesaikan tugas perusahaan dengan cara terbaik.  Perusahaan, layanan, tujuan - semuanya berbeda.  Karenanya beragam alat. </p><br><p>  Kedua, kami sedang mencari cara untuk menggunakan Bereaksi seperti yang kita inginkan.  Dengan semua fitur yang diberikan teknologi kami di atas. </p><br><p>  Dipercaya secara luas bahwa kode yang menggunakan Bereaksi cepat secara default.  Jika Anda juga berpikir demikian, maka Anda salah besar.  Satu-satunya hal yang React lakukan adalah, dalam banyak kasus, membantu berinteraksi secara optimal dengan DOM. </p><br><p>  Hingga versi 16, React memiliki kesalahan fatal.  Itu 10 kali lebih lambat dari <code>bem-xjst</code> di server.  Kami tidak mampu membeli limbah seperti itu.  Waktu respons untuk Yandex adalah salah satu metrik utama.  Bayangkan ketika Anda meminta resep anggur, Anda mendapat jawaban 10 kali lebih lambat dari biasanya.  Anda tidak akan senang dengan alasan, bahkan jika Anda tahu apa pun tentang pengembangan web.  Apa yang bisa kita katakan tentang penjelasannya, seperti "tetapi menjadi lebih nyaman bagi pengembang untuk berkomunikasi dengan DOM".  Tambahkan di sini rasio harga implementasi dan laba - dan Anda sendiri yang akan membuat satu-satunya keputusan yang tepat. </p><br><p>  Untungnya untuk kesedihan, para pengembang adalah orang-orang aneh.  Jika sesuatu tidak berhasil, maka ini bukan alasan untuk membatalkan semuanya ... </p><br><h2 id="shivorot-navyvorot">  Terbalik </h2><br><p>  Kami yakin bahwa kami bisa mengalahkan kelambatan React.  Kami sudah memiliki mesin templat cepat.  Yang Anda butuhkan hanyalah membuat HTML di server menggunakan <code>bem-xjst</code> , dan pada klien untuk "memaksa" Bereaksi untuk menerima markup ini sebagai miliknya.  Idenya sangat sederhana sehingga tidak ada yang menandakan kegagalan. </p><br><p>  Dalam versi hingga dan termasuk 15, React memvalidasi validitas markup menggunakan hash sum - sebuah algoritma yang mengubah setiap optimasi menjadi labu.  Untuk meyakinkan React dari validitas markup, perlu untuk meletakkan id untuk setiap node dan menghitung jumlah hash dari semua node.  Itu juga berarti mendukung satu set templat ganda: Bereaksi untuk klien dan <code>bem-xjst</code> untuk server.  Tes kecepatan sederhana dengan instalasi id membuatnya jelas bahwa tidak ada gunanya melanjutkan. </p><br><p>  <code>bem-xjst</code> bem <code>bem-xjst</code> adalah alat yang sangat diremehkan.  Lihatlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan pemilik utama Glory Oliyanchuk</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat</a> sendiri.  <code>bem-xjst</code> didasarkan pada arsitektur yang memungkinkan Anda untuk menggunakan satu sintaks templat untuk transformasi berbeda dari pohon sumber.  Sangat mirip dengan Bereaksi, bukan?  Fitur ini hari ini memungkinkan alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>react-sketchapp</code></a> . </p><br><p>  Di luar kotak <code>bem-xjst</code> berisi dua jenis konversi: dalam HTML dan JSON.  Setiap pengembang yang cukup rajin dapat menulis mesinnya sendiri untuk mengubah template menjadi apa pun.  Kami mengajarkan <code>bem-xjst</code> mengubah pohon data menjadi urutan panggilan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi HyperScript</a> .  Yang berarti kompatibilitas penuh dengan React dan implementasi lain dari algoritma DOM Virtual, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Preact</a> . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yPV6pcMdezM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>Pengantar rinci untuk pembuatan panggilan fungsi HyperScript</em> </p><br><p>  Karena Bereaksi templat memerlukan koeksistensi tata letak dan logika bisnis, kami harus membawa logika dari <code>i-bem.js</code> ke templat kami, yang tidak dimaksudkan untuk ini.  Bagi mereka itu tidak wajar.  Mereka pergi secara berbeda.  Ngomong-ngomong! </p><br><p>  Di bawah ini adalah contoh dari kedalaman perekatan dunia yang berbeda dalam satu runtime. </p><br><pre> <code class="javascript hljs">block(<span class="hljs-string"><span class="hljs-string">'select'</span></span>).elem(<span class="hljs-string"><span class="hljs-string">'menu'</span></span>)( def()(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> React = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'react'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Menu = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../components/menu/menu'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MenuItem = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../components/menu-item/menu-item'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _select = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ctx._select; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selectComponent = _select._select; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> React.createElement.apply(React, [ Menu, { <span class="hljs-attr"><span class="hljs-attr">mix</span></span>: { <span class="hljs-attr"><span class="hljs-attr">block</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.block, <span class="hljs-attr"><span class="hljs-attr">elem</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elem }, <span class="hljs-attr"><span class="hljs-attr">ref</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">menu</span></span></span><span class="hljs-function"> =&gt;</span></span> selectComponent._menu = menu, <span class="hljs-attr"><span class="hljs-attr">size</span></span>: _select.mods.size, <span class="hljs-attr"><span class="hljs-attr">disabled</span></span>: _select.mods.disabled, <span class="hljs-attr"><span class="hljs-attr">mode</span></span>: _select.mods.mode, <span class="hljs-attr"><span class="hljs-attr">content</span></span>: _select.options, <span class="hljs-attr"><span class="hljs-attr">checkedItems</span></span>: _select.bindings.checkedItems, <span class="hljs-attr"><span class="hljs-attr">style</span></span>: _select.bindings.popupMenuWidth, <span class="hljs-attr"><span class="hljs-attr">onKeyDown</span></span>: _select.bindings.onKeyDown, <span class="hljs-attr"><span class="hljs-attr">theme</span></span>: _select.mods.theme, }].concat(_select.options.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">option</span></span></span><span class="hljs-function"> =&gt;</span></span> React.createElement( MenuItem, { <span class="hljs-attr"><span class="hljs-attr">onClick</span></span>: _select.bindings.onOptionCheck, <span class="hljs-attr"><span class="hljs-attr">theme</span></span>: _select.mods.theme, <span class="hljs-attr"><span class="hljs-attr">val</span></span>: option.value, }, option.content) )) ); }) );</code> </pre> <br><p>  Tentu saja, kami memiliki kebaktian kami sendiri.  Seperti yang Anda tahu, operasi tercepat adalah penggabungan string.  Mesin <code>bem-xjst</code> dibangun di atasnya, perakitan dibangun di atasnya.  File blok, elemen, dan pengubah terletak di folder, dan perakitan hanya perlu merekatkan file dalam urutan yang benar.  Dengan pendekatan ini, Anda dapat merekatkan JS, CSS, dan templat secara paralel, serta entitas itu sendiri.  Artinya, jika Anda memiliki empat komponen dalam suatu proyek, empat inti pada laptop, dan merakit satu komponen teknologi membutuhkan satu detik, maka membangun proyek akan memakan waktu dua detik.  Di sini seharusnya menjadi lebih jelas bagaimana kita mengelola untuk mendorong hanya kode yang diperlukan ke dalam browser. </p><br><p>  Semua ini untuk kami lakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ENB</a> .  Kami menerima pohon terakhir untuk standardisasi hanya dalam runtime, dan karena ketergantungan antara komponen harus muncul sedikit lebih awal untuk mengumpulkan bundel, fungsi ini diambil alih oleh teknologi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>deps.js</code></a> kurang dikenal.  Itu memungkinkan Anda untuk membuat grafik ketergantungan antara komponen, setelah itu kolektor dapat merekatkan kode dalam urutan yang diinginkan, melewati grafik. </p><br><p>  Bereaksi versi 16 berhenti bekerja ke arah ini. Kecepatan eksekusi templat pada server <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sama</a> .  Di fasilitas produksi, perbedaannya menjadi tak terlihat. </p><br><p>  Node: <strong>v8.4.0</strong> <br>  Anak-anak: <strong>5K</strong> </p><br><table><thead><tr><th>  penyaji </th><th>  waktu yang berarti </th><th>  ops / dtk </th></tr></thead><tbody><tr><td>  <strong>preact</strong> v8.2.6 </td><td>  66.235 ms </td><td>  15 </td></tr><tr><td>  <strong>bem-xjst</strong> v8.8.4 </td><td>  71.326 ms </td><td>  14 </td></tr><tr><td>  <strong>bereaksi</strong> v16.1.0 </td><td>  73.966 ms </td><td>  14 </td></tr></tbody></table><br><p>  Dengan menggunakan tautan di bawah ini, Anda dapat memulihkan riwayat pendekatan: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://ru.bem.info/forum/961/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/awinogradov/react-bl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/awinogradov/xjst-ddsl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/awinogradov/ddsl-react</a> </li></ul><br><p>  Sudahkah kita mencoba yang lain? </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/veged/bem-components-react</a> - pendekatan pertama untuk menerapkan metodologi dalam Bereaksi; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/Yeti-or/bem-hazard</a> - pendekatan serupa berdasarkan pada mesin templat BH.  Omong-omong, dengan BH, Anda dapat bermain-main secara online; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/dfilatov/bem-react</a> - membuat komponen melalui BEMJSON; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/rebem</a> - Utilitas BEM di dunia Bereaksi. </li></ul><br><p><img src="https://habrastorage.org/webt/uv/si/wt/uvsiwtsrexhffeuznrqhpxvtjva.png"></p><br><h2 id="motivaciya">  Motivasi </h2><br><p>  Di tengah cerita, akan berguna untuk membicarakan apa yang memotivasi kami.  Itu layak dilakukan di awal, tetapi - yang mengingat yang lama, mata itu sebagai hadiah.  Mengapa kita membutuhkan semua ini?  Apa yang BEM bawa yang Bereaksi tidak bisa lakukan?  Pertanyaan yang diajukan hampir semua orang. </p><br><h3 id="dekompoziciya">  Dekomposisi </h3><br><p>  Fungsi komponen menjadi lebih rumit dari tahun ke tahun, dan jumlah variasi meningkat.  Ini dinyatakan oleh <code>if</code> atau <code>switch</code> konstruksi, sebagai akibatnya, basis kode pasti tumbuh, sebagai akibatnya, berat komponen dan proyek yang menggunakan komponen tersebut meningkat.  Bagian utama dari logika komponen Bereaksi terkandung dalam metode <code>render()</code> .  Untuk mengubah fungsionalitas komponen, perlu menulis ulang sebagian besar metode, yang pasti mengarah pada peningkatan eksponensial dalam jumlah komponen yang sangat khusus. </p><br><p>  Semua orang tahu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">material-ui</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fabric-ui,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">react-bootstrap</a> .  Secara umum, semua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan terkenal</a> dengan komponen memiliki kelemahan yang sama.  Bayangkan Anda memiliki beberapa proyek dan semuanya menggunakan perpustakaan yang sama.  Anda mengambil komponen yang sama, tetapi dalam variasi yang berbeda: di sini ada pilih dengan kotak centang, tidak ada, ada tombol biru dengan ikon, ada tombol merah tanpa.  Bobot CSS dan JS yang diberikan perpustakaan kepada Anda akan sama di semua proyek.  Tapi mengapa?  Variasi komponen tertanam di dalam komponen itu sendiri dan ikut dengannya, baik Anda mau atau tidak.  Bagi kami ini tidak bisa diterima. </p><br><p>  Yandex juga memiliki perpustakaan sendiri dengan komponen - Lego.  Diterapkan dalam ~ 200 layanan.  Apakah kami ingin penggunaan Lego dalam Penelusuran dengan biaya yang sama untuk Yandex.Health?  Anda tahu jawabannya. </p><br><h3 id="krossplatformennaya-razrabotka">  Pengembangan lintas platform </h3><br><p>  Untuk mendukung banyak platform, paling sering mereka membuat versi terpisah untuk setiap platform, atau satu versi adaptif. </p><br><p>  Pengembangan versi individual membutuhkan sumber daya tambahan: semakin banyak platform, semakin banyak upaya.  Mempertahankan status sinkron properti produk dalam versi yang berbeda akan menyebabkan kesulitan baru. </p><br><p>  Pengembangan versi adaptif menyulitkan kode, menambah bobot, mengurangi kecepatan produk dengan perbedaan yang tepat antara platform. </p><br><p>  Apakah kita ingin orang tua / teman / kolega / anak-anak menggunakan versi desktop di ponsel dengan kecepatan internet yang lebih rendah dan produktivitas yang lebih rendah?  Anda tahu jawabannya. </p><br><h3 id="eksperimenty">  Eksperimennya </h3><br><p>  Jika Anda sedang mengembangkan proyek untuk audiens yang besar, Anda perlu memastikan setiap perubahan.  Eksperimen A / B adalah salah satu cara untuk mendapatkan kepercayaan itu. </p><br><p>  Cara mengatur kode untuk eksperimen: </p><br><ul><li>  fork proyek dan penciptaan instance layanan dalam produksi; </li><li>  kondisi titik di dalam basis kode. </li></ul><br><p>  Jika proyek memiliki banyak percobaan panjang, percabangan basis kode menyebabkan biaya yang signifikan.  Diperlukan untuk selalu memperbarui setiap cabang dengan eksperimen: kesalahan yang diperbaiki pelabuhan dan fungsionalitas produk.  Percabangan basis kode mempersulit percobaan memotong beberapa kali. </p><br><p>  Kondisi titik bekerja lebih fleksibel, tetapi menyulitkan basis kode: kondisi percobaan dapat mempengaruhi bagian proyek yang berbeda.  Sejumlah besar kondisi menurunkan kinerja dengan meningkatkan jumlah kode untuk browser.  Penting untuk menghapus ketentuan, menjadikan kode dasar atau sepenuhnya menghapus percobaan yang gagal. </p><br><p>  Dalam Pencarian ~ 100 percobaan online dalam berbagai kombinasi untuk pemirsa yang berbeda.  Anda bisa melihatnya sendiri.  Ingat, mungkin Anda memperhatikan fungsinya, dan seminggu kemudian secara ajaib menghilang.  Apakah kita ingin menguji teori produk dengan biaya mempertahankan ratusan cabang basis kode aktif 500.000 baris, yang diubah oleh ~ 60 pengembang setiap hari?  Anda tahu jawabannya. </p><br><h3 id="globalnye-izmeneniya">  Perubahan global </h3><br><p>  Misalnya, Anda dapat membuat komponen <code>CustomButton</code> diwarisi dari <code>Button</code> dari pustaka.  Tetapi <code>CustomButton</code> diwarisi tidak akan berlaku untuk semua komponen dari pustaka yang berisi <code>Button</code> .  Perpustakaan mungkin memiliki komponen <code>Search</code> dibangun dari <code>Input</code> dan <code>Button</code> .  Dalam hal ini, <code>CustomButton</code> diwarisi tidak muncul di dalam komponen <code>Search</code> .  Apakah kita ingin secara manual berkeliling seluruh basis kode tempat <code>Button</code> digunakan? </p><br><p><img src="https://habrastorage.org/webt/po/7j/fg/po7jfgnxrawurvtkoi-3ch2wneu.jpeg"></p><br><h2 id="dolgaya-doroga-v-kompoziciyu">  Jalan panjang menuju komposisi </h2><br><p>  Kami memutuskan untuk mengubah strategi.  Dalam pendekatan sebelumnya, mereka mengambil teknologi Yandex sebagai dasar dan mencoba membuat React bekerja berdasarkan ini.  Taktik baru menyarankan sebaliknya.  Inilah bagaimana proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inti-reaksi-bem</a> muncul. </p><br><blockquote>  Hentikan itu!  Kenapa Bereaksi sama sekali? </blockquote><p>  Kami melihat di dalamnya kesempatan untuk menyingkirkan rendering awal eksplisit dalam HTML dan dari dukungan manual status komponen JS nanti dalam runtime - pada kenyataannya, menjadi mungkin untuk menggabungkan templat BEMHMTL dan komponen JS menjadi satu teknologi. </p><br><h3 id="v100httpsgithubcombembem-reacttreev100">  <a href="">v1.0.0</a> </h3><br><p>  Awalnya, kami berencana untuk mentransfer semua praktik terbaik dan properti <code>bem-xjst</code> ke perpustakaan di atas Bereaksi.  Hal pertama yang menarik perhatian Anda adalah tanda tangan, atau, jika Anda lebih suka, sintaks untuk menggambarkan komponen. </p><br><p>  <em>Apa yang sudah Anda lakukan, ada JSX!</em> </p><br><p>  Versi pertama dibangun berdasarkan pewarisan - perpustakaan yang membantu mengimplementasikan kelas dan pewarisan.  Seperti yang Anda ingat, pada masa itu, prototipe prototipe dalam JavaScript tidak memiliki kelas, tidak ada <code>super</code> .  Secara umum, mereka masih absen, lebih tepatnya, ini bukan kelas yang pertama kali muncul di pikiran.  <code>inherit</code> melakukan segala sesuatu yang dapat dilakukan kelas dalam standar ES2015 sekarang, dan apa yang dianggap ilmu hitam: multiple inheritance dan prototype penggabungan alih-alih membangun kembali rantai, yang secara positif mempengaruhi kinerja.  Anda tidak akan salah jika Anda berpikir bahwa itu tampak masuk akal seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">warisan di Node.js</a> , tetapi mereka bekerja secara berbeda. </p><br><p>  Di bawah ini adalah contoh sintaks template <code>bem-react-core@v1.0.0</code> . </p><br><p>  <strong>App-Header.js</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { decl } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bem-react-core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> decl({ <span class="hljs-attr"><span class="hljs-attr">block</span></span>: <span class="hljs-string"><span class="hljs-string">'App'</span></span>, <span class="hljs-attr"><span class="hljs-attr">elem</span></span>: <span class="hljs-string"><span class="hljs-string">'Header'</span></span>, <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: { <span class="hljs-attr"><span class="hljs-attr">role</span></span>: <span class="hljs-string"><span class="hljs-string">'heading'</span></span> }, content() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } });</code> </pre> <br><p>  <strong>App-Header@desktop.js</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { decl } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bem-react-core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> decl({ <span class="hljs-attr"><span class="hljs-attr">block</span></span>: <span class="hljs-string"><span class="hljs-string">'App'</span></span>, <span class="hljs-attr"><span class="hljs-attr">elem</span></span>: <span class="hljs-string"><span class="hljs-string">'Header'</span></span>, <span class="hljs-attr"><span class="hljs-attr">tag</span></span>: <span class="hljs-string"><span class="hljs-string">'h1'</span></span>, attrs() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...this.__base(...arguments), <span class="hljs-string"><span class="hljs-string">'aria-level'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, }, content() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">` </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.__base(...</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">arguments</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">     h1`</span></span>; } });</code> </pre> <br><p>  <strong>App-Header@touch.js</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { decl } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bem-react-core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> decl({ <span class="hljs-attr"><span class="hljs-attr">block</span></span>: <span class="hljs-string"><span class="hljs-string">'App'</span></span>, <span class="hljs-attr"><span class="hljs-attr">elem</span></span>: <span class="hljs-string"><span class="hljs-string">'Header'</span></span>, <span class="hljs-attr"><span class="hljs-attr">tag</span></span>: <span class="hljs-string"><span class="hljs-string">'h2'</span></span>, content() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">` </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.__base(...</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">arguments</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">  `</span></span>; } });</code> </pre> <br><p>  <strong>index.js</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDomServer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom/server'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AppHeader <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b:App e:Header'</span></span>; ReactDomServer.renderToStaticMarkup(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">AppHeader</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">);</span></span></code> </pre> <br><p>  <strong>output@desktop.html</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"App-Header"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">role</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"heading"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">aria-level</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag">&gt;</span></span>A       h1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  <strong>output@touch.html</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"App-Header"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">role</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"heading"</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  <em>Templat perangkat untuk komponen yang lebih kompleks dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .</em> </p><br><p>  Karena kelas adalah objek, dan bekerja dengan objek dalam JavaScript paling mudah, sintaksinya sesuai.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sintaks</a> kemudian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bermigrasi</a> ke dalang <code>bem-xjst</code> . </p><br><p>  Perpustakaan adalah repositori global dari deklarasi objek - hasil dari mengeksekusi fungsi <code>decl</code> , bagian entitas: blok, elemen, atau pengubah.  BEM menyediakan mekanisme penamaan yang unik dan karenanya cocok untuk membuat kunci dalam lemari besi.  Komponen Bereaksi yang dihasilkan dilem di tempat penggunaannya.  Kuncinya adalah bahwa <code>decl</code> bekerja ketika mengimpor modul.  Ini memungkinkan untuk menunjukkan bagian komponen mana yang diperlukan di setiap tempat menggunakan daftar impor sederhana.  Tapi ingat: komponennya kompleks, ada banyak bagian, daftar impor panjang, pengembang malas. </p><br><h4 id="magiya-importov">  Impor Magic </h4><br><p>  Seperti yang Anda lihat, dalam contoh kode ada baris <code>import AppHeader from 'b:App e:Header'</code> . </p><br><p>  <em>Anda melanggar standar!</em>  <em>Itu tidak mungkin!</em>  <em>Itu tidak akan berhasil!</em> </p><br><p>  Pertama, standar impor tidak beroperasi dengan ketentuan dalam semangat "harus ada jalur ke modul nyata di jalur impor".  Kedua, itu adalah gula sintaksis yang dikonversi menggunakan Babel.  Ketiga, konstruksi tanda baca <code>import txt from 'raw-loader!./file.txt';</code> aneh untuk <code>import txt from 'raw-loader!./file.txt';</code> webpack <code>import txt from 'raw-loader!./file.txt';</code>  untuk beberapa alasan mereka tidak mengganggu siapa pun. <br>  Jadi, blok kami disajikan dalam dua platform: <code>desktop</code> , <code>touch</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Hello <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b:Hello'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     : var Hello = [ require('path/to/desktop/Hello/Hello.js'), require('path/to/touch/Hello/Hello.js') ][0].applyDecls();</span></span></code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini, kode akan mengimpor semua definisi komponen secara berurutan </font></font><code>Hello</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kemudian memanggil fungsi </font></font><code>applyDecls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menempelkan semua deklarasi blok dari repositori global melalui </font></font><code>inherit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan membuat komponen Bereaksi baru yang unik untuk tempat tertentu dalam proyek.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plugin untuk Babel yang melakukan konversi ini dapat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditemukan di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dan loader untuk webpack, yang mencari definisi komponen pada sistem file, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pada akhirnya, apa yang baik: </font></font></p><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sintaks templat deklaratif singkat yang memungkinkan Anda untuk mendefinisikan kembali berbagai bagian komponen di mana saja dalam proyek; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak ada rantai prototipe dalam warisan; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Komponen Bereaksi Unik untuk setiap tempat penggunaan. </font></font></li></ul><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan itu buruk: </font></font></p><br><ul><li>   TypeScript/Flow; </li><li>    React- ; </li><li> -         ; </li><li>      . </li></ul><br><h3 id="v200httpsgithubcombembem-reacttreev200"> <a href="">v2.0.0</a> </h3><br><p>     <code>bem-react-core@v1.0.0</code>  ,       . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Elem } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bem-react-core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Button } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../Button'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppHeader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Elem</span></span></span><span class="hljs-class"> </span></span>{ block = <span class="hljs-string"><span class="hljs-string">'App'</span></span>; elem = <span class="hljs-string"><span class="hljs-string">'Header'</span></span>; tag() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'h2'</span></span>; } content() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); } }</code> </pre> <br><p>     ,     .    ,   ,      TypeScript/Flow.   ,     <code>inherit</code>  «» ,     ,            . </p><br><p>   : <br> —         webpack    Babel; <br> —      ; <br> —       ,    . </p><br><p>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HOC</a> ,             . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Block, Elem, withMods } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bem-react-core'</span></span>; interface IButtonProps { <span class="hljs-attr"><span class="hljs-attr">children</span></span>: string; } interface IModsProps extends IButtonProps { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'link'</span></span> | <span class="hljs-string"><span class="hljs-string">'button'</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//   Text class Text extends Elem { block = 'Button'; elem = 'Text'; tag() { return 'span'; } } //   Button class Button&lt;T extends IModsProps&gt; extends Block&lt;T&gt; { block = 'Button'; tag() { return 'button'; } mods() { return { type: this.props.type }; } content() { return ( &lt;Text&gt;{this.props.children}&lt;/Text&gt; ); } } //    Button,    type   link class ButtonLink extends Button&lt;IModsProps&gt; { static mod = ({ type }: any) =&gt; type === 'link'; tag() { return 'a'; } mods() { return { type: this.props.type }; } attrs() { return { href: 'www.yandex.ru' }; } } //   Button  ButtonLink const ButtonView = withMods(Button, ButtonLink); ReactDOM.render( &lt;React.Fragment&gt; &lt;ButtonView type='button'&gt;Click me&lt;/ButtonView&gt; &lt;ButtonView type='link'&gt;Click me&lt;/ButtonView&gt; &lt;/React.Fragment&gt;, document.getElementById('root') );</span></span></code> </pre> <br><p>              ,     . </p><br><p> <code>withMods</code>       ,   (),      .   ,     , withMods        ,      .      .       , ,     ,   ( )   .               .       ,   ,    —    ,    . </p><br><p> ,   : </p><br><ul><li>    . ,        .   ,    TS.        ,      .    ES5 TS   super   ,         . , TS     ,    . </li><li>    . TS  ES6  Babel  ES5.      ,    npm-    .  ,          Babel. </li></ul><br><p>  : </p><br><ul><li>       ,   . ,     . :    DOM-.     HOC,      .   withMods       . </li><li>   (, , )       .             <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SFC</a> . </li><li>  CSS-.  CSS-   JS-     .      ,   ,          . </li></ul><br><p>      v2. </p><br><h2 id="manifest">  </h2><br><p> ,    .   .  ,    ,      1  2.      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . </p><br><p>   —    .   CSS-     HOC,        —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dependency injection</a> . </p><br><p>       React: </p><br><ul><li>   CSS-. </li><li>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> (, ); </li></ul><br><p>         .         .        <code>React.ComponentType</code>     -.         HOC     compose    . </p><br><p>             . </p><br><p>        dependency injection,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>React.ContextAPI</code></a>    .             ,        ,        .        ,      .   DI —  HOC,     .         .     ,  ,         . </p><br><p> ,    ,         .   ,      ,    4 ,    <code>1.5Kb</code> . </p><br><p>     .  Terima kasih kepada mereka yang membaca sampai akhir.     ,     React  . . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438598/">https://habr.com/ru/post/id438598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438588/index.html">Widget googleTranslate khusus untuk situs</a></li>
<li><a href="../id438590/index.html">Guntur di Surga atau Mengapa Anda tidak harus menggunakan FlylinkDC ++</a></li>
<li><a href="../id438592/index.html">Apa yang harus dicari ketika memilih pembaca - kita berbicara tentang faktor bentuk dan tampilan</a></li>
<li><a href="../id438594/index.html">Tempat kerja dan 4k @ 60Hz</a></li>
<li><a href="../id438596/index.html">Menyimpan data pengguna setelah pemuatan ulang halaman</a></li>
<li><a href="../id438600/index.html">SciPy, input dan output dalam MATLAB</a></li>
<li><a href="../id438602/index.html">Kami membongkar protokol pesan pager POCSAG, bagian 1</a></li>
<li><a href="../id438604/index.html">Bitrix dalam banyak Nginx + PHP-FPM, mengatur CNC, serta cache komposit dengan umpan balik melalui nginx. Konfigurasi yang dimodifikasi</a></li>
<li><a href="../id438606/index.html">Degradasi anggun. Laporkan Yandex.Taxi</a></li>
<li><a href="../id438610/index.html">Templat Figma Responsif: Membuat Komponen Desain yang Fleksibel untuk Navigasi Seluler iOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>