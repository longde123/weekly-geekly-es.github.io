<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‰ ğŸ‘ƒ ğŸ™‹ğŸ» Implementasi asli dari perpustakaan ECS ğŸš¸ ğŸ†‘ ğŸ•µğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Minggu ini, saya mulai bekerja pada mesin Vagabond saya dan mulai menerapkan templat entitas-komponen-sistem . 

 Pada artikel ini saya ingin berbicar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementasi asli dari perpustakaan ECS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459288/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c9/fc6/23e/4c9fc623e0787518bde7823317b0e6af.png" alt="gambar"></div><br>  Minggu ini, saya mulai bekerja pada mesin Vagabond saya dan mulai menerapkan templat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">entitas-komponen-sistem</a> . <br><br>  Pada artikel ini saya ingin berbicara tentang implementasi saya, yang tersedia secara bebas di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Tetapi alih-alih hanya mengomentari kode, saya ingin menjelaskan bagaimana strukturnya dirancang.  Oleh karena itu, saya akan mulai dengan implementasi pertama yang saya tulis, menganalisis kekuatan dan kelemahannya, dan kemudian menunjukkan bagaimana saya memperbaikinya.  Pada akhirnya saya akan daftar daftar aspek yang juga dapat ditingkatkan. <br><br><h1>  Pendahuluan </h1><br><h2>  Motivasi </h2><br>  Saya tidak akan berbicara tentang manfaat ECS atas pendekatan berorientasi objek, karena banyak orang sebelum saya telah melakukan ini dengan baik.  Scott Bilas adalah salah satu yang pertama berbicara tentang ECS â€‹â€‹di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20101011021902/">GDC 2002</a> .  Pengantar penting lainnya untuk topik ini termasuk bab Mike West's <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Evolve Your Hierarchy</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Components</a> dari buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Game Programming Patterns</a> Robert Nistrom yang menakjubkan. <br><br>  Singkatnya, saya akan mengatakan bahwa tugas ECS adalah menciptakan pendekatan berorientasi data ke entitas permainan dan pemisahan data dan logika yang nyaman.  Entitas terdiri dari komponen yang berisi data.  Dan sistem yang mengandung proses logika komponen-komponen ini. <br><br>  Jika Anda masuk ke detail, alih-alih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pewarisan</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komposisi</a> digunakan dalam ECS.  Selain itu, pendekatan yang berorientasi pada data ini membuat penggunaan cache lebih baik, yang berarti ini mencapai kinerja yang sangat baik. <br><a name="habracut"></a><br><h2>  Contohnya </h2><br>  Sebelum mempelajari kode, saya ingin menunjukkan kepada Anda apa yang akan kami desain. <br><br>  Menetapkan komponen sangat sederhana: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Position</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Component&lt;Position&gt; { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Velocity</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Component&lt;Velocity&gt; { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; };</code> </pre> <br>  Seperti yang Anda lihat, kami akan menggunakan template <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CRTP</a> . <br><br>  Kemudian, untuk alasan teknis, yang akan saya jelaskan nanti, kita perlu memperbaiki jumlah komponen dan jumlah sistem: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ComponentCount = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> SystemCount = <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br>  Selanjutnya, Anda dapat menentukan sistem yang akan mengambil semua entitas yang memiliki kedua komponen dan memperbarui posisi mereka: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PhysicsSystem</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> System&lt;ComponentCount, SystemCount&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PhysicsSystem(EntityManager&lt;ComponentCount, SystemCount&gt;&amp; entityManager) : mEntityManager(entityManager) { setRequirements&lt;Position, Velocity&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; entity : getManagedEntities()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [position, velocity] = mEntityManager.getComponents&lt;Position, Velocity&gt;(entity); position.x += velocity.x * dt; position.y += velocity.y * dt; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: EntityManager&lt;ComponentCount, SystemCount&gt;&amp; mEntityManager; };</code> </pre> <br>  Sistem hanya menggunakan metode <code>setRequirements</code> untuk <code>setRequirements</code> komponen-komponennya yang <code>setRequirements</code> .  Kemudian, dalam metode <code>update</code> , ini dapat memanggil <code>getManagedEntities</code> untuk secara berulang melintasi semua entitas yang memenuhi persyaratan. <br><br>  Akhirnya, mari kita buat manajer entitas, daftarkan komponen, buat sistem dan beberapa entitas, lalu perbarui posisi mereka menggunakan sistem: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> manager = EntityManager&lt;ComponentCount, SystemCount&gt;(); manager.registerComponent&lt;Position&gt;(); manager.registerComponent&lt;Velocity&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> system = manager.createSystem&lt;PhysicsSystem&gt;(manager); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> entity = manager.createEntity(); manager.addComponent&lt;Position&gt;(entity); manager.addComponent&lt;Velocity&gt;(entity); } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> dt = <span class="hljs-number"><span class="hljs-number">1.0f</span></span> / <span class="hljs-number"><span class="hljs-number">60.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) system-&gt;update(dt);</code> </pre> <br><h3>  Tingkatan yang dicapai </h3><br>  Saya tidak akan berpura-pura membuat perpustakaan ECS terbaik.  Saya hanya ingin menulisnya sendiri.  Selain itu, saya hanya mengerjakannya selama seminggu. <br><br>  Namun, ini bukan alasan untuk membuat sesuatu yang sama sekali tidak efektif.  Jadi mari kita instal tolok ukur: <br><br><ul><li>  Yang pertama akan membuat entitas; </li><li>  Yang kedua akan menggunakan sistem untuk melintasi berulang entitas; </li><li>  Yang terakhir akan membuat dan menghancurkan entitas; </li></ul><br>  Parameter dari semua tolok ukur ini adalah jumlah entitas, jumlah komponen untuk setiap entitas, jumlah maksimum komponen dan jumlah maksimum sistem.  Dengan cara ini, kita bisa melihat seberapa baik skala implementasi kita.  Secara khusus, saya akan menunjukkan hasil untuk tiga profil berbeda: <br><br><ul><li>  Profil A: 32 komponen dan 16 sistem; </li><li>  Profil AA: 128 komponen dan 32 sistem; </li><li>  Profil AAA: 512 komponen dan 64 sistem. </li></ul><br>  Terlepas dari kenyataan bahwa tolok ukur ini akan memberi kita gambaran tentang kualitas implementasi, mereka cukup sederhana.  Misalnya, dalam tolok ukur ini kami hanya menggunakan entitas yang homogen, dan komponennya kecil. <br><br><h1>  Implementasi </h1><br><h2>  Esensi </h2><br>  Dalam implementasi saya, sebuah entitas hanyalah sebuah id: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Entity = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>;</code> </pre> <br>  Selain itu, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Entity.h</a> kita juga akan mendefinisikan <code>Index</code> alias, yang akan berguna nanti: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> InvalidIndex = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;Index&gt;::max();</code> </pre> <br>  Saya memutuskan untuk menggunakan <code>uint32_t</code> bukan tipe 64-bit atau <code>std::size_t</code> untuk menghemat ruang dan meningkatkan optimasi cache.  Kami tidak akan kehilangan begitu banyak: tidak mungkin seseorang akan memiliki miliaran entitas. <br><br><h2>  Komponen </h2><br>  Sekarang mari kita mendefinisikan kelas dasar untuk komponen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(Type); };</code> </pre> <br>  Kelas template sangat sederhana, hanya menyimpan tipe id, yang akan kita gunakan nanti untuk mengindeks struktur data dengan tipe komponen. <br><br>  Parameter templat pertama adalah jenis komponen.  Yang kedua adalah nilai yang dikonversi ke <code>std::size_t</code> , yang akan berfungsi sebagai id jenis komponen. <br><br>  Sebagai contoh, kita dapat mendefinisikan komponen <code>Position</code> sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Positon</span></span></span><span class="hljs-class"> :</span></span> Component&lt;Position, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; };</code> </pre> <br>  Namun, pencacahan mungkin lebih nyaman: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentType</span></span></span><span class="hljs-class"> {</span></span> Position }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Positon</span></span></span><span class="hljs-class"> :</span></span> Component&lt;Position, ComponentType::Position&gt; { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y; };</code> </pre> <br>  Dalam contoh pengantar, hanya ada satu parameter templat: kita tidak perlu menentukan id jenis secara manual.  Nanti kita akan melihat bagaimana memperbaiki struktur dan menghasilkan pengenal tipe secara otomatis. <br><br><h2>  EntityContainer </h2><br>  Kelas <code>EntityContainer</code> akan bertanggung jawab untuk mengelola entitas dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>std::bitset</code></a> untuk masing-masing.  Set bit ini akan menunjukkan komponen yang dimiliki entitas. <br><br>  Karena kita akan menggunakan entitas untuk mengindeks wadah, dan khususnya <code>std::vector</code> , kita perlu id sekecil mungkin dan menggunakan lebih sedikit memori.  Oleh karena itu, kami akan menggunakan kembali id â€‹â€‹entitas yang hancur.  Untuk melakukan ini, id gratis akan disimpan dalam wadah yang disebut <code>mFreeEntities</code> . <br><br>  Ini <code>EntityContainer</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ComponentCount, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SystemCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EntityContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; getEntityToBitset(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&amp; getBitset(Entity entity) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt; mEntityToBitset; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt; mFreeEntities; };</code> </pre> <br>  Mari kita lihat bagaimana metode diimplementasikan. <br><br>  <code>getEntityToBitset</code> dan <code>getBitset</code> adalah getter kecil yang biasa: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; getEntityToBitset() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEntityToBitset; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&amp; getBitset(Entity entity) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEntityToBitset[entity]; }</code> </pre> <br>  Metode <code>create</code> lebih menarik: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> entity = Entity(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mFreeEntities.empty()) { entity = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Entity&gt;(mEntityToBitset.size()); mEntityToBitset.emplace_back(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { entity = mFreeEntities.back(); mFreeEntities.pop_back(); mEntityToBitset[entity].reset(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entity; }</code> </pre> <br>  Jika ada entitas bebas, ia menggunakannya kembali.  Kalau tidak, metode menciptakan entitas baru. <br><br>  Metode <code>remove</code> cukup menambahkan entitas yang akan dihapus di <code>mFreeEntities</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ mFreeEntities.push_back(entity); }</code> </pre> <br>  Metode terakhir adalah <code>reserve</code> .  Tugasnya adalah untuk menyimpan memori untuk berbagai wadah.  Seperti yang kita ketahui, mengalokasikan memori adalah operasi yang mahal, jadi jika kira-kira kita mengetahui jumlah entitas masa depan dalam game, maka memori cadangan akan mempercepat pekerjaan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ mFreeEntities.resize(size); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::iota(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(mFreeEntities), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(mFreeEntities), <span class="hljs-number"><span class="hljs-number">0</span></span>); mEntityToBitset.resize(size); }</code> </pre> <br>  Selain cadangan memori sederhana, ini juga mengisi <code>mFreeEntities</code> . <br><br><h2>  ComponentContainer </h2><br>  Kelas <code>ComponentContainer</code> akan bertanggung jawab untuk menyimpan semua komponen dari tipe yang ditentukan. <br><br>  Dalam arsitektur saya, semua komponen dari tipe tertentu disimpan bersama.  Artinya, ada satu array besar untuk setiap jenis komponen, yang disebut <code>mComponents</code> . <br><br>  Selain itu, untuk dapat menambah, menerima atau menghapus komponen dari suatu entitas dalam waktu yang konstan, kita memerlukan cara untuk berpindah dari suatu entitas ke suatu komponen dan dari komponen ke entitas.  Untuk melakukan ini, kita memerlukan dua struktur data lagi yang disebut <code>mComponentToEntity</code> dan <code>mEntityToComponent</code> . <br><br>  Berikut ini adalah deklarasi <code>ComponentContainer</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ComponentCount, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SystemCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentContainer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BaseComponentContainer { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ComponentContainer(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; entityToBitset); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, Args&amp;&amp;... args)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryRemove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; component)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; mComponents; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt; mComponentToEntity; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;Entity, Index&gt; mEntityToComponent; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; mEntityToBitset; };</code> </pre> <br>  Anda dapat melihat bahwa itu mewarisi dari <code>BaseComponentContainer</code> , yang ditetapkan seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseComponentContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~BaseComponentContainer() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryRemove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br>  Satu-satunya tujuan kelas dasar ini adalah untuk dapat menyimpan semua instance dari <code>ComponentContainer</code> dalam sebuah wadah. <br><br>  Sekarang mari kita lihat definisi metode. <br><br>  Pertama, pertimbangkan konstruktor: itu mendapatkan referensi ke wadah yang berisi set bit entitas.  Kelas ini akan menggunakannya untuk memeriksa keberadaan komponen dalam suatu entitas dan untuk memperbarui sekumpulan bit entitas ketika menambah atau menghapus komponen: <br><br><pre> <code class="cpp hljs">ComponentContainer(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;&gt;&amp; entityToBitset) : mEntityToBitset(entityToBitset) { }</code> </pre> <br>  Metode <code>get</code> sederhana, kami hanya menggunakan <code>mEntityToComponent</code> untuk menemukan indeks komponen entitas di <code>mComponents</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mComponents[mEntityToComponent[entity]]; }</code> </pre> <br>  Metode <code>add</code> menggunakan argumennya untuk menyisipkan komponen baru di akhir <code>mComponents</code> , dan kemudian menyiapkan tautan untuk berpindah dari entitas ke komponen dan dari komponen ke entitas.  Pada akhirnya, ini menetapkan bit <code>entity</code> bit yang cocok dengan komponen menjadi <code>true</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Index&gt;(mComponents.size()); mComponents.emplace_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); mComponentToEntity.emplace_back(entity); mEntityToComponent[entity] = index; mEntityToBitset[entity][T::type] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Metode <code>remove</code> menetapkan komponen bit yang sesuai ke <code>false</code> , dan kemudian memindahkan komponen <code>mComponents</code> terakhir pada indeks yang ingin kita hapus.  Ini memperbarui tautan ke komponen yang baru saja kami pindah, dan menghapus salah satu komponen yang ingin kami hancurkan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ mEntityToBitset[entity][T::type] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> index = mEntityToComponent[entity]; <span class="hljs-comment"><span class="hljs-comment">// Update mComponents mComponents[index] = std::move(mComponents.back()); mComponents.pop_back(); // Update mEntityToComponent mEntityToComponent[mComponentToEntity.back()] = index; mEntityToComponent.erase(entity); // Update mComponentToEntity mComponentToEntity[index] = mComponentToEntity.back(); mComponentToEntity.pop_back(); }</span></span></code> </pre> <br>  Kita dapat melakukan pergerakan waktu konstan dengan memindahkan komponen terakhir pada indeks yang ingin kita hancurkan.  Dan pada kenyataannya, maka kita hanya perlu menghapus komponen terakhir, yang dapat dilakukan dalam <code>std::vector</code> dalam waktu yang konstan. <br><br>  Metode <code>tryRemove</code> memeriksa untuk melihat apakah suatu entitas memiliki komponen sebelum mencoba untuk menghapusnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryRemove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mEntityToBitset[entity][T::type]) { remove(entity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Metode <code>getOwner</code> mengembalikan entitas yang memiliki komponen, untuk ini ia menggunakan pointer aritmatika dan <code>mComponentToEntity</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; component)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> begin = mComponents.data(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(&amp;component - begin); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mComponentToEntity[index]; }</code> </pre> <br>  Metode terakhir adalah <code>reserve</code> , ia memiliki tujuan yang sama dengan metode serupa di <code>EntityContainer</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> override </span></span>{ mComponents.reserve(size); mComponentToEntity.reserve(size); mEntityToComponent.reserve(size); }</code> </pre> <br><h2>  Sistem </h2><br>  Sekarang mari kita lihat kelas <code>System</code> . <br><br>  Setiap sistem memiliki satu set bit <code>mRequirements</code> yang menjelaskan komponen yang dibutuhkannya.  Selain itu, ia menyimpan satu set entitas <code>mManagedEntities</code> yang memenuhi persyaratan ini.  Saya ulangi, agar dapat mengimplementasikan semua operasi dalam waktu yang konstan, kita perlu cara untuk berpindah dari suatu entitas ke indeksnya di <code>mManagedEntities</code> .  Untuk melakukan ini, kita akan menggunakan <code>std::unordered_map</code> disebut <code>mEntityToManagedEntity</code> . <br><br>  Seperti apa deklarasi <code>System</code> itu: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ComponentCount, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SystemCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">System</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~System() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRequirements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt;&amp; getManagedEntities() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onManagedEntityAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([[maybe_unused]] Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onManagedEntityRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([[maybe_unused]] Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> EntityManager&lt;ComponentCount, SystemCount&gt;; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt; mRequirements; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mType; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt; mManagedEntities; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;Entity, Index&gt; mEntityToManagedEntity; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEntityUpdated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">bitset</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;ComponentCount&gt;&amp; components)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEntityRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; };</code> </pre> <br>  <code>setRequirements</code> menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekspresi konvolusi</a> untuk menetapkan nilai bit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRequirements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ (mRequirements.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(Ts::type), ...); }</code> </pre> <br>  <code>getManagedEntities</code> adalah pengambil yang akan digunakan oleh kelas yang dihasilkan untuk mengakses entitas yang sedang diproses: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Entity&gt;&amp; getManagedEntities() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mManagedEntities; }</code> </pre> <br>  Ini mengembalikan referensi konstan sehingga kelas yang dihasilkan tidak berusaha untuk memodifikasi <code>mManagedEntities</code> . <br><br>  <code>onManagedEntityAdded</code> dan <code>onManagedEntityRemoved</code> kosong.  Mereka akan didefinisikan ulang nanti.  Metode ini akan dipanggil ketika menambahkan entitas ke <code>mManagedEntities</code> atau menghapusnya. <br><br>  Metode berikut akan bersifat pribadi dan hanya dapat diakses dari <code>EntityManager</code> , yang dinyatakan sebagai kelas ramah. <br><br>  <code>setUp</code> akan dipanggil oleh manajer entitas untuk menetapkan id ke sistem.  Kemudian dapat menggunakannya untuk mengindeks array: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span><span class="hljs-function"> </span></span>{ mType = type; }</code> </pre> <br>  <code>onEntityUpdated</code> dipanggil saat entitas berubah, mis.  saat menambah atau menghapus komponen.  Sistem memeriksa apakah persyaratan terpenuhi dan apakah entitas sudah diproses.  Jika memenuhi persyaratan dan belum diproses, maka sistem menambahkannya.  Namun, jika entitas tidak memenuhi persyaratan dan telah diproses, maka sistem akan menghapusnya.  Dalam semua kasus lain, sistem tidak melakukan apa-apa: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEntityUpdated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">bitset</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;ComponentCount&gt;&amp; components)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> satisfied = (mRequirements &amp; components) == mRequirements; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> managed = mEntityToManagedEntity.find(entity) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(mEntityToManagedEntity); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (satisfied &amp;&amp; !managed) addEntity(entity); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!satisfied &amp;&amp; managed) removeEntity(entity); }</code> </pre> <br>  <code>onEntityRemoved</code> dipanggil oleh manajer entitas ketika entitas dihapus.  Jika entitas diproses oleh sistem, ia menghapusnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onEntityRemoved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mEntityToManagedEntity.find(entity) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(mEntityToManagedEntity)) removeEntity(entity); }</code> </pre> <br>  <code>addEntity</code> dan <code>removeEntity</code> hanyalah metode pembantu. <br><br>  <code>addEntity</code> menetapkan tautan untuk pergi dari entitas yang ditambahkan dengan indeksnya di <code>mManagedEntities</code> , menambahkan entitas, dan panggilan <code>onManagedEntityAdded</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ mEntityToManagedEntity[entity] = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Index&gt;(mManagedEntities.size()); mManagedEntities.emplace_back(entity); onManagedEntityAdded(entity); }</code> </pre> <br>  <code>removeEntity</code> panggilan pertama <code>onManagedEntityRemoved</code> .  Kemudian memindahkan entitas yang diproses terakhir pada indeks yang sedang dihapus.  Ini memperbarui referensi ke entitas yang dipindahkan.  Pada akhirnya, itu menghapus entitas yang akan dihapus dari <code>mManagedEntities</code> dan <code>mEntityToManagedEntity</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ onManagedEntityRemoved(entity); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> index = mEntityToManagedEntity[entity]; mEntityToManagedEntity[mManagedEntities.back()] = index; mEntityToManagedEntity.erase(entity); mManagedEntities[index] = mManagedEntities.back(); mManagedEntities.pop_back(); }</code> </pre> <br><h2>  Manajer Entitas </h2><br>  Semua logika penting ada di kelas lain.  Seorang manajer entitas hanya mengikat semuanya. <br><br>  Mari kita lihat iklannya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ComponentCount, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> SystemCount&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EntityManager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createSystem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args&amp;&amp; ...args)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasComponents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts&amp;...&gt; getComponents(Entity entity); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ts&amp;...&gt; getComponents(Entity entity) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, Args&amp;&amp;... args)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; component)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;BaseComponentContainer&gt;, ComponentCount&gt; mComponentContainers; EntityContainer&lt;ComponentCount, SystemCount&gt; mEntities; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;System&lt;ComponentCount, SystemCount&gt;&gt;&gt; mSystems; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkComponentType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkComponentTypes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponentContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponentContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre> <br>  Kelas <code>EntityManager</code> memiliki tiga variabel anggota: <code>mComponentContainers</code> , yang menyimpan <code>std::unique_ptr</code> ke <code>BaseComponentContainer</code> , <code>mEntities</code> , yang merupakan turunan dari <code>EntityContainer</code> dan <code>mSystems</code> , yang menyimpan pointer <code>unique_ptr</code> ke <code>System</code> . <br><br>  Kelas memiliki banyak metode, tetapi sebenarnya semuanya sangat sederhana. <br><br>  Pertama-tama mari kita lihat <code>getComponentContainer</code> , yang mengembalikan pointer ke kontainer komponen yang memproses komponen tipe <code>T</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponentContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;ComponentContainer&lt;T, ComponentCount, SystemCount&gt;*&gt;(mComponentContainers[T::type].get()); }</code> </pre> <br>  Fungsi pembantu lainnya adalah <code>checkComponentType</code> , yang hanya memeriksa bahwa id jenis komponen di bawah jumlah maksimum komponen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkComponentType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(T::type &lt; ComponentCount); }</code> </pre> <br>  <code>checkComponentTypes</code> menggunakan ekspresi konvolusi untuk melakukan beberapa jenis pemeriksaan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkComponentTypes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ (checkComponentType&lt;Ts&gt;(), ...); }</code> </pre> <br>  <code>registerComponent</code> membuat wadah baru komponen dari tipe yang ditentukan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); mComponentContainers[T::type] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;ComponentContainer&lt;T, ComponentCount, SystemCount&gt;&gt;( mEntities.getEntityToBitset()); }</code> </pre> <br>  <code>createSystem</code> membuat sistem baru dari tipe yang ditentukan dan menetapkan tipenya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Args&gt; <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createSystem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Args&amp;&amp; ...args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> type = mSystems.size(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; system = mSystems.emplace_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;T&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...)); system-&gt;setUp(type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(system.get()); }</code> </pre> <br>  Metode <code>reserve</code> memanggil metode <code>reserve</code> <code>EntityContainer</code> <code>ComponentContainer</code> dan <code>EntityContainer</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); i &lt; ComponentCount; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mComponentContainers[i]) mComponentContainers[i]-&gt;reserve(size); } mEntities.reserve(size); }</code> </pre> <br>  Metode <code>createEntity</code> mengembalikan hasil dari metode <code>create</code> dari manajer <code>EntityManager</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEntities.create(); }</code> </pre> <br>  <code>hasComponent</code> menggunakan satu set bit entitas untuk dengan cepat memverifikasi bahwa entitas ini memiliki komponen dari tipe yang ditentukan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEntities.getBitset(entity)[T::type]; }</code> </pre> <br>  <code>hasComponents</code> menggunakan ekspresi konvolusi untuk membuat satu set bit yang menunjukkan komponen yang diperlukan, dan kemudian menggunakannya dengan seperangkat bit entitas untuk memeriksa apakah entitas memiliki semua komponen yang diperlukan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasComponents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ checkComponentTypes&lt;Ts...&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> requirements = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">bitset</span></span>&lt;ComponentCount&gt;(); (requirements.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(Ts::type), ...); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (requirements &amp; mEntities.getBitset(entity)) == requirements; }</code> </pre> <br>  <code>getComponent</code> mengalihkan permintaan ke wadah komponen yang diperlukan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity)</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getComponentContainer&lt;T&gt;()-&gt;get(entity); }</code> </pre> <br>  <code>getComponents</code> mengembalikan tupel tautan ke komponen yang diminta.  Untuk melakukan ini, ia menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>std::tie</code></a> dan ekspresi konvolusi: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ...Ts&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Ts&amp;...&gt; getComponents(Entity entity) { checkComponentTypes&lt;Ts...&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie(getComponentContainer&lt;Ts&gt;()-&gt;get(entity)...); }</code> </pre> <br>  <code>addComponent</code> dan <code>removeComponent</code> mengalihkan permintaan ke wadah komponen yang diperlukan, dan kemudian memanggil <code>onEntityUpdated</code> sistem <code>onEntityUpdated</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Entity entity, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); getComponentContainer&lt;T&gt;()-&gt;add(entity, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Args&gt;(args)...); <span class="hljs-comment"><span class="hljs-comment">// Send message to systems const auto&amp; bitset = mEntities.getBitset(entity); for (auto&amp; system : mSystems) system-&gt;onEntityUpdated(entity, bitset); } template&lt;typename T&gt; void removeComponent(Entity entity) { checkComponentType&lt;T&gt;(); getComponentContainer&lt;T&gt;()-&gt;remove(entity); // Send message to systems const auto&amp; bitset = mEntities.getBitset(entity); for (auto&amp; system : mSystems) system-&gt;onEntityUpdated(entity, bitset); }</span></span></code> </pre> <br>  Akhirnya, <code>getOwner</code> mengalihkan permintaan ke komponen kontainer yang diperlukan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">Entity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; component)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ checkComponentType&lt;T&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getComponentContainer&lt;T&gt;()-&gt;getOwner(component); }</code> </pre> <br>  Itu implementasi pertama saya.  Ini terdiri dari hanya 357 baris kode.  Semua kode dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utas</a> ini. <br><br><h1>  Pembuatan profil dan tolok ukur </h1><br><h2>  Tingkatan yang dicapai </h2><br>  Sekarang adalah waktu untuk membandingkan implementasi ECS pertama saya! <br><br>  Inilah hasilnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c9/fc6/23e/4c9fc623e0787518bde7823317b0e6af.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/323/9a9/bb03239a90cccf5f95ab47ecf94e3a4d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/679/e54/f0e/679e54f0e32260a9f62621838b51a15e.png"></div><br>  Templat berskala cukup baik!  Jumlah yang diproses per detik kira-kira sama ketika meningkatkan jumlah entitas dan mengubah profil (A, AA dan AAA). <br><br>  Selain itu, ini berskala baik dengan peningkatan jumlah komponen dalam entitas.  Ketika kita beralih melalui entitas dengan tiga komponen, mereka terjadi tiga kali lebih lambat daripada iterasi melalui entitas dengan satu komponen.  Ini diharapkan karena kita perlu mendapatkan tiga komponen. <br><br><h2>  Tembolok merindukan </h2><br>  Untuk memeriksa jumlah cache yang hilang, saya menjalankan contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cachegrind yang</a> diambil <a href="">dari sini</a> . <br><br>  Inilah hasil untuk 10.000 entitas: <br><br> <code>==1652== D refs: 277,577,353 (254,775,159 rd + 22,802,194 wr) <br> ==1652== D1 misses: 20,814,368 ( 20,759,914 rd + 54,454 wr) <br> ==1652== LLd misses: 43,483 ( 7,847 rd + 35,636 wr) <br> ==1652== D1 miss rate: 7.5% ( 8.1% + 0.2% ) <br> ==1652== LLd miss rate: 0.0% ( 0.0% + 0.2% )</code> <br> <br>  Ini adalah hasil untuk 100.000 entitas: <br><br> <code>==1738== D refs: 2,762,879,670 (2,539,368,564 rd + 223,511,106 wr) <br> ==1738== D1 misses: 207,415,181 ( 206,902,072 rd + 513,109 wr) <br> ==1738== LLd misses: 207,274,328 ( 206,789,289 rd + 485,039 wr) <br> ==1738== D1 miss rate: 7.5% ( 8.1% + 0.2% ) <br> ==1738== LLd miss rate: 7.5% ( 8.1% + 0.2% )</code> <br> <br>  Hasilnya cukup bagus.  Hanya sedikit aneh mengapa ada begitu banyak LLD yang hilang pada 100.000 entitas. <br><br><h2>  Pembuatan profil </h2><br>  Untuk memahami bagian mana dari implementasi saat ini yang membutuhkan waktu lebih lama, saya membuat profil contoh dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gprof</a> . <br><br>  Inilah hasilnya: <br><br> <code>Flat profile: <br> <br> Each sample counts as 0.01 seconds. <br> % cumulative self self total <br> time seconds seconds calls ms/call ms/call name <br> 57.45 1.16 1.16 200300000 0.00 0.00 std::__detail::_Map_base&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt;, true&gt;::operator[](unsigned int const&amp;) <br> 19.31 1.55 0.39 main <br> 16.34 1.88 0.33 200500000 0.00 0.00 std::_Hashtable&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt; &gt;::_M_find_before_node(unsigned long, unsigned int const&amp;, unsigned long) const <br> 3.96 1.96 0.08 300000 0.00 0.00 std::_Hashtable&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt; &gt;::_M_insert_unique_node(unsigned long, unsigned long, std::__detail::_Hash_node&lt;std::pair&lt;unsigned int const, unsigned int&gt;, false&gt;*) <br> 2.48 2.01 0.05 300000 0.00 0.00 unsigned int&amp; std::vector&lt;unsigned int, std::allocator&lt;unsigned int&gt; &gt;::emplace_back&lt;unsigned int&amp;&gt;(unsigned int&amp;) <br> 0.50 2.02 0.01 3 3.33 3.33 std::_Hashtable&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt; &gt;::~_Hashtable() <br> 0.00 2.02 0.00 200000 0.00 0.00 std::_Hashtable&lt;unsigned int, std::pair&lt;unsigned int const, unsigned int&gt;, std::allocator&lt;std::pair&lt;unsigned int const, unsigned int&gt; &gt;, std::__detail::_Select1st, std::equal_to&lt;unsigned int&gt;, std::hash&lt;unsigned int&gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits&lt;false, false, true&gt; &gt;::find(unsigned int const&amp;)</code> <br> <br>  Hasilnya mungkin sedikit terdistorsi karena saya dikompilasi dengan flag <code>-O1</code> gprof <code>-O1</code> sesuatu yang bermakna.  Tampaknya ketika tingkat optimasi ditingkatkan, kompiler mulai secara agresif menanamkan semuanya dan gprof mengatakan hampir tidak ada. <br><br>  Menurut gprof, hambatan yang jelas dalam implementasi ini adalah <code>std::unordered_map</code> .  Jika kita ingin mengoptimalkannya, maka ada baiknya mencoba menyingkirkannya. <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perbandingan dengan </font></font><code>std::map</code> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya menjadi penasaran tentang perbedaan kinerja antara </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jadi saya mengubah kode semua </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada </font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Implementasi ini tersedia di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini.</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berikut adalah hasil benchmark:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/611/50b/3da/61150b3da1ec1cf850a0ed5b761f03a1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/136/3be/951/1363be95163a3dfb2ab968c1591c7c60.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d08/b4b/7f1/d08b4b7f1b5b35531bdc32a614ccbb81.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita bisa melihat bahwa kali ini implementasinya tidak skala dengan baik dengan peningkatan jumlah entitas. </font><font style="vertical-align: inherit;">Dan bahkan dengan 1000 entitas, iterasi dua kali lebih lambat dari versi c </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h1>  Kesimpulan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami telah membuat pustaka yang sederhana namun sudah praktis dari templat entitas-komponen-sistem. </font><font style="vertical-align: inherit;">Di masa depan, kami akan menggunakannya sebagai landasan untuk peningkatan dan optimalisasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian selanjutnya, kami akan menunjukkan cara meningkatkan produktivitas dengan mengganti </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Selain itu, kami akan menunjukkan cara menetapkan tipe id secara otomatis ke komponen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengganti std :: unordered_map dengan std :: vector </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang kita lihat, mereka </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah hambatan dalam implementasi kami. </font><font style="vertical-align: inherit;">Oleh karena itu, alih-alih </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita gunakan </font></font><code>mEntityToComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk </font></font><code>ComponentContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan dalam </font></font><code>mEntityToManagedEntity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk </font></font><code>System</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vektor </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perubahan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perubahannya akan sangat sederhana, Anda bisa melihatnya di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu-satunya kehalusan terletak pada kenyataan bahwa </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam </font></font><code>mEntityToComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>mEntityToManagedEntity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">telah cukup lama untuk indeks setiap entitas. </font><font style="vertical-align: inherit;">Untuk melakukan cara sederhana ini, saya memutuskan untuk menyimpan ini </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di </font></font><code>EntityContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, di mana kita tahu entitas maksimum id. </font><font style="vertical-align: inherit;">Lalu saya meneruskan vektor ke </font></font><code>vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wadah komponen dengan referensi atau pointer di manajer entitas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode yang dimodifikasi dapat ditemukan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ini </font><font style="vertical-align: inherit;">.</font></font><br><br><h2>  Hasil </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mari kita periksa bagaimana versi ini bekerja lebih baik daripada versi sebelumnya: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38a/1df/4bd/38a1df4bd3c8110d3873588854ffc314.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/897/2ae/0f58972ae408b9726899597fbd774be1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22b/3f5/fcd/22b3f5fcd21c8285cc779f46ca3896a4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, membuat dan menghapus dengan sejumlah besar komponen dan sistem menjadi sedikit </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lebih lambat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, iterasi telah menjadi jauh lebih cepat, hampir sepuluh kali lipat! </font><font style="vertical-align: inherit;">Dan itu bersisik dengan sangat baik. </font><font style="vertical-align: inherit;">Percepatan ini sangat melebihi perlambatan kreasi dan penghapusan. </font><font style="vertical-align: inherit;">Dan ini logis: iterasi entitas akan terjadi berkali-kali, tetapi dibuat dan dihapus hanya sekali. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang mari kita lihat apakah ini mengurangi jumlah cache yang hilang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut ini adalah output dari cachegrind dengan 10.000 entitas: </font><font style="vertical-align: inherit;">Dan di sini adalah output untuk 100.000 entitas: </font><font style="vertical-align: inherit;">Kami melihat bahwa versi ini menciptakan sekitar tiga kali lebih sedikit tautan dan empat kali lebih sedikit kehilangan cache.</font></font><br><br> <code>==1374== D refs: 94,563,949 (72,082,880 rd + 22,481,069 wr) <br> ==1374== D1 misses: 4,813,780 ( 4,417,702 rd + 396,078 wr) <br> ==1374== LLd misses: 378,905 ( 9,626 rd + 369,279 wr) <br> ==1374== D1 miss rate: 5.1% ( 6.1% + 1.8% ) <br> ==1374== LLd miss rate: 0.4% ( 0.0% + 1.6% )</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>==1307== D refs: 938,405,796 (715,424,940 rd + 222,980,856 wr) <br> ==1307== D1 misses: 51,034,738 ( 44,045,090 rd + 6,989,648 wr) <br> ==1307== LLd misses: 5,866,508 ( 1,997,948 rd + 3,868,560 wr) <br> ==1307== D1 miss rate: 5.4% ( 6.2% + 3.1% ) <br> ==1307== LLd miss rate: 0.6% ( 0.3% + 1.7% )</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jenis Otomatis </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perbaikan terakhir yang akan saya bicarakan adalah pembuatan pengenal tipe komponen otomatis. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perubahan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua perubahan untuk menerapkan pembuatan otomatis tipe id dapat ditemukan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk, agar dapat menetapkan satu id unik untuk setiap jenis komponen, Anda perlu menggunakan CRTP dan fungsi dengan penghitung statis:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> type; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> generateComponentType() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> counter = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Component&lt;T&gt;::type = generateComponentType();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda mungkin memperhatikan bahwa id jenis sekarang dihasilkan saat runtime, dan sebelumnya dikenal pada waktu kompilasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode setelah perubahan dapat ditemukan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ini </font><font style="vertical-align: inherit;">.</font></font><br><br><h2>  Hasil </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk menguji kinerja versi ini, saya melakukan benchmark: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bd/112/0da/7bd1120da37daac5e3ef48446776b6e7.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/234/f2f/937/234f2f9377a0f3ad8ea231f91e335ddf.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/101/4f2/ade/1014f2adebd6156bc48c9b6fe5670b43.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk pembuatan dan penghapusan, hasilnya tetap sama. </font><font style="vertical-align: inherit;">Namun, Anda dapat melihat bahwa iterasi telah menjadi sedikit lebih lambat, sekitar 10%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlambatan ini dapat dijelaskan oleh fakta bahwa kompiler digunakan untuk mengetahui pengenal jenis pada waktu kompilasi, yang berarti dapat lebih mengoptimalkan kode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penugasan manual tipe id agak tidak nyaman dan dapat menyebabkan kesalahan. </font><font style="vertical-align: inherit;">Jadi, bahkan jika kita sedikit mengurangi kinerja, itu masih merupakan peningkatan dalam kegunaan perpustakaan ECS kami.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gagasan untuk Perbaikan Lebih Lanjut </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum mengakhiri artikel ini, saya ingin berbagi dengan Anda ide untuk peningkatan lainnya. </font><font style="vertical-align: inherit;">Sejauh ini saya belum mengimplementasikannya, tapi mungkin saya akan melakukannya di masa depan.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jumlah komponen dan sistem yang dinamis </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sangat tidak nyaman untuk menunjukkan terlebih dahulu jumlah maksimum komponen dan sistem dalam bentuk parameter templat. </font><font style="vertical-align: inherit;">Saya pikir itu akan mungkin untuk menggantikan </font></font><code>std::array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di </font></font><code>EntityManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atas </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tanpa penurunan kinerja yang kuat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, itu </font></font><code>std::bitset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membutuhkan mengetahui jumlah bit pada waktu kompilasi. </font><font style="vertical-align: inherit;">Sementara saya pikir memperbaiki masalah ini dengan mengganti </font></font><code>std::vector&lt;bitset&lt;ComponentCount&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di </font></font><code>EntityContainer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atas </font></font><code>std::vector&lt;char&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan melepaskan dalam jumlah yang memadai byte untuk mewakili set bit semua entitas. </font><font style="vertical-align: inherit;">Kemudian kami menerapkan kelas ringan </font></font><code>BitsetView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menerima input sepasang pointer ke awal dan akhir set bit, dan kemudian melakukan semua operasi yang diperlukan dengan </font></font><code>std::bitset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam rentang memori ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gagasan lain: jangan gunakan set bit lagi dan cukup periksa untuk </font></font><code>mEntityToComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melihat apakah entitas memiliki komponen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iterasi komponen yang disederhanakan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saat ini, jika sistem ingin mengulangi komponen entitas yang diolahnya secara iteratif, kita perlu melakukannya seperti ini: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; entity : getManagedEntities()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [position, velocity] = mEntityManager.getComponents&lt;Position, Velocity&gt;(entity); ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akan lebih cantik dan sederhana jika kita bisa melakukan sesuatu seperti ini: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [position, velocity] : mEntityManager.getComponents&lt;Position, Velocity&gt;(mManagedEntities)) { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menerapkannya akan lebih mudah daripada menggunakan </font></font><code>std::view::transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rentang perpustakaan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, belum ada di sana. </font><font style="vertical-align: inherit;">Saya bisa menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perpustakaan rentang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eric Nibler, tapi saya tidak ingin menambahkan dependensi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusinya bisa dengan mengimplementasikan kelas </font></font><code>EntityRangeView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang akan menerima jenis komponen yang perlu diterima sebagai parameter templat, dan referensi </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entitas </font><font style="vertical-align: inherit;">sebagai parameter konstruktor </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Maka kita akan memiliki hanya untuk menyadari </font></font><code>begin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>end</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan jenis iterator untuk mencapai perilaku yang diinginkan. </font><font style="vertical-align: inherit;">Ini tidak terlalu sulit, tetapi sedikit memakan waktu untuk menulis.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimalisasi Manajemen Acara </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam implementasi saat ini, ketika menambah atau menghapus komponen dari suatu entitas, kami memanggil </font></font><code>onEntityUpdated</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semua sistem. </font><font style="vertical-align: inherit;">Ini agak tidak efisien karena banyak sistem tidak tertarik pada jenis komponen yang baru saja diubah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk meminimalkan kerusakan, kita dapat menyimpan pointer ke sistem yang tertarik pada tipe komponen yang ditentukan dalam struktur data, misalnya </font></font><code>std::array&lt;std::vector&lt;System&lt;ComponentCount, SystemCount&gt;&gt;, ComponentCount&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kemudian, ketika menambah atau menghapus komponen, kita cukup memanggil metode </font></font><code>onEntityUpdated</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistem yang tertarik pada komponen ini.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Himpunan bagian entitas yang dikelola oleh manajer entitas alih-alih sistem </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ide terakhir saya akan mengarah pada perubahan yang lebih luas dalam struktur perpustakaan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih sistem yang mengelola set entitas mereka, manajer entitas akan melakukan ini. Keuntungan dari skema semacam itu adalah bahwa jika dua sistem tertarik pada satu set komponen, kami tidak menduplikasi subset entitas yang memenuhi persyaratan ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistem dapat dengan mudah menyatakan persyaratannya kepada manajer entitas. Kemudian manajer entitas akan menyimpan semua subset entitas yang berbeda. Akhirnya, sistem akan meminta entitas menggunakan sintaksis yang serupa:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; entity : mEntityManager.getEntitiesWith&lt;Position, Velocity&gt;()) { ... }</code> </pre> <br><h1>  Kesimpulan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini, ini adalah akhir dari sebuah artikel tentang implementasi sistem entitas-komponen saya. </font><font style="vertical-align: inherit;">Jika saya melakukan perbaikan lain, saya mungkin akan menulis artikel baru di masa depan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi yang dijelaskan dalam artikel ini cukup sederhana: terdiri dari kurang dari 500 baris kode, dan juga memiliki kinerja yang baik. </font><font style="vertical-align: inherit;">Semua transaksi direalisasi untuk waktu yang konstan (diamortisasi). </font><font style="vertical-align: inherit;">Selain itu, dalam praktiknya, ia menggunakan cache secara optimal dan sangat cepat menerima dan mengembalikan entitas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya harap artikel ini menarik atau bahkan bermanfaat bagi Anda.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bacaan tambahan </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berikut adalah beberapa sumber daya yang berguna untuk studi yang lebih mendalam tentang pola entitas-komponen-sistem: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Michelle Kayney, penulis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , menulis serangkaian artikel yang sangat menarik tentang entitas-komponen-sistem yang disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS bolak-balik</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entity Systems Wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berisi informasi dan tautan yang sangat berguna.</font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459288/">https://habr.com/ru/post/id459288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459274/index.html">Kerentanan Kunci Layar di Astra Linux Edisi Khusus (Smolensk)</a></li>
<li><a href="../id459276/index.html">Epic fail resistance 2 atau mengapa Anda tidak boleh terlibat dalam privasi dengan plugin FireFox</a></li>
<li><a href="../id459280/index.html">Mengapa pengembang suka membangun aplikasi asli?</a></li>
<li><a href="../id459284/index.html">Pengantar Singkat Strategi Produk Dan Prioritas Fitur</a></li>
<li><a href="../id459286/index.html">Telluride tungsten semi-logam - pisau Swiss untuk zaman nanoteknologi</a></li>
<li><a href="../id459292/index.html">Otomasi Uji Aplikasi Seluler: Perbandingan Alat</a></li>
<li><a href="../id459294/index.html">Apa yang lebih penting: untuk mengetahui bahasa pemrograman atau untuk dapat memecahkan masalah bisnis?</a></li>
<li><a href="../id459296/index.html">Harga JavaScript 2019</a></li>
<li><a href="../id459298/index.html">Sudut: status pada 2019</a></li>
<li><a href="../id459300/index.html">Quasar 1.0: alat berguna baru untuk pengembang Vue dan tidak hanya untuk mereka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>