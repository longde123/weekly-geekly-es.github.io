<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏩 🚛 🧞 Peluncuran Predator - Repositori Data Terkompilasi 👩🏽‍🚀 🤱🏼 🍿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini, tim Micronaut di Object Computing Inc (OCI) memperkenalkan Predator , sebuah proyek open source baru yang tujuannya adalah untuk secara sign...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Peluncuran Predator - Repositori Data Terkompilasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460839/"><p><img src="https://habrastorage.org/webt/zy/lo/n1/zylon1nrzso3rt7yshzjaia3krg.jpeg"></p><br><p>  Hari ini, tim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Micronaut</a> di Object Computing Inc (OCI) memperkenalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Predator</a> , sebuah proyek open source baru yang tujuannya adalah untuk secara signifikan meningkatkan runtime dan kinerja (dari memori) akses data untuk layanan-layanan microser dan serverless, tanpa kehilangan produktivitas dibandingkan dengan alat seperti GORM dan Spring Data. </p><a name="habracut"></a><br>
<h2 id="istoriya-instrumentov-dostupa-k-dannym">  Riwayat Alat Akses Data </h2><br><p>  Kita bisa melacak sejarah templat repositori data sejak 2004, ketika Ruby on Rails keluar dengan subsistem ActiveRecord, sebuah API yang merevolusi pemahaman kita tentang akses data dalam hal produktivitas pengembang. </p><br><p>  Pada 2007, tim Grails pertama kali memperkenalkan API seperti ActiveRecord untuk JVM - GORM (bagian dari Grails).  GORM mengandalkan sifat dinamis Groovy untuk menerapkan metode pencarian di atas Hibernate dan memberikan manfaat produktivitas yang sama kepada pengguna JVM. </p><br><p> Karena GORM bergantung pada bahasa Groovy, proyek Data Spring dibuat pada 2011 yang memungkinkan pengembang Java untuk menentukan metode pencarian, seperti <code>findByTitle</code> , di antarmuka, dan secara otomatis menerapkan logika kueri saat runtime. </p><br><h2 id="kak-rabotayut-instrumenty-dostupa-k-dannym">  Cara kerja alat akses data </h2><br><p>  Semua implementasi yang disebutkan menggunakan templat yang sama, yaitu untuk membangun metamodel entitas proyek pada saat run time yang memodelkan hubungan antara kelas entitas Anda.  Di Spring Data, ini adalah MappingContext, dan dalam GORM juga disebut MappingContext.  Mereka dibangun dengan memindai kelas menggunakan refleksi.  (Kesamaan dalam penamaan tidak disengaja di sini. Pada 2010, saya bekerja dengan tim Data Spring untuk mencoba menciptakan GORM untuk Java, pada proyek yang akhirnya berubah menjadi apa yang disebut Data Musim Semi hari ini) </p><br><p>  Metamodel ini kemudian digunakan untuk mengubah ekspresi pencarian, seperti <code>bookRepository.findByTitle("The Stand")</code> , menjadi model kueri abstrak saat runtime menggunakan kombinasi parsing ekspresi reguler dan kerangka logika.  Kami membutuhkan model permintaan abstrak karena dialek target dari permintaan berbeda untuk setiap basis data (SQL, JPA-QL, Cypher, Bson, dll.) </p><br><h2 id="podderzhka-repozitoriev-v-micronaut">  Dukungan Repositori Micronaut </h2><br><p>  Sejak meluncurkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Micronaut</a> lebih dari setahun yang lalu, fitur utama yang hilang yang kami tanyakan adalah "GORM for Java" atau dukungan Data Musim Semi.  Begitu banyak pengembang yang jatuh cinta pada produktivitas yang disediakan alat-alat ini, serta kemudahan mendefinisikan antarmuka yang diterapkan kerangka kerja.  Saya akan mengatakan bahwa sebagian besar kesuksesan Grails dan Spring Boot masing-masing dapat dikaitkan dengan GORM dan Spring Data. </p><br><p>  Untuk pengguna Micronaut yang menggunakan Groovy, kami mendapat dukungan GORM sejak hari pertama, dan pengguna Java dan Kotlin tidak memiliki apa-apa, karena mereka perlu mengimplementasikan repositori sendiri. </p><br><p>  Secara teknis akan mungkin, dan terus terang lebih mudah, cukup menambahkan modul untuk Micronaut yang akan mengkonfigurasi Spring Data.  Namun, mengikuti jalur ini, kami akan menyediakan subsistem yang diimplementasikan menggunakan semua metode yang coba dihindari oleh Micronaut: meluasnya penggunaan proxy, refleksi, dan konsumsi memori yang tinggi. </p><br><h2 id="predstavlyaem-predator">  Memperkenalkan Predator! </h2><br><p>  Predator, kependekan dari Precomputed Data Repository, menggunakan Micronaut API untuk mengkompilasi sebelum eksekusi (AoT, sebelum waktu) untuk mentransfer model meta entitas dan mengubah ekspresi pencarian (seperti <code>findByTitle</code> ) ke dalam SQL atau JPA-QL yang sesuai untuk kompiler Anda .  Akibatnya, kueri mengeksekusi lapisan runtime program yang sangat tipis tanpa refleksi, dan hanya tinggal menjalankan kueri dan mengembalikan hasilnya. </p><br><p>  Hasilnya luar biasa ... awal yang dingin berkurang secara signifikan, kami mendapatkan konsumsi memori yang sangat rendah dan peningkatan kinerja yang tajam. </p><br><p>  Hari ini kita membuka kode sumber untuk Predator di bawah lisensi Apache 2, itu akan datang dengan dua implementasi awal (lebih banyak fitur yang direncanakan untuk masa depan) untuk JPA (berdasarkan Hibernate) dan untuk SQL dengan JDBC. </p><br><p>  Implementasi JDBC paling menyenangkan bagi saya, karena sepenuhnya independen dari refleksi, tidak menggunakan proxy dan pemuatan kelas dinamis untuk tingkat akses data Anda, yang mengarah pada peningkatan kinerja.  Lapisan runtime sangat ringan sehingga kode repositori yang ditulis oleh tangan tidak akan mengeksekusi lebih cepat. </p><br><h2 id="proizvoditelnost-predator">  Predator Kinerja </h2><br><p>  Karena Predator tidak perlu menjalankan transformasi kueri apa pun pada waktu berjalan, keuntungan kinerja menjadi signifikan.  Dalam dunia pemanfaatan komputasi awan, di mana Anda membayar jumlah waktu yang dijalankan aplikasi Anda atau untuk pelaksanaan fungsi tunggal, pengembang sering kali tidak melihat kinerja mekanisme akses data mereka. </p><br><p>  Tabel berikut ini merangkum perbedaan kinerja yang dapat diharapkan untuk ekspresi pencarian sederhana, seperti <code>findByTitle</code> , dibandingkan dengan implementasi lainnya.  Semua tes dilakukan dengan menggunakan bangku tes pada 8-core Xeon iMac Pro dalam kondisi yang sama, tes terbuka dan dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di repositori</a> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Implementasi </th><th>  Operasi per detik </th></tr></thead><tbody><tr><td>  Predator JDBC </td><td>  225K ops / dtk </td></tr><tr><td>  Predator jpa </td><td>  130K ops / dtk </td></tr><tr><td>  Data pegas jpa </td><td>  90K ops / dtk </td></tr><tr><td>  JPA GORM </td><td>  50K ops / dtk </td></tr><tr><td>  Data Musim Semi JDBC </td><td>  Pencari tidak didukung </td></tr></tbody></table></div><br><p>  Ya, Anda membacanya dengan benar.  Dengan Predator JDBC, Anda dapat mengharapkan peningkatan kinerja hampir 4X dari GORM dan 2.5X dari Data Spring. </p><br><p>  Dan bahkan jika Anda menggunakan Predator JPA, Anda dapat mengandalkan lebih dari 2X peningkatan kinerja lebih dari GORM dan hingga 40% dibandingkan Spring Data JPA. </p><br><p>  Lihatlah perbedaan ukuran tumpukan eksekusi ketika menggunakan Predator dibandingkan dengan alternatif: </p><br><p>  <strong>Predator:</strong> </p><br><p><img src="https://habrastorage.org/webt/6_/5l/ns/6_5lnsvtlyng0zisy5updpoii30.png"></p><br><p>  <strong>Predator JPA:</strong> </p><br><p><img src="https://habrastorage.org/webt/dw/us/bc/dwusbcyeubxeu8l-glmhgq0r7me.png"></p><br><p>  <strong>Data Musim Semi:</strong> </p><br><p><img src="https://habrastorage.org/webt/di/m2/uv/dim2uvimrgxvs4ksszq0gsxujkq.png"></p><br><p>  <strong>GORM:</strong> </p><br><p><img src="https://habrastorage.org/webt/ad/7z/rs/ad7zrsyjfc1-fpr-cm3vqp9cmle.png"></p><br><p>  Predator JDBC hanya menggunakan 15 frame sampai saat permintaan Anda dieksekusi, sementara Predator JPA menggunakan 30 frame (terutama karena Hibernate), dibandingkan dengan 50+ stack frame di Spring Data atau GORM.  Dan semua berkat mekanisme AOP Micronaut yang tidak menggunakan refleksi. </p><br><p>  Stacker pendek juga menyederhanakan debugging aplikasi.  Salah satu keuntungan melakukan sebagian besar pekerjaan selama kompilasi adalah bahwa kesalahan dapat dideteksi sebelum aplikasi diluncurkan, yang sangat meningkatkan pengalaman pengembang.  Kami segera mendapatkan kesalahan kompilasi alih-alih kesalahan runtime untuk kesalahan paling umum. </p><br><h2 id="proverki-vremeni-kompilyacii">  Kompilasi pemeriksaan waktu </h2><br><p>  Sebagian besar implementasi templat repositori hanya mengandalkan menjalankan semua operasi saat runtime.  Ini berarti bahwa jika pengembang membuat kesalahan dalam mendefinisikan antarmuka repositori, kesalahan tidak akan terlihat sampai aplikasi benar-benar diluncurkan. </p><br><p>  Ini merampas beberapa manfaat Java untuk pengecekan tipe dan kami memiliki pengalaman data yang buruk.  Ini tidak terjadi dengan Predator.  Perhatikan contoh berikut: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@JdbcRepository</span></span>(dialect = Dialect.H2) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Book</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Book </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByTile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String t)</span></span></span></span>; }</code> </pre> <br><p>  Di sini <code>BookRepository</code> kami mendeklarasikan permintaan ke objek bernama <code>Book</code> , yang memiliki properti <code>title</code> .  Sayangnya, ada kesalahan dalam deklarasi ini: kami menamai metode <code>findByTile</code> alih-alih <code>findByTitle</code> .  Alih-alih menjalankan kode ini, Predator tidak akan mengizinkan kode Anda untuk dikompilasi dengan pesan kesalahan informatif: </p><br><pre> <code class="plaintext hljs">Error:(9, 10) java: Unable to implement Repository method: BookRepository.findByTile(String title). Cannot use [Equals] criterion on non-existent property path: tile</code> </pre> <br><p>  Banyak aspek Predator diperiksa pada waktu kompilasi, bila memungkinkan, untuk memastikan bahwa kesalahan runtime tidak disebabkan oleh deklarasi repositori yang salah. </p><br><h2 id="predator-jdbc-i-graalvm-substrate">  Predator JDBC dan GraalVM Substrat </h2><br><p>  Alasan lain Predator harus senang adalah bahwa ia berada di luar kotak yang kompatibel dengan gambar asli GraalVM dan tidak memerlukan konversi bytecode kompleks selama pembuatan, tidak seperti yang untuk Hibernate di GraalVM. </p><br><p>  Dengan sepenuhnya menghilangkan refleksi dan proksi dinamis dari lapisan akses data, Predator sangat menyederhanakan pembuatan aplikasi yang bekerja dengan data yang berjalan di GraalVM. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi sampel Predator JDBC</a> berjalan pada Substrat tanpa masalah dan memungkinkan Anda untuk membuat gambar asli yang jauh lebih kecil (25 MB lebih sedikit!) Dari pada Hibernate perlu bekerja, berkat lapisan runtime yang jauh lebih tipis. </p><br><p>  Kami melihat hasil yang sama ketika kami mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kompilasi aturan Validasi Bean</a> untuk Micronaut 1.2.  Ukuran gambar asli menurun 10 MB, segera setelah kami menghapus ketergantungan pada Hibernate Validator, dan ukuran JAR sebesar 2 MB. </p><br><p>  Keuntungannya di sini jelas: dengan melakukan lebih banyak pekerjaan selama kompilasi dan membuat lebih banyak runtimes yang kompak, Anda mendapatkan gambar asli yang lebih kecil dan file JAR, yang mengarah pada penyebaran layanan microser yang lebih kecil dan lebih mudah ketika digunakan melalui Docker.  Masa depan kerangka kerja Java adalah kompiler yang lebih kuat dan runtime yang lebih kecil dan lebih ringan. </p><br><h2 id="predator-i-buduschee">  Predator dan masa depan </h2><br><p>  Kami baru mulai bekerja dengan Predator dan sangat senang dengan peluang yang terbuka. </p><br><p>  Awalnya, kami mulai dengan dukungan untuk JPA dan SQL, tetapi di masa depan Anda dapat mengharapkan dukungan untuk MongoDB, Neo4J, SQL Reaktif dan database lainnya.  Untungnya, pekerjaan ini jauh lebih sederhana karena sebagian besar Predator sebenarnya didasarkan pada kode sumber GORM, dan kita dapat menggunakan kembali logika GORM untuk Neo4J dan GORM untuk MongoDB untuk merilis implementasi ini lebih cepat dari yang Anda harapkan. </p><br><p>  Predator adalah puncak dari menggabungkan berbagai blok bangunan di Micronaut Core yang memungkinkan untuk mengimplementasikannya, dari API AoT, yang juga digunakan untuk menghasilkan dokumentasi Swagger, hingga dukungan Bean Introspection yang relatif baru, yang memungkinkan Anda untuk menganalisis objek saat runtime tanpa refleksi. </p><br><p>  Micronaut menyediakan blok bangunan untuk hal-hal menakjubkan.  Predator adalah satu hal seperti itu, dan kami baru mulai bekerja pada beberapa fitur yang menjanjikan dari Micronaut 1.0. </p><br><p>  PEMBARUAN: Setelah pengumuman yang mengejutkan, pembunuh Data Spring diganti namanya menjadi Data Micronaut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://micronaut-projects.github.io/micronaut-data/1.0.x/guide/</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460839/">https://habr.com/ru/post/id460839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460825/index.html">Pengantar Screen Capture API - Memindai kode QR di browser</a></li>
<li><a href="../id460827/index.html">Masalah PGP</a></li>
<li><a href="../id460831/index.html">Bahaya desainer</a></li>
<li><a href="../id460833/index.html">Fisika dan Ekonomi. Perbedaan gnoseologis dan manifestasinya dalam IT</a></li>
<li><a href="../id460837/index.html">Buku Pegangan Podcast Pemula</a></li>
<li><a href="../id460841/index.html">Aplikasi Pembelajaran Bahasa TOP-23</a></li>
<li><a href="../id460843/index.html">Memperkenalkan 3CX Call Flow Designer Baru dan Generator Template 3CX CRM</a></li>
<li><a href="../id460845/index.html">Fernando Corbato, bapak komputer Anda (dan kata sandi), meninggal pada usia 93</a></li>
<li><a href="../id460847/index.html">12,3 juta WebSockets bersamaan</a></li>
<li><a href="../id460849/index.html">Bagian 4. Model grafik untuk menghitung fungsi logis untuk proses paralel asinkron</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>