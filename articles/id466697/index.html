<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòå ü§µüèº üë©üèø‚Äçüöí Monad di Erlang üë∞üèΩ üßëüèø‚Äçü§ù‚Äçüßëüèæ üòò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di Habr√©, Anda dapat menemukan banyak publikasi yang mengungkap teori monad dan praktik penerapannya. Sebagian besar artikel ini diharapkan tentang Ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monad di Erlang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466697/"><p><img src="https://habrastorage.org/webt/uu/-w/xm/uu-wxmn1samfdcrveqdv27zpvvm.jpeg"></p><br><p>  Di Habr√©, Anda dapat menemukan banyak publikasi yang mengungkap teori monad dan praktik penerapannya.  Sebagian besar artikel ini diharapkan tentang Haskell.  Saya tidak akan menceritakan kembali teori untuk yang ke-9 kalinya.  Hari ini kita akan berbicara tentang beberapa masalah Erlang, cara untuk menyelesaikannya dengan monad, penggunaan sebagian fungsi dan gula sintaksis dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">erlando</a> - perpustakaan keren dari tim RabbitMQ. </p><a name="habracut"></a><br><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Erlang memiliki kekekalan, tetapi tidak ada monad <strong>*</strong> .  Namun berkat fungsionalitas parse_transform dan implementasi erlando dalam bahasa, masih ada kemungkinan menggunakan monad di Erlang. </p><br><p> Tentang kekebalan pada awal cerita, saya berbicara bukan secara kebetulan.  Kekebalan hampir di mana-mana dan selalu merupakan salah satu ide utama Erlang.  Kekebalan dan kemurnian fungsi memungkinkan Anda untuk fokus pada pengembangan fungsi tertentu dan tidak takut efek samping.  Tetapi pendatang baru di Erlang, yang berasal dari Jawa atau Python, misalnya, merasa sangat sulit untuk memahami dan menerima ide-ide Erlang.  Apalagi jika Anda mengingat sintaks Erlang.  Mereka yang mencoba untuk mulai menggunakan Erlang mungkin mencatat keanehan dan kemandiriannya.  Bagaimanapun, saya telah mengumpulkan banyak umpan balik dari pemula dan sintaksis "aneh" memimpin peringkat. </p><br><h2 id="erlando">  Erlando </h2><br><p>  Erlando adalah set ekstensi Erlang yang memberi kita: </p><br><ul><li>  Penggunaan sebagian / currying fungsi dengan potongan seperti Skema </li><li>  Seperti Haskell, lakukan notasi </li><li>  import-as - gula sintaksis untuk mengimpor fungsi dari modul lain. </li></ul><br><p>  <strong>Catatan:</strong> Saya mengambil contoh kode berikut untuk mengilustrasikan fitur erlando dari presentasi Matthew Sackman, sebagian melemahkannya dengan kode dan penjelasan saya. </p><br><h2 id="abstrakciya-cut">  Potong Abstrak </h2><br><p>  Langsung ke intinya.  Pertimbangkan beberapa fungsi dari proyek nyata: </p><br><pre><code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info_all</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VHostPath, Items)</span></span></span><span class="hljs-function"> -&gt;</span></span> map(VHostPath, <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> (Q) -&gt; info(Q, Items) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>). backing_queue_timeout(State = #q{ backing_queue = BQ }) -&gt; run_backing_queue( BQ, <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> (M, BQS) -&gt; M:timeout(BQS) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, State). reset_msg_expiry_fun(TTL) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> (MsgProps) -&gt; MsgProps #message_properties{ expiry = calculate_msg_expiry(TTL)} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br><p>  Semua fungsi ini dirancang untuk menggantikan parameter menjadi ekspresi sederhana.  Sebenarnya, ini adalah aplikasi parsial, karena beberapa parameter tidak akan diketahui sebelum panggilan.  Bersama dengan fleksibilitas, fitur-fitur ini menambah derau pada kode kami.  Dengan mengubah sedikit sintaks - dengan memasukkan cut - Anda dapat memperbaiki situasinya. </p><br><h3 id="znachenie-_">  Nilai _ </h3><br><ul><li>  _ dapat digunakan dalam template </li><li>  Cut memungkinkan Anda menggunakan _ pola luar </li><li>  Jika di <em>luar template, itu</em> menjadi parameter untuk ekspresi di mana ia berada </li><li>  Penggunaan banyak _ dalam ekspresi yang sama mengarah pada penggantian beberapa parameter dalam ekspresi ini </li><li>  Cut bukan pengganti penutupan (kesenangan) </li><li>  Argumen dievaluasi sebelum fungsi potong. </li></ul><br><p>  Cut menggunakan _ dalam ekspresi untuk menunjukkan di mana abstraksi harus diterapkan.  Potong hanya membungkus level terdekat dalam ekspresi, tetapi potongan bersarang tidak dilarang. <br>  Misalnya <code>list_to_binary([1, 2, math:pow(2, _)]).</code>  <code>list_to_binary([1, 2, fun (X) -&gt; math:pow(2, X) end]).</code> ke <code>list_to_binary([1, 2, fun (X) -&gt; math:pow(2, X) end]).</code>  tetapi tidak <code>fun (X) -&gt; list_to_binary([1, 2, math:pow(2, X)]) end.</code>  . </p><br><p>  Kedengarannya agak membingungkan, mari kita menulis ulang contoh di atas menggunakan cut: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info_all</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VHostPath, Items)</span></span></span><span class="hljs-function"> -&gt;</span></span> map(VHostPath, <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> (Q) -&gt; info(Q, Items) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>). info_all(VHostPath, Items) -&gt; map(VHostPath, info(_, Items)).</code> </pre> <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">backing_queue_timeout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State = #q{ backing_queue = BQ })</span></span></span><span class="hljs-function"> -&gt;</span></span> run_backing_queue( BQ, <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> (M, BQS) -&gt; M:timeout(BQS) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, State). backing_queue_timeout(State = #q{backing_queue = BQ}) -&gt; run_backing_queue(BQ, _:timeout(_), State).</code> </pre> <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset_msg_expiry_fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TTL)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> (MsgProps) -&gt; MsgProps #message_properties { expiry = calculate_msg_expiry(TTL) } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>. reset_msg_expiry_fun(TTL) -&gt; _ #message_properties { expiry = calculate_msg_expiry(TTL) }.</code> </pre> <br><h3 id="poryadok-vychisleniya-argumentov">  Urutan Perhitungan Argumen </h3><br><p>  Untuk mengilustrasikan urutan penghitungan argumen, pertimbangkan contoh berikut: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_, _)</span></span></span><span class="hljs-function"> -&gt;</span></span> io:format(<span class="hljs-string"><span class="hljs-string">"in f1~n"</span></span>). test() -&gt; F = f1(io:format(<span class="hljs-string"><span class="hljs-string">"test line 1~n"</span></span>), _), F(io:format(<span class="hljs-string"><span class="hljs-string">"test line 2~n"</span></span>)).</code> </pre> <br><p>  Karena argumen dievaluasi sebelum fungsi pemotongan, berikut ini akan ditampilkan: </p><br><pre> <code class="plaintext hljs">test line 2 test line 1 in f1</code> </pre> <br><h3 id="abstrakciya-cut-v-razlichnyh-tipah-i-shablonah-koda">  Potong abstraksi dalam berbagai jenis dan pola kode </h3><br><ul><li>  Tuples <br><pre> <code class="erlang hljs">F = {_, <span class="hljs-number"><span class="hljs-number">3</span></span>}, {a, <span class="hljs-number"><span class="hljs-number">3</span></span>} = F(a).</code> </pre> </li><li>  Daftar <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbl_cons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List)</span></span></span><span class="hljs-function"> -&gt;</span></span> [_, _ | List]. test() -&gt; F = dbl_cons([<span class="hljs-number"><span class="hljs-number">33</span></span>]), [<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">33</span></span>] = F(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>).</code> </pre> </li><li>  Rekaman <br><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">-record</span></span><span class="hljs-params"><span class="hljs-params">(vector, { x, y, z })</span></span>. test() -&gt; GetZ = _#vector.z, <span class="hljs-number"><span class="hljs-number">7</span></span> = GetZ(#vector { z = <span class="hljs-number"><span class="hljs-number">7</span></span> }), SetX = _#vector{x = _}, V = #vector{ x = <span class="hljs-number"><span class="hljs-number">5</span></span>, y = <span class="hljs-number"><span class="hljs-number">4</span></span> } = SetX(#vector{ y = <span class="hljs-number"><span class="hljs-number">4</span></span> }, <span class="hljs-number"><span class="hljs-number">5</span></span>).</code> </pre> </li><li>  Kasing <br><pre> <code class="erlang hljs">F = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> N <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> is_integer(N) -&gt; N + N; N -&gt; N <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> = F(<span class="hljs-number"><span class="hljs-number">5</span></span>), ok = F(ok).</code> </pre> </li><li>  Peta <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> GetZ = maps:get(z, _), <span class="hljs-number"><span class="hljs-number">7</span></span> = GetZ(#{ z =&gt; <span class="hljs-number"><span class="hljs-number">7</span></span> }), SetX = _#{x =&gt; _}, V = #{ x := <span class="hljs-number"><span class="hljs-number">5</span></span>, y := <span class="hljs-number"><span class="hljs-number">4</span></span> } = SetX(#{ y =&gt; <span class="hljs-number"><span class="hljs-number">4</span></span> }, <span class="hljs-number"><span class="hljs-number">5</span></span>).</code> </pre> </li><li>  Daftar yang Cocok dan Membangun Data Biner <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_cut_comprehensions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> F = &lt;&lt; &lt;&lt;(<span class="hljs-number"><span class="hljs-number">1</span></span> + (X*<span class="hljs-number"><span class="hljs-number">2</span></span>))&gt;&gt; || _ &lt;- _, X &lt;- _ &gt;&gt;, <span class="hljs-comment"><span class="hljs-comment">%% Note, this'll only be a /2 ! &lt;&lt;"AAA"&gt;&gt; = F([a,b,c], [32]), F1 = [ {X, Y, Z} || X &lt;- _, Y &lt;- _, Z &lt;- _, math:pow(X,2) + math:pow(Y,2) == math:pow(Z,2) ], [{3,4,5}, {4,3,5}, {6,8,10}, {8,6,10}] = lists:usort(F1(lists:seq(1,10), lists:seq(1,10), lists:seq(1,10))).</span></span></code> </pre> </li></ul><br><p>  <strong>Pro</strong> </p><br><ul><li>  Kode menjadi lebih kecil, oleh karena itu lebih mudah dipelihara. </li><li>  Kode menjadi lebih sederhana dan lebih rapi. </li><li>  Hilang kebisingan dari kesenangan. </li><li>  Untuk pemula di Erlang, lebih mudah menulis fungsi Get / Set. </li></ul><br><p>  <strong>Cons</strong> </p><br><ul><li>  Peningkatan ambang entri untuk pengembang Erlang berpengalaman, sekaligus mengurangi ambang entri untuk pemula.  Sekarang tim dituntut untuk memahami cut dan tahu satu sintaks lagi. </li></ul><br><h2 id="do-notaciya">  Lakukan notasi </h2><br><p>  Koma lunak adalah konstruksi pengikatan komputasi.  Erlang tidak memiliki model perhitungan malas.  Mari kita bayangkan apa yang akan terjadi jika Erlang malas seperti Haskell </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> A = foo(), B = bar(A, dog), ok.</code> </pre> <br><p>  Untuk menjamin urutan eksekusi, kita perlu menautkan penghitungan secara eksplisit dengan mendefinisikan koma. </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> A = foo(), comma(), B = bar(A, dog), comma(), ok.</code> </pre> <br><p>  Lanjutkan konversi: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> comma(foo(), <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> (A) -&gt; comma(bar(A, dog), <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> (B) -&gt; ok <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)).</code> </pre> <br><p>  Berdasarkan kesimpulan, koma / 2 adalah fungsi idiomatis <code>&gt;&gt;=/2</code> .  Monad hanya membutuhkan tiga fungsi: <code>&gt;&gt;=/2</code> , <code>return/1</code> dan <code>fail/1</code> . <br>  Semuanya akan baik-baik saja, tetapi sintaksinya buruk.  Kami menerapkan transformer sintaksis dari <code>erlando</code> . </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([Monad || A &lt;- foo(), B &lt;- bar(A, dog), ok])</span></span></span><span class="hljs-function">.</span></span></code> </pre> <br><h2 id="tipy-monad">  Jenis-jenis Monads </h2><br><p>  Karena do-block sudah diparameterisasi, kita bisa menggunakan monad dari berbagai tipe.  Di dalam do-block, masing-masing panggilan <code>return/1</code> dan <code>fail/1</code> dikerahkan ke <code>Monad:return/1</code> dan <code>Monad:fail/1</code> . </p><br><ul><li><p>  Identitas-monad. <br>  Monad identik adalah monad paling sederhana yang tidak mengubah jenis nilai dan tidak berpartisipasi dalam kontrol proses perhitungan.  Itu diterapkan dengan transformer.  Melakukan menghubungkan ekspresi - koma perangkat lunak yang dibahas di atas. </p><br></li><li><p>  Mungkin-monad. <br>  Monad perhitungan dengan memproses nilai yang hilang.  Mengaitkan parameter dengan perhitungan parameter adalah transfer parameter ke perhitungan, menghubungkan parameter tidak ada dengan perhitungan parameter adalah hasil yang tidak ada. <br>  Pertimbangkan contoh mungkin_m: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if_safe_div_zero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, Y, Fun)</span></span></span><span class="hljs-function"> -&gt;</span></span> do([maybe_m || Result &lt;- <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Y == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; fail(<span class="hljs-string"><span class="hljs-string">"Cannot divide by zero"</span></span>); <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; return(X / Y) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, return(Fun(Result))]).</code> </pre> <br><p>  Evaluasi ekspresi berhenti jika tidak ada yang dikembalikan. </p><br><pre> <code class="erlang hljs">{just, <span class="hljs-number"><span class="hljs-number">6</span></span>} = if_safe_div_zero(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, _+<span class="hljs-number"><span class="hljs-number">4</span></span>) ## <span class="hljs-number"><span class="hljs-number">10</span></span>/<span class="hljs-number"><span class="hljs-number">5</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">6</span></span> nothing = if_safe_div_zero(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, _+<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br></li><li><p>  Kesalahan-monad. <br>  Mirip dengan maybe_m, hanya dengan penanganan kesalahan.  Kadang-kadang prinsip let it crash tidak berlaku dan kesalahan harus ditangani pada saat itu terjadi.  Dalam kasus ini, tangga dari kasing sering muncul dalam kode, misalnya, ini: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path, Data, Modes)</span></span></span><span class="hljs-function"> -&gt;</span></span> Modes1 = [binary, write | (Modes -- [binary, write])], <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> make_binary(Data) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Bin <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> is_binary(Bin) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> file:open(Path, Modes1) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> {ok, Hdl} -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> file:write(Hdl, Bin) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ok -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> file:sync(Hdl) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ok -&gt; file:close(Hdl); {error, _} = E -&gt; file:close(Hdl), E <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; {error, _} = E -&gt; file:close(Hdl), E <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; {error, _} = E -&gt; E <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; {error, _} = E -&gt; E <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_binary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bin)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">when</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_binary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bin)</span></span></span><span class="hljs-function"> -&gt;</span></span> Bin; make_binary(List) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> iolist_to_binary(List) <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> error:Reason -&gt; {error, Reason} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br></li></ul><br><p>  Membaca ini tidak menyenangkan, sepertinya mi panggilan balik di JS.  Error_m datang untuk menyelamatkan: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path, Data, Modes)</span></span></span><span class="hljs-function"> -&gt;</span></span> Modes1 = [binary, write | (Modes -- [binary, write])], do([error_m || Bin &lt;- make_binary(Data), Hdl &lt;- file:open(Path, Modes1), Result &lt;- return(do([error_m || file:write(Hdl, Bin), file:sync(Hdl)])), file:close(Hdl), Result]). make_binary(Bin) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> is_binary(Bin) -&gt; error_m:return(Bin); make_binary(List) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> error_m:return(iolist_to_binary(List)) <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> error:Reason -&gt; error_m:fail(Reason) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br><ul><li>  Daftar-monad. <br>  Nilai adalah daftar yang dapat diartikan sebagai beberapa hasil yang mungkin dari satu perhitungan.  Jika satu perhitungan tergantung pada yang lain, maka perhitungan kedua dilakukan untuk setiap hasil yang pertama, dan hasil (perhitungan kedua) dikumpulkan dalam daftar. <br>  Perhatikan contoh dengan tiga kali lipat Pythagoras klasik.  Kami menghitungnya tanpa monad: <br><pre> <code class="erlang hljs">P = [{X, Y, Z} || Z &lt;- lists:seq(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>), X &lt;- lists:seq(<span class="hljs-number"><span class="hljs-number">1</span></span>,Z), Y &lt;- lists:seq(X,Z), math:pow(X,<span class="hljs-number"><span class="hljs-number">2</span></span>) + math:pow(Y,<span class="hljs-number"><span class="hljs-number">2</span></span>) == math:pow(Z,<span class="hljs-number"><span class="hljs-number">2</span></span>)].</code> </pre> </li></ul><br><p>  Hal yang sama dengan list_m saja: </p><br><pre> <code class="erlang hljs">P = do([list_m || Z &lt;- lists:seq(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>), X &lt;- lists:seq(<span class="hljs-number"><span class="hljs-number">1</span></span>,Z), Y &lt;- lists:seq(X,Z), monad_plus:guard(list_m, math:pow(X,<span class="hljs-number"><span class="hljs-number">2</span></span>) + math:pow(Y,<span class="hljs-number"><span class="hljs-number">2</span></span>) == math:pow(Z,<span class="hljs-number"><span class="hljs-number">2</span></span>)), return({X,Y,Z})]).</code> </pre> <br><ul><li>  Negara-monad. <br>  Monad komputasi stateful. <br>  Pada awal artikel, kami berbicara tentang kesulitan pemula ketika bekerja dengan keadaan variabel.  Seringkali kode terlihat seperti ini: <br><pre> <code class="erlang hljs">State1 = init(Dimensions), State2 = plant_seeds(SeedCount, State1), {DidFlood, State3} = pour_on_water(WaterVolume, State2), State4 = apply_sunlight(Time, State3), {DidFlood2, State5} = pour_on_water(WaterVolume, State4), {Crop, State6} = harvest(State5), ...</code> </pre> </li></ul><br><p>  Menggunakan transformator dan cut-notation, kode ini dapat ditulis ulang dalam bentuk yang lebih ringkas dan mudah dibaca: </p><br><pre> <code class="erlang hljs">StateT = state_t:new(identity_m), SM = StateT:modify(_), SMR = StateT:modify_and_return(_), StateT:exec( do([StateT || StateT:put(init(Dimensions)), SM(plant_seeds(SeedCount, _)), DidFlood &lt;- SMR(pour_on_water(WaterVolume, _)), SM(apply_sunlight(Time, _)), DidFlood2 &lt;- SMR(pour_on_water(WaterVolume, _)), Crop &lt;- SMR(harvest(_)), ... ]), undefined).</code> </pre> <br><ul><li>  Omega-monad. <br>  Mirip dengan list_m monad.  Namun, perikop ini dibuat secara diagonal. </li></ul><br><h3 id="skrytaya-obrabotka-oshibok">  Penanganan kesalahan tersembunyi </h3><br><p>  Mungkin salah satu fitur favorit saya dari <code>error_m</code> monad.  Di mana pun kesalahan terjadi, monad akan selalu mengembalikan <code>{ok, Result}</code> atau <code>{error, Reason}</code> .  Contoh yang menggambarkan perilaku: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([error_m || Hdl &lt;- file:open(Path, Modes), Data &lt;- file:read(Hdl, BytesToRead), file:write(Hdl, DataToWrite), file:sync(Hdl), file:close(Hdl), file:rename(Path, Path2), file:delete(Path), return(Data)])</span></span></span><span class="hljs-function">.</span></span></code> </pre> <br><h2 id="import_as">  Import_as </h2><br><p>  Untuk camilan, kami memiliki sintaks import_as gula.  Sintaks standar untuk atribut -import / 2 memungkinkan Anda untuk mengimpor fungsi dari yang lain ke modul lokal.  Namun, sintaks ini tidak memungkinkan Anda untuk memberikan nama alternatif ke fungsi yang diimpor.  Import_as menyelesaikan masalah ini: </p><br><pre> <code class="erlang hljs">-import_as<span class="hljs-params"><span class="hljs-params">({my_mod, [{size/</span><span class="hljs-number"><span class="hljs-params"><span class="hljs-number">1</span></span></span><span class="hljs-params">, m_size}]})</span></span> -import_as<span class="hljs-params"><span class="hljs-params">({my_other_mod, [{size/</span><span class="hljs-number"><span class="hljs-params"><span class="hljs-number">1</span></span></span><span class="hljs-params">, o_size}]})</span></span></code> </pre> <br><p>  Ekspresi ini diperluas ke fungsi lokal nyata, masing-masing: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span><span class="hljs-function"> -&gt;</span></span> my_mod:size(A). o_size(A) -&gt; my_other_mod:size(A).</code> </pre> <br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Tentu saja, monads memungkinkan Anda untuk mengontrol proses perhitungan dengan metode yang lebih ekspresif, menghemat kode dan waktu untuk mendukungnya.  Di sisi lain, mereka menambah kompleksitas ekstra untuk anggota tim yang tidak terlatih. </p><br><p>  <strong>*</strong> - sebenarnya, di Erlang monad ada tanpa erlando.  Ekspresi pemisah koma adalah konstruksi penghitungan linearisasi dan penghubung. </p><br><p>  PS Baru-baru ini, perpustakaan erlando ditandai oleh penulis sebagai arsip.  Saya menulis artikel ini lebih dari setahun yang lalu.  Namun, seperti sekarang, di Habr√© tidak ada informasi tentang monad di Erlang.  Untuk memperbaiki situasi ini, saya menerbitkan, meskipun terlambat, artikel ini. <br>  Untuk menggunakan erlando di erlang&gt; = 22, Anda harus memperbaiki masalah dengan erlang yang sudah usang: get_stacktrace / 0.  Contoh perbaikan dapat ditemukan di garpu saya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/Vonmo/erlando/commit/52e23ecedd2b8c13707a11c7f0f14496b5a191c2</a> </p><br><p>  Terima kasih untuk waktu anda! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466697/">https://habr.com/ru/post/id466697/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466683/index.html">Acara digital di Moskow 9-15 September</a></li>
<li><a href="../id466685/index.html">Melihat uang</a></li>
<li><a href="../id466689/index.html">Cara membuat kelas karakter di MMO Action seluler</a></li>
<li><a href="../id466691/index.html">Jadi semua RAML atau OAS (Swagger) yang sama?</a></li>
<li><a href="../id466693/index.html">Jika Anda masuk bukan di IT</a></li>
<li><a href="../id466699/index.html">Menjinakkan protokol kepercayaan - OAuth otentikasi dengan InterSystems IRIS</a></li>
<li><a href="../id466701/index.html">Let's Encrypt melayani hampir 30% domain</a></li>
<li><a href="../id466705/index.html">Vivaldi Beta untuk Android - Browser Asli</a></li>
<li><a href="../id466709/index.html">Mengembangkan OS seperti Unix monolitik - Perpustakaan C (2)</a></li>
<li><a href="../id466711/index.html">Kerentanan DaOffice diizinkan untuk menghapus pengguna mana pun dari jejaring sosial</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>