<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÄ üßïüèº üôä Testen Sie den Automatisierungswiderstand üëèüèº ü¶å üëÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Trotz der Tatsache, dass es Unit-Testing-Technologien seit 30 Jahren gibt (Kent Beck schrieb 1989 den Artikel ‚ÄûSimple Smalltalk Testing: With Patterns...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testen Sie den Automatisierungswiderstand</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418491/"><p>  Trotz der Tatsache, dass es Unit-Testing-Technologien seit 30 Jahren gibt (Kent Beck schrieb 1989 den Artikel ‚ÄûSimple Smalltalk Testing: With Patterns‚Äú), besitzen nicht alle Programmierer diese Technologie, und nicht alle Unternehmen haben das automatische Testen zu einem Teil ihrer Unternehmenskultur gemacht. .  Trotz der offensichtlichen Vorteile des automatischen Testens ist der Verhaltenswiderstand immer noch recht stark.  Wer versucht hat, automatisierte Tests zu implementieren, wei√ü, dass es immer einen Grund gibt, warum dies nicht m√∂glich ist. </p><br><p>  Aus meiner pers√∂nlichen Erfahrung mit der Implementierung zuverl√§ssiger Programmiermethoden in meinem Unternehmen, in den von mir konsultierten Unternehmen, der Kommunikation auf Konferenzen und auch aus √∂ffentlich zug√§nglichen Quellen habe ich typische Einw√§nde und Widerst√§nde formuliert, die die Implementierung einer Kultur des automatischen Testens behindern. </p><br><p>  Ich habe alle Einw√§nde in einer Pyramide zuverl√§ssiger Programmierung zusammengefasst, die vier Ebenen umfasst: <a name="habracut"></a></p><br><ul><li>  <strong>Die Berufskultur</strong> (die h√∂chste Ebene, die Grundlage f√ºr zuverl√§ssige Programmierung) besteht aus einer Reihe von Normen, ungeschriebenen Regeln und √úberzeugungen der Mitarbeiter, die ihn bei seiner Arbeit leiten.  Beispiel: "Das Senden von Code, der durch Tests aufgedeckt wurde, an das Repository ist schlecht", "Das Schweigen √ºber gefundene Fehler im Code ist eine Schande". </li><li>  <strong>Management</strong> sind die von der Organisation verabschiedeten Verfahren, Richtlinien, Regeln sowie der Wille (die Entscheidung) der F√ºhrungskr√§fte.  Zum Beispiel: ‚ÄûJede entwickelte Anwendungsfunktion muss einen √úberpr√ºfungscode √ºbergeben.  Keine Ausnahmen! " </li><li>  <strong>Methoden</strong> sind wissenschaftliche Ans√§tze, Methoden zur L√∂sung eines bestimmten Problems.  Beispiel: "Wenn die Funktion der Anwendung schwer zu testen ist, m√ºssen Sie die Testbarkeit der Anwendung durch Anwenden der Vorlage" Abh√§ngigkeitsinjektion "verbessern." </li><li>  <strong>Technologien</strong> (die unterste Ebene) sind Programmiersprachen, Bibliotheken, Frameworks und Tools.  Zum Beispiel JUnit, Selen, XCTest und so weiter. </li></ul><br><p><img src="https://habrastorage.org/webt/ky/wa/ev/kywaevzql1sl53klb8pzmazzwcm.png"></p><br><p>  Warum ist eine solche Aufteilung notwendig?  Weil das Problem einer Ebene durch Methoden derselben Ebene oder durch Methoden einer h√∂heren Ebene gel√∂st wird.  Wenn es beispielsweise f√ºr eine Organisation nicht √ºblich ist, automatische Tests zu schreiben (das Problem der Berufskultur), kann dieses Problem nicht durch eine detaillierte Beschreibung des Testgesch√§ftsprozesses (Ebene ‚ÄûManagement‚Äú) oder durch die Installation eines modernen Frameworks (Ebene ‚ÄûTechnologie‚Äú) gel√∂st werden.  Ich gebe eine Garantie, dass in einer Woche trotz des genehmigten Gesch√§ftsprozesses niemand Tests schreiben wird. </p><br><h2 id="vozrazheniya-kulturnogo-urovnya">  Kulturelle Einw√§nde </h2><br><h3 id="moi-programmy-ne-lomayutsya-ya-ne-vizhu-nuzhdy-v-testirovanii">  ‚ÄûMeine Programme brechen nicht.  Ich sehe keine Notwendigkeit zum Testen. " </h3><br><p>  Ich habe diese Aussage von Anf√§ngern oder √ºberm√§√üig selbstbewussten Programmierern geh√∂rt. <br>  Nat√ºrlich kann eine einmal geschriebene Funktion nicht von alleine brechen.  Hier ist es jedoch wichtig zu verstehen, dass das Programm im Laufe der Zeit m√∂glicherweise Unterst√ºtzung, die Einf√ºhrung neuer Funktionen oder Erg√§nzungen bestehender Funktionen ben√∂tigt.  Die Komplexit√§t der Programme - die Anzahl der Klassen und die Abh√§ngigkeiten zwischen ihnen - ist ziemlich gro√ü, und schlie√ülich tritt fr√ºher oder sp√§ter ein Fehler auf, nachdem eine andere neue Funktion erstellt oder eine vorhandene verbessert wurde.  Ein automatischer Test w√ºrde eine solche Regression erkennen. </p><br><p>  Dar√ºber hinaus ist ein solcher Einwand h√§ufig von unerfahrenen Programmierern zu h√∂ren, die kein Testkonzept haben.  Beispielsweise werden nur Abst√ºrze als Ausfall betrachtet, keine Funktionsfehler. </p><br><p>  Bei einem der von mir durchgef√ºhrten Interviews fand folgender Dialog statt: </p><br><p>  - Haben Sie die F√§higkeiten zum automatischen Testen? <br>  - Nein, ich habe einfache Programme geschrieben, es gab nichts zu brechen. <br>  - Was ist Ihre Motivation, den Job zu wechseln? <br>  - Ich m√∂chte komplexe Anwendungen schreiben. </p><br><p>  Ich wei√ü sehr gut, wie das endet.  Dem Programmierer wird vertraut, dass er ein komplexeres Programm entwickelt, er kennt jedoch die Methoden des automatischen Testens nicht, er kann die Anwendung nicht qualitativ testen und er kann den Umfang des Projekts nicht bew√§ltigen, was zu einer St√∂rung des Projekts, einer Kosten√ºberschreitung der Entwicklung und einem Reputationsverlust f√ºhren wird.  Weil ich pers√∂nlich Projekte geleitet habe, bei denen ich den Umfang des Projekts nicht bew√§ltigen konnte und es gerade wegen des Fehlens automatischer Tests nicht bestanden habe. </p><br><h3 id="nezhelanie-brat-otvetstvennost-za-kachestvo-koda-za-testirovanie">  Widerwillen, Verantwortung f√ºr die Qualit√§t des Codes zu √ºbernehmen, f√ºr Tests. </h3><br><p>  Automatisierte Tests sind die einzige Quelle f√ºr betriebliche und objektive Informationen √ºber die wahre Qualit√§t eines Softwareprodukts.  Mit anderen Worten, der Programmierer hat immer einen Vorgesetzten hinter seinem R√ºcken, der dem Management jederzeit berichten kann, wie gut der Programmierer seine Arbeit macht.  Mit automatisierten Tests k√∂nnen Sie die Produktivit√§t der Arbeit nicht mit geschlossenen Tickets im Jira verkn√ºpfen, sondern mit der tats√§chlichen Qualit√§t des Softwareprodukts.  Und hier m√ºssen Sie bereits dar√ºber nachdenken, wie Sie zuverl√§ssig schreiben k√∂nnen, damit bei jeder n√§chsten √Ñnderung des Codes vorhandene Funktionen nicht besch√§digt werden.  Damit jede neue Funktion nicht nur im Skript funktioniert, wenn alles in Ordnung ist, sondern auch Fehler korrekt verarbeitet. </p><br><p>  Verantwortung ist die freiwillige Verpflichtung, ein positives Arbeitsergebnis sicherzustellen.  Der Mitarbeiter √ºbernimmt diese Verpflichtung aufgrund seines Charakters und seiner Ausbildung.  Leider ist aufgrund der kulturellen und beruflichen Krise nicht jeder Programmierer bereit, solche Verpflichtungen zu √ºbernehmen. </p><br><h3 id="pishite-srazu-pravilno-bez-oshibok">  "Schreiben Sie jetzt ohne Fehler" </h3><br><p>  Menschen, die mit der Funktionsweise der Softwareentwicklung nicht sehr vertraut sind, stehen Entwicklern, die Fehler erw√§hnen, m√∂glicherweise negativ gegen√ºber. </p><br><p>  - Lassen Sie uns die Anwendung mit automatischen Tests abdecken. <br>  - Warum? <br>  - Um sicherzustellen, dass alles richtig funktioniert und keine Fehler vorliegen. <br>  - Schreiben Sie mit Fehlern?  Haben Sie geringe Qualifikationen?  Schreiben Sie sofort ohne Fehler. <br>  "Ja, aber jeder macht Fehler ..." <br>  - Aber die Firma XYZ sagte zu einem Freund, dass sie Top-Programmierer haben, die fehlerfrei schreiben! </p><br><p>  Daher ist es schwierig, die Entwicklung von Tests an Kunden zu ‚Äûverkaufen‚Äú, die technisch nicht versiert sind.  Infolgedessen ist das Management gezwungen, ein Projekt ohne automatische Tests zu entwickeln, was zu bekannten Problemen f√ºhrt. </p><br><h2 id="vozrazheniya-na-urovne-menedzhmenta">  Einw√§nde des Managements </h2><br><h3 id="c-testami-programmu-pisat-v-dva-raza-dolshe-my-ne-ulozhimsya-v-sroki">  ‚ÄûBei Tests ist das Schreiben eines Programms doppelt so lang.  Wir werden die Fristen nicht einhalten. ‚Äú </h3><br><p>  Diese These erscheint auf den ersten Blick fair.  Es ist wirklich notwendig, Programmiererzeit damit zu verbringen, Tests zu schreiben.  Programmierer und Management ber√ºcksichtigen jedoch nicht, dass die gesamte Produktentwicklungszeit nicht nur die Programmierung, sondern auch das Debuggen und den Support sowie die enormen Kosten f√ºr manuelle Regressionstests nach Korrekturen umfasst. </p><br><p>  Automatisierte Tests haben mehrere Funktionen: </p><br><ol><li>  <strong>√úberpr√ºfen</strong> . <br>  1.1.  Tests stellen sicher, dass das Testobjekt ordnungsgem√§√ü funktioniert. <br>  1.2.  Tests √ºberpr√ºfen die Qualit√§t der Arbeit des Programmierers: ob die Aufgabe gel√∂st ist, ob es irgendwelche Nebenwirkungen in Form von Regressionen gibt. </li><li>  <strong>Diagnose</strong> .  Diagnosetests k√∂nnen die Zeit f√ºr die Suche nach einem Defekt erheblich verk√ºrzen.  Mit Tests k√∂nnen Sie den Ort des Fehlers genau auf die Klasse und Methode und manchmal auf die Codezeile genau bestimmen. </li><li>  <strong>Automatisieren</strong> .  Mit Tests k√∂nnen Sie das Testobjekt schnell und einfach im gew√ºnschten Status zum Debuggen eingeben. </li><li>  <strong>Dokumentieren</strong> . <br>  4.1.  Abnahmetests erfassen die Anforderungen des Kunden an das zu entwickelnde Produkt. <br>  4.2.  Tests zeigen Beispiele f√ºr die Verwendung der entwickelten Komponente, wodurch der Zeitaufwand f√ºr das Studium der Arbeit des Systems durch einen anderen Programmierer verringert wird. </li></ol><br><p>  In einer der von mir konsultierten Organisationen widersetzte sich der Manager der Einf√ºhrung einer Kultur des automatischen Testens: </p><br><p>  - Aber Tests schon lange schreiben!  Wir werden keine Fristen einhalten! <br>  - Haben Sie Fehler, nach denen Sie schon sehr lange gesucht und diese korrigiert haben? <br>  - Ja, es gibt einige. <br>  - Was ist der schwierigste Fall? <br>  - Wir haben 80 Stunden lang nach einem Fehler gesucht. <br>  - 80 Stunden sind zwei Wochen Arbeit des Programmierers.  Wenn Sie sogar eine ganze Woche lang die Automatisierung testen w√ºrden, w√ºrden Sie Monate bei der Diagnose und beim Debuggen Ihrer Anwendung sparen! </p><br><p>  Unsere Organisation hat das Postulat: "Mit Tests ist das Schreiben eines Programms doppelt so schnell!"  und dieses Postulat wird nicht diskutiert.  Es wird nur der Koeffizient 2 diskutiert - manchmal gibt es 3 und 4. Und einige Projekte k√∂nnen ohne kompetente automatische Tests einfach nicht abgeschlossen werden (siehe das √ºberforderte Projekt). </p><br><h3 id="u-nas-uzhe-est-otdel-ruchnogo-testirovaniya-pust-oni-i-testiruyut">  "Wir haben bereits eine manuelle Testabteilung, lassen Sie sie testen." </h3><br><p>  Auf den ersten Blick erscheint die Trennung von Spezialisierungen in Test und Programmierung logisch. </p><br><p>  Aber schauen wir uns die Nachteile des manuellen Testens an: </p><br><ul><li>  Es ist sehr teuer. </li><li>  Es dauert sehr lange.  Beispiel: Das Testskript f√ºr den Tester der mobilen Anwendung ‚ÄûOnline Cinema‚Äú dauert 40 Stunden.  Und das nur f√ºr eine Plattform!  Wenn Sie die Anwendung auf iPhone, iPad, Apple TV, Android und Fire TV testen m√ºssen, m√ºssen Sie 40 √ó 6 = 240 Stunden Arbeitszeit aufwenden. Dies sind anderthalb Monate, was f√ºr kurze Entwicklungszyklen nicht akzeptabel ist. </li><li>  Manuelle Tests unterliegen h√§ufigen menschlichen Fehlern - sie liefern kein objektives und wahres Ergebnis. </li></ul><br><p>  Dar√ºber hinaus k√∂nnen einige Arten von Tests nicht innerhalb einer angemessenen Zeit durchgef√ºhrt werden, da die Anzahl der Kombinationen von Formaten und verschiedenen Testskripten sehr gro√ü ist.  Zum Beispiel: </p><br><ol><li>  Funktion zum Importieren von CSV-Dateien. </li><li>  Parser f√ºr Textdokumente. </li><li>  Finanzinstrumente. </li></ol><br><h2 id="vozrazheniya-na-urovne-metodov">  Einw√§nde auf Methodenebene </h2><br><h3 id="neznanie-metodov-avtomaticheskogo-testirovaniya">  Ignoranz automatischer Testmethoden. </h3><br><p>  Aufgrund der Bildungskrise gibt es an den Universit√§ten keine Disziplinen f√ºr automatische Tests.  Es gibt nur sehr wenige solcher Kurse an kommerziellen IT-Schulen.  Und die bestehenden Kurse sind oberfl√§chlich und von schlechter Qualit√§t.  Daher habe ich unter Programmierern oft einen Stupor erlebt: Sie wissen nicht, wie man nicht triviale Anwendungen testet (schwieriger als 2 + 2 = 4). </p><br><p>  In der Tat ist die Wissenschaft des Testens ziemlich umfangreich.  Zum Beispiel wird nicht jeder Programmierer die Fragen sofort beantworten: a) Was ist Testbarkeit?  b) Was ist Kontrollierbarkeit und Beobachtbarkeit?  c) Welche Entwurfsmuster verbessern die Testbarkeit der Anwendung?  Usw. </p><br><h3 id="programmisty-ne-znayut-chto-oni-pishut-kak-ono-vyglyadit-kakie-budut-funkcii-i-interfeysy">  Programmierer wissen nicht, was sie schreiben, wie es aussieht, welche Funktionen und Schnittstellen es geben wird. </h3><br><p>  Es ist sehr schwierig zu testen, was nicht klar ist, wie es aussieht.  Mit anderen Worten, ohne die vordefinierten Anforderungen f√ºr die Anwendung kann der Programmierer nicht verstehen, was von ihm erwartet wird. </p><br><p>  Die Besonderheit einiger Projekte besteht darin, dass sie unter Verwendung der Minimum Viable Product-Technologie entwickelt werden, die mit anderen Worten wie folgt beschrieben werden kann: ‚ÄûLassen Sie uns zumindest etwas f√ºr die minimale Zeit und das minimale Budget tun‚Äú, und der Programmierer wird vom Kunden oder Management als Analyst, Designer, Architekt betrachtet. Programmierer und Tester in einer Flasche.  Bei diesem Ansatz wird die formale Phase des Entwurfs eines Softwaresystems ausgeschlossen: die Definition von Gesch√§ftslogik, Dom√§ne, Komponentenschnittstellen sowie deren interne Organisation ihrer Beziehung zwischen ihnen.  Es gibt keine formalisierte Architektur, keine Schnittstellen, keine vorgeschriebenen Gesch√§ftsprozesse - es ist nicht klar, was getestet werden soll, √ºber welche Schnittstellen und was das erwartete Ergebnis ist. </p><br><h3 id="netestoprigodnyy-kod">  Unangemessener Code. </h3><br><p>  Testbarkeit ist eine Projekteigenschaft, die angibt, wie einfach sie getestet werden kann.  Die Testeignung wird durch zwei weitere Eigenschaften bestimmt: Kontrollierbarkeit und Beobachtbarkeit.  Verwaltbarkeit - Eine Eigenschaft, die bestimmt, wie einfach es ist, eine Anwendung zum Testen in den gew√ºnschten Zustand zu versetzen (Voraussetzungen erf√ºllen).  Beobachtbarkeit - Wie einfach es ist, den Zustand nach dem Test zu betrachten, vergleichen Sie ihn mit dem erwarteten. </p><br><p>  Beispielsweise ist es sehr schwierig, die Zwei-Faktor-Authentifizierung mithilfe von SMS automatisch zu testen, da die Funktion zum Empfangen von SMS au√üerhalb des Bereichs der automatisierten Testumgebung liegt.  Ein solches System ist ungeeignet. </p><br><p>  Angesichts eines ungeeigneten Systems gibt der Programmierer auf und vermeidet das Testen eines solchen Systems. </p><br><h3 id="podgotovka-testovyh-dannyh">  Vorbereitung der Testdaten. </h3><br><p>  Einer der nicht offensichtlichen Widerst√§nde ist die Erstellung von Testdaten und Standards.  Beispiel: Der Anfangszustand der Datenbank, f√ºr die Tests durchgef√ºhrt werden.  Die Erstellung von Testdaten kann viel Zeit und Routinearbeit erfordern, daher wird diese Arbeit von Programmierern als undankbar und uninteressant angesehen. </p><br><p>  L√∂sung: </p><br><ul><li>  Entwicklung von Referenzwerten und Beispielen in der Phase der Entwicklung von Abnahmetests - sie werden auch dazu beitragen, Konflikte mit dem Kunden in der Phase der Abnahme der Arbeit zu l√∂sen. </li><li>  Entwicklung von Referenzwerten in der Phase des Systemdesigns.  Beispielsweise erleichtern Standard-HTTP-Anforderungen und -Antworten die Integration von Client und Server. </li><li>  Entwicklung spezieller Verfahren zum Zusammenstellen von Datenbanken, bei denen der erforderliche Status der Datenbank automatisch und nicht manuell erstellt wird </li><li>  Verwendung der Vorlage Objektmutter [Fowler, Schuh, Peter und Stephanie Punke.  "Vereinfachen der Erstellung von Testobjekten in XP."  XP-Universum.  2003], mit dessen Hilfe Objekte im erforderlichen Zustand einfach zugeordnet und initialisiert werden k√∂nnen. </li></ul><br><h3 id="obsluzhivanie-testov">  Testdienst. </h3><br><p>  W√§hrend der Entwicklung eines Projekts k√∂nnen sich die Anforderungen (Kl√§rung, √Ñnderung) √§ndern.  Oder es kann zu internem Refactoring kommen, was zu einer √Ñnderung der Klassenschnittstellen f√ºhrt.  Mit der √Ñnderung der Anforderungen √§ndern sich auch die Akzeptanzkriterien einer bestimmten Funktion und damit auch die Tests.  Irgendwann kann der Programmierer die Wartung der Tests verweigern, dh sie auf dem neuesten Stand halten. </p><br><p>  L√∂sung: </p><br><ul><li>  Verwenden der Vorlage "Adapter", um die Logik des Tests von der zu testenden Schnittstelle zu entkoppeln; </li><li>  Verwendung von hochrangigen Tests (Gurke, Gurke, gegeben-wann-dann); </li><li>  Siehe L√∂sung gegen Widerstand ‚ÄûVorbereitung der Testdaten‚Äú. </li></ul><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Es besteht kein Zweifel, dass Software zuverl√§ssig sein muss: die Erwartungen der Kunden √ºbertreffen.  Automatisierte Tests sind nicht die einzige, sondern wichtige Komponente bei der Entwicklung zuverl√§ssiger Software. </p><br><p>  Ich formulierte typische Einw√§nde und Hindernisse f√ºr die Implementierung automatischer Tests, auf die ich pers√∂nlich in meiner Organisation sowie in den von mir konsultierten Organisationen gesto√üen bin. </p><br><p>  Der Artikel beschreibt nur Probleme und geht kaum auf L√∂sungswege ein.  Im Allgemeinen scheint mir die Strategie zur L√∂sung dieser Probleme folgenderma√üen zu sein: </p><br><ol><li>  Bildung und F√∂rderung einer neuen Kultur des IT-Designs, die Zuverl√§ssigkeit, Stolz und pers√∂nliche Verantwortung f√ºr das Ergebnis bedeutet. </li><li>  Entwicklung neuer hoher Standards f√ºr Codetests. </li><li>  Entwicklung und Durchf√ºhrung von Schulungen. </li><li>  Die Einf√ºhrung von Motivation in die Karriere von Programmierern und Managern, verbunden mit der Qualit√§t der zu entwickelnden Softwareprodukte sowie mit den F√§higkeiten des automatischen Testens. </li></ol><br><p>  Das Wichtigste, was ich verstanden habe, ist, dass die Probleme auf verschiedenen Ebenen liegen: technologisch, methodisch, verwaltungstechnisch und kulturell.  Und sie m√ºssen auf angemessenen Ebenen angegangen werden.  Es ist sehr schwierig, automatisierte Tests zu implementieren, wenn der Programmierer nicht in testgeeigneten Entwurfsmethoden geschult ist oder wenn das Management keine Kultur zuverl√§ssiger Programmierung in der Organisation unterst√ºtzt. </p><br><p>  Ich bin dankbar f√ºr Beispiele aus Ihrer Praxis, wie einfach oder wie schwierig es war, automatisierte Tests in Ihrem Unternehmen durchzuf√ºhren.  Welche Probleme hatten Sie?  Wie hast du sie gel√∂st? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418491/">https://habr.com/ru/post/de418491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418481/index.html">Leben in Israel - Einige IT-bezogene Momente</a></li>
<li><a href="../de418483/index.html">So komprimieren Sie den Bootloader f√ºr STM8 auf eine Gr√∂√üe von 8 Byte im FLASH-Speicher</a></li>
<li><a href="../de418485/index.html">Breaking Bad 3 - √úberquere den dunklen F√∂rster</a></li>
<li><a href="../de418487/index.html">√úber die Arbeit in Deutschland</a></li>
<li><a href="../de418489/index.html">Meisterwerke des Welts√§ulenbaus: Entwicklung eines Drei-Wege-Standard-Studiokults von JBL</a></li>
<li><a href="../de418493/index.html">Bluetooth Ich-Geschichte</a></li>
<li><a href="../de418497/index.html">"Ich erkenne dich nicht im Make-up" (c)</a></li>
<li><a href="../de418499/index.html">SAMBA classicupgrade Erfahrung auf Debian 8</a></li>
<li><a href="../de418501/index.html">Opfer der DSGVO: die ihre Arbeit aufgrund einer neuen Regelung personenbezogener Daten bereits eingestellt haben</a></li>
<li><a href="../de418503/index.html">Nach 2020 wird Gro√übritannien den ersten Raumhafen erwerben - in Schottland</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>