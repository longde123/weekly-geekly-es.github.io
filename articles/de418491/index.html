<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👀 🧕🏼 🙊 Testen Sie den Automatisierungswiderstand 👏🏼 🦌 👃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Trotz der Tatsache, dass es Unit-Testing-Technologien seit 30 Jahren gibt (Kent Beck schrieb 1989 den Artikel „Simple Smalltalk Testing: With Patterns...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testen Sie den Automatisierungswiderstand</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418491/"><p>  Trotz der Tatsache, dass es Unit-Testing-Technologien seit 30 Jahren gibt (Kent Beck schrieb 1989 den Artikel „Simple Smalltalk Testing: With Patterns“), besitzen nicht alle Programmierer diese Technologie, und nicht alle Unternehmen haben das automatische Testen zu einem Teil ihrer Unternehmenskultur gemacht. .  Trotz der offensichtlichen Vorteile des automatischen Testens ist der Verhaltenswiderstand immer noch recht stark.  Wer versucht hat, automatisierte Tests zu implementieren, weiß, dass es immer einen Grund gibt, warum dies nicht möglich ist. </p><br><p>  Aus meiner persönlichen Erfahrung mit der Implementierung zuverlässiger Programmiermethoden in meinem Unternehmen, in den von mir konsultierten Unternehmen, der Kommunikation auf Konferenzen und auch aus öffentlich zugänglichen Quellen habe ich typische Einwände und Widerstände formuliert, die die Implementierung einer Kultur des automatischen Testens behindern. </p><br><p>  Ich habe alle Einwände in einer Pyramide zuverlässiger Programmierung zusammengefasst, die vier Ebenen umfasst: <a name="habracut"></a></p><br><ul><li>  <strong>Die Berufskultur</strong> (die höchste Ebene, die Grundlage für zuverlässige Programmierung) besteht aus einer Reihe von Normen, ungeschriebenen Regeln und Überzeugungen der Mitarbeiter, die ihn bei seiner Arbeit leiten.  Beispiel: "Das Senden von Code, der durch Tests aufgedeckt wurde, an das Repository ist schlecht", "Das Schweigen über gefundene Fehler im Code ist eine Schande". </li><li>  <strong>Management</strong> sind die von der Organisation verabschiedeten Verfahren, Richtlinien, Regeln sowie der Wille (die Entscheidung) der Führungskräfte.  Zum Beispiel: „Jede entwickelte Anwendungsfunktion muss einen Überprüfungscode übergeben.  Keine Ausnahmen! " </li><li>  <strong>Methoden</strong> sind wissenschaftliche Ansätze, Methoden zur Lösung eines bestimmten Problems.  Beispiel: "Wenn die Funktion der Anwendung schwer zu testen ist, müssen Sie die Testbarkeit der Anwendung durch Anwenden der Vorlage" Abhängigkeitsinjektion "verbessern." </li><li>  <strong>Technologien</strong> (die unterste Ebene) sind Programmiersprachen, Bibliotheken, Frameworks und Tools.  Zum Beispiel JUnit, Selen, XCTest und so weiter. </li></ul><br><p><img src="https://habrastorage.org/webt/ky/wa/ev/kywaevzql1sl53klb8pzmazzwcm.png"></p><br><p>  Warum ist eine solche Aufteilung notwendig?  Weil das Problem einer Ebene durch Methoden derselben Ebene oder durch Methoden einer höheren Ebene gelöst wird.  Wenn es beispielsweise für eine Organisation nicht üblich ist, automatische Tests zu schreiben (das Problem der Berufskultur), kann dieses Problem nicht durch eine detaillierte Beschreibung des Testgeschäftsprozesses (Ebene „Management“) oder durch die Installation eines modernen Frameworks (Ebene „Technologie“) gelöst werden.  Ich gebe eine Garantie, dass in einer Woche trotz des genehmigten Geschäftsprozesses niemand Tests schreiben wird. </p><br><h2 id="vozrazheniya-kulturnogo-urovnya">  Kulturelle Einwände </h2><br><h3 id="moi-programmy-ne-lomayutsya-ya-ne-vizhu-nuzhdy-v-testirovanii">  „Meine Programme brechen nicht.  Ich sehe keine Notwendigkeit zum Testen. " </h3><br><p>  Ich habe diese Aussage von Anfängern oder übermäßig selbstbewussten Programmierern gehört. <br>  Natürlich kann eine einmal geschriebene Funktion nicht von alleine brechen.  Hier ist es jedoch wichtig zu verstehen, dass das Programm im Laufe der Zeit möglicherweise Unterstützung, die Einführung neuer Funktionen oder Ergänzungen bestehender Funktionen benötigt.  Die Komplexität der Programme - die Anzahl der Klassen und die Abhängigkeiten zwischen ihnen - ist ziemlich groß, und schließlich tritt früher oder später ein Fehler auf, nachdem eine andere neue Funktion erstellt oder eine vorhandene verbessert wurde.  Ein automatischer Test würde eine solche Regression erkennen. </p><br><p>  Darüber hinaus ist ein solcher Einwand häufig von unerfahrenen Programmierern zu hören, die kein Testkonzept haben.  Beispielsweise werden nur Abstürze als Ausfall betrachtet, keine Funktionsfehler. </p><br><p>  Bei einem der von mir durchgeführten Interviews fand folgender Dialog statt: </p><br><p>  - Haben Sie die Fähigkeiten zum automatischen Testen? <br>  - Nein, ich habe einfache Programme geschrieben, es gab nichts zu brechen. <br>  - Was ist Ihre Motivation, den Job zu wechseln? <br>  - Ich möchte komplexe Anwendungen schreiben. </p><br><p>  Ich weiß sehr gut, wie das endet.  Dem Programmierer wird vertraut, dass er ein komplexeres Programm entwickelt, er kennt jedoch die Methoden des automatischen Testens nicht, er kann die Anwendung nicht qualitativ testen und er kann den Umfang des Projekts nicht bewältigen, was zu einer Störung des Projekts, einer Kostenüberschreitung der Entwicklung und einem Reputationsverlust führen wird.  Weil ich persönlich Projekte geleitet habe, bei denen ich den Umfang des Projekts nicht bewältigen konnte und es gerade wegen des Fehlens automatischer Tests nicht bestanden habe. </p><br><h3 id="nezhelanie-brat-otvetstvennost-za-kachestvo-koda-za-testirovanie">  Widerwillen, Verantwortung für die Qualität des Codes zu übernehmen, für Tests. </h3><br><p>  Automatisierte Tests sind die einzige Quelle für betriebliche und objektive Informationen über die wahre Qualität eines Softwareprodukts.  Mit anderen Worten, der Programmierer hat immer einen Vorgesetzten hinter seinem Rücken, der dem Management jederzeit berichten kann, wie gut der Programmierer seine Arbeit macht.  Mit automatisierten Tests können Sie die Produktivität der Arbeit nicht mit geschlossenen Tickets im Jira verknüpfen, sondern mit der tatsächlichen Qualität des Softwareprodukts.  Und hier müssen Sie bereits darüber nachdenken, wie Sie zuverlässig schreiben können, damit bei jeder nächsten Änderung des Codes vorhandene Funktionen nicht beschädigt werden.  Damit jede neue Funktion nicht nur im Skript funktioniert, wenn alles in Ordnung ist, sondern auch Fehler korrekt verarbeitet. </p><br><p>  Verantwortung ist die freiwillige Verpflichtung, ein positives Arbeitsergebnis sicherzustellen.  Der Mitarbeiter übernimmt diese Verpflichtung aufgrund seines Charakters und seiner Ausbildung.  Leider ist aufgrund der kulturellen und beruflichen Krise nicht jeder Programmierer bereit, solche Verpflichtungen zu übernehmen. </p><br><h3 id="pishite-srazu-pravilno-bez-oshibok">  "Schreiben Sie jetzt ohne Fehler" </h3><br><p>  Menschen, die mit der Funktionsweise der Softwareentwicklung nicht sehr vertraut sind, stehen Entwicklern, die Fehler erwähnen, möglicherweise negativ gegenüber. </p><br><p>  - Lassen Sie uns die Anwendung mit automatischen Tests abdecken. <br>  - Warum? <br>  - Um sicherzustellen, dass alles richtig funktioniert und keine Fehler vorliegen. <br>  - Schreiben Sie mit Fehlern?  Haben Sie geringe Qualifikationen?  Schreiben Sie sofort ohne Fehler. <br>  "Ja, aber jeder macht Fehler ..." <br>  - Aber die Firma XYZ sagte zu einem Freund, dass sie Top-Programmierer haben, die fehlerfrei schreiben! </p><br><p>  Daher ist es schwierig, die Entwicklung von Tests an Kunden zu „verkaufen“, die technisch nicht versiert sind.  Infolgedessen ist das Management gezwungen, ein Projekt ohne automatische Tests zu entwickeln, was zu bekannten Problemen führt. </p><br><h2 id="vozrazheniya-na-urovne-menedzhmenta">  Einwände des Managements </h2><br><h3 id="c-testami-programmu-pisat-v-dva-raza-dolshe-my-ne-ulozhimsya-v-sroki">  „Bei Tests ist das Schreiben eines Programms doppelt so lang.  Wir werden die Fristen nicht einhalten. “ </h3><br><p>  Diese These erscheint auf den ersten Blick fair.  Es ist wirklich notwendig, Programmiererzeit damit zu verbringen, Tests zu schreiben.  Programmierer und Management berücksichtigen jedoch nicht, dass die gesamte Produktentwicklungszeit nicht nur die Programmierung, sondern auch das Debuggen und den Support sowie die enormen Kosten für manuelle Regressionstests nach Korrekturen umfasst. </p><br><p>  Automatisierte Tests haben mehrere Funktionen: </p><br><ol><li>  <strong>Überprüfen</strong> . <br>  1.1.  Tests stellen sicher, dass das Testobjekt ordnungsgemäß funktioniert. <br>  1.2.  Tests überprüfen die Qualität der Arbeit des Programmierers: ob die Aufgabe gelöst ist, ob es irgendwelche Nebenwirkungen in Form von Regressionen gibt. </li><li>  <strong>Diagnose</strong> .  Diagnosetests können die Zeit für die Suche nach einem Defekt erheblich verkürzen.  Mit Tests können Sie den Ort des Fehlers genau auf die Klasse und Methode und manchmal auf die Codezeile genau bestimmen. </li><li>  <strong>Automatisieren</strong> .  Mit Tests können Sie das Testobjekt schnell und einfach im gewünschten Status zum Debuggen eingeben. </li><li>  <strong>Dokumentieren</strong> . <br>  4.1.  Abnahmetests erfassen die Anforderungen des Kunden an das zu entwickelnde Produkt. <br>  4.2.  Tests zeigen Beispiele für die Verwendung der entwickelten Komponente, wodurch der Zeitaufwand für das Studium der Arbeit des Systems durch einen anderen Programmierer verringert wird. </li></ol><br><p>  In einer der von mir konsultierten Organisationen widersetzte sich der Manager der Einführung einer Kultur des automatischen Testens: </p><br><p>  - Aber Tests schon lange schreiben!  Wir werden keine Fristen einhalten! <br>  - Haben Sie Fehler, nach denen Sie schon sehr lange gesucht und diese korrigiert haben? <br>  - Ja, es gibt einige. <br>  - Was ist der schwierigste Fall? <br>  - Wir haben 80 Stunden lang nach einem Fehler gesucht. <br>  - 80 Stunden sind zwei Wochen Arbeit des Programmierers.  Wenn Sie sogar eine ganze Woche lang die Automatisierung testen würden, würden Sie Monate bei der Diagnose und beim Debuggen Ihrer Anwendung sparen! </p><br><p>  Unsere Organisation hat das Postulat: "Mit Tests ist das Schreiben eines Programms doppelt so schnell!"  und dieses Postulat wird nicht diskutiert.  Es wird nur der Koeffizient 2 diskutiert - manchmal gibt es 3 und 4. Und einige Projekte können ohne kompetente automatische Tests einfach nicht abgeschlossen werden (siehe das überforderte Projekt). </p><br><h3 id="u-nas-uzhe-est-otdel-ruchnogo-testirovaniya-pust-oni-i-testiruyut">  "Wir haben bereits eine manuelle Testabteilung, lassen Sie sie testen." </h3><br><p>  Auf den ersten Blick erscheint die Trennung von Spezialisierungen in Test und Programmierung logisch. </p><br><p>  Aber schauen wir uns die Nachteile des manuellen Testens an: </p><br><ul><li>  Es ist sehr teuer. </li><li>  Es dauert sehr lange.  Beispiel: Das Testskript für den Tester der mobilen Anwendung „Online Cinema“ dauert 40 Stunden.  Und das nur für eine Plattform!  Wenn Sie die Anwendung auf iPhone, iPad, Apple TV, Android und Fire TV testen müssen, müssen Sie 40 × 6 = 240 Stunden Arbeitszeit aufwenden. Dies sind anderthalb Monate, was für kurze Entwicklungszyklen nicht akzeptabel ist. </li><li>  Manuelle Tests unterliegen häufigen menschlichen Fehlern - sie liefern kein objektives und wahres Ergebnis. </li></ul><br><p>  Darüber hinaus können einige Arten von Tests nicht innerhalb einer angemessenen Zeit durchgeführt werden, da die Anzahl der Kombinationen von Formaten und verschiedenen Testskripten sehr groß ist.  Zum Beispiel: </p><br><ol><li>  Funktion zum Importieren von CSV-Dateien. </li><li>  Parser für Textdokumente. </li><li>  Finanzinstrumente. </li></ol><br><h2 id="vozrazheniya-na-urovne-metodov">  Einwände auf Methodenebene </h2><br><h3 id="neznanie-metodov-avtomaticheskogo-testirovaniya">  Ignoranz automatischer Testmethoden. </h3><br><p>  Aufgrund der Bildungskrise gibt es an den Universitäten keine Disziplinen für automatische Tests.  Es gibt nur sehr wenige solcher Kurse an kommerziellen IT-Schulen.  Und die bestehenden Kurse sind oberflächlich und von schlechter Qualität.  Daher habe ich unter Programmierern oft einen Stupor erlebt: Sie wissen nicht, wie man nicht triviale Anwendungen testet (schwieriger als 2 + 2 = 4). </p><br><p>  In der Tat ist die Wissenschaft des Testens ziemlich umfangreich.  Zum Beispiel wird nicht jeder Programmierer die Fragen sofort beantworten: a) Was ist Testbarkeit?  b) Was ist Kontrollierbarkeit und Beobachtbarkeit?  c) Welche Entwurfsmuster verbessern die Testbarkeit der Anwendung?  Usw. </p><br><h3 id="programmisty-ne-znayut-chto-oni-pishut-kak-ono-vyglyadit-kakie-budut-funkcii-i-interfeysy">  Programmierer wissen nicht, was sie schreiben, wie es aussieht, welche Funktionen und Schnittstellen es geben wird. </h3><br><p>  Es ist sehr schwierig zu testen, was nicht klar ist, wie es aussieht.  Mit anderen Worten, ohne die vordefinierten Anforderungen für die Anwendung kann der Programmierer nicht verstehen, was von ihm erwartet wird. </p><br><p>  Die Besonderheit einiger Projekte besteht darin, dass sie unter Verwendung der Minimum Viable Product-Technologie entwickelt werden, die mit anderen Worten wie folgt beschrieben werden kann: „Lassen Sie uns zumindest etwas für die minimale Zeit und das minimale Budget tun“, und der Programmierer wird vom Kunden oder Management als Analyst, Designer, Architekt betrachtet. Programmierer und Tester in einer Flasche.  Bei diesem Ansatz wird die formale Phase des Entwurfs eines Softwaresystems ausgeschlossen: die Definition von Geschäftslogik, Domäne, Komponentenschnittstellen sowie deren interne Organisation ihrer Beziehung zwischen ihnen.  Es gibt keine formalisierte Architektur, keine Schnittstellen, keine vorgeschriebenen Geschäftsprozesse - es ist nicht klar, was getestet werden soll, über welche Schnittstellen und was das erwartete Ergebnis ist. </p><br><h3 id="netestoprigodnyy-kod">  Unangemessener Code. </h3><br><p>  Testbarkeit ist eine Projekteigenschaft, die angibt, wie einfach sie getestet werden kann.  Die Testeignung wird durch zwei weitere Eigenschaften bestimmt: Kontrollierbarkeit und Beobachtbarkeit.  Verwaltbarkeit - Eine Eigenschaft, die bestimmt, wie einfach es ist, eine Anwendung zum Testen in den gewünschten Zustand zu versetzen (Voraussetzungen erfüllen).  Beobachtbarkeit - Wie einfach es ist, den Zustand nach dem Test zu betrachten, vergleichen Sie ihn mit dem erwarteten. </p><br><p>  Beispielsweise ist es sehr schwierig, die Zwei-Faktor-Authentifizierung mithilfe von SMS automatisch zu testen, da die Funktion zum Empfangen von SMS außerhalb des Bereichs der automatisierten Testumgebung liegt.  Ein solches System ist ungeeignet. </p><br><p>  Angesichts eines ungeeigneten Systems gibt der Programmierer auf und vermeidet das Testen eines solchen Systems. </p><br><h3 id="podgotovka-testovyh-dannyh">  Vorbereitung der Testdaten. </h3><br><p>  Einer der nicht offensichtlichen Widerstände ist die Erstellung von Testdaten und Standards.  Beispiel: Der Anfangszustand der Datenbank, für die Tests durchgeführt werden.  Die Erstellung von Testdaten kann viel Zeit und Routinearbeit erfordern, daher wird diese Arbeit von Programmierern als undankbar und uninteressant angesehen. </p><br><p>  Lösung: </p><br><ul><li>  Entwicklung von Referenzwerten und Beispielen in der Phase der Entwicklung von Abnahmetests - sie werden auch dazu beitragen, Konflikte mit dem Kunden in der Phase der Abnahme der Arbeit zu lösen. </li><li>  Entwicklung von Referenzwerten in der Phase des Systemdesigns.  Beispielsweise erleichtern Standard-HTTP-Anforderungen und -Antworten die Integration von Client und Server. </li><li>  Entwicklung spezieller Verfahren zum Zusammenstellen von Datenbanken, bei denen der erforderliche Status der Datenbank automatisch und nicht manuell erstellt wird </li><li>  Verwendung der Vorlage Objektmutter [Fowler, Schuh, Peter und Stephanie Punke.  "Vereinfachen der Erstellung von Testobjekten in XP."  XP-Universum.  2003], mit dessen Hilfe Objekte im erforderlichen Zustand einfach zugeordnet und initialisiert werden können. </li></ul><br><h3 id="obsluzhivanie-testov">  Testdienst. </h3><br><p>  Während der Entwicklung eines Projekts können sich die Anforderungen (Klärung, Änderung) ändern.  Oder es kann zu internem Refactoring kommen, was zu einer Änderung der Klassenschnittstellen führt.  Mit der Änderung der Anforderungen ändern sich auch die Akzeptanzkriterien einer bestimmten Funktion und damit auch die Tests.  Irgendwann kann der Programmierer die Wartung der Tests verweigern, dh sie auf dem neuesten Stand halten. </p><br><p>  Lösung: </p><br><ul><li>  Verwenden der Vorlage "Adapter", um die Logik des Tests von der zu testenden Schnittstelle zu entkoppeln; </li><li>  Verwendung von hochrangigen Tests (Gurke, Gurke, gegeben-wann-dann); </li><li>  Siehe Lösung gegen Widerstand „Vorbereitung der Testdaten“. </li></ul><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Es besteht kein Zweifel, dass Software zuverlässig sein muss: die Erwartungen der Kunden übertreffen.  Automatisierte Tests sind nicht die einzige, sondern wichtige Komponente bei der Entwicklung zuverlässiger Software. </p><br><p>  Ich formulierte typische Einwände und Hindernisse für die Implementierung automatischer Tests, auf die ich persönlich in meiner Organisation sowie in den von mir konsultierten Organisationen gestoßen bin. </p><br><p>  Der Artikel beschreibt nur Probleme und geht kaum auf Lösungswege ein.  Im Allgemeinen scheint mir die Strategie zur Lösung dieser Probleme folgendermaßen zu sein: </p><br><ol><li>  Bildung und Förderung einer neuen Kultur des IT-Designs, die Zuverlässigkeit, Stolz und persönliche Verantwortung für das Ergebnis bedeutet. </li><li>  Entwicklung neuer hoher Standards für Codetests. </li><li>  Entwicklung und Durchführung von Schulungen. </li><li>  Die Einführung von Motivation in die Karriere von Programmierern und Managern, verbunden mit der Qualität der zu entwickelnden Softwareprodukte sowie mit den Fähigkeiten des automatischen Testens. </li></ol><br><p>  Das Wichtigste, was ich verstanden habe, ist, dass die Probleme auf verschiedenen Ebenen liegen: technologisch, methodisch, verwaltungstechnisch und kulturell.  Und sie müssen auf angemessenen Ebenen angegangen werden.  Es ist sehr schwierig, automatisierte Tests zu implementieren, wenn der Programmierer nicht in testgeeigneten Entwurfsmethoden geschult ist oder wenn das Management keine Kultur zuverlässiger Programmierung in der Organisation unterstützt. </p><br><p>  Ich bin dankbar für Beispiele aus Ihrer Praxis, wie einfach oder wie schwierig es war, automatisierte Tests in Ihrem Unternehmen durchzuführen.  Welche Probleme hatten Sie?  Wie hast du sie gelöst? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418491/">https://habr.com/ru/post/de418491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418481/index.html">Leben in Israel - Einige IT-bezogene Momente</a></li>
<li><a href="../de418483/index.html">So komprimieren Sie den Bootloader für STM8 auf eine Größe von 8 Byte im FLASH-Speicher</a></li>
<li><a href="../de418485/index.html">Breaking Bad 3 - Überquere den dunklen Förster</a></li>
<li><a href="../de418487/index.html">Über die Arbeit in Deutschland</a></li>
<li><a href="../de418489/index.html">Meisterwerke des Weltsäulenbaus: Entwicklung eines Drei-Wege-Standard-Studiokults von JBL</a></li>
<li><a href="../de418493/index.html">Bluetooth Ich-Geschichte</a></li>
<li><a href="../de418497/index.html">"Ich erkenne dich nicht im Make-up" (c)</a></li>
<li><a href="../de418499/index.html">SAMBA classicupgrade Erfahrung auf Debian 8</a></li>
<li><a href="../de418501/index.html">Opfer der DSGVO: die ihre Arbeit aufgrund einer neuen Regelung personenbezogener Daten bereits eingestellt haben</a></li>
<li><a href="../de418503/index.html">Nach 2020 wird Großbritannien den ersten Raumhafen erwerben - in Schottland</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>