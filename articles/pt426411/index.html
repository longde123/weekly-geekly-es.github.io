<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏾 🍅 🎹 Desenvolvendo Classes de Descritores C ++ / CLI 👨🏼‍💻 🤸🏾 🤱🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em C ++ / CLI, as chamadas classes de descritor são frequentemente usadas - classes gerenciadas que possuem um ponteiro para a classe nativa como memb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desenvolvendo Classes de Descritores C ++ / CLI</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426411/"><hr><p>  <i>Em C ++ / CLI, as chamadas classes de descritor são frequentemente usadas - classes gerenciadas que possuem um ponteiro para a classe nativa como membro.</i>  <i>O artigo discute um esquema conveniente e compacto para gerenciar a vida útil do objeto nativo correspondente, com base no uso de modelos gerenciados.</i>  <i>Casos complexos de finalização são considerados.</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1>  Sumário </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Introdução</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Padrão básico de descarte em C ++ / CLI</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Definição de destruidor e finalizador</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando semântica de Pilha</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2. Modelos gerenciados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ponteiros inteligentes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exemplo de uso</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Opções de finalização mais complexas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.3.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloqueio do finalizador</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.3.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Usando o SafeHandle</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Referências</a> <br></p><br><a name="id-introdaction"></a><br><h1>  1. Introdução </h1><br><p> C ++ / CLI - uma das linguagens do .NET Framework - raramente é usada para desenvolver grandes projetos independentes.  Seu principal objetivo é criar assemblies para interação do .NET com código nativo (não gerenciado).  Consequentemente, as classes denominadas classes de descritor são amplamente usadas, classes gerenciadas que possuem um ponteiro para a classe nativa como membro.  Normalmente, essa classe de descritor possui o objeto nativo correspondente, ou seja, deve excluí-lo no momento apropriado.  É bastante natural tornar essa classe isenta, ou seja, implementar a <code>System::IDisposable</code> .  A implementação dessa interface no .NET deve seguir um padrão especial chamado Basic Dispose [Cwalina].  Um recurso notável do C ++ / CLI é que o compilador assume quase todo o trabalho de rotina da implementação desse modelo, enquanto no C # quase tudo precisa ser feito manualmente. </p><br><a name="id-1"></a><br><h1>  1. Padrão básico de descarte em C ++ / CLI </h1><br><p>  Existem duas maneiras principais de implementar este modelo. </p><br><a name="id-1-1"></a><br><h2>  1.1  Definição de destruidor e finalizador </h2><br><p>  Nesse caso, o destruidor e o finalizador devem ser definidos na classe gerenciada, o compilador fará o resto. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span>    ~X() {<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} <span class="hljs-comment"><span class="hljs-comment">//     !X() {/* ... */} //  // ... };</span></span></code> </pre> <br><p>  Em particular, o compilador faz o seguinte: </p><br><ol><li>  Para a classe <code>X</code> implementa a <code>System::IDisposable</code> . </li><li>  No <code>X::Dispose()</code> fornece uma chamada para o destruidor, uma chamada para o destruidor da classe base (se houver) e uma chamada para <code>GC::SupressFinalize()</code> . </li><li>  Substitui <code>System::Object::Finalize()</code> , onde fornece uma chamada para o finalizador e finalizadores das classes base (se houver). </li></ol><br><p>  Você pode especificar a herança de <code>System::IDisposable</code> explicitamente, mas não pode definir <code>X::Dispose()</code> . </p><br><a name="id-1-2"></a><br><h2>  1.2  Usando semântica de Pilha </h2><br><p>  O padrão Dispose básico também é implementado pelo compilador se a classe tiver um membro do tipo liberado e for declarada usando a semântica da pilha.  Isso significa que o nome do tipo sem o limite (' <code>^</code> ') é usado para a declaração, e a inicialização ocorre na lista de inicialização do construtor, e não usando <code>gcnew</code> .  A semântica da pilha é descrita em [Hogenson]. </p><br><p>  Aqui está um exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> :</span></span> System::IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    R(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  // ... }; public ref class X {    R m_R; //   R^ m_R public:    X(/*  */) //         : m_R(/*  */) //   m_R = gcnew R(/*  */)    {/* ... */} // ... };</span></span></code> </pre> <br><p>  O compilador nesse caso faz o seguinte: </p><br><ol><li>  Para a classe <code>X</code> implementa a <code>System::IDisposable</code> . </li><li>  No <code>X::Dispose()</code> fornece uma chamada para <code>R::Dispose()</code> para <code>m_R</code> . </li></ol><br><p>  A finalização é determinada pela funcionalidade correspondente da classe <code>R</code>  Como no caso anterior, a herança de <code>System::IDisposable</code> pode ser especificada explicitamente, mas você não pode definir <code>X::Dispose()</code> .  Naturalmente, a classe pode ter outros membros declarados usando a semântica da pilha, e sua chamada <code>Dispose()</code> também é fornecida para eles. </p><br><a name="id-2"></a><br><h1>  2. Modelos gerenciados </h1><br><p>  E, finalmente, outro ótimo recurso do C ++ / CLI torna possível simplificar a criação de classes de descritores o máximo possível.  Estamos falando de modelos gerenciados.  Estes não são genéricos, mas modelos reais, como no C ++ clássico, mas os modelos não são nativos, mas classes gerenciadas.  A instanciação de tais padrões leva à criação de classes gerenciadas que podem ser usadas como classes base ou como membros de outras classes dentro de um assembly.  Modelos gerenciados são descritos em [Hogenson]. </p><br><a name="id-2-1"></a><br><h2>  2.1  Ponteiros inteligentes </h2><br><p>  Modelos gerenciados permitem criar classes como ponteiros inteligentes que contêm um ponteiro para o objeto nativo como membro e fornecem sua remoção no destruidor e finalizador.  Esses indicadores inteligentes podem ser usados ​​como classes base ou membros (naturalmente, usando semântica de pilha) ao desenvolver classes de descritores que são automaticamente liberadas. </p><br><p>  Aqui está um exemplo de tais padrões.  O primeiro modelo é um modelo base, o segundo é destinado ao uso como classe base e o terceiro como membro da classe.  Esses modelos têm um parâmetro de modelo (nativo) projetado para excluir um objeto.  A classe de exclusão, por padrão, exclui o objeto com o operador de <code>delete</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  , -  , T —   template &lt;typename T&gt; struct DefDeleter {    void operator()(T* p) const { delete p; } }; //  , //      //  , T —  , D — - template &lt;typename T, typename D&gt; public ref class ImplPtrBase : System::IDisposable {    T* m_Ptr;    void Delete()    {        if (m_Ptr != nullptr)        {            D del;            del(m_Ptr);            m_Ptr = nullptr;        }    }    ~ImplPtrBase() { Delete(); }    !ImplPtrBase() { Delete(); } protected:    ImplPtrBase(T* p) : m_Ptr(p) {}    T* Ptr() { return m_Ptr; } }; //        template &lt;typename T, typename D = DefDeleter&lt;T&gt;&gt; public ref class ImplPtr : ImplPtrBase&lt;T, D&gt; { protected:    ImplPtr(T* p) : ImplPtrBase(p) {} public:    property bool IsValid    {        bool get() { return (ImplPtrBase::Ptr() != nullptr); }    } }; //        template &lt;typename T, typename D = DefDeleter&lt;T&gt;&gt; public ref class ImplPtrM sealed : ImplPtrBase&lt;T, D&gt; { public:    ImplPtrM(T* p) : ImplPtrBase(p) {}    operator bool() { return ( ImplPtrBase::Ptr() != nullptr); }    T* operator-&gt;() { return ImplPtrBase::Ptr(); }    T* Get() { return ImplPtrBase::Ptr(); } };</span></span></code> </pre> <br><a name="id-2-2"></a><br><h2>  2.2  Exemplo de uso </h2><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">N</span></span></span><span class="hljs-class"> //   {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    N();    ~N();    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... }; using NPtr = ImplPtr&lt;N&gt;; //   public ref class U : NPtr //  - { public:    U() : NPtr(new N()) {}    void DoSomething() { if (IsValid) Ptr()-&gt;DoSomething(); } // ... }; public ref class V //  -,   {    ImplPtrM&lt;N&gt; m_NPtr; //   public:    V() : m_NPtr(new N()) {}    void DoSomething() { if (m_NPtr) m_NPtr-&gt;DoSomething(); } // ... };</span></span></code> </pre> <br><p>  Nesses exemplos, as classes <code>U</code> e <code>V</code> são liberadas sem nenhum esforço adicional; seu <code>Dispose()</code> fornece uma chamada ao operador de <code>delete</code> para um ponteiro para <code>N</code>  A segunda opção, usando <code>ImplPtrM&lt;&gt;</code> , permite gerenciar várias classes nativas em uma única classe de descritor. </p><br><a name="id-2-3"></a><br><h2>  2.3  Opções de finalização mais complexas </h2><br><p>  A finalização é um aspecto bastante problemático do .NET.  Em cenários normais de aplicativos, os finalizadores não devem ser chamados; os recursos devem ser liberados em <code>Dispose()</code> .  Mas em cenários de emergência, isso pode acontecer e os finalizadores devem funcionar corretamente. </p><br><a name="id-2-3-1"></a><br><h3>  2.3.1  Bloqueio do finalizador </h3><br><p>  Se a classe nativa estiver localizada em uma DLL que carrega e descarrega dinamicamente - usando <code>LoadLibrary()/FreeLibrary()</code> , pode ocorrer uma situação quando, após o descarregamento da DLL, houver objetos não liberados que tenham referências a instâncias dessa classe.  Nesse caso, depois de um tempo, o coletor de lixo tentará finalizá-las e, como a DLL é descarregada, o programa provavelmente falhará.  (Um recurso característico é uma falha vários segundos depois que o aplicativo é aparentemente fechado.) Portanto, após o descarregamento da DLL, os finalizadores devem ser bloqueados.  Isso pode ser alcançado com uma pequena modificação do modelo básico do <code>ImplPtrBase</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DllFlag</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> s_Loaded = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLoaded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> loaded)</span></span></span><span class="hljs-function"> </span></span>{ s_Loaded = loaded; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImplPtrBase</span></span></span><span class="hljs-class"> :</span></span> DllFlag, System::IDisposable { <span class="hljs-comment"><span class="hljs-comment">// ...    !ImplPtrBase() { if (s_Loaded) Delete(); } // ... };</span></span></code> </pre> <br><p>  Depois de carregar a DLL, você precisa chamar <code>DllFlag::SetLoaded(true)</code> e antes de descarregar <code>DllFlag::SetLoaded(false)</code> . </p><br><a name="id-2-3-2"></a><br><h3>  2.3.2  Usando o <code>SafeHandle</code> </h3><br><p>  A classe <code>SafeHandle</code> implementa um algoritmo de finalização bastante complexo e mais confiável, consulte [Richter].  O modelo <code>ImplPtrBase&lt;&gt;</code> pode ser reprojetado para usar o <code>SafeHandle</code> .  Os demais modelos não precisam ser alterados. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> SH = System::Runtime::InteropServices::SafeHandle; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PtrType = System::IntPtr; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ref <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImplPtrBase</span></span></span><span class="hljs-class"> :</span></span> SH { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ImplPtrBase(T* p) : SH(PtrType::Zero, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)    {        handle = PtrType(p);    }    <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(handle.ToPointer()); }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReleaseHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override    </span></span>{        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsInvalid)        {            D del;            del(Ptr());            handle = PtrType::Zero;        }        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;    } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    property <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsInvalid    {        <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override        </span></span>{            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (handle == PtrType::Zero);        }    } };</code> </pre> <br><a name="id-refs"></a><br><h1>  Referências </h1><br><p>  [Richter] <br>  Richter, Jeffrey.  Programação na plataforma Microsoft .NET Framework 4.5 em C #.  4a ed.: Per.  do inglês  - São Petersburgo: Peter, 2016. </p><br><p>  [Cwalina] <br>  Tsvalina, Krzhishtov.  Abrams, Brad.  Infraestrutura de projetos de software: convenções, idiomas e modelos para bibliotecas .NET reutilizáveis.: Transl.  do inglês  - M .: LLC “I.D.  Williams, 2011. </p><br><p>  [Hogenson] <br>  Hogenson, Gordon.  C ++ / CLI: linguagem Visual C ++ para o ambiente .NET.: Por.  do inglês  - M .: LLC “I.D.  Williams, 2007. </p><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426411/">https://habr.com/ru/post/pt426411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426399/index.html">Cronos: sem viagem no tempo, mesmo em sistemas distribuídos</a></li>
<li><a href="../pt426401/index.html">Amazon ensinará sua IA a definir emoções humanas</a></li>
<li><a href="../pt426405/index.html">Hackers no âmbito das leis da Federação Russa</a></li>
<li><a href="../pt426407/index.html">Como tornar a viagem para a conferência o mais inútil possível</a></li>
<li><a href="../pt426409/index.html">O hacker Alexei, que protege os roteadores MikroTik sem a permissão dos proprietários, tornou-se famoso</a></li>
<li><a href="../pt426413/index.html">Princípios do SOLID que todo desenvolvedor deve conhecer</a></li>
<li><a href="../pt426415/index.html">Fintech-digest: controle de digitalização pelo Banco Central, salário de criptomoeda, cartão Mir em forma de pulseiras e chaveiros</a></li>
<li><a href="../pt426417/index.html">Pavel 2.0: consultor reptilóide em JS, node.js com soquetes e telefonia</a></li>
<li><a href="../pt426419/index.html">Métodos de sobrecarga ou ponte proibidos em Java</a></li>
<li><a href="../pt426421/index.html">EHCI humanamente em russo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>