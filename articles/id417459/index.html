<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‡ ğŸ–¤ â™Œï¸ Ketahui JIT Anda: lebih dekat ke mobil ğŸ“¸ ğŸ¤¸ğŸ¾ ğŸ–•ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebelum kode yang ditulis oleh kami dieksekusi, ia berjalan agak jauh. Andrey Melikhov dalam laporannya tentang RIT ++ 2018 memeriksa setiap langkah d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ketahui JIT Anda: lebih dekat ke mobil</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/417459/"> Sebelum kode yang ditulis oleh kami dieksekusi, ia berjalan agak jauh.  <strong>Andrey Melikhov</strong> dalam laporannya tentang RIT ++ 2018 memeriksa setiap langkah di jalur ini menggunakan contoh mesin V8.  Datanglah ke bawah kucing untuk mencari tahu apa yang memberi kita pemahaman mendalam tentang prinsip-prinsip kompiler dan bagaimana membuat kode JavaScript lebih produktif. <br><br><img src="https://habrastorage.org/webt/iy/2r/ke/iy2rkenolmtnchwu_whyurlrw80.jpeg"><br><br>  Kami akan mencari tahu apakah WASM adalah peluru perak untuk meningkatkan kinerja kode, dan apakah optimasi selalu dibenarkan. <br><br>  <strong><em>Spoiler:</em></strong> "Optimalisasi prematur adalah akar dari semua penyakit," Donald Knuth. <br><br><img src="https://habrastorage.org/webt/rd/-o/q7/rd-oq7q2m9bjipzyqo1l3jrlqti.jpeg"><br><br>  <strong><em>Tentang pembicara:</em></strong> Andrei Melikhov bekerja di Yandex.Money, menulis secara aktif di Node.js, dan lebih sedikit di browser, jadi server JavaScript lebih dekat dengannya.  Andrew mendukung dan mengembangkan komunitas devShacht, jadi lihatlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Medium</a> . <br><a name="habracut"></a><br><h2>  <strong>Motivasi dan Daftar Istilah</strong> </h2><br>  Hari ini kita akan berbicara tentang kompilasi JIT.  Saya pikir ini menarik bagi Anda, karena Anda membaca ini.  Namun, mari kita perjelas mengapa Anda perlu tahu apa itu JIT dan bagaimana V8 bekerja, dan mengapa menulis Bereaksi di browser tidak cukup. <br><br><ul><li>  Memungkinkan Anda <strong>menulis kode yang lebih efisien</strong> , karena bahasa kami spesifik. </li><li>  <strong>Ini mengungkapkan teka</strong> - <strong>teki</strong> mengapa di perpustakaan orang lain kode ini ditulis dengan cara ini, dan bukan sebaliknya.  Kadang-kadang kita menjumpai perpustakaan lama dan melihat apa yang tertulis di sana entah bagaimana aneh, tetapi jika ini perlu, itu tidak perlu - itu tidak jelas.  Ketika Anda tahu cara kerjanya, Anda mengerti mengapa ini dilakukan. <br></li><li>  <strong>Ini sangat menarik</strong> .  Selain itu, ini memungkinkan kita untuk memahami apa yang disampaikan oleh Axel Rauschmeier, Benedict Moyrer dan Dan Abramov di Twitter. <br></li></ul><br><img src="https://habrastorage.org/webt/le/oy/yg/leoyyg4b8ru_n_2djyzkg6hbe1a.jpeg"><br><br>  Wikipedia mengatakan bahwa JavaScript adalah bahasa pemrograman tingkat tinggi yang ditafsirkan dengan pengetikan dinamis.  Kami akan berurusan dengan persyaratan ini. <br><br>  <strong>Kompilasi dan interpretasi</strong> <br><br>  Kompilasi - ketika program dikirim dalam kode biner, dan pada awalnya dioptimalkan untuk lingkungan di mana ia akan bekerja. <br><br>  Interpretasi - ketika kami mengirimkan kode apa adanya. <br><br>  JavaScript dikirimkan apa adanya - ini adalah bahasa yang ditafsirkan, seperti yang ditulis di Wikipedia. <br><br>  <strong>Pengetikan dinamis dan statis</strong> <br><br>  Pengetikan statis dan dinamis sering dikacaukan dengan pengetikan lemah dan kuat.  Misalnya, C adalah bahasa dengan pengetikan lemah statis.  JavaScript memiliki ketikan dinamis yang lemah. <br><br>  Mana yang lebih baik?  Jika program dikompilasi, itu diarahkan pada lingkungan di mana ia akan dieksekusi, yang berarti akan bekerja lebih baik.  Pengetikan statis membuat kode ini lebih efisien.  Dalam JavaScript, yang terjadi adalah sebaliknya. <br><br>  Tetapi pada saat yang sama, aplikasi kita menjadi lebih kompleks: baik di klien dan di server, kelompok besar muncul di Node.js, yang berfungsi dengan baik dan menggantikan aplikasi Java. <br><br>  Tetapi bagaimana semuanya bekerja jika pada awalnya tampaknya menjadi pecundang. <br><br><blockquote>  JIT akan merekonsiliasi semua orang!  Atau setidaknya coba. </blockquote><br>  Kami memiliki JIT (kompilasi Just In Time) yang terjadi saat runtime.  Kami akan membicarakannya. <br><br><h3>  <strong>Mesin Js</strong> </h3><br><ul><li>  Chakra Unloved, yang terletak di Internet Explorer.  Ini bahkan tidak berfungsi dengan JavaScript, tetapi dengan Jscript - ada subset seperti itu. <br></li><li>  Chakra dan Chakra modern yang berfungsi di Edge; <br></li><li>  SpiderMonkey di FireFox; </li><li>  JavaScriptCore di WebKit.  Ini juga digunakan dalam Bereaksi Asli.  Jika Anda memiliki aplikasi RN untuk Android, maka itu juga berjalan di JavaScriptCore - mesin dibundel dengan aplikasi tersebut. <br></li><li>  V8 adalah favorit saya.  Ini bukan yang terbaik, saya hanya bekerja dengan Node.js, di mana itu adalah mesin utama, seperti di semua browser Berbasis Chrome. <br></li><li>  Badak dan Nashorn adalah mesin yang digunakan di Jawa.  Dengan bantuan mereka, Anda juga dapat menjalankan JavaScript di sana. <br></li><li>  JerryScript - untuk perangkat yang disematkan; <br></li><li>  dan lainnya ... </li></ul><br>  Anda dapat menulis mesin sendiri, tetapi jika Anda bergerak menuju eksekusi yang efektif, Anda akan sampai pada skema yang kira-kira sama, yang akan saya tunjukkan nanti. <br><br>  Hari ini kita akan berbicara tentang V8, dan ya, dinamai mesin 8-silinder. <br><br><h2>  <strong>Kami memanjat di bawah tenda</strong> </h2><br>  Bagaimana javascript dijalankan? <br><br><ul><li>  Ada kode yang ditulis dalam JavaScript, yang disediakan. <br></li><li>  dia mengurai; </li><li>  sedang dieksekusi; </li><li>  hasilnya didapat. <br></li></ul><br><img src="https://habrastorage.org/webt/wj/n0/us/wjn0ustvepwu4kmulit2v6xxtsy.jpeg"><br><br>  Parsing mengubah kode menjadi <strong>pohon sintaksis abstrak</strong> .  AST adalah tampilan struktur sintaksis kode dalam bentuk pohon.  Ini sebenarnya nyaman untuk program ini, meskipun sulit dibaca. <br><img src="https://habrastorage.org/webt/3i/1p/y-/3i1py-dcnwj6enma0zveqcv67tq.jpeg"><br><br>  Mendapatkan elemen array dengan indeks 1 dalam bentuk pohon direpresentasikan sebagai operator dan dua operan: muat properti dengan kunci dan kunci-kunci ini. <br><br><h3>  <strong>Di mana AST digunakan?</strong> </h3><br>  AST tidak hanya di mesin.  Menggunakan AST, banyak utilitas menulis ekstensi, termasuk: <br><br><ul><li>  ESLint; </li><li>  Babel; </li><li>  Lebih cantik </li><li>  Jscodeshift. </li></ul><br>  Misalnya, hal keren Jscodeshift, yang belum diketahui semua orang, memungkinkan Anda menulis transformasi.  Jika Anda mengubah API suatu fungsi, Anda dapat mengatur transformasi ini di atasnya dan membuat perubahan di seluruh proyek. <br><br><img src="https://habrastorage.org/webt/wl/ct/8e/wlct8ejmclt1hoqiinm9jwbayyg.jpeg"><br><br>  Kami melanjutkan.  Prosesor tidak mengerti pohon sintaksis abstrak, itu membutuhkan <strong>kode mesin</strong> .  Oleh karena itu, transformasi lebih lanjut terjadi melalui penerjemah, karena bahasa ditafsirkan. <br><img src="https://habrastorage.org/webt/i6/cj/zh/i6cjzhohklmcdyenrvrjmdw6fyk.jpeg"><br><br>  Begitulah, sementara browser memiliki sedikit JavaScript - sorot baris, buka sesuatu, tutup.  Tapi sekarang kami memiliki aplikasi - SPA, Node.js, dan <strong>juru bahasa menjadi hambatan</strong> . <br><br><h2>  <strong>Mengoptimalkan JIT Compiler</strong> </h2><br>  Alih-alih penerjemah, kompiler JIT yang optimal muncul, yaitu kompiler Just-in-time.  Kompiler sebelumnya bekerja sebelum eksekusi aplikasi, dan JIT - selama.  Pada masalah optimisasi, kompiler JIT mencoba menebak bagaimana kode akan dieksekusi, tipe apa yang akan digunakan, dan mengoptimalkan kode sehingga ia bekerja lebih baik. <br><br>  Optimalisasi semacam itu disebut <strong>spekulatif</strong> , karena berspekulasi pada pengetahuan tentang apa yang terjadi pada kode sebelumnya.  Artinya, jika sesuatu dengan tipe angka dipanggil 10 kali, kompiler berpikir bahwa ini akan terjadi setiap saat dan dioptimalkan untuk tipe ini. <br><br>  Secara alami, jika Boolean memasukkan input, terjadi deoptimisasi.  Pertimbangkan fungsi yang menambahkan angka. <br><br> <code>const foo=(a, b) =&gt; a + b; <br> foo (1, 2); <br> foo (2, 3);</code> <br> <br>  Lipat sekali, yang kedua kalinya.  Kompiler membuat prediksi: "Ini adalah angka, saya punya solusi keren untuk menambahkan angka!"  Dan Anda menulis <code>foo('WTF', 'JS')</code> , dan meneruskan garis ke fungsi - kami memiliki JavaScript, kami dapat menambahkan baris dengan angka. <br><br>  Pada titik ini, terjadi deoptimisasi. <br><br><img src="https://habrastorage.org/webt/h4/bf/d-/h4bfd-9twvmsqlk-euvv34he48u.jpeg"><br><br>  Jadi, penerjemah digantikan oleh kompiler.  Diagram di atas tampaknya memiliki pipa yang sangat sederhana.  Pada kenyataannya, semuanya sedikit berbeda. <br><br><img src="https://habrastorage.org/webt/zp/ma/oo/zpmaoosvxia3btjyxstyyaq5nnc.jpeg"><br><br>  Itu sampai tahun lalu.  Tahun lalu, Anda dapat mendengar banyak laporan dari Google bahwa mereka meluncurkan saluran pipa baru dengan TurboFan dan sekarang skemanya terlihat lebih sederhana. <br><br><img src="https://habrastorage.org/webt/qz/wo/2x/qzwo2xg_2ju3fafi6hb4y8ssm24.jpeg"><br><br>  Menariknya, seorang penerjemah muncul di sini. <br><br><img src="https://habrastorage.org/webt/w5/tu/u4/w5tuu4i3irrzbsck7e2ohdnzgai.jpeg"><br><br>  Seorang juru bahasa diperlukan untuk mengubah pohon sintaksis abstrak menjadi bytecode, dan meneruskan bytecode ke kompiler.  Dalam kasus deoptimisasi, ia kembali pergi ke penerjemah. <br><br><h2>  <strong>Ignition Interpreter</strong> </h2><br>  Sebelumnya, tidak ada skema interpreter pengapian.  Google awalnya mengatakan bahwa juru bahasa tidak diperlukan - JavaScript sudah kompak dan cukup dapat ditafsirkan - kami tidak akan memenangkan apa pun. <br><br>  Tetapi tim yang bekerja dengan aplikasi seluler mengalami masalah berikut ini. <br><br><img src="https://habrastorage.org/webt/7e/ms/yd/7emsydqevnntiujqhsa_rtrvdec.jpeg"><br><br>  Pada 2013-2014, orang mulai menggunakan perangkat seluler untuk mengakses Internet lebih sering daripada desktop.  Pada dasarnya, ini bukan iPhone, tetapi dari perangkat yang lebih sederhana - mereka memiliki sedikit memori dan prosesor yang lemah. <br><br><img src="https://habrastorage.org/webt/8b/0l/zi/8b0lzi2wb8mqqbsetc88t2lsale.jpeg"><br><br>  Di atas adalah grafik analisis awal 1 MB kode sebelum memulai juru bahasa.  Dapat dilihat bahwa desktop menang sangat banyak.  IPhone juga tidak buruk, tetapi memiliki mesin yang berbeda, dan kita berbicara tentang V8, yang berfungsi di Chrome. <br><br><blockquote>  Tahukah Anda bahwa jika Anda memasang Chrome di iPhone, itu akan tetap berfungsi di JavaScriptCore? </blockquote><br>  Dengan demikian, waktu terbuang - dan ini hanya analisis, bukan eksekusi - file Anda telah dimuat, dan ia mencoba memahami apa yang tertulis di dalamnya. <br><img src="https://habrastorage.org/webt/kx/kv/l5/kxkvl5nr4j2cxe5d6kuhwegffnk.jpeg"><br><br>  Ketika deoptimisasi terjadi, Anda perlu mengambil kode sumber lagi, yaitu  itu perlu disimpan di suatu tempat.  Butuh banyak memori. <br><br>  Dengan demikian, penerjemah memiliki dua tugas: <br><br><ol><li>  mengurangi parsing overhead; <br></li><li>  mengurangi konsumsi memori. <br></li></ol><br>  Tugas diselesaikan dengan beralih ke penerjemah bytecode. <br><img src="https://habrastorage.org/webt/yr/ky/sk/yrkyskmi_annr0w3jnps13y5alc.jpeg"><br><br>  <strong>Bytecode di Chrome adalah mesin register dengan baterai</strong> .  SpiderMonkey memiliki mesin bertumpuk, semua data ada di tumpukan, tetapi tidak ada register.  Inilah mereka. <br><br>  Kami tidak akan sepenuhnya menganalisis cara kerjanya, lihat saja fragmen kode. <br><br><img src="https://habrastorage.org/webt/vu/is/fh/vuisfhp0lin_et7pozzqny-g6q0.jpeg"><br><br>  Dikatakan di sini: ambil nilai yang ada di baterai dan tambahkan ke nilai yang ada di register <strong>a0</strong> , yaitu, dalam variabel <strong>a</strong> .  Belum ada yang diketahui tentang jenis di sini.  Jika itu adalah kode assembler nyata, maka itu akan ditulis dengan pemahaman tentang jenis shift apa yang ada dalam memori, apa yang ada di dalamnya.  Ini hanya sebuah instruksi - ambil apa yang ada di register <strong>a0</strong> dan tambahkan ke nilai yang ada di baterai. <br><br>  Tentu saja, interpreter tidak hanya mengambil pohon sintaksis abstrak dan menerjemahkannya menjadi bytecode. <br><img src="https://habrastorage.org/webt/vv/4g/i6/vv4gi6zw_zrtlsgl5lsb7ebqqza.jpeg"><br><br>  Ada juga optimasi, misalnya, penghapusan kode mati. <br>  Jika suatu bagian dari kode tidak dipanggil, itu dibuang dan tidak disimpan lebih lanjut.  Jika Ignition melihat penambahan dua angka, ia menambahkannya dan membiarkannya sedemikian rupa agar tidak menyimpan informasi yang tidak perlu.  Hanya setelah ini diperoleh bytecode. <br><br><h2>  <strong>Optimasi dan deoptimisasi</strong> </h2><br><h3>  Fitur dingin dan panas </h3><br>  Ini adalah topik yang paling mudah. <br><br>  Fungsi dingin adalah fungsi yang dipanggil sekali atau tidak dipanggil sama sekali, fungsi panas adalah fungsi yang dipanggil beberapa kali.  Tidak mungkin untuk mengatakan dengan tepat berapa kali - setiap saat ini dapat diulang.  Tetapi pada titik tertentu, fungsinya menjadi panas, dan mesin mengerti bahwa itu perlu dioptimalkan. <br><br><img src="https://habrastorage.org/webt/mk/1t/vr/mk1tvrgq5h2l7mp72g4p6vg6wlm.jpeg"><br><br>  Skema kerja. <br><br><ul><li>  Ignition (interpreter) mengumpulkan informasi.  Dia tidak hanya mengubah JavaScript menjadi bytecode, tetapi juga memahami tipe apa yang masuk, fungsi apa yang menjadi panas, dan dia memberi tahu kompilator tentang semua ini. </li><li>  Ada optimasi. </li><li>  Kompiler mengeksekusi kode.  Semuanya berfungsi dengan baik, tetapi di sini suatu tipe tiba bahwa dia tidak berharap, dia tidak memiliki kode untuk bekerja dengan tipe ini. </li><li>  Terjadi deoptimisasi.  Kompiler mengakses interpreter Pengapian untuk kode ini. </li></ul><br>  Ini adalah siklus normal yang terjadi setiap saat, tetapi ini tidak terbatas.  Pada titik tertentu, mesin mengatakan, "Tidak, itu tidak mungkin untuk dioptimalkan," dan mulai dijalankan tanpa optimasi.  Penting untuk dipahami bahwa monomorfisme harus diperhatikan. <br><br>  <strong>Monomorfisme</strong> adalah ketika tipe yang sama selalu masuk ke input fungsi Anda.  Artinya, jika Anda mendapatkan string sepanjang waktu, maka Anda tidak perlu melewati boolean di sana. <br><br>  Tapi apa yang harus dilakukan dengan benda?  Objek adalah semua objek.  Kami memiliki kelas, tetapi mereka tidak nyata - itu hanya gula dari model prototipe.  Tapi di dalam mesin ada yang disebut kelas tersembunyi. <br><br><h3>  Kelas tersembunyi </h3><br>  Ada kelas tersembunyi di semua mesin, tidak hanya di V8.  Di mana-mana mereka dipanggil secara berbeda, dalam hal V8 itu adalah Peta. <br><br>  Semua objek yang Anda buat memiliki kelas tersembunyi.  Jika anda <br>  lihat profil memori, Anda akan melihat bahwa ada elemen tempat daftar elemen disimpan, properti tempat properti disimpan, dan peta (biasanya parameter pertama), di mana tautan ke sana ditunjukkan pada kelas tersembunyi. <br><br>  Peta menggambarkan struktur objek, karena pada prinsipnya, dalam JavaScript, pengetikan hanya mungkin struktural, bukan nominal.  Kita bisa menggambarkan seperti apa objek kita, untuk apa itu. <br><br>  Saat menghapus / menambahkan properti objek kelas Tersembunyi, objek berubah, yang baru ditugaskan.  Mari kita lihat kodenya. <br><img src="https://habrastorage.org/webt/4i/ia/bs/4iiabsuemjg-7nu0yiywvlsd9hc.jpeg"><br><br>  Kami memiliki konstruktor yang membuat objek baru bertipe Point. <br><br><ul><li>  Buat objek. </li><li>  Bind kelas tersembunyi untuk itu, yang mengatakan bahwa itu adalah objek bertipe Point. </li><li>  Kami menambahkan bidang x - kelas tersembunyi baru yang mengatakan itu adalah objek bertipe Point, di mana nilai x lebih dulu. </li><li>  Menambahkan y - kelas Tersembunyi baru, di mana x, dan kemudian y. </li><li>  Dibuat objek lain - hal yang sama terjadi.  Artinya, ia juga mengikat apa yang sudah dibuat.  Pada saat ini, kedua objek ini memiliki tipe yang sama (melalui kelas Tersembunyi). </li><li>  Ketika bidang baru ditambahkan ke objek kedua, kelas tersembunyi baru muncul di objek.  Sekarang untuk mesin p1 dan p2, ini adalah objek dari kelas yang berbeda, karena mereka memiliki struktur yang berbeda </li><li>  Jika Anda mentransfer objek pertama di suatu tempat, maka ketika Anda mentransfer objek kedua di sana, deoptimisasi akan terjadi.  Yang pertama mengacu pada satu kelas tersembunyi, yang kedua ke yang lain. </li></ul><br>  <strong>Bagaimana saya bisa memeriksa kelas tersembunyi?</strong> <br><br>  Di Node.js, Anda bisa menjalankan simpul â€”allow-asli-sintaks.  Maka Anda akan mendapatkan kesempatan untuk menulis perintah dalam sintaks khusus, yang, tentu saja, tidak dapat digunakan dalam produksi.  Ini terlihat seperti ini: <br><br><pre> <code class="javascript hljs">%HaveSameMap({<span class="hljs-string"><span class="hljs-string">'a'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-string"><span class="hljs-string">'b'</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>})</code> </pre> <br>  Tidak ada yang menjamin bahwa besok perintah ini akan berfungsi, mereka tidak ada dalam spesifikasi ECMAScript, itu saja untuk debugging. <br><br>  Menurut Anda apa hasil dari memanggil fungsi% HaveSameMap untuk dua objek.  Jawaban yang benar salah, karena yang satu memiliki bidang, dan yang lainnya <strong>b</strong> .  Ini adalah objek yang berbeda.  Pengetahuan ini dapat digunakan untuk teknik Cache Inline. <br><br><h3>  Cache sebaris </h3><br>  Kami memanggil fungsi yang sangat sederhana yang mengembalikan bidang dari suatu objek.  Mengembalikan unit tampaknya sangat sederhana.  Tetapi jika Anda melihat spesifikasi ECMAScript, Anda akan melihat bahwa ada daftar besar apa yang perlu Anda lakukan untuk mendapatkan bidang dari objek.  Karena, jika bidang tidak ada di objek, ada kemungkinan bahwa itu dalam prototipe.  Mungkin itu setter, pengambil dan sebagainya.  Semua ini perlu diperiksa. <br><img src="https://habrastorage.org/webt/02/dn/nj/02dnnjtvkqa7fn87e8ioa3kwgpy.jpeg"><br><br>  Dalam hal ini, objek memiliki tautan ke peta, yang mengatakan: untuk mendapatkan bidang <strong>x</strong> , Anda perlu melakukan offset dengan satu, dan kami mendapatkan <strong>x</strong> .  Anda tidak perlu naik ke mana pun, dalam prototipe apa pun, semuanya ada di dekatnya.  Cache Inline menggunakan ini. <br><br><img src="https://habrastorage.org/webt/ck/53/ny/ck53nyrhuj7ihixe7vi7ds_vjvc.jpeg"><br><br><ul><li>  Jika kita memanggil fungsi untuk pertama kalinya, semuanya baik-baik saja, penerjemah telah melakukan optimasi </li><li>  Untuk panggilan kedua, keadaan monomorfik disimpan. </li><li>  Saya memanggil fungsi untuk ketiga kalinya, melewatkan objek yang sedikit berbeda {x: 3, y: 1}.  Deoptimisasi terjadi, jika muncul, kita masuk ke keadaan polimorfik.  Sekarang kode yang menjalankan fungsi ini tahu bahwa dua jenis objek dapat terbang ke dalamnya. </li><li>  Jika kita melewati objek yang berbeda beberapa kali, ia tetap dalam keadaan polimorfik, menambahkan ifs baru.  Tetapi pada titik tertentu menyerah dan pergi ke keadaan megamorphic, yaitu  ketika: "Terlalu banyak jenis berbeda tiba di pintu masuk - saya tidak tahu cara mengoptimalkannya!" </li></ul><br>  Tampaknya sekarang 4 negara polimorfik diizinkan, tetapi besok mungkin ada 8. Ini diputuskan oleh para pengembang mesin.  Lebih baik kita tetap dalam keadaan monomorfik, dalam kasus ekstrim, polimorfik.  Transisi antara keadaan monomorfik dan polimorfik mahal, karena Anda harus pergi ke juru bahasa, mendapatkan kode lagi dan mengoptimalkannya lagi. <br><br><h3>  Array </h3><br>  Dalam JavaScript, selain dari Typed Arays tertentu, ada satu jenis <br>  array  Ada 6 dari mereka di mesin V8: <br><br>  1. [1, 2, 3, 4] // PACKED_SMI_ELEMENTS - hanya array bilangan bulat kecil yang dikemas.  Ada optimasi untuknya. <br><br>  2. [1.2, 2.3, 3.4, 4.6] // PACKED_DOUBLE_ELEMENTS - array elemen ganda yang dikemas, ada juga optimasi untuknya, tetapi yang lebih lambat. <br><br>  3. [1, 2, 3, 4, 'X'] // PACKED_ELEMENTS - larik yang dikemas di mana terdapat objek, string, dan yang lainnya.  Baginya, juga, ada optimasi. <br><br>  Tiga tipe berikut adalah array dengan tipe yang sama dengan tiga yang pertama, tetapi berlubang: <br><br>  4. [1, / * hole * /, 2, / * hole * /, 3, 4] // HOLEY_SMI_ELEMENTS <br><br>  5. [1.2, / * hole * /, 2, / * hole * /, 3,4] // HOLEY_DOUBLE_ELEMENTS <br><br>  6. [1, / * lubang * /, 'X'] // HOLEY_ELEMENTS <br><br>  Ketika lubang muncul di array Anda, optimasi menjadi kurang efisien.  Mereka mulai bekerja dengan buruk, karena tidak mungkin untuk melewati array ini secara berurutan, memilah-milah iterasi.  Setiap jenis selanjutnya kurang dioptimalkan <br><br><img src="https://habrastorage.org/webt/qb/rw/zf/qbrwzflusrdjbboqwgsth1ezozu.jpeg"><br><br>  Dalam diagram, semuanya di atas dioptimalkan lebih cepat.  Artinya, semua metode asli Anda - peta, kurangi, sortir - di dalam dioptimalkan dengan baik.  Tetapi dengan masing-masing jenis, optimasi semakin buruk. <br><br>  Sebagai contoh, sebuah array sederhana [ <strong>1</strong> , <strong>2</strong> , <strong>3</strong> ] datang ke input (integer kecil tipe-dikemas).  Kami sedikit mengubah array ini dengan menambahkan double ke dalamnya - masuk ke status PACKED_DOUBLE_ELEMENTS.  Tambahkan objek ke sana - buka status berikutnya, persegi panjang hijau PACKED_ELEMENTS.  Tambahkan lubang ke dalamnya - buka status HOLEY_ELEMENTS.  Kami ingin mengembalikannya ke keadaan sebelumnya sehingga menjadi "baik" lagi - kami menghapus semua yang kami tulis dan tetap dalam kondisi yang sama ... dengan lubang!  Yaitu, HOLEY_ELEMENTS di kanan bawah diagram.  Kembali ini tidak berfungsi.  Array Anda hanya dapat menjadi lebih buruk, tetapi tidak sebaliknya. <br><br><h2>  <strong>Objek seperti array</strong> </h2><br>  Kita sering menemukan Array-Like Objects - ini adalah objek yang terlihat seperti array karena memiliki tanda panjang.  Faktanya, mereka seperti kucing bajak laut, artinya mereka mirip, tetapi dalam efisiensi konsumsi rum, kucing akan lebih buruk daripada bajak laut.  Demikian pula, Obyek Array-Like seperti array, tetapi tidak efisien. <br><img src="https://habrastorage.org/webt/uf/f4/u_/uff4u_bbjb3elwmhhor3lv2tiwm.jpeg"><br><br>  Dua Objek Seperti Array favorit kami adalah argumen dan document.querySelectorAII.  Ada hal-hal fungsional yang begitu indah. <br><img src="https://habrastorage.org/webt/i7/_j/ul/i7_juluulfkpnerhxwnif4tjnoa.jpeg"><br><br>  Kami punya peta - kami merobeknya dari prototipe dan tampaknya bisa menggunakannya.  Tetapi jika bukan array yang masuk ke inputnya, tidak akan ada optimasi.  Mesin kami tidak dapat melakukan optimasi pada objek. <br><br>  Apa yang perlu dilakukan? <br><br><ul><li>  Opsi old-school - melalui slice.call () berubah menjadi array nyata. </li><li>  Opsi modern bahkan lebih baik: tulis (... istirahat), dapatkan array bersih - bukan argumen - semuanya baik-baik saja! </li></ul><br>  Dengan querySelectorSemua hal yang sama - karena penyebaran kami dapat mengubahnya menjadi array yang lengkap dan bekerja dengan semua optimisasi. <br><br><h2>  <strong>Array besar</strong> </h2><br><blockquote>  <strong>Riddle:</strong> new Array (1000) vs array = [] <br>  Opsi mana yang lebih baik: segera buat array besar dan isi dengan 1000 objek dalam satu lingkaran, atau buat yang kosong dan isi secara bertahap? <br></blockquote><br>  <strong>Jawaban yang benar:</strong> tergantung pada. <br><br>  Apa bedanya? <br><br><ul><li>  Saat kami membuat array dengan cara pertama dan mengisi 1000 elemen, kami membuat 1000 lubang.  Array ini tidak akan dioptimalkan.  Tapi dia akan menulis dengan cepat. <br></li><li>  Membuat array sesuai dengan varian kedua, sedikit memori dialokasikan, kita menulis, misalnya, 60 elemen, sedikit lebih banyak memori dialokasikan, dll. </li></ul><br>  Artinya, pada kasus pertama kita menulis dengan cepat - kita bekerja lambat;  di detik kita menulis perlahan - kita bekerja dengan cepat. <br><br><h2>  <strong>Pengumpul sampah</strong> </h2><br>  Pengumpul sampah juga makan sedikit waktu dan sumber daya.  Tanpa menyelam dalam-dalam, saya akan memberikan dasar yang paling umum. <br><br><img src="https://habrastorage.org/webt/fg/8e/1c/fg8e1csx9x1mo4y2hlvuzzjvgem.jpeg"><br><br>  Model generatif kami memiliki <strong>ruang benda muda dan tua</strong> .  Objek yang dibuat jatuh ke ruang benda muda.  Setelah beberapa waktu, pembersihan dimulai.  Jika objek tidak dapat dijangkau oleh tautan dari root, maka itu dapat dikumpulkan dalam sampah.  Jika objek masih digunakan, ia bergerak ke ruang objek lama, yang kurang sering dibersihkan.  Namun, pada titik tertentu, objek lama dihapus. <br><img src="https://habrastorage.org/webt/ac/rd/1l/acrd1lqmylajg5b3crff97j-9h8.jpeg"><br><br>  Ini adalah cara kerja pengumpul sampah otomatis - ia membersihkan benda-benda berdasarkan tidak ada tautan ke sana.  Ini adalah dua algoritma yang berbeda. <br><br><ol><li>  <strong>Mengais</strong> adalah cepat tetapi tidak efektif. <br></li><li>  <strong>Mark-Sweep</strong> lambat tapi efisien. <br></li></ol><br>  Jika Anda mulai membuat profil konsumsi memori di Node.js, Anda mendapatkan sesuatu seperti ini. <br><br><img src="https://habrastorage.org/webt/yp/uj/1b/ypuj1bus74-w473vsmczkvgwi0s.jpeg"><br><br>  Pada awalnya, itu tumbuh secara tiba-tiba - ini adalah karya dari algoritma Scavenge.  Kemudian terjadi penurunan tajam - algoritma Mark-Sweep ini telah mengumpulkan sampah di ruang objek lama.  Pada saat ini, semuanya mulai melambat sedikit.  <strong>Anda tidak dapat mengendalikannya</strong> , karena Anda tidak tahu kapan itu akan terjadi.  Anda hanya dapat menyesuaikan ukurannya. <br><br>  Oleh karena itu, pipa memiliki tahap pengumpulan sampah yang menghabiskan waktu. <br><br><img src="https://habrastorage.org/webt/zi/_3/ya/zi_3yao0kydtrtagdizs4oklcr0.jpeg"><br><br><h2>  <strong>Lebih cepat lagi?</strong> </h2><br>  Mari kita melihat masa depan.  Apa yang harus dilakukan selanjutnya, bagaimana menjadi lebih cepat? <br><img src="https://habrastorage.org/webt/ts/vc/fz/tsvcfzihzzewt_udo-39cjqea8c.jpeg"><br><br>  Pada baris ini, ukuran blok kira-kira terkait dalam waktu yang dibutuhkan. <br><br>  Hal pertama yang terlintas dalam pikiran bagi orang-orang yang telah mendengar tentang bytecode - segera kirimkan bytecode ke input dan decode, daripada menguraikannya - akan lebih cepat! <br><br><img src="https://habrastorage.org/webt/7i/lf/xd/7ilfxdfdm0dbkdknw0ecpushflo.jpeg"><br><br>  Masalahnya adalah bahwa bytecode berbeda sekarang.  Seperti yang saya katakan: di Safari satu, di FireFox yang lain, di Chrome ketiga.  Meskipun demikian, pengembang dari Mozilla, Bloomberg dan Facebook telah mengajukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proposal</a> semacam itu, tetapi ini adalah masa depan. <br><br>  Ada masalah lain - kompilasi, optimasi, dan optimasi ulang, jika kompiler tidak menebak.  Bayangkan ada bahasa yang diketik secara statis pada input yang menghasilkan kode efektif, yang berarti bahwa optimasi ulang tidak lagi diperlukan, karena apa yang kami dapatkan sudah efisien.  Masukan semacam itu hanya dapat dikompilasi dan dioptimalkan satu kali.  Kode yang dihasilkan akan lebih efisien dan dieksekusi lebih cepat. <br><br>  Apa lagi yang bisa dilakukan?  Bayangkan bahwa bahasa ini memiliki manajemen memori manual.  Maka tidak perlu pemulung.  Garis menjadi lebih pendek dan lebih cepat. <br><br><img src="https://habrastorage.org/webt/e0/36/ut/e036utlk16ybet20xbica5qziey.jpeg"><br><br>  Coba tebak seperti apa?  <strong>WebMerkirakan</strong> sekitar <br>  ini cara kerjanya: manajemen memori manual, diketik secara statis <br>  bahasa dan eksekusi cepat. <br><img src="https://habrastorage.org/webt/qf/cd/8h/qfcd8hamo_iv_fznbksf35whw9q.jpeg"><br><br>  Apakah WebSsembly peluru perak? <br><img src="https://habrastorage.org/webt/ke/ip/pd/keippdq9hmpt3ueb7-kgd-zt1ig.jpeg"><br><br>  Tidak, karena ini singkatan dari JavaScript.  WASM belum bisa melakukan apa pun.  Dia tidak memiliki akses ke DOM API.  Itu ada di dalam mesin JavaScript - di dalam mesin yang sama!  Itu melakukan semuanya melalui JavaScript, jadi <strong>WASM tidak akan mempercepat kode Anda</strong> .  Ini dapat mempercepat perhitungan individual, tetapi pertukaran Anda antara JavaScript dan WASM akan menjadi hambatan. <br><br>  Karena itu, sementara bahasa kita adalah JavaScript dan hanya itu, dan beberapa bantuan dari kotak hitam. <br><br><h2>  <strong>Total</strong> </h2><br>  Tiga jenis pengoptimalan dapat dibedakan. <br><br>  â— <strong>Optimalisasi algoritma</strong> <br><br>  Ada sebuah artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mungkin Anda tidak perlu Rust untuk mempercepat JS Anda</a> " oleh Vyacheslav Egorov, yang pernah mengembangkan V8 dan sekarang mengembangkan Dart.  Ceritakan kembali kisahnya dengan singkat. <br><br>  Ada perpustakaan JavaScript yang tidak berfungsi dengan sangat cepat.  Beberapa orang menulis ulang di Rust, dikompilasi dan mendapat WebAssembly, dan aplikasi mulai bekerja lebih cepat.  Vyacheslav Egorov sebagai pengembang JS berpengalaman memutuskan untuk menjawabnya.  Dia menerapkan optimasi algoritmik, dan solusi JavaScript menjadi jauh lebih cepat daripada solusi Rust.  Pada gilirannya, orang-orang itu melihat ini, melakukan optimasi yang sama, dan menang lagi, tetapi tidak terlalu banyak - itu tergantung pada mesin: di Mozilla mereka menang, di Chrome mereka tidak. <br><br>  Hari ini kami tidak berbicara tentang optimasi algoritmik, dan render front-end biasanya tidak membicarakannya.  Ini sangat buruk, karena <strong>algoritma juga memungkinkan kode berjalan lebih cepat</strong> .  Anda cukup menghapus siklus yang tidak Anda butuhkan. <br><br>  â— <strong>Optimalisasi khusus bahasa</strong> <br><br>  Inilah yang kita bicarakan hari ini: bahasa kita ditafsirkan diketik secara dinamis.  Memahami cara kerja array, objek, dan monomorfisme <strong>memungkinkan Anda menulis kode yang efisien</strong> .  Ini harus diketahui dan ditulis dengan benar. <br><br>  â— <strong>Optimalisasi khusus engine</strong> <br><br>  Ini adalah optimasi yang paling berbahaya.  Jika pengembang Anda sangat pintar, tetapi tidak terlalu ramah, yang menerapkan banyak optimasi seperti itu dan tidak memberi tahu siapa pun tentangnya, tidak menulis dokumentasi, maka jika Anda membuka kode, Anda tidak akan melihat JavaScript, tetapi, misalnya, Crankshaft Script.  Artinya, JavaScript ditulis dengan pemahaman mendalam tentang cara kerja mesin Crankshaft dua tahun lalu.  Semuanya berfungsi, tetapi sekarang tidak lagi diperlukan. <br><br>  Oleh karena itu, optimasi tersebut harus didokumentasikan, ditutupi dengan tes yang membuktikan keefektifannya saat ini.  Mereka harus dipantau.  Anda harus mengunjungi mereka hanya pada saat Anda benar-benar melambat di suatu tempat - Anda tidak bisa melakukannya tanpa sepengetahuan perangkat yang begitu mendalam.  Karena itu, frasa terkenal Donald Knuth tampaknya logis. <br><img src="https://habrastorage.org/webt/yx/xo/1u/yxxo1uda9lkq9fim_uy9zzylxlw.jpeg"><br><br>  Tidak perlu mencoba menerapkan optimasi keras apa pun hanya karena Anda membaca ulasan positif tentangnya. <br><br>  Orang harus takut dengan optimasi seperti itu, pastikan untuk mendokumentasikan dan meninggalkan metrik.  Umumnya selalu mengumpulkan metrik.  <strong>Metrik itu penting!</strong> <br><br>  <strong>Tautan yang bermanfaat:</strong> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Abstrak dan presentasi laporan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ada apa dengan monomorfisme?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang membuat WebAssembly cepat?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Memahami Bytecode V8</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Devshacht: Hardcore</a> </li></ul><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontend Conf Moscow</a> <strong>4  5 </strong>               . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> <strong> 15 </strong> ,  ,     : <br><br><ul><li> <strong> </strong> (KeepSolid)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,    Offline First    Persistent Storage </li><li> <strong> </strong> (TradingView)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>    WebGL  WebAssembly  ,        ,  <strong>  API</strong> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> <strong> </strong>  ,          Google Docs. <br></li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417459/">https://habr.com/ru/post/id417459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417447/index.html">Ekspedisi ke lingkaran peri misterius di gurun Namib</a></li>
<li><a href="../id417449/index.html">Dunia Jurassic: Bisakah Kita Benar-Benar Membangkitkan Dinosaurus?</a></li>
<li><a href="../id417451/index.html">Lima Kesalahan Umum untuk Pemula</a></li>
<li><a href="../id417453/index.html">Organisasi magang untuk siswa: menyapu dan trik</a></li>
<li><a href="../id417457/index.html">Frontend Conf Moscow - sisi klien masuk dan keluar</a></li>
<li><a href="../id417461/index.html">Ivan Tulup: asinkron di JS di bawah tenda</a></li>
<li><a href="../id417463/index.html">Pertemuan yang tidak terduga. Bab 17</a></li>
<li><a href="../id417465/index.html">Ikhtisar metode penautan teks</a></li>
<li><a href="../id417469/index.html">Lima alasan egois untuk bekerja secara berulang</a></li>
<li><a href="../id417471/index.html">Solder Sederhana MK936 SMD. Stasiun solder DIY untuk komponen SMD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>