<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©â€ğŸ­ ğŸ“‚ ğŸ’Ÿ Structures de donnÃ©es pour le stockage des graphes: un examen de l'existant et deux "presque nouveaux" â˜ğŸ¾ ğŸ¤ŸğŸ¾ â°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour Ã  tous. 

 Dans cette note, j'ai dÃ©cidÃ© d'Ã©numÃ©rer les principales structures de donnÃ©es utilisÃ©es pour stocker des graphiques en informatique...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Structures de donnÃ©es pour le stockage des graphes: un examen de l'existant et deux "presque nouveaux"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469967/">  Bonjour Ã  tous. <br><br>  Dans cette note, j'ai dÃ©cidÃ© d'Ã©numÃ©rer les principales structures de donnÃ©es utilisÃ©es pour stocker des graphiques en informatique et de parler Ã©galement de quelques autres structures qui se sont cristallisÃ©es par moi-mÃªme. <br><br>  CommenÃ§ons donc.  Mais pas depuis le tout dÃ©but - je pense ce qu'est un graphique et ce qu'il est (orientÃ©, non orientÃ©, pondÃ©rÃ©, non pondÃ©rÃ©, avec plusieurs bords et boucles ou sans eux), nous le savons tous dÃ©jÃ . <br><br>  Alors allons-y.  Quelles sont les options pour les structures de donnÃ©es pour le "stockage graphique" que nous avons. <br><a name="habracut"></a><br><h2>  1. Structures de donnÃ©es matricielles </h2><br>  1.1 <b>Matrice d'adjacence.</b>  La matrice d'adjacence est une matrice oÃ¹ les en-tÃªtes de ligne et de colonne correspondent aux numÃ©ros des sommets du graphique, et la valeur de chacun de ses Ã©lÃ©ments a (i, j) est dÃ©terminÃ©e par la prÃ©sence ou l'absence d'arÃªtes entre les sommets i et j (il est clair qu'une telle matrice pour un graphique non orientÃ© sera symÃ©trique, eh bien, ou vous pouvez convenir que nous stockons toutes les valeurs uniquement au-dessus de la diagonale principale).  Pour les graphiques non pondÃ©rÃ©s, a (i, j) peut Ãªtre spÃ©cifiÃ© par le nombre d'arÃªtes de i Ã  j (s'il n'y en a pas, alors a (i, j) = 0), et pour les courbes pondÃ©rÃ©es, par le poids (poids total) des arÃªtes mentionnÃ©es. <br><br>  1.2 <b>La matrice d'incidence.</b>  Dans ce cas, notre graphique est Ã©galement stockÃ© dans un tableau, dans lequel, en rÃ¨gle gÃ©nÃ©rale, les numÃ©ros de ligne correspondent aux numÃ©ros de ses sommets, et les numÃ©ros de colonne correspondent Ã  des bords prÃ©numÃ©rotÃ©s.  Si le sommet et le bord sont incidents l'un Ã  l'autre, alors une valeur non nulle est Ã©crite dans la cellule correspondante (pour les graphiques non orientÃ©s, 1 est Ã©crit dans le cas de l'incidence du sommet et du bord, pour les graphiques orientÃ©s "1" si le bord "quitte" le sommet et "-1" si c'est le cas). il Â«entreÂ» (on s'en souvient assez facilement, car le signe moins semble Ã©galement Ãªtre Â«inclusÂ» dans le nombre Â«-1Â»)).  Pour les graphiques pondÃ©rÃ©s, encore une fois, au lieu de 1 et -1, vous pouvez spÃ©cifier le poids total de l'arÃªte. <br><br><h2>  2. Structures de donnÃ©es d'Ã©numÃ©ration </h2><br>  2.1 <b>liste d'adjacence.</b>  Eh bien, tout semble simple.  En gÃ©nÃ©ral, chaque sommet d'un graphe peut Ãªtre associÃ© Ã  n'importe quelle structure d'Ã©numÃ©ration (liste, vecteur, tableau, ...), dans laquelle les nombres de tous les sommets adjacents Ã  celui-ci seront stockÃ©s.  Pour les graphes orientÃ©s, nous ne listerons que les sommets dans lesquels il y a une arÃªte "dirigÃ©e" de l'attribut vertex.  Pour les graphiques pondÃ©rÃ©s, l'implÃ©mentation sera plus complexe. <br><br>  2.2 <b>Liste des cÃ´tes.</b>  Structure de donnÃ©es assez populaire.  La liste des arÃªtes, comme nous le dit Captain Evidence, est en fait une liste des arÃªtes du graphique, chacune Ã©tant dÃ©finie par un sommet initial, un sommet final (pour les graphiques non orientÃ©s, l'ordre n'est pas important ici, bien que diffÃ©rentes rÃ¨gles puissent Ãªtre utilisÃ©es pour l'unification, par exemple, spÃ©cifiez les sommets dans l'ordre croissant) et le poids (uniquement pour les graphiques pondÃ©rÃ©s). <br><br>  Ã€ propos des listes de matrices rÃ©pertoriÃ©es ci-dessus, vous pouvez voir (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ) plus en dÃ©tail. <br><br>  2.3 <b>Tableau d'adjacence.</b>  Pas la structure la plus courante.  Ã€ la base, il s'agit d'une forme de Â«regroupementÂ» de listes d'adjacence dans une structure d'Ã©numÃ©ration (tableau, vecteur).  Les n premiers Ã©lÃ©ments (par le nombre de sommets de graphe) d'un tel tableau contiennent des indices de dÃ©but du mÃªme tableau, Ã  partir desquels tous les sommets adjacents Ã  celui-ci sont Ã©crits dans une rangÃ©e. <br><br>  Ici, j'ai trouvÃ© l'explication la plus comprÃ©hensible (pour moi): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ejuo.livejournal.com/4518.html</a> <br><br><h2>  3. Vecteur d'adjacence et rÃ©seau d'adjacence associatif </h2><br>  Cela s'est produit de sorte que l'auteur de ces lignes, n'Ã©tant pas un programmeur professionnel, mais traitant pÃ©riodiquement de graphiques, s'occupait le plus souvent de listes d'arÃªtes.  En effet, il est pratique que le graphe comporte plusieurs boucles et arÃªtes.  Et maintenant, dans le dÃ©veloppement des listes classiques d'arÃªtes, je propose de prÃªter attention Ã  leur Â«dÃ©veloppement / ramification / modification / mutationÂ», Ã  savoir: le vecteur d'adjacence et le tableau associatif d'adjacence. <br><br>  <b>3.1 Vecteur d'adjacence</b> <br><br>  <i>Cas (A1): nombre non pondÃ©rÃ©</i> <br><br>  Nous appellerons le vecteur d'adjacence pour un graphe non pondÃ©rÃ© un ensemble ordonnÃ© d'un nombre pair d'entiers (a [2i], a [2i + 1], ..., oÃ¹ i est numÃ©rotÃ© c 0), dans lequel chaque paire de nombres a [2i], a [2i +1] dÃ©finit le bord du graphe entre les sommets a [2i] et a [2i + 1], respectivement. <br>  Ce format d'enregistrement ne contient aucune information indiquant si le graphique est orientÃ© (les deux options sont possibles).  Lors de l'utilisation du format digraph, on suppose que le bord est dirigÃ© d'un [2i] vers un [2i + 1].  Ci-aprÃ¨s: pour les graphiques non orientÃ©s, si nÃ©cessaire, les exigences relatives Ã  l'ordre d'enregistrement des sommets peuvent Ãªtre appliquÃ©es (par exemple, de sorte que le sommet avec la valeur la plus basse du nombre qui lui est attribuÃ© passe en premier). <br><br>  En C ++, il est conseillÃ© de spÃ©cifier le vecteur d'adjacence en utilisant std :: vector, Ã  partir duquel le nom de cette structure de donnÃ©es a Ã©tÃ© choisi. <br><br>  <i>Cas (a2): graphique non pondÃ©rÃ©, poids de bord entiers</i> <br><br>  Par analogie avec le cas (a1), nous appelons le vecteur d'adjacence pour un graphe pondÃ©rÃ© avec des poids de bord entiers un ensemble ordonnÃ© (tableau dynamique) de nombres (a [3i], a [3i + 1], a [3i + 2], ..., oÃ¹ i est numÃ©rotÃ©e c 0), oÃ¹ chaque "triplet" des nombres a [3i], a [3i + 1], a [3i + 2] dÃ©finit le bord du graphique entre les sommets sous les nombres a [3i] et a [3i + 1], respectivement, et la valeur de [3i + 2] est le poids de cette arÃªte.  Un tel graphique peut Ã©galement Ãªtre orientÃ© ou non. <br><br>  <i>Cas (b): graphique non pondÃ©rÃ©, poids de bord non entiers</i> <br><br>  Comme les Ã©lÃ©ments hÃ©tÃ©rogÃ¨nes ne peuvent pas Ãªtre stockÃ©s dans un seul tableau (vecteur), l'implÃ©mentation suivante est possible, par exemple.  Le graphique est stockÃ© dans une paire de vecteurs, dans lesquels le premier vecteur est le vecteur d'adjacence du graphique sans indiquer de poids, et le deuxiÃ¨me vecteur contient les poids correspondants (une implÃ©mentation possible pour C ++ est: std :: pair &lt;std :: vector, std :: vector&gt;).  Ainsi, pour une arÃªte dÃ©finie par une paire de sommets sous les indices 2i, 2i + 1 du premier vecteur, le poids sera Ã©gal Ã  l'Ã©lÃ©ment sous l'indice i du deuxiÃ¨me vecteur. <br><br>  <i>Eh bien, pourquoi est-ce nÃ©cessaire?</i> <br><br>  Eh bien, pour l'auteur de ces lignes pour rÃ©soudre un certain nombre de problÃ¨mes, cela semblait trÃ¨s utile.  Eh bien, d'un point de vue formel, il y aura de tels avantages: <br><br><ul><li>  Le vecteur d'adjacence, comme toute autre structure "Ã©numÃ©rative", est suffisamment compact, prend moins de mÃ©moire que la matrice d'adjacence (pour les graphiques clairsemÃ©s), est relativement facile Ã  implÃ©menter. </li><li>  Les sommets du graphique, en principe, peuvent Ãªtre marquÃ©s par des nombres nÃ©gatifs.  Du coup, une telle Â«perversionÂ» s'impose Ã©galement. </li><li>  Les graphiques peuvent contenir plusieurs arÃªtes et plusieurs boucles, avec des pondÃ©rations diffÃ©rentes (positives, nÃ©gatives, voire nulles).  Il n'y a aucune restriction ici. </li><li>  Et les cÃ´tes peuvent avoir des propriÃ©tÃ©s diffÃ©rentes - mais Ã  ce sujet, voir le paragraphe 4. </li></ul><br>  Cependant, je dois admettre que cette Â«listotÂ» n'implique pas un accÃ¨s rapide Ã  la cÃ´te.  Et ici, le tableau d'adjacence associative se dÃ©pÃªche d'aider, dont - ci-dessous. <br><br>  <b>3.2 Tableau d'adjacence associative</b> <br><br>  Donc, si pour nous l'accÃ¨s Ã  un bord particulier, son poids et d'autres propriÃ©tÃ©s sont critiques et que les besoins en mÃ©moire ne permettent pas l'utilisation d'une matrice d'adjacence, alors rÃ©flÃ©chissons Ã  la faÃ§on dont vous pouvez changer le vecteur d'adjacence pour rÃ©soudre ce problÃ¨me.  Ainsi, la clÃ© est le bord du graphique, qui peut Ãªtre dÃ©fini comme une paire ordonnÃ©e d'entiers.  Ã€ quoi Ã§a ressemble?  Serait-ce une clÃ© dans un tableau associatif?  Et si oui, pourquoi ne mettons-nous pas cela en Å“uvre?  Ayons un tel tableau associatif, oÃ¹ chaque clÃ© - une paire ordonnÃ©e d'entiers - sera associÃ©e Ã  une valeur - un entier ou un nombre rÃ©el qui spÃ©cifie le poids du bord.  En C ++, il est conseillÃ© d'implÃ©menter cette structure sur la base du conteneur std :: map (std :: map &lt;std :: pair &lt;int, int&gt;, int&gt; ou std :: map &lt;std :: pair &lt;int, int&gt;, double&gt;) ou std :: multimap si plusieurs arÃªtes sont supposÃ©es.  Eh bien, et ici nous avons une structure pour stocker des graphiques, qui prend moins de mÃ©moire que les structures Â«matriciellesÂ», peut dÃ©finir des graphiques avec plusieurs boucles et arÃªtes et mÃªme sans exigences strictes pour la non-nÃ©gativitÃ© des nombres de sommets (je ne sais pas qui en a besoin, mais quand mÃªme). <br><br><h2>  4. Les structures de donnÃ©es sont au moins Â«inondÃ©esÂ», mais quelque chose manque </h2><br>  Et la vÃ©ritÃ© est: lors de la rÃ©solution d'un certain nombre de problÃ¨mes, nous devrons peut-Ãªtre attribuer certains attributs aux bords du graphique et, en consÃ©quence, les stocker.  S'il est possible de rÃ©duire sans ambiguÃ¯tÃ© ces caractÃ©ristiques en nombres entiers, il est possible de stocker de tels Â«graphiques avec des caractÃ©ristiques supplÃ©mentairesÂ» en utilisant des versions Ã©tendues du vecteur de contiguÃ¯tÃ© et du tableau de contiguÃ¯tÃ© associatif. <br><br>  Donc, ayons un graphe non pondÃ©rÃ©, pour chaque arÃªte dont il faut stocker, par exemple, 2 signes supplÃ©mentaires spÃ©cifiÃ©s par des entiers.  Dans ce cas, il est possible de spÃ©cifier son vecteur d'adjacence comme un ensemble ordonnÃ© non pas de Â«pairesÂ», mais de Â«quatuorsÂ» d'entiers (a [2i], a [2i + 1], a [2i + 2], a [2i + 3] .. .), oÃ¹ un [2i + 2] et un [2i + 3] dÃ©termineront les caractÃ©ristiques du bord correspondant.  Pour un graphique avec des poids de bord entiers, l'ordre est gÃ©nÃ©ralement similaire (la seule diffÃ©rence est que les signes suivent le poids du bord et sont donnÃ©s par les Ã©lÃ©ments a [2i + 3] et a [2i + 4], et le bord lui-mÃªme sera spÃ©cifiÃ© pas 4, mais 5 numÃ©ros ordonnÃ©s).  Et pour un graphique avec des poids de bord non entiers, les attributs peuvent Ãªtre Ã©crits dans sa composante non pondÃ©rÃ©e. <br><br>  Lorsque vous utilisez un tableau de contiguÃ¯tÃ© associatif pour les graphiques avec des poids de bord entiers, il est possible de spÃ©cifier non pas un nombre individuel, mais un tableau (vecteur) de nombres qui spÃ©cifient, en plus du poids du bord, tous ses autres attributs nÃ©cessaires.  En mÃªme temps, l'inconvÃ©nient pour le cas des poids non entiers sera la nÃ©cessitÃ© de spÃ©cifier un caractÃ¨re avec un nombre Ã  virgule flottante (oui, c'est un inconvÃ©nient, mais s'il n'y a pas tellement de tels signes, et si vous ne les dÃ©finissez pas trop "dÃ©licat" double, alors ce ne sera peut-Ãªtre rien) .  Et donc, en C ++, les tableaux d'adjacence associative Ã©tendue peuvent Ãªtre dÃ©finis comme suit: std :: map &lt;std :: pair &lt;int, int&gt;, std :: vector&gt; ou std :: map &lt;std :: pair &lt;int, int&gt;, std :: vector, avec la premiÃ¨re valeur dans "vector-value-by-key" est le poids du bord, puis les dÃ©signations numÃ©riques de ses caractÃ©ristiques sont localisÃ©es. <br><br><h2>  RÃ©fÃ©rences: </h2><br>  <i>Ã€ propos des graphiques et algorithmes en gÃ©nÃ©ral:</i> <br><br>  1. Cormen, Thomas H., Leiserson, Charles I., Rivest, Ronald L., Stein, Clifford.  Algorithmes: construction et analyse, 2e Ã©dition: Per.  de l'anglais  - M.: Williams Publishing House, 2011. <br>  2. Harari Frank.  ThÃ©orie des graphes.  M .: Mir, 1973. <br>  <i>Le rapport de l'auteur sur ces mÃªmes vecteurs et tableau associatif d'adjacence:</i> <br>  3. Chernoukhov S.A.  Vecteur d'adjacence et tableau d'adjacence associatif comme moyens de reprÃ©senter et de stocker des graphiques / SA Chernouhov.  Vecteur d'adjacence et carte d'adjacence comme structures de donnÃ©es pour reprÃ©senter un graphique // Collection d'articles de la confÃ©rence internationale scientifique et pratique "ProblÃ¨mes de mise en Å“uvre des rÃ©sultats de dÃ©veloppements innovants et moyens de les rÃ©soudre" (Saratov, 14 septembre 2019).  - Sterlitamak: AMI, 2019, p.  65-69 <br>  <i>Sources Internet utiles sur le sujet:</i> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.prog-cpp.ru/data-graph</a> <br>  5. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ejuo.livejournal.com/4518.html</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469967/">https://habr.com/ru/post/fr469967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469945/index.html">Est-il important que les ordinateurs et les gens voient le monde diffÃ©remment?</a></li>
<li><a href="../fr469947/index.html">De minuscules images Docker qui croyaient en elles-mÃªmes *</a></li>
<li><a href="../fr469949/index.html">Le jour de l'anniversaire de Yuri Knorozov: nous Ã©tudions les bases de l'Ã©criture maya</a></li>
<li><a href="../fr469955/index.html">Custdev, services sophistiquÃ©s et art de la prÃ©sentation: ce que nous avons enseignÃ© aux participants de l'accÃ©lÃ©rateur VTB</a></li>
<li><a href="../fr469961/index.html">Rust chez Microsoft (ou la crÃ©ation de Security Daemon Azure IoT Edge)</a></li>
<li><a href="../fr469975/index.html">Chemin de Santiago avec ordinateur portable</a></li>
<li><a href="../fr469977/index.html">Comment trois camarades de classe sont devenus partenaires Facebook - histoire Revealbot</a></li>
<li><a href="../fr469979/index.html">Enregistrements des rapports de la deuxiÃ¨me iOS mitap Redmadrobot</a></li>
<li><a href="../fr469981/index.html">Que contient le chat bot?</a></li>
<li><a href="../fr469985/index.html">AccÃ©lÃ©rer un programme pour un processeur synthÃ©tisÃ© Redd sans optimisation: remplacer une horloge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>