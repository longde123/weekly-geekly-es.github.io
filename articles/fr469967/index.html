<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🏭 📂 💟 Structures de données pour le stockage des graphes: un examen de l'existant et deux "presque nouveaux" ☝🏾 🤟🏾 ⏰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous. 

 Dans cette note, j'ai décidé d'énumérer les principales structures de données utilisées pour stocker des graphiques en informatique...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Structures de données pour le stockage des graphes: un examen de l'existant et deux "presque nouveaux"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469967/">  Bonjour à tous. <br><br>  Dans cette note, j'ai décidé d'énumérer les principales structures de données utilisées pour stocker des graphiques en informatique et de parler également de quelques autres structures qui se sont cristallisées par moi-même. <br><br>  Commençons donc.  Mais pas depuis le tout début - je pense ce qu'est un graphique et ce qu'il est (orienté, non orienté, pondéré, non pondéré, avec plusieurs bords et boucles ou sans eux), nous le savons tous déjà. <br><br>  Alors allons-y.  Quelles sont les options pour les structures de données pour le "stockage graphique" que nous avons. <br><a name="habracut"></a><br><h2>  1. Structures de données matricielles </h2><br>  1.1 <b>Matrice d'adjacence.</b>  La matrice d'adjacence est une matrice où les en-têtes de ligne et de colonne correspondent aux numéros des sommets du graphique, et la valeur de chacun de ses éléments a (i, j) est déterminée par la présence ou l'absence d'arêtes entre les sommets i et j (il est clair qu'une telle matrice pour un graphique non orienté sera symétrique, eh bien, ou vous pouvez convenir que nous stockons toutes les valeurs uniquement au-dessus de la diagonale principale).  Pour les graphiques non pondérés, a (i, j) peut être spécifié par le nombre d'arêtes de i à j (s'il n'y en a pas, alors a (i, j) = 0), et pour les courbes pondérées, par le poids (poids total) des arêtes mentionnées. <br><br>  1.2 <b>La matrice d'incidence.</b>  Dans ce cas, notre graphique est également stocké dans un tableau, dans lequel, en règle générale, les numéros de ligne correspondent aux numéros de ses sommets, et les numéros de colonne correspondent à des bords prénumérotés.  Si le sommet et le bord sont incidents l'un à l'autre, alors une valeur non nulle est écrite dans la cellule correspondante (pour les graphiques non orientés, 1 est écrit dans le cas de l'incidence du sommet et du bord, pour les graphiques orientés "1" si le bord "quitte" le sommet et "-1" si c'est le cas). il «entre» (on s'en souvient assez facilement, car le signe moins semble également être «inclus» dans le nombre «-1»)).  Pour les graphiques pondérés, encore une fois, au lieu de 1 et -1, vous pouvez spécifier le poids total de l'arête. <br><br><h2>  2. Structures de données d'énumération </h2><br>  2.1 <b>liste d'adjacence.</b>  Eh bien, tout semble simple.  En général, chaque sommet d'un graphe peut être associé à n'importe quelle structure d'énumération (liste, vecteur, tableau, ...), dans laquelle les nombres de tous les sommets adjacents à celui-ci seront stockés.  Pour les graphes orientés, nous ne listerons que les sommets dans lesquels il y a une arête "dirigée" de l'attribut vertex.  Pour les graphiques pondérés, l'implémentation sera plus complexe. <br><br>  2.2 <b>Liste des côtes.</b>  Structure de données assez populaire.  La liste des arêtes, comme nous le dit Captain Evidence, est en fait une liste des arêtes du graphique, chacune étant définie par un sommet initial, un sommet final (pour les graphiques non orientés, l'ordre n'est pas important ici, bien que différentes règles puissent être utilisées pour l'unification, par exemple, spécifiez les sommets dans l'ordre croissant) et le poids (uniquement pour les graphiques pondérés). <br><br>  À propos des listes de matrices répertoriées ci-dessus, vous pouvez voir (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ) plus en détail. <br><br>  2.3 <b>Tableau d'adjacence.</b>  Pas la structure la plus courante.  À la base, il s'agit d'une forme de «regroupement» de listes d'adjacence dans une structure d'énumération (tableau, vecteur).  Les n premiers éléments (par le nombre de sommets de graphe) d'un tel tableau contiennent des indices de début du même tableau, à partir desquels tous les sommets adjacents à celui-ci sont écrits dans une rangée. <br><br>  Ici, j'ai trouvé l'explication la plus compréhensible (pour moi): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ejuo.livejournal.com/4518.html</a> <br><br><h2>  3. Vecteur d'adjacence et réseau d'adjacence associatif </h2><br>  Cela s'est produit de sorte que l'auteur de ces lignes, n'étant pas un programmeur professionnel, mais traitant périodiquement de graphiques, s'occupait le plus souvent de listes d'arêtes.  En effet, il est pratique que le graphe comporte plusieurs boucles et arêtes.  Et maintenant, dans le développement des listes classiques d'arêtes, je propose de prêter attention à leur «développement / ramification / modification / mutation», à savoir: le vecteur d'adjacence et le tableau associatif d'adjacence. <br><br>  <b>3.1 Vecteur d'adjacence</b> <br><br>  <i>Cas (A1): nombre non pondéré</i> <br><br>  Nous appellerons le vecteur d'adjacence pour un graphe non pondéré un ensemble ordonné d'un nombre pair d'entiers (a [2i], a [2i + 1], ..., où i est numéroté c 0), dans lequel chaque paire de nombres a [2i], a [2i +1] définit le bord du graphe entre les sommets a [2i] et a [2i + 1], respectivement. <br>  Ce format d'enregistrement ne contient aucune information indiquant si le graphique est orienté (les deux options sont possibles).  Lors de l'utilisation du format digraph, on suppose que le bord est dirigé d'un [2i] vers un [2i + 1].  Ci-après: pour les graphiques non orientés, si nécessaire, les exigences relatives à l'ordre d'enregistrement des sommets peuvent être appliquées (par exemple, de sorte que le sommet avec la valeur la plus basse du nombre qui lui est attribué passe en premier). <br><br>  En C ++, il est conseillé de spécifier le vecteur d'adjacence en utilisant std :: vector, à partir duquel le nom de cette structure de données a été choisi. <br><br>  <i>Cas (a2): graphique non pondéré, poids de bord entiers</i> <br><br>  Par analogie avec le cas (a1), nous appelons le vecteur d'adjacence pour un graphe pondéré avec des poids de bord entiers un ensemble ordonné (tableau dynamique) de nombres (a [3i], a [3i + 1], a [3i + 2], ..., où i est numérotée c 0), où chaque "triplet" des nombres a [3i], a [3i + 1], a [3i + 2] définit le bord du graphique entre les sommets sous les nombres a [3i] et a [3i + 1], respectivement, et la valeur de [3i + 2] est le poids de cette arête.  Un tel graphique peut également être orienté ou non. <br><br>  <i>Cas (b): graphique non pondéré, poids de bord non entiers</i> <br><br>  Comme les éléments hétérogènes ne peuvent pas être stockés dans un seul tableau (vecteur), l'implémentation suivante est possible, par exemple.  Le graphique est stocké dans une paire de vecteurs, dans lesquels le premier vecteur est le vecteur d'adjacence du graphique sans indiquer de poids, et le deuxième vecteur contient les poids correspondants (une implémentation possible pour C ++ est: std :: pair &lt;std :: vector, std :: vector&gt;).  Ainsi, pour une arête définie par une paire de sommets sous les indices 2i, 2i + 1 du premier vecteur, le poids sera égal à l'élément sous l'indice i du deuxième vecteur. <br><br>  <i>Eh bien, pourquoi est-ce nécessaire?</i> <br><br>  Eh bien, pour l'auteur de ces lignes pour résoudre un certain nombre de problèmes, cela semblait très utile.  Eh bien, d'un point de vue formel, il y aura de tels avantages: <br><br><ul><li>  Le vecteur d'adjacence, comme toute autre structure "énumérative", est suffisamment compact, prend moins de mémoire que la matrice d'adjacence (pour les graphiques clairsemés), est relativement facile à implémenter. </li><li>  Les sommets du graphique, en principe, peuvent être marqués par des nombres négatifs.  Du coup, une telle «perversion» s'impose également. </li><li>  Les graphiques peuvent contenir plusieurs arêtes et plusieurs boucles, avec des pondérations différentes (positives, négatives, voire nulles).  Il n'y a aucune restriction ici. </li><li>  Et les côtes peuvent avoir des propriétés différentes - mais à ce sujet, voir le paragraphe 4. </li></ul><br>  Cependant, je dois admettre que cette «listot» n'implique pas un accès rapide à la côte.  Et ici, le tableau d'adjacence associative se dépêche d'aider, dont - ci-dessous. <br><br>  <b>3.2 Tableau d'adjacence associative</b> <br><br>  Donc, si pour nous l'accès à un bord particulier, son poids et d'autres propriétés sont critiques et que les besoins en mémoire ne permettent pas l'utilisation d'une matrice d'adjacence, alors réfléchissons à la façon dont vous pouvez changer le vecteur d'adjacence pour résoudre ce problème.  Ainsi, la clé est le bord du graphique, qui peut être défini comme une paire ordonnée d'entiers.  À quoi ça ressemble?  Serait-ce une clé dans un tableau associatif?  Et si oui, pourquoi ne mettons-nous pas cela en œuvre?  Ayons un tel tableau associatif, où chaque clé - une paire ordonnée d'entiers - sera associée à une valeur - un entier ou un nombre réel qui spécifie le poids du bord.  En C ++, il est conseillé d'implémenter cette structure sur la base du conteneur std :: map (std :: map &lt;std :: pair &lt;int, int&gt;, int&gt; ou std :: map &lt;std :: pair &lt;int, int&gt;, double&gt;) ou std :: multimap si plusieurs arêtes sont supposées.  Eh bien, et ici nous avons une structure pour stocker des graphiques, qui prend moins de mémoire que les structures «matricielles», peut définir des graphiques avec plusieurs boucles et arêtes et même sans exigences strictes pour la non-négativité des nombres de sommets (je ne sais pas qui en a besoin, mais quand même). <br><br><h2>  4. Les structures de données sont au moins «inondées», mais quelque chose manque </h2><br>  Et la vérité est: lors de la résolution d'un certain nombre de problèmes, nous devrons peut-être attribuer certains attributs aux bords du graphique et, en conséquence, les stocker.  S'il est possible de réduire sans ambiguïté ces caractéristiques en nombres entiers, il est possible de stocker de tels «graphiques avec des caractéristiques supplémentaires» en utilisant des versions étendues du vecteur de contiguïté et du tableau de contiguïté associatif. <br><br>  Donc, ayons un graphe non pondéré, pour chaque arête dont il faut stocker, par exemple, 2 signes supplémentaires spécifiés par des entiers.  Dans ce cas, il est possible de spécifier son vecteur d'adjacence comme un ensemble ordonné non pas de «paires», mais de «quatuors» d'entiers (a [2i], a [2i + 1], a [2i + 2], a [2i + 3] .. .), où un [2i + 2] et un [2i + 3] détermineront les caractéristiques du bord correspondant.  Pour un graphique avec des poids de bord entiers, l'ordre est généralement similaire (la seule différence est que les signes suivent le poids du bord et sont donnés par les éléments a [2i + 3] et a [2i + 4], et le bord lui-même sera spécifié pas 4, mais 5 numéros ordonnés).  Et pour un graphique avec des poids de bord non entiers, les attributs peuvent être écrits dans sa composante non pondérée. <br><br>  Lorsque vous utilisez un tableau de contiguïté associatif pour les graphiques avec des poids de bord entiers, il est possible de spécifier non pas un nombre individuel, mais un tableau (vecteur) de nombres qui spécifient, en plus du poids du bord, tous ses autres attributs nécessaires.  En même temps, l'inconvénient pour le cas des poids non entiers sera la nécessité de spécifier un caractère avec un nombre à virgule flottante (oui, c'est un inconvénient, mais s'il n'y a pas tellement de tels signes, et si vous ne les définissez pas trop "délicat" double, alors ce ne sera peut-être rien) .  Et donc, en C ++, les tableaux d'adjacence associative étendue peuvent être définis comme suit: std :: map &lt;std :: pair &lt;int, int&gt;, std :: vector&gt; ou std :: map &lt;std :: pair &lt;int, int&gt;, std :: vector, avec la première valeur dans "vector-value-by-key" est le poids du bord, puis les désignations numériques de ses caractéristiques sont localisées. <br><br><h2>  Références: </h2><br>  <i>À propos des graphiques et algorithmes en général:</i> <br><br>  1. Cormen, Thomas H., Leiserson, Charles I., Rivest, Ronald L., Stein, Clifford.  Algorithmes: construction et analyse, 2e édition: Per.  de l'anglais  - M.: Williams Publishing House, 2011. <br>  2. Harari Frank.  Théorie des graphes.  M .: Mir, 1973. <br>  <i>Le rapport de l'auteur sur ces mêmes vecteurs et tableau associatif d'adjacence:</i> <br>  3. Chernoukhov S.A.  Vecteur d'adjacence et tableau d'adjacence associatif comme moyens de représenter et de stocker des graphiques / SA Chernouhov.  Vecteur d'adjacence et carte d'adjacence comme structures de données pour représenter un graphique // Collection d'articles de la conférence internationale scientifique et pratique "Problèmes de mise en œuvre des résultats de développements innovants et moyens de les résoudre" (Saratov, 14 septembre 2019).  - Sterlitamak: AMI, 2019, p.  65-69 <br>  <i>Sources Internet utiles sur le sujet:</i> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.prog-cpp.ru/data-graph</a> <br>  5. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ejuo.livejournal.com/4518.html</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469967/">https://habr.com/ru/post/fr469967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469945/index.html">Est-il important que les ordinateurs et les gens voient le monde différemment?</a></li>
<li><a href="../fr469947/index.html">De minuscules images Docker qui croyaient en elles-mêmes *</a></li>
<li><a href="../fr469949/index.html">Le jour de l'anniversaire de Yuri Knorozov: nous étudions les bases de l'écriture maya</a></li>
<li><a href="../fr469955/index.html">Custdev, services sophistiqués et art de la présentation: ce que nous avons enseigné aux participants de l'accélérateur VTB</a></li>
<li><a href="../fr469961/index.html">Rust chez Microsoft (ou la création de Security Daemon Azure IoT Edge)</a></li>
<li><a href="../fr469975/index.html">Chemin de Santiago avec ordinateur portable</a></li>
<li><a href="../fr469977/index.html">Comment trois camarades de classe sont devenus partenaires Facebook - histoire Revealbot</a></li>
<li><a href="../fr469979/index.html">Enregistrements des rapports de la deuxième iOS mitap Redmadrobot</a></li>
<li><a href="../fr469981/index.html">Que contient le chat bot?</a></li>
<li><a href="../fr469985/index.html">Accélérer un programme pour un processeur synthétisé Redd sans optimisation: remplacer une horloge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>