<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼 🤸🏽 🧜🏿 Integritas Data dalam Arsitektur Layanan Mikro - Cara Memastikannya Tanpa Transaksi Terdistribusi dan Konektivitas yang Kuat 👨🏼‍🏭 🧗🏽 🚴🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya. Seperti yang Anda ketahui, saya biasa menulis dan berbicara lebih banyak tentang penyimpanan, Vertica, penyimpanan data besar dan hal-h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Integritas Data dalam Arsitektur Layanan Mikro - Cara Memastikannya Tanpa Transaksi Terdistribusi dan Konektivitas yang Kuat</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/426101/"><p>  Halo semuanya.  Seperti yang Anda ketahui, saya biasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis</a> dan berbicara lebih banyak tentang penyimpanan, Vertica, penyimpanan data besar dan hal-hal analitis lainnya.  Sekarang semua database lain telah jatuh ke dalam bidang tanggung jawab saya, tidak hanya analitis, tetapi juga OLTP (PostgreSQL), dan NOSQL (MongoDB, Redis, Tarantool). </p><br><p>  Situasi ini memungkinkan saya untuk melihat organisasi yang memiliki beberapa basis data sebagai organisasi yang memiliki satu basis data yang terdistribusi heterogen (heterogen).  Sebuah database heterogen terdistribusi tunggal, terdiri dari sekelompok PostgreSQL, Redis dan Mong ... Dan, mungkin, satu atau dua database Vertica. </p><br><p> Pekerjaan dari pangkalan terdistribusi tunggal ini menghasilkan banyak tugas menarik.  Pertama-tama, dari sudut pandang bisnis, penting bahwa semuanya normal dengan data bergerak di sepanjang pangkalan tersebut.  Saya tidak secara khusus menggunakan istilah integritas, konsistensi, karena  istilah ini kompleks, dan dalam nuansa yang berbeda dalam mempertimbangkan DBMS (teorema <strong>C</strong> ID dan <strong>C</strong> AP) ia memiliki arti yang berbeda. </p><br><p>  Situasi dengan basis terdistribusi diperburuk jika perusahaan mencoba untuk beralih ke arsitektur layanan-mikro.  Di bawah kucing, saya berbicara tentang bagaimana memastikan integritas data dalam arsitektur layanan mikro tanpa transaksi terdistribusi dan konektivitas yang ketat.  (Dan pada akhirnya saya jelaskan mengapa saya memilih ilustrasi ini untuk artikel). </p><br><p><img src="https://habrastorage.org/webt/br/li/ui/brliuiadpszbdp6shhwg-a7agpu.png"></p><a name="habracut"></a><br><p>  Menurut Chris Richardson (salah satu penginjil paling terkenal dari arsitektur layanan mikro), arsitektur ini memiliki dua pendekatan untuk bekerja dengan database: database bersama dan basis data per layanan. </p><br><p><img src="https://habrastorage.org/webt/ry/jh/xk/ryjhxkec5ilup0adwjqav-aoikg.png"></p><br><p>  Basis data bersama adalah langkah pertama yang baik, solusi yang bagus untuk perusahaan kecil tanpa rencana pertumbuhan yang ambisius.  Selain itu, pola ini sendiri merupakan anti-pola dari sudut pandang arsitektur layanan microsoft  dua layanan yang berbagi basis umum tidak dapat diuji dan diskalakan secara independen.  Yaitu  alih-alih, layanan ini adalah salah satu layanan yang cenderung menjadi monolit. </p><br><p>  Pola basis data per layanan mengasumsikan bahwa setiap layanan memiliki basis datanya sendiri.  Suatu layanan dapat mengakses data layanan lain hanya melalui API (dalam arti luas), tanpa koneksi langsung ke basis datanya. </p><br><p>  Pola basis data per layanan memungkinkan tim layanan terkait untuk memilih database yang mereka inginkan.  Seseorang dapat di MongoDB, seseorang percaya pada PostgreSQL, seseorang membutuhkan Redis (risiko kehilangan data saat dimatikan dapat diterima untuk layanan ini), dan seseorang umumnya menyimpan data dalam file CSV pada disk (dan mengapa, sebenarnya , dan tidak?). </p><br><p><img src="https://habrastorage.org/webt/8y/uf/ln/8yuflnhn4nzbfso12xm39_6_p9u.png"></p><br><p>  Bekerja dengan “kebun binatang” basis data meningkatkan tugas memulihkan urutan data ke tingkat kompleksitas yang sama sekali baru. </p><br><h1 id="acid-i-mikroservisnaya-arhitektura">  ACID dan arsitektur microservice </h1><br><p>  Mari kita lihat tugas mengatur segala sesuatunya melalui prisma dari serangkaian persyaratan ACID berbasis DBMS klasik: kita akan memperluas esensi setiap huruf singkatan dan menggambarkan kesulitan dengan huruf ini dalam arsitektur layanan mikro. </p><br><p>  <strong>(A) CID - Atomicity.</strong>  <strong>Atomicity - semua atau tidak sama sekali.</strong> </p><br><p>  Menurut persyaratan Atomicity, sangat penting untuk menyelesaikan semua langkah (dengan kemungkinan pengulangan), jika langkah penting gagal, batalkan langkah yang sudah selesai. </p><br><p>  Ilustrasi di atas menunjukkan proses pengujian untuk membeli layanan VIP: uang dicadangkan dalam penagihan (1), layanan bonus (2) diaktifkan untuk pengguna, jenis pengguna diubah menjadi Pro (3), uang pesanan dalam penagihan didebit (4).  Keempat langkah harus diselesaikan atau tidak selesai. </p><br><p><img src="https://habrastorage.org/webt/ag/gt/cx/aggtcxiv5ip-anc82hoivfcpxyg.png"></p><br><p>  Dalam hal ini, Anda tidak dapat menggantung di tengah proses, oleh karena itu, sinkronisasi lebih disukai, dalam kasus ekstrim, sinkronisasi dengan batas waktu bawaan. </p><br><p>  <strong>A (C) ID - Konsistensi.</strong>  <strong>Konsistensi - setiap langkah tidak boleh bertentangan dengan kondisi batas.</strong> </p><br><p>  Contoh klasik kondisi untuk, misalnya, mengirim uang dari klien A dalam layanan 1 ke klien B dalam layanan 2: sebagai akibat dari pengiriman uang tersebut tidak boleh kurang (uang tidak boleh hilang selama transfer) atau lebih (tidak dapat diterima untuk mengirim uang yang sama ke dua pengguna pada saat bersamaan).  Untuk mematuhi persyaratan ini, Anda perlu kode kondisi di suatu tempat dan memeriksa data untuk kondisi (idealnya, tanpa panggilan tambahan). </p><br><p><img src="https://habrastorage.org/webt/hz/ha/zn/hzhazn63hlnpo7hojezmf5gmuyw.png"></p><br><p>  <strong>ACI (D) - Daya Tahan.</strong>  <strong>Persyaratan Daya Tahan berarti bahwa efek operasi tidak hilang.</strong> </p><br><p>  Dalam kondisi kegigihan Polyglot, suatu layanan dapat beroperasi pada basis data yang secara teratur dapat "kehilangan" data yang dicatat di dalamnya.  Trik serupa dapat diperoleh bahkan dari database padat seperti PostgreSQL, jika replikasi asinkron diaktifkan di sana.  Ilustrasi menunjukkan bagaimana perubahan yang direkam dalam Master, tetapi yang tidak mencapai Slave melalui replikasi asinkron, dapat dihancurkan dengan membakar server Master.  Untuk memastikan persyaratan Daya Tahan, perlu untuk dapat mendiagnosis dan memulihkan kerugian tersebut dengan benar. </p><br><p><img src="https://habrastorage.org/webt/du/y0/fv/duy0fv-a9l8auvniphyeguskx_g.png"></p><br><p>  <strong>Dan di mana saya, Anda bertanya?</strong> </p><br><p>  Dan tidak ada tempat.  Isolasi dalam lingkungan beberapa layanan asinkron independen adalah persyaratan teknis.  Penelitian modern telah menunjukkan bahwa proses bisnis nyata dapat diimplementasikan tanpa isolasi.  Isolasi menyederhanakan pemikiran dengan meminimalkan konkurensi (mengembangkan komputasi paralel lebih sulit bagi seorang programmer), tetapi arsitektur layanan mikro secara paralel paralel, isolasi dalam lingkungan seperti itu berlebihan. </p><br><p>  Ada banyak pendekatan untuk mencapai kepatuhan dengan persyaratan di atas.  Algoritma yang paling dikenal luas dari transaksi terdistribusi yang disediakan oleh apa yang disebut dua fase komitmen (2PC).  Sayangnya, menerapkan komitmen dua fase memerlukan penulisan ulang semua layanan yang terlibat.  Dan yang paling serius: algoritma ini tidak terlalu produktif.  Ilustrasi dari penelitian terbaru menunjukkan bahwa algoritma ini menunjukkan kinerja tertentu pada basis terdistribusi dari dua server, tetapi dengan peningkatan jumlah server, produktivitas tidak tumbuh secara linear ... Atau lebih tepatnya, tidak tumbuh sama sekali. </p><br><p><img src="https://habrastorage.org/webt/2t/eh/c6/2tehc6ckxsixeoqru14yp75pfy0.png"></p><br><p>  Salah satu keunggulan utama arsitektur layanan-mikro adalah kemampuan untuk meningkatkan kinerja secara linear dengan hanya menambah lebih banyak server.  Ternyata jika kita menggunakan komitmen dua fase untuk memastikan integritas terdistribusi, proses ini akan menjadi hambatan, pembatas pertumbuhan produktivitas, meskipun ada peningkatan jumlah server. </p><br><p>  Bagaimana Anda dapat memastikan integritas terdistribusi (persyaratan ACiD) tanpa komitmen dua fase, dengan kemampuan untuk skala secara linear dalam kinerja? </p><br><p>  Penelitian modern (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Evaluasi Kontrol Concurrency Terdistribusi. VLDB 2017</a> ) berpendapat bahwa apa yang disebut "pendekatan optimistis" dapat membantu.  Perbedaan antara komitmen dua fase dan "pendekatan optimis" umum dapat diilustrasikan oleh perbedaan antara toko lama Soviet (dengan counter) dan supermarket modern seperti Auchan.  Di toko dengan penghitung, setiap pelanggan dianggap mencurigakan, dan disajikan dengan kontrol maksimal.  Karena itu garis dan konflik.  Dan di supermarket, pembeli dianggap jujur ​​secara default, mereka memberinya kesempatan untuk mendekati rak dan mengisi gerobak.  Tentu saja, ada alat pemantauan untuk menangkap penjahat (kamera, keamanan), tetapi sebagian besar pembeli tidak perlu berurusan dengan mereka. </p><br><p>  Oleh karena itu, supermarket dapat ditingkatkan, diperluas, hanya dengan menempatkan lebih banyak meja kas.  Mirip dengan arsitektur microservice: jika integritas terdistribusi dipastikan oleh "pendekatan optimistis", ketika hanya proses di mana sesuatu yang salah ditambahkan dengan pemeriksaan.  Dan proses normal berjalan tanpa pemeriksaan tambahan. </p><br><p>  Itu penting.  "Pendekatan optimis" mencakup beberapa algoritma.  Saya ingin bercerita tentang saga - algoritma untuk menjaga integritas terdistribusi, direkomendasikan oleh Chris Richardson. </p><br><h1 id="sagi--elementy-algoritma">  Sagas - elemen algoritma </h1><br><p>  Algoritma melorot memiliki dua opsi.  Oleh karena itu, pada awalnya saya ingin menjelaskan elemen-elemen algoritma yang diperlukan secara universal sehingga deskripsi tersebut cocok untuk kedua opsi. </p><br><p>  <strong>Elemen 1.</strong> Saluran persisten pengiriman acara yang dapat diandalkan antar layanan, yang menjamin "setidaknya satu kali pengiriman".  Yaitu  jika langkah 2 dari proses telah selesai dengan sukses, maka pemberitahuan (acara) tentang ini harus mencapai langkah 3 setidaknya sekali, pengiriman berulang dapat diterima, tetapi tidak ada yang harus hilang.  "Persistent" berarti bahwa saluran harus menyimpan pemberitahuan untuk beberapa waktu (2-3 hari, seminggu) sehingga layanan yang telah kehilangan perubahan terbaru karena hilangnya basis data (lihat contoh Daya Tahan, pada ilustrasi ini adalah langkah 2), dapat memulihkan perubahan ini dengan memutar ulang acara dari saluran. </p><br><p><img src="https://habrastorage.org/webt/du/kr/sy/dukrsykrnmfcf4u6srrgffx4f5a.png"></p><br><p>  <strong>Elemen 2.</strong> Idempotensi panggilan layanan melalui penggunaan kunci idempotensi unik.  Bayangkan saya (pengguna) memulai proses pembelian paket VIP (lihat contoh untuk Atomicity).  Pada awal proses, saya diberikan kunci unik, kunci idempotensi, misalnya, 42. Selanjutnya, panggilan ke setiap langkah (1 → 2 → 3 → 4) harus dilakukan dengan kunci idempotensi yang ditunjukkan.  Dalam paragraf di atas, kemungkinan kedatangan berulang pesan yang sama ke layanan (dalam langkah) disebutkan.  Layanan (langkah) harus secara otomatis dapat mengabaikan kedatangan berulang dari acara yang diproses, memeriksa pengulangan dengan kunci idempotensi.  Artinya, jika semua layanan (langkah-langkah proses) idempoten, maka untuk memenuhi persyaratan Atomicity dan Daya Tahan, cukup untuk mengarahkan ulang ke langkah-langkah yang terkait dengan acara dari saluran.  Langkah-langkah yang melewatkan acara akan mengeksekusi mereka, dan langkah-langkah yang sudah menyelesaikan acara akan mengabaikannya karena idempotensi. </p><br><p><img src="https://habrastorage.org/webt/1u/5i/0e/1u5i0epymw6_tmvodacj2yeirra.png"></p><br><p>  <strong>Elemen 3.</strong> Pembatalan panggilan layanan (langkah-langkah) oleh kunci idempotency. </p><br><p>  Untuk memastikan Atomicity (lihat contoh), jika proses dengan kunci idempotensi 42, misalnya, berhenti / jatuh pada langkah 3, maka perlu untuk membatalkan keberhasilan pelaksanaan langkah 1 dan 2 untuk kunci 42. Untuk ini, setiap langkah proses wajib harus memiliki langkah "kompensasi" , Metode API yang membatalkan eksekusi langkah yang diperlukan untuk kunci idempotensi yang ditentukan (42).  Implementasi panggilan kompensasi adalah elemen yang sulit tetapi perlu dalam penyempurnaan layanan sebagai bagian dari implementasi algoritma sag. </p><br><p><img src="https://habrastorage.org/webt/rp/oc/pb/rpocpblpnxfk5uw6mk6-2cvywdi.png"></p><br><p>  Tiga elemen yang tercantum di atas relevan untuk kedua versi implementasi "melorot": diatur dan koreografi. </p><br><h1 id="orkestriruemye-sagi">  Sagas yang diatur </h1><br><p>  Algoritma yang lebih sederhana dan lebih jelas untuk kisah-kisah yang diatur lebih mudah dipahami dan diimplementasikan.  Dalam sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang sangat bagus,</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">kevteev</a> menggambarkan algoritma dan proses implementasi dari mekanisme kisah-kisah yang diatur dalam Avito.  Algoritma mereka mengasumsikan adanya layanan kontrol, "mengatur" panggilan layanan dalam kerangka proses bisnis yang dilayani.  Layanan pemantauan yang sama mungkin memiliki database sendiri (misalnya, PostgreSQL), yang bertindak sebagai saluran pengiriman peristiwa persisten yang dapat diandalkan (elemen 1). </p><br><h1 id="horeograficheskie-sagi">  Sagas koreografi </h1><br><p>  Kisah koreografi lebih rumit.  Di sini, bus data yang menerapkan persyaratan berikut ini harus bertindak sebagai saluran persisten yang andal: penerbitan api-dan-lupakan, publikasi-berlangganan pengiriman acara, setidaknya sekali pengiriman.  Yaitu  setiap langkah dari setiap proses harus menerima perintah untuk beroperasi dari bus, dan memberikan pesan tentang penyelesaian yang berhasil, tentang dimulainya langkah berikutnya, sehingga ia juga membacanya dari bus dan melanjutkan prosesnya.  Terlebih lagi, untuk setiap pesan mungkin ada beberapa pelanggan. </p><br><p>  Saga koreografi juga harus memiliki layanan pengendali, layanan kisah, tetapi jauh lebih "ringan".  Layanan harus tahu tentang proses bisnis yang terdaftar dalam sistem, tentang komposisi langkah-langkah yang termasuk dalam setiap proses.  Dia juga harus mendengarkan bus, memantau pelaksanaan setiap proses (setiap kunci idempotensi), dan hanya jika ada yang salah, melempar "pengulangan" langkah-langkah tertentu, atau melempar "membatalkan", "kompensasi" untuk langkah-langkah yang diambil. </p><br><h1 id="nyuansy">  Nuansa </h1><br><p>  Salah satu nuansa terpenting dari kisah-kisah yang membedakan mereka dari transaksi klasik adalah penyimpangan dari linearitas, urutan, dan kewajiban setiap langkah.  Sebuah saga tidak harus berupa rangkaian kejadian linier, ini bisa berupa grafik terarah: acara pendaftaran pengguna baru dapat menghasilkan beberapa langkah secara paralel (mengirim SMS, mendaftarkan login, menghasilkan kata sandi, mengirim email), beberapa di antaranya mungkin opsional.  Dalam perkiraan pertama, tampaknya dalam saga "bercabang" dengan langkah-langkah opsional, sulit untuk menentukan penyelesaian saga (proses), tetapi, pada kenyataannya, semuanya sederhana: saga (proses) selesai ketika semua langkah yang diperlukan selesai, dalam urutan apa pun. </p><br><p><img src="https://habrastorage.org/webt/ta/ff/rz/taffrzux1gpdt5c_-dtqilxmqh4.png"></p><br><p>  Nuansa kedua, yang lebih khas untuk kisah-kisah koreografi, tetapi juga mungkin untuk kisah-kisah yang diatur, adalah memilih pendekatan untuk mendaftarkan proses-proses bisnis, jenis-jenis kisah dalam layanan kisah.  Contoh Atomicity menggambarkan proses empat langkah yang diperlukan berturut-turut. </p><br><p>  Siapa yang mendaftarkan proses ini, mengindikasikan semua langkah, menempatkan dependensi dan langkah-langkah wajib?  Jawaban yang jelas, tetapi kuno adalah bahwa proses registrasi harus dilakukan secara terpusat dalam layanan sag.  Tetapi jawaban ini tidak terlalu konsisten dengan arsitektur microservice.  Dalam arsitektur microservice, lebih menjanjikan, lebih produktif, dan lebih cepat untuk mendaftarkan proses bottom-up.  Yaitu  bukan untuk menuliskan semua nuansa proses dalam layanan sag, tetapi untuk memungkinkan layanan individual untuk "menyesuaikan" ke dalam proses yang ada sendiri, menunjukkan sifat mengikat / opsional dan pendahulunya wajib. </p><br><p>  Yaitu  proses mendaftarkan pengguna dalam layanan sag awalnya mungkin terdiri dari tiga langkah, dan kemudian, selama pengembangan sistem, tujuh langkah lagi akan cocok di sana, dan satu langkah akan dituliskan, dan akan ada sembilan dari mereka.  Skema "anarkis" dan "terdesentralisasi" seperti itu sulit untuk diuji, untuk menerapkan proses yang ketat dan terkoordinasi, tetapi jauh lebih nyaman bagi tim Agile, untuk evolusi produk multi arah yang berkelanjutan. </p><br><p>  Sebenarnya disini.  Dengan presentasi yang serius, saya pikir layak untuk menyelesaikannya, jika tidak artikelnya terlalu besar. </p><br><hr><br><p>  Berikut ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ke presentasi</a> materi ini, saya membuat laporan tentang topik ini di Highload Siberia 2018. <br>  UPD - dan video dari konferensi: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6HvSpqBc8fA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><hr><br><h1 id="epilog">  Epilog </h1><br><p>  Pada akhirnya, saya ingin mencoba menjelaskan semua hal di atas dalam bahasa yang lebih kiasan. <br>  Lagipula, apa saga awalnya?  Plot ini, petualangan ini dari Abad Pertengahan ... Atau dari Game of Thrones.  Sebuah peristiwa terjadi (pertempuran, pernikahan, seseorang meninggal), berita tentang ini terbang di seluruh dunia melalui pembawa pesan, melalui merpati pos, melalui pedagang.  Ketika berita sampai pada mereka yang tertarik (dalam seminggu, dalam sebulan, dalam satu tahun), mereka bereaksi: mereka mengirim tentara, menyatakan perang, mereka mengeksekusi seseorang, dan pesan-pesan baru beterbangan. </p><br><p>  Tidak ada badan pengawas yang memantau urutan tindakan.  Tidak ada transaksi, tidak ada kemunduran, dalam arti membatalkan tindakan, seolah-olah tidak pernah terjadi.  Semua dengan cara dewasa, setiap tindakan berlangsung selamanya.  Itu bisa dikompensasi, tetapi justru tindakan (pembunuhan) dan kompensasi (membayar untuk kepala, vira), dan bukan penghapusan kematian. </p><br><p>  Peristiwa memakan waktu lama, datang dari sumber yang berbeda, tindakan terjadi secara paralel, dan tidak secara berurutan.  Dan cukup sering, peserta baru tiba-tiba muncul di plot, yang memutuskan untuk berpartisipasi (naga tiba;)) ... dan beberapa peserta lama tiba-tiba mati. </p><br><p>  Hal-hal seperti itu.  Sepertinya berantakan dan kacau, tetapi semuanya berfungsi, koordinasi internal dunia tidak dilanggar, plotnya berkembang dan konsisten ... Meskipun terkadang tidak dapat diprediksi. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426101/">https://habr.com/ru/post/id426101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426091/index.html">8 cloud log analyzer untuk mengevaluasi lingkungan kerja</a></li>
<li><a href="../id426093/index.html">Monetisasi data pengguna vs iklan dalam aplikasi: pro dan kontra</a></li>
<li><a href="../id426095/index.html">Buka webinar "Bagaimana tidak menulis dengan Python"</a></li>
<li><a href="../id426097/index.html">Arduino Proyek "Mesin Robot RoboCar4W"</a></li>
<li><a href="../id426099/index.html">Berita Typegram</a></li>
<li><a href="../id426103/index.html">Webinar "Apakah Anda Membutuhkan Kubernetes" 15 Oktober pukul 19:00</a></li>
<li><a href="../id426105/index.html">Tangkapan saya dalam seminggu</a></li>
<li><a href="../id426111/index.html">Google masih akan meluncurkan layanan pencarian yang disensor di Cina</a></li>
<li><a href="../id426113/index.html">Google News dan Leo Tolstoy: Visualisasi Representasi Vektor Kata-kata dengan t-SNE</a></li>
<li><a href="../id426115/index.html">Praktek menggunakan model aktor di platform backend dari Quake Champions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>