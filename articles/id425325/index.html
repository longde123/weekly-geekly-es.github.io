<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏰ 👩🏽‍🏫 👸 Penerjemah Bytecode DIY ⬛️ 👩🏻‍⚖️ 👂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mesin virtual bahasa pemrograman telah menjadi sangat luas dalam beberapa dekade terakhir. Cukup banyak waktu telah berlalu sejak presentasi Java Virt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penerjemah Bytecode DIY</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/425325/"><p><img src="https://habrastorage.org/webt/aa/zv/cl/aazvcl84q5xly1zkqhtxelkemju.png"></p><br><p>  Mesin virtual bahasa pemrograman telah menjadi sangat luas dalam beberapa dekade terakhir.  Cukup banyak waktu telah berlalu sejak presentasi Java Virtual Machine di paruh kedua tahun 90-an, dan aman untuk mengatakan bahwa byte-code interpreter bukanlah masa depan, tetapi masa kini. </p><br><p>  Tetapi teknik ini, menurut pendapat saya, hampir universal, dan memahami prinsip-prinsip dasar pengembangan juru bahasa berguna tidak hanya untuk pencipta penantang berikutnya untuk judul "Bahasa of the Year" menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TIOBE</a> , tetapi untuk setiap programmer pada umumnya. </p><br><p>  Singkatnya, jika Anda tertarik untuk mempelajari bagaimana bahasa pemrograman favorit kami menambah angka, pengembang mesin virtual apa yang masih berdebat dan bagaimana cara mencocokkan string dan ekspresi reguler tanpa rasa sakit, saya minta kucing. </p><a name="habracut"></a><br><p>  Bagian satu, pengantar (saat ini) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian Dua, Mengoptimalkan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian Tiga, Diterapkan</a> </p><br><h1 id="predystoriya">  Latar belakang </h1><br><p>  Salah satu sistem yang ditulis sendiri dari departemen Business Intelligence perusahaan kami memiliki antarmuka dalam bentuk bahasa permintaan yang sederhana.  Dalam versi pertama sistem, bahasa ini ditafsirkan dengan cepat, tanpa kompilasi, langsung dari baris input dengan permintaan.  Versi parser kedua akan sudah bekerja dengan bytecode perantara, yang akan memungkinkan Anda untuk memisahkan bahasa query dari eksekusi dan sangat menyederhanakan kode. </p><br><p> Dalam proses mengerjakan versi kedua sistem, saya berlibur selama satu atau dua jam setiap hari, saya teralihkan dari urusan keluarga untuk mempelajari materi tentang arsitektur dan kinerja penerjemah bytecode.  Saya memutuskan untuk membagikan catatan dan contoh penerjemah yang dihasilkan kepada pembaca Habr sebagai serangkaian artikel. </p><br><p>  Yang pertama dari mereka menyajikan lima mesin virtual kecil (hingga ratusan baris kode C sederhana), yang masing-masing mengungkapkan aspek tertentu dari pengembangan penerjemah tersebut. </p><br><h1 id="otkuda-est-poshli-bayt-kody-v-yazykah-programmirovaniya">  Di mana kode byte digunakan dalam bahasa pemrograman? </h1><br><p>  Banyak sekali mesin virtual, set instruksi virtual yang paling beragam selama beberapa dekade terakhir, telah ditemukan.  Wikipedia mengklaim bahwa bahasa pemrograman pertama mulai dikompilasi ke dalam berbagai representasi menengah yang disederhanakan pada tahun 60an di abad lalu.  Beberapa kode byte pertama dikonversi menjadi kode mesin dan dieksekusi oleh prosesor nyata, sementara yang lain ditafsirkan dengan cepat oleh prosesor virtual. </p><br><p>  Popularitas set instruksi virtual sebagai representasi perantara kode disebabkan oleh tiga alasan: </p><br><ol><li>  Program Bytecode mudah dipindahkan ke platform baru. </li><li>  Penerjemah bytecode lebih cepat daripada penafsir dari pohon kode sintaks. </li><li>  Anda dapat mengembangkan mesin virtual sederhana hanya dalam beberapa jam. </li></ol><br><p>  Mari kita membuat beberapa mesin virtual C sederhana dan menggunakan contoh-contoh ini untuk menyoroti aspek teknis utama penerapan mesin virtual. </p><br><p>  Kode sampel lengkap tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Contoh dapat dikompilasi dengan GCC yang relatif segar: </p><br><pre><code class="plaintext hljs">gcc interpreter-basic-switch.c -o interpreter ./interpreter</code> </pre> <br><p>  Semua contoh memiliki struktur yang sama: pertama datang kode mesin virtual itu sendiri, lalu fungsi utama dengan pernyataan yang memeriksa operasi kode.  Saya mencoba mengomentari dengan jelas opcodes dan tempat-tempat utama dari penerjemah.  Saya harap artikel ini dapat dimengerti bahkan oleh orang-orang yang tidak menulis dalam C setiap hari. </p><br><h1 id="samyy-prostoy-v-mire-interpretator-bayt-koda">  Penerjemah bytecode termudah di dunia </h1><br><p>  Seperti yang saya katakan, juru bahasa paling sederhana sangat mudah dibuat.  Komentar tepat di belakang daftar, tetapi mari kita mulai langsung dengan kode: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> accumulator; } vm; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* increment the register */</span></span> OP_INC, <span class="hljs-comment"><span class="hljs-comment">/* decrement the register */</span></span> OP_DEC, <span class="hljs-comment"><span class="hljs-comment">/* stop execution */</span></span> OP_DONE } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> interpret_result { SUCCESS, ERROR_UNKNOWN_OPCODE, } interpret_result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Reset vm state"</span></span>); vm = (typeof(vm)) { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }; } <span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(); <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Start interpreting"</span></span>); vm.ip = bytecode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *vm.ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_INC: { vm.accumulator++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DEC: { vm.accumulator--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; }</code> </pre><br><p>  Ada kurang dari seratus baris, tetapi semua atribut karakteristik mesin virtual diwakili.  Mesin memiliki register tunggal ( <code>vm.accumulator</code> ), tiga operasi (register increment, register decrement, dan penyelesaian eksekusi program) dan sebuah pointer ke instruksi saat ini ( <code>vm.ip</code> ). </p><br><p>  Setiap operasi (eng. <em>Kode operasi</em> , atau <em>opcode</em> ) dikodekan dengan satu byte, dan penjadwalan dilakukan dengan menggunakan <code>switch</code> biasa dalam fungsi <code>vm_interpret</code> .  Cabang-cabang dalam <code>switch</code> berisi logika operasi, yaitu, mereka mengubah keadaan register atau menyelesaikan eksekusi program. </p><br><p>  Operasi ditransfer ke fungsi <code>vm_interpret</code> dalam bentuk array byte - bytecode (Eng. <em>Bytecode</em> ) - dan secara berurutan dieksekusi sampai operasi <code>OP_DONE</code> mesin virtual ( <code>OP_DONE</code> ) <code>OP_DONE</code> . </p><br><p>  Aspek kunci dari mesin virtual adalah semantik, yaitu serangkaian operasi yang mungkin ada di dalamnya.  Dalam hal ini, hanya ada dua operasi, dan mereka mengubah nilai register tunggal. </p><br><p>  Beberapa peneliti ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teknik Abstraksi dan Optimasi Mesin-Virtual</a> , 2009) mengusulkan membagi mesin virtual menjadi yang <em>tingkat tinggi</em> dan <em>tingkat</em> <em>rendah</em> sesuai dengan kedekatan semantik mesin virtual dengan semantik mesin fisik di mana bytecode akan dieksekusi. </p><br><p>  Dalam kasus ekstrem, bytecode mesin virtual level rendah dapat sepenuhnya mengulangi kode mesin dari mesin fisik dengan RAM yang disimulasikan, satu set register penuh, instruksi untuk bekerja dengan stack, dan sebagainya.  Mesin virtual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bochs</a> , misalnya, mengulangi set instruksi arsitektur x86. </p><br><p>  Dan sebaliknya: operasi mesin virtual tingkat tinggi sangat mencerminkan semantik bahasa pemrograman khusus yang dikompilasi menjadi bytecode.  Jadi, bekerja, misalnya, SQLite, Gawk dan banyak versi Prolog. </p><br><p>  Posisi menengah ditempati oleh penerjemah bahasa pemrograman serba guna yang memiliki elemen level tinggi dan rendah.  Java Virtual Machine paling populer memiliki instruksi level rendah untuk bekerja dengan stack dan dukungan bawaan untuk pemrograman berorientasi objek dengan alokasi memori otomatis. </p><br><p>  Kode di atas lebih cenderung menjadi yang paling primitif dari mesin virtual tingkat rendah: setiap instruksi virtual adalah pembungkus lebih dari satu atau dua instruksi fisik, register virtual sepenuhnya konsisten dengan satu register prosesor "besi". </p><br><h1 id="argumenty-instrukciy-v-bayt-kode">  Argumen instruksi bytecode </h1><br><p>  Kita dapat mengatakan bahwa satu-satunya register dalam contoh mesin virtual kami adalah argumen dan nilai balik dari semua instruksi yang dieksekusi.  Namun, kami mungkin merasa berguna untuk menyampaikan argumen dalam instruksi.  Salah satu caranya adalah dengan meletakkannya dalam bytecode secara langsung. </p><br><p>  Kami akan memperluas contoh dengan memperkenalkan instruksi (OP_ADDI, OP_SUBI) yang mengambil argumen dalam bentuk byte segera setelah opcode: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> accumulator; } vm; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* increment the register */</span></span> OP_INC, <span class="hljs-comment"><span class="hljs-comment">/* decrement the register */</span></span> OP_DEC, <span class="hljs-comment"><span class="hljs-comment">/* add the immediate argument to the register */</span></span> OP_ADDI, <span class="hljs-comment"><span class="hljs-comment">/* subtract the immediate argument from the register */</span></span> OP_SUBI, <span class="hljs-comment"><span class="hljs-comment">/* stop execution */</span></span> OP_DONE } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> interpret_result { SUCCESS, ERROR_UNKNOWN_OPCODE, } interpret_result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Reset vm state"</span></span>); vm = (typeof(vm)) { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }; } <span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(); <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Start interpreting"</span></span>); vm.ip = bytecode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *vm.ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_INC: { vm.accumulator++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DEC: { vm.accumulator--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADDI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> arg = *vm.ip++; vm.accumulator += arg; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_SUBI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> arg = *vm.ip++; vm.accumulator -= arg; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; }</code> </pre><br><p>  Instruksi baru (lihat fungsi <code>vm_interpret</code> ) membaca argumen mereka dari bytecode dan menambahkannya ke register / kurangi dari register. </p><br><p>  Argumen seperti itu disebut <em>argumen langsung</em> , karena terletak langsung di array opcode.  Keterbatasan utama dalam implementasi kami adalah bahwa argumennya adalah satu byte dan hanya dapat mengambil 256 nilai. </p><br><p>  Di mesin virtual kami, kisaran nilai argumen instruksi yang mungkin tidak memainkan peran besar.  Tetapi jika mesin virtual akan digunakan sebagai juru bahasa nyata, maka masuk akal untuk menyulitkan bytecode dengan menambahkan tabel konstanta yang terpisah dari array opcode dan instruksi dengan argumen langsung yang sesuai dengan alamat argumen ini di tabel konstanta. </p><br><h1 id="stekovaya-mashina">  Mesin tumpukan </h1><br><p>  Instruksi dalam mesin virtual kami yang sederhana selalu bekerja dengan satu register dan tidak dapat mengirimkan data satu sama lain dengan cara apa pun.  Selain itu, argumen ke instruksi hanya bisa langsung, dan, katakanlah, operasi penambahan atau perkalian mengambil dua argumen. </p><br><p>  Sederhananya, kami tidak memiliki cara untuk mengevaluasi ekspresi kompleks.  Untuk mengatasi masalah ini, diperlukan mesin bertumpuk, yaitu mesin virtual dengan tumpukan terintegrasi: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STACK_MAX 256 struct { uint8_t *ip; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Fixed-size stack */</span></span></span><span class="hljs-meta"> uint64_t stack[STACK_MAX]; uint64_t *stack_top; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* A single register containing the result */</span></span></span><span class="hljs-meta"> uint64_t result; } vm; typedef enum { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* push the immediate argument onto the stack */</span></span></span><span class="hljs-meta"> OP_PUSHI, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, add and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_ADD, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, subtract and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_SUB, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, divide and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_DIV, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, multiply and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_MUL, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop the top of the stack and set it as execution result */</span></span></span><span class="hljs-meta"> OP_POP_RES, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* stop execution */</span></span></span><span class="hljs-meta"> OP_DONE, } opcode; typedef enum interpret_result { SUCCESS, ERROR_DIVISION_BY_ZERO, ERROR_UNKNOWN_OPCODE, } interpret_result; void vm_reset(void) { puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Reset vm state"</span></span></span><span class="hljs-meta">); vm = (typeof(vm)) { NULL }; vm.stack_top = vm.stack; } void vm_stack_push(uint64_t value) { *vm.stack_top = value; vm.stack_top++; } uint64_t vm_stack_pop(void) { vm.stack_top--; return *vm.stack_top; } interpret_result vm_interpret(uint8_t *bytecode) { vm_reset(); puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Start interpreting"</span></span></span><span class="hljs-meta">); vm.ip = bytecode; for (;;) { uint8_t instruction = *vm.ip++; switch (instruction) { case OP_PUSHI: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span></span><span class="hljs-meta"> uint8_t arg = *vm.ip++; vm_stack_push(arg); break; } case OP_ADD: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, add 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left + arg_right; vm_stack_push(res); break; } case OP_SUB: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, subtract 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left - arg_right; vm_stack_push(res); break; } case OP_DIV: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, divide 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Don't forget to handle the div by zero error */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (arg_right == 0) return ERROR_DIVISION_BY_ZERO; uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left / arg_right; vm_stack_push(res); break; } case OP_MUL: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, multiply 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left * arg_right; vm_stack_push(res); break; } case OP_POP_RES: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop the top of the stack, set it as a result value */</span></span></span><span class="hljs-meta"> uint64_t res = vm_stack_pop(); vm.result = res; break; } case OP_DONE: { return SUCCESS; } default: return ERROR_UNKNOWN_OPCODE; } } return SUCCESS; }</span></span></code> </pre><br><p>  Dalam contoh ini, sudah ada lebih banyak operasi, dan hampir semuanya hanya bekerja dengan stack.  OP_PUSHI mendorong argumen langsungnya ke tumpukan.  Instruksi OP_ADD, OP_SUB, OP_DIV, OP_MUL muncul dari setumpuk nilai, menghitung hasilnya, dan mendorongnya kembali ke stack.  OP_POP_RES menghapus nilai dari tumpukan dan menempatkannya dalam register hasil, yang dimaksudkan untuk hasil mesin virtual. </p><br><p>  Untuk operasi pembagian (OP_DIV), pembagian dengan kesalahan nol ditangkap, yang menghentikan mesin virtual. </p><br><p>  Kemampuan mesin seperti itu jauh lebih luas daripada yang sebelumnya dengan register tunggal dan memungkinkan, misalnya, untuk menghitung ekspresi aritmatika yang kompleks.  Keuntungan lain (dan penting!) Adalah kesederhanaan mengkompilasi bahasa pemrograman ke dalam kode byte mesin stack. </p><br><h1 id="registrovaya-mashina">  Daftarkan mesin </h1><br><p>  Karena kesederhanaannya, mesin virtual yang ditumpuk paling banyak digunakan di kalangan pengembang bahasa pemrograman;  JVM dan Python VM yang sama menggunakan persisnya. </p><br><p>  Namun, mesin tersebut memiliki kelemahan: mereka harus menambahkan instruksi khusus untuk bekerja dengan stack, ketika menghitung ekspresi, semua argumen berulang kali melewati struktur data tunggal, banyak instruksi tambahan pasti akan muncul dalam kode stack. </p><br><p>  Sementara itu, pelaksanaan setiap instruksi tambahan memerlukan biaya penjadwalan, yaitu, decoding opcode dan beralih ke badan instruksi. </p><br><p>  Alternatif untuk mesin bertumpuk adalah mendaftarkan mesin virtual.  Mereka memiliki bytecode yang lebih kompleks: jumlah argumen register dan jumlah hasil register secara eksplisit dikodekan dalam setiap instruksi.  Dengan demikian, alih-alih tumpukan, set register yang diperluas digunakan sebagai penyimpanan nilai-nilai perantara. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> REGISTER_NUM 16 struct { uint16_t *ip; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Register array */</span></span></span><span class="hljs-meta"> uint64_t reg[REGISTER_NUM]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* A single register containing the result */</span></span></span><span class="hljs-meta"> uint64_t result; } vm; typedef enum { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Load an immediate value into r0 */</span></span></span><span class="hljs-meta"> OP_LOADI, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Add values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_ADD, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Subtract values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_SUB, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Divide values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_DIV, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Multiply values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_MUL, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Move a value from r0 register into the result register */</span></span></span><span class="hljs-meta"> OP_MOV_RES, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* stop execution */</span></span></span><span class="hljs-meta"> OP_DONE, } opcode; typedef enum interpret_result { SUCCESS, ERROR_DIVISION_BY_ZERO, ERROR_UNKNOWN_OPCODE, } interpret_result; void vm_reset(void) { puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Reset vm state"</span></span></span><span class="hljs-meta">); vm = (typeof(vm)) { NULL }; } void decode(uint16_t instruction, uint8_t *op, uint8_t *reg0, uint8_t *reg1, uint8_t *reg2, uint8_t *imm) { *op = (instruction &amp; 0xF000) &gt;&gt; 12; *reg0 = (instruction &amp; 0x0F00) &gt;&gt; 8; *reg1 = (instruction &amp; 0x00F0) &gt;&gt; 4; *reg2 = (instruction &amp; 0x000F); *imm = (instruction &amp; 0x00FF); } interpret_result vm_interpret(uint16_t *bytecode) { vm_reset(); puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Start interpreting"</span></span></span><span class="hljs-meta">); vm.ip = bytecode; uint8_t op, r0, r1, r2, immediate; for (;;) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* fetch the instruction */</span></span></span><span class="hljs-meta"> uint16_t instruction = *vm.ip++; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* decode it */</span></span></span><span class="hljs-meta"> decode(instruction, &amp;op, &amp;r0, &amp;r1, &amp;r2, &amp;immediate); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* dispatch */</span></span></span><span class="hljs-meta"> switch (op) { case OP_LOADI: { vm.reg[r0] = immediate; break; } case OP_ADD: { vm.reg[r2] = vm.reg[r0] + vm.reg[r1]; break; } case OP_SUB: { vm.reg[r2] = vm.reg[r0] - vm.reg[r1]; break; } case OP_DIV: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Don't forget to handle the div by zero error */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (vm.reg[r1] == 0) return ERROR_DIVISION_BY_ZERO; vm.reg[r2] = vm.reg[r0] / vm.reg[r1]; break; } case OP_MUL: { vm.reg[r2] = vm.reg[r0] * vm.reg[r1]; break; } case OP_MOV_RES: { vm.result = vm.reg[r0]; break; } case OP_DONE: { return SUCCESS; } default: return ERROR_UNKNOWN_OPCODE; } } return SUCCESS; }</span></span></code> </pre><br><p>  Contoh menunjukkan mesin register dengan 16 register.  Instruksi menempati 16 bit masing-masing dan dikodekan dalam tiga cara: </p><br><ol><li>  4 bit per opcode + 4 bit per nama register + 8 bit per argumen. </li><li>  4 bit per opcode + tiga kali 4 bit per nama register. </li><li>  4 bit per opcode + 4 bit per nama register tunggal + 8 bit yang tidak digunakan. </li></ol><br><p>  Mesin virtual kecil kami memiliki operasi yang sangat sedikit, sehingga empat bit (atau 16 operasi yang mungkin) per opcode cukup.  Operasi menentukan apa yang sebenarnya mewakili bit sisa instruksi. </p><br><p>  Jenis pengkodean pertama (4 + 4 + 8) diperlukan untuk memuat data ke dalam register dengan operasi OP_LOADI.  Tipe kedua (4 + 4 + 4 + 4) digunakan untuk operasi aritmatika, yang harus tahu di mana harus mengambil sepasang argumen dan di mana menambahkan hasil perhitungan.  Dan akhirnya, bentuk terakhir (4 + 4 + 8 bit yang tidak perlu) digunakan untuk instruksi dengan register tunggal sebagai argumen, dalam kasus kami adalah OP_MOV_RES. </p><br><p>  Untuk menyandikan dan mendekode instruksi, kita sekarang memerlukan logika khusus (fungsi <code>decode</code> ).  Di sisi lain, logika instruksi, berkat indikasi eksplisit lokasi argumen, menjadi lebih mudah - operasi dengan tumpukan menghilang. </p><br><p>  Fitur utama: dalam bytecode mesin register terdapat lebih sedikit instruksi, instruksi individual lebih luas, kompilasi ke bytecode seperti itu lebih sulit - kompiler harus memutuskan bagaimana menggunakan register yang tersedia. </p><br><p>  Perlu dicatat bahwa dalam prakteknya dalam mendaftar mesin virtual biasanya ada tumpukan di mana, misalnya, argumen fungsi ditempatkan;  register digunakan untuk menghitung ekspresi individu.  Bahkan jika tidak ada stack eksplisit, array digunakan untuk membangun stack, memainkan peran yang sama dengan RAM di mesin fisik. </p><br><h1 id="stekovye-i-registrovye-mashiny-sravnenie">  Tumpuk dan daftarkan mesin, perbandingan </h1><br><p>  Ada penelitian yang menarik ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">showdown mesin Virtual: Stack versus register</a> , 2008) yang telah memiliki pengaruh besar pada semua perkembangan selanjutnya di bidang mesin virtual untuk bahasa pemrograman.  Penulisnya telah mengusulkan metode terjemahan langsung dari kode tumpukan JVM standar ke dalam kode register dan membandingkan kinerja. </p><br><p>  Metode ini tidak sepele: kode pertama kali diterjemahkan, dan kemudian dioptimalkan dengan cara yang agak rumit.  Tetapi perbandingan selanjutnya dari kinerja program yang sama menunjukkan bahwa siklus prosesor tambahan yang dihabiskan untuk instruksi decoding sepenuhnya dikompensasi oleh penurunan jumlah total instruksi.  Secara umum, singkatnya, mesin register lebih efisien daripada yang stack. </p><br><p>  Seperti yang telah disebutkan di atas, efisiensi ini memiliki harga yang cukup nyata: kompiler harus mengalokasikan register itu sendiri dan pengoptimal lanjutan juga diinginkan. </p><br><p>  Perdebatan tentang arsitektur mana yang lebih baik masih belum berakhir.  Jika kita berbicara tentang kompiler Java, maka bytecode Dalvik VM, yang hingga saat ini bekerja pada setiap perangkat Android, terdaftar;  tetapi judul JVM tetap memiliki setumpuk instruksi.  Mesin virtual Lua menggunakan mesin register, tetapi Python VM masih bisa ditumpuk.  Dan sebagainya. </p><br><h1 id="bayt-kod-v-interpretatorah-regulyarnyh-vyrazheniy">  Bytecode dalam juru bahasa ekspresi reguler </h1><br><p>  Akhirnya, untuk mengalihkan perhatian kita dari mesin virtual level rendah, mari kita lihat juru bahasa khusus yang memeriksa string untuk pencocokan ekspresi reguler: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* match a single char to an immediate argument from the string and advance ip and cp, or * abort*/</span></span> OP_CHAR, <span class="hljs-comment"><span class="hljs-comment">/* jump to and match either left expression or the right one, abort if nothing matches*/</span></span> OP_OR, <span class="hljs-comment"><span class="hljs-comment">/* do an absolute jump to an offset in the immediate argument */</span></span> OP_JUMP, <span class="hljs-comment"><span class="hljs-comment">/* stop execution and report a successful match */</span></span> OP_MATCH, } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> match_result { MATCH_OK, MATCH_FAIL, MATCH_ERROR, } match_result; <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_match_recur</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *sp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_CHAR:{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> cur_c = *sp; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> arg_c = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)*ip ; <span class="hljs-comment"><span class="hljs-comment">/* no match? FAILed to match */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arg_c != cur_c) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_FAIL; <span class="hljs-comment"><span class="hljs-comment">/* advance both current instruction and character pointers */</span></span> ip++; sp++; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JUMP:{ <span class="hljs-comment"><span class="hljs-comment">/* read the offset and jump to the instruction */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> offset = *ip; ip = bytecode + offset; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_OR:{ <span class="hljs-comment"><span class="hljs-comment">/* get both branch offsets */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> left_offset = *ip++; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> right_offset = *ip; <span class="hljs-comment"><span class="hljs-comment">/* check if following the first offset get a match */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *left_ip = bytecode + left_offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vm_match_recur(bytecode, left_ip, sp) == MATCH_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_OK; <span class="hljs-comment"><span class="hljs-comment">/* no match? Check the second branch */</span></span> ip = bytecode + right_offset; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_MATCH:{ <span class="hljs-comment"><span class="hljs-comment">/* success */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_OK; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_ERROR; } } <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_match</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Start matching a string: %s\n"</span></span>, str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vm_match_recur(bytecode, bytecode, str); }</code> </pre><br><p>  Instruksi utama adalah OP_CHAR.  Dia mengambil argumen langsungnya dan membandingkannya dengan karakter saat ini dalam string ( <code>char *sp</code> ).  Dalam hal kebetulan dari karakter yang diharapkan dan saat ini di baris, transisi ke instruksi berikutnya dan karakter berikutnya terjadi. </p><br><p>  Mesin juga memahami operasi lompatan (OP_JUMP), yang membutuhkan argumen langsung.  Argumen berarti offset absolut dalam bytecode, dari tempat untuk melanjutkan perhitungan. </p><br><p>  Operasi penting terakhir adalah OP_OR.  Dia mengambil dua offset, mencoba menerapkan kode pertama pada yang pertama, lalu, jika ada kesalahan, yang kedua.  Dia melakukan ini dengan panggilan rekursif, yaitu, instruksi berjalan ke kedalaman pohon dari semua varian yang mungkin dari ekspresi reguler. </p><br><p>  Anehnya, empat opcode dan tujuh puluh baris kode sudah cukup untuk mengekspresikan ekspresi reguler seperti "abc", "a? Bc", "(ab | bc) d", "a * bc".  Mesin virtual ini bahkan tidak memiliki keadaan eksplisit, karena semua yang Anda butuhkan - penunjuk ke awal aliran instruksi, instruksi saat ini dan karakter saat ini - diteruskan sebagai argumen untuk fungsi rekursif. </p><br><p>  Jika Anda tertarik pada detail kerja mesin ekspresi reguler, Anda dapat terlebih dahulu membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian artikel oleh</a> Russ Cox, penulis mesin ekspresi reguler dari Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RE2</a> . </p><br><h1 id="itogi">  Ringkasan </h1><br><p>  Mari kita simpulkan. </p><br><p>  Untuk bahasa pemrograman tujuan umum, sebagai aturan, dua arsitektur digunakan: stack dan register. </p><br><p>  Dalam model tumpukan, struktur data utama dan metode menyampaikan argumen antara instruksi adalah tumpukan.  Dalam model register, satu set register digunakan untuk menghitung ekspresi, tetapi tumpukan eksplisit atau implisit masih digunakan untuk menyimpan argumen fungsi. </p><br><p>  Kehadiran tumpukan eksplisit dan satu set register membawa mesin seperti itu lebih dekat ke tingkat rendah dan bahkan yang fisik.  Banyaknya instruksi tingkat rendah dalam bytecode seperti itu berarti bahwa pengeluaran sumber daya yang signifikan dari prosesor fisik jatuh pada decoding dan penjadwalan instruksi virtual. </p><br><p>  Di sisi lain, instruksi tingkat tinggi memainkan peran besar dalam mesin virtual populer.  Di Jawa, misalnya, ini adalah instruksi untuk panggilan fungsi polimorfik, alokasi objek, dan pengumpulan sampah. </p><br><p>  Mesin virtual tingkat tinggi murni - misalnya, penerjemah byte-kode bahasa dengan bahasa maju dan jauh dari semantik besi - sebagian besar waktu dihabiskan bukan di dispatcher atau decoder, tetapi di badan instruksi dan, karenanya, relatif efisien. </p><br><p>  Rekomendasi praktis: </p><br><ol><li>  Jika Anda perlu menjalankan bytecode apa pun dan melakukannya dalam jumlah waktu yang wajar, maka cobalah untuk beroperasi dengan instruksi yang paling dekat dengan tugas Anda;  semakin tinggi tingkat semantik, semakin baik.  Ini akan mengurangi biaya penjadwalan dan menyederhanakan pembuatan kode. </li><li>  Jika Anda membutuhkan lebih banyak fleksibilitas dan semantik heterogen, Anda setidaknya harus mencoba untuk menyoroti penyebut umum dalam bytecode sehingga instruksi yang dihasilkan berada pada tingkat rata-rata kondisional. </li><li>  Jika di masa depan mungkin diperlukan untuk menghitung ekspresi apa pun, membuat mesin bertumpuk, ini akan mengurangi sakit kepala saat menyusun kode byte. </li><li>  Jika ekspresi tidak diharapkan, maka buat mesin register sepele, yang akan menghindari biaya tumpukan dan menyederhanakan instruksi itu sendiri. </li></ol><br><p>  Dalam artikel berikut, saya akan membahas implementasi praktis mesin virtual dalam bahasa pemrograman populer dan menjelaskan mengapa departemen Badoo Intelijen Bisnis memerlukan bytecode. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425325/">https://habr.com/ru/post/id425325/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425313/index.html">10 ekstensi Kode VS terbaik 2018 untuk pengembang front-end</a></li>
<li><a href="../id425315/index.html">Mengatur penyimpanan kode di GitLab dan mengintegrasikan tinjauan kode ke GitFlow</a></li>
<li><a href="../id425317/index.html">Cara melakukannya: kita menulis "Minesweeper" dalam 4 menit</a></li>
<li><a href="../id425321/index.html">Pemrograman adalah perwujudan gagasan.</a></li>
<li><a href="../id425323/index.html">"Lubang kelinci." Desainer UX dalam tim produk</a></li>
<li><a href="../id425327/index.html">Pemrograman fungsional: mengukur tujuh kali, potong sekali</a></li>
<li><a href="../id425329/index.html">Beberapa saran untuk generasi milenium dari "oldies." Cara sukses di dunia digital kita</a></li>
<li><a href="../id425331/index.html">Alice akan membantu pengembang menemukan objek dalam permintaan pengguna. NER dalam Dialog</a></li>
<li><a href="../id425333/index.html">Boot dirimu, Spring akan datang (Bagian 2)</a></li>
<li><a href="../id425335/index.html">Armada Garmin yang tak terkalahkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>