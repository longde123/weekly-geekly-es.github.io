<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç¢ üëáüèª üë®üèΩ‚Äçüîß Implemente aplicaciones de Symfony + React en AWS a trav√©s de CI üë©üèª‚Äçüîß üö´ ü§üüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buenas tardes, en este art√≠culo mostrar√© c√≥mo implementar la aplicaci√≥n Symfony 4 en AWS. Hay un ejemplo de dicho proceso en la documentaci√≥n oficial,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implemente aplicaciones de Symfony + React en AWS a trav√©s de CI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462415/"> Buenas tardes, en este art√≠culo mostrar√© c√≥mo implementar la aplicaci√≥n Symfony 4 en AWS.  Hay un ejemplo de dicho proceso en la documentaci√≥n oficial, pero mi versi√≥n no es tan trivial como descargar un archivo zip con una aplicaci√≥n.  En el patio de 2019, en modo acoplable, la arquitectura de microservicios y las pr√°cticas de CI / CD finalmente comienzan a incluirse en las herramientas no solo de los ingenieros de DevOps, sino tambi√©n de <s>los</s> desarrolladores <s>mortales</s> comunes.  Para hacer el art√≠culo m√°s interesante, agregu√© un frente a React.JS, para cubrir las necesidades de m√°s personas, si su aplicaci√≥n no usa Encore - no importa, le indicar√© c√≥mo cambiar el archivo Docker para usted, el soporte para React.JS solo lo afecta .  ¬øQui√©n estar√° interesado en este tutorial?  En primer lugar, est√° dirigido a los desarrolladores de PHP que desean cambiar su pr√°ctica de implementaci√≥n: alejarse de los c√°nones habituales y usar docker para empacar su aplicaci√≥n y dise√±ar la imagen.  Pero puede profundizar un poco m√°s, y la narraci√≥n adicional tendr√° como objetivo implementar autom√°ticamente la aplicaci√≥n desde Git a trav√©s de la plataforma CI / CD (se utilizar√° CircleCI, pero si est√° interesado en la configuraci√≥n de Gitlab, escriba los comentarios, lo adjuntar√©).  De hecho, no es absolutamente importante para React / PHP si tiene una aplicaci√≥n o, por ejemplo, .NET Core, esta parte ser√° interesante para que los desarrolladores adquieran habilidades de automatizaci√≥n de implementaci√≥n en general.  El c√≥digo fuente est√° disponible en el repositorio de github, enlace al final del art√≠culo.  Bueno, vamos! <br><a name="habracut"></a><br>  Supongo que tiene su propia aplicaci√≥n Symfony, pero para los prop√≥sitos de demostraci√≥n esboc√© "hola, mundo!" Que contiene los siguientes paquetes: <br><br>  <code>`symfony/webpack-encore-bundle symfony/form symfony/orm-pack symfony/profiler-pack symfony/security-bundle symfony/twig-bundle symfony/validator symfony/phpunit-bridge`</code> es un conjunto de caballeros m√≠nimo.  Por el momento, la estructura de la carpeta debe ser la siguiente: <br><br><img width="350" src="https://habrastorage.org/webt/6m/ck/xi/6mckxiczmqlde3nsjhdpzcbforq.png" alt="imagen"><br><br>  Ahora necesita configurar su infraestructura en la nube.  No me enfocar√© en registrar y activar el per√≠odo de prueba de AWS, en esta etapa necesitamos crear 2 instancias de DB. Usar√© 2 tipos de entorno: STG (puesta en escena) para probar la implementaci√≥n de nuevas "caracter√≠sticas" y PROD (producci√≥n) como directamente "combate". servidor  Se han escrito muchos art√≠culos sobre los beneficios de la base de datos de servicios administrados, adem√°s, principalmente buscamos la conveniencia para el desarrollador en esta gu√≠a, por lo tanto, utilizamos RDS, en lugar de crear nuestro propio servidor de base de datos separado.  Como DBMS para este ejemplo, utilic√© PostgreSQL, puede elegir el que m√°s le convenga, ir al servicio RDS y crear 2 instancias de la capacidad y el volumen que necesita.  Dado que el archivo <code>.env</code> est√° disponible para nosotros " <code>.env</code> para usar" en Symfony, lo usaremos, por ejemplo, para PROD, y para STG crearemos una copia de <code>.env.stg</code> y cambiaremos <code>APP_ENV=dev</code> a <code>APP_ENV=stg</code> en <code>.env.stg</code> y <code>APP_ENV=dev</code> en <code>APP_ENV=prod</code> en <code>.env</code> y tambi√©n ingrese los par√°metros de conexi√≥n de la <code>.env</code> para cada una de las instancias creadas. <br><br>  ¬°Genial, se ha comenzado!  Como sabes, las dependencias de Symfony se instalan a trav√©s de Composer, para instalarlo, usa el archivo composer.sh, que colocamos en la ra√≠z del proyecto: <br><br><div class="spoiler">  <b class="spoiler_title">composer.sh</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#!/bin/sh EXPECTED_SIGNATURE="$(wget -q -O - https://composer.github.io/installer.sig)" php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');" ACTUAL_SIGNATURE="$(php -r "echo hash_file('sha384', 'composer-setup.php');")" if [ "$EXPECTED_SIGNATURE" != "$ACTUAL_SIGNATURE" ] then &gt;&amp;2 echo 'ERROR: Invalid installer signature' rm composer-setup.php exit 1 fi php composer-setup.php --quiet RESULT=$? rm composer-setup.php exit $RESULT</code> </pre> <br></div></div><br>  Esta <a href="">es una</a> gu√≠a de <a href="">instalaci√≥n de software del compositor</a> . <br><br>  Ahora, para cada uno de los entornos, cree su propio Dockerfile en la ra√≠z del proyecto: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerfile.stg (puesta en escena)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">FROM php:7.2.19-apache EXPOSE 80 RUN mv "$PHP_INI_DIR/php.ini-production" "$PHP_INI_DIR/php.ini" &amp;&amp; a2enmod rewrite RUN sed -ri -e 's!memory_limit = 128M!memory_limit = 256M!g' "$PHP_INI_DIR/php.ini" RUN apt-get update &amp;&amp; apt-get install -y \ wget \ curl \ libfreetype6-dev \ libjpeg62-turbo-dev \ libpng-dev \ libzip-dev \ zip \ libpq-dev \ &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \ &amp;&amp; docker-php-ext-configure zip --with-libzip \ &amp;&amp; docker-php-ext-configure pgsql -with-pgsql=/usr/local/pgsql \ &amp;&amp; docker-php-ext-install -j$(nproc) gd \ &amp;&amp; docker-php-ext-install zip \ &amp;&amp; docker-php-ext-install pdo pdo_pgsql pgsql WORKDIR /var/www ENV APACHE_DOCUMENT_ROOT /var/www/public RUN sed -ri -e 's!/var/www/html!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/sites-available/*.conf RUN sed -ri -e 's!/var/www/!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/apache2.conf /etc/apache2/conf-available/*.conf RUN echo "ServerName localhost" &gt;&gt; /etc/apache2/apache2.conf COPY ./composer.sh ./ RUN chmod +x ./composer.sh &amp;&amp; ./composer.sh &amp;&amp; mv composer.phar /usr/local/bin/composer RUN curl -sL https://deb.nodesource.com/setup_10.x | bash - \ &amp;&amp; apt-get install -y nodejs RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \ &amp;&amp; echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list \ &amp;&amp; apt-get update -qq \ &amp;&amp; apt-get install -y yarn COPY ./ ./ COPY ./.env.stg ./.env RUN composer install &amp;&amp; yarn &amp;&amp; yarn run build</code> </pre> <br></div></div><br>  y <br><br><div class="spoiler">  <b class="spoiler_title">Dockerfile (producci√≥n)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">FROM php:7.2.19-apache EXPOSE 80 RUN mv "$PHP_INI_DIR/php.ini-production" "$PHP_INI_DIR/php.ini" &amp;&amp; a2enmod rewrite RUN sed -ri -e 's!memory_limit = 128M!memory_limit = 256M!g' "$PHP_INI_DIR/php.ini" RUN apt-get update &amp;&amp; apt-get install -y \ wget \ curl \ libfreetype6-dev \ libjpeg62-turbo-dev \ libpng-dev \ libzip-dev \ zip \ libpq-dev \ &amp;&amp; docker-php-ext-configure gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ \ &amp;&amp; docker-php-ext-configure zip --with-libzip \ &amp;&amp; docker-php-ext-configure pgsql -with-pgsql=/usr/local/pgsql \ &amp;&amp; docker-php-ext-install -j$(nproc) gd \ &amp;&amp; docker-php-ext-install zip \ &amp;&amp; docker-php-ext-install pdo pdo_pgsql pgsql WORKDIR /var/www ENV APACHE_DOCUMENT_ROOT /var/www/public RUN sed -ri -e 's!/var/www/html!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/sites-available/*.conf RUN sed -ri -e 's!/var/www/!${APACHE_DOCUMENT_ROOT}!g' /etc/apache2/apache2.conf /etc/apache2/conf-available/*.conf RUN echo "ServerName localhost" &gt;&gt; /etc/apache2/apache2.conf COPY ./composer.sh ./ RUN chmod +x ./composer.sh &amp;&amp; ./composer.sh &amp;&amp; mv composer.phar /usr/local/bin/composer RUN curl -sL https://deb.nodesource.com/setup_10.x | bash - \ &amp;&amp; apt-get install -y nodejs RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \ &amp;&amp; echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list \ &amp;&amp; apt-get update -qq \ &amp;&amp; apt-get install -y yarn COPY ./ ./ RUN composer install &amp;&amp; yarn &amp;&amp; yarn run build</code> </pre> <br></div></div><br>  Los archivos se pueden usar "tal cual", no se usan macros para los cambios.  Veamos el contenido del Dockerfile para disipar el toque "m√°gico".  Como "base", utilizamos la imagen oficial de PHP 7.2.19 con el servidor web Apache integrado (puede usar cualquiera de sus opciones, configurar un paquete con Nginx, etc.). En este ejemplo, utilizo lo anterior como m√°ximo, en mi opini√≥n, conveniente).  La l√≠nea de exposici√≥n no es importante para nosotros en este momento, por s√≠ sola no hace nada, pero en el futuro ser√° utilizada por ElasticBeanstalk, que necesita desplegarse correctamente.  Las siguientes construcciones utilizan configuraciones de producci√≥n optimizadas para PHP recomendadas por el fabricante, activan mod_rewrite para Apache y aumentan el tama√±o m√°ximo de memoria para un script PHP de 128 a 256 mb, que es necesario para que el compositor funcione correctamente.  A continuaci√≥n, instalamos las aplicaciones necesarias, las dependencias y extensiones de PHP, y las configuramos de inmediato.  Asignamos la carpeta / var / www al directorio de trabajo de nuestra aplicaci√≥n; el c√≥digo fuente de nuestra aplicaci√≥n se copiar√° all√≠.  Como apache, por defecto, usa / var / www como punto de entrada para su host, y el archivo de √≠ndice de Symfony se encuentra en / var / www / public, cambiamos la ra√≠z del documento de apache con la siguiente construcci√≥n.  Luego instalamos composer, nodejs e hilo secuencialmente (si no usa encore / react.js en su aplicaci√≥n, entonces no necesita los dos √∫ltimos puntos).  Finalmente, copiamos nuestro c√≥digo fuente y comenzamos la instalaci√≥n de dependencias a trav√©s del compositor para Symfony y Yarn para react.js.  El significado de un Dockerfile separado para STG reside en las pen√∫ltimas instrucciones para docker: copiar .env.stg a .env, por lo que el archivo .env en la imagen STG contendr√° los par√°metros relevantes para este entorno.  Puede recolectar localmente (por supuesto, con Docker instalado) la imagen, ejecutarla y asegurarse de que la aplicaci√≥n funciona y no necesita nada m√°s para este trabajo: <br><br><pre> <code class="plaintext hljs">docker build -t tmp:stg -f Dockerfile.stg . docker run -p 80:80 tmp:stg</code> </pre> <br>  para STG y <br><br><pre> <code class="plaintext hljs">docker build -t tmp:prod . docker run -p 80:80 tmp:prod</code> </pre> <br>  para PROD. <br>  Podemos usar EC2, configurar ELB / ASG, etc., o usar ElasticBeanstalk, que es solo un regalo para nosotros en t√©rminos de conveniencia.  Vaya a la secci√≥n ElasticBeanstalk y cree una nueva aplicaci√≥n con su nombre y descripci√≥n.  Luego, cree 2 entornos que se mencionaron anteriormente: STG y PROD, cree ambos entornos como un entorno de servidor web, especifique "Docker" como plataforma y deje la aplicaci√≥n de muestra como el c√≥digo de la aplicaci√≥n.  La implementaci√≥n en ElasticBeanstalk se realiza cargando archivos de proyecto o instrucciones, generalmente en un archivo zip.  En nuestro caso, el flujo ser√° as√≠: recopilamos la imagen del acoplador de nuestra aplicaci√≥n, la cargamos en el repositorio y cargamos las instrucciones en lugar del archivo fuente o la imagen del acoplador, lo que le dice a ElasticBeanstalk que tome la imagen del servidor remoto y la implemente.  Y todo esto es autom√°tico. <br><br>  Comencemos creando un repositorio para almacenar im√°genes acoplables.  Hay 2 opciones: <br><br>  1 - su proyecto es privado, su c√≥digo est√° cerrado y el repositorio, respectivamente, tambi√©n debe estar cerrado.  En este caso, puede mantener su propio registro de im√°genes en alg√∫n lugar o utilizar una nube privada.  AWS tiene ECR para estos fines, puede crear un repositorio all√≠, pero nadie lo obliga a hacerlo. <br><br>  2: tiene un proyecto de c√≥digo abierto y puede usar dockerhub. <br><br>  En nuestro ejemplo, el c√≥digo est√° abierto, pero mostrar√© c√≥mo usar repositorios cerrados, despu√©s de comprender este proceso, conectar una imagen desde dockerhub no ser√° dif√≠cil.  Lo primero que necesitamos es crear el repositorio en s√≠, despu√©s de eso obtendr√° su URI √∫nico.  La narraci√≥n adicional ir√° a terceros (no a los repositorios de AWS ECR y su integraci√≥n), para ECR escribir√© despu√©s de eso. <br><br>  Despu√©s de crear el repositorio, necesitamos iniciar sesi√≥n en este servicio y hay un peque√±o truco ... Vaya a la configuraci√≥n de su acoplador instalado localmente y verifique que tenga la opci√≥n de guardar las contrase√±as en el almacenamiento externo eliminado (para usuarios de macOS: "Almacene de forma segura los inicios de los acopladores en macOS Keychain ‚Äù), de lo contrario, el archivo de configuraci√≥n que necesitamos estar√° vac√≠o.  Y as√≠, autorizamos en el servicio seleccionado para almacenar los registros de sus im√°genes: <br><br><pre> <code class="plaintext hljs">docker login -u LOGIN -p PASSWORD REGISTRY</code> </pre> <br>  despu√©s de una autenticaci√≥n exitosa, la siguiente construcci√≥n aparecer√° en el archivo de configuraci√≥n ~ / .docker / config.json: <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"REGISTRY"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"auth"</span></span> : <span class="hljs-string"><span class="hljs-string">"BASE64_ENCODED_TOKEN"</span></span> }</code> </pre><br>  Si no aparece, verifique nuevamente la configuraci√≥n de la ventana acoplable descrita anteriormente. <br><br>  Ahora todo est√° listo para preparar el archivo de instrucciones para ElasticBeanstalk - Dockerrun.aws.json, su c√≥digo ser√° as√≠: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerrun.aws.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"AWSEBDockerrunVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Authentication"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Bucket"</span></span>: <span class="hljs-string"><span class="hljs-string">"BUCKET_ID"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Key"</span></span>: <span class="hljs-string"><span class="hljs-string">"KEY_PATH"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Image"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"IMAGE_URL"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Update"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Ports"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"ContainerPort"</span></span>: <span class="hljs-string"><span class="hljs-string">"80"</span></span> } ] }</code> </pre><br></div></div><br>  En general, la instrucci√≥n se ve as√≠: despu√©s de iniciar sesi√≥n con la clave ubicada por KEY_PATH en el BUCKET_ID de almacenamiento S3, cargue la imagen IMAGE_URL sobrescribiendo la guardada, comience enviando el puerto 80 al mismo puerto en el contenedor.  Ahora sobre las constantes utilizadas: <br><br>  BUCKET_ID es la "mochila" creada autom√°ticamente para usted en el servicio S3, que tiene la forma de elasticbeanstalk-REGION-HASH, aqu√≠ es donde el sistema localiza los archivos de servicio para su ElasticBeanstalk, incluidos los archivos de aplicaci√≥n que descarga utilizando el bot√≥n "Cargar e implementar". <br><br>  KEY_PATH: ruta del archivo de autorizaci√≥n al repositorio de im√°genes, utilizo el formato APP_NAME / cr.json, es decir, en la carpeta dentro de BUCKET_ID bajo el nombre de mi aplicaci√≥n (creo, si no todav√≠a) pongo el archivo cr.json que contiene el c√≥digo recibido despu√©s de la autorizaci√≥n en el registro Im√°genes a nivel local: <br><br><div class="spoiler">  <b class="spoiler_title">BUCKET_ID / APP_NAME / cr.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"REGISTRY"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"auth"</span></span> : <span class="hljs-string"><span class="hljs-string">"BASE64_ENCODED_TOKEN"</span></span> } }</code> </pre> </div></div><br>  IMAGE_URL es el URI √∫nico de su registro de imagen + etiqueta de la imagen en s√≠, todo debe quedar claro aqu√≠. <br><br>  Eso es todo, ahora podemos descargar este archivo como una versi√≥n de nuestra aplicaci√≥n en ElasticBeanstalk, y √©l extraer√° la imagen especificada y la implementar√°. <br><br>  Queda por automatizar este proceso.  Y para ser absolutamente interesante, implementar√© la secuencia de pasos para el siguiente flujo: para todos los commits NO en la rama maestra, la imagen se recopilar√° y desplegar√° en el entorno STG, y si ingresamos en el maestro, o mejor, lo cierro y lo llenamos con la solicitud de fusi√≥n 's, entonces el c√≥digo se implementar√° en PROD.  Por lo tanto, obtenemos en PROD un asistente actualizado, en el que todo deber√≠a estar bien, y se ramifica para desarrollar y probar nuevo c√≥digo en STG.  Para esta implementaci√≥n, necesitamos instrucciones para cargar im√°genes que no sean las √∫ltimas, copie Dockerrun.aws.json en Dockerrun.aws.stg.json y cambie el nombre de Dockerrun.aws.json a Dockerrun.aws.prod.json (solo por conveniencia). <br><br>  Lo √∫nico que diferencia a Dockerrun.aws.stg.json de Dockerrun.aws.prod.json es IMAGE_URL: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerrun.aws.stg.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"AWSEBDockerrunVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Authentication"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Bucket"</span></span>: <span class="hljs-string"><span class="hljs-string">"BUCKET_ID"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Key"</span></span>: <span class="hljs-string"><span class="hljs-string">"KEY_PATH"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Image"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"IMAGE_URL:dev"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Update"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Ports"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"ContainerPort"</span></span>: <span class="hljs-string"><span class="hljs-string">"80"</span></span> } ] }</code> </pre><br></div></div><br>  Como dije al comienzo del art√≠culo, usar√© CircleCI como un CI / CD, que, seg√∫n mis sentimientos personales, es m√°s r√°pido que GitlabCI si uso la versi√≥n gratuita de SaaS.  Travis libre lo har√≠a, pero como no funciona con repositorios privados de git, no realic√© una demostraci√≥n espec√≠fica para que no haya decepciones cuando se necesitara esa oportunidad.  Dejar√© la configuraci√≥n del proyecto en CircleCI a los lectores para que la estudien de forma independiente, yo mismo dar√© las instrucciones necesarias para la implementaci√≥n: en la ra√≠z de nuestro proyecto crearemos la carpeta .circleci, en ella config.yml con el siguiente contenido: <br><br><div class="spoiler">  <b class="spoiler_title">.circleci / config.yml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">version: 2 jobs: build: machine: true steps: - checkout - run: echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:dev -f Dockerfile.stg . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:dev build-master: machine: true steps: - checkout - run: echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:latest . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:latest deploy-stg: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.stg.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli deploy-prod: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.prod.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli workflows: version: 2 build: jobs: - build: filters: branches: ignore: - master - deploy-stg: requires: - build filters: branches: ignore: - master build-deploy: jobs: - build-master: filters: branches: only: - master - deploy-prod: requires: - build-master filters: branches: only: - master</code> </pre></div></div><br>  Pint√© el flujo en s√≠ un poco antes, aqu√≠ est√° traducido en instrucciones yaml para CircleCI, veamos la implementaci√≥n de pasos espec√≠ficos.  Es importante tener en cuenta la presencia de variables de entorno definidas para CI que ser√°n utilizadas por √©l durante el trabajo: <br><br>  CI_REGISTRY, CI_REGISTRY_USER, CI_REGISTRY_PASSWORD son necesarios para acceder al almacenamiento de im√°genes del acoplador, lo mismo que colocamos en cr.json, solo sin base64 <br><br>  CI_REGISTRY / CI_REGISTRY_ID forman una URL de imagen √∫nica, sin etiqueta <br><br>  AWS_ACCESS_KEY_ID y AWS_SECRET_ACCESS_KEY: los nombres hablan por s√≠ mismos, estos son cr√©ditos de AWS para el usuario en cuyo nombre se desplegar√° CircleCI.  Vaya a AWS IAM y cree un usuario, agr√©guelo al grupo de administradores y proporcione solo acceso program√°tico.  Recuerde que AWS_SECRET_ACCESS_KEY est√° disponible para ver / copiar solo una vez, despu√©s de hacer clic en el enlace mostrar, no lo volver√° a ver. <br><br>  Volver a los pasos de configuraci√≥n de CircleCI.  Que es la magia  Checkout carga el c√≥digo fuente de la rama git en el directorio de trabajo actual, este proceso se repite en cada trabajo.  En el proceso de compilaci√≥n, iniciamos sesi√≥n secuencialmente en el repositorio, recopilamos el c√≥digo basado en Dockerfile.stg bajo la etiqueta XXX: dev y lo enviamos al repositorio.  build-master hace lo mismo, solo para la compilaci√≥n, utiliza el Dockerfile "normal" bajo la etiqueta XXX: √∫ltimo. <br><br>  deploy-stg instala AWS EB CLI y crea un perfil de autorizaci√≥n en el archivo ~ / .aws / config, que es necesario para que la CLI funcione correctamente, luego inicializa las variables para la CLI; deber√° especificar la regi√≥n que elija, la plataforma, siempre Docker y el nombre de su aplicaci√≥n.  A continuaci√≥n, copiamos el contenido de Dockerrun.aws.stg.json al nuevo archivo Dockerrun.aws.json y, usando el entorno y la regi√≥n espec√≠ficos, le damos el comando para implementar nuestra aplicaci√≥n usando el perfil de autorizaci√≥n creado.  De manera predeterminada, como resultado de este comando, todo el c√≥digo de la rama monitoreada terminar√° en un archivo zip, que se descargar√° a ElasticBeanstalk y se desempaquetar√° all√≠, pero esta operaci√≥n es relativamente costosa, por eso creamos un nuevo archivo Dockerrun.aws.json, que es suficiente para implementar el creado por nosotros. imagen remota, y solo necesitamos cargarla, de hecho.  Para hacer esto, cree un archivo .ebignore en la ra√≠z del proyecto: <br><br><div class="spoiler">  <b class="spoiler_title">.ebignore</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">* !Dockerrun.aws.json</code> </pre></div></div><br>  Este archivo utiliza la sintaxis .gitignore y es .gitignore, pero no para Git CLI, sino para AWS EB CLI.  En este archivo, le digo a la CLI que omita todos los archivos excepto Dockerrun.aws.json.  Eso es todo, ahora cuando ejecuta el trabajo deploy-stg en ElasticBeanstalk, solo se enviar√° el archivo que creamos.  deploy-prod hace lo mismo, solo copia el contenido del archivo Dockerrun.aws.prod.json a Dockerrun.aws.json, y el √∫ltimo es una indicaci√≥n de la secuencia de trabajo en el formato CircleCI (deploy-stg despu√©s de la compilaci√≥n y deploy-prod despu√©s de la compilaci√≥n -master), y en qu√© ramas est√°n buscando los datos (ignore: - master y solo: - master). <br><br>  Un asunto diferente es con AWS ECR, como promet√≠, volveremos a ello.  No necesita iniciar sesi√≥n de forma remota en el ECR y crear un archivo cr.json, ya que ElasticBeanstalk "conoce a un hermano en persona".  En consecuencia, Dockerrun.aws.json se ver√° diferente, simplemente no habr√° bloque de autenticaci√≥n: <br><br><div class="spoiler">  <b class="spoiler_title">Dockerrun.aws.json (AWS ECR)</b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"AWSEBDockerrunVersion"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Image"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"IMAGE_URL"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Update"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"Ports"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"ContainerPort"</span></span>: <span class="hljs-string"><span class="hljs-string">"80"</span></span> } ] }</code> </pre><br></div></div><br>  Pero, ¬øc√≥mo ocurrir√° la autenticaci√≥n?  El hecho es que el servicio que accede al ECR tiene un cierto conjunto de derechos, que a su vez se basan en ciertas pol√≠ticas de seguridad.  En nuestro caso, cuando la implementaci√≥n se inicia a trav√©s de la CLI de AWS desde un servidor de terceros (desde CI), se utiliza la funci√≥n "aws-elasticbeanstalk-ec2-role", encu√©ntrela en el AWS IAM en la secci√≥n de roles y adjunte la pol√≠tica adicional "AmazonEC2ContainerRegistryReadOnly".  Ahora la descarga desde un repositorio privado a su "vecino" tendr√° √©xito sin errores. <br><br>  Pero esto se carga exactamente desde la misma VPC, a trav√©s de la CLI, el comando de inicio de sesi√≥n de Docker tampoco est√° "sin trucos": debe obtener (solo obtener) cr√©ditos para el inicio de sesi√≥n de Docker a trav√©s de la CLI de AWS, para esto hay un comando <br><br> <code>aws ecr get-login --region REGION --no-include-email</code> <br> <br>  Este comando le devolver√° una l√≠nea del formulario de inicio de sesi√≥n del acoplador ..., simplemente, en la consola que necesita ejecutar <br><br> <code>eval $(aws ecr get-login --region EB_REGION --no-include-email)</code> <br> <br>  El comando primero recibir√° una cadena para la autenticaci√≥n y luego comenzar√° el proceso correspondiente.  En vista de estas reglas para AWS ECR, el archivo de instrucciones para CircleCI se ver√° as√≠: <br><br><div class="spoiler">  <b class="spoiler_title">.circleci / config.yml (para AWS ECR)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">version: 2 jobs: build: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awscli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - setup_remote_docker - run: eval $(aws ecr get-login --region EB_REGION --no-include-email) - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:dev -f Dockerfile.stg . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:dev build-master: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awscli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - setup_remote_docker - run: eval $(aws ecr get-login --region EB_REGION --no-include-email) - run: docker build -t $CI_REGISTRY/$CI_REGISTRY_ID:latest . - run: docker push $CI_REGISTRY/$CI_REGISTRY_ID:latest deploy-stg: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.stg.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli deploy-prod: docker: - image: circleci/python:latest steps: - checkout - run: sudo pip install awsebcli --upgrade - run: | mkdir ~/.aws touch ~/.aws/config chmod 600 ~/.aws/config echo "[profile eb-cli]" &gt; ~/.aws/config echo "aws_access_key_id=$AWS_ACCESS_KEY_ID" &gt;&gt; ~/.aws/config echo "aws_secret_access_key=$AWS_SECRET_ACCESS_KEY" &gt;&gt; ~/.aws/config - run: eb init --region EB_REGION --platform Docker EB_APP - run: cp Dockerrun.aws.prod.json Dockerrun.aws.json - run: eb use EB_ENV_STG --region EB_REGION - run: eb deploy -v --staged --profile eb-cli workflows: version: 2 build: jobs: - build: filters: branches: ignore: - master - deploy-stg: requires: - build filters: branches: ignore: - master build-deploy: jobs: - build-master: filters: branches: only: - master - deploy-prod: requires: - build-master filters: branches: only: - master</code> </pre></div></div><br>   docker-in-docker   setup_remote_docker   ,          .   ,       : <br><br><img width="350" src="https://habrastorage.org/webt/7e/cw/sj/7ecwsjkjjmr8myxiuutwkujwnkg.png" alt="imagen"><br><br>   ,     ,     ()      .   ¬´¬ª   .  ( - )  ,      ,         ,                . <br><br>    GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tutorial-aws-symfony-ci</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/462415/">https://habr.com/ru/post/462415/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../462401/index.html">Desarrollador Deadly Sins</a></li>
<li><a href="../462403/index.html">Selecci√≥n del tama√±o del monitor: teor√≠a del tama√±o angular, justificaci√≥n y comparaci√≥n</a></li>
<li><a href="../462407/index.html">Food Design Digest Julio 2019</a></li>
<li><a href="../462409/index.html">Biblioteca generadora de c√≥digo ensamblador para microcontroladores AVR. Parte 1</a></li>
<li><a href="../462411/index.html">Resuelve Sudoku con Algoritmo X</a></li>
<li><a href="../462417/index.html">Petici√≥n de Apple</a></li>
<li><a href="../462421/index.html">Apollo Guidance Computer: software de arquitectura y sistema. Parte 2</a></li>
<li><a href="../462423/index.html">Project Management</a></li>
<li><a href="../462429/index.html">VueJs + VueRouter + modal. Otra bicicleta</a></li>
<li><a href="../462431/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 309 (29 de julio - 4 de agosto)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>