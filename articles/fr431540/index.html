<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🚀 😅 👗 Packages et gestionnaires de packages pour k8s ♀️ 🏔️ 👨🏽‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous utilisons tous une sorte de gestionnaire de colis, y compris la femme de ménage Tante Galya, qui a un iPhone dans sa poche en ce moment mis à jou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Packages et gestionnaires de packages pour k8s</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/431540/">  Nous utilisons tous une sorte de gestionnaire de colis, y compris la femme de ménage Tante Galya, qui a un iPhone dans sa poche en ce moment mis à jour.  Mais il n'y a pas d'accord général sur les fonctions des gestionnaires de packages, et les systèmes d'exploitation et les systèmes de build rpm et dpkg standard sont appelés gestionnaires de packages.  Nous proposons de réfléchir sur le sujet de leurs fonctions - ce que c'est et pourquoi elles sont nécessaires dans le monde moderne.  Et puis nous allons creuser vers Kubernetes et considérer soigneusement Helm en termes de ces fonctions. <br><img src="https://habrastorage.org/webt/xs/mf/h5/xsmfh5898yrlawroqge2dn6v_iw.png"><br><br>  Nous comprendrons pourquoi dans ce diagramme, seule la fonction de modèle est mise en évidence en vert, et quels sont les problèmes d'assemblage et d'emballage, d'automatisation de l'environnement, etc.  Mais ne vous inquiétez pas, l'article ne se termine pas par le fait que tout va mal.  La communauté n'a pas pu accepter cela et propose des outils et des solutions alternatifs - nous les traiterons. <br><br>  <b>Ivan Glushkov</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">gli</a> ) nous a aidé à cet égard avec son rapport sur RIT ++, une version vidéo et texte de cette présentation détaillée et détaillée ci-dessous. <br><br><blockquote>  Des vidéos de ce discours et d'autres discours de DevOps sur RIT ++ sont publiées et ouvertes à la visualisation gratuite sur notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chaîne YouTube</a> - partez à la recherche de réponses à vos questions de travail. <br></blockquote><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/V_DGgD7ihsQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>À propos de l'orateur:</strong> Ivan Glushkov développe des logiciels depuis 15 ans.  J'ai réussi à travailler en MZ, à Echo sur une plateforme de commentaires, à participer au développement de compilateurs pour le processeur Elbrus en MCST.  Il participe actuellement à des projets d'infrastructure chez Postmates.  Ivan est l'un des principaux podcasts <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DevZen</a> dans lequel ils parlent de nos conférences: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici</a> RIT ++, et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> HighLoad ++. <br><br><h2>  Gestionnaires de packages <br></h2><br>  Bien que tout le monde utilise une sorte de gestionnaire de packages, il n'y a pas d'accord unique sur ce que c'est.  Il y a une compréhension commune, et chacune a la sienne. <br><br>  Rappelons quels types de gestionnaires de packages viennent à l'esprit en premier: <br><br><ul><li>  Gestionnaires de packages standard de tous les systèmes d'exploitation: <strong>rpm, dpkg, portage</strong> , ... </li><li>  Gestionnaires de packages pour différents langages de programmation: <strong>cargo, cabal, rebar3, mix</strong> , ... </li></ul><br>  Leur fonction principale est d'exécuter des commandes pour installer un package, mettre à jour un package, désinstaller un package et gérer les dépendances.  Dans les gestionnaires de packages à l'intérieur des langages de programmation, les choses sont un peu plus compliquées.  Par exemple, il existe des commandes comme «lancer un package» ou «créer une version» (build / run / release).  Il s'avère que c'est déjà un système de construction, bien que nous l'appelions également un gestionnaire de paquets. <br><img src="https://habrastorage.org/webt/ct/di/ni/ctdinidgmq8e-zcuksmz-cfym2y.png"><br><br>  Tout cela est uniquement dû au fait que vous ne pouvez pas simplement le prendre et ... laissez les amoureux de Haskell pardonner cette comparaison.  Vous pouvez exécuter le fichier binaire, mais vous ne pouvez pas exécuter le programme dans Haskell ou C, vous devez d'abord le préparer en quelque sorte.  Et cette préparation est plutôt compliquée, et les utilisateurs veulent que tout soit fait automatiquement. <br><br><h3>  Développement <br></h3><br>  Celui qui a travaillé avec GNU libtool, qui a été conçu pour un grand projet composé d'un grand nombre de composants, ne se moque pas du cirque.  C'est vraiment très difficile, et certains cas ne peuvent pas être résolus en principe, mais peuvent seulement être contournés. <br><br>  Par rapport à cela, les gestionnaires de langue de package modernes comme cargo for Rust sont beaucoup plus pratiques - vous appuyez sur le bouton et tout fonctionne.  Bien qu'en fait, sous le capot, un grand nombre de problèmes soient résolus.  De plus, toutes ces nouvelles fonctions nécessitent quelque chose de plus, notamment une base de données.  Bien que dans le gestionnaire de paquets lui-même, il puisse être appelé comme vous voulez, je l'appelle une base de données, car  les données y sont stockées: sur les packages installés, sur leurs versions, les référentiels connectés, les versions de ces référentiels.  Tout cela doit être stocké quelque part, il existe donc une base de données interne. <br><br>  Développement dans ce langage de programmation, tests pour ce langage de programmation, lancements - tout cela est intégré et situé à l'intérieur, le <strong>travail devient très pratique</strong> .  La plupart des langues modernes ont soutenu cette approche.  Même ceux qui n'ont pas soutenu commencent à soutenir, car la communauté insiste et dit que dans le monde moderne, c'est impossible sans cela. <br><br>  <strong>Mais toute solution présente toujours non seulement des avantages, mais aussi des inconvénients</strong> .  L'inconvénient ici est que vous avez besoin d'encapsuleurs, d'utilitaires supplémentaires et d'une «base de données» intégrée. <br><br><h2>  Docker <br></h2><br><blockquote>  Pensez-vous que Docker est un gestionnaire de paquets ou non? <br></blockquote><br>  Peu importe comment, mais essentiellement oui.  Je ne connais pas d'utilitaire plus correct pour assembler complètement l'application avec toutes les dépendances, et pour la faire fonctionner d'un simple clic.  Qu'est-ce que ce n'est pas un gestionnaire de paquets?  C'est un excellent gestionnaire de paquets! <br><br>  Maxim Lapshin a déjà <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dit</a> qu'avec Docker, c'est devenu beaucoup plus facile, et c'est ainsi.  Docker a un système de build intégré, toutes ces bases de données, liaisons, utilitaires. <br><br>  Quel est le prix de tous les avantages?  Ceux qui travaillent avec Docker réfléchissent peu aux applications industrielles.  J'ai une telle expérience, et le prix est en fait très élevé: <br><br><ul><li>  <strong>La quantité d'informations</strong> (taille d'image) qui doit être stockée dans l'image Docker.  Vous avez besoin de toutes les dépendances, parties d'utilitaires, bibliothèques à emballer à l'intérieur, l'image est grande et vous devez pouvoir travailler avec elle. </li><li>  Il est beaucoup plus compliqué qu'un <strong>changement de paradigme</strong> se produise. </li></ul><br>  Par exemple, j'ai eu la tâche de transférer un programme pour utiliser Docker.  Le programme a été développé au fil des ans par une équipe.  Je viens, nous faisons tout ce qui est écrit dans les livres: nous peignons des histoires d'utilisateurs, des rôles, voyons ce qu'ils font et comment ils le font, leurs routines standard. <br><br>  Je dis: <br><br>  - Docker peut résoudre tous vos problèmes.  Regardez comment cela se fait. <br><br>  - Tout sera sur le bouton - super!  Mais nous voulons que SSH fasse à l'intérieur des conteneurs Kubernetes. <br><br>  - Attendez, pas de SSH n'importe où. <br><br>  - Oui, oui, tout va bien ... Mais la SSH est-elle possible? <br><br>  Pour transformer la perception des utilisateurs dans une nouvelle direction, cela prend beaucoup de temps, il faut du travail éducatif et beaucoup d'efforts. <br><br>  Un autre facteur de prix est que le <strong>registre Docker</strong> est un référentiel externe pour les images, il doit être installé et contrôlé d'une manière ou d'une autre.  Il a ses propres problèmes, un récupérateur de déchets et ainsi de suite, et il peut souvent tomber si vous ne le suivez pas, mais tout est résolu. <br><br><h2>  Kubernetes <br></h2><br>  Enfin, nous sommes arrivés à Kubernetes.  Il s'agit d'un système de gestion d'applications OpenSource sympa qui est activement soutenu par la communauté.  Bien qu'il ait initialement quitté une entreprise, Kubernetes a maintenant une énorme communauté, et il est impossible de la suivre, il n'y a pratiquement aucune alternative. <br><br>  Fait intéressant, tous les nœuds Kubernetes fonctionnent dans Kubernetes lui-même via des conteneurs, et toutes les applications externes fonctionnent via des conteneurs - <strong>tout fonctionne via des conteneurs</strong> !  C'est à la fois un plus et un moins. <br><br>  Kubernetes possède de nombreuses fonctionnalités et propriétés utiles: distribution, tolérance aux pannes, capacité à travailler avec différents services cloud et orientation vers l'architecture de microservices.  Tout cela est intéressant et cool, mais comment installer l'application dans Kubernetes? <br><br><h3>  Comment installer l'appli? <br></h3><br><blockquote>  Installez l'image Docker dans le registre Docker. </blockquote><br>  Derrière cette phrase se cache un abîme.  Vous imaginez - vous avez une application écrite, disons, en Ruby, et vous devez mettre l'image Docker dans le registre Docker.  Cela signifie que vous devez: <br><br><ul><li>  Préparer une image Docker </li><li>  comprendre comment cela se passe, sur quelles versions il est basé; </li><li>  pouvoir le tester; </li><li>  collecter, remplir le Docker-Registry, que vous avez d'ailleurs déjà installé auparavant. </li></ul><br>  En fait, c'est une très grosse douleur sur une seule ligne. <br><br>  De plus, vous devez toujours décrire le manifeste de l'application en termes (ressources) de k8s.  L'option la plus simple: <br><br><ul><li>  décrire le déploiement + le module, le service + l'entrée (éventuellement); </li><li>  exécutez la commande kubectl apply -f resources.yaml et transférez toutes les ressources vers cette commande. </li></ul><br><img src="https://habrastorage.org/webt/o9/pj/8w/o9pj8wgukswoi3laskibnzkemg0.png"><br><br>  Gandhi se frotte les mains sur la diapositive - on dirait que j'ai trouvé le gestionnaire de paquets dans Kubernetes.  Mais kubectl n'est pas un gestionnaire de paquets.  Il dit simplement que je veux voir un tel état final du système.  Ce n'est pas installer un paquet, ne pas travailler avec des dépendances, pas construire - c'est juste "Je veux voir cet état final". <br><br><h2>  Heaume <br></h2><br>  Enfin, nous sommes arrivés à Helm.  Helm est un utilitaire polyvalent.  Nous allons maintenant examiner quels sont les domaines de développement de Helm et travailler avec. <br><br><h3>  Moteur de modèle <br></h3><br>  Premièrement, Helm est un moteur de modèle.  Nous avons discuté des ressources à préparer, et le problème est d'écrire en termes de Kubernetes (et pas seulement en yaml).  La chose la plus intéressante est que ce sont des fichiers statiques pour votre application spécifique dans cet environnement particulier. <br><br>  Cependant, si vous travaillez avec plusieurs environnements et que vous disposez non seulement de Production, mais également de Staging, Testing, Development et de différents environnements pour différentes équipes, vous devez disposer de plusieurs manifestes similaires.  Par exemple, parce que dans l'un d'eux il y a plusieurs serveurs et que vous devez avoir un grand nombre de répliques, et dans l'autre - une seule réplique.  Il n'y a pas de base de données, d'accès à RDS et vous devez installer PostgreSQL à l'intérieur.  Et ici, nous avons l'ancienne version, et nous devons tout réécrire un peu. <br><br>  Toute cette diversité conduit au fait que vous devez prendre votre manifeste pour Kubernetes, le copier partout et le réparer partout: ici remplacez un chiffre, voici autre chose.  Cela devient très inconfortable. <br><br>  La solution est simple - vous devez <strong>saisir des modèles</strong> .  En d'autres termes, vous formez un manifeste, vous y définissez des variables, puis vous soumettez les variables définies en externe sous forme de fichier.  Le modèle crée le manifeste final.  Il se révèle réutiliser le même manifeste pour tous les environnements, ce qui est beaucoup plus pratique. <br><br>  Par exemple, le manifeste pour Helm. <br><img src="https://habrastorage.org/webt/ls/ys/ms/lsysmsc7kcnrm1vl8epif7ooowu.png"><br><br><ul><li>  La partie la plus importante de Helm est <strong>Chart.yaml</strong> , qui décrit de quel type de manifeste il s'agit, quelles versions, comment cela fonctionne. </li><li>  <strong>les modèles ne</strong> sont que des modèles de ressources Kubernetes qui contiennent en eux-mêmes une sorte de variables.  Ces variables doivent être définies dans un fichier externe ou sur la ligne de commande, mais toujours en externe. </li><li>  <strong>values.yaml</strong> est le nom standard du fichier avec des variables pour ces modèles. </li></ul><br>  La commande de démarrage la plus simple pour installer le graphique est helm install ./wordpress (dossier).  Pour redéfinir certains paramètres, nous disons: "Je veux redéfinir précisément ces paramètres et définir telle ou telle valeur". <br><br>  Helm fait face à cette tâche, donc dans le diagramme, nous le marquons en vert. <br><img src="https://habrastorage.org/webt/it/nk/7s/itnk7so3wdowimy9riigh74amhy.png"><br><br>  Certes, les inconvénients apparaissent: <br><br><ul><li>  <strong>Verbosité</strong> .  Les ressources sont définies complètement en termes de Kubernetes, les concepts de niveaux supplémentaires d'abstraction ne sont pas introduits: nous écrivons simplement tout ce que nous aimerions écrire pour Kubernetes et y remplaçons des variables. </li><li>  <strong>Ne vous répétez pas - sans objet.</strong>  Il est souvent nécessaire de répéter la même chose.  Si vous avez deux services similaires avec des noms différents, vous devez copier complètement le dossier entier (le plus souvent, ils le font) et modifier les fichiers nécessaires. </li></ul><br>  Avant de plonger dans la direction de Helm - un gestionnaire de paquets, pour lequel je vous dis tout cela, voyons comment Helm fonctionne avec les dépendances. <br><br><h3>  Travailler avec des dépendances <br></h3><br>  Helm est difficile de travailler avec des dépendances.  Tout d'abord, il existe un fichier requirements.yaml qui correspond à ce dont nous dépendons.  Tout en travaillant avec les exigences, il fait requirements.lock - c'est l'état actuel (nugget) de toutes les dépendances.  Après cela, il les télécharge dans un dossier appelé / charts. <br><br>  Il existe des outils pour gérer: qui, comment, où se connecter - <strong>balises et conditions</strong> , avec lesquelles il est déterminé dans quel environnement, en fonction de quels paramètres externes, pour se connecter ou non pour connecter certaines dépendances. <br><br>  Disons que vous avez PostgreSQL pour l'environnement de transfert (ou RDS pour la production ou NoSQL pour les tests).  En installant ce paquet dans Production, vous n'installerez pas PostgreSQL, car il n'y est pas nécessaire - il suffit d'utiliser des balises et des conditions. <br><br>  Qu'est-ce qui est intéressant ici? <br><br><ul><li>  Helm mélange toutes les ressources de toutes les dépendances et applications; </li><li>  trier -&gt; installer / mettre à jour </li></ul><br>  Après avoir téléchargé toutes les dépendances dans / charts (ces dépendances peuvent être, par exemple, 100), Helm prend et copie toutes les ressources à l'intérieur.  Après avoir rendu les modèles, il rassemble toutes les ressources en un seul endroit et les trie dans une sorte de son propre ordre.  Vous ne pouvez pas influencer cet ordre.  Vous devez déterminer par vous-même de quoi dépend votre package, et si le package a des dépendances transitives, vous devez tous les inclure dans la description dans requirements.yaml.  Il faut garder cela à l'esprit. <br><br><h3>  Gestionnaire de paquets <br></h3><br>  Helm installe les applications et les dépendances, et vous pouvez dire à Helm install - et il installera le package.  Il s'agit donc d'un gestionnaire de packages. <br><br>  Dans le même temps, si vous avez un référentiel externe dans lequel vous téléchargez le package, vous pouvez y accéder non pas en tant que dossier local, mais simplement dire: «À partir de ce référentiel, prenez ce package, installez-le avec tel ou tel paramètre». <br><br>  Il existe des référentiels ouverts avec de nombreux packages.  Par exemple, vous pouvez exécuter: helm install -f prod / values.yaml stable / wordpress <br><br>  Depuis le référentiel stable, vous prendrez wordpress et l'installerez vous-même.  Vous pouvez tout faire: rechercher / mettre à niveau / supprimer.  Il s'avère que Helm est un gestionnaire de paquets. <br><br>  Mais il y a des inconvénients: toutes <strong>les dépendances transitives</strong> doivent être incluses à l'intérieur.  C'est un gros problème lorsque les dépendances transitives sont des applications indépendantes et que vous souhaitez travailler séparément avec elles pour les tests et le développement. <br><br>  Un autre inconvénient est la <strong>configuration de bout en bout</strong> .  Lorsque vous avez une base de données et que son nom doit être transféré dans tous les packages, cela peut être le cas, mais c'est difficile à faire. <br><br><img src="https://habrastorage.org/webt/ws/8m/ox/ws8moxa7dp9ekfc_fcb4mcrytae.png"><br><br>  Plus souvent qu'autrement, vous avez installé un petit paquet et cela fonctionne.  Le monde est complexe: l'application dépend de l'application, qui à son tour dépend également de l'application - vous devez les configurer intelligemment.  Helm ne sait pas comment soutenir cela, ou le supporte avec de gros problèmes, et parfois vous devez beaucoup danser avec un tambourin pour le faire fonctionner.  C'est mauvais, donc le "gestionnaire de paquets" dans le diagramme est surligné en rouge. <br><br><img src="https://habrastorage.org/webt/c5/rj/sz/c5rjszxy-hf_-pulkkcz_tsaie0.png"><br><br><h3>  Assemblage et emballage <br></h3><br>  "Vous ne pouvez pas simplement obtenir et exécuter" l'application dans Kubernetes.  Vous devez l'assembler, c'est-à-dire créer une image Docker, l'écrire dans le registre Docker, etc.  Bien que la définition de package entière dans Helm soit.  Nous déterminons ce qu'est le package, quelles fonctions et quels champs doivent y être, les signatures et l'authentification (le système de sécurité de votre entreprise sera très content).  Par conséquent, d'une part, l'assemblage et le conditionnement semblent être pris en charge, et d'autre part, le travail avec les images Docker n'est pas configuré. <br><br><blockquote>  Helm ne vous permet pas d'exécuter l'application sans image Docker.  Dans le même temps, Helm n'est pas configuré pour l'assemblage et le conditionnement, c'est-à-dire qu'il ne sait pas comment travailler avec les images Docker. <br></blockquote><br>  C'est la même chose que si, pour effectuer une installation de mise à niveau pour une petite bibliothèque, vous seriez envoyé dans un dossier distant pour exécuter le compilateur. <br><br>  Par conséquent, nous disons que Helm ne sait pas comment travailler avec des images. <br><img src="https://habrastorage.org/webt/am/li/ia/amliiax7srabjlml74xvn2xtyb8.png"><br><br><h3>  Développement <br></h3><br>  Le prochain mal de tête est le développement.  En cours de développement, nous voulons changer rapidement et facilement notre code.  Le temps a passé lorsque vous avez percé des trous sur des cartes perforées et le résultat a été obtenu après 5 jours.  Tout le monde a l'habitude de remplacer une lettre par une autre dans l'éditeur, d'appuyer sur la compilation et le programme déjà modifié fonctionne. <br><br>  Il s'avère ici que lors du changement de code, de nombreuses actions supplémentaires sont nécessaires: préparer un fichier Docker;  Exécutez Docker pour qu'il crée l'image;  pour le pousser quelque part;  déployer sur le cluster Kubernetes.  Et seulement alors, vous obtiendrez ce que vous voulez sur Production, et vous pourrez vérifier le code. <br><br>  Il y a encore des inconvénients en raison de la <strong>mise à</strong> niveau <strong>destructrice du</strong> casque de mise à jour.  Vous avez regardé comment tout fonctionnait, grâce à kubectl exec, vous avez regardé à l'intérieur du conteneur, tout va bien.  À ce moment, vous démarrez la mise à jour, une nouvelle image est téléchargée, de nouvelles ressources sont lancées et les anciennes sont supprimées - vous devez tout recommencer depuis le tout début. <br><br>  La plus grande douleur est les <strong>grandes images</strong> .  La plupart des entreprises ne travaillent pas avec de petites applications.  Souvent, sinon un supermonolithe, alors au moins un petit monolithique.  Au fil du temps, les anneaux annuels se développent, la base de code augmente et progressivement l'application devient assez importante.  J'ai rencontré à plusieurs reprises des images Docker supérieures à 2 Go.  Imaginez maintenant que vous apportez une modification d'un octet dans votre programme, appuyez sur un bouton et une image Docker de deux gigaoctets commence à s'assembler.  Ensuite, vous appuyez sur le bouton suivant et le transfert de 2 Go vers le serveur commence. <br><br>  Docker vous permet de travailler avec des calques, c'est-à-dire  vérifie s'il y a une couche ou une autre et envoie celle qui manque.  Mais le monde est tel que le plus souvent ce sera une grande couche.  Alors que 2 Go iront au serveur, alors qu'ils iront à Kubernetes avec le registre Docker, ils seront déployés de toutes les manières, jusqu'à ce que vous commenciez enfin, vous pouvez prendre le thé en toute sécurité. <br><br>  Helm n'offre aucune aide pour les grandes images Docker.  Je crois que cela ne devrait pas être le cas, mais les développeurs de Helm le savent mieux que tous les utilisateurs, et Steve Jobs lui sourit. <br><br><img src="https://habrastorage.org/webt/xk/wk/4z/xkwk4zdrvxa1xpejhdf02ogsdgo.png"><br><br>  Le bloc avec le développement est également devenu rouge. <br><br><img src="https://habrastorage.org/webt/pu/o2/ha/puo2ha8r-gmi9cqnkr_sfdv_mpq.png"><br><br><h3>  Automatisation de l'environnement <br></h3><br>  La dernière direction - l'automatisation de l'environnement - est un domaine intéressant.  Avant le monde de Docker (et Kubernetes, en tant que modèle connexe), il n'y avait aucun moyen de dire: "Je veux installer mon application sur ce serveur ou sur ces serveurs pour qu'il y ait n répliques, 50 dépendances, et tout cela fonctionne automatiquement!"  Tel, pourrait-on dire, ce qui était, mais ne l'était pas! <br><br>  Kubernetes fournit cela et il est logique de l'utiliser d'une manière ou d'une autre, par exemple pour dire: "Je déploie un nouvel environnement ici et je veux que toutes les équipes de développement qui ont préparé leurs applications puissent simplement cliquer sur un bouton et toutes ces applications seront automatiquement installées sur le nouvel environnement" .  Théoriquement, Helm devrait aider à cela, afin que la configuration puisse être prise à partir d'une source de données externe - S3, GitHub - de n'importe où. <br><br>  Il est conseillé qu'il y ait un bouton spécial dans Helm "Fais-moi du bien déjà enfin!"  - et cela deviendrait immédiatement bon.  Kubernetes vous permet de le faire. <br><br>  Ceci est particulièrement pratique car Kubernetes peut être exécuté n'importe où et fonctionne via l'API.  En lançant minikube localement, dans AWS ou dans Google Cloud Engine, vous obtenez Kubernetes dès la sortie de la boîte et travaillez de la même manière partout: appuyez sur un bouton et tout va bien tout de suite. <br><br>  Il semblerait que Helm vous le permette naturellement.  Car sinon, à quoi bon créer Helm en général? <br><br>  Mais il s'avère que non! <br><img src="https://habrastorage.org/webt/xs/mf/h5/xsmfh5898yrlawroqge2dn6v_iw.png"><br><br>  Il n'y a pas d'automatisation de l'environnement. <br><br><h2>  Alternatives <br></h2><br>  Quand il y a une application de Kubernetes que tout le monde utilise (c'est maintenant en fait la solution numéro 1), mais Helm a les problèmes discutés ci-dessus, la communauté n'a pas pu s'empêcher de répondre.  Il a commencé à créer des outils et des solutions alternatifs. <br><br><h3>  Moteurs de modèles <br></h3><br>  Il semblerait qu'en tant que moteur de modèle, Helm ait résolu tous les problèmes, mais la communauté crée toujours des alternatives.  Permettez-moi de vous rappeler les problèmes du moteur de template: verbosité et réutilisation du code. <br><br>  Un bon représentant ici est <strong>Ksonnet.</strong>  Il utilise un modèle de données et de concepts fondamentalement différent et ne fonctionne pas avec les ressources Kubernetes, mais avec ses propres définitions: <br>  <em>prototype (params) -&gt; composant -&gt; application -&gt; environnements.</em> <em><br></em> <br><br>  Il y a des pièces qui composent le prototype.  Le prototype est paramétré par des données externes et le composant apparaît.  Plusieurs composants constituent une application que vous pouvez exécuter.  Il fonctionne dans différents environnements.  Il existe des liens clairs vers les ressources Kubernetes ici, mais il n'y a peut-être pas d'analogie directe. <br><br>  Le principal objectif de Ksonnet était, bien sûr, de <strong>réutiliser les ressources</strong> .  Ils voulaient s'assurer qu'une fois que vous avez écrit le code, vous pourrez ensuite l'utiliser n'importe où, ce qui augmente la vitesse de développement.  Si vous créez une grande bibliothèque externe, les utilisateurs peuvent y publier en permanence leurs ressources et toute la communauté pourra les réutiliser. <br><br>  Théoriquement, c'est pratique.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Je ne l'ai pratiquement pas utilisé. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gestionnaires de packages </font></font><br></h3><br>  ,    —   ,  ,  .  Ksonnet  .  Ksonnet    Helm ,         ,       ..   ,    ,     ,       . <br><img src="https://habrastorage.org/webt/-e/ed/76/-eed76zagrsnj_ydzkcqedelf1g.png"><br><br>    ,   ,  ,    ,   .      .    ,      ,   ,      0.1. ,     . <br><img src="https://habrastorage.org/webt/-c/om/sm/-comsmfipyfxjxvsbit48zbwhoe.png"><br><br> ,   —  <strong>KubePack</strong> ,       . <br><br><h3>  Développement <br></h3><br>      : <br><br><ol><li>    Helm; <br></li><li>  Helm; <br></li><li>    ,        ; <br></li><li>   ,   . <br></li></ol><br><h4> 1.   Helm <br></h4><br>   —  <strong>Draft</strong> .   —      ,   ,     . Draft    — Heroku-style: <br><br><ul><li>      (pack); </li><li> , ,  Python «Hello, world!»; </li><li>  ,   Docker- (   ); </li><li>   ,   ,   docker-registry,     ; </li><li>    . </li></ul><br>        ,   ,   . <br><br>          Helm,   Draft  Helm-,        production ready,   ,  Draft   Helm-,  .       . <br><br> ,  Draft           ,      Helm-. Draft —     . <br><br><h4> 2.   Helm <br></h4><br>   Helm Charts      Kubernetes-,       Helm Charts.   : <br><br><ul><li> GitKube; </li><li> Skaffold; </li><li> Forge. </li></ul><br>      Helm,    .  ,   ,     command line interface,  Chart ,     git push   . <br><br>   ,     docker build, docker push  kubectl rollout.   ,     Helm,   .        . <br><br><h4> 3.     <br></h4><br>   —    .    — <strong>Metaparticle</strong> . ,     Python,    Python  ,     . <br><br><blockquote>       ,          ,      ,      sysconfig  ..    . <br></blockquote><br>     ,     ,    ,  -           Kubernetes-. <br><br>    :   ,     ;   ,      ;        .. <br><img src="https://habrastorage.org/webt/wn/vg/4-/wnvg4-72i7bhg5dabn9_1zinijw.png"><br><br>   ,  ,     ,    -  ,   Python-     Kubernetes-.     ? <br><br>     - ,    .    . ,  ,       preinstall ,   -     .      Kubernetes-,       Metaparticle,   . <br><br>     ,    ,   Kubernetes-   .  ,       ,  Metaparticle. <br><br><img src="https://habrastorage.org/webt/l1/py/fi/l1pyfi0l2xjkhgatomlhj6sil3s.png"><br><br>    Metaparticle,      Helm .   ,       . <br><br> <strong>Telepresence/Ksync</strong> —   . ,      ,  Helm-,   .   ,   -  ,       - , ,      . ,     Production-,     Production - . <br><br>  Kubernetes  ,        Docker,  registry,   Kubernetes.          .      ,    . <br><br> , ,       ,    Development     .    :  ,   ,   ,     ,     —   ,   ,   ,   Helm,  ,     . <br><br>   ,    . <br><br><h4> 4.   Kubernetes  Kubernetes <br></h4><br>   ,      Kubernetes  Kubernetes.  ,       Helm-    ,         .          ,      .     ,    Docker-compose . <br><br>    Docker-compose ,       ,    ,    ,       Docker,     Kubernetes,    Docker-compose,   .     ,    .   ,       Docker.     . <br><br>        minikube   ,      Docker-compose,    .  ,   ,  Docker-compose —  10     .         ,   . <br><img src="https://habrastorage.org/webt/m2/h4/tt/m2h4tthsizav7rv4tubxlkfo0qg.png"><br><br>     Docker-compose,    ,         . <br><br><h3>    <br></h3><br> ,    —   Helm, , ,  Helm -  .       CI/CD,   ,   .     —      Helm,     ? ,     ,    . <br><br>     CI/CD,     ,      docker',  set-,         ,    —   . <br><br> CI/CD —       ,     . <br><br><h2>  Résumé <br></h2><br><img src="https://habrastorage.org/webt/fy/pc/ba/fypcbahu2fgsz16tn-imk2a5vpy.png"><br><br>  5   Helm   .   ,    .     ,  ,       .     ,          ,  ,   . <br><br><h2>  Helm <br></h2><br> ,       ,   Helm  .   ,  Helm    ,   . ,     ,   ,     Helm. <br><br> ,     Road Map.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kuberneres Helm  community</a> ,          ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Helm V3</a> . <br><br><h3>   Tiller,  cli <br></h3><br>      ,   .  Helm    : <br><br><ol><li>  ,       (cmd  ..). <br></li><li> Tiller —  ,      Kubernetes. <br></li></ol><br> Tiller  ,     Command Line Interface.    : «     Chart» —   Helm  , ,  Tiller',    : «,  - ! ,      Kubernetes-» —  . <br><br>    Helm,    Tiller       ,    .    ,   ,    ,     ,   Tiller' —   namespace .  Tiller      namespace,    ,       .      ,     . <br><br>    V3 Tiller  . <br><img src="https://habrastorage.org/webt/k2/rs/3d/k2rs3djfuxajcdf1cgr2whzob58.png"><br><br>     ?  ,   ,   Command Line Interface,  ,     Kubernetes. ,   Kubernetes      ,    Tiller.      kubectl cli    . <br><br>  Tiller  <strong> </strong> .    ,     Kubernetes  Command Line Interface  : , , , pre-  post-.    . <br><br><h3> Lua-  Chart <br></h3><br>       ,  — ,       <strong>lua-</strong> .    Chart    lua-,     .       . ,  .   ,   ,    ,      . <br><img src="https://habrastorage.org/webt/cr/ie/h1/crieh1qr2o9qc9oocuti_i9bhhm.png"><br><br> Lua      ,      ,   ,  - ,    ,      . <br><br>  ,   ,   .  ,           .       Kubernetes,    - ,    ,    ,   ,    .  Voyons ce qui se passe. <br><br><h3> Release- + secret   <br></h3><br>  ,     ,  <strong>Release-</strong>    ,  Release  .   ,     Release-,     ,  ,   CRD,  , . <br><br><h3>   namespace  <br></h3><br>  Release-     namespace,     ,   -  <strong>   Tiller'</strong>  namespace —  ,      . <br><br><h3> CRD: controller <br></h3><br>        ,   CRD-controller  Helm   ,       push-.        . <br><br><h2>   <br></h2><br>  ,     . <br><img src="https://habrastorage.org/webt/c-/kk/zv/c-kkzvsvdzuwr3werccbixl1an4.png"><br><br>  ,  <strong>Helm</strong> .   ,      ,     ,     .  ,       ,      .  Helm —  -   Kubernetes.      -  ,  ,  . <br><br>  , <strong>CI/CD</strong> ,    .      <strong>  Slack</strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous avons un bot qui signale quand une nouvelle build est passée en master, et que tous les tests ont réussi. </font><font style="vertical-align: inherit;">Vous lui dites: "Je veux l'installer dans Staging" - et il installe, vous dites: "Je veux y faire un test!" </font><font style="vertical-align: inherit;">- et il commence. </font><font style="vertical-align: inherit;">Assez confortable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour le développement, utilisez </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docker-compose ou Telepresence.</font></font></strong> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plusieurs versions d'un service </font></font><br></h2><br><img src="https://habrastorage.org/webt/gg/cq/wv/ggcqwvrbonamtzi4wudhx3t9jly.png"><br><br>  Au final, nous analyserons la situation lorsqu'il y a deux applications A et B, qui dépendent de C, mais C de versions différentes.  Besoin de résoudre ce problème: <br><br><ul><li>  pour le développement, car en fait nous devons développer la même chose, mais deux versions différentes; </li><li>  pour publication; </li><li>  pour un conflit de noms, car dans tous les gestionnaires de packages standard, l'installation de deux packages de versions différentes peut entraîner des problèmes. </li></ul><br>  En fait, Kubernetes décide de tout pour nous - il vous suffit de l'utiliser correctement. <br><br><img src="https://habrastorage.org/webt/wq/ra/mr/wqramrfg3yh1izbnppjmxeuc9hs.png"><br><br>  Je conseillerais de créer 4 graphiques en termes de Helm, 3 référentiels (pour le référentiel C, ce ne seront que deux branches différentes).  Ce qui est le plus intéressant, toutes les installations pour v1 et pour v2 doivent contenir en elles-mêmes des informations sur la version ou pour quel service elle a été créée.  Une solution sur la diapositive, annexe C;  le nom de la version indique qu'il s'agit de la version v1 pour le service A;  le nom du service contient également la version.  Ceci est l'exemple le plus simple, vous pouvez le faire complètement différemment.  Mais la chose la plus importante est que les noms sont uniques. <br><br>  Le second est les dépendances transitives, et ici c'est plus compliqué. <br><img src="https://habrastorage.org/webt/pi/5l/ya/pi5lyafuuagwemrrfdhkdb_zby4.png"><br><br>  Par exemple, vous développez une chaîne de services et souhaitez tester A. Pour cela, vous devez transférer toutes les dépendances dont dépend A, y compris transitive, dans la définition Helm de votre package.  Mais en même temps, vous souhaitez développer B et le tester également - comment le faire est incompréhensible, car vous devez également y mettre toutes les dépendances transitives. <br><br>  Par conséquent, je vous conseille de ne pas ajouter toutes les dépendances à l'intérieur de chaque package, mais de les rendre indépendantes et du contrôle extérieur de ce qui est en cours d'exécution.  C'est gênant, mais c'est le moindre de deux maux. <br><br><h2>  Liens utiles <br></h2><br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Brouillon</a> <br><br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitKube</a> <br><br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Heaume</a> <br><br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ksonnet</a> <br><br>  • Autocollants de télégramme: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux</a> <br><br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sig-Apps</a> <br><br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">KubePack</a> <br><br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Métaparticule</a> <br><br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Skaffold</a> <br><br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Helm v3</a> <br><br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Docker-compose</a> <br><br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ksync</a> <br><br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Téléprésence</a> <br><br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Drone</a> <br><br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Forge</a> <br><br>  Profil du conférencier Ivan Glushkov sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> , sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Twitter</a> , sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Habr</a> . <br><br><blockquote>  Bonne nouvelle <br><br>  Sur notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chaîne YouTube,</a> nous avons <strong>ouvert une vidéo de tous les reportages sur DevOps du festival RIT ++</strong> .  Il s'agit d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste de lecture</a> distincte, mais dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste complète des</a> vidéos, il y a beaucoup de choses utiles d'autres conférences. <br><br>  Mieux encore, abonnez-vous à la chaîne et à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">newsletter</a> , car l'année prochaine <strong>nous aurons beaucoup de devops</strong> : en mai, le framework de RIT ++;  au printemps, en été et en automne en tant que section de HighLoad ++, et en automne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DevOpsConf Russie</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431540/">https://habr.com/ru/post/fr431540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431530/index.html">Leçon ouverte "Android Material Design: aperçu de la mise à jour"</a></li>
<li><a href="../fr431532/index.html">Memristors constitués de pièces de 2 nm d'épaisseur</a></li>
<li><a href="../fr431534/index.html">Identités des problèmes parmi les développeurs</a></li>
<li><a href="../fr431536/index.html">Ceph. Anatomie de catastrophe</a></li>
<li><a href="../fr431538/index.html">Case Rate & Goods et Mobio: augmentation progressive de tous les indicateurs</a></li>
<li><a href="../fr431542/index.html">Développement et maintenance efficaces des rôles Ansible</a></li>
<li><a href="../fr431544/index.html">Portez DevOps aux masses</a></li>
<li><a href="../fr431546/index.html">Pourquoi disons-nous OK?</a></li>
<li><a href="../fr431548/index.html">Solar Dozor - Qu'est-ce qui se cache derrière les étoiles?</a></li>
<li><a href="../fr431550/index.html">Moulage par injection de film (IMD): comment cela fonctionne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>