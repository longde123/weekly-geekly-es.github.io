<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëñ üîµ üõÇ Geben Sie Ihren Code schlie√ülich ein üìú üéΩ üëçüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 


 Neulich habe ich wieder den Typcode bekommen 


if(someParameter.Volatilities.IsEmpty()) { // We have to report about the broken chann...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Geben Sie Ihren Code schlie√ülich ein</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462655/"><p>  Hallo Habr! </p><br><p>  Neulich habe ich wieder den Typcode bekommen </p><br><pre><code class="plaintext hljs">if(someParameter.Volatilities.IsEmpty()) { // We have to report about the broken channels, however we could not differ it from just not started cold system. // Therefore write this case into the logs and then in case of emergency IT Ops will able to gather the target line Log.Info("Channel {0} is broken or was not started yet", someParameter.Key) }</code> </pre> <br><p>  Der Code enth√§lt eine wichtige Funktion: Der Empf√§nger m√∂chte sehr gerne wissen, was wirklich passiert ist.  In einem Fall haben wir Probleme mit dem System, in dem anderen w√§rmen wir uns einfach auf.  Das Modell gibt uns dies jedoch nicht (um dem Absender zu gefallen, der h√§ufig der Autor des Modells ist). <br>  Dar√ºber hinaus ist selbst die Tatsache, dass m√∂glicherweise etwas nicht stimmt, darauf zur√ºckzuf√ºhren, dass die <code>Volatilities</code> Sammlung leer ist.  Was in einigen F√§llen richtig sein kann. </p><br><p>  Ich bin sicher, dass die meisten erfahrenen Entwickler im Code Zeilen gesehen haben, die geheimes Wissen im Stil von "Wenn diese Kombination von Flags gesetzt ist, werden wir gebeten, A, B und C zu erstellen" (obwohl dies f√ºr das Modell selbst nicht sichtbar ist). </p><br><p>  Aus meiner Sicht wirken sich solche Einsparungen bei der Struktur von Klassen in Zukunft √§u√üerst negativ auf das Projekt aus und verwandeln es in eine Reihe von Hacks und Kr√ºcken, wodurch ein mehr oder weniger praktischer Code schrittweise in Legacy umgewandelt wird. </p><br><p>  <strong>Wichtig:</strong> In dem Artikel gebe ich Beispiele, die f√ºr Projekte n√ºtzlich sind, in denen mehrere Entwickler (und nicht einer) arbeiten, und die mindestens 5-10 Jahre lang aktualisiert und erweitert werden.  All dies ist nicht sinnvoll, wenn das Projekt f√ºnf Jahre lang einen Entwickler hat oder wenn nach der Ver√∂ffentlichung keine √Ñnderungen geplant sind.  Und es ist logisch, wenn das Projekt nur f√ºr ein paar Monate ben√∂tigt wird, macht es keinen Sinn, in ein klares Datenmodell zu investieren. </p><br><p>  Wenn Sie jedoch lange spielen - willkommen bei cat. </p><a name="habracut"></a><br><h1 id="ispolzuyte-pattern-visitor">  Verwenden Sie das Besuchermuster </h1><br><p>  Oft enth√§lt dasselbe Feld ein Objekt, das unterschiedliche semantische Bedeutungen haben kann (wie im Beispiel).  Um Klassen zu speichern, l√§sst der Entwickler jedoch nur einen Typ √ºbrig und versorgt ihn mit Flags (oder Kommentaren im Stil "Wenn hier nichts ist, wurde nichts gez√§hlt").  Ein √§hnlicher Ansatz kann einen Fehler maskieren (was f√ºr das Projekt schlecht, aber f√ºr das Team, das den Service bereitstellt, praktisch ist, da die Fehler von au√üen nicht sichtbar sind).  Eine korrektere Option, mit der Sie sogar am anderen Ende des Kabels herausfinden k√∂nnen, was tats√§chlich passiert, ist die Verwendung der Schnittstelle + Besucher. </p><br><p>  In diesem Fall wird das Beispiel aus der Kopfzeile zum Code des Formulars: </p><br><pre> <code class="plaintext hljs">class Response { public IVolatilityResponse Data { get; } } interface IVolatilityResponse { TOutput Visit&lt;TInput, TOutput&gt;(IVolatilityResponseVisitor&lt;TInput, TOutput&gt; visitor, TInput input) } class VolatilityValues : IVolatilityResponse { public Surface Data; TOutput Visit&lt;TInput, TOutput&gt;(IVolatilityResponseVisitor&lt;TInput, TOutput&gt; visitor, TInput input) =&gt; visitor.Visit(this, input); } class CalculationIsBroken : IVolatilityResponse { TOutput Visit&lt;TInput, TOutput&gt;(IVolatilityResponseVisitor&lt;TInput, TOutput&gt; visitor, TInput input) =&gt; visitor.Visit(this, input); } interface IVolatilityResponseVisitor&lt;TInput, TOutput&gt; { TOutput Visit(VolatilityValues instance, TInput input); TOutput Visit(CalculationIsBroken instance, TInput input); }</code> </pre> <br><p>  Mit dieser Art der Verarbeitung: </p><br><ul><li>  Wir brauchen mehr Code.  Wenn wir mehr Informationen im Modell ausdr√ºcken m√∂chten, sollten es leider mehr sein. </li><li>  Aufgrund dieser Art der Vererbung k√∂nnen wir die <code>Response</code> auf <code>json</code> / <code>protobuf</code> nicht mehr serialisieren, da dort <code>protobuf</code> verloren gehen.  Wir m√ºssen einen speziellen Container erstellen, der dies erledigt (Sie k√∂nnen beispielsweise eine Klasse erstellen, die f√ºr jede Implementierung ein separates Feld enth√§lt, von dem jedoch nur eines ausgef√ºllt wird). </li><li>  Um das Modell zu erweitern ( <code>IVolatilityResponseVisitor&lt;TInput, TOutput&gt;</code> neue Klassen hinzuzuf√ºgen), muss die Schnittstelle <code>IVolatilityResponseVisitor&lt;TInput, TOutput&gt;</code> erweitert werden. <code>IVolatilityResponseVisitor&lt;TInput, TOutput&gt;</code> bedeutet, dass der Compiler die Unterst√ºtzung im Code <code>IVolatilityResponseVisitor&lt;TInput, TOutput&gt;</code> .  Der Programmierer wird nicht vergessen, den neuen Typ zu verarbeiten, da das Projekt sonst nicht kompiliert wird. </li><li>  Aufgrund der statischen Typisierung m√ºssen wir keine Dokumentation mit m√∂glichen Kombinationen von Feldern usw. irgendwo speichern.  Wir haben alle m√∂glichen Optionen im Code beschrieben, die sowohl f√ºr den Compiler als auch f√ºr die Person verst√§ndlich sind.  Wir werden keine Desynchronisation zwischen Dokumentation und Code haben, da wir auf die erste verzichten k√∂nnen. </li></ul><br><h2 id="pro-ogranichenie-nasledovaniya-v-drugih-yazykah">  √úber die Einschr√§nkung der Vererbung in anderen Sprachen </h2><br><p>  Eine Reihe anderer Sprachen (z. B. <code>Scala</code> oder <code>Kotlin</code> ) verf√ºgen √ºber Schl√ºsselw√∂rter, mit denen Sie unter bestimmten Bedingungen das Erben von einem bestimmten Typ verbieten k√∂nnen.  So kennen wir in der Kompilierungsphase alle m√∂glichen Nachkommen unseres Typs. </p><br><p>  Insbesondere kann das obige Beispiel in <code>Kotlin</code> folgenderma√üen umgeschrieben werden: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: IVolatilityResponse ) <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VolatilityResponse</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VolatilityValues</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VolatilityResponse</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: Surface } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CalculationIsBroken</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VolatilityResponse</span></span></span></span>()</code> </pre><br><p>  Es stellte sich heraus, dass es etwas weniger als der Code war, aber jetzt beim Kompilieren wissen wir, dass sich alle m√∂glichen <code>VolatilityResponse</code> in derselben Datei befinden, was bedeutet, dass der folgende Code nicht kompiliert wird, da wir nicht alle m√∂glichen Werte der Klasse durchlaufen haben. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getResponseString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">VolatilityResponse</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(response) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> VolatilityValues -&gt; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.toString() }</code> </pre> <br><p>  Es ist jedoch zu beachten, dass solche √úberpr√ºfungen nur f√ºr Funktionsaufrufe funktionieren.  Der folgende Code wird fehlerfrei kompiliert: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getResponseString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">VolatilityResponse</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(response) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> VolatilityValues -&gt; println(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.toString()) } }</code> </pre> <br><h1 id="ne-vse-primitivnye-tipy-oznachayut-odno-i-to-zhe">  Nicht alle primitiven Typen bedeuten dasselbe </h1><br><p>  Betrachten Sie eine relativ typische Entwicklung f√ºr eine Datenbank.  H√∂chstwahrscheinlich haben Sie irgendwo im Code Objektkennungen.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">class Group { public int Id { get; } public string Name { get; } } class User { public int Id { get; } public int GroupId { get; } public string Name { get; } }</code> </pre> <br><p>  Es scheint wie ein Standardcode.  Die Typen stimmen sogar mit denen in der Datenbank √ºberein.  Die Frage ist jedoch: Ist der folgende Code korrekt? </p><br><pre> <code class="plaintext hljs">public bool IsInGroup(User user, Group group) { return user.Id == group.Id; } public User CreateUser(string name, Group group) { return new User { Id = group.Id, GroupId = group.Id, name = name } }</code> </pre> <br><p>  Die Antwort ist h√∂chstwahrscheinlich nicht, da wir im ersten Beispiel die Benutzer- <code>Id</code> und die Gruppen- <code>Id</code> .  Und im zweiten Fall haben wir f√§lschlicherweise die <code>id</code> von <code>Group</code> als die <code>id</code> von <code>User</code> . </p><br><p>  Seltsamerweise ist dies recht einfach zu beheben: <code>GroupId</code> <code>UserId</code> einfach die Typen <code>GroupId</code> , <code>UserId</code> und so weiter.  Daher funktioniert die Erstellung des <code>User</code> nicht mehr, da Ihre Typen nicht konvergieren.  Das ist unglaublich cool, weil man dem Compiler vom Modell erz√§hlen kann. </p><br><p>  Dar√ºber hinaus funktionieren Methoden mit denselben Parametern f√ºr Sie korrekt, da sie jetzt nicht wiederholt werden: </p><br><pre> <code class="plaintext hljs">public void SetUserGroup(UserId userId, GroupId groupId) { /* some sql code */ }</code> </pre> <br><p>  Kehren wir jedoch zum Beispiel des Vergleichs von Bezeichnern zur√ºck.  Dies ist etwas komplizierter, da Sie verhindern m√ºssen, dass der Compiler das Unvergleichliche w√§hrend des Erstellungsprozesses vergleicht. </p><br><p>  Und Sie k√∂nnen dies wie folgt tun: </p><br><pre> <code class="plaintext hljs">class GroupId { public int Id { get; } public bool Equals(GroupId groupId) =&gt; Id == groupId?.Id; [Obsolete("GroupId can be equal only with GroupId", error: true)] public override bool Equals(object obj) =&gt; Equals(obj as GroupId) public static bool operator==(GroupId id1, GroupId id2) { if(ReferenceEquals(id1, id2)) return true; if(ReferenceEquals(id1, null) || ReferenceEquals(id2, null)) return false; return id1.Id == id2.Id; } [Obsolete("GroupId can be equal only with GroupId", error: true)] public static bool operator==(object _, GroupId __) =&gt; throw new NotSupportedException("GroupId can be equal only with GroupId") [Obsolete("GroupId can be equal only with GroupId", error: true)] public static bool operator==(GroupId _, object __) =&gt; throw new NotSupportedException("GroupId can be equal only with GroupId") }</code> </pre> <br><p>  Als Ergebnis: </p><br><ul><li>  Wir brauchten wieder mehr Code.  Wenn Sie dem Compiler mehr Informationen geben m√∂chten, m√ºssen Sie h√§ufig mehr Zeilen schreiben. </li><li>  Wir haben neue Typen erstellt (wir werden im Folgenden auf Optimierungen eingehen), die manchmal die Leistung geringf√ºgig beeintr√§chtigen k√∂nnen. </li><li>  In unserem Code: <br><ul><li>  Wir haben verboten, Identifikatoren zu verwechseln.  Sowohl der Compiler als auch der Entwickler sehen jetzt deutlich, dass es unm√∂glich ist <code>GroupId</code> Feld <code>GroupId</code> in das Feld <code>GroupId</code> zu <code>GroupId</code> </li><li>  Es ist uns verboten, das Unvergleichliche zu vergleichen.  Ich werde <code>IEquitable</code> dass der Vergleichscode nicht vollst√§ndig ist (es ist auch w√ºnschenswert, die <code>IEquitable</code> Schnittstelle zu implementieren, Sie m√ºssen auch die <code>GetHashCode</code> Methode implementieren), sodass das Beispiel nicht nur in das Projekt kopiert werden muss.  Die Idee selbst ist jedoch klar: Wir haben dem Compiler ausdr√ºcklich untersagt, auszudr√ºcken, wann die falschen Typen verglichen wurden.  Das hei√üt,  anstatt zu sagen "Sind diese Fr√ºchte gleich?"  Der Compiler sieht nun "Ist eine Birne gleich einem Apfel?". </li></ul></li></ul><br><h2 id="nemnogo-esche-ob-sql-i-ob-ogranicheniyah">  Ein bisschen mehr √ºber SQL und Einschr√§nkungen </h2><br><p>  In unseren Anwendungen f√ºr Typen werden h√§ufig zus√§tzliche Regeln eingef√ºhrt, die leicht zu √ºberpr√ºfen sind.  Im schlimmsten Fall sehen einige Funktionen ungef√§hr so ‚Äã‚Äãaus: </p><br><pre> <code class="plaintext hljs">void SetName(string name) { if(name == null || name.IsEmpty() || !name[0].IsLetter || !name[0].IsCapital || name.Length &gt; MAX_NAME_COLUMN_LENGTH) { throw .... } /**/ }</code> </pre> <br><p>  Das hei√üt, die Funktion nimmt eine ziemlich breite Art von Eingabe entgegen und f√ºhrt dann die √úberpr√ºfungen aus.  Dies ist im Allgemeinen nicht der Fall, da: </p><br><ul><li>  Wir haben dem Programmierer und Compiler nicht erkl√§rt, was wir hier wollen. </li><li>  In einer anderen √§hnlichen Funktion m√ºssen Sie die Schecks kopieren. </li><li>  Als wir eine <code>string</code> , die den <code>name</code> kennzeichnet, fielen wir nicht sofort, sondern aus irgendeinem Grund wurde die weitere Ausf√ºhrung auf einige Prozessoranweisungen sp√§ter beschr√§nkt. </li></ul><br><p>  Das richtige Verhalten: </p><br><ul><li>  Erstellen Sie einen separaten Typ (in unserem Fall anscheinend <code>Name</code> ). </li><li>  F√ºhren Sie darin alle erforderlichen Validierungen und √úberpr√ºfungen durch. </li><li>  Wickeln Sie die <code>string</code> so schnell wie m√∂glich in <code>Name</code> so schnell wie m√∂glich einen Fehler zu erhalten. </li></ul><br><p>  Als Ergebnis erhalten wir: </p><br><ul><li>  Weniger Code, da wir die Namenspr√ºfungen im Konstruktor ausgecheckt haben. </li><li>  <em>Fail Fast-</em> Strategie - Nachdem wir einen problematischen Namen erhalten haben, werden wir sofort fallen, anstatt ein paar weitere Methoden aufzurufen, aber immer noch fallen.  Anstelle eines Fehlers aus einer Datenbank vom Typ Typ zu gro√ü stellen wir au√üerdem sofort fest, dass es keinen Sinn macht, solche Namen √ºberhaupt zu verarbeiten. </li><li>  Es ist f√ºr uns bereits schwieriger, die Argumente zu verwechseln, wenn die Funktionssignatur lautet: <code>void UpdateData(Name name, Email email, PhoneNumber number)</code> .  Schlie√ülich √ºbergeben wir jetzt nicht drei identische <code>string</code> , sondern drei verschiedene unterschiedliche Entit√§ten. </li></ul><br><h2 id="nemnogo-o-privedenii-tipov">  Ein bisschen √ºber Casting </h2><br><p>  Wenn wir eine ziemlich strenge Typisierung einf√ºhren, sollten wir auch nicht vergessen, dass wir beim √úbertragen von Daten nach SQL immer noch eine echte Kennung ben√∂tigen.  In diesem Fall ist es logisch, die Typen, die eine <code>string</code> umschlie√üen, geringf√ºgig zu aktualisieren: </p><br><ul><li>  Hinzuf√ºgen einer Implementierung einer Schnittstelle der Formularschnittstelle <code>interface IValueGet&lt;TValue&gt;{ TValue Wrapped { get; } }</code>  <code>interface IValueGet&lt;TValue&gt;{ TValue Wrapped { get; } }</code> .  In diesem Fall k√∂nnen wir in der √úbersetzungsschicht in SQL den Wert direkt abrufen </li><li>  Anstatt eine Reihe von mehr oder weniger identischen Typen im Code zu erstellen, k√∂nnen Sie einen abstrakten Vorfahren erstellen und den Rest davon erben.  Das Ergebnis ist ein Code der Form: </li></ul><br><pre> <code class="plaintext hljs">interface IValueGet&lt;TValue&gt; { TValue Wrapped { get; } } abstract class BaseWrapper : IValueGet&lt;TValue&gt; { protected BaseWrapper(TValue initialValue) { Wrapped = initialValue; } public TValue Wrapped { get; private set; } } sealed class Name : BaseWrapper&lt;string&gt; { public Name(string value) :base(value) { /*no necessary validations*/ } } sealed class UserId : BaseWrapper&lt;int&gt; { public UserId(int id) :base(id) { /*no necessary validations*/ } }</code> </pre> <br><h1 id="proizvoditelnost">  Leistung </h1><br><p>  Wenn Sie √ºber das Erstellen einer gro√üen Anzahl von Typen sprechen, k√∂nnen Sie h√§ufig zwei dialektische Argumente treffen: </p><br><ul><li>  Je mehr Typen, Verschachtelung und il-Code vorhanden sind, desto langsamer ist die Software, da es f√ºr jit schwieriger ist, das Programm zu optimieren.  Daher f√ºhrt diese Art der strengen Eingabe zu ernsthaften Bremsen im Projekt. </li><li>  Je mehr Wrapper, desto mehr Speicherplatz verbraucht die Anwendung.  Das Hinzuf√ºgen von Wrappern erh√∂ht daher die RAM-Anforderungen erheblich. </li></ul><br><p>  Genau genommen werden beide Argumente jedoch oft ohne Fakten vorgebracht: </p><br><ul><li>  Tats√§chlich belegen in den meisten Anwendungen auf demselben Java Zeichenfolgen (und Bytearrays) den Hauptspeicher.  Das hei√üt, das Erstellen von Wrappern ist f√ºr den Endbenutzer im Allgemeinen unwahrscheinlich.  Aufgrund dieser Art der Eingabe erhalten wir jedoch ein wichtiges Plus: Bei der Analyse eines Speicherauszugs k√∂nnen Sie bewerten, welchen Beitrag jeder Ihrer Typen zum Speicher leistet.  Schlie√ülich sehen Sie nicht nur eine anonyme Liste von Zeilen, die √ºber das Projekt verteilt sind.  Im Gegenteil, wir k√∂nnen verstehen, welche Arten von Objekten gr√∂√üer sind.  Aufgrund der Tatsache, dass nur Wrapper Zeichenfolgen und andere massive Objekte enthalten, ist es f√ºr Sie einfacher zu verstehen, welchen Beitrag jeder einzelne Wrapper-Typ zum gemeinsam genutzten Speicher leistet. </li><li>  Das Argument der JIT-Optimierung ist teilweise richtig, aber nicht vollst√§ndig.  In der Tat beginnt Ihre Software aufgrund der strengen Eingabe, zahlreiche √úberpr√ºfungen am Eingang der Funktionen zu beseitigen.  Alle Ihre Modelle werden auf ihre Eignung √ºberpr√ºft.  Im allgemeinen Fall haben Sie also weniger √úberpr√ºfungen (es reicht aus, einfach den richtigen Typ zu ben√∂tigen).  Aufgrund der Tatsache, dass √úberpr√ºfungen an den Konstruktor √ºbertragen und nicht durch Code verschmiert werden, ist es au√üerdem einfacher zu bestimmen, welche von ihnen wirklich Zeit ben√∂tigen. </li><li>  Leider kann ich in diesem Artikel keinen vollst√§ndigen Leistungstest geben, der das Projekt mit einer gro√üen Anzahl von Mikrotypen und mit der klassischen Entwicklung vergleicht und nur <code>int</code> , <code>string</code> und andere primitive Typen verwendet.  Der Hauptgrund ist, dass Sie daf√ºr zuerst ein typisches fett gedrucktes Projekt f√ºr den Test erstellen und dann begr√ºnden m√ºssen, dass dieses bestimmte Projekt ein typisches ist.  Und mit dem zweiten Punkt ist alles kompliziert, da die Projekte im wirklichen Leben wirklich anders sind.  Es wird jedoch ziemlich seltsam sein, synthetische Tests durchzuf√ºhren, da, wie ich bereits sagte, die Erstellung von Mikrotypobjekten in Unternehmensanwendungen nach meinen Messungen immer vernachl√§ssigbare Ressourcen hinterlie√ü (auf der Ebene des Messfehlers). </li></ul><br><h2 id="kak-mozhno-optimizirovat-kod-sostoyaschiy-iz-bolshogo-chisla-podobnyh-mikrotipov">  Wie k√∂nnen Sie einen Code optimieren, der aus einer gro√üen Anzahl solcher Mikrotypen besteht? </h2><br><p>  <strong>Wichtig: Sie</strong> sollten sich mit solchen Optimierungen nur befassen, wenn Sie garantierte Fakten erhalten, dass es Mikrotypen sind, die die Anwendung verlangsamen.  Nach meiner Erfahrung ist eine solche Situation eher unm√∂glich.  Mit einer h√∂heren Wahrscheinlichkeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verlangsamt</a> Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">derselbe Logger</a> , da jeder Vorgang auf ein Flush auf die Festplatte wartet (auf dem Computer des Entwicklers mit M.2-SSD war alles akzeptabel, aber ein Benutzer mit einer alten Festplatte sieht v√∂llig andere Ergebnisse). </p><br><p>  Die Tricks selbst: </p><br><ul><li>  Verwenden Sie aussagekr√§ftige Typen anstelle von Referenztypen.  Dies kann n√ºtzlich sein, wenn Wrapper auch mit signifikanten Typen arbeitet, was bedeutet, dass Sie theoretisch alle erforderlichen Informationen durch den Stapel leiten k√∂nnen.  Es sollte jedoch beachtet werden, dass die Beschleunigung nur dann erfolgt, wenn Ihr Code gerade aufgrund von Mikrotypen wirklich unter h√§ufigem GC leidet. <br><ul><li>  <code>struct</code> in .Net kann h√§ufiges Boxen / Unboxing verursachen.  Gleichzeitig ben√∂tigen solche Strukturen m√∂glicherweise mehr Speicher in <code>Dictionary</code> / <code>Map</code> Sammlungen (da Arrays mit einem Rand versehen sind). </li><li>  <code>inline</code> Typen von Kotlin / Scala sind nur begrenzt anwendbar.  Beispielsweise k√∂nnen Sie nicht mehrere Felder darin speichern (was manchmal n√ºtzlich sein kann, um den <code>ToString</code> / <code>GetHashCode</code> Wert zwischenzuspeichern). </li><li>  Eine Reihe von Optimierern kann Speicher auf dem Stapel zuweisen.  Insbesondere .Net <a href="">tut dies f√ºr kleine tempor√§re Objekte</a> , und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GraalVM in Java kann</a> ein Objekt auf dem Stapel zuweisen, es dann aber auf den Heap kopieren, wenn es zur√ºckgegeben werden musste (geeignet f√ºr Code, der reich an Bedingungen ist). </li></ul></li><li>  Verwenden Sie die Internierung von Objekten (dh versuchen Sie, vorgefertigte, vorgefertigte Objekte zu nehmen). <br><ul><li>  Wenn der Konstruktor ein Argument hat, k√∂nnen Sie einfach einen Cache erstellen, in dem der Schl√ºssel dieses Argument ist und der Wert das zuvor erstellte Objekt ist.  Wenn die Vielfalt der Objekte recht gering ist, k√∂nnen Sie die vorgefertigten Objekte einfach wiederverwenden. </li><li>  Wenn ein Objekt mehrere Argumente hat, k√∂nnen Sie einfach ein neues Objekt erstellen und dann √ºberpr√ºfen, ob es sich im Cache befindet.  Wenn es eine √§hnliche gibt, ist es besser, die bereits erstellte zur√ºckzugeben. </li><li>  Ein solches Schema verlangsamt die Arbeit der Designer, da <code>Equals</code> / <code>GetHashCode</code> f√ºr alle Argumente <code>GetHashCode</code> muss.  Es beschleunigt jedoch auch zuk√ºnftige Vergleiche von Objekten, wenn Sie den Wert des Hashs zwischenspeichern, da in diesem Fall die Objekte unterschiedlich sind, wenn sie unterschiedlich sind.  Und identische Objekte haben oft eine Verkn√ºpfung. </li><li>  Diese Optimierung beschleunigt jedoch das Programm aufgrund des schnelleren <code>GetHashCode</code> / <code>Equals</code> (siehe Abschnitt oben).  Au√üerdem sinkt die Lebensdauer neuer Objekte (die sich jedoch im Cache befinden) dramatisch, sodass sie nur in die Generation 0 gelangen. </li></ul></li><li>  √úberpr√ºfen Sie beim Erstellen neuer Objekte die Eingabeparameter und passen Sie sie nicht an.  Trotz der Tatsache, dass dieser Rat h√§ufig im Abschnitt √ºber den Codierungsstil enthalten ist, k√∂nnen Sie damit die Effektivit√§t des Programms steigern.  Wenn f√ºr Ihr Objekt beispielsweise eine Zeichenfolge mit nur GROSSBUCHSTABEN erforderlich ist, werden h√§ufig zwei Ans√§tze verwendet, um zu √ºberpr√ºfen: entweder <code>ToUpperInvariant</code> aus dem Argument <code>ToUpperInvariant</code> oder in einer Schleife √ºberpr√ºfen, ob alle Buchstaben gro√ü sind.  Im ersten Fall wird garantiert eine neue Zeile erstellt, im zweiten Fall wird ein maximaler Iterator erstellt.  Infolgedessen sparen Sie Speicherplatz (in beiden F√§llen wird jedoch jedes Zeichen weiterhin √ºberpr√ºft, sodass die Leistung nur im Kontext einer selteneren Speicherbereinigung erh√∂ht wird). </li></ul><br><h1 id="vyvod">  Fazit </h1><br><p>  Ich werde noch einmal den wichtigen Punkt aus dem Titel wiederholen: Alle im Artikel beschriebenen Dinge sind in gro√üen Projekten sinnvoll, die seit Jahren entwickelt und verwendet werden.  In F√§llen, in denen es sinnvoll ist, die Supportkosten und die Kosten f√ºr das Hinzuf√ºgen neuer Funktionen zu senken.  In anderen F√§llen ist es oft am sinnvollsten, ein Produkt so schnell wie m√∂glich herzustellen, ohne sich um Tests, Modelle und ‚Äûguten Code‚Äú zu k√ºmmern. </p><br><p>  F√ºr langfristige Projekte ist es jedoch sinnvoll, die strengste Typisierung zu verwenden, wobei wir im Modell genau beschreiben k√∂nnen, welche Werte im Prinzip m√∂glich sind. </p><br><p>  Wenn Ihr Service manchmal ein nicht funktionierendes Ergebnis zur√ºckgeben kann, dr√ºcken Sie es im Modell aus und zeigen Sie es dem Entwickler explizit.  F√ºgen Sie nicht tausend Flags mit Beschreibungen in der Dokumentation hinzu. </p><br><p>  Wenn Ihre Typen im Programm identisch sein k√∂nnen, sie sich jedoch im Wesentlichen im Gesch√§ft unterscheiden, definieren Sie sie genau als unterschiedlich.  Mischen Sie sie nicht, auch wenn die Arten ihrer Felder gleich sind. </p><br><p>  Wenn Sie Fragen zur Produktivit√§t haben, wenden Sie die wissenschaftliche Methode an und machen Sie einen Test (oder bitten Sie eine unabh√§ngige Person, dies alles zu √ºberpr√ºfen).  In diesem Szenario beschleunigen Sie das Programm und verschwenden nicht nur die Zeit des Teams.  Das Gegenteil ist jedoch auch der Fall: Wenn der Verdacht besteht, dass Ihr Programm oder Ihre Bibliothek langsam ist, f√ºhren Sie einen Test durch.  Sie m√ºssen nicht sagen, dass alles in Ordnung ist. Zeigen Sie es einfach in Zahlen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462655/">https://habr.com/ru/post/de462655/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462635/index.html">Quanten oder hin und zur√ºck: Ein neuer Algorithmus zur Untersuchung des quantenklassischen √úbergangs</a></li>
<li><a href="../de462641/index.html">52 Merkmale des idealen Produktmanagers</a></li>
<li><a href="../de462643/index.html">Bestimmen Sie mithilfe von Python voneinander abh√§ngige Personen an Bord von Strukturen</a></li>
<li><a href="../de462649/index.html"># 18 Mosdroid Argon - Bericht</a></li>
<li><a href="../de462653/index.html">LTE als Symbol der Unabh√§ngigkeit</a></li>
<li><a href="../de462657/index.html">SkyRC B6 Nano Ladeger√§t Bewertung & Test</a></li>
<li><a href="../de462659/index.html">Erste Schritte mit dem PVS-Studio Static Analyzer f√ºr die C ++ - Entwicklung unter Linux</a></li>
<li><a href="../de462661/index.html">Kenntnis des statischen Analysators PVS-Studio bei der Entwicklung von C ++ - Programmen unter Linux</a></li>
<li><a href="../de462663/index.html">Schwimmen, tanzen (!) Und rocken: Welche Aktivit√§ten wollen igrodely</a></li>
<li><a href="../de462665/index.html">Helmsicherheit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>