<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§úüèº üé± ‚ôàÔ∏è Engenharia reversa do emulador NES no jogo para GameCube üå∂Ô∏è üßöüèª üëåüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Enquanto procurava maneiras de ativar os menus do desenvolvedor deixados em Animal Crossing, incluindo o menu de sele√ß√£o de jogos para o emulador NES,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Engenharia reversa do emulador NES no jogo para GameCube</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417117/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/dc8/2e4/499dc82e445ffd6bfd607d4f834ccd5a.png" alt="imagem"></div><br>  Enquanto procurava maneiras de ativar os menus do desenvolvedor deixados em Animal Crossing, incluindo o menu de sele√ß√£o de jogos para o emulador NES, encontrei um recurso interessante que existe no jogo original e estava constantemente ativo, mas nunca foi usado pela Nintendo. <br><br>  Al√©m dos jogos NES / Famicom no jogo, voc√™ pode baixar novos jogos NES a partir de um cart√£o de mem√≥ria. <br><br>  Tamb√©m consegui encontrar uma maneira de usar esse carregador de inicializa√ß√£o da ROM para corrigir meu c√≥digo e dados no jogo, o que permite executar o c√≥digo atrav√©s de um cart√£o de mem√≥ria. <br><br><h2>  Introdu√ß√£o - Objetos do Console NES </h2><br>  Jogos comuns de NES, que podem ser obtidos na Animal Crossing, s√£o m√≥veis separados na forma de um console da NES com um cartucho sobre ele. <br><br>  Tendo localizado este objeto em sua casa e interagindo com ele, voc√™ pode executar este √∫nico jogo.  A imagem abaixo mostra Excitebike e Golf. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40e/e33/409/40ee334095bd1151c3c968a84f8cf92b.png"></div><a name="habracut"></a><br>  H√° tamb√©m um objeto comum do NES Console no qual n√£o h√° jogos internos.  Ele pode ser comprado na Redd e, √†s vezes, obtido atrav√©s de eventos aleat√≥rios, por exemplo, lendo no quadro de avisos da cidade que o console est√° enterrado em um ponto aleat√≥rio da cidade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f41/d20/687/f41d20687aed7d6a4d044a5a5d084045.png"></div><br>  Esse objeto se parece com um console NES no qual n√£o h√° cartuchos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35c/010/9a3/35c0109a32b31deeb202280773f363a0.png"></div><br>  O problema com esse objeto √© que ele era considerado imposs√≠vel de jogar.  Toda vez que voc√™ interage com ele, voc√™ v√™ uma mensagem dizendo que n√£o possui um software de jogo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/6d3/3b8/a9e6d33b8e039a2f17c12fd134cf0308.png"></div><br>  Acontece que este objeto est√° realmente tentando digitalizar o cart√£o de mem√≥ria em busca de arquivos especialmente projetados contendo imagens de ROM para o NES!  O emulador NES usado para executar jogos incorporados parece ser o emulador NES padr√£o completo para o GameCube e √© capaz de iniciar a maioria dos jogos. <br><br>  Antes de demonstrar esses recursos, explicarei o processo de engenharia reversa deles. <br><br><h2>  Pesquisar ROM bootloader no cart√£o de mem√≥ria </h2><br><h3>  Estamos √† procura de um menu de desenvolvedor </h3><br>  Inicialmente, eu queria encontrar um c√≥digo que ative v√°rios menus do desenvolvedor, como o menu de sele√ß√£o de mapa ou o menu de sele√ß√£o de jogos do emulador NES.  O menu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Forest Map Select</a> , gra√ßas ao qual voc√™ pode facilmente carregar instantaneamente diferentes locais do jogo, foi bastante simples de encontrar - procurei a linha FOREST MAP SELECT que aparece na parte superior da tela (pode ser vista em diferentes v√≠deos e capturas de tela na Internet ) <br><br>  No "FOREST MAP SELECT", h√° refer√™ncias cruzadas de dados para a fun√ß√£o <code>select_print_wait</code> , o que leva a v√°rias outras fun√ß√µes que tamb√©m t√™m o prefixo <code>select_*</code> , incluindo a fun√ß√£o <code>select_init</code> .  Acabaram sendo fun√ß√µes que controlam o menu de sele√ß√£o de mapa. <br><br>  A fun√ß√£o <code>select_init</code> leva a outra fun√ß√£o interessante chamada <code>game_get_next_game_dlftbl</code> .  Esta fun√ß√£o une todos os outros menus e ‚Äúcenas‚Äù que voc√™ pode executar: uma tela com o logotipo da Nintendo, a tela principal, o menu de sele√ß√£o de cart√µes, o menu do emulador NES (Famicom) e assim por diante.  Inicia no in√≠cio do procedimento principal do jogo, localiza qual fun√ß√£o de inicializa√ß√£o de cena deve ser executada e encontra sua entrada na estrutura de dados da tabela chamada <code>game_dlftbls</code> .  Esta tabela cont√©m links para as fun√ß√µes de processamento de v√°rias cenas, bem como alguns outros dados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d93/cbc/019/d93cbc0191a754e6bb566525f1a21666.png"></div><br>  Um estudo cuidadoso do primeiro bloco da fun√ß√£o mostrou que ela carrega a fun√ß√£o "next game init" e come√ßa a compar√°-la com uma s√©rie de fun√ß√µes init bem conhecidas: <br><br><ul><li> <code>first_game_init</code> </li> <li> <code>select_init</code> </li> <li> <code>play_init</code> </li> <li> <code>second_game_init</code> </li> <li> <code>trademark_init</code> </li> <li> <code>player_select_init</code> </li> <li> <code>save_menu_init</code> </li> <li> <code>famicom_emu_init</code> </li> <li> <code>prenmi_init</code> </li> </ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e6/785/bae/2e6785bae4c526f3acba034d4f7e4b2e.png"></div><br>  Um dos indicadores de fun√ß√£o que ele est√° procurando √© <code>famicom_emu_init</code> , respons√°vel pela execu√ß√£o do emulador NES / Famicom.  <code>game_get_next_game_init</code> resultado <code>game_get_next_game_init</code> a <code>famicom_emu_init</code> ou <code>select_init</code> no depurador Dolphin, consegui exibir menus especiais.  O pr√≥ximo passo √© determinar como esses ponteiros s√£o configurados da maneira normal durante a execu√ß√£o do programa.  A √∫nica coisa que a fun√ß√£o <code>game_get_next_game_init</code> √© carregar o valor no deslocamento <code>0xC</code> primeiro argumento no <code>game_get_next_game_dlftbl</code> . <br><br>  Manter o controle desses valores definidos em v√°rias estruturas de dados foi um pouco chato, ent√£o irei direto ao n√∫cleo.  A coisa mais importante que encontrei: <br><br><ul><li>  Quando o jogo come√ßa da maneira usual, ele executa a seguinte sequ√™ncia de a√ß√µes: <br><ul><li> <code>first_game_init</code> </li> <li> <code>second_game_init</code> </li> <li> <code>trademark_init</code> </li> <li> <code>play_init</code> </li> </ul></li><li>  <code>player_select_init</code> define o pr√≥ximo init como <code>select_init</code> .  Essa tela deve permitir que voc√™ selecione um jogador imediatamente ap√≥s escolher uma carta, mas parece que ela n√£o funciona corretamente. </li></ul><br>  Tamb√©m encontrei uma fun√ß√£o sem nome que define a fun√ß√£o init do emulador, mas n√£o encontrei nada que defina a fun√ß√£o init com o valor init do jogador ou da escolha do mapa. <br><br>  Nesse ponto, percebi que tinha outro problema est√∫pido na maneira como carregava nomes de fun√ß√µes no IDA: devido √† express√£o regular usada para cortar linhas no arquivo de s√≠mbolo de depura√ß√£o, perdi todos os nomes de fun√ß√µes come√ßando com uma letra mai√∫scula .  A fun√ß√£o que o <code>famicom_emu_init</code> configurou parecia transi√ß√µes entre cenas e, √© claro, foi chamada de <code>Game_play_fbdemo_wipe_proc</code> . <br><br>  <code>Game_play_fbdemo_wipe_proc</code> lida com transi√ß√µes entre cenas, como apagamentos de tela e apag√µes. <br><br>  Sob certas condi√ß√µes, a transi√ß√£o da tela foi realizada da jogabilidade usual para a exibi√ß√£o do emulador.  Foi ele quem definiu a fun√ß√£o init do emulador. <br><br><h3>  Manipulando objetos do console </h3><br>  Na verdade, manipuladores de objetos de m√≥veis para consoles NES fazem com que o manipulador de transi√ß√£o de tela mude para o emulador.  Quando um jogador interage com um dos consoles, <code>aMR_FamicomEmuCommonMove</code> √© <code>aMR_FamicomEmuCommonMove</code> . <br><br>  Ao chamar a fun√ß√£o, <code>r6</code> cont√©m o valor do √≠ndice correspondente aos n√∫meros nos nomes dos arquivos do jogo NES em <code>famicom.arc</code> : <br><br><ul><li> <code>01_nes_cluclu3.bin.szs</code> </li> <li> <code>02_usa_balloon.nes.szs</code> </li> <li> <code>03_nes_donkey1_3.bin.szs</code> </li> <li> <code>04_usa_jr_math.nes.szs</code> </li> <li> <code>05_pinball_1.nes.szs</code> </li> <li> <code>06_nes_tennis3.bin.szs</code> </li> <li> <code>07_usa_golf.nes.szs</code> </li> <li> <code>08_punch_wh.nes.szs</code> </li> <li> <code>09_usa_baseball_1.nes.szs</code> </li> <li> <code>10_cluclu_1.qd.szs</code> </li> <li> <code>11_usa_donkey3.nes.szs</code> </li> <li> <code>12_donkeyjr_1.nes.szs</code> </li> <li> <code>13_soccer.nes.szs</code> </li> <li> <code>14_exbike.nes.szs</code> </li> <li> <code>15_usa_wario.nes.szs</code> </li> <li> <code>16_usa_icecl.nes.szs</code> </li> <li> <code>17_nes_mario1_2.bin.szs</code> </li> <li> <code>18_smario_0.nes.szs</code> </li> <li> <code>19_usa_zelda1_1.nes.szs</code> </li> </ul><br>  ( <code>.arc</code> √© um formato de arquivo propriet√°rio). <br><br>  Quando <code>r6</code> n√£o <code>r6</code> igual a zero, √© passado na chamada <code>aMR_RequestStartEmu</code> .  Nesse caso, a transi√ß√£o para o emulador √© acionada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f78/268/1d7/f782681d712b4098ad6f9269cf2df5cc.png"></div><br>  No entanto, se <code>r6</code> for zero, a fun√ß√£o <code>aMR_RequestStartEmu_MemoryC</code> ser√° chamada.  Definindo o valor no depurador como 0, recebi a mensagem "N√£o tenho nenhum software".  N√£o lembrei imediatamente que precisava verificar o objeto Console do NES para garantir que ele redefinisse o valor <code>r6</code> , mas o √≠ndice zero √© usado para o objeto do console sem cartucho. <br><br>  Embora <code>aMR_RequestStartEmu</code> simplesmente armazene o valor do √≠ndice em algum tipo de estrutura de dados, <code>aMR_RequestStartEmu_MemoryC</code> executa opera√ß√µes muito mais complexas ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d23/844/831/d23844831e1e9f9b8ef5b6a4306948ab.png"></div><br>  Esse terceiro bloco de c√≥digo chama <code>aMR_GetCardFamicomCount</code> e verifica um resultado diferente de zero, caso contr√°rio, ignora a maioria das coisas interessantes no lado esquerdo do gr√°fico de fun√ß√µes. <br><br>  <code>aMR_GetCardFamicomCount</code> chama <code>famicom_get_disksystem_titles</code> , que ent√£o chama <code>memcard_game_list</code> , e aqui tudo se torna muito interessante. <br><br>  <code>memcard_game_list</code> monta o cart√£o de mem√≥ria e come√ßa a circular no ciclo de grava√ß√£o do arquivo, verificando cada um de alguns valores.  Ao rastrear a fun√ß√£o no depurador, eu pude entender que ele estava comparando os valores com cada um dos meus arquivos no cart√£o de mem√≥ria. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da1/e17/dd1/da1e17dd1b1acd6552eeeabaedc586fb.png"></div><br>  A fun√ß√£o decide se deve ou n√£o fazer o download do arquivo, dependendo dos resultados da verifica√ß√£o de v√°rias linhas.  Primeiro, verifica a presen√ßa das linhas "GAFE" e "01", que s√£o os identificadores do jogo e da empresa.  01 significa Nintendo, GAFE significa Animal Crossing.  Eu acho que significa GameCube Animal Forest English. <br><br>  Ela ent√£o verifica as linhas "DobutsunomoriP_F_" e "SAVE".  Nesse caso, a primeira linha deve corresponder, mas n√£o a segunda.  Descobriu-se que "DobutsunomoriP_F_SAVE" √© o nome do arquivo que armazena os dados dos jogos incorporados para o NES.  Portanto, todos os arquivos, exceto este, ser√£o carregados com o prefixo ‚ÄúDobutsunomoriP_F_‚Äù. <br><br>  Usando o depurador Dolphin para ignorar as compara√ß√µes de seq√º√™ncias de caracteres com ‚ÄúSAVE‚Äù e fazendo o truque do jogo para acreditar que meu arquivo ‚ÄúSAVE‚Äù pode ser baixado com seguran√ßa, cheguei a este menu depois de usar o console NES: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d4/1d2/696/1d41d26963aeaf11450155f1d7d53085.png"></div><br>  Respondi "Sim" e tentei carregar o arquivo salvo como um jogo, depois do qual vi pela primeira vez a tela de travamento do jogo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41e/662/4cc/41e6624cc68fe28e897cd1803ba1a39a.png"></div><br>  √ìtimo!  Agora eu sei que ela est√° realmente tentando baixar jogos de um cart√£o de mem√≥ria e posso come√ßar a analisar o formato dos arquivos salvos para ver se uma ROM real pode ser baixada. <br><br>  A primeira coisa que tentei fazer foi tentar descobrir onde o nome do jogo √© lido no arquivo do cart√£o de mem√≥ria.  Pesquisando a linha "FEFSC" que estava presente na mensagem "Deseja reproduzir &lt;name&gt;?", Encontrei o deslocamento em que foi lido no arquivo: <code>0x642</code> .  Copiei o arquivo salvo, alterei o nome do arquivo para ‚ÄúDobutsunomoriP_F_TEST‚Äù, alterei os bytes no deslocamento <code>0x642</code> para ‚ÄúTESTING‚Äù e importei o salvamento alterado, ap√≥s o qual o nome que eu precisava aparecia no menu. <br><br>  Depois de adicionar mais alguns arquivos neste formato, mais algumas op√ß√µes apareceram no menu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/ca3/668/235ca3668ae0a02ad2609847bdf193c0.png"></div><br><h3>  Download da ROM </h3><br>  Se <code>aMR_GetCardFamicomCount</code> retornado diferente de zero, a mem√≥ria √© alocada no heap, <code>famicom_get_disksystem_titles</code> √© chamado diretamente <code>famicom_get_disksystem_titles</code> , ap√≥s o qual um monte de compensa√ß√µes aleat√≥rias s√£o especificadas na estrutura de dados.  Em vez de decifrar onde esses valores ser√£o lidos, comecei a estudar a lista de fun√ß√µes <code>famicom</code> . <br><br>  Acabou que eu precisava de <code>famicom_rom_load</code> .  Ele controla o carregamento da ROM, a partir de um cart√£o de mem√≥ria ou de recursos internos do jogo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/999/22b/462/99922b462892ef544d45e849da1c54a5.png"></div><br>  A coisa mais importante neste bloco de "inicializa√ß√£o a partir do cart√£o de mem√≥ria" √© que ele chama <br>  <code>memcard_game_load</code> .  Ela monta o arquivo no cart√£o de mem√≥ria novamente, l√™ e analisa.  √â aqui que as op√ß√µes mais importantes de formato de arquivo se tornam aparentes. <br><br><h4>  Valor de soma de verifica√ß√£o </h4><br>  A primeira coisa que acontece ap√≥s o upload do arquivo √© o c√°lculo da soma de verifica√ß√£o.  A fun√ß√£o <code>calcSum</code> √© <code>calcSum</code> , que √© um algoritmo muito simples que soma os valores de todos os bytes nos dados do cart√£o de mem√≥ria.  Os oito bits inferiores do resultado devem ser zero.  Ou seja, para passar nessa verifica√ß√£o, voc√™ precisa somar os valores de todos os bytes no arquivo de origem, calcular o valor que precisa ser adicionado para que os oito bits inferiores se tornem zero e atribuir esse valor ao byte da soma de verifica√ß√£o no arquivo. <br><br>  Se a verifica√ß√£o falhar, voc√™ receber√° uma mensagem sobre a impossibilidade de ler corretamente o cart√£o de mem√≥ria e nada acontece.  Durante a depura√ß√£o, tudo o que preciso fazer √© pular essa verifica√ß√£o. <br><br><h4>  Copiar ROM </h4><br>  Perto do final de <code>memcard_game_load</code> , outra coisa interessante acontece.  Existem v√°rios blocos de c√≥digo mais interessantes entre ele e a soma de verifica√ß√£o, mas nenhum deles leva a ramifica√ß√µes que ignoram a execu√ß√£o desse comportamento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc8/376/55d/cc837655d2ec1b207b0f7420db856a1e.png"></div><br>  Se um determinado valor inteiro de 16 bits lido no cart√£o de mem√≥ria n√£o for igual a zero, √© chamada uma fun√ß√£o que verifica o cabe√ßalho de compacta√ß√£o no buffer.  Ele verifica os formatos propriet√°rios de compacta√ß√£o da Nintendo, observando o in√≠cio do buffer Yay0 ou Yaz0.  Se uma dessas linhas for encontrada, a fun√ß√£o desempacotar √© chamada.  Caso contr√°rio, √© executada uma fun√ß√£o de c√≥pia simples.  De qualquer forma, depois disso, uma vari√°vel chamada <code>nesinfo_data_size</code> . <br><br>  Outra dica de contexto aqui √© que os arquivos ROM para jogos NES incorporados usam a compacta√ß√£o Yaz0, e essa linha est√° presente nos cabe√ßalhos de seus arquivos. <br><br>  Depois de observar o valor verificado como zero e o buffer passado para as fun√ß√µes de verifica√ß√£o de compacta√ß√£o, descobri rapidamente de onde o jogo estava sendo lido no arquivo do cart√£o de mem√≥ria.  A verifica√ß√£o zero √© realizada para parte do buffer de 32 bytes copiado do deslocamento <code>0x640</code> no arquivo, que provavelmente √© o cabe√ßalho da ROM.  Esta fun√ß√£o tamb√©m verifica outras partes do arquivo, e √© nelas que o nome do jogo est√° localizado (come√ßando com o terceiro byte do cabe√ßalho). <br><br>  No caminho de execu√ß√£o de c√≥digo que encontrei, o buffer da ROM est√° localizado imediatamente ap√≥s esse buffer de cabe√ßalho de 32 bytes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c2/01f/34c/7c201f34c3b9427c288654d487acbcbf.png"></div><br>  Esta informa√ß√£o √© suficiente para tentar criar um arquivo ROM funcional.  Eu apenas peguei um dos outros arquivos salvos do Animal Crossing e editei-o em um editor hexadecimal para substituir o nome do arquivo por <code>DobutsunomoriP_F_TEST</code> e limpar todas as √°reas onde eu queria colar os dados. <br><br>  Para uma execu√ß√£o de teste, usei a ROM do jogo de pinball, que j√° est√° no jogo, e inseri seu conte√∫do ap√≥s o cabe√ßalho de 32 bytes.  Em vez de calcular o valor da soma de verifica√ß√£o, defino pontos de interrup√ß√£o para simplesmente ignorar o <code>calcSum</code> e tamb√©m observar os resultados de outras verifica√ß√µes que podem levar a uma ramifica√ß√£o que ignora o processo de inicializa√ß√£o da ROM. <br><br>  Por fim, importei o novo arquivo atrav√©s do gerenciador de cart√µes de mem√≥ria Dolphin, reiniciei o jogo e tentei iniciar o console. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/199/d08/799/199d087997375f8666284220e7ffcc62.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/be8/5f5/527be85f54ab8f37609047d323c6b442.png"></div><br>  Funcionou!  Havia alguns pequenos bugs gr√°ficos relacionados aos par√¢metros do Dolphin, que afetavam o modo gr√°fico usado pelo emulador NES, mas, em geral, o jogo teve um bom desempenho.  (Nas vers√µes mais recentes do Dolphin, ele deve funcionar por padr√£o.) <br><br>  Para garantir que outros jogos tamb√©m iniciem, tentei escrever v√°rias outras ROMs que n√£o estavam no jogo.  Os battletoads come√ßaram, mas pararam de funcionar ap√≥s o texto da tela inicial (ap√≥s outras configura√ß√µes, consegui torn√°-lo jog√°vel).  Mega Man, por outro lado, funcionou perfeitamente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/5a2/7da/9235a27da4d094a496a477cc24cd4846.png"></div><br>  Para aprender a gerar novos arquivos ROM que poderiam ser carregados sem a interven√ß√£o de depuradores, tive que come√ßar a escrever c√≥digo e entender melhor a an√°lise de formato de arquivo. <br><br><h3>  Formato de arquivo ROM externo </h3><br>  A parte mais importante da an√°lise de arquivos acontece em <code>memcard_game_load</code> .  Existem seis se√ß√µes principais de blocos de an√°lise de c√≥digo nesta fun√ß√£o: <br><br><ul><li>  Soma de verifica√ß√£o </li><li>  Salvar nome do arquivo </li><li>  Cabe√ßalho do arquivo ROM </li><li>  Buffer desconhecido copiado sem qualquer processamento </li><li>  Coment√°rio de texto, √≠cone e carregador de banner (para criar um novo arquivo salvo) </li><li>  Carregador de inicializa√ß√£o ROM </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/194/51e/f0019451e2d0070900f75c62cb83535a.png"></div><br><h4>  Soma de verifica√ß√£o </h4><br>  Os oito bits inferiores da soma de todos os valores de bytes no arquivo salvo devem ser zero.  Aqui est√° um c√≥digo Python simples que gera o byte de soma de verifica√ß√£o necess√°rio: <br><br><pre> <code class="python hljs">checksum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_data_tmp: checksum += byte_val checksum = checksum % (<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-comment"><span class="hljs-comment"># keep it 32 bit checkbyte = 256 - (checksum % 256) new_data_tmp[-1] = checkbyte</span></span></code> </pre> <br>  Provavelmente existe um local especial para armazenar o byte da soma de verifica√ß√£o, mas adicion√°-lo ao espa√ßo vazio no final do arquivo salvo funciona muito bem. <br><br><h4>  Nome do arquivo </h4><br>  Novamente, o nome do arquivo salvo deve come√ßar com "DobutsunomoriP_F_" e terminar com algo que n√£o contenha "SAVE".  Este nome de arquivo √© copiado algumas vezes e, em um caso, a letra "F" √© substitu√≠da por "S".  Este ser√° o nome dos arquivos salvos para o jogo NES ("DobutsunomoriP_S_NAME"). <br><br><h4>  Cabe√ßalho ROM </h4><br>  Uma c√≥pia direta do cabe√ßalho de 32 bytes √© carregada na mem√≥ria.  Alguns dos valores neste cabe√ßalho s√£o usados ‚Äã‚Äãpara determinar como lidar com as se√ß√µes subseq√ºentes.  Basicamente, esses s√£o alguns valores de tamanho de 16 bits e bits de par√¢metro compactados. <br><br>  Se voc√™ rastrear o ponteiro copiado pelo cabe√ßalho at√© o in√≠cio da fun√ß√£o e encontrar a posi√ß√£o de seu argumento, a assinatura da fun√ß√£o abaixo mostrar√° que ele realmente possui o tipo <code>MemcardGameHeader_t*</code> . <br><br><pre> <code class="python hljs">memcard_game_load(unsigned char *, int, unsigned char **, char *, char *, MemcardGameHeader_t *, unsigned char *, unsigned long, unsigned char *, unsigned long)</code> </pre> <br><h4>  Buffer desconhecido </h4><br>  Verifica o valor do tamanho de 16 bits no cabe√ßalho.  Se n√£o for igual a zero, o n√∫mero correspondente de bytes ser√° copiado diretamente do buffer do arquivo para um novo bloco de mem√≥ria alocada.  Isso move o ponteiro de dados no buffer do arquivo para que outras c√≥pias possam continuar na pr√≥xima se√ß√£o. <br><br><h4>  Banner, √≠cone e coment√°rio </h4><br>  Outro valor de tamanho √© verificado no cabe√ßalho e, se n√£o for igual a zero, a fun√ß√£o de verifica√ß√£o de compacta√ß√£o de arquivos √© chamada.  Se necess√°rio, o algoritmo de descompacta√ß√£o ser√° iniciado, ap√≥s o qual <code>SetupExternCommentImage</code> ser√° <code>SetupExternCommentImage</code> . <br><br>  Esta fun√ß√£o faz tr√™s coisas: ‚Äúcoment√°rio‚Äù, imagem e √≠cone do banner.  Para cada um deles, h√° um c√≥digo no cabe√ßalho da ROM mostrando como lidar com eles.  Existem as seguintes op√ß√µes: <br><br><ol><li>  Usar valor padr√£o </li><li>  Copie da se√ß√£o banner / √≠cone / coment√°rio no arquivo ROM </li><li>  Copiar do buffer alternativo </li></ol><br>  Os valores padr√£o do c√≥digo fazem com que o √≠cone ou banner seja carregado a partir do recurso em disco, e o nome do arquivo e do coment√°rio salvos (descri√ß√£o em texto do arquivo) recebe os valores "Animal Crossing" e "NES Cassette Save Data".  Aqui est√° o que parece: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/906/519/045/906519045718e74cf565c2983401692c.png"></div><br>  O segundo valor do c√≥digo simplesmente copia o nome do jogo do arquivo ROM (uma alternativa para "Animal Crossing") e, em seguida, tenta encontrar a string "] ROM" no coment√°rio do arquivo e substitui-a por "] SAVE".  Aparentemente, os arquivos que a Nintendo queria lan√ßar deveriam estar no formato dos nomes "Game Name [NES] ROM" ou algo semelhante. <br><br>  Para o √≠cone e o banner, o c√≥digo tenta determinar o formato da imagem, obter um valor de tamanho fixo correspondente a esse formato e copiar a imagem. <br><br>  No √∫ltimo valor de c√≥digo, o nome e a descri√ß√£o do arquivo s√£o copiados sem altera√ß√µes do buffer, e o √≠cone e o banner tamb√©m s√£o carregados do buffer alternativo. <br><br><h4>  ROM </h4><br>  Se voc√™ observar atentamente a captura de tela da <code>memcard_game_load</code> copiando ROM, poder√° ver que o valor de 16 bits verificado quanto √† igualdade a zero √© deslocado para a esquerda em 4 bits (multiplicado por 16) e, em seguida, √© usado como o tamanho da fun√ß√£o <code>memcpy</code> se a compacta√ß√£o n√£o for detectada.  Este √© outro valor de tamanho presente no cabe√ßalho. <br><br>  Se o tamanho n√£o for igual a zero, os dados da ROM ser√£o verificados quanto √† compacta√ß√£o e copiados. <br><br><h3>  Pesquisa desconhecida de buffer e bug </h3><br>  Embora o download de novas ROMs seja bastante curioso, a coisa mais interessante sobre esse carregador de ROM para mim foi que, de fato, essa √© a √∫nica parte do jogo que recebe entrada do usu√°rio de tamanho vari√°vel e a copia para diferentes locais de mem√≥ria.  Quase todo o resto usa buffers de tamanho constante.  Coisas como nomes e textos de letras podem parecer diferentes em tamanho, mas essencialmente o espa√ßo vazio √© simplesmente preenchido com espa√ßos.  As seq√º√™ncias terminadas em zero s√£o usadas com pouca frequ√™ncia, evitando erros comuns de corrup√ß√£o de mem√≥ria, como usar <code>strcpy</code> com um buffer muito pequeno para copiar as seq√º√™ncias. <br><br>  Eu estava muito interessado na possibilidade de encontrar uma explora√ß√£o do jogo com base em arquivos salvos, e parecia que essa era a melhor op√ß√£o. <br><br>  A maioria das opera√ß√µes de arquivo ROM descritas acima usam c√≥pias de tamanho constante, com exce√ß√£o de um buffer desconhecido e dados da ROM.  Infelizmente, o c√≥digo que processa esse buffer aloca exatamente o espa√ßo necess√°rio para copi√°-lo, para que n√£o haja excesso e a configura√ß√£o de tamanhos de arquivo ROM muito grandes n√£o foi muito √∫til. <br><br>  Mas eu ainda queria saber o que acontece com esse buffer, que √© copiado sem nenhum processamento. <br><br><h4>  Manipuladores de informa√ß√µes da NES </h4><br>  Voltei para <code>famicom_rom_load</code> .  Ap√≥s carregar a ROM de um cart√£o ou disco de mem√≥ria, v√°rias fun√ß√µes s√£o chamadas: <br><br><ul><li> <code>nesinfo_tag_process1</code> </li> <li> <code>nesinfo_tag_process2</code> </li> <li> <code>nesinfo_tag_process3</code> </li> </ul><br>  Depois de rastrear o local em que o buffer desconhecido √© copiado, certifiquei-me de que esta tarefa seja executada por essas fun√ß√µes.  Eles come√ßam com uma chamada para <code>nesinfo_next_tag</code> , que executa um algoritmo simples: <br><br><ul><li>  Verifica se o ponteiro especificado <code>nesinfo_tags_end</code> ponteiro em <code>nesinfo_tags_end</code> .  Se for menor que <code>nesinfo_tags_end</code> ou <code>nesinfo_tags_end</code> for zero, <code>nesinfo_tags_end</code> a presen√ßa da string "END" no cabe√ßalho do ponteiro. <br><br><ul><li>  Se "END" for atingido ou o ponteiro tiver subido para ou acima de <code>nesinfo_tags_end</code> , a fun√ß√£o retornar√° nulo. </li><li>  Caso contr√°rio, o byte no deslocamento <code>0x3</code> ponteiro √© adicionado a 4 e ao ponteiro atual, ap√≥s o qual o valor √© retornado. </li></ul></li></ul><br>  Isso nos diz que existe algum tipo de formato de etiqueta de um nome de tr√™s letras, valor do tamanho dos dados e dos pr√≥prios dados.  O resultado √© um ponteiro para o pr√≥ximo r√≥tulo, porque o r√≥tulo atual √© ignorado ( <code>cur_ptr + 4</code> ignora o nome de tr√™s letras e um byte e <code>size_byte</code> ignora os dados). <br><br>  Se o resultado n√£o for zero, a fun√ß√£o de processamento de r√≥tulo realiza uma s√©rie de compara√ß√µes de strings para descobrir qual r√≥tulo precisa ser processado.  Alguns dos nomes de r√≥tulos marcados em <code>nesinfo_tag_process1</code> : VEQ, VNE, GID, GNO, BBR e QDS. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f1/094/08b/0f109408b8d01ec8cf4522445463e378.png"></div><br>  Se uma correspond√™ncia de etiqueta for encontrada, algum c√≥digo do manipulador ser√° executado.  Alguns manipuladores n√£o fazem nada al√©m de exibir um r√≥tulo na mensagem de depura√ß√£o.  Outros t√™m manipuladores mais complexos.  Ap√≥s o processamento do r√≥tulo, a fun√ß√£o tenta obter o pr√≥ximo r√≥tulo e continuar o processamento. <br><br>  Felizmente, existem muitas mensagens detalhadas de depura√ß√£o que s√£o exibidas quando as tags s√£o detectadas.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eles s√£o todos em japon√™s, portanto devem ser decodificados a partir do Shift-JIS e traduzidos. Por exemplo, uma mensagem para o QDS pode ler ‚ÄúCarregando uma √°rea de economia de disco‚Äù ou ‚ÄúComo esta √© a primeira execu√ß√£o, crie uma √°rea de economia de disco‚Äù. As mensagens para o BBR dizem "carregando um backup da bateria" ou "como este √© o primeiro in√≠cio, realizamos uma limpeza". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esses dois c√≥digos tamb√©m carregam alguns valores da se√ß√£o de dados de seus r√≥tulos e os utilizam para calcular o deslocamento nos dados da ROM, ap√≥s o qual eles executam opera√ß√µes de c√≥pia. Obviamente, eles s√£o respons√°veis ‚Äã‚Äãpor determinar as partes na mem√≥ria ROM associadas √† preserva√ß√£o do estado.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√° tamb√©m uma marca "HSC" com uma mensagem de depura√ß√£o dizendo que est√° processando registros de pontos. </font><font style="vertical-align: inherit;">Ela obt√©m um deslocamento na ROM de seus dados de tag, bem como o valor do registro de pontua√ß√£o original. </font><font style="vertical-align: inherit;">Essas marcas podem ser usadas para indicar um lugar na mem√≥ria do jogo NES para armazenar recordes, possivelmente para salv√°-los e restaur√°-los no futuro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essas tags criam um sistema de download de metadados de ROM bastante complexo. </font><font style="vertical-align: inherit;">Al√©m disso, muitos deles levam a chamadas com </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base nos valores transmitidos nos dados da etiqueta.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ca√ßa de insetos </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maioria das tags que levam √† manipula√ß√£o de mem√≥ria n√£o √© muito √∫til para explora√ß√µes, porque todas elas t√™m valores m√°ximos de deslocamento e tamanho especificados como n√∫meros inteiros de 16 bits. </font><font style="vertical-align: inherit;">Isso √© suficiente para trabalhar com o espa√ßo de endere√ßo do NES de 16 bits, mas n√£o o suficiente para gravar valores de destino √∫teis, como ponteiros para fun√ß√µes ou endere√ßos de retorno na pilha no espa√ßo de endere√ßo do GameCube de 32 bits. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, existem v√°rios casos em que os valores dos desvios de tamanho transmitidos </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podem exceder </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> QDS </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O QDS carrega um deslocamento de 24 bits de seus dados de tag, bem como um valor de tamanho de 16 bits. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O bom aqui √© que o deslocamento √© usado para calcular o endere√ßo de destino da opera√ß√£o de c√≥pia. O endere√ßo base do deslocamento √© o in√≠cio dos dados baixados, a origem da c√≥pia est√° no arquivo ROM do cart√£o de mem√≥ria e o tamanho √© definido pelo valor do tamanho de 16 bits da etiqueta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O valor de 24 bits possui um valor m√°ximo </font></font><code>0xFFFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que √© muito mais do que o necess√°rio para gravar fora dos dados ROM carregados. No entanto, existem alguns problemas ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O primeiro √© que, embora o valor m√°ximo do tamanho seja igual </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ele √© usado inicialmente para redefinir a parti√ß√£o de mem√≥ria. Se o valor do tamanho for muito alto (n√£o muito maior </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), isso redefinir√° a marca ‚ÄúQDS‚Äù no c√≥digo do jogo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E a√≠ est√° o problema, porque </font></font><code>nesinfo_tag_process1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na verdade √© chamado duas vezes. Pela primeira vez, ela recebe algumas informa√ß√µes sobre o espa√ßo necess√°rio para se preparar para os dados armazenados. As tags QDS e BBR n√£o s√£o totalmente processadas na primeira execu√ß√£o. Ap√≥s a primeira execu√ß√£o, um local √© preparado para salvar os dados e a fun√ß√£o √© chamada novamente. Desta vez, as tags QDS e BBR s√£o totalmente processadas, mas se as cadeias de nomes de tags forem apagadas da mem√≥ria, ser√° imposs√≠vel corresponder as tags novamente! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso pode ser evitado definindo um valor de tamanho menor. Outro problema √© que o valor de deslocamento s√≥ pode avan√ßar na mem√≥ria e os dados ROM NES est√£o localizados no heap bem perto do final da mem√≥ria dispon√≠vel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois deles, existem apenas alguns montes, e nenhum deles tem algo particularmente √∫til, como indicadores √≥bvios de fun√ß√µes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No caso normal, voc√™ pode usar isso para explorar um estouro de heap, mas na implementa√ß√£o </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usada para esse heap, foram adicionados alguns bytes de verifica√ß√µes de sa√∫de em blocos </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Podemos escrever sobre valores de ponteiro em blocos de heap subsequentes. Sem verifica√ß√µes de integridade, isso poderia ser usado para gravar em uma √°rea de mem√≥ria arbitr√°ria quando chamado </font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por um bloco de heap envolvido. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, a implementa√ß√£o usada aqui </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verifica um padr√£o de bytes espec√≠fico ( </font></font><code>0x7373</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) no in√≠cio dos blocos seguintes e anteriores que ele manipular√° quando chamado</font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se ela n√£o encontrar esses bytes, ela liga </font></font><code>OSPanic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e o jogo congela.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/516/68f/447/51668f447b75887250574f1ad1ec1800.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o √© poss√≠vel influenciar a presen√ßa desses bytes em algum local de destino, n√£o √© poss√≠vel escrever aqui. </font><font style="vertical-align: inherit;">Em outras palavras, √© imposs√≠vel gravar algo em um local arbitr√°rio sem poder gravar algo pr√≥ximo a esse local. </font><font style="vertical-align: inherit;">Pode haver alguma maneira de tornar o valor </font></font><code>0x73730000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">armazenado na pilha diretamente em frente ao endere√ßo de retorno </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e o</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> local ao qual o valor se refere, ao qual queremos gravar no endere√ßo de destino (ele tamb√©m ser√° verificado como se fosse um ponteiro para um bloco de pilha), mas isso √© dif√≠cil conseguir e usar isso em uma explora√ß√£o.</font></font><br><br><h5> <code>nesinfo_update_highscore</code> </h5> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra fun√ß√£o referente √†s tags QDS, BBR e HSC √© essa </font></font><code>nesinfo_update_highscore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Os tamanhos das marcas QDS, BBR e OFS (deslocamento) s√£o usados ‚Äã‚Äãpara calcular o deslocamento no qual gravar, e a marca HSC inclui a grava√ß√£o nesse local. Essa fun√ß√£o √© executada para cada quadro processado pelo emulador NES. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O valor m√°ximo de deslocamento para cada etiqueta nesse caso, mesmo para QDS, √© igual </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. No entanto, durante o ciclo de processamento de etiquetas, os valores de dimens√£o das etiquetas BBR e QDS realmente se </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acumulam</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Isso significa que v√°rias marcas podem ser usadas para calcular quase qualquer valor de deslocamento. A limita√ß√£o √© o n√∫mero de etiquetas que podem caber na se√ß√£o de dados das etiquetas da ROM em um arquivo no cart√£o de mem√≥ria e tamb√©m possui um tamanho m√°ximo </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O endere√ßo base ao qual o deslocamento √© adicionado √© o </font></font><code>0x800C3180</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buffer de dados salvos. </font><font style="vertical-align: inherit;">Esse endere√ßo √© muito menor que os dados da ROM, o que nos d√° mais liberdade na escolha de um local de grava√ß√£o. </font><font style="vertical-align: inherit;">Por exemplo, ser√° bastante simples reescrever o endere√ßo de retorno na pilha no endere√ßo </font></font><code>0x812F95DC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, isso tamb√©m n√£o funcionou. </font><font style="vertical-align: inherit;">Acontece que ele </font></font><code>nesinfo_tag_process1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamb√©m verifica o tamanho acumulado das compensa√ß√µes desses r√≥tulos e usa esse tamanho para inicializar o espa√ßo:</font></font><br><br><pre> <code class="cpp hljs">bzero(nintendo_hi_0, ((offset_sum + <span class="hljs-number"><span class="hljs-number">0xB</span></span>) * <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0x40</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b3/531/0ab/7b35310ab9bae3406ee423acd1c1a1a5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com o valor de deslocamento que eu estava tentando calcular, isso levou ao fato de que </font></font><code>0x48D91EC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(76.386.796) bytes de mem√≥ria </font><font style="vertical-align: inherit;">foram limpos </font><font style="vertical-align: inherit;">, e √© por isso que o jogo travou espetacularmente.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Marca PAT </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu j√° tinha come√ßado a perder a esperan√ßa, porque todas essas tags que faziam chamadas desprotegidas </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haviam falhado antes mesmo de eu us√°-las. Decidi apenas documentar o objetivo de cada tag e, gradualmente, cheguei √†s tags </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maioria dos manipuladores de etiquetas </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nunca inicia, porque eles s√≥ funcionam quando o ponteiro √© </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diferente de zero. Nada no c√≥digo atribui um valor diferente de zero a esse ponteiro. √â inicializado com um valor nulo e nunca √© usado novamente. Quando o carregamento da ROM √© definido apenas </font></font><code>nesinfo_data_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, parece um c√≥digo morto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, h√° um r√≥tulo que ainda pode funcionar quando diferente de zero </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: PAT. Este √© o r√≥tulo mais dif√≠cil de uma fun√ß√£o </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5a/8fa/e47/b5a8fae47c7ba7f82b2ee9810a950c6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ele tamb√©m usa como ponteiro </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas nunca verifica como zero. </font><font style="vertical-align: inherit;">A tag PAT l√™ seu pr√≥prio buffer de dados, processando c√≥digos que calculam as compensa√ß√µes. </font><font style="vertical-align: inherit;">Esses deslocamentos s√£o adicionados ao ponteiro </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para calcular o endere√ßo de destino e os bytes s√£o copiados do buffer de corre√ß√£o para esse local. </font><font style="vertical-align: inherit;">Essa c√≥pia √© feita carregando e salvando bytes, sem usar instru√ß√µes </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por isso n√£o notei isso antes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada buffer de dados da marca PAT possui um c√≥digo de tipo de 8 bits, um tamanho de patch de 8 bits e um valor de deslocamento de 16 bits, seguido pelos dados do patch.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se o c√≥digo for 2, o valor do deslocamento ser√° adicionado √† soma atual das compensa√ß√µes. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se o c√≥digo for 9, o deslocamento ser√° aumentado em 4 bits e adicionado √† soma atual das compensa√ß√µes. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se o c√≥digo for 3, a soma dos deslocamentos ser√° redefinida para 0. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O tamanho m√°ximo do r√≥tulo de informa√ß√µes do NES √© 255, ou seja, o maior tamanho do patch PAT √© 251 bytes. </font><font style="vertical-align: inherit;">No entanto, v√°rias marcas PAT podem ser usadas, ou seja, voc√™ pode corrigir mais de 251 bytes, bem como corrigir espa√ßos n√£o cont√≠guos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde que tenhamos uma s√©rie de solas PAT com o c√≥digo 2 ou 9, o deslocamento do ponteiro de destino continua a se acumular. </font><font style="vertical-align: inherit;">Ao copiar dados de patch, ele √© redefinido para zero, mas se voc√™ usar um tamanho de patch zero, isso poder√° ser evitado. </font><font style="vertical-align: inherit;">√â claro que isso pode ser usado para calcular algum deslocamento arbitr√°rio com um ponteiro nulo </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usando muitas marcas PAT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, existem mais duas verifica√ß√µes de valores de c√≥digo ...</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o c√≥digo estiver entre </font></font><code>0x80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>0xFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ent√£o ele ser√° adicionado </font></font><code>0x7F80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e aumentado para 16 bits. </font><font style="vertical-align: inherit;">Em seguida, √© adicionado ao valor de deslocamento de 16 bits e usado como o endere√ßo final do patch.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso nos permite atribuir um endere√ßo de destino para o patch no intervalo de </font></font><code>0x80000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>0x807FFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font><font style="vertical-align: inherit;">√â aqui que a maior parte do c√≥digo Animal Crossing reside na mem√≥ria. </font><font style="vertical-align: inherit;">Isso significa que podemos corrigir o pr√≥prio c√≥digo do Animal Crossing usando r√≥tulos de metadados da ROM de um arquivo em um cart√£o de mem√≥ria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com a ajuda de um pequeno carregador de patches, voc√™ pode facilmente baixar patches maiores de um cart√£o de mem√≥ria para qualquer endere√ßo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como verifica√ß√£o r√°pida, criei um patch que inclu√≠a o "zuru mode 2" (modo de desenvolvedor de jogos, descrito no meu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo anterior</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) quando um usu√°rio carrega uma ROM de um mapa do jogo. </font><font style="vertical-align: inherit;">Verificou-se que o truque das teclas apenas ativa o modo "zuru mode 1", que n√£o tem acesso √†s fun√ß√µes do Modo 2. Com esse patch, gra√ßas ao cart√£o de mem√≥ria, podemos obter acesso completo ao modo de desenvolvedor em hardware real.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/d51/d15/864d51d15fa180ea3fab552a0dd4977b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As marcas de corre√ß√£o ser√£o processadas quando a ROM for inicializada. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/dc8/2e4/499dc82e445ffd6bfd607d4f834ccd5a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ap√≥s carregar a ROM, voc√™ precisa sair do emulador NES para ver o resultado. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/6ea/3a2/6946ea3a20e0290b75eeba8bbf400d10.png"></div><br>  Isso funciona! <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Formato da etiqueta de informa√ß√µes do patch </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As marcas de informa√ß√£o no arquivo de salvamento que executam esse patch s√£o assim: </font></font><br><br> <code>000000 5a 5a 5a 00 50 41 54 08 a0 04 6f 9c 00 00 00 7d &gt;ZZZ.PAT...o....}&lt; <br> 000010 45 4e 44 00 &gt;END.&lt;</code> <br> <br><ul><li> <code>ZZZ \x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: marca de in√≠cio ignorada. </font></font><code>0x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â o tamanho do seu buffer de dados: zero.</font></font></li><li> <code>PAT \x08 \xA0 \x04 \x6F\x9C \x00\x00\x00\x7D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Correc√ß√£o </font></font><code>0x80206F9C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no </font></font><code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><ul><li> <code>0x08</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √â o tamanho do buffer do r√≥tulo. </font></font></li><li> <code>0xA0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando adicionado a </font></font><code>0x7F80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">torna </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">se </font></font><code>0x8020</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ou seja, os 16 bits superiores do endere√ßo de destino.</font></font></li><li> <code>0x04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â o tamanho dos dados do patch ( </font></font><code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li><li> <code>0x6F9C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> S√£o os 16 bits inferiores do endere√ßo de destino. </font></font></li><li> <code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> S√£o os dados do patch. </font></font></li></ul></li><li> <code>END \x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : marca final. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ quiser experimentar sozinho a cria√ß√£o de um patcher ou de arquivos salvos em ROM, em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/jamchamb/ac-nesrom-save-generator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , publiquei um c√≥digo muito simples para gerar arquivos. </font><font style="vertical-align: inherit;">Um patch como o mostrado acima pode ser gerado com o seguinte comando:</font></font><br><br> <code>$ ./patcher.py Patcher /dev/null zuru_mode_2.gci -p 80206F9c 0000007D</code> <br> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Execu√ß√£o de c√≥digo arbitr√°rio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gra√ßas a essa tag, voc√™ pode obter a execu√ß√£o arbitr√°ria de c√≥digo no Animal Crossing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas aqui vem o √∫ltimo obst√°culo: o uso de patches para dados funciona bem, mas surgem problemas ao aplicar instru√ß√µes de c√≥digo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando os patches s√£o registrados, o jogo continua seguindo as instru√ß√µes antigas que estavam no seu lugar. Parece um problema de armazenamento em cache, e na verdade √©. A CPU do GameCube possui caches de instru√ß√µes, conforme descrito </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nas especifica√ß√µes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para entender como voc√™ pode limpar o cache, comecei a estudar as fun√ß√µes relacionadas ao cache na documenta√ß√£o do GameCube SDK e descobri </font></font><code>ICInvalidateRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esta fun√ß√£o invalida os blocos de instru√ß√µes em cache no endere√ßo de mem√≥ria especificado, o que permite que a mem√≥ria de instru√ß√µes modificada seja executada com c√≥digo atualizado.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, sem a capacidade de executar o c√≥digo original, ainda n√£o podemos ligar </font></font><code>ICInvalidateRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para uma execu√ß√£o bem-sucedida do c√≥digo, precisamos de mais um truque. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estudando a implementa√ß√£o </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para a possibilidade de usar uma explora√ß√£o com estouro de heap, aprendi que as fun√ß√µes de implementa√ß√£o </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podem ser desabilitadas dinamicamente usando uma estrutura de dados chamada </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">carrega um ponteiro para a implementa√ß√£o atual </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de um local est√°tico na mem√≥ria e chama essa fun√ß√£o, passando todos os argumentos passados ‚Äã‚Äãpara </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O emulador NES usa ativamente</font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para alocar e liberar mem√≥ria para dados NES relacionados √† ROM, ent√£o eu tinha certeza de que seria lan√ßado v√°rias vezes mais ou menos ao mesmo tempo que as marcas PAT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ele </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">carrega um ponteiro da mem√≥ria e faz uma transi√ß√£o para ele, eu posso alterar o processo de execu√ß√£o do programa simplesmente substituindo o ponteiro para que aponte para a fun√ß√£o atual </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O armazenamento em cache da ferramenta n√£o impedir√° que isso aconte√ßa, porque nenhuma instru√ß√£o precisa ser alterada </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O desenvolvedor do projeto de f√£ D≈çbutsu no Mori e +, chamado Cuyler, escreveu um carregador no PowerPC assembler e demonstrou seu uso para injetar novo c√≥digo neste v√≠deo: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.youtube.com/watch?v=BdxN7gP6WIc</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(D≈çbutsu no Mori e + foi a √∫ltima itera√ß√£o de Animal Crossing no GameCube, que teve mais atualiza√ß√µes. Lan√ßada apenas no Jap√£o.) O patch faz o download de um c√≥digo que permite ao jogador criar qualquer objeto digitando seu ID por letra e pressionando o bot√£o Z.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BdxN7gP6WIc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gra√ßas a isso, voc√™ pode baixar mods, cheats e homebrew em uma c√≥pia regular do Animal </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crossing em um GameCube real.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt417117/">https://habr.com/ru/post/pt417117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt417107/index.html">Criador do jogo enquanto True: aprenda () sobre programa√ß√£o de gamedev, problemas de VR e simula√ß√µes de ML</a></li>
<li><a href="../pt417109/index.html">Richard Hamming: Cap√≠tulo 10. Teoria da Codifica√ß√£o - I</a></li>
<li><a href="../pt417111/index.html">Confer√™ncias online: streaming vs webinar</a></li>
<li><a href="../pt417113/index.html">Impressora 3D italiana na R√∫ssia: Raise3D N1 Dual - modelagem e prototipagem</a></li>
<li><a href="../pt417115/index.html">Enterrar ou queimar Flutter.io?</a></li>
<li><a href="../pt417119/index.html">Pagina√ß√£o no Vue.js</a></li>
<li><a href="../pt417123/index.html">Integra√ß√£o do Spark Streaming e Kafka</a></li>
<li><a href="../pt417125/index.html">RTC Meetup .Net: convite para a primeira reuni√£o</a></li>
<li><a href="../pt417127/index.html">Tesla assina acordo para construir o Gigafactory 3 na China</a></li>
<li><a href="../pt417129/index.html">Universo da mente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>