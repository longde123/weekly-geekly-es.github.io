<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❣️ 👨‍🔬 🌳 Comment analyser le vidage des threads 👩🏻‍🎓 👩🏿‍🏫 👩🏾‍🤝‍👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a pas mal de sujets sur les internes de la JVM dans le programme de cours Java Developer . Nous comprenons les mécanismes de fonctionnement des c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment analyser le vidage des threads</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/427513/">  <i>Il <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">y a</a> pas mal de sujets sur les internes de la JVM dans le programme de cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java Developer</a> .</i>  <i>Nous comprenons les mécanismes de fonctionnement des collections, bytecode, garbage collectors, etc.</i>  <i>Aujourd'hui, nous offrons votre attention sur la traduction d'un article assez intéressant sur le vidage de threads.</i>  <i>Qu'est-ce que c'est, comment l'obtenir et comment l'utiliser.</i> <br><br>  Vous voulez apprendre à analyser le vidage des threads?  Allez sous le chat pour en savoir plus sur la façon d'obtenir un vidage de threads en Java et que faire avec plus tard. <br><a name="habracut"></a><br>  La plupart des applications Java modernes sont multithread.  Le multithreading peut étendre considérablement les fonctionnalités de l'application, tout en introduisant une complexité importante. <br><br>  Dans une application monothread, toutes les ressources (mémoire partagée, opérations d'entrée / sortie, etc.) peuvent être utilisées sans synchronisation, car  à un moment donné, un seul thread utilise la ressource. <br><br>  Dans le cas d'applications multi-thread, il est nécessaire de trouver un compromis entre compliquer le programme et une augmentation possible des performances, lorsque plusieurs threads peuvent utiliser tous les processeurs (CPU) de base disponibles (souvent plus d'un).  Si tout est fait correctement, alors en utilisant le multithreading (formalisé dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la loi d'Amdahl</a> ), vous pouvez obtenir une augmentation significative des performances de l'application.  Cependant, il faut se rappeler de fournir un accès simultané de plusieurs flux à une ressource partagée.  Dans la plupart des cas, les frameworks tels que Spring encapsulent le travail avec les threads et masquent de nombreux détails techniques aux utilisateurs.  Cependant, dans le cas de l'utilisation de cadres complexes modernes, quelque chose peut mal tourner, et nous, en tant qu'utilisateurs, rencontrerons des bogues multithreads difficiles à résoudre. <br><br>  Heureusement, Java est équipé d'un mécanisme spécial pour obtenir des informations sur l'état actuel de tous les threads à un moment donné - il s'agit d'un vidage de thread (une sorte d'instantané).  Dans cet article, nous apprendrons comment obtenir un vidage de thread pour une application de taille réaliste et comment analyser ce vidage. <br><br>  Il est supposé que le lecteur dispose d'informations de base sur la programmation multithread et qu'il est conscient des problèmes de synchronisation des threads et d'utilisation des ressources partagées.  Néanmoins, il ne sera pas superflu de rafraîchir certains termes et concepts de base. <br><br><h4>  Terminologie de base </h4><br>  À première vue, les vidages de threads Java peuvent sembler être une «lettre chinoise», les concepts suivants sont essentiels pour la comprendre.  En général, répétons les termes de base du multithreading, que nous utiliserons pour analyser les vidages. <br><br><ul><li> <strong>Le thread</strong> ou le thread est une unité multithread discrète gérée par la machine virtuelle Java (JVM).  Les threads JVM correspondent aux threads du système d'exploitation (OS) - threads natifs, qui implémentent le mécanisme d'exécution de code. <br><br>  Chaque thread a un identifiant et un nom uniques.  Les flux peuvent être des "démons" et "pas des démons". <br><br>  Le programme se termine lorsque tous les threads non démon se terminent ou <i>lorsque la</i> méthode <i>Runtime.exit</i> est <i>appelée</i> .  Les «démons» qui travaillent n'affectent pas l'achèvement du programme.  C'est-à-dire  La JVM attend que tous les «non-démons» soient finalisés et fermés, ils ne font pas attention aux «non-démons». <br><br>  Pour plus d'informations, consultez la documentation de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe Thread</a> . <br>  Un flux peut se trouver dans l'un des états suivants: <br><br><ul><li>  <strong>Fil vivant</strong> ou «en direct» - un fil qui fonctionne (état normal). </li><li>  <strong>Thread bloqué</strong> ou «bloqué» - un thread qui a tenté d'entrer dans la section synchronisée (synchronisé), mais un autre thread a déjà réussi à entrer ce bloc en premier, et tous les threads suivants qui tentent d'entrer dans le même bloc sont bloqués. </li><li>  <strong>Fil d'attente</strong> ou «en attente» - un fil qui a appelé la méthode d' <i>attente</i> (éventuellement avec un délai d'expiration) et attend maintenant qu'une autre méthode s'exécute <i>notifie</i> ou <i>nonifieAll</i> sur le même objet. <br><br>  Veuillez noter que le thread n'est pas considéré comme «en attente» s'il a appelé wait with a timeout et que ce délai a expiré. </li><li>  <strong>Fil dormant</strong> ou "dormant" - un fil qui n'est pas en cours d'exécution, car  effectué la méthode Thread.sleep (indiquant la durée du "sommeil"). </li></ul></li><li>  <strong>Monitor</strong> est un mécanisme utilisé par la JVM pour fournir un accès multithread à un seul objet.  Le mécanisme est démarré à l'aide du <i>mot clé synchronisé</i> spécial. <br><br>  Chaque objet en Java a un moniteur avec lequel le thread peut être synchronisé, c'est-à-dire  définir un verrou, ce qui garantit qu'aucun autre thread n'accédera à cet objet tant que le verrou n'est pas libéré, c'est-à-dire  thread - le propriétaire du verrou ne quittera pas le bloc <i>synchronisé</i> . <br><br>  Voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">section Synchronisation (17.1) de la spécification Java Langauge (JLS) pour plus d'informations</a> . <br></li><li>  <strong>Le blocage</strong> est une situation dans laquelle un thread, par exemple A, bloque une ressource, il a besoin d'une autre ressource qui est bloquée par un autre thread, par exemple B. Le flux B ne libère pas cette ressource, car  Pour terminer une certaine opération, il a besoin d'une ressource qui est bloquée par le thread A. Il s'avère que le thread A attend que la ressource soit déverrouillée par le thread B, qui attend qu'une autre ressource soit déverrouillée par le thread A. Et, par conséquent, les threads attendent les uns les autres.  Par conséquent, le programme entier se bloque et attend que les threads se déverrouillent et continuent de fonctionner.  Il peut y avoir plusieurs threads dans une impasse.  Ce problème est bien connu sous le nom de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«problème des philosophes de la restauration»</a> . <br><br><img src="https://habrastorage.org/webt/8t/ll/jb/8tlljb_n-e80_dk_0uayobgil_s.png"><br></li><li>  <strong>Livelock</strong> est une situation où le thread A force le thread B à effectuer une action, ce qui oblige le thread A à effectuer l'action initiale, ce qui provoque à nouveau l'action du thread B. Une dépendance cyclique est obtenue.  Cela peut être imaginé comme un chien qui court après sa queue.  Comme pour <i>Deadlock</i> , dans une situation Livelock, le programme ne progresse pas, c'est-à-dire  n'effectue pas d'action utile, cependant, dans cette situation, les threads ne sont pas bloqués. <br></li></ul><br>  La terminologie présentée n'est pas exhaustive pour décrire le monde du multithreading, mais cela suffit pour commencer à analyser les vidages de threads. <br><br>  Des informations plus détaillées peuvent être trouvées dans ces sources: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Section 17 du JLS</a> et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la concurrence Java en pratique</a> <br><br>  En utilisant ces concepts simples sur le flux en Java, nous pouvons créer une application de test.  Pour cette application, nous compilerons le vidage des threads.  Nous analyserons le vidage résultant et extrairons des informations utiles sur les flux d'application actuels. <br><br><h4>  Création d'un exemple de programme </h4><br>  Avant de créer un vidage de thread, nous devons développer une application Java.  Le traditionnel "bonjour, le monde!"  trop simple pour notre objectif, et un vidage de taille moyenne de l'application peut être trop compliqué à démontrer.  Sur cette base, nous allons créer une application assez simple dans laquelle deux threads sont créés.  Et les fils tombent dans l'impasse: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceB, resourceA)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br>  Ce programme crée deux ressources: resourceA et resourceB et démarre deux threads: threadLockingResourceAFirst et threadLockingResourceBFirst, qui se bloquent mutuellement les ressources. <br><br>  La cause du blocage est un blocage «croisé» des ressources par les threads. <br><br>  La raison de l'occurrence de l'impasse est une tentative de saisie "mutuelle" des ressources, c'est-à-dire  Le thread threadLockingResourceAFirst capture la ressource resourceA, le thread threadLockingResourceBFirst capture la ressource resourceB.  Après cela, threadLockingResourceAFirst, sans libérer sa ressource, tente de capturer resourceB, et threadLockingResourceBFirst, sans libérer sa ressource, tente de capturer resourceA.  Par conséquent, les threads sont bloqués.  Un délai de 1 s a été ajouté pour garantir le blocage.  Les threads attendent la libération des ressources nécessaires, mais cela ne se produira jamais. <br><br>  La sortie du programme sera comme ceci (les chiffres après java.lang.Object @ seront différents pour chaque lancement): <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Thread-0</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">locked</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">resource</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Object</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">149bc794</span></span> Thread-<span class="hljs-number"><span class="hljs-number">1</span></span>: locked resource -&gt; java.lang.Object@<span class="hljs-number"><span class="hljs-number">17</span></span>c10009</code> </pre> <br>  Après la sortie de ces messages, le programme aura l'air d'être en cours d'exécution (le processus exécutant ce programme n'est pas terminé), tandis que le programme ne fait aucun travail.  Voici à quoi ressemble l'impasse dans la pratique.  Pour résoudre le problème, nous devons créer manuellement un vidage de la bande de roulement et analyser l'état des threads. <br><br><h4>  Génération de vidage de thread </h4><br>  En pratique, un programme Java peut se bloquer lors de la création d'un vidage de thread.  Cependant, dans certains cas (par exemple, dans le cas de blocages), le programme ne se termine pas et le vidage de thread ne se crée pas, il se bloque simplement.  Pour créer un vidage de ces programmes bloqués, vous devez d'abord trouver l'identifiant du processus du programme, c'est-à-dire  ID de processus (PID).  Pour ce faire, vous pouvez utiliser l'utilitaire JVM Process Status (JPS) qui, à partir de la version 7, fait partie du kit de développement Java (JDK).  Pour trouver le processus PID de notre programme bloqué, nous exécutons simplement jps dans le terminal (Windows ou Linux): <br><br><pre> <code class="hljs ruby">$ jps <span class="hljs-number"><span class="hljs-number">11568</span></span> DeadlockProgram <span class="hljs-number"><span class="hljs-number">15584</span></span> Jps <span class="hljs-number"><span class="hljs-number">15636</span></span></code> </pre> <br>  La première colonne est l'identifiant de la machine virtuelle locale (Local VM ID, c'est-à-dire lvmid) pour le processus Java en cours d'exécution.  Dans le contexte de la JVM locale, lvmid pointe vers le PID du processus Java. <br><br>  Il convient de noter que cette valeur est susceptible de différer de la valeur ci-dessus.  La deuxième colonne est le nom de l'application, qui peut pointer vers le nom de la classe principale, du fichier jar ou égal à "Inconnu".  Tout dépend de la façon dont l'application a été lancée. <br><br>  Dans notre cas, le nom de l'application DeadlockProgram est le nom des principales classes qui ont été lancées au démarrage du programme.  Dans l'exemple ci-dessus PID du programme 11568, ces informations sont suffisantes pour générer un vidage de thread.  Pour générer le vidage, nous utiliserons l'utilitaire <strong>jstack</strong> , qui fait partie du JDK, à partir de la version 7. Pour obtenir le vidage, nous <strong>passerons le</strong> PID de notre programme à <strong>jstack</strong> et spécifierons le drapeau -l (créant une longue liste).  La sortie de l'utilitaire sera redirigée vers un fichier texte, c'est-à-dire  thread_dump.txt: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">jstack</span></span> -l <span class="hljs-number"><span class="hljs-number">11568</span></span> &gt; thread_dump.txt</code> </pre> <br>  Le fichier thread_dump.txt résultant contient le vidage de thread de notre programme bloqué et contient des informations importantes pour diagnostiquer les causes de blocage. <br><br>  Si le JDK est utilisé jusqu'à la version 7, pour générer un vidage, vous pouvez utiliser l'utilitaire Linux - <strong>kill</strong> avec l'indicateur -3.  L'appel de kill -3 enverra au programme un signal SIGQUIT. <br><br>  Dans notre cas, l'appel sera comme ceci: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">kill</span></span> <span class="hljs-number"><span class="hljs-number">-3</span></span> <span class="hljs-number"><span class="hljs-number">11568</span></span></code> </pre> <br><h4>  Analyse simple de vidage de thread </h4><br>  En ouvrant le fichier thread_dump.txt, nous verrons quelque chose comme ceci: <br><br><pre> 2018-06-19 16:44:44
 Sauvegarde complète du thread Java VM HotSpot (TM) 64 bits Server (10.0.1 + 10 mode mixte):
 Informations sur la classe de threads SMR:
 _java_thread_list = 0x00000250e5488a00, longueur = 13, elements = {
 0x00000250e4979000, 0x00000250e4982800, 0x00000250e52f2800, 0x00000250e4992800,
 0x00000250e4995800, 0x00000250e49a5800, 0x00000250e49ae800, 0x00000250e5324000,
 0x00000250e54cd800, 0x00000250e54cf000, 0x00000250e54d1800, 0x00000250e54d2000,
 0x00000250e54d0800
 }
 "Reference Handler" # 2 daemon prio = 10 os_prio = 2 tid = 0x00000250e4979000 nid = 0x3c28 en attente à la condition [0x000000b82a9ff000]
    java.lang.Thread.State: RUNNABLE
     à java.lang.ref.Reference.waitForReferencePendingList (java.base@10.0.1/Native Method)
     à java.lang.ref.Reference.processPendingReferences (java.base@10.0.1/Reference.java: 174)
     à java.lang.ref.Reference.access 000 $ (java.base@10.0.1/Reference.java: 44)
     à java.lang.ref.Reference $ ReferenceHandler.run (java.base@10.0.1/Reference.java: 138)
    Synchroniseurs propriétaires verrouillés:
     - Aucun
 "Finalizer" # 3 daemon prio = 8 os_prio = 1 tid = 0x00000250e4982800 nid = 0x2a54 dans Object.wait () [0x000000b82aaff000]
    java.lang.Thread.State: WAITING (sur le moniteur d'objet)
     à java.lang.Object.wait (java.base@10.0.1/Native Method)
     - en attente sur &lt;0x0000000089509410&gt; (un java.lang.ref.ReferenceQueue $ Lock)
     à java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 151)
     - en attente de re-verrouillage en attente () &lt;0x0000000089509410&gt; (un java.lang.ref.ReferenceQueue $ Lock)
     à java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 172)
     à java.lang.ref.Finalizer $ FinalizerThread.run (java.base@10.0.1/Finalizer.java: 216)
    Synchroniseurs propriétaires verrouillés:
     - Aucun
 "Signal Dispatcher" # 4 démon prio = 9 os_prio = 2 tid = 0x00000250e52f2800 nid = 0x2184 exécutable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Synchroniseurs propriétaires verrouillés:
     - Aucun
 "Attach Listener" # 5 daemon prio = 5 os_prio = 2 tid = 0x00000250e4992800 nid = 0x1624 en attente à la condition [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Synchroniseurs propriétaires verrouillés:
     - Aucun
 "C2 CompilerThread0" # 6 démon prio = 9 os_prio = 2 tid = 0x00000250e4995800 nid = 0x4198 en attente à la condition [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Aucune tâche de compilation
    Synchroniseurs propriétaires verrouillés:
     - Aucun
 "C2 CompilerThread1" # 7 démon prio = 9 os_prio = 2 tid = 0x00000250e49a5800 nid = 0x3b98 en attente à la condition [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Aucune tâche de compilation
    Synchroniseurs propriétaires verrouillés:
     - Aucun
 "C1 CompilerThread2" # 8 démon prio = 9 os_prio = 2 tid = 0x00000250e49ae800 nid = 0x1a84 en attente à la condition [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Aucune tâche de compilation
    Synchroniseurs propriétaires verrouillés:
     - Aucun
 "Thread Sweeper" # 9 daemon prio = 9 os_prio = 2 tid = 0x00000250e5324000 nid = 0x5f0 exécutable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Synchroniseurs propriétaires verrouillés:
     - Aucun
 "Service Thread" # 10 daemon prio = 9 os_prio = 0 tid = 0x00000250e54cd800 nid = 0x169c exécutable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Synchroniseurs propriétaires verrouillés:
     - Aucun
 Démon "Common-Cleaner" # 11 prio = 8 os_prio = 1 tid = 0x00000250e54cf000 nid = 0x1610 dans Object.wait () [0x000000b82b2fe000]
    java.lang.Thread.State: TIMED_WAITING (sur le moniteur d'objet)
     à java.lang.Object.wait (java.base@10.0.1/Native Method)
     - en attente sur &lt;0x000000008943e600&gt; (un java.lang.ref.ReferenceQueue $ Lock)
     à java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 151)
     - en attente de re-verrouillage dans wait () &lt;0x000000008943e600&gt; (un java.lang.ref.ReferenceQueue $ Lock)
     à jdk.internal.ref.CleanerImpl.run (java.base@10.0.1/CleanerImpl.java: 148)
     à java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
     à jdk.internal.misc.InnocuousThread.run (java.base@10.0.1/InnocuousThread.java: 134)
    Synchroniseurs propriétaires verrouillés:
     - Aucun
 "Thread-0" # 12 prio = 5 os_prio = 0 tid = 0x00000250e54d1800 nid = 0xdec en attente d'entrée du moniteur [0x000000b82b4ff000]
    java.lang.Thread.State: BLOCKED (sur le moniteur d'objet)
     à DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - en attente de verrouillage &lt;0x00000000894465b0&gt; (un java.lang.Object)
     - verrouillé &lt;0x00000000894465a0&gt; (un java.lang.Object)
     à java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Synchroniseurs propriétaires verrouillés:
     - Aucun
 "Thread-1" # 13 prio = 5 os_prio = 0 tid = 0x00000250e54d2000 nid = 0x415c en attente d'entrée du moniteur [0x000000b82b5ff000]
    java.lang.Thread.State: BLOCKED (sur le moniteur d'objet)
     à DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - en attente de verrouillage &lt;0x00000000894465a0&gt; (un java.lang.Object)
     - verrouillé &lt;0x00000000894465b0&gt; (un java.lang.Object)
     à java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Synchroniseurs propriétaires verrouillés:
     - Aucun
 "DestroyJavaVM" # 14 prio = 5 os_prio = 0 tid = 0x00000250e54d0800 nid = 0x2b8c en attente à la condition [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Synchroniseurs propriétaires verrouillés:
     - Aucun
 "VM Thread" os_prio = 2 tid = 0x00000250e496d800 nid = 0x1920 exécutable  
 "GC Thread # 0" os_prio = 2 tid = 0x00000250c35b5800 nid = 0x310c exécutable  
 "GC Thread # 1" os_prio = 2 tid = 0x00000250c35b8000 nid = 0x12b4 exécutable  
 "GC Thread # 2" os_prio = 2 tid = 0x00000250c35ba800 nid = 0x43f8 exécutable  
 "GC Thread # 3" os_prio = 2 tid = 0x00000250c35c0800 nid = 0x20c0 exécutable  
 "G1 Main Marker" os_prio = 2 tid = 0x00000250c3633000 nid = 0x4068 exécutable  
 "G1 Conc # 0" os_prio = 2 tid = 0x00000250c3636000 nid = 0x3e28 exécutable  
 "G1 Affiner # 0" os_prio = 2 tid = 0x00000250c367e000 nid = 0x3c0c exécutable  
 "G1 Affiner # 1" os_prio = 2 tid = 0x00000250e47fb800 nid = 0x3890 exécutable  
 "G1 Affiner # 2" os_prio = 2 tid = 0x00000250e47fc000 nid = 0x32a8 exécutable  
 "G1 Affiner # 3" os_prio = 2 tid = 0x00000250e47fd800 nid = 0x3d00 exécutable  
 "G1 Young RemSet Sampling" os_prio = 2 tid = 0x00000250e4800800 nid = 0xef4 exécutable  
 "Thread de tâche périodique VM" os_prio = 2 tid = 0x00000250e54d6800 nid = 0x3468 en attente de condition  
 Références mondiales JNI: 2
 Trouvé un blocage au niveau Java:
 ===============================
 "Thread-0":
   en attente de verrouillage du moniteur 0x00000250e4982480 (objet 0x00000000894465b0, un java.lang.Object),
   qui est détenu par "Thread-1"
 "Thread-1":
   en attente de verrouillage du moniteur 0x00000250e4982380 (objet 0x00000000894465a0, un java.lang.Object),
   qui est détenu par "Thread-0"
 Informations sur la pile Java pour les threads répertoriés ci-dessus:
 =================================================== =
 "Thread-0":
     à DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - en attente de verrouillage &lt;0x00000000894465b0&gt; (un java.lang.Object)
     - verrouillé &lt;0x00000000894465a0&gt; (un java.lang.Object)
     à java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 "Thread-1":
     à DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - en attente de verrouillage &lt;0x00000000894465a0&gt; (un java.lang.Object)
     - verrouillé &lt;0x00000000894465b0&gt; (un java.lang.Object)
     à java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 Trouvé 1 blocage.
</pre><br><h3>  Informations introductives </h3><br>  Bien qu'à première vue ce fichier puisse sembler trop compliqué et déroutant, en réalité il est assez simple si vous le démontez par étapes étape par étape. <br><br>  La première ligne indique l'heure à laquelle le vidage a été formé, la seconde - des informations de diagnostic sur la machine virtuelle Java, sur lesquelles le vidage a été reçu: <br><br><pre> <code class="hljs css">2018<span class="hljs-selector-tag"><span class="hljs-selector-tag">-06-19</span></span> 16<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Full</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">thread</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dump</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Java</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">HotSpot</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TM</span></span>) 64<span class="hljs-selector-tag"><span class="hljs-selector-tag">-Bit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Server</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">VM</span></span> (10<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span>+10 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mixed</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mode</span></span>):</code> </pre> <br>  Il n'y a aucune information de flux dans cette section.  Ici, le contexte général du système dans lequel le vidage a été collecté est défini. <br><br><h4>  Informations générales sur le flux </h4><br>  La section suivante fournit des informations sur les unités d'exécution qui étaient en cours d'exécution dans le système au moment de la collecte de vidage: <br><br><pre> Informations sur la classe de threads SMR:
 _java_thread_list = 0x00000250e5488a00, longueur = 13, elements = {
 0x00000250e4979000, 0x00000250e4982800, 0x00000250e52f2800, 0x00000250e4992800,
 0x00000250e4995800, 0x00000250e49a5800, 0x00000250e49ae800, 0x00000250e5324000,
 0x00000250e54cd800, 0x00000250e54cf000, 0x00000250e54d1800, 0x00000250e54d2000,
 0x00000250e54d0800
 }
</pre><br>  La section suivante répertorie: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Informations sur la récupération de mémoire sécurisée (SMR)</a> <br><br>  Il contient des informations sur les threads en dehors de la JVM, c'est-à-dire  ce ne sont pas des threads de machine virtuelle ou des threads de récupération de place.  Si vous regardez les adresses de ces threads, vous remarquerez qu'elles correspondent à la valeur de <i>tid</i> - l'adresse «naturelle, de fer» (native) dans le système d'exploitation, et non l'ID de thread. <br><br>  Les points de suspension sont utilisés pour masquer les informations redondantes: <br><br><pre> "Gestionnaire de référence" # 2 ... tid = 0x00000250e4979000 ...
 "Finaliseur" # 3 ... tid = 0x00000250e4982800 ...
 "Signal Dispatcher" # 4 ... tid = 0x00000250e52f2800 ...
 "Attach Listener" # 5 ... tid = 0x00000250e4992800 ...
 "C2 CompilerThread0" # 6 ... tid = 0x00000250e4995800 ...
 "C2 CompilerThread1" # 7 ... tid = 0x00000250e49a5800 ...
 "C1 CompilerThread2" # 8 ... tid = 0x00000250e49ae800 ...
 "Fil de balayage" # 9 ... tid = 0x00000250e5324000 ...
 "Fil de service" # 10 ... tid = 0x00000250e54cd800 ...
 "Common-Cleaner" # 11 ... tid = 0x00000250e54cf000 ...
 "Thread-0" # 12 ... tid = 0x00000250e54d1800 ...
 "Thread-1" # 13 ... tid = 0x00000250e54d2000 ...
 "DestroyJavaVM" # 14 ... tid = 0x00000250e54d0800 ...
</pre><br><h3>  Streams </h3><br>  Juste après le bloc SMR se trouve une liste de threads.  Le premier fil de notre liste est le gestionnaire de référence: <br><br><pre> "Reference Handler" # 2 daemon prio = 10 os_prio = 2 tid = 0x00000250e4979000 nid = 0x3c28 en attente à la condition [0x000000b82a9ff000]
    java.lang.Thread.State: RUNNABLE
     à java.lang.ref.Reference.waitForReferencePendingList (java.base@10.0.1/Native Method)
     à java.lang.ref.Reference.processPendingReferences (java.base@10.0.1/Reference.java: 174)
     à java.lang.ref.Reference.access 000 $ (java.base@10.0.1/Reference.java: 44)
     à java.lang.ref.Reference $ ReferenceHandler.run (java.base@10.0.1/Reference.java: 138)
    Synchroniseurs propriétaires verrouillés:
     - Aucun
</pre><br><h4>  Brève description </h4><br>  La première ligne de chaque thread fournit une description générale.  La description contient les éléments suivants: <br><table><tbody><tr><th width="70">  Section </th><th width="100">  Exemple </th><th>  La description </th></tr><tr><td>  Nom </td><td>  "Gestionnaire de référence" </td><td>  Nom de flux lisible par l'homme.  Le nom peut être spécifié en appelant la méthode <i>setName</i> de l'objet <i>Thread</i> .  Et passez un appel à <i>getName</i> </td></tr><tr><td>  Identifiant </td><td>  # 2 </td><td>  Un ID unique attribué à chaque objet de la classe <i>Thread</i> .  L'ID est généré pour les threads du système.  La valeur initiale est 1. Chaque thread nouvellement créé se voit attribuer son propre ID, précédemment augmenté de 1. Cette propriété de thread en lecture seule peut être obtenue à l'aide de la fonction <i>getId</i> d' <i>un</i> objet de la classe <i>Thread</i> . </td></tr><tr><td>  Statut du démon </td><td>  démon </td><td>  Le drapeau est un signe que le fil est un démon.  S'il s'agit d'un démon, alors le drapeau sera mis.  Par exemple, le thread <i>-0 n'est</i> pas un démon. </td></tr><tr><td>  Priorité </td><td>  prio = 10 </td><td>  La priorité numérique du flux Java.  Notez que cette priorité ne correspond pas nécessairement à la priorité du thread associé dans le système d'exploitation.  Pour définir la priorité, vous pouvez <br>  utiliser la méthode <i>setPriority</i> d' <i>un</i> objet de classe <i>Thread</i> , et pour obtenir <br>  Méthode <i>getPriority</i> . </td></tr><tr><td>  Priorité du thread OS </td><td>  os_prio = 2 </td><td>  Thread prioritaire dans le système d'exploitation.  Cette priorité peut différer de celle attribuée au thread Java lié. </td></tr><tr><td>  Adresse </td><td>  tid = 0x00000250e4979000 </td><td>  L'adresse du flux Java.  Cette adresse est un pointeur vers l'objet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">natif Java Native Interface (JNI)</a> de la classe <i>Thread</i> (un objet C ++ <i>Thread</i> qui est connecté au thread Java via JNI).  Cette valeur est obtenue en plaçant un pointeur sur ce <br>  (l'objet C ++ associé à ce thread Java) en entier.  Voir <br>  <a href="">ligne 879 dans hotspot / share / runtime / thread.cpp</a> : <br><pre> st-&gt; print ("tid =" INTPTR_FORMAT "", p2i (this));
</pre><br>  Bien que la clé de cet objet ( <i>tid</i> ) puisse ressembler à un ID de flux, <br>  en fait, c'est l'adresse de l'objet connecté <i>JNI C ++ Thread</i> , et ce n'est pas la valeur qui <br>  renvoie la méthode <i>getId</i> du <i>thread</i> Java. </td></tr><tr><td>  ID de thread du système d'exploitation </td><td>  nid = 0x3c28 </td><td>  Identificateur unique du thread du système d'exploitation auquel le thread Java est lié. <br>  Cette valeur est sortie avec le code suivant: <br>  <a href="">ligne 42 dans hotspot / share / runtime / osThread.cpp</a> : <br><pre> st-&gt; print ("nid = 0x% x", thread_id ());
</pre><br></td></tr><tr><td>  Statut </td><td>  attente sous condition </td><td>  Statut lisible par l'homme du thread actuel. <br>  Cette ligne affiche des informations supplémentaires sur le statut simple du flux (voir ci-dessous), qui peuvent être <br>  utilisé pour comprendre ce que le thread allait faire (c'est-à-dire si le thread essayait d'obtenir un verrou <br>  ou en attendant que la condition de déverrouillage soit remplie). </td></tr><tr><td>  Dernier pointeur de pile Java connu </td><td>  [0x000000b82a9ff000] </td><td>  Le dernier pointeur de pile (SP) connu associé à ce flux. <br>  Cette valeur est obtenue en utilisant du code C ++ natif mélangé avec du code Java utilisant JNI.  La valeur est retournée par la fonction <i>last_Java_sp ()</i> , <br>  <a href="">ligne 2886 dans hotspot / share / runtime / thread.cpp</a> : <br><pre>   st-&gt; print_cr ("[" INTPTR_FORMAT "]", 
     (intptr_t) last_Java_sp () &amp; ~ right_n_bits (12));
</pre><br>  Pour les vidages de threads simples, ces informations sont presque inutiles.  Cependant, dans des cas complexes, SP peut <br>  être utilisé pour suivre les serrures. </td></tr></tbody></table><br><h4>  Statut du flux </h4><br>  La deuxième ligne est l'état actuel du flux.  Les états de flux possibles sont répertoriés dans l'énumération: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Thread.State</a> : <br><br>  NOUVEAU <br>  RUNNABLE <br>  BLOQUÉ <br>  EN ATTENTE <br>  TIMED_WAITING <br>  RÉSILIÉ <br><br>  Voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">documentation pour</a> plus de détails. <br><br><h4>  Trace de pile de threads </h4><br>  La section suivante contient la trace de pile du flux au moment où le vidage a été effectué.  Cette trace de pile est très similaire à une trace de pile, qui est levée par une exception non interceptée.  Et il contient les noms des classes et des chaînes qui ont été exécutées au moment de la formation du vidage.  Dans le cas du flux du gestionnaire de référence, nous ne voyons rien d'intéressant. <br><br>  Cependant, il y a quelque chose d'intéressant dans la trace de thread Thread-02 qui est différent de la trace standard: <br><br><pre> "Thread-0" # 12 prio = 5 os_prio = 0 tid = 0x00000250e54d1800 nid = 0xdec en attente d'entrée du moniteur [0x000000b82b4ff000]
    java.lang.Thread.State: BLOCKED (sur le moniteur d'objet)
     à DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - en attente de verrouillage &lt;0x00000000894465b0&gt; (un java.lang.Object)
     - verrouillé &lt;0x00000000894465a0&gt; (un java.lang.Object)
     à java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Synchroniseurs propriétaires verrouillés:
     - Aucun
</pre><br>  Dans la trace, nous voyons que des informations sur le verrou ont été ajoutées.  Ce thread attend un verrou sur l'objet avec l'adresse 0x00000000894465b0 (type d'objet java.lang.Object).  De plus, le thread lui-même détient le verrou avec l'adresse 0x00000000894465a0 (également un java.lang.Object).  Ces informations nous seront utiles ultérieurement pour le diagnostic de blocage. <br><br><h4>  Primitives de synchronisation capturées (synchroniseur propriétaire) </h4><br>  La dernière section répertorie les primitives de synchronisation capturées par le flux.  Ce sont des objets qui peuvent être utilisés pour synchroniser des threads, par exemple des verrous. <br><br>  Selon la documentation Java officielle, <strong>Ownable Synchronizer</strong> est le descendant de <i>AbstractOwnableSynchronizer</i> (ou sa sous-classe), qui peut être exclusivement capturé par le flux à des fins de synchronisation. <br><br>  <i>ReentrantLock</i> et <i>write-lock</i> , mais pas le <i>read-lock</i> de la classe <i>ReentrantReadWriteLock</i> sont deux bons exemples de tels «synchroniseurs propriétaires» offerts par la plate-forme. <br><br>  Pour plus d'informations à ce sujet, vous pouvez vous référer à ce <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">poster</a> . <br><br><h4>  Threads JVM </h4><br>  La section suivante du vidage contient des informations sur les threads techniques JVM qui ne font pas partie de l'application et sont associés aux threads du système d'exploitation.  Parce que  ces flux fonctionnent en dehors de l'application, ils n'ont pas d'identifiants de flux.  Le plus souvent, ce sont des threads de garbage collector et d'autres threads techniques JVM: <br><br><pre> "VM Thread" os_prio = 2 tid = 0x00000250e496d800 nid = 0x1920 exécutable  
 "GC Thread # 0" os_prio = 2 tid = 0x00000250c35b5800 nid = 0x310c exécutable  
 "GC Thread # 1" os_prio = 2 tid = 0x00000250c35b8000 nid = 0x12b4 exécutable  
 "GC Thread # 2" os_prio = 2 tid = 0x00000250c35ba800 nid = 0x43f8 exécutable  
 "GC Thread # 3" os_prio = 2 tid = 0x00000250c35c0800 nid = 0x20c0 exécutable  
 "G1 Main Marker" os_prio = 2 tid = 0x00000250c3633000 nid = 0x4068 exécutable  
 "G1 Conc # 0" os_prio = 2 tid = 0x00000250c3636000 nid = 0x3e28 exécutable  
 "G1 Affiner # 0" os_prio = 2 tid = 0x00000250c367e000 nid = 0x3c0c exécutable  
 "G1 Affiner # 1" os_prio = 2 tid = 0x00000250e47fb800 nid = 0x3890 exécutable  
 "G1 Affiner # 2" os_prio = 2 tid = 0x00000250e47fc000 nid = 0x32a8 exécutable  
 "G1 Affiner # 3" os_prio = 2 tid = 0x00000250e47fd800 nid = 0x3d00 exécutable  
 "G1 Young RemSet Sampling" os_prio = 2 tid = 0x00000250e4800800 nid = 0xef4 exécutable  
 "Thread de tâche périodique VM" os_prio = 2 tid = 0x00000250e54d6800 nid = 0x3468 en attente de condition
</pre><br><h4>  Liens mondiaux JNI </h4><br>  Cette section indique le nombre de références globales utilisées par la JVM via JNI.  Ces liens ne sont pas desservis par le garbage collector et peuvent provoquer une fuite de mémoire dans certaines circonstances. <br><br><pre> Références mondiales JNI: 2
</pre><br>  Dans la plupart des cas simples, ces informations ne sont pas utilisées.  Cependant, l'importance des références mondiales doit être comprise.  Voir cet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">article pour</a> plus de détails. <br><br><h4>  Fils bloqués </h4><br>  La dernière section contient des informations sur les blocages trouvés. <br>  Si ceux-ci ne sont pas trouvés, la section sera vide.  Parce que  Nous avons spécifiquement développé une application avec des verrous, dans notre cas cette section est.  Un verrou a été détecté lors du vidage et affiche le message suivant: <br><br><pre> Trouvé un blocage au niveau Java:
 ===============================
 "Thread-0":
   en attente de verrouillage du moniteur 0x00000250e4982480 (objet 0x00000000894465b0, un java.lang.Object),
   qui est détenu par "Thread-1"
 "Thread-1":
   en attente de verrouillage du moniteur 0x00000250e4982380 (objet 0x00000000894465a0, un java.lang.Object),
   qui est détenu par "Thread-0"
 Informations sur la pile Java pour les threads répertoriés ci-dessus:
 =================================================== =
 "Thread-0":
     à DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - en attente de verrouillage &lt;0x00000000894465b0&gt; (un java.lang.Object)
     - verrouillé &lt;0x00000000894465a0&gt; (un java.lang.Object)
     à java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 "Thread-1":
     à DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - en attente de verrouillage &lt;0x00000000894465a0&gt; (un java.lang.Object)
     - verrouillé &lt;0x00000000894465b0&gt; (un java.lang.Object)
     à java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 Trouvé 1 blocage.
</pre><br>  La première sous-section décrit le scénario de blocage: <br><br>  Thread-0 s'attend à pouvoir capturer le moniteur (c'est un accès au bloc <i>synchronisé (secondResource)</i> dans notre application), en même temps ce thread tient un moniteur qui essaie de capturer le Thread-1 (c'est accéder au même fragment de code: <i>synchronized (secondResource )</i> dans notre application). <br><br>  Cette serrure circulaire est autrement appelée <strong>impasse</strong> .  Dans l'image ci-dessous <br>  cette situation est présentée sous forme graphique: <br><br><img src="https://habrastorage.org/webt/11/yd/kr/11ydkrm0xkbw8aqxb8t71kypskg.png"><br><br>  Dans la deuxième sous-section, la trace de pile est donnée pour les deux threads bloqués. <br><br>  Cette trace de pile nous permet de suivre le fonctionnement de chaque thread jusqu'à ce qu'un verrouillage se produise. <br>  Dans notre cas, si nous regardons la ligne: <br><br>  <i>à DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)</i> , alors nous verrons la partie problématique du code: <br><br><pre> printLockedResource (secondResource);
</pre><br>  Cette ligne est la première ligne du bloc synchronisé, qui est la raison du verrouillage, et nous indique que la synchronisation sur la seconde ressource est la raison du verrouillage mutuel.  Pour remédier à la situation, nous devons nous assurer que les deux threads ont le même ordre de synchronisation sur les ressources resourceA et resourceB.  Si nous le faisons, nous arriverons à l'application suivante: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br>  Cette application se terminera sans verrouillage, et par conséquent, nous obtiendrons la sortie suivante (notez que les adresses de la classe Object ont changé): <br><br><pre> Thread-0: ressource verrouillée -&gt; java.lang.Object@1ad895d1
 Thread-0: ressource verrouillée -&gt; java.lang.Object@6e41d7dd
 Thread-1: ressource verrouillée -&gt; java.lang.Object@1ad895d1
 Thread-1: ressource verrouillée -&gt; java.lang.Object@6e41d7dd
</pre><br>  ,   ,   thread dump,           .        (     deadlock-).      ,   . <br><br><h3>    Thread Dump- </h3><br>         . <br><br>   JVM       .         (     ,   ). <br><br>         . <br><br>       - — Thread Dump Analyzers (TDAs).    Java thread dump-     - ,     .  ,           . ,        . <br><br>        TDA: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">fastThread</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Spotify TDA</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">IBM Thread and Monitor Dump Analyze for Java</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">irockel TDA</a> </li></ul><br>        .               . <br><br><h4>  Conclusion </h4><br> Thread dump- —      Java-,       .     ,           . <br><br>        deadlock,    .         .     ,           — . <br><br>   ,   Java-     thread dump-.     ,             . <br><br> , thread dump —   « »   ,        ,      Java-. <br><br> <i>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> Java</a>     .       ,        deadlock- .</i> <br><br> <i>      ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427513/">https://habr.com/ru/post/fr427513/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427499/index.html">De quoi parlent-ils dans le support technique du streamer vidéo?</a></li>
<li><a href="../fr427501/index.html">Seymour Papert: Hard Fun</a></li>
<li><a href="../fr427505/index.html">Présomption d'esprit</a></li>
<li><a href="../fr427507/index.html">Seymour Papert: la délicieuse découverte de "rien"</a></li>
<li><a href="../fr427509/index.html">Serveurs Web: expérience et pratique de Southbridge</a></li>
<li><a href="../fr427517/index.html">Aperçu des rapports Joker 2018 les plus intéressants: version EastBanc Technologies</a></li>
<li><a href="../fr427519/index.html">@Kubernetes Meetup at Mail.Ru Group: le 29 octobre et toujours</a></li>
<li><a href="../fr427521/index.html">Prix ​​révolutionnaire 2019. Annonce des lauréats des prix scientifiques Milner, Brin et Zuckerberg.</a></li>
<li><a href="../fr427523/index.html">Succès de couverture</a></li>
<li><a href="../fr427525/index.html">Intel Core 9th Gen en chiffres et benchmarks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>