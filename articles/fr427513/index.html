<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ù£Ô∏è üë®‚Äçüî¨ üå≥ Comment analyser le vidage des threads üë©üèª‚Äçüéì üë©üèø‚Äçüè´ üë©üèæ‚Äçü§ù‚Äçüë©üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a pas mal de sujets sur les internes de la JVM dans le programme de cours Java Developer . Nous comprenons les m√©canismes de fonctionnement des c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment analyser le vidage des threads</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/427513/">  <i>Il <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">y a</a> pas mal de sujets sur les internes de la JVM dans le programme de cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java Developer</a> .</i>  <i>Nous comprenons les m√©canismes de fonctionnement des collections, bytecode, garbage collectors, etc.</i>  <i>Aujourd'hui, nous offrons votre attention sur la traduction d'un article assez int√©ressant sur le vidage de threads.</i>  <i>Qu'est-ce que c'est, comment l'obtenir et comment l'utiliser.</i> <br><br>  Vous voulez apprendre √† analyser le vidage des threads?  Allez sous le chat pour en savoir plus sur la fa√ßon d'obtenir un vidage de threads en Java et que faire avec plus tard. <br><a name="habracut"></a><br>  La plupart des applications Java modernes sont multithread.  Le multithreading peut √©tendre consid√©rablement les fonctionnalit√©s de l'application, tout en introduisant une complexit√© importante. <br><br>  Dans une application monothread, toutes les ressources (m√©moire partag√©e, op√©rations d'entr√©e / sortie, etc.) peuvent √™tre utilis√©es sans synchronisation, car  √† un moment donn√©, un seul thread utilise la ressource. <br><br>  Dans le cas d'applications multi-thread, il est n√©cessaire de trouver un compromis entre compliquer le programme et une augmentation possible des performances, lorsque plusieurs threads peuvent utiliser tous les processeurs (CPU) de base disponibles (souvent plus d'un).  Si tout est fait correctement, alors en utilisant le multithreading (formalis√© dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la loi d'Amdahl</a> ), vous pouvez obtenir une augmentation significative des performances de l'application.  Cependant, il faut se rappeler de fournir un acc√®s simultan√© de plusieurs flux √† une ressource partag√©e.  Dans la plupart des cas, les frameworks tels que Spring encapsulent le travail avec les threads et masquent de nombreux d√©tails techniques aux utilisateurs.  Cependant, dans le cas de l'utilisation de cadres complexes modernes, quelque chose peut mal tourner, et nous, en tant qu'utilisateurs, rencontrerons des bogues multithreads difficiles √† r√©soudre. <br><br>  Heureusement, Java est √©quip√© d'un m√©canisme sp√©cial pour obtenir des informations sur l'√©tat actuel de tous les threads √† un moment donn√© - il s'agit d'un vidage de thread (une sorte d'instantan√©).  Dans cet article, nous apprendrons comment obtenir un vidage de thread pour une application de taille r√©aliste et comment analyser ce vidage. <br><br>  Il est suppos√© que le lecteur dispose d'informations de base sur la programmation multithread et qu'il est conscient des probl√®mes de synchronisation des threads et d'utilisation des ressources partag√©es.  N√©anmoins, il ne sera pas superflu de rafra√Æchir certains termes et concepts de base. <br><br><h4>  Terminologie de base </h4><br>  √Ä premi√®re vue, les vidages de threads Java peuvent sembler √™tre une ¬´lettre chinoise¬ª, les concepts suivants sont essentiels pour la comprendre.  En g√©n√©ral, r√©p√©tons les termes de base du multithreading, que nous utiliserons pour analyser les vidages. <br><br><ul><li> <strong>Le thread</strong> ou le thread est une unit√© multithread discr√®te g√©r√©e par la machine virtuelle Java (JVM).  Les threads JVM correspondent aux threads du syst√®me d'exploitation (OS) - threads natifs, qui impl√©mentent le m√©canisme d'ex√©cution de code. <br><br>  Chaque thread a un identifiant et un nom uniques.  Les flux peuvent √™tre des "d√©mons" et "pas des d√©mons". <br><br>  Le programme se termine lorsque tous les threads non d√©mon se terminent ou <i>lorsque la</i> m√©thode <i>Runtime.exit</i> est <i>appel√©e</i> .  Les ¬´d√©mons¬ª qui travaillent n'affectent pas l'ach√®vement du programme.  C'est-√†-dire  La JVM attend que tous les ¬´non-d√©mons¬ª soient finalis√©s et ferm√©s, ils ne font pas attention aux ¬´non-d√©mons¬ª. <br><br>  Pour plus d'informations, consultez la documentation de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classe Thread</a> . <br>  Un flux peut se trouver dans l'un des √©tats suivants: <br><br><ul><li>  <strong>Fil vivant</strong> ou ¬´en direct¬ª - un fil qui fonctionne (√©tat normal). </li><li>  <strong>Thread bloqu√©</strong> ou ¬´bloqu√©¬ª - un thread qui a tent√© d'entrer dans la section synchronis√©e (synchronis√©), mais un autre thread a d√©j√† r√©ussi √† entrer ce bloc en premier, et tous les threads suivants qui tentent d'entrer dans le m√™me bloc sont bloqu√©s. </li><li>  <strong>Fil d'attente</strong> ou ¬´en attente¬ª - un fil qui a appel√© la m√©thode d' <i>attente</i> (√©ventuellement avec un d√©lai d'expiration) et attend maintenant qu'une autre m√©thode s'ex√©cute <i>notifie</i> ou <i>nonifieAll</i> sur le m√™me objet. <br><br>  Veuillez noter que le thread n'est pas consid√©r√© comme ¬´en attente¬ª s'il a appel√© wait with a timeout et que ce d√©lai a expir√©. </li><li>  <strong>Fil dormant</strong> ou "dormant" - un fil qui n'est pas en cours d'ex√©cution, car  effectu√© la m√©thode Thread.sleep (indiquant la dur√©e du "sommeil"). </li></ul></li><li>  <strong>Monitor</strong> est un m√©canisme utilis√© par la JVM pour fournir un acc√®s multithread √† un seul objet.  Le m√©canisme est d√©marr√© √† l'aide du <i>mot cl√© synchronis√©</i> sp√©cial. <br><br>  Chaque objet en Java a un moniteur avec lequel le thread peut √™tre synchronis√©, c'est-√†-dire  d√©finir un verrou, ce qui garantit qu'aucun autre thread n'acc√©dera √† cet objet tant que le verrou n'est pas lib√©r√©, c'est-√†-dire  thread - le propri√©taire du verrou ne quittera pas le bloc <i>synchronis√©</i> . <br><br>  Voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">section Synchronisation (17.1) de la sp√©cification Java Langauge (JLS) pour plus d'informations</a> . <br></li><li>  <strong>Le blocage</strong> est une situation dans laquelle un thread, par exemple A, bloque une ressource, il a besoin d'une autre ressource qui est bloqu√©e par un autre thread, par exemple B. Le flux B ne lib√®re pas cette ressource, car  Pour terminer une certaine op√©ration, il a besoin d'une ressource qui est bloqu√©e par le thread A. Il s'av√®re que le thread A attend que la ressource soit d√©verrouill√©e par le thread B, qui attend qu'une autre ressource soit d√©verrouill√©e par le thread A. Et, par cons√©quent, les threads attendent les uns les autres.  Par cons√©quent, le programme entier se bloque et attend que les threads se d√©verrouillent et continuent de fonctionner.  Il peut y avoir plusieurs threads dans une impasse.  Ce probl√®me est bien connu sous le nom de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´probl√®me des philosophes de la restauration¬ª</a> . <br><br><img src="https://habrastorage.org/webt/8t/ll/jb/8tlljb_n-e80_dk_0uayobgil_s.png"><br></li><li>  <strong>Livelock</strong> est une situation o√π le thread A force le thread B √† effectuer une action, ce qui oblige le thread A √† effectuer l'action initiale, ce qui provoque √† nouveau l'action du thread B. Une d√©pendance cyclique est obtenue.  Cela peut √™tre imagin√© comme un chien qui court apr√®s sa queue.  Comme pour <i>Deadlock</i> , dans une situation Livelock, le programme ne progresse pas, c'est-√†-dire  n'effectue pas d'action utile, cependant, dans cette situation, les threads ne sont pas bloqu√©s. <br></li></ul><br>  La terminologie pr√©sent√©e n'est pas exhaustive pour d√©crire le monde du multithreading, mais cela suffit pour commencer √† analyser les vidages de threads. <br><br>  Des informations plus d√©taill√©es peuvent √™tre trouv√©es dans ces sources: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Section 17 du JLS</a> et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la concurrence Java en pratique</a> <br><br>  En utilisant ces concepts simples sur le flux en Java, nous pouvons cr√©er une application de test.  Pour cette application, nous compilerons le vidage des threads.  Nous analyserons le vidage r√©sultant et extrairons des informations utiles sur les flux d'application actuels. <br><br><h4>  Cr√©ation d'un exemple de programme </h4><br>  Avant de cr√©er un vidage de thread, nous devons d√©velopper une application Java.  Le traditionnel "bonjour, le monde!"  trop simple pour notre objectif, et un vidage de taille moyenne de l'application peut √™tre trop compliqu√© √† d√©montrer.  Sur cette base, nous allons cr√©er une application assez simple dans laquelle deux threads sont cr√©√©s.  Et les fils tombent dans l'impasse: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceB, resourceA)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br>  Ce programme cr√©e deux ressources: resourceA et resourceB et d√©marre deux threads: threadLockingResourceAFirst et threadLockingResourceBFirst, qui se bloquent mutuellement les ressources. <br><br>  La cause du blocage est un blocage ¬´crois√©¬ª des ressources par les threads. <br><br>  La raison de l'occurrence de l'impasse est une tentative de saisie "mutuelle" des ressources, c'est-√†-dire  Le thread threadLockingResourceAFirst capture la ressource resourceA, le thread threadLockingResourceBFirst capture la ressource resourceB.  Apr√®s cela, threadLockingResourceAFirst, sans lib√©rer sa ressource, tente de capturer resourceB, et threadLockingResourceBFirst, sans lib√©rer sa ressource, tente de capturer resourceA.  Par cons√©quent, les threads sont bloqu√©s.  Un d√©lai de 1 s a √©t√© ajout√© pour garantir le blocage.  Les threads attendent la lib√©ration des ressources n√©cessaires, mais cela ne se produira jamais. <br><br>  La sortie du programme sera comme ceci (les chiffres apr√®s java.lang.Object @ seront diff√©rents pour chaque lancement): <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Thread-0</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">locked</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">resource</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Object</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">149bc794</span></span> Thread-<span class="hljs-number"><span class="hljs-number">1</span></span>: locked resource -&gt; java.lang.Object@<span class="hljs-number"><span class="hljs-number">17</span></span>c10009</code> </pre> <br>  Apr√®s la sortie de ces messages, le programme aura l'air d'√™tre en cours d'ex√©cution (le processus ex√©cutant ce programme n'est pas termin√©), tandis que le programme ne fait aucun travail.  Voici √† quoi ressemble l'impasse dans la pratique.  Pour r√©soudre le probl√®me, nous devons cr√©er manuellement un vidage de la bande de roulement et analyser l'√©tat des threads. <br><br><h4>  G√©n√©ration de vidage de thread </h4><br>  En pratique, un programme Java peut se bloquer lors de la cr√©ation d'un vidage de thread.  Cependant, dans certains cas (par exemple, dans le cas de blocages), le programme ne se termine pas et le vidage de thread ne se cr√©e pas, il se bloque simplement.  Pour cr√©er un vidage de ces programmes bloqu√©s, vous devez d'abord trouver l'identifiant du processus du programme, c'est-√†-dire  ID de processus (PID).  Pour ce faire, vous pouvez utiliser l'utilitaire JVM Process Status (JPS) qui, √† partir de la version 7, fait partie du kit de d√©veloppement Java (JDK).  Pour trouver le processus PID de notre programme bloqu√©, nous ex√©cutons simplement jps dans le terminal (Windows ou Linux): <br><br><pre> <code class="hljs ruby">$ jps <span class="hljs-number"><span class="hljs-number">11568</span></span> DeadlockProgram <span class="hljs-number"><span class="hljs-number">15584</span></span> Jps <span class="hljs-number"><span class="hljs-number">15636</span></span></code> </pre> <br>  La premi√®re colonne est l'identifiant de la machine virtuelle locale (Local VM ID, c'est-√†-dire lvmid) pour le processus Java en cours d'ex√©cution.  Dans le contexte de la JVM locale, lvmid pointe vers le PID du processus Java. <br><br>  Il convient de noter que cette valeur est susceptible de diff√©rer de la valeur ci-dessus.  La deuxi√®me colonne est le nom de l'application, qui peut pointer vers le nom de la classe principale, du fichier jar ou √©gal √† "Inconnu".  Tout d√©pend de la fa√ßon dont l'application a √©t√© lanc√©e. <br><br>  Dans notre cas, le nom de l'application DeadlockProgram est le nom des principales classes qui ont √©t√© lanc√©es au d√©marrage du programme.  Dans l'exemple ci-dessus PID du programme 11568, ces informations sont suffisantes pour g√©n√©rer un vidage de thread.  Pour g√©n√©rer le vidage, nous utiliserons l'utilitaire <strong>jstack</strong> , qui fait partie du JDK, √† partir de la version 7. Pour obtenir le vidage, nous <strong>passerons le</strong> PID de notre programme √† <strong>jstack</strong> et sp√©cifierons le drapeau -l (cr√©ant une longue liste).  La sortie de l'utilitaire sera redirig√©e vers un fichier texte, c'est-√†-dire  thread_dump.txt: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">jstack</span></span> -l <span class="hljs-number"><span class="hljs-number">11568</span></span> &gt; thread_dump.txt</code> </pre> <br>  Le fichier thread_dump.txt r√©sultant contient le vidage de thread de notre programme bloqu√© et contient des informations importantes pour diagnostiquer les causes de blocage. <br><br>  Si le JDK est utilis√© jusqu'√† la version 7, pour g√©n√©rer un vidage, vous pouvez utiliser l'utilitaire Linux - <strong>kill</strong> avec l'indicateur -3.  L'appel de kill -3 enverra au programme un signal SIGQUIT. <br><br>  Dans notre cas, l'appel sera comme ceci: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">kill</span></span> <span class="hljs-number"><span class="hljs-number">-3</span></span> <span class="hljs-number"><span class="hljs-number">11568</span></span></code> </pre> <br><h4>  Analyse simple de vidage de thread </h4><br>  En ouvrant le fichier thread_dump.txt, nous verrons quelque chose comme ceci: <br><br><pre> 2018-06-19 16:44:44
 Sauvegarde compl√®te du thread Java VM HotSpot (TM) 64 bits Server (10.0.1 + 10 mode mixte):
 Informations sur la classe de threads SMR:
 _java_thread_list = 0x00000250e5488a00, longueur = 13, elements = {
 0x00000250e4979000, 0x00000250e4982800, 0x00000250e52f2800, 0x00000250e4992800,
 0x00000250e4995800, 0x00000250e49a5800, 0x00000250e49ae800, 0x00000250e5324000,
 0x00000250e54cd800, 0x00000250e54cf000, 0x00000250e54d1800, 0x00000250e54d2000,
 0x00000250e54d0800
 }
 "Reference Handler" # 2 daemon prio = 10 os_prio = 2 tid = 0x00000250e4979000 nid = 0x3c28 en attente √† la condition [0x000000b82a9ff000]
    java.lang.Thread.State: RUNNABLE
     √† java.lang.ref.Reference.waitForReferencePendingList (java.base@10.0.1/Native Method)
     √† java.lang.ref.Reference.processPendingReferences (java.base@10.0.1/Reference.java: 174)
     √† java.lang.ref.Reference.access 000 $ (java.base@10.0.1/Reference.java: 44)
     √† java.lang.ref.Reference $ ReferenceHandler.run (java.base@10.0.1/Reference.java: 138)
    Synchroniseurs propri√©taires verrouill√©s:
     - Aucun
 "Finalizer" # 3 daemon prio = 8 os_prio = 1 tid = 0x00000250e4982800 nid = 0x2a54 dans Object.wait () [0x000000b82aaff000]
    java.lang.Thread.State: WAITING (sur le moniteur d'objet)
     √† java.lang.Object.wait (java.base@10.0.1/Native Method)
     - en attente sur &lt;0x0000000089509410&gt; (un java.lang.ref.ReferenceQueue $ Lock)
     √† java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 151)
     - en attente de re-verrouillage en attente () &lt;0x0000000089509410&gt; (un java.lang.ref.ReferenceQueue $ Lock)
     √† java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 172)
     √† java.lang.ref.Finalizer $ FinalizerThread.run (java.base@10.0.1/Finalizer.java: 216)
    Synchroniseurs propri√©taires verrouill√©s:
     - Aucun
 "Signal Dispatcher" # 4 d√©mon prio = 9 os_prio = 2 tid = 0x00000250e52f2800 nid = 0x2184 ex√©cutable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Synchroniseurs propri√©taires verrouill√©s:
     - Aucun
 "Attach Listener" # 5 daemon prio = 5 os_prio = 2 tid = 0x00000250e4992800 nid = 0x1624 en attente √† la condition [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Synchroniseurs propri√©taires verrouill√©s:
     - Aucun
 "C2 CompilerThread0" # 6 d√©mon prio = 9 os_prio = 2 tid = 0x00000250e4995800 nid = 0x4198 en attente √† la condition [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Aucune t√¢che de compilation
    Synchroniseurs propri√©taires verrouill√©s:
     - Aucun
 "C2 CompilerThread1" # 7 d√©mon prio = 9 os_prio = 2 tid = 0x00000250e49a5800 nid = 0x3b98 en attente √† la condition [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Aucune t√¢che de compilation
    Synchroniseurs propri√©taires verrouill√©s:
     - Aucun
 "C1 CompilerThread2" # 8 d√©mon prio = 9 os_prio = 2 tid = 0x00000250e49ae800 nid = 0x1a84 en attente √† la condition [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Aucune t√¢che de compilation
    Synchroniseurs propri√©taires verrouill√©s:
     - Aucun
 "Thread Sweeper" # 9 daemon prio = 9 os_prio = 2 tid = 0x00000250e5324000 nid = 0x5f0 ex√©cutable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Synchroniseurs propri√©taires verrouill√©s:
     - Aucun
 "Service Thread" # 10 daemon prio = 9 os_prio = 0 tid = 0x00000250e54cd800 nid = 0x169c ex√©cutable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Synchroniseurs propri√©taires verrouill√©s:
     - Aucun
 D√©mon "Common-Cleaner" # 11 prio = 8 os_prio = 1 tid = 0x00000250e54cf000 nid = 0x1610 dans Object.wait () [0x000000b82b2fe000]
    java.lang.Thread.State: TIMED_WAITING (sur le moniteur d'objet)
     √† java.lang.Object.wait (java.base@10.0.1/Native Method)
     - en attente sur &lt;0x000000008943e600&gt; (un java.lang.ref.ReferenceQueue $ Lock)
     √† java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 151)
     - en attente de re-verrouillage dans wait () &lt;0x000000008943e600&gt; (un java.lang.ref.ReferenceQueue $ Lock)
     √† jdk.internal.ref.CleanerImpl.run (java.base@10.0.1/CleanerImpl.java: 148)
     √† java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
     √† jdk.internal.misc.InnocuousThread.run (java.base@10.0.1/InnocuousThread.java: 134)
    Synchroniseurs propri√©taires verrouill√©s:
     - Aucun
 "Thread-0" # 12 prio = 5 os_prio = 0 tid = 0x00000250e54d1800 nid = 0xdec en attente d'entr√©e du moniteur [0x000000b82b4ff000]
    java.lang.Thread.State: BLOCKED (sur le moniteur d'objet)
     √† DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - en attente de verrouillage &lt;0x00000000894465b0&gt; (un java.lang.Object)
     - verrouill√© &lt;0x00000000894465a0&gt; (un java.lang.Object)
     √† java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Synchroniseurs propri√©taires verrouill√©s:
     - Aucun
 "Thread-1" # 13 prio = 5 os_prio = 0 tid = 0x00000250e54d2000 nid = 0x415c en attente d'entr√©e du moniteur [0x000000b82b5ff000]
    java.lang.Thread.State: BLOCKED (sur le moniteur d'objet)
     √† DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - en attente de verrouillage &lt;0x00000000894465a0&gt; (un java.lang.Object)
     - verrouill√© &lt;0x00000000894465b0&gt; (un java.lang.Object)
     √† java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Synchroniseurs propri√©taires verrouill√©s:
     - Aucun
 "DestroyJavaVM" # 14 prio = 5 os_prio = 0 tid = 0x00000250e54d0800 nid = 0x2b8c en attente √† la condition [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Synchroniseurs propri√©taires verrouill√©s:
     - Aucun
 "VM Thread" os_prio = 2 tid = 0x00000250e496d800 nid = 0x1920 ex√©cutable  
 "GC Thread # 0" os_prio = 2 tid = 0x00000250c35b5800 nid = 0x310c ex√©cutable  
 "GC Thread # 1" os_prio = 2 tid = 0x00000250c35b8000 nid = 0x12b4 ex√©cutable  
 "GC Thread # 2" os_prio = 2 tid = 0x00000250c35ba800 nid = 0x43f8 ex√©cutable  
 "GC Thread # 3" os_prio = 2 tid = 0x00000250c35c0800 nid = 0x20c0 ex√©cutable  
 "G1 Main Marker" os_prio = 2 tid = 0x00000250c3633000 nid = 0x4068 ex√©cutable  
 "G1 Conc # 0" os_prio = 2 tid = 0x00000250c3636000 nid = 0x3e28 ex√©cutable  
 "G1 Affiner # 0" os_prio = 2 tid = 0x00000250c367e000 nid = 0x3c0c ex√©cutable  
 "G1 Affiner # 1" os_prio = 2 tid = 0x00000250e47fb800 nid = 0x3890 ex√©cutable  
 "G1 Affiner # 2" os_prio = 2 tid = 0x00000250e47fc000 nid = 0x32a8 ex√©cutable  
 "G1 Affiner # 3" os_prio = 2 tid = 0x00000250e47fd800 nid = 0x3d00 ex√©cutable  
 "G1 Young RemSet Sampling" os_prio = 2 tid = 0x00000250e4800800 nid = 0xef4 ex√©cutable  
 "Thread de t√¢che p√©riodique VM" os_prio = 2 tid = 0x00000250e54d6800 nid = 0x3468 en attente de condition  
 R√©f√©rences mondiales JNI: 2
 Trouv√© un blocage au niveau Java:
 ===============================
 "Thread-0":
   en attente de verrouillage du moniteur 0x00000250e4982480 (objet 0x00000000894465b0, un java.lang.Object),
   qui est d√©tenu par "Thread-1"
 "Thread-1":
   en attente de verrouillage du moniteur 0x00000250e4982380 (objet 0x00000000894465a0, un java.lang.Object),
   qui est d√©tenu par "Thread-0"
 Informations sur la pile Java pour les threads r√©pertori√©s ci-dessus:
 =================================================== =
 "Thread-0":
     √† DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - en attente de verrouillage &lt;0x00000000894465b0&gt; (un java.lang.Object)
     - verrouill√© &lt;0x00000000894465a0&gt; (un java.lang.Object)
     √† java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 "Thread-1":
     √† DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - en attente de verrouillage &lt;0x00000000894465a0&gt; (un java.lang.Object)
     - verrouill√© &lt;0x00000000894465b0&gt; (un java.lang.Object)
     √† java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 Trouv√© 1 blocage.
</pre><br><h3>  Informations introductives </h3><br>  Bien qu'√† premi√®re vue ce fichier puisse sembler trop compliqu√© et d√©routant, en r√©alit√© il est assez simple si vous le d√©montez par √©tapes √©tape par √©tape. <br><br>  La premi√®re ligne indique l'heure √† laquelle le vidage a √©t√© form√©, la seconde - des informations de diagnostic sur la machine virtuelle Java, sur lesquelles le vidage a √©t√© re√ßu: <br><br><pre> <code class="hljs css">2018<span class="hljs-selector-tag"><span class="hljs-selector-tag">-06-19</span></span> 16<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Full</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">thread</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dump</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Java</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">HotSpot</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TM</span></span>) 64<span class="hljs-selector-tag"><span class="hljs-selector-tag">-Bit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Server</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">VM</span></span> (10<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span>+10 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mixed</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mode</span></span>):</code> </pre> <br>  Il n'y a aucune information de flux dans cette section.  Ici, le contexte g√©n√©ral du syst√®me dans lequel le vidage a √©t√© collect√© est d√©fini. <br><br><h4>  Informations g√©n√©rales sur le flux </h4><br>  La section suivante fournit des informations sur les unit√©s d'ex√©cution qui √©taient en cours d'ex√©cution dans le syst√®me au moment de la collecte de vidage: <br><br><pre> Informations sur la classe de threads SMR:
 _java_thread_list = 0x00000250e5488a00, longueur = 13, elements = {
 0x00000250e4979000, 0x00000250e4982800, 0x00000250e52f2800, 0x00000250e4992800,
 0x00000250e4995800, 0x00000250e49a5800, 0x00000250e49ae800, 0x00000250e5324000,
 0x00000250e54cd800, 0x00000250e54cf000, 0x00000250e54d1800, 0x00000250e54d2000,
 0x00000250e54d0800
 }
</pre><br>  La section suivante r√©pertorie: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Informations sur la r√©cup√©ration de m√©moire s√©curis√©e (SMR)</a> <br><br>  Il contient des informations sur les threads en dehors de la JVM, c'est-√†-dire  ce ne sont pas des threads de machine virtuelle ou des threads de r√©cup√©ration de place.  Si vous regardez les adresses de ces threads, vous remarquerez qu'elles correspondent √† la valeur de <i>tid</i> - l'adresse ¬´naturelle, de fer¬ª (native) dans le syst√®me d'exploitation, et non l'ID de thread. <br><br>  Les points de suspension sont utilis√©s pour masquer les informations redondantes: <br><br><pre> "Gestionnaire de r√©f√©rence" # 2 ... tid = 0x00000250e4979000 ...
 "Finaliseur" # 3 ... tid = 0x00000250e4982800 ...
 "Signal Dispatcher" # 4 ... tid = 0x00000250e52f2800 ...
 "Attach Listener" # 5 ... tid = 0x00000250e4992800 ...
 "C2 CompilerThread0" # 6 ... tid = 0x00000250e4995800 ...
 "C2 CompilerThread1" # 7 ... tid = 0x00000250e49a5800 ...
 "C1 CompilerThread2" # 8 ... tid = 0x00000250e49ae800 ...
 "Fil de balayage" # 9 ... tid = 0x00000250e5324000 ...
 "Fil de service" # 10 ... tid = 0x00000250e54cd800 ...
 "Common-Cleaner" # 11 ... tid = 0x00000250e54cf000 ...
 "Thread-0" # 12 ... tid = 0x00000250e54d1800 ...
 "Thread-1" # 13 ... tid = 0x00000250e54d2000 ...
 "DestroyJavaVM" # 14 ... tid = 0x00000250e54d0800 ...
</pre><br><h3>  Streams </h3><br>  Juste apr√®s le bloc SMR se trouve une liste de threads.  Le premier fil de notre liste est le gestionnaire de r√©f√©rence: <br><br><pre> "Reference Handler" # 2 daemon prio = 10 os_prio = 2 tid = 0x00000250e4979000 nid = 0x3c28 en attente √† la condition [0x000000b82a9ff000]
    java.lang.Thread.State: RUNNABLE
     √† java.lang.ref.Reference.waitForReferencePendingList (java.base@10.0.1/Native Method)
     √† java.lang.ref.Reference.processPendingReferences (java.base@10.0.1/Reference.java: 174)
     √† java.lang.ref.Reference.access 000 $ (java.base@10.0.1/Reference.java: 44)
     √† java.lang.ref.Reference $ ReferenceHandler.run (java.base@10.0.1/Reference.java: 138)
    Synchroniseurs propri√©taires verrouill√©s:
     - Aucun
</pre><br><h4>  Br√®ve description </h4><br>  La premi√®re ligne de chaque thread fournit une description g√©n√©rale.  La description contient les √©l√©ments suivants: <br><table><tbody><tr><th width="70">  Section </th><th width="100">  Exemple </th><th>  La description </th></tr><tr><td>  Nom </td><td>  "Gestionnaire de r√©f√©rence" </td><td>  Nom de flux lisible par l'homme.  Le nom peut √™tre sp√©cifi√© en appelant la m√©thode <i>setName</i> de l'objet <i>Thread</i> .  Et passez un appel √† <i>getName</i> </td></tr><tr><td>  Identifiant </td><td>  # 2 </td><td>  Un ID unique attribu√© √† chaque objet de la classe <i>Thread</i> .  L'ID est g√©n√©r√© pour les threads du syst√®me.  La valeur initiale est 1. Chaque thread nouvellement cr√©√© se voit attribuer son propre ID, pr√©c√©demment augment√© de 1. Cette propri√©t√© de thread en lecture seule peut √™tre obtenue √† l'aide de la fonction <i>getId</i> d' <i>un</i> objet de la classe <i>Thread</i> . </td></tr><tr><td>  Statut du d√©mon </td><td>  d√©mon </td><td>  Le drapeau est un signe que le fil est un d√©mon.  S'il s'agit d'un d√©mon, alors le drapeau sera mis.  Par exemple, le thread <i>-0 n'est</i> pas un d√©mon. </td></tr><tr><td>  Priorit√© </td><td>  prio = 10 </td><td>  La priorit√© num√©rique du flux Java.  Notez que cette priorit√© ne correspond pas n√©cessairement √† la priorit√© du thread associ√© dans le syst√®me d'exploitation.  Pour d√©finir la priorit√©, vous pouvez <br>  utiliser la m√©thode <i>setPriority</i> d' <i>un</i> objet de classe <i>Thread</i> , et pour obtenir <br>  M√©thode <i>getPriority</i> . </td></tr><tr><td>  Priorit√© du thread OS </td><td>  os_prio = 2 </td><td>  Thread prioritaire dans le syst√®me d'exploitation.  Cette priorit√© peut diff√©rer de celle attribu√©e au thread Java li√©. </td></tr><tr><td>  Adresse </td><td>  tid = 0x00000250e4979000 </td><td>  L'adresse du flux Java.  Cette adresse est un pointeur vers l'objet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">natif Java Native Interface (JNI)</a> de la classe <i>Thread</i> (un objet C ++ <i>Thread</i> qui est connect√© au thread Java via JNI).  Cette valeur est obtenue en pla√ßant un pointeur sur ce <br>  (l'objet C ++ associ√© √† ce thread Java) en entier.  Voir <br>  <a href="">ligne 879 dans hotspot / share / runtime / thread.cpp</a> : <br><pre> st-&gt; print ("tid =" INTPTR_FORMAT "", p2i (this));
</pre><br>  Bien que la cl√© de cet objet ( <i>tid</i> ) puisse ressembler √† un ID de flux, <br>  en fait, c'est l'adresse de l'objet connect√© <i>JNI C ++ Thread</i> , et ce n'est pas la valeur qui <br>  renvoie la m√©thode <i>getId</i> du <i>thread</i> Java. </td></tr><tr><td>  ID de thread du syst√®me d'exploitation </td><td>  nid = 0x3c28 </td><td>  Identificateur unique du thread du syst√®me d'exploitation auquel le thread Java est li√©. <br>  Cette valeur est sortie avec le code suivant: <br>  <a href="">ligne 42 dans hotspot / share / runtime / osThread.cpp</a> : <br><pre> st-&gt; print ("nid = 0x% x", thread_id ());
</pre><br></td></tr><tr><td>  Statut </td><td>  attente sous condition </td><td>  Statut lisible par l'homme du thread actuel. <br>  Cette ligne affiche des informations suppl√©mentaires sur le statut simple du flux (voir ci-dessous), qui peuvent √™tre <br>  utilis√© pour comprendre ce que le thread allait faire (c'est-√†-dire si le thread essayait d'obtenir un verrou <br>  ou en attendant que la condition de d√©verrouillage soit remplie). </td></tr><tr><td>  Dernier pointeur de pile Java connu </td><td>  [0x000000b82a9ff000] </td><td>  Le dernier pointeur de pile (SP) connu associ√© √† ce flux. <br>  Cette valeur est obtenue en utilisant du code C ++ natif m√©lang√© avec du code Java utilisant JNI.  La valeur est retourn√©e par la fonction <i>last_Java_sp ()</i> , <br>  <a href="">ligne 2886 dans hotspot / share / runtime / thread.cpp</a> : <br><pre>   st-&gt; print_cr ("[" INTPTR_FORMAT "]", 
     (intptr_t) last_Java_sp () &amp; ~ right_n_bits (12));
</pre><br>  Pour les vidages de threads simples, ces informations sont presque inutiles.  Cependant, dans des cas complexes, SP peut <br>  √™tre utilis√© pour suivre les serrures. </td></tr></tbody></table><br><h4>  Statut du flux </h4><br>  La deuxi√®me ligne est l'√©tat actuel du flux.  Les √©tats de flux possibles sont r√©pertori√©s dans l'√©num√©ration: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Thread.State</a> : <br><br>  NOUVEAU <br>  RUNNABLE <br>  BLOQU√â <br>  EN ATTENTE <br>  TIMED_WAITING <br>  R√âSILI√â <br><br>  Voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">documentation pour</a> plus de d√©tails. <br><br><h4>  Trace de pile de threads </h4><br>  La section suivante contient la trace de pile du flux au moment o√π le vidage a √©t√© effectu√©.  Cette trace de pile est tr√®s similaire √† une trace de pile, qui est lev√©e par une exception non intercept√©e.  Et il contient les noms des classes et des cha√Ænes qui ont √©t√© ex√©cut√©es au moment de la formation du vidage.  Dans le cas du flux du gestionnaire de r√©f√©rence, nous ne voyons rien d'int√©ressant. <br><br>  Cependant, il y a quelque chose d'int√©ressant dans la trace de thread Thread-02 qui est diff√©rent de la trace standard: <br><br><pre> "Thread-0" # 12 prio = 5 os_prio = 0 tid = 0x00000250e54d1800 nid = 0xdec en attente d'entr√©e du moniteur [0x000000b82b4ff000]
    java.lang.Thread.State: BLOCKED (sur le moniteur d'objet)
     √† DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - en attente de verrouillage &lt;0x00000000894465b0&gt; (un java.lang.Object)
     - verrouill√© &lt;0x00000000894465a0&gt; (un java.lang.Object)
     √† java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Synchroniseurs propri√©taires verrouill√©s:
     - Aucun
</pre><br>  Dans la trace, nous voyons que des informations sur le verrou ont √©t√© ajout√©es.  Ce thread attend un verrou sur l'objet avec l'adresse 0x00000000894465b0 (type d'objet java.lang.Object).  De plus, le thread lui-m√™me d√©tient le verrou avec l'adresse 0x00000000894465a0 (√©galement un java.lang.Object).  Ces informations nous seront utiles ult√©rieurement pour le diagnostic de blocage. <br><br><h4>  Primitives de synchronisation captur√©es (synchroniseur propri√©taire) </h4><br>  La derni√®re section r√©pertorie les primitives de synchronisation captur√©es par le flux.  Ce sont des objets qui peuvent √™tre utilis√©s pour synchroniser des threads, par exemple des verrous. <br><br>  Selon la documentation Java officielle, <strong>Ownable Synchronizer</strong> est le descendant de <i>AbstractOwnableSynchronizer</i> (ou sa sous-classe), qui peut √™tre exclusivement captur√© par le flux √† des fins de synchronisation. <br><br>  <i>ReentrantLock</i> et <i>write-lock</i> , mais pas le <i>read-lock</i> de la classe <i>ReentrantReadWriteLock</i> sont deux bons exemples de tels ¬´synchroniseurs propri√©taires¬ª offerts par la plate-forme. <br><br>  Pour plus d'informations √† ce sujet, vous pouvez vous r√©f√©rer √† ce <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">poster</a> . <br><br><h4>  Threads JVM </h4><br>  La section suivante du vidage contient des informations sur les threads techniques JVM qui ne font pas partie de l'application et sont associ√©s aux threads du syst√®me d'exploitation.  Parce que  ces flux fonctionnent en dehors de l'application, ils n'ont pas d'identifiants de flux.  Le plus souvent, ce sont des threads de garbage collector et d'autres threads techniques JVM: <br><br><pre> "VM Thread" os_prio = 2 tid = 0x00000250e496d800 nid = 0x1920 ex√©cutable  
 "GC Thread # 0" os_prio = 2 tid = 0x00000250c35b5800 nid = 0x310c ex√©cutable  
 "GC Thread # 1" os_prio = 2 tid = 0x00000250c35b8000 nid = 0x12b4 ex√©cutable  
 "GC Thread # 2" os_prio = 2 tid = 0x00000250c35ba800 nid = 0x43f8 ex√©cutable  
 "GC Thread # 3" os_prio = 2 tid = 0x00000250c35c0800 nid = 0x20c0 ex√©cutable  
 "G1 Main Marker" os_prio = 2 tid = 0x00000250c3633000 nid = 0x4068 ex√©cutable  
 "G1 Conc # 0" os_prio = 2 tid = 0x00000250c3636000 nid = 0x3e28 ex√©cutable  
 "G1 Affiner # 0" os_prio = 2 tid = 0x00000250c367e000 nid = 0x3c0c ex√©cutable  
 "G1 Affiner # 1" os_prio = 2 tid = 0x00000250e47fb800 nid = 0x3890 ex√©cutable  
 "G1 Affiner # 2" os_prio = 2 tid = 0x00000250e47fc000 nid = 0x32a8 ex√©cutable  
 "G1 Affiner # 3" os_prio = 2 tid = 0x00000250e47fd800 nid = 0x3d00 ex√©cutable  
 "G1 Young RemSet Sampling" os_prio = 2 tid = 0x00000250e4800800 nid = 0xef4 ex√©cutable  
 "Thread de t√¢che p√©riodique VM" os_prio = 2 tid = 0x00000250e54d6800 nid = 0x3468 en attente de condition
</pre><br><h4>  Liens mondiaux JNI </h4><br>  Cette section indique le nombre de r√©f√©rences globales utilis√©es par la JVM via JNI.  Ces liens ne sont pas desservis par le garbage collector et peuvent provoquer une fuite de m√©moire dans certaines circonstances. <br><br><pre> R√©f√©rences mondiales JNI: 2
</pre><br>  Dans la plupart des cas simples, ces informations ne sont pas utilis√©es.  Cependant, l'importance des r√©f√©rences mondiales doit √™tre comprise.  Voir cet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">article pour</a> plus de d√©tails. <br><br><h4>  Fils bloqu√©s </h4><br>  La derni√®re section contient des informations sur les blocages trouv√©s. <br>  Si ceux-ci ne sont pas trouv√©s, la section sera vide.  Parce que  Nous avons sp√©cifiquement d√©velopp√© une application avec des verrous, dans notre cas cette section est.  Un verrou a √©t√© d√©tect√© lors du vidage et affiche le message suivant: <br><br><pre> Trouv√© un blocage au niveau Java:
 ===============================
 "Thread-0":
   en attente de verrouillage du moniteur 0x00000250e4982480 (objet 0x00000000894465b0, un java.lang.Object),
   qui est d√©tenu par "Thread-1"
 "Thread-1":
   en attente de verrouillage du moniteur 0x00000250e4982380 (objet 0x00000000894465a0, un java.lang.Object),
   qui est d√©tenu par "Thread-0"
 Informations sur la pile Java pour les threads r√©pertori√©s ci-dessus:
 =================================================== =
 "Thread-0":
     √† DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - en attente de verrouillage &lt;0x00000000894465b0&gt; (un java.lang.Object)
     - verrouill√© &lt;0x00000000894465a0&gt; (un java.lang.Object)
     √† java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 "Thread-1":
     √† DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - en attente de verrouillage &lt;0x00000000894465a0&gt; (un java.lang.Object)
     - verrouill√© &lt;0x00000000894465b0&gt; (un java.lang.Object)
     √† java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 Trouv√© 1 blocage.
</pre><br>  La premi√®re sous-section d√©crit le sc√©nario de blocage: <br><br>  Thread-0 s'attend √† pouvoir capturer le moniteur (c'est un acc√®s au bloc <i>synchronis√© (secondResource)</i> dans notre application), en m√™me temps ce thread tient un moniteur qui essaie de capturer le Thread-1 (c'est acc√©der au m√™me fragment de code: <i>synchronized (secondResource )</i> dans notre application). <br><br>  Cette serrure circulaire est autrement appel√©e <strong>impasse</strong> .  Dans l'image ci-dessous <br>  cette situation est pr√©sent√©e sous forme graphique: <br><br><img src="https://habrastorage.org/webt/11/yd/kr/11ydkrm0xkbw8aqxb8t71kypskg.png"><br><br>  Dans la deuxi√®me sous-section, la trace de pile est donn√©e pour les deux threads bloqu√©s. <br><br>  Cette trace de pile nous permet de suivre le fonctionnement de chaque thread jusqu'√† ce qu'un verrouillage se produise. <br>  Dans notre cas, si nous regardons la ligne: <br><br>  <i>√† DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)</i> , alors nous verrons la partie probl√©matique du code: <br><br><pre> printLockedResource (secondResource);
</pre><br>  Cette ligne est la premi√®re ligne du bloc synchronis√©, qui est la raison du verrouillage, et nous indique que la synchronisation sur la seconde ressource est la raison du verrouillage mutuel.  Pour rem√©dier √† la situation, nous devons nous assurer que les deux threads ont le m√™me ordre de synchronisation sur les ressources resourceA et resourceB.  Si nous le faisons, nous arriverons √† l'application suivante: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br>  Cette application se terminera sans verrouillage, et par cons√©quent, nous obtiendrons la sortie suivante (notez que les adresses de la classe Object ont chang√©): <br><br><pre> Thread-0: ressource verrouill√©e -&gt; java.lang.Object@1ad895d1
 Thread-0: ressource verrouill√©e -&gt; java.lang.Object@6e41d7dd
 Thread-1: ressource verrouill√©e -&gt; java.lang.Object@1ad895d1
 Thread-1: ressource verrouill√©e -&gt; java.lang.Object@6e41d7dd
</pre><br>  ,   ,   thread dump,           .        (     deadlock-).      ,   . <br><br><h3>    Thread Dump- </h3><br>         . <br><br>   JVM       .         (     ,   ). <br><br>         . <br><br>       - ‚Äî Thread Dump Analyzers (TDAs).    Java thread dump-     - ,     .  ,           . ,        . <br><br>        TDA: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">fastThread</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Spotify TDA</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">IBM Thread and Monitor Dump Analyze for Java</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">irockel TDA</a> </li></ul><br>        .               . <br><br><h4>  Conclusion </h4><br> Thread dump- ‚Äî      Java-,       .     ,           . <br><br>        deadlock,    .         .     ,           ‚Äî . <br><br>   ,   Java-     thread dump-.     ,             . <br><br> , thread dump ‚Äî   ¬´ ¬ª   ,        ,      Java-. <br><br> <i>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> Java</a>     .       ,        deadlock- .</i> <br><br> <i>      ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427513/">https://habr.com/ru/post/fr427513/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427499/index.html">De quoi parlent-ils dans le support technique du streamer vid√©o?</a></li>
<li><a href="../fr427501/index.html">Seymour Papert: Hard Fun</a></li>
<li><a href="../fr427505/index.html">Pr√©somption d'esprit</a></li>
<li><a href="../fr427507/index.html">Seymour Papert: la d√©licieuse d√©couverte de "rien"</a></li>
<li><a href="../fr427509/index.html">Serveurs Web: exp√©rience et pratique de Southbridge</a></li>
<li><a href="../fr427517/index.html">Aper√ßu des rapports Joker 2018 les plus int√©ressants: version EastBanc Technologies</a></li>
<li><a href="../fr427519/index.html">@Kubernetes Meetup at Mail.Ru Group: le 29 octobre et toujours</a></li>
<li><a href="../fr427521/index.html">Prix ‚Äã‚Äãr√©volutionnaire 2019. Annonce des laur√©ats des prix scientifiques Milner, Brin et Zuckerberg.</a></li>
<li><a href="../fr427523/index.html">Succ√®s de couverture</a></li>
<li><a href="../fr427525/index.html">Intel Core 9th Gen en chiffres et benchmarks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>