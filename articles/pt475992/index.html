<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎺 💆🏾 🛠️ Escrevendo um plugin VLC para aprender inglês ⚱️ 👩🏻‍🤝‍👨🏾 🤵🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, falarei sobre como escrever um plug-in em C para o VLC media player. Eu escrevi meu plugin para simplificar assistir programas de TV e f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escrevendo um plugin VLC para aprender inglês</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475992/"><img src="https://habrastorage.org/webt/nl/nj/r4/nlnjr4lpomher2u_r87vvsjeptc.png" alt="imagem"><br><br>  Neste artigo, falarei sobre como escrever um plug-in em C para o VLC media player.  Eu escrevi meu plugin para simplificar assistir programas de TV e filmes em inglês.  A ideia de criar este plugin é descrita nas seções <b>Idéia</b> e <b>Localização de uma solução</b> .  Detalhes técnicos da implementação do plug-in são fornecidos nas seções <b>Plug</b> - <b>in do Hello World</b> e <b>Implementação</b> .  O que aconteceu no final e como usá-lo pode ser encontrado na última seção, <b>Resultado</b> . <br><br>  O código fonte do projeto está disponível no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . <br><a name="habracut"></a><br><h1>  Idéia </h1><br>  A idéia de aprender uma língua estrangeira enquanto assisto minha série favorita não é nova, mas sempre tive problemas com ela pessoalmente.  É muito difícil assistir a uma série ou filme quando você não entende metade do que eles dizem.  Obviamente, você pode ativar legendas, mas se uma palavra ou expressão desconhecida for encontrada em um discurso, não ficará mais claro que será duplicado pelo texto.  E eu não gostei de assistir a série com legendas em russo - o cérebro muda para o idioma nativo e deixa de perceber fala estrangeira.  Li em algum lugar que primeiro você precisa assistir a uma série em russo e depois no original.  Mas essa abordagem também não me agradou.  Em primeiro lugar, onde levar tanto tempo para assistir à mesma coisa várias vezes e, em segundo lugar, assistir à segunda vez não é mais tão interessante - a motivação está perdida. <br><br>  Apesar de todas as dificuldades em assistir programas de TV estrangeiros, eu posso muito bem ler documentação técnica, artigos e livros em inglês.  Gosto de ler livros no leitor eletrônico do Kindle, pois a função de dicionário é legal por lá - você pode encontrar uma tradução de uma palavra desconhecida com um toque na tela.  É conveniente ler artigos e sites em inglês instalando uma extensão especial para tradução no navegador - eu uso a extensão <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Yandex.Translation</a> .  Essa abordagem permite que você leia e compreenda textos em inglês, sem muita distração para a busca de palavras desconhecidas. <br><br>  Pensei, por que não aplicar a mesma abordagem para assistir programas de TV - ligamos a série em inglês assim que uma frase incompreensível é encontrada, mudamos para a faixa de áudio russa e retrocedemos um pouco.  Em seguida, continuamos a assistir a série em inglês. <br><br><h1>  Procure uma solução </h1><br>  De fato, toda a funcionalidade que eu preciso já está disponível em muitos players de mídia populares.  A única coisa que gostaria de mudar a faixa de áudio e retroceder o vídeo alguns segundos atrás com o clique de um botão.  Também seria ótimo se, depois de traduzir um fragmento incompreensível, o próprio media player retornasse a faixa de áudio para o inglês.  Bem, seria bom poder repetir o fragmento traduzido anteriormente com a faixa em inglês. <br><br>  Ou seja, preciso de um media player para o qual você possa escrever plugins.  Também é desejável que seja multiplataforma, pois eu uso um PC no Windows e um laptop no Linux.  Minha escolha caiu imediatamente no VLC.  No habr, eu até encontrei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo</a> no qual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@Idunno</a> diz como escrever uma extensão VLC no LUA.  A propósito, ele também escreveu esta extensão para aprender inglês. Infelizmente, essa extensão não funciona nas versões mais recentes do VLC (anteriores à 2.0.5).  Devido à operação instável, a capacidade de adicionar funções de retorno de chamada através das quais foi possível processar eventos de teclado na extensão LUA foi removida da API LUA.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">README</a> , um link para a lista de discussão dos desenvolvedores do VLC que discutem esse problema leva à sua extensão no GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@Idunno</a> . <br><br>  Portanto, para implementar minha ideia, uma extensão para LUA não funciona, você precisa escrever um plug-in em C. E, embora eu tenha escrito algo em C pela última vez há cerca de 7 anos, na universidade, decidi tentar. <br><br><h1>  Hello world plugin </h1><br>  Vale a pena notar que o VLC media player possui uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> muito boa.  Aprendi com ele que o desenvolvimento de um media player usa uma abordagem modular.  O VLC consiste em vários módulos independentes que implementam determinadas funcionalidades e no kernel ( <b>libVLCCore</b> ), que gerencia esses módulos.  Existem dois tipos de módulos: interno ( <i>dentro da árvore</i> ) e externo ( <i>fora da árvore</i> ).  O código fonte dos módulos internos é armazenado em um repositório com o código do kernel.  Os módulos externos são desenvolvidos e montados independentemente do media player VLC.  Na verdade, estes são os chamados plugins. <br><br>  A documentação também possui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo</a> sobre como gravar seu plug-in (módulo) em C. Este artigo fornece o código-fonte de um plug-in simples que, quando o VLC é iniciado, exibe uma mensagem de boas-vindas " <i>Hello, &lt;name&gt;</i> " no console (o valor &lt;name&gt; é usado nas configurações do plug-in).  Correndo um pouco à frente, direi que no exemplo acima, adicione a seguinte linha após <code>set_category(CAT_INTERFACE)</code> : <br><br><pre> <code class="cpp hljs">set_subcategory( SUBCAT_INTERFACE_CONTROL )</code> </pre> <br>  Bem, tudo o que resta é montar o plug-in e testar seu funcionamento.  Há também uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instrução para</a> criar um plugin externo.  Aqui, vale a pena prestar atenção na seção <b>Internacionalização</b> , que descreve como a localização funciona no VLC.  Em resumo, para plug-ins externos, você precisa definir as macros <code>N_()</code> , <code>_()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DOMAIN </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"vlc-myplugin"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _(str) dgettext(DOMAIN, str) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_(str) (str)</span></span></code> </pre> <br>  Para montagem, propõe-se usar os bons e antigos Makefile ou Autotools.  Decidi seguir o caminho mais simples e escolhi o Makefile.  No Makefile, você precisa se lembrar de definir a variável <b><code>MODULE_STRING</code></b> - este é o identificador do nosso plugin.  Também ajustei um pouco o trabalho com os diretórios - agora eles são definidos através do <i>pkg-config</i> .  O resultado são os seguintes arquivos: <br><br><div class="spoiler">  <b class="spoiler_title">hello.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @file hello.c * @brief Hello world interface VLC module example */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> HAVE_CONFIG_H # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"config.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DOMAIN </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"vlc-myplugin"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _(str) dgettext(DOMAIN, str) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_(str) (str) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; /* VLC core API headers */ #include &lt;vlc_common.h&gt; #include &lt;vlc_plugin.h&gt; #include &lt;vlc_interface.h&gt; /* Forward declarations */ static int Open(vlc_object_t *); static void Close(vlc_object_t *); /* Module descriptor */ vlc_module_begin() set_shortname(N_("Hello")) set_description(N_("Hello interface")) set_capability("interface", 0) set_callbacks(Open, Close) set_category(CAT_INTERFACE) set_subcategory( SUBCAT_INTERFACE_CONTROL ) add_string("hello-who", "world", "Target", "Whom to say hello to.", false) vlc_module_end () /* Internal state for an instance of the module */ struct intf_sys_t { char *who; }; /** * Starts our example interface. */ static int Open(vlc_object_t *obj) { intf_thread_t *intf = (intf_thread_t *)obj; /* Allocate internal state */ intf_sys_t *sys = malloc(sizeof (*sys)); if (unlikely(sys == NULL)) return VLC_ENOMEM; intf-&gt;p_sys = sys; /* Read settings */ char *who = var_InheritString(intf, "hello-who"); if (who == NULL) { msg_Err(intf, "Nobody to say hello to!"); goto error; } sys-&gt;who = who; msg_Info(intf, "Hello %s!", who); return VLC_SUCCESS; error: free(sys); return VLC_EGENERIC; } /** * Stops the interface. */ static void Close(vlc_object_t *obj) { intf_thread_t *intf = (intf_thread_t *)obj; intf_sys_t *sys = intf-&gt;p_sys; msg_Info(intf, "Good bye %s!", sys-&gt;who); /* Free internal state */ free(sys-&gt;who); free(sys); }</span></span></span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Makefile</b> <div class="spoiler_text"><pre> <code class="smalltalk hljs"><span class="hljs-type"><span class="hljs-type">LD</span></span> = ld <span class="hljs-type"><span class="hljs-type">CC</span></span> = cc <span class="hljs-type"><span class="hljs-type">PKG_CONFIG</span></span> = pkg-config <span class="hljs-type"><span class="hljs-type">INSTALL</span></span> = install <span class="hljs-type"><span class="hljs-type">CFLAGS</span></span> = -g -<span class="hljs-type"><span class="hljs-type">O2</span></span> -<span class="hljs-type"><span class="hljs-type">Wall</span></span> -<span class="hljs-type"><span class="hljs-type">Wextra</span></span> <span class="hljs-type"><span class="hljs-type">LDFLAGS</span></span> = <span class="hljs-type"><span class="hljs-type">LIBS</span></span> = <span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_CFLAGS</span></span> := <span class="hljs-string"><span class="hljs-string">$(</span></span>shell <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">PKG_CONFIG</span></span>) --cflags vlc-plugin) <span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_LIBS</span></span> := <span class="hljs-string"><span class="hljs-string">$(</span></span>shell <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">PKG_CONFIG</span></span>) --libs vlc-plugin) <span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_DIR</span></span> := <span class="hljs-string"><span class="hljs-string">$(</span></span>shell <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">PKG_CONFIG</span></span>) --variable=pluginsdir vlc-plugin) plugindir = <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_DIR</span></span>)/misc override <span class="hljs-type"><span class="hljs-type">CC</span></span> += -std=gnu99 override <span class="hljs-type"><span class="hljs-type">CPPFLAGS</span></span> += -<span class="hljs-type"><span class="hljs-type">DPIC</span></span> -<span class="hljs-type"><span class="hljs-type">I</span></span>. -<span class="hljs-type"><span class="hljs-type">Isrc</span></span> override <span class="hljs-type"><span class="hljs-type">CFLAGS</span></span> += -fPIC override <span class="hljs-type"><span class="hljs-type">LDFLAGS</span></span> += -<span class="hljs-type"><span class="hljs-type">Wl</span></span>,-no-undefined,-z,defs override <span class="hljs-type"><span class="hljs-type">CPPFLAGS</span></span> += -<span class="hljs-type"><span class="hljs-type">DMODULE_STRING</span></span>=\<span class="hljs-comment"><span class="hljs-comment">"hello\"</span></span> override <span class="hljs-type"><span class="hljs-type">CFLAGS</span></span> += <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_CFLAGS</span></span>) override <span class="hljs-type"><span class="hljs-type">LIBS</span></span> += <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_LIBS</span></span>) all: libhello_plugin.so install: all mkdir -p -- <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">DESTDIR</span></span>)<span class="hljs-string"><span class="hljs-string">$(</span></span>plugindir) <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">INSTALL</span></span>) --mode <span class="hljs-number"><span class="hljs-number">0755</span></span> libhello_plugin.so <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">DESTDIR</span></span>)<span class="hljs-string"><span class="hljs-string">$(</span></span>plugindir) install-strip: <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">MAKE</span></span>) install <span class="hljs-type"><span class="hljs-type">INSTALL</span></span>=<span class="hljs-comment"><span class="hljs-comment">"$(INSTALL) -s"</span></span> uninstall: rm -f <span class="hljs-string"><span class="hljs-string">$(</span></span>plugindir)/libhello_plugin.so clean: rm -f -- libhello_plugin.so src/*.o mostlyclean: clean <span class="hljs-type"><span class="hljs-type">SOURCES</span></span> = hello.c <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SOURCES</span></span>:%.c=src/%.o): <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SOURCES</span></span>:%.c=src/%.c) libhello_plugin.so: <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SOURCES</span></span>:%.c=src/%.o) <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">CC</span></span>) <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">LDFLAGS</span></span>) -shared -o <span class="hljs-string"><span class="hljs-string">$@</span></span> <span class="hljs-string"><span class="hljs-string">$^</span></span> <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">LIBS</span></span>) .<span class="hljs-type"><span class="hljs-type">PHONY</span></span>: all install install-strip uninstall clean mostlyclean</code> </pre></div></div><br>  A maneira mais fácil de criar um plugin para Linux.  Para fazer isso, você precisa instalar, de fato, o próprio VLC media player, bem como os arquivos e as ferramentas necessárias para criar o plug-in.  No Debian / Ubuntu, isso pode ser feito com o seguinte comando: <br><br><pre> <code class="bash hljs">sudo apt-get install vlc libvlc-dev libvlccore-dev gcc make pkg-config</code> </pre> <br>  Na verdade, está tudo pronto, coletamos e instalamos nosso plugin usando o comando: <br><br><pre> <code class="bash hljs">sudo make install</code> </pre> <br>  Para testar o plug-in, execute o VLC também no console: <br><br><pre> <code class="bash hljs">vlc</code> </pre> <br>  Infelizmente, não vimos nenhum " <i>Olá, mundo</i> ".  A questão é que o plug-in deve primeiro ser ativado.  Para fazer isso, abra as configurações ( <b>Ferramentas</b> &gt; <b>Preferências</b> ), alterne para a visualização avançada (selecione <b>Tudo</b> no grupo <b>Mostrar configurações</b> ) e encontre na árvore no painel esquerdo <b>Interface</b> &gt; <b>Interfaces de</b> <b>controle</b> - marque a caixa ao lado do nosso plug-in de <b>interface Hello</b> . <br><br> <a href=""><img src="https://habrastorage.org/webt/fi/wr/ey/fiwreyqdhfd4ncbgzc2g8z1z3y8.png"></a> <br><br>  Salvaremos as configurações e reiniciaremos o VLC. <br><br> <a href=""><img src="https://habrastorage.org/webt/g3/-n/h3/g3-nh3qc7k37kzwpbfywtow8msa.png"></a> <br><br><h1>  Crie um plug-in para Windows </h1><br>  Com o Windows, as coisas são um pouco mais complicadas.  Para criar o plug-in, você precisa fazer o download do sdk, que contém bibliotecas, cabeçalho e arquivos de configuração do VLC.  Anteriormente, o sdk fazia parte do conjunto regular do VLC e podia ser encontrado na pasta de instalação do programa.  Agora, ele vem como uma montagem separada do media player.  Por exemplo, para o VLC versão 3.0.8, é possível fazer o download deste assembly em <a href="">ftp://ftp.videolan.org/pub/videolan/vlc/3.0.8/win64/vlc-3.0.8-win64.7z</a> (é importante fazer o download do 7z -arquivo). <br><br>  Copie o conteúdo do arquivo morto para uma pasta, por exemplo, em <i>C: \ Projetos</i> .  Além do sdk, o arquivo morto também contém o próprio media player, que pode ser usado para testar e depurar o plug-in. <br><br>  Para que nosso Makefile possa ser usado para criar e instalar o plug-in, é necessário corrigir o arquivo <i>C: \ Projects \ vlc-3.0.8 \ sdk \ lib \ pkgconfig \ vlc-plugin.pc</i> , indicando o caminho correto para a pasta <b>sdk</b> nas variáveis <b>prefix</b> e <b>pluginsdir</b> e <b>plugins,</b> respectivamente: <br><br><pre> <code class="bash hljs">prefix=/c/Projects/vlc-3.0.8/sdk pluginsdir=/c/Projects/vlc-3.0.8/plugins</code> </pre> <br>  Para criar no Windows, também precisamos instalar um compilador e outros utilitários.  Todo o software necessário pode ser obtido instalando o ambiente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MSYS2</a> .  O site do projeto possui instruções detalhadas de instalação.  Em resumo, imediatamente após a instalação, você precisa abrir o console ( <i>C: \ msys64 \ msys2.exe</i> ) e atualizar os pacotes MSYS2 usando o comando: <br><br><pre> <code class="bash hljs">pacman -Syu</code> </pre> <br>  Em seguida, feche a janela do terminal MSYS2, abra-a novamente e execute o comando <br><br><pre> <code class="bash hljs">pacman -Su</code> </pre> <br>  Após atualizar todos os pacotes, você precisa instalar o conjunto de ferramentas: <br><br><pre> <code class="bash hljs">pacman -S base-devel mingw-w64-x86_64-toolchain</code> </pre> <br>  Agora que todos os pacotes necessários estão instalados, você pode começar a criar o plugin.  Modifiquei um pouco o Makefile para que ele pudesse criar o plug-in no Linux e no Windows.  Além disso, eu tive que remover alguns parâmetros de compilação MinGW não suportados, como resultado, o Makefile começou a ficar assim: <br><br><div class="spoiler">  <b class="spoiler_title">Makefile para Windows</b> <div class="spoiler_text"><pre> <code class="smalltalk hljs"><span class="hljs-type"><span class="hljs-type">LD</span></span> = ld <span class="hljs-type"><span class="hljs-type">CC</span></span> = cc <span class="hljs-type"><span class="hljs-type">PKG_CONFIG</span></span> = pkg-config <span class="hljs-type"><span class="hljs-type">INSTALL</span></span> = install <span class="hljs-type"><span class="hljs-type">CFLAGS</span></span> = -g -<span class="hljs-type"><span class="hljs-type">O2</span></span> -<span class="hljs-type"><span class="hljs-type">Wall</span></span> -<span class="hljs-type"><span class="hljs-type">Wextra</span></span> <span class="hljs-type"><span class="hljs-type">LDFLAGS</span></span> = <span class="hljs-type"><span class="hljs-type">LIBS</span></span> = <span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_CFLAGS</span></span> := <span class="hljs-string"><span class="hljs-string">$(</span></span>shell <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">PKG_CONFIG</span></span>) --cflags vlc-plugin) <span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_LIBS</span></span> := <span class="hljs-string"><span class="hljs-string">$(</span></span>shell <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">PKG_CONFIG</span></span>) --libs vlc-plugin) <span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_DIR</span></span> := <span class="hljs-string"><span class="hljs-string">$(</span></span>shell <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">PKG_CONFIG</span></span>) --variable=pluginsdir vlc-plugin) plugindir = <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_DIR</span></span>)/misc override <span class="hljs-type"><span class="hljs-type">CC</span></span> += -std=gnu99 override <span class="hljs-type"><span class="hljs-type">CPPFLAGS</span></span> += -<span class="hljs-type"><span class="hljs-type">DPIC</span></span> -<span class="hljs-type"><span class="hljs-type">I</span></span>. -<span class="hljs-type"><span class="hljs-type">Isrc</span></span> override <span class="hljs-type"><span class="hljs-type">CFLAGS</span></span> += -fPIC override <span class="hljs-type"><span class="hljs-type">LDFLAGS</span></span> += -<span class="hljs-type"><span class="hljs-type">Wl</span></span>,-no-undefined override <span class="hljs-type"><span class="hljs-type">CPPFLAGS</span></span> += -<span class="hljs-type"><span class="hljs-type">DMODULE_STRING</span></span>=\<span class="hljs-comment"><span class="hljs-comment">"hello\"</span></span> override <span class="hljs-type"><span class="hljs-type">CFLAGS</span></span> += <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_CFLAGS</span></span>) override <span class="hljs-type"><span class="hljs-type">LIBS</span></span> += <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">VLC_PLUGIN_LIBS</span></span>) <span class="hljs-type"><span class="hljs-type">SUFFIX</span></span> := so ifeq (<span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">OS</span></span>),<span class="hljs-type"><span class="hljs-type">Windows_NT</span></span>) <span class="hljs-type"><span class="hljs-type">SUFFIX</span></span> := dll endif all: libhello_plugin.<span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SUFFIX</span></span>) install: all mkdir -p -- <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">DESTDIR</span></span>)<span class="hljs-string"><span class="hljs-string">$(</span></span>plugindir) <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">INSTALL</span></span>) --mode <span class="hljs-number"><span class="hljs-number">0755</span></span> libhello_plugin.<span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SUFFIX</span></span>) <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">DESTDIR</span></span>)<span class="hljs-string"><span class="hljs-string">$(</span></span>plugindir) install-strip: <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">MAKE</span></span>) install <span class="hljs-type"><span class="hljs-type">INSTALL</span></span>=<span class="hljs-comment"><span class="hljs-comment">"$(INSTALL) -s"</span></span> uninstall: rm -f <span class="hljs-string"><span class="hljs-string">$(</span></span>plugindir)/libhello_plugin.<span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SUFFIX</span></span>) clean: rm -f -- libhello_plugin.<span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SUFFIX</span></span>) src/*.o mostlyclean: clean <span class="hljs-type"><span class="hljs-type">SOURCES</span></span> = hello.c <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SOURCES</span></span>:%.c=src/%.o): <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SOURCES</span></span>:%.c=src/%.c) libhello_plugin.<span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SUFFIX</span></span>): <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">SOURCES</span></span>:%.c=src/%.o) <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">CC</span></span>) <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">LDFLAGS</span></span>) -shared -o <span class="hljs-string"><span class="hljs-string">$@</span></span> <span class="hljs-string"><span class="hljs-string">$^</span></span> <span class="hljs-string"><span class="hljs-string">$(</span></span><span class="hljs-type"><span class="hljs-type">LIBS</span></span>) .<span class="hljs-type"><span class="hljs-type">PHONY</span></span>: all install install-strip uninstall clean mostlyclean</code> </pre></div></div><br>  Como o MSYS2 não sabe nada sobre o sdk for VLC, você precisa adicionar o caminho para a pasta <b>pkgconfig</b> desse sdk na <b>variável de</b> ambiente <b>PKG_CONFIG_PATH</b> .  Abra o console do MinGW ( <i>C: \ msys64 \ mingw64.exec</i> ) e execute os comandos: <br><br><pre> <code class="plaintext hljs">export PKG_CONFIG_PATH=/c/projects/vlc-3.0.8/sdk/lib/pkgconfig:$PKG_CONFIG_PATH make install</code> </pre> <br>  Para testar o plug-in, execute o VLC também no console: <br><br><pre> <code class="plaintext hljs">/c/projects/vlc-3.0.8/vlc</code> </pre> <br>  Como no caso do Linux, vá para as configurações e ative nosso plugin.  Salvaremos as configurações e reiniciaremos o VLC. <br><br><h1>  Implementação de plugins </h1><br>  Para implementar meu plug-in, eu precisava entender como controlar o media player (alterar a faixa de áudio, rebobinar) e como lidar com os eventos de pressionamento de tecla do teclado.  Para entender tudo isso, virei-me para a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> .  Também na Internet, encontrei alguns artigos interessantes que esclarecem a arquitetura do media player: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20141204234622/">A arquitetura da estrutura de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mídia VLC</a> e a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação da API do VLC media player</a> . <br><br>  O VLC consiste em um grande número de módulos independentes (mais de 400).  Cada módulo deve fornecer informações sobre o tipo de funcionalidade que implementa, bem como as funções de inicialização / finalização.  Essas informações são descritas no <b>bloco vlc_module_begin ()</b> - <b>vlc_module_end ()</b> usando as <b>macros set_capability ()</b> e <b>set_callbacks ()</b> .  As funções de inicialização / finalização do módulo (geralmente chamadas de <b>Abrir</b> e <b>Fechar</b> ) têm a seguinte assinatura: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vlc_object_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vlc_object_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span></span></code> </pre> <br>  <b>vlc_object_t</b> é o tipo de base para representar dados no VLC, do qual todos os outros são herdados (consulte o artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gerenciamento de objetos</a> ).  Um ponteiro para <b>vlc_object_t</b> deve ser <b>convertido</b> em um tipo de dados específico, de acordo com a funcionalidade que o módulo implementa.  Para controlar o media player, <b>defino o</b> valor <b>da</b> <b><i>interface</i></b> na macro <b>set_capability ()</b> .  Assim, nas funções <b>Abrir</b> e <b>Fechar</b> , preciso converter <b>vlc_object_t</b> em <b>intf_thread_t</b> . <br><br>  A interação entre os módulos é baseada no padrão de design do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">observador</a> .  O VLC fornece um mecanismo de <i>"variáveis ​​de objeto"</i> (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Variáveis</a> ), com o qual você pode adicionar variáveis ​​a instâncias do tipo <b>vlc_object_t</b> (e suas derivadas).  Os módulos podem trocar dados através dessas variáveis.  Você também pode anexar uma função de retorno de chamada à variável, que será chamada quando o valor dessa variável for alterado. <br><br>  Como exemplo, considere o módulo de teclas de <b>atalho</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modules / control / hotkeys.c</a> ), responsável por manipular eventos de teclas de atalho.  Na função Abrir, a função de retorno de chamada <b>ActionEvent</b> está pendurada na <b>variável de</b> <b>ação-chave</b> : <br><br><pre> <code class="cpp hljs">var_AddCallback( p_intf-&gt;obj.libvlc, <span class="hljs-string"><span class="hljs-string">"key-action"</span></span>, ActionEvent, p_intf );</code> </pre> <br>  Um ponteiro para <b>vlc_object_t</b> , um nome de variável, uma função de retorno de chamada e um ponteiro para anular são passados ​​para a função <b>var_AddCallback</b> para transmitir dados arbitrários, que são encaminhados para a função de retorno de chamada especificada.  A assinatura da função de retorno de chamada é mostrada abaixo. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ActionEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vlc_object_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vlc_value_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vlc_value_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span></span></code> </pre> <br>  Um ponteiro para <b>vlc_object_t</b> , o nome da variável, os valores antigos e novos dessa variável (nesse caso, o identificador da combinação de teclas de atalho correspondente correspondente da ação), bem como o ponteiro para quaisquer dados adicionais especificados ao adicionar a função de retorno de chamada, são passados ​​para a função de retorno de chamada . <br><br>  O processamento direto de eventos de teclas de atalho é realizado na função <b>PutAction</b> , chamada dentro da função de retorno de chamada <b>ActionEvent</b> .  A função <b>PutAction</b> aceita um identificador de um evento ao pressionar uma combinação de teclas de atalho ( <b>i_action</b> ) e, com a ajuda do operador do comutador, executa as ações correspondentes. <br><br>  Por exemplo, um evento de retrocesso corresponde a <b><code>ACTIONID_JUMP_BACKWARD_SHORT</code></b> .  Para executar a ação correspondente, o intervalo de retrocesso é obtido das configurações do VLC (da variável <b>tamanho do salto curto</b> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mtime_t</span></span> it = var_InheritInteger( p_input, varname );</code> </pre> <br>  Para retroceder o arquivo em reprodução, basta definir a variável de <b>deslocamento de tempo</b> no valor correspondente ao tempo (em microssegundos) pelo qual você deseja alterar a reprodução: <br><br><pre> <code class="cpp hljs">var_SetInteger( p_input, <span class="hljs-string"><span class="hljs-string">"time-offset"</span></span>, it * sign * CLOCK_FREQ );</code> </pre> <br>  Para avanço rápido, você precisa especificar um valor positivo, para retrocesso rápido - negativo.  A <b>constante CLOCK_FREQ é</b> usada para converter segundos em microssegundos. <br><br>  Da mesma forma, a faixa de áudio é alterada (evento <b><code>ACTIONID_AUDIO_TRACK</code></b> ).  Somente a variável <b>audio-es</b> responsável pela faixa de áudio pode aceitar um conjunto limitado de valores (de acordo com as faixas de áudio disponíveis no arquivo sendo reproduzido).  Você pode obter uma lista dos possíveis valores de uma variável usando a função <b>var_Change ()</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">vlc_value_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>, list2; var_Change( p_input, <span class="hljs-string"><span class="hljs-string">"audio-es"</span></span>, VLC_VAR_GETCHOICES, &amp;<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>, &amp;list2 );</code> </pre> <br>  Além da lista de valores, essa função também permite obter uma lista de descrições desses valores (nesse caso, o nome das faixas de áudio).  Agora podemos mudar a faixa de áudio usando a função <b>var_Set ()</b> : <br><br><pre> <code class="cpp hljs">var_Set( p_input, <span class="hljs-string"><span class="hljs-string">"audio-es"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>.p_list-&gt;p_values[i] );</code> </pre> <br>  Como gerenciar o media player descoberto, resta aprender a lidar com os eventos do teclado.  Infelizmente, não foi possível adicionar uma nova tecla de atalho.  Todas as teclas de atalho são codificadas no código do kernel do VLC ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">src / misc / actions.c</a> ).  Portanto, adicionei um manipulador para eventos de pressionamento de tecla de teclado de nível inferior, suspendendo minha função de retorno de chamada para alterar a variável <b>pressionada por tecla</b> : <br><br><pre> <code class="cpp hljs">var_AddCallback( p_intf-&gt;obj.libvlc, <span class="hljs-string"><span class="hljs-string">"key-pressed"</span></span>, KeyboardEvent, p_intf );</code> </pre> <br>  A variável <b>pressionada por tecla</b> armazena o código de caractere (em Unicode) correspondente à última tecla pressionada.  Por exemplo, quando você pressiona a tecla com o número <b>"1"</b> , a variável <b>pressionada por tecla</b> recebe o valor <b><i>49</i></b> (0x00000031 no 16º sistema numérico).  Você pode ver outros códigos de caracteres em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">unicode-table.com</a> .  Além disso, o valor da variável <b>pressionada por tecla</b> leva em consideração o pressionamento das teclas modificadoras, o quarto byte significativo é alocado para elas.  Assim, por exemplo, ao pressionar a combinação de <b>teclas</b> " <b>Ctrl + 1</b> ", a variável <b>pressionada por tecla</b> receberá o valor 0x <b>04</b> 000031 (00000 <b>1</b> 00 00000000 00000000 00110001 <sub>2</sub> ).  Para maior clareza, a tabela abaixo mostra os significados de várias combinações de teclas: <br><div class="scrollable-table"><table><tbody><tr><th>  Atalho do teclado </th><th>  Valor </th></tr><tr><td>  Ctrl + 1 </td><td>  00000 <b>1</b> 00 00000000 00000000 00110001 <sub>2</sub> </td></tr><tr><td>  Alt + 1 </td><td>  0000000 <b>1</b> 00000000 00000000 00110001 <sub>2</sub> </td></tr><tr><td>  Ctrl + Alt + 1 </td><td>  00000 <b>1</b> 0 <b>1</b> 00000000 00000000 00110001 <sub>2</sub> </td></tr><tr><td>  Shift + 1 </td><td>  000000 <b>1</b> 0 00000000 00000000 <b>00100001</b> <sub>2</sub> </td></tr></tbody></table></div>  Preste atenção ao valor ao pressionar a combinação “ <b>Shift + 1</b> ”.  Como neste caso o “ <b>!</b>  ", O valor do primeiro byte corresponderá ao código desse caractere em Unicode (0x00000021). <br><br><h1>  Resultado </h1><br>  Eu chamei meu plug-in de <b>DICA de</b> acrônimo para a frase "traduza, por favor", também a dica pode ser traduzida como "dica".  O código fonte do plug-in é publicado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> , onde você também pode fazer o download de assemblies de plug-in prontos para Windows e Linux. <br><br>  Para instalar o plug-in, você precisa copiar o arquivo <b>libtip_plugin.dll</b> (libtip_plugin.so para Linux) para a pasta <i>&lt;path-to-vlc&gt; / plugins</i> .  No Windows, o VLC geralmente é instalado na pasta <i>C: \ Arquivos de Programas \ VideoLAN \ VLC</i> .  No Linux, você pode encontrar a pasta de instalação usando o comando: <br><br><pre> <code class="plaintext hljs">whereis vlc</code> </pre> <br>  No Ubuntu, por exemplo, o VLC é instalado em <i>/ usr / lib / x86_64-linux-gnu / vlc</i> . <br><br>  Em seguida, você precisará reiniciar o VLC e, no menu principal, abra <b>Ferramentas</b> &gt; <b>Preferências</b> , alterne para a visualização avançada (selecione <b>Tudo</b> no grupo <b>Mostrar configurações</b> ), vá para a seção <b>Interface</b> &gt; <b>Controle</b> no painel esquerdo e marque a caixa ao lado de <b>DICA (traduza-a, por favor)</b> .  Então, novamente, você precisará reiniciar o VLC. <br><br> <a href=""><img src="https://habrastorage.org/webt/df/06/qk/df06qkcl2vbiatwq7j_8uw4m_ey.png"></a> <br><br>  Nas configurações do plug-in, você pode especificar os números das faixas de áudio principal e auxiliar (para tradução), bem como o tempo (em segundos) pelo qual o plug-in será rebobinado para repetir com a faixa de áudio auxiliar. <br><br> <a href=""><img src="https://habrastorage.org/webt/mv/9-/vu/mv9-vuo9mfzicqyiqpsopnevrpu.png"></a> <br><br>  Para controlar o plug-in, adicionei os seguintes atalhos de teclado: <br><br><ul><li>  " <b>/</b> " Para tradução </li><li>  " <b>Shift + /</b> " para repetir o fragmento de vídeo traduzido anteriormente com a faixa de áudio principal </li></ul><br>  Durante a execução dos comandos de conversão e nova tentativa, o plug-in exibe as mensagens <i>"DICA: traduzir"</i> e <i>"DICA: repetir"</i> no canto superior esquerdo <i>,</i> respectivamente. <br><br><img src="https://habrastorage.org/webt/4z/bu/1p/4zbu1p5mwskebq8vpbiny_oayr4.png"><br><br>  Pela minha experiência no uso do plug-in, posso dizer que, em geral, estou satisfeito com o resultado.  O principal é escolher o conteúdo certo, se pelo menos metade da fala estrangeira usada lá for entendida, o plug-in ajudará a traduzir o restante.  Caso contrário, o plug-in provavelmente será inútil. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt475992/">https://habr.com/ru/post/pt475992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt475980/index.html">Baixa conectividade, arquitetura e organização da equipe</a></li>
<li><a href="../pt475982/index.html">Como aprender uma língua estrangeira</a></li>
<li><a href="../pt475986/index.html">Visão geral do PocketBook 740 Pro Reader: 7,8 polegadas, proteção de áudio e IPX8</a></li>
<li><a href="../pt475988/index.html">Atualizações do ML.NET Model Builder</a></li>
<li><a href="../pt475990/index.html">Criando aplicativos modernos de nuvem usando Pulumi e .NET Core</a></li>
<li><a href="../pt475994/index.html">Dicas e truques interessantes sobre WSL (Windows Subsystem para Linux)</a></li>
<li><a href="../pt475996/index.html">Adicionando Quartz à Inicialização Spring</a></li>
<li><a href="../pt475998/index.html">Aplicação do RPA em cálculos científicos e de engenharia</a></li>
<li><a href="../pt476000/index.html">Atualizações do ML.NET Model Builder</a></li>
<li><a href="../pt476002/index.html">Experiência em encontrar uma posição de estudante de doutorado na Alemanha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>