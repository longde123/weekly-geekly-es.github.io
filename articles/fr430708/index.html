<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüíª üë®‚Äçüç≥ üë®‚Äç‚úàÔ∏è Tic Tac Toe ¬´Sans Fronti√®res¬ª üññüèΩ üë™ üîÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tic-tac-toe ... tout le monde les a jou√©s, j'en suis s√ªr. Le jeu est s√©duisant par sa simplicit√©, surtout lorsque vous faites glisser l'horloge quelqu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tic Tac Toe ¬´Sans Fronti√®res¬ª</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430708/"> Tic-tac-toe ... tout le monde les a jou√©s, j'en suis s√ªr.  Le jeu est s√©duisant par sa simplicit√©, surtout lorsque vous faites glisser l'horloge quelque part dans la le√ßon, un couple, et il n'y a rien √† port√©e de main, sauf une feuille de cahier et un simple crayon.  Je ne sais pas qui a √©t√© le premier √† avoir pens√© √† dessiner des croix et des cercles sur 9 cases, mais depuis lors, le jeu n'a plus perdu en demande, d'autant plus que les gens ont propos√© de nombreuses variantes. <br><br><img src="https://habrastorage.org/webt/pd/gx/-c/pdgx-cibc6880fmwfxt90nxmi-k.jpeg"><br><br>  Cet article concerne le processus de d√©veloppement de l'IA sur javascript pour jouer √† l'une de ces variations de tic-tac-toe: j'ai beaucoup de mat√©riel, mais je l'ai dilu√© avec de l'animation et des images.  Dans tous les cas, au moins √ßa vaut le coup d'essayer de le jouer. <br>  Les diff√©rences entre cette version du jeu et l'original sont les suivantes: <br><br><ol><li>  <b>Le champ</b> peut √™tre arbitrairement <b>grand</b> (combien de temps durera le bloc-notes) </li><li>  Le gagnant est celui qui met <b>5 pi√®ces</b> (si vous pouvez les appeler ainsi) dans une rang√©e. </li></ol><br>  Tout est simple ... et en m√™me temps compliqu√©: le r√©sultat du jeu ne peut pas √™tre calcul√© √† l'avance, comme dans l'analogue classique.  Cette "petite projection" m'a enlev√© beaucoup de temps et de nerfs.  J'esp√®re que vous le trouverez int√©ressant. <a name="habracut"></a><br><br><h3>  Avant de commencer </h3><br>  Forc√© de m'excuser √† l'avance pour le volume de l'article et √† certains endroits une pr√©sentation de pens√©e pas tout √† fait intelligible, cependant, je n'ai pas pu serrer le troupeau sans perte de contenu et de qualit√©. <br>  Je vous recommande de vous familiariser d'abord avec le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©sultat</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code</a> <br><br>  Raccourcis clavier et commandes: <br><br><ul><li>  <b>D</b> - AI fera un pas pour vous </li><li>  <b>T</b> - voir le poids des cellules </li><li>  √âcrivez <b>SHOW_WEIGHTS = true</b> dans la console pour afficher les poids de toutes les cellules analys√©es. </li></ul><br><h3>  Commen√ßons </h3><br>  Vous devez commencer par la mise en ≈ìuvre du jeu lui-m√™me, c'est-√†-dire  √©crire une application pour deux joueurs, jusqu'ici sans bot.  Pour mes besoins, j'ai d√©cid√© d'utiliser javascript + jquery + bootstrap4, bien qu'il n'y soit pratiquement pas utilis√©, mais il vaut mieux le laisser - sinon la table flottera.  Il n'y a rien de sp√©cial √† dire, il y a beaucoup de mat√©riel sur js, jquery et bootstrap.  Je peux seulement dire que j'ai utilis√© MVC.  Quoi qu'il en soit, je n'expliquerai pas absolument tout le code - il y a d√©j√† eu beaucoup de mat√©riel. <br><br>  Le terrain de jeu √©tait donc pr√™t.  Vous pouvez d√©finir des formes dans les cellules.  Mais la victoire de l'un des joueurs n'a √©t√© fix√©e en aucune fa√ßon. <br><br><h3>  Analyse de fin de partie </h3><br>  Le jeu se termine lorsque l'un des joueurs met <b>5 pi√®ces</b> d'affil√©e.  "C'est simple!"  Pensai-je.  Et il a commenc√© √† balayer absolument toutes les cellules du champ: tout d'abord l'horizontale, puis la verticale, et enfin les diagonales. <br><br>  C'est une fa√ßon stupide, mais cela a fonctionn√©.  Cependant, cela pourrait √™tre consid√©rablement am√©lior√©, ce que j'ai fait: la plupart des cellules resteront vides tout au long du jeu - le terrain de jeu est trop grand pour √™tre enti√®rement rempli.  Puisqu'il √©tait n√©cessaire de le scanner √† chaque mouvement, et qu'une seule pi√®ce est plac√©e en un seul mouvement - vous pouvez vous concentrer uniquement sur cette pi√®ce (cellule): scannez seulement une horizontale, verticale et deux diagonales de la cellule qui poss√®de la m√™me cellule. <br><br>  De plus, vous n'avez pas besoin de scanner toutes les lign√©es cellulaires.  Puisque la fin du jeu est de 5 pi√®ces d'affil√©e, les pi√®ces qui sont √† 6 cases les unes des autres ne nous int√©ressent pas.  Il suffit de scanner cinq cellules de chaque c√¥t√©.  Je ne comprends pas?  Voir l'animation ci-dessous. <br><br><img src="https://habrastorage.org/webt/nt/fj/wu/ntfjwuj6nfabfj2qtedcs4g-fp0.gif"><br><br><div class="spoiler">  <b class="spoiler_title">Afficher le code</b> <div class="spoiler_text"><pre><code class="javascript hljs">checkWin( cellX, cellY ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newFig = getFig(cellX,cellY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! newFig ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res; res = res || checkLine( cellX, cellY, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-comment"><span class="hljs-comment">//horizontal res = res || checkLine( cellX, cellY, 0, 1 ); //vertical res = res || checkLine( cellX, cellY, 1, 1 ); //diagonal 45 res = res || checkLine( cellX, cellY, 1, -1 ); //diagonal 135 return res; function getFig( x, y ){ return Model.Field[x] &amp;&amp; Model.Field[x][y] ? Model.Field[x][y] : 'b'; } function checkLine( x, y, dx, dy ){ x = +x; y = +y; var score = 0; while( getFig( x - dx, y - dy ) == newFig ){ x -= dx; y -= dy; } while( getFig( x, y ) == newFig ){ x += dx; y += dy; score++; } if( score &gt;= 5 ) return true; return false; } }</span></span></code> </pre> <br></div></div><br><h3>  Descendons au bot lui-m√™me </h3><br>  Donc, nous avons d√©j√† √©crit une page avec tic-tac-toe.  Nous passons √† la t√¢che principale - l'IA. <br>  Vous ne pouvez pas simplement prendre et √©crire du code si vous ne savez pas comment: vous devez r√©fl√©chir √† la logique du bot. <br><br>  L'essentiel est d'analyser le terrain de jeu, au moins une partie de celui-ci, et de calculer le <b>prix (poids) de</b> chaque cellule sur le terrain.  La cellule avec le poids le plus √©lev√© - la plus prometteuse - le bot y mettra un chiffre.  La principale difficult√© est de calculer le poids d'une cellule. <br><br><h3>  Terminologie </h3><br>  <b>Les croix et les orteils</b> sont des figures. <br>  <b>Une attaque</b> sera appel√©e plusieurs personnages identiques c√¥te √† c√¥te sur la m√™me ligne.  En fait, c'est beaucoup.  Le nombre de pi√®ces dans une attaque est sa <b>puissance</b> .  Une pi√®ce distincte est √©galement une attaque (puissance 1). <br><br>  Sur les cellules d'attaque adjacentes (aux extr√©mit√©s), il peut y avoir des cellules vides ou des pi√®ces ennemies.  Il est logique de penser qu'une attaque avec deux cellules vides aux ¬´extr√©mit√©s¬ª peut se d√©velopper dans deux directions, ce qui la rend plus prometteuse.  Le nombre de cellules vides aux "extr√©mit√©s" de l'attaque sera appel√© son <b>potentiel</b> .  Le potentiel peut √™tre 0, 1 ou 2. <br>  Nous d√©signons les attaques comme suit: <b>[puissance d'attaque, potentiel]</b> .  Par exemple, une <b>attaque [4: 1]</b> . <br><br><img src="https://habrastorage.org/webt/1_/pk/e3/1_pke3kve1yjbf6cjjzg3hnnzvm.jpeg"><br>  <i>Figure 1. Attaque [4: 1]</i> <br><br>  Au cours de l'analyse, nous √©valuerons toutes les cellules qui entrent dans une zone sp√©cifique.  Chaque cellule calculera son <b>poids</b> .  Il est calcul√© sur la base du poids de toutes les attaques que cette cellule affecte. <br><br><h3>  L'essence de l'analyse </h3><br>  Imaginez que sur le terrain de jeu, il y a d√©j√† plusieurs attaques d'un et du deuxi√®me joueur.  Un des joueurs fait un mouvement (laissez les croix).  Naturellement, il se d√©place vers une cellule vide - et ainsi il peut: <br><br><ol><li>  D√©veloppez votre attaque, et peut-√™tre plus d'une, en augmentant sa puissance.  Peut lancer une nouvelle attaque, etc. </li><li>  Emp√™chez le d√©veloppement d'une attaque ennemie ou bloquez-la compl√®tement. </li></ol><br>  Autrement dit, notre protagoniste peut attaquer et d√©fendre.  Ou peut-√™tre d'un coup.  Pour lui, le premier et le second sont importants. <br><br>  L'essence de l'analyse est la suivante: <br><br><ol><li>  Le bot substitue les chiffres de la cellule coch√©e: d'abord une croix, puis un z√©ro. </li><li>  Il recherche ensuite toutes les attaques re√ßues par de tels mouvements et r√©sume leurs poids. </li><li>  Le montant re√ßu est le poids de la cellule. </li><li>  Un algorithme similaire est ex√©cut√© pour toutes les cellules du terrain de jeu. </li></ol><br><img src="https://habrastorage.org/webt/ur/rc/qz/urrcqzyrjrnp9oupxjoqc1iu6wg.gif"><br><br>  En fait, nous v√©rifions avec un tel algorithme ce qui se passera si nous allons de cette fa√ßon ... et ce qui se passera si l'adversaire va de cette fa√ßon.  Nous attendons avec impatience une √©tape et s√©lectionnons la cellule la plus appropri√©e - avec le poids le plus √©lev√©. <br><br>  Si une cellule a plus de poids qu'une autre, elle conduit √† la cr√©ation d'attaques plus dangereuses ou √† bloquer de fortes attaques ennemies.  Tout est logique ... il me semble. <br>  Si vous allez sur la page et √©crivez dans la console SHOW_WEIGHTS = true, vous pouvez sentir visuellement le fonctionnement de l'algorithme (les poids des cellules seront affich√©s). <br><br><h3>  Poids d'attaque </h3><br>  Je suis all√© sur mon cerveau et apport√© une telle correspondance d'attaques et de poids: <br><br><pre> <code class="javascript hljs">ATTACK_WEIGHT = [[],[],[],[],[],[]]; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0.1</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">6</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0.25</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">5</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">7</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">100</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre><br>  Empiriquement s√©lectionn√© - ce n'est peut-√™tre pas la meilleure option. <br><br>  J'ai ajout√© une puissance d'attaque de 5 avec un poids prohibitif √† la matrice.  Cela peut s'expliquer par le fait que le bot analyse le jeu en regardant un pas en avant (en rempla√ßant la figure dans la cellule).  Sauter une telle attaque n'est rien d'autre qu'une d√©faite.  Eh bien, ou la victoire ... selon qui. <br><br>  Les attaques √† fort potentiel sont valoris√©es plus haut. <br><br>  L'attaque [4: 2] dans la plupart des cas d√©cide du r√©sultat de la partie.  Si le joueur a r√©ussi √† cr√©er une telle attaque, l'adversaire ne pourra plus la bloquer.  Mais ce n'est pas une victoire.  L'ennemi peut terminer le jeu plus rapidement, m√™me si nous avons une attaque [4: 2] sur le terrain, donc son poids est inf√©rieur √† celui des attaques d'une puissance de 5. Voir un exemple ci-dessous. <br><br><img src="https://habrastorage.org/webt/pk/4u/mm/pk4ummarchcw9j4lpkujlmj_iig.jpeg"><br>  <i>Figure 2. Attaque [4: 2]</i> <br><br><h3>  Attaques d√©chir√©es </h3><br>  Le code n'est pas pr√©sent√© dans ce paragraphe.  Ici, nous introduisons le concept d'un diviseur d'attaque et expliquons l'essence des <b>¬´attaques d√©chir√©es¬ª</b> . <br><br>  Consid√©rez la situation suivante: lorsque vous remplacez un chiffre pour supprimer plusieurs cellules vides, mais pas plus de 5, une autre est localis√©e. <br><br>  Et, semble-t-il, deux figures identiques, sur la m√™me ligne ... visuellement cela ressemble √† une attaque, mais en fait non.  Pas un ordre, car de telles attaques "d√©chir√©es" comportent √©galement une menace potentielle. <br><br>  Surtout pour de tels cas, pour chaque attaque, nous calculerons le diviseur.  Initialement, sa valeur est 1. <br><br><ol><li>  Nous pr√©sentons l'attaque "d√©chir√©e" comme plusieurs </li><li>  On compte le nombre de cellules vides entre l'attaque centrale et le c√¥t√© </li><li>  Pour chaque cellule vide, le diviseur est augment√© de 1 </li><li>  Nous calculons le poids de l'attaque centrale comme d'habitude, le poids des attaques lat√©rales - divis√© par le diviseur </li></ol><br><img src="https://habrastorage.org/webt/dc/w9/62/dcw9629rd4zdhomn6q2uwi5yxkg.jpeg"><br>  <i>Fig 3. Analyse de "Attaque d√©chir√©e".</i>  <i>Une cellule avec une croix jaune est scann√©e.</i> <br><br>  Ainsi, les attaques d√©chir√©es seront √©galement prises en compte par l'IA.  En fait, ce seront des attaques ordinaires, mais plus elles sont √©loign√©es de la cellule scann√©e, moins elles ont d'influence sur elle et, par cons√©quent, elles ont moins de poids (gr√¢ce au diviseur). <br><br><h3>  Algorithme de recherche d'attaque </h3><br>  Cr√©ez d'abord <b>une classe d'</b> attaque.  L'attaque aura 3 attributs, dont j'ai parl√© plus t√¥t: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attack</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( cap = 0, pot = 0, div = 1 ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability = cap; <span class="hljs-comment"><span class="hljs-comment">// this.potential = pot; // this.divider = div; // }</span></span></code> </pre><br>  Et une <b>m√©thode</b> qui renverra le poids d'une attaque donn√©e: <br><br><pre> <code class="javascript hljs">countWeigth(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ATTACK_WEIGHT[ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.potential ] / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.divider } }</code> </pre><br>  Ensuite.  Nous diviserons la recherche de toutes les attaques pour une cellule en: <br><br><ol><li>  Recherche horizontale </li><li>  Recherche verticale </li><li>  Recherche diagonale √† 45 degr√©s </li><li>  Recherche en diagonale √† 135 degr√©s </li></ol><br>  Ce sont toutes des <b>lignes</b> , et l'algorithme de recherche d'attaques sur ces lignes peut √™tre g√©n√©ralis√©: <b>la classe checkLine</b> . <br><br>  Cependant, nous n'avons pas besoin de v√©rifier toute la ligne.  La puissance d'attaque maximale qui nous int√©resse est de 5. Bien s√ªr, il est possible de cr√©er une attaque avec une puissance de, disons, 6.  Mais pour une IA qui analyse la situation de jeu du prochain coup, c'est la m√™me chose que 6 ou 5. La perspective d'obtenir l'une de ces attaques indique la fin du jeu au coup suivant.  En cons√©quence, le poids de la cellule analys√©e sera le m√™me dans les deux cas. <br><br>  Attributs de classe: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">checkLine</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">//,        this.subFig = "√ó"; //     .    ¬´0¬ª - . this.Attacks = []; //  this.curAttack = new Attack; // (      ) this.iter = 1; //,     this.checkEdge = false;</span></span></code> </pre><br>  Il faut s'arr√™ter l√†, car la question peut se poser: pourquoi v√©rifier la 6e cellule si la puissance d'attaque maximale est 5. La r√©ponse est de d√©terminer le potentiel √©loign√© du centre d'attaque. <br><br>  Voici un exemple: une attaque avec une puissance de 1 dans l'image se situe √† la fronti√®re de la zone scann√©e.  Pour d√©couvrir le potentiel de cette attaque, vous devez ¬´regarder √† l'√©tranger¬ª. <br><br><img src="https://habrastorage.org/webt/cg/hb/0r/cghb0ryfnk7kgmaqhw-67emn0qc.jpeg"><br>  <i>Fig.</i>  <i>3. Num√©risation des 6e cellules.</i>  <i>Si vous ne scannez pas la 6e cellule, vous pouvez d√©terminer incorrectement le potentiel d'attaque.</i> <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   this.attackplace = 1; }</span></span></code> </pre><br>  Il n'y a peut-√™tre tout simplement pas assez d'espace pour terminer certaines attaques.  Apr√®s avoir compt√© le lieu de l'attaque, nous pouvons comprendre √† l'avance laquelle des attaques n'est pas prometteuse. <br><br><img src="https://habrastorage.org/webt/ww/fy/n4/wwfyn4tolymet3ylnf53hax6gju.jpeg"><br>  <i>Fig.</i>  <i>4. Lieu d'attaque</i> <br><br>  L'algorithme est le suivant: <br><br>  1) Commen√ßons par la cellule centrale.  Elle doit √™tre vide (nous allons y faire un pas, non? Mais nous n'oublions pas que notre IA doit substituer les chiffres de cette cellule pour l'analyse du prochain coup. Le chiffre que nous substituons est <b>this.subfig</b> - la valeur par d√©faut est une croix). √âtant donn√© que la cellule centrale contiendra initialement une certaine forme apr√®s substitution, elle appartiendra √† une attaque <b>this.curAttack</b> : <br><br><ul><li>  sa puissance ne sera pas inf√©rieure √† 1 (un chiffre dans la cellule centrale) </li><li>  diviseur - 1, car  c'est une attaque centrale (elle appartient √† la cellule scann√©e); </li><li>  le potentiel n'est pas encore connu - la valeur par d√©faut est 0; </li></ul><br><br>  Nous avons affich√© tous ces points dans les valeurs par d√©faut du constructeur - voir le code ci-dessus. <br><br>  2) Ensuite, en r√©duisant l'it√©rateur, it√®re plus de 5 cellules d'un c√¥t√© de celle num√©ris√©e.  La fonction <b>getAttacks (cellX, cellY, subFig, dx, dy) en</b> est responsable, o√π: <br><br>  <b>cellX, cellY</b> - coordonn√©es de la cellule coch√©e <br>  <b>subFig</b> - le chiffre que nous substituons dans la cellule coch√©e <br>  <b>dx, dy</b> - changements dans les coordonn√©es x et y dans les cycles - c'est ainsi que nous d√©finissons la direction de recherche: <br><br><ul><li>  Horizontale (dx = 1, dy = 0) </li><li>  Verticale (dx = 0, dy = 1) </li><li>  Diagonale 45 (dx = 1, dy = -1) </li><li>  Diagonale 135 (dx = 1, dy = 1) </li></ul><br>  Dans un sens, il s'agit d'un vecteur parall√®le √† la ligne de recherche.  Ainsi, une fonction pourra rechercher dans 4 directions et nous ne violerons pas le principe DRY √† nouveau. <br><br>  Code de fonction: <br><br><pre> <code class="javascript hljs">getAttacks( cellX, cellY, subFig, dx, dy ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.substitudeFigure( subFig ); <span class="hljs-comment"><span class="hljs-comment">//  ‚Äì  ... for( var x = cellX - dx, y = cellY - dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x -= dx, y -= dy ) if( this.checkCell( x, y ) ) break; //: //    (  ) this.turnAround(); //  -    ... for( var x = cellX + dx, y = cellY + dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x += dx, y += dy ) if( this.checkCell( x, y ) ) break; return this.Attacks; }</span></span></code> </pre><br>  Veuillez noter que si checkCell () renvoie quelque chose, la boucle s'arr√™te. <br><br>  3) Nous v√©rifions les chiffres de ces cellules. <br>  La fonction <b>checkCell (x, y) en</b> est responsable: <br><br>  Tout d'abord, √©crivez la forme dans la variable <b>fig</b> : <br>  <b>Model.Field</b> est notre terrain de jeu. <br><br><pre> <code class="javascript hljs">checkCell( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fig = Model.Field[x] &amp;&amp; Model.Field[x][y] !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> ? Model.Field[x][y] : <span class="hljs-string"><span class="hljs-string">'b'</span></span>;</code> </pre><br>  <b>fig</b> peut √™tre 'x', 'o', 'b' (bordure), 0 (cellule vide). <br><br><ul><li>  Si une telle figure co√Øncide avec la figure de la cellule centrale ( <b>this.subFig</b> ), alors nous continuons l'algorithme - alors nous continuons √† scanner l'attaque, tout va bien, nous continuons dans le m√™me esprit.  Une pi√®ce suppl√©mentaire dans l'attaque est un plus pour sa puissance ( <b>this.curAttack.capability</b> ) et sa place ( <b>this.attackplace</b> ). <br><br>  (Voir le code dans le paragraphe suivant) </li><li>  S'il s'agit d'un chiffre diff√©rent, l'attaque que nous avons analys√©e auparavant (this.curAttack) est bloqu√©e de ce c√¥t√©.  Nous ne changeons rien dans les param√®tres d'attaque, l'√©crivons dans le tableau d'attaques et sortons de la boucle. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'‚óã'</span></span> || fig == <span class="hljs-string"><span class="hljs-string">'√ó'</span></span> ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig != fig ){ <span class="hljs-comment"><span class="hljs-comment">//  this.Attacks.push( this.curAttack ); //  return fig; //      } else{ //    this.curAttack.capability++; // +   this.attackplace++; // +   } }</span></span></code> </pre><br></li><li>  S'il n'y a pas de telles cellules, cela signifie qu'elles sont tomb√©es hors de la limite du champ, ce qui signifie que l'attaque est bloqu√©e.  Nous l'√©crivons dans un tableau de toutes les attaques et sortons de la boucle. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'b'</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">// this.Attacks.push( this.curAttack ); return 'b'; }</span></span></code> </pre><br></li><li>  Si vous attrapez une cage vide, cela signifie que l'attaque en cours est termin√©e ou que nous avons affaire √† une "attaque d√©chir√©e".  Plus le potentiel et le lieu d'attaque (car l'attaque n'est pas bloqu√©e).  Cependant, nous ne sortons pas de la boucle - c'est peut-√™tre une "attaque d√©chir√©e" - nous √©crivons simplement this.curAttack dans le tableau de toutes les attaques de la ligne this.Attacks [].  Cr√©ez une nouvelle attaque ¬´actuelle¬ª et augmentez son diviseur de 1 (il s'agit d'une attaque lat√©rale). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  if( this.curAttack.capability ){ this.curAttack.potential++; this.Attacks.push( this.curAttack ); this.curAttack = new Attack; this.curAttack.potential++; } this.curAttack.divider++; this.attackplace++; }</span></span></code> </pre><br></li></ul><br><br>  4) Si sur la 5√®me cellule le chiffre co√Øncide avec la cellule centrale, alors l'attaque "reposait" contre la fronti√®re et pour d√©terminer le potentiel d'attaque, vous devrez "v√©rifier la fronti√®re" ( <b>this.checkEdge = true</b> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter == <span class="hljs-number"><span class="hljs-number">4</span></span> &amp;&amp; fig == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig ) <span class="hljs-comment"><span class="hljs-comment">// 5-  this.checkEdge = true; else if( this.iter == 5 ){ if( this.checkEdge ){ if( fig == this.curFig || fig == 0 ) this.curAttack.potential++; this.Attacks.push( this.curAttack ) } return 0; } this.iter++</span></span></code> </pre><br>  La fonction <b>checkCell</b> est pr√™te.  Cependant, nous continuons √† travailler sur la classe <b>checkLine</b> . <br><br>  5) Apr√®s avoir termin√© le premier cycle, vous devez "faire demi-tour".  Nous traduisons l'it√©rateur au centre et l'attaque centrale, avec l'index 0, le supprimons du tableau d'attaques et le d√©finissons comme l'actuel. <br><br><pre> <code class="javascript hljs">turnAround(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.checkEdge = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curAttack = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre><br>  6) Ensuite, allez de l'autre c√¥t√© de la cellule actuelle, augmentant l'it√©rateur. <br>  Absolument le m√™me contr√¥le des chiffres.  (Code d√©j√† √©crit - fonction <b>getAttacks</b> ) <br><br>  7) Tout, nous avons rassembl√© toutes les attaques qui √©taient sur la ligne dans un m√™me tableau. <br>  C'est tout avec la classe <b>checkLine ...</b> tout est fait. <br><br>  Eh bien, alors tout est simple - cr√©ez un objet <b>checkLine</b> pour chacune des lignes (2 diagonales, horizontale et verticale) et appelez la fonction <b>getAttacks</b> .  Autrement dit, pour chaque ligne - son propre objet <b>checkLine</b> et, par cons√©quent, son propre ensemble d'attaques. <br><br>  Que la fonction <b>getAllAttacks ()</b> soit responsable de tout cela - d√©j√† s√©par√©ment des classes d√©crites ci-dessus; <br><br><pre> <code class="javascript hljs">getAllAttacks( cellX, cellY ){ <span class="hljs-comment"><span class="hljs-comment">// ,  , //       if( Model.Field[ cellX ][ cellY ] ) return false var cX = []; var cO = []; //   ... cX['0'] = this.getAttacksLine( cellX, cellY, '√ó', 1, 0 ); cX['90'] = this.getAttacksLine( cellX, cellY, '√ó', 0, 1 ); cX['45'] = this.getAttacksLine( cellX, cellY, '√ó', 1, -1 ); cX['135'] = this.getAttacksLine( cellX, cellY, '√ó', 1, 1 ); //  ... cO['0'] = this.getAttacksLine( cellX, cellY, '‚óã', 1, 0 ); cO['90'] = this.getAttacksLine( cellX, cellY, '‚óã', 0, 1 ); cO['45'] = this.getAttacksLine( cellX, cellY, '‚óã', 1, -1 ); cO['135'] = this.getAttacksLine( cellX, cellY, '‚óã', 1, 1 ); return { //     'x': cX, 'o': cO } } getAttacksLine( cellX, cellY, subFig, dx, dy ){ //      var C = new checkLine; C.getAttacks( cellX, cellY, subFig, dx, dy ); return this.filterAttacks( C ) //   }</span></span></code> </pre><br>  En sortie, nous avons un objet avec toutes les attaques pour la cellule test√©e <br><br>  Cependant, vous avez peut-√™tre remarqu√© une sorte de fonction de filtre.  Sa t√¢che est de filtrer les attaques ¬´futiles¬ª: <br><br><ul><li>  Avec une puissance nulle (on ne sait jamais s'ils entrent dans le r√©seau) </li><li>  Attaques qui manquent d'espace (lieu d'attaque &lt;5) </li><li>  Avec un potentiel nul. </li></ul><br>  Cependant, si l'attaque a une puissance sup√©rieure √† 5, le filtre la sautera.  Le bot doit voir de telles attaques, leur d√©pistage entra√Ænera des jambages en fin de partie. <br><br><pre> <code class="javascript hljs">filterAttacks( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( attackLine.attackplace &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) attackLine.Attacks.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &amp;&amp; a.potential || a.capability &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) res.push( a ) }) attackLine.Attacks = res; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res }</code> </pre><br><h3>  Points d'arr√™t </h3><br>  Oui ... encore une fois, d√©sol√©!  Nous appellerons donc la situation dans le jeu, lorsqu'un mauvais coup d√©cide du r√©sultat du jeu. <br><br>  Par exemple, une attaque [3: 2] est un point d'arr√™t.  Si l'adversaire ne le bloque pas en pla√ßant une pi√®ce √† c√¥t√© de lui, alors au prochain coup, nous avons d√©j√† une attaque [4: 2] sur le terrain de jeu - eh bien, le r√©sultat du jeu est d√©cid√©, quoi qu'on puisse dire (dans la grande majorit√© des cas). <br><br>  Ou une attaque [4: 1].  Un b√¢illement - et le jeu peut √™tre facilement termin√©. <br><br><img src="https://habrastorage.org/webt/bd/vc/d0/bdvcd0jzf2wiiqqm9wupccpgmn4.jpeg"><br>  <i>Figure 5. Point d'arr√™t</i> <br><br>  Tout est clair et compr√©hensible, et l'algorithme d√©crit ci-dessus est d√©j√† capable de prendre en compte les points d'arr√™t et de les bloquer en temps opportun.  Le bot attend avec impatience.  Il verra qu'au prochain tour, l'adversaire est capable de cr√©er une attaque [5: 1], par exemple, dont le poids est de 200 - ce qui signifie que le ringard rus√© ira ici. <br><br>  Cependant, imaginez une situation o√π l'un des joueurs parvient √† obtenir 2 points d'arr√™t sur le terrain.  Et cela, √©videmment, ne laisse aucune chance √† l'adversaire, car  d'un seul coup, nous ne pouvons bloquer qu'un seul point d'arr√™t.  Comment apprendre √† notre IA √† bloquer de telles attaques? <br><br><img src="https://habrastorage.org/webt/bh/qu/79/bhqu79lupldi6d3pshuan0lxcmg.jpeg"><br>  <i>Figure 6. 2 points d'arr√™t</i> <br><br>  Tout est simple, lors de l'analyse d'une cellule, en y substituant une pi√®ce, nous compterons le nombre de points d'arr√™t que nous obtiendrons au prochain coup (le bot regarde le pas en avant, n'oubliez pas).  En comptant 2 points d'arr√™t, nous augmentons le poids des cellules de 100. <br><br>  Et maintenant, le bot emp√™chera non seulement de telles situations de jeu, mais pourra √©galement les cr√©er, ce qui en fait maintenant un adversaire plus redoutable. <br><br><h3>  Comment comprendre qu'une attaque est un point d'arr√™t </h3><br>  Commen√ßons par l'√©vidence: toute attaque d'une puissance de 4 est un point d'arr√™t.  Un seul coup manqu√© nous donne la possibilit√© de terminer le jeu, c'est-√†-dire  mettre 5 morceaux d'affil√©e. <br><br>  De plus, si le potentiel d'attaque est de 2, alors nous d√©penserons 1 tour de plus pour bloquer une telle attaque, ce qui signifie qu'il y a un point d'arr√™t d'une puissance de 3. Mais il n'y a qu'un seul point d'arr√™t - c'est une attaque [3: 2]. <br><br>  Et encore plus difficile - <b>"attaques d√©chir√©es"</b> . <br>  Nous ne consid√©rerons que les attaques avec une cellule vide au milieu - pas plus.  En effet, pour terminer l'attaque avec deux cellules vides au milieu, vous devez d√©penser au moins 2 mouvements - ce n'est clairement pas un point d'arr√™t. <br><br>  Comme nous nous en souvenons, nous consid√©rons les attaques d√©chir√©es comme plusieurs attaques classiques: une attaque centrale et des attaques lat√©rales.  L'attaque centrale appartient √† la cellule scann√©e, le diviseur lat√©ral en a plus de 1 - cela a √©t√© d√©crit ci-dessus. <br><br>  Algorithme pour trouver un point d'arr√™t (plus facile, lire ci-dessous): <br><br><ol><li>  Nous introduisons le <b>score</b> variable </li><li>  On prend l'attaque centrale, on consid√®re le pouvoir </li><li>  Nous prenons l'un des c√¥t√©s si son diviseur n'est pas plus de 2x. </li><li>  <b>Score</b> - la somme de la puissance des attaques centrales et lat√©rales </li><li>  Si les potentiels des attaques centrales et lat√©rales sont de 2, alors pour bloquer une telle attaque, vous devez passer un tour de plus.  Par cons√©quent, le score est augment√© de 1 </li><li>  Si <b>score</b> &gt; = 4, alors c'est un point d'arr√™t <br>  En fait, les points d'arr√™t pouvaient simplement √™tre √©num√©r√©s, il n'y en a pas beaucoup, mais je n'ai pas tout de suite compris cela. </li></ol><br><pre> <code class="javascript hljs">isBreakPoint( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attackLine || ! attackLine.length ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> centAtk; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">1</span></span> ) centAtk = a; }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.potential == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> score = centAtk.capability; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">//side attack if( centAtk.potential == 2 &amp;&amp; a.potential == 2 ) score++; if( score + a.capability &gt;= 4 ){ res = true; return; } } }) return res; }</span></span></code> </pre><br><h3>  Oui, nous allons enfin tout rassembler </h3><br>  Ainsi, l'enfer principal derri√®re est d√©crit ci-dessus.  Il est temps de fa√ßonner quelque chose qui fonctionne √† partir de cela.  Fonction <b>countWeight (x, y)</b> - prend les coordonn√©es de la cellule en entr√©e et renvoie son poids.  Qu'y a-t-il sous sa capuche? <br><br>  Tout d'abord, nous obtenons un tableau de toutes les attaques auxquelles appartient la cellule.  ( <b>getAllAttacks (x, y)</b> ).  En parcourant toutes les lignes, nous comptons le nombre de points d'arr√™t.  S'il y a 2 points d'arr√™t, nous rappelons qu'une telle situation peut d√©cider du r√©sultat du jeu et augmenter le poids des cellules de 100. <br>  Cependant, tous les points d'arr√™t doivent appartenir √† un seul joueur, j'ai donc d√ª impl√©menter une v√©rification en 2 √©tapes: d'abord les croix, puis les z√©ros. <br><br>  √âtant donn√© que dans la gamme de poids d'attaque ( <b>ATTACK_WEIGHTS []</b> ), je n'ai pas fourni d'attaques d'une puissance de 6 ou plus, j'ai d√ª les remplacer par des attaques d'une puissance de 5. Cela ne fait aucune diff√©rence - ils m√®nent tous √† la fin du jeu. <br><br>  Eh bien, nous r√©sumons les poids d'attaque - c'est tout. <br><br>  Autre petit point: pour que le bot ne soit pas stupide en fin de partie, quand il a d√©j√† construit une attaque avec une puissance de 4 et pense au coup en cours, il faut augmenter significativement le poids de la cellule pour terminer une telle attaque.  Sans cela, l'IA peut tout simplement commencer √† se d√©fendre contre les attaques ¬´dangereuses¬ª de l'adversaire, bien que le jeu semble gagn√©.  Le dernier mouvement est important. <br><br><pre> <code class="javascript hljs">countWeight( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attacks = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getAttacks( x, y ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attacks ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.x, <span class="hljs-string"><span class="hljs-string">'√ó'</span></span> ); sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.o, <span class="hljs-string"><span class="hljs-string">'‚óã'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> atks, curFig </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weight = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> breakPoints = <span class="hljs-number"><span class="hljs-number">0</span></span>; [ <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"45"</span></span>, <span class="hljs-string"><span class="hljs-string">"90"</span></span>, <span class="hljs-string"><span class="hljs-string">"135"</span></span> ].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> p </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isBreakPoint( atks[p] ) ){ debug( <span class="hljs-string"><span class="hljs-string">"Break point"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ++breakPoints == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; debug( <span class="hljs-string"><span class="hljs-string">"Good cell"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } atks[p].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ) a.capability = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability == <span class="hljs-number"><span class="hljs-number">5</span></span> &amp;&amp; curFig == Model.whoPlays.char ) weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; weight += a.getWeight(); }); }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weight } }</code> </pre><br>  Maintenant, lors de l'appel de cette fonction pour une cellule sp√©cifique, nous obtiendrons son poids.  Nous effectuons cette op√©ration pour toutes les cellules et s√©lectionnons la meilleure (avec le poids le plus √©lev√©).  L√† et allez) <br><br>  Vous pouvez trouver le reste du code sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> .  Il y a d√©j√† beaucoup de mat√©riel, et sa pr√©sentation, comme je n'ai pas essay√©, laisse beaucoup √† d√©sirer.  Mais si vous pouviez lire jusqu'ici, cher lecteur, je vous en serais reconnaissant. <br><br><h3>      </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descends! </font><font style="vertical-align: inherit;">Oui, vous pouvez le battre, mais le faire est un peu probl√©matique pour moi personnellement. </font><font style="vertical-align: inherit;">Peut-√™tre que je ne fais pas assez attention. </font><font style="vertical-align: inherit;">Essayez aussi votre force. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je sais que c'est plus facile, mais je ne sais pas comment. </font><font style="vertical-align: inherit;">Je voudrais √©couter les gens qui connaissent ou regardent d'autres impl√©mentations d'un tel bot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je sais ce qui peut √™tre mieux. </font><font style="vertical-align: inherit;">Oui ... vous pouvez utiliser des algorithmes bien connus, tels que minimax, mais pour cela, vous devez avoir une base de connaissances dans le domaine de la th√©orie des jeux, dont je ne peux malheureusement pas me vanter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä l'avenir, je pr√©vois d'ajouter une analyse des points d'arr√™t √† plusieurs √©tapes, ce qui fera du bot un adversaire encore plus s√©rieux. </font><font style="vertical-align: inherit;">Cependant, maintenant je n'ai pas une id√©e claire de la mise en ≈ìuvre de cela; </font><font style="vertical-align: inherit;">J'ai juste la prochaine session et un dipl√¥me incomplet - ce qui m'attriste. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merci si vous lisez jusqu'au bout.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430708/">https://habr.com/ru/post/fr430708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430694/index.html">Un petit guide pour apprendre le C ++: quoi, quand et sur quoi cr√©er</a></li>
<li><a href="../fr430700/index.html">Un syst√®me unifi√© d'enregistrement des vues de films en ligne commencera √† fonctionner en Russie</a></li>
<li><a href="../fr430702/index.html">Formation tr√®s √©trange</a></li>
<li><a href="../fr430704/index.html">Comment les technologies de l'intelligence artificielle aident les ventes d'avias √† se d√©velopper: sept exemples</a></li>
<li><a href="../fr430706/index.html">Nouvelle th√©orie de l'√©volution</a></li>
<li><a href="../fr430710/index.html">Que faire si le Black Friday est demain et que vos serveurs ne sont pas pr√™ts</a></li>
<li><a href="../fr430712/index.html">NeurIPS: Comment conqu√©rir la meilleure conf√©rence ML</a></li>
<li><a href="../fr430714/index.html">VMware ach√®te Heptio - qu'est-ce que cela signifie pour Kubernetes</a></li>
<li><a href="../fr430718/index.html">Pour quels objets vaut-il la peine d'utiliser la vid√©osurveillance dans le cloud?</a></li>
<li><a href="../fr430720/index.html">Intel RealSense D435i: petite mise √† jour et courte digression historique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>