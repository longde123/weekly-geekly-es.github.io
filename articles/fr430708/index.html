<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍💻 👨‍🍳 👨‍✈️ Tic Tac Toe «Sans Frontières» 🖖🏽 👪 🔅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tic-tac-toe ... tout le monde les a joués, j'en suis sûr. Le jeu est séduisant par sa simplicité, surtout lorsque vous faites glisser l'horloge quelqu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tic Tac Toe «Sans Frontières»</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430708/"> Tic-tac-toe ... tout le monde les a joués, j'en suis sûr.  Le jeu est séduisant par sa simplicité, surtout lorsque vous faites glisser l'horloge quelque part dans la leçon, un couple, et il n'y a rien à portée de main, sauf une feuille de cahier et un simple crayon.  Je ne sais pas qui a été le premier à avoir pensé à dessiner des croix et des cercles sur 9 cases, mais depuis lors, le jeu n'a plus perdu en demande, d'autant plus que les gens ont proposé de nombreuses variantes. <br><br><img src="https://habrastorage.org/webt/pd/gx/-c/pdgx-cibc6880fmwfxt90nxmi-k.jpeg"><br><br>  Cet article concerne le processus de développement de l'IA sur javascript pour jouer à l'une de ces variations de tic-tac-toe: j'ai beaucoup de matériel, mais je l'ai dilué avec de l'animation et des images.  Dans tous les cas, au moins ça vaut le coup d'essayer de le jouer. <br>  Les différences entre cette version du jeu et l'original sont les suivantes: <br><br><ol><li>  <b>Le champ</b> peut être arbitrairement <b>grand</b> (combien de temps durera le bloc-notes) </li><li>  Le gagnant est celui qui met <b>5 pièces</b> (si vous pouvez les appeler ainsi) dans une rangée. </li></ol><br>  Tout est simple ... et en même temps compliqué: le résultat du jeu ne peut pas être calculé à l'avance, comme dans l'analogue classique.  Cette "petite projection" m'a enlevé beaucoup de temps et de nerfs.  J'espère que vous le trouverez intéressant. <a name="habracut"></a><br><br><h3>  Avant de commencer </h3><br>  Forcé de m'excuser à l'avance pour le volume de l'article et à certains endroits une présentation de pensée pas tout à fait intelligible, cependant, je n'ai pas pu serrer le troupeau sans perte de contenu et de qualité. <br>  Je vous recommande de vous familiariser d'abord avec le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">résultat</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code</a> <br><br>  Raccourcis clavier et commandes: <br><br><ul><li>  <b>D</b> - AI fera un pas pour vous </li><li>  <b>T</b> - voir le poids des cellules </li><li>  Écrivez <b>SHOW_WEIGHTS = true</b> dans la console pour afficher les poids de toutes les cellules analysées. </li></ul><br><h3>  Commençons </h3><br>  Vous devez commencer par la mise en œuvre du jeu lui-même, c'est-à-dire  écrire une application pour deux joueurs, jusqu'ici sans bot.  Pour mes besoins, j'ai décidé d'utiliser javascript + jquery + bootstrap4, bien qu'il n'y soit pratiquement pas utilisé, mais il vaut mieux le laisser - sinon la table flottera.  Il n'y a rien de spécial à dire, il y a beaucoup de matériel sur js, jquery et bootstrap.  Je peux seulement dire que j'ai utilisé MVC.  Quoi qu'il en soit, je n'expliquerai pas absolument tout le code - il y a déjà eu beaucoup de matériel. <br><br>  Le terrain de jeu était donc prêt.  Vous pouvez définir des formes dans les cellules.  Mais la victoire de l'un des joueurs n'a été fixée en aucune façon. <br><br><h3>  Analyse de fin de partie </h3><br>  Le jeu se termine lorsque l'un des joueurs met <b>5 pièces</b> d'affilée.  "C'est simple!"  Pensai-je.  Et il a commencé à balayer absolument toutes les cellules du champ: tout d'abord l'horizontale, puis la verticale, et enfin les diagonales. <br><br>  C'est une façon stupide, mais cela a fonctionné.  Cependant, cela pourrait être considérablement amélioré, ce que j'ai fait: la plupart des cellules resteront vides tout au long du jeu - le terrain de jeu est trop grand pour être entièrement rempli.  Puisqu'il était nécessaire de le scanner à chaque mouvement, et qu'une seule pièce est placée en un seul mouvement - vous pouvez vous concentrer uniquement sur cette pièce (cellule): scannez seulement une horizontale, verticale et deux diagonales de la cellule qui possède la même cellule. <br><br>  De plus, vous n'avez pas besoin de scanner toutes les lignées cellulaires.  Puisque la fin du jeu est de 5 pièces d'affilée, les pièces qui sont à 6 cases les unes des autres ne nous intéressent pas.  Il suffit de scanner cinq cellules de chaque côté.  Je ne comprends pas?  Voir l'animation ci-dessous. <br><br><img src="https://habrastorage.org/webt/nt/fj/wu/ntfjwuj6nfabfj2qtedcs4g-fp0.gif"><br><br><div class="spoiler">  <b class="spoiler_title">Afficher le code</b> <div class="spoiler_text"><pre><code class="javascript hljs">checkWin( cellX, cellY ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newFig = getFig(cellX,cellY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! newFig ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res; res = res || checkLine( cellX, cellY, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-comment"><span class="hljs-comment">//horizontal res = res || checkLine( cellX, cellY, 0, 1 ); //vertical res = res || checkLine( cellX, cellY, 1, 1 ); //diagonal 45 res = res || checkLine( cellX, cellY, 1, -1 ); //diagonal 135 return res; function getFig( x, y ){ return Model.Field[x] &amp;&amp; Model.Field[x][y] ? Model.Field[x][y] : 'b'; } function checkLine( x, y, dx, dy ){ x = +x; y = +y; var score = 0; while( getFig( x - dx, y - dy ) == newFig ){ x -= dx; y -= dy; } while( getFig( x, y ) == newFig ){ x += dx; y += dy; score++; } if( score &gt;= 5 ) return true; return false; } }</span></span></code> </pre> <br></div></div><br><h3>  Descendons au bot lui-même </h3><br>  Donc, nous avons déjà écrit une page avec tic-tac-toe.  Nous passons à la tâche principale - l'IA. <br>  Vous ne pouvez pas simplement prendre et écrire du code si vous ne savez pas comment: vous devez réfléchir à la logique du bot. <br><br>  L'essentiel est d'analyser le terrain de jeu, au moins une partie de celui-ci, et de calculer le <b>prix (poids) de</b> chaque cellule sur le terrain.  La cellule avec le poids le plus élevé - la plus prometteuse - le bot y mettra un chiffre.  La principale difficulté est de calculer le poids d'une cellule. <br><br><h3>  Terminologie </h3><br>  <b>Les croix et les orteils</b> sont des figures. <br>  <b>Une attaque</b> sera appelée plusieurs personnages identiques côte à côte sur la même ligne.  En fait, c'est beaucoup.  Le nombre de pièces dans une attaque est sa <b>puissance</b> .  Une pièce distincte est également une attaque (puissance 1). <br><br>  Sur les cellules d'attaque adjacentes (aux extrémités), il peut y avoir des cellules vides ou des pièces ennemies.  Il est logique de penser qu'une attaque avec deux cellules vides aux «extrémités» peut se développer dans deux directions, ce qui la rend plus prometteuse.  Le nombre de cellules vides aux "extrémités" de l'attaque sera appelé son <b>potentiel</b> .  Le potentiel peut être 0, 1 ou 2. <br>  Nous désignons les attaques comme suit: <b>[puissance d'attaque, potentiel]</b> .  Par exemple, une <b>attaque [4: 1]</b> . <br><br><img src="https://habrastorage.org/webt/1_/pk/e3/1_pke3kve1yjbf6cjjzg3hnnzvm.jpeg"><br>  <i>Figure 1. Attaque [4: 1]</i> <br><br>  Au cours de l'analyse, nous évaluerons toutes les cellules qui entrent dans une zone spécifique.  Chaque cellule calculera son <b>poids</b> .  Il est calculé sur la base du poids de toutes les attaques que cette cellule affecte. <br><br><h3>  L'essence de l'analyse </h3><br>  Imaginez que sur le terrain de jeu, il y a déjà plusieurs attaques d'un et du deuxième joueur.  Un des joueurs fait un mouvement (laissez les croix).  Naturellement, il se déplace vers une cellule vide - et ainsi il peut: <br><br><ol><li>  Développez votre attaque, et peut-être plus d'une, en augmentant sa puissance.  Peut lancer une nouvelle attaque, etc. </li><li>  Empêchez le développement d'une attaque ennemie ou bloquez-la complètement. </li></ol><br>  Autrement dit, notre protagoniste peut attaquer et défendre.  Ou peut-être d'un coup.  Pour lui, le premier et le second sont importants. <br><br>  L'essence de l'analyse est la suivante: <br><br><ol><li>  Le bot substitue les chiffres de la cellule cochée: d'abord une croix, puis un zéro. </li><li>  Il recherche ensuite toutes les attaques reçues par de tels mouvements et résume leurs poids. </li><li>  Le montant reçu est le poids de la cellule. </li><li>  Un algorithme similaire est exécuté pour toutes les cellules du terrain de jeu. </li></ol><br><img src="https://habrastorage.org/webt/ur/rc/qz/urrcqzyrjrnp9oupxjoqc1iu6wg.gif"><br><br>  En fait, nous vérifions avec un tel algorithme ce qui se passera si nous allons de cette façon ... et ce qui se passera si l'adversaire va de cette façon.  Nous attendons avec impatience une étape et sélectionnons la cellule la plus appropriée - avec le poids le plus élevé. <br><br>  Si une cellule a plus de poids qu'une autre, elle conduit à la création d'attaques plus dangereuses ou à bloquer de fortes attaques ennemies.  Tout est logique ... il me semble. <br>  Si vous allez sur la page et écrivez dans la console SHOW_WEIGHTS = true, vous pouvez sentir visuellement le fonctionnement de l'algorithme (les poids des cellules seront affichés). <br><br><h3>  Poids d'attaque </h3><br>  Je suis allé sur mon cerveau et apporté une telle correspondance d'attaques et de poids: <br><br><pre> <code class="javascript hljs">ATTACK_WEIGHT = [[],[],[],[],[],[]]; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0.1</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">6</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0.25</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">5</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">7</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">4</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">100</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>; ATTACK_WEIGHT[<span class="hljs-number"><span class="hljs-number">5</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre><br>  Empiriquement sélectionné - ce n'est peut-être pas la meilleure option. <br><br>  J'ai ajouté une puissance d'attaque de 5 avec un poids prohibitif à la matrice.  Cela peut s'expliquer par le fait que le bot analyse le jeu en regardant un pas en avant (en remplaçant la figure dans la cellule).  Sauter une telle attaque n'est rien d'autre qu'une défaite.  Eh bien, ou la victoire ... selon qui. <br><br>  Les attaques à fort potentiel sont valorisées plus haut. <br><br>  L'attaque [4: 2] dans la plupart des cas décide du résultat de la partie.  Si le joueur a réussi à créer une telle attaque, l'adversaire ne pourra plus la bloquer.  Mais ce n'est pas une victoire.  L'ennemi peut terminer le jeu plus rapidement, même si nous avons une attaque [4: 2] sur le terrain, donc son poids est inférieur à celui des attaques d'une puissance de 5. Voir un exemple ci-dessous. <br><br><img src="https://habrastorage.org/webt/pk/4u/mm/pk4ummarchcw9j4lpkujlmj_iig.jpeg"><br>  <i>Figure 2. Attaque [4: 2]</i> <br><br><h3>  Attaques déchirées </h3><br>  Le code n'est pas présenté dans ce paragraphe.  Ici, nous introduisons le concept d'un diviseur d'attaque et expliquons l'essence des <b>«attaques déchirées»</b> . <br><br>  Considérez la situation suivante: lorsque vous remplacez un chiffre pour supprimer plusieurs cellules vides, mais pas plus de 5, une autre est localisée. <br><br>  Et, semble-t-il, deux figures identiques, sur la même ligne ... visuellement cela ressemble à une attaque, mais en fait non.  Pas un ordre, car de telles attaques "déchirées" comportent également une menace potentielle. <br><br>  Surtout pour de tels cas, pour chaque attaque, nous calculerons le diviseur.  Initialement, sa valeur est 1. <br><br><ol><li>  Nous présentons l'attaque "déchirée" comme plusieurs </li><li>  On compte le nombre de cellules vides entre l'attaque centrale et le côté </li><li>  Pour chaque cellule vide, le diviseur est augmenté de 1 </li><li>  Nous calculons le poids de l'attaque centrale comme d'habitude, le poids des attaques latérales - divisé par le diviseur </li></ol><br><img src="https://habrastorage.org/webt/dc/w9/62/dcw9629rd4zdhomn6q2uwi5yxkg.jpeg"><br>  <i>Fig 3. Analyse de "Attaque déchirée".</i>  <i>Une cellule avec une croix jaune est scannée.</i> <br><br>  Ainsi, les attaques déchirées seront également prises en compte par l'IA.  En fait, ce seront des attaques ordinaires, mais plus elles sont éloignées de la cellule scannée, moins elles ont d'influence sur elle et, par conséquent, elles ont moins de poids (grâce au diviseur). <br><br><h3>  Algorithme de recherche d'attaque </h3><br>  Créez d'abord <b>une classe d'</b> attaque.  L'attaque aura 3 attributs, dont j'ai parlé plus tôt: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attack</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( cap = 0, pot = 0, div = 1 ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability = cap; <span class="hljs-comment"><span class="hljs-comment">// this.potential = pot; // this.divider = div; // }</span></span></code> </pre><br>  Et une <b>méthode</b> qui renverra le poids d'une attaque donnée: <br><br><pre> <code class="javascript hljs">countWeigth(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ATTACK_WEIGHT[ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.capability, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.potential ] / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.divider } }</code> </pre><br>  Ensuite.  Nous diviserons la recherche de toutes les attaques pour une cellule en: <br><br><ol><li>  Recherche horizontale </li><li>  Recherche verticale </li><li>  Recherche diagonale à 45 degrés </li><li>  Recherche en diagonale à 135 degrés </li></ol><br>  Ce sont toutes des <b>lignes</b> , et l'algorithme de recherche d'attaques sur ces lignes peut être généralisé: <b>la classe checkLine</b> . <br><br>  Cependant, nous n'avons pas besoin de vérifier toute la ligne.  La puissance d'attaque maximale qui nous intéresse est de 5. Bien sûr, il est possible de créer une attaque avec une puissance de, disons, 6.  Mais pour une IA qui analyse la situation de jeu du prochain coup, c'est la même chose que 6 ou 5. La perspective d'obtenir l'une de ces attaques indique la fin du jeu au coup suivant.  En conséquence, le poids de la cellule analysée sera le même dans les deux cas. <br><br>  Attributs de classe: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">checkLine</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-comment"><span class="hljs-comment">//,        this.subFig = "×"; //     .    «0» - . this.Attacks = []; //  this.curAttack = new Attack; // (      ) this.iter = 1; //,     this.checkEdge = false;</span></span></code> </pre><br>  Il faut s'arrêter là, car la question peut se poser: pourquoi vérifier la 6e cellule si la puissance d'attaque maximale est 5. La réponse est de déterminer le potentiel éloigné du centre d'attaque. <br><br>  Voici un exemple: une attaque avec une puissance de 1 dans l'image se situe à la frontière de la zone scannée.  Pour découvrir le potentiel de cette attaque, vous devez «regarder à l'étranger». <br><br><img src="https://habrastorage.org/webt/cg/hb/0r/cghb0ryfnk7kgmaqhw-67emn0qc.jpeg"><br>  <i>Fig.</i>  <i>3. Numérisation des 6e cellules.</i>  <i>Si vous ne scannez pas la 6e cellule, vous pouvez déterminer incorrectement le potentiel d'attaque.</i> <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   this.attackplace = 1; }</span></span></code> </pre><br>  Il n'y a peut-être tout simplement pas assez d'espace pour terminer certaines attaques.  Après avoir compté le lieu de l'attaque, nous pouvons comprendre à l'avance laquelle des attaques n'est pas prometteuse. <br><br><img src="https://habrastorage.org/webt/ww/fy/n4/wwfyn4tolymet3ylnf53hax6gju.jpeg"><br>  <i>Fig.</i>  <i>4. Lieu d'attaque</i> <br><br>  L'algorithme est le suivant: <br><br>  1) Commençons par la cellule centrale.  Elle doit être vide (nous allons y faire un pas, non? Mais nous n'oublions pas que notre IA doit substituer les chiffres de cette cellule pour l'analyse du prochain coup. Le chiffre que nous substituons est <b>this.subfig</b> - la valeur par défaut est une croix). Étant donné que la cellule centrale contiendra initialement une certaine forme après substitution, elle appartiendra à une attaque <b>this.curAttack</b> : <br><br><ul><li>  sa puissance ne sera pas inférieure à 1 (un chiffre dans la cellule centrale) </li><li>  diviseur - 1, car  c'est une attaque centrale (elle appartient à la cellule scannée); </li><li>  le potentiel n'est pas encore connu - la valeur par défaut est 0; </li></ul><br><br>  Nous avons affiché tous ces points dans les valeurs par défaut du constructeur - voir le code ci-dessus. <br><br>  2) Ensuite, en réduisant l'itérateur, itère plus de 5 cellules d'un côté de celle numérisée.  La fonction <b>getAttacks (cellX, cellY, subFig, dx, dy) en</b> est responsable, où: <br><br>  <b>cellX, cellY</b> - coordonnées de la cellule cochée <br>  <b>subFig</b> - le chiffre que nous substituons dans la cellule cochée <br>  <b>dx, dy</b> - changements dans les coordonnées x et y dans les cycles - c'est ainsi que nous définissons la direction de recherche: <br><br><ul><li>  Horizontale (dx = 1, dy = 0) </li><li>  Verticale (dx = 0, dy = 1) </li><li>  Diagonale 45 (dx = 1, dy = -1) </li><li>  Diagonale 135 (dx = 1, dy = 1) </li></ul><br>  Dans un sens, il s'agit d'un vecteur parallèle à la ligne de recherche.  Ainsi, une fonction pourra rechercher dans 4 directions et nous ne violerons pas le principe DRY à nouveau. <br><br>  Code de fonction: <br><br><pre> <code class="javascript hljs">getAttacks( cellX, cellY, subFig, dx, dy ){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.substitudeFigure( subFig ); <span class="hljs-comment"><span class="hljs-comment">//  –  ... for( var x = cellX - dx, y = cellY - dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x -= dx, y -= dy ) if( this.checkCell( x, y ) ) break; //: //    (  ) this.turnAround(); //  -    ... for( var x = cellX + dx, y = cellY + dy; Math.abs( x - cellX ) &lt;= 5 &amp;&amp; Math.abs( y - cellY ) &lt;= 5; x += dx, y += dy ) if( this.checkCell( x, y ) ) break; return this.Attacks; }</span></span></code> </pre><br>  Veuillez noter que si checkCell () renvoie quelque chose, la boucle s'arrête. <br><br>  3) Nous vérifions les chiffres de ces cellules. <br>  La fonction <b>checkCell (x, y) en</b> est responsable: <br><br>  Tout d'abord, écrivez la forme dans la variable <b>fig</b> : <br>  <b>Model.Field</b> est notre terrain de jeu. <br><br><pre> <code class="javascript hljs">checkCell( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fig = Model.Field[x] &amp;&amp; Model.Field[x][y] !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> ? Model.Field[x][y] : <span class="hljs-string"><span class="hljs-string">'b'</span></span>;</code> </pre><br>  <b>fig</b> peut être 'x', 'o', 'b' (bordure), 0 (cellule vide). <br><br><ul><li>  Si une telle figure coïncide avec la figure de la cellule centrale ( <b>this.subFig</b> ), alors nous continuons l'algorithme - alors nous continuons à scanner l'attaque, tout va bien, nous continuons dans le même esprit.  Une pièce supplémentaire dans l'attaque est un plus pour sa puissance ( <b>this.curAttack.capability</b> ) et sa place ( <b>this.attackplace</b> ). <br><br>  (Voir le code dans le paragraphe suivant) </li><li>  S'il s'agit d'un chiffre différent, l'attaque que nous avons analysée auparavant (this.curAttack) est bloquée de ce côté.  Nous ne changeons rien dans les paramètres d'attaque, l'écrivons dans le tableau d'attaques et sortons de la boucle. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'○'</span></span> || fig == <span class="hljs-string"><span class="hljs-string">'×'</span></span> ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig != fig ){ <span class="hljs-comment"><span class="hljs-comment">//  this.Attacks.push( this.curAttack ); //  return fig; //      } else{ //    this.curAttack.capability++; // +   this.attackplace++; // +   } }</span></span></code> </pre><br></li><li>  S'il n'y a pas de telles cellules, cela signifie qu'elles sont tombées hors de la limite du champ, ce qui signifie que l'attaque est bloquée.  Nous l'écrivons dans un tableau de toutes les attaques et sortons de la boucle. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fig == <span class="hljs-string"><span class="hljs-string">'b'</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">// this.Attacks.push( this.curAttack ); return 'b'; }</span></span></code> </pre><br></li><li>  Si vous attrapez une cage vide, cela signifie que l'attaque en cours est terminée ou que nous avons affaire à une "attaque déchirée".  Plus le potentiel et le lieu d'attaque (car l'attaque n'est pas bloquée).  Cependant, nous ne sortons pas de la boucle - c'est peut-être une "attaque déchirée" - nous écrivons simplement this.curAttack dans le tableau de toutes les attaques de la ligne this.Attacks [].  Créez une nouvelle attaque «actuelle» et augmentez son diviseur de 1 (il s'agit d'une attaque latérale). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  if( this.curAttack.capability ){ this.curAttack.potential++; this.Attacks.push( this.curAttack ); this.curAttack = new Attack; this.curAttack.potential++; } this.curAttack.divider++; this.attackplace++; }</span></span></code> </pre><br></li></ul><br><br>  4) Si sur la 5ème cellule le chiffre coïncide avec la cellule centrale, alors l'attaque "reposait" contre la frontière et pour déterminer le potentiel d'attaque, vous devrez "vérifier la frontière" ( <b>this.checkEdge = true</b> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter == <span class="hljs-number"><span class="hljs-number">4</span></span> &amp;&amp; fig == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subFig ) <span class="hljs-comment"><span class="hljs-comment">// 5-  this.checkEdge = true; else if( this.iter == 5 ){ if( this.checkEdge ){ if( fig == this.curFig || fig == 0 ) this.curAttack.potential++; this.Attacks.push( this.curAttack ) } return 0; } this.iter++</span></span></code> </pre><br>  La fonction <b>checkCell</b> est prête.  Cependant, nous continuons à travailler sur la classe <b>checkLine</b> . <br><br>  5) Après avoir terminé le premier cycle, vous devez "faire demi-tour".  Nous traduisons l'itérateur au centre et l'attaque centrale, avec l'index 0, le supprimons du tableau d'attaques et le définissons comme l'actuel. <br><br><pre> <code class="javascript hljs">turnAround(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.iter = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.checkEdge = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.curAttack = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Attacks.splice(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre><br>  6) Ensuite, allez de l'autre côté de la cellule actuelle, augmentant l'itérateur. <br>  Absolument le même contrôle des chiffres.  (Code déjà écrit - fonction <b>getAttacks</b> ) <br><br>  7) Tout, nous avons rassemblé toutes les attaques qui étaient sur la ligne dans un même tableau. <br>  C'est tout avec la classe <b>checkLine ...</b> tout est fait. <br><br>  Eh bien, alors tout est simple - créez un objet <b>checkLine</b> pour chacune des lignes (2 diagonales, horizontale et verticale) et appelez la fonction <b>getAttacks</b> .  Autrement dit, pour chaque ligne - son propre objet <b>checkLine</b> et, par conséquent, son propre ensemble d'attaques. <br><br>  Que la fonction <b>getAllAttacks ()</b> soit responsable de tout cela - déjà séparément des classes décrites ci-dessus; <br><br><pre> <code class="javascript hljs">getAllAttacks( cellX, cellY ){ <span class="hljs-comment"><span class="hljs-comment">// ,  , //       if( Model.Field[ cellX ][ cellY ] ) return false var cX = []; var cO = []; //   ... cX['0'] = this.getAttacksLine( cellX, cellY, '×', 1, 0 ); cX['90'] = this.getAttacksLine( cellX, cellY, '×', 0, 1 ); cX['45'] = this.getAttacksLine( cellX, cellY, '×', 1, -1 ); cX['135'] = this.getAttacksLine( cellX, cellY, '×', 1, 1 ); //  ... cO['0'] = this.getAttacksLine( cellX, cellY, '○', 1, 0 ); cO['90'] = this.getAttacksLine( cellX, cellY, '○', 0, 1 ); cO['45'] = this.getAttacksLine( cellX, cellY, '○', 1, -1 ); cO['135'] = this.getAttacksLine( cellX, cellY, '○', 1, 1 ); return { //     'x': cX, 'o': cO } } getAttacksLine( cellX, cellY, subFig, dx, dy ){ //      var C = new checkLine; C.getAttacks( cellX, cellY, subFig, dx, dy ); return this.filterAttacks( C ) //   }</span></span></code> </pre><br>  En sortie, nous avons un objet avec toutes les attaques pour la cellule testée <br><br>  Cependant, vous avez peut-être remarqué une sorte de fonction de filtre.  Sa tâche est de filtrer les attaques «futiles»: <br><br><ul><li>  Avec une puissance nulle (on ne sait jamais s'ils entrent dans le réseau) </li><li>  Attaques qui manquent d'espace (lieu d'attaque &lt;5) </li><li>  Avec un potentiel nul. </li></ul><br>  Cependant, si l'attaque a une puissance supérieure à 5, le filtre la sautera.  Le bot doit voir de telles attaques, leur dépistage entraînera des jambages en fin de partie. <br><br><pre> <code class="javascript hljs">filterAttacks( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( attackLine.attackplace &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) attackLine.Attacks.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &amp;&amp; a.potential || a.capability &gt;= <span class="hljs-number"><span class="hljs-number">5</span></span> ) res.push( a ) }) attackLine.Attacks = res; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res }</code> </pre><br><h3>  Points d'arrêt </h3><br>  Oui ... encore une fois, désolé!  Nous appellerons donc la situation dans le jeu, lorsqu'un mauvais coup décide du résultat du jeu. <br><br>  Par exemple, une attaque [3: 2] est un point d'arrêt.  Si l'adversaire ne le bloque pas en plaçant une pièce à côté de lui, alors au prochain coup, nous avons déjà une attaque [4: 2] sur le terrain de jeu - eh bien, le résultat du jeu est décidé, quoi qu'on puisse dire (dans la grande majorité des cas). <br><br>  Ou une attaque [4: 1].  Un bâillement - et le jeu peut être facilement terminé. <br><br><img src="https://habrastorage.org/webt/bd/vc/d0/bdvcd0jzf2wiiqqm9wupccpgmn4.jpeg"><br>  <i>Figure 5. Point d'arrêt</i> <br><br>  Tout est clair et compréhensible, et l'algorithme décrit ci-dessus est déjà capable de prendre en compte les points d'arrêt et de les bloquer en temps opportun.  Le bot attend avec impatience.  Il verra qu'au prochain tour, l'adversaire est capable de créer une attaque [5: 1], par exemple, dont le poids est de 200 - ce qui signifie que le ringard rusé ira ici. <br><br>  Cependant, imaginez une situation où l'un des joueurs parvient à obtenir 2 points d'arrêt sur le terrain.  Et cela, évidemment, ne laisse aucune chance à l'adversaire, car  d'un seul coup, nous ne pouvons bloquer qu'un seul point d'arrêt.  Comment apprendre à notre IA à bloquer de telles attaques? <br><br><img src="https://habrastorage.org/webt/bh/qu/79/bhqu79lupldi6d3pshuan0lxcmg.jpeg"><br>  <i>Figure 6. 2 points d'arrêt</i> <br><br>  Tout est simple, lors de l'analyse d'une cellule, en y substituant une pièce, nous compterons le nombre de points d'arrêt que nous obtiendrons au prochain coup (le bot regarde le pas en avant, n'oubliez pas).  En comptant 2 points d'arrêt, nous augmentons le poids des cellules de 100. <br><br>  Et maintenant, le bot empêchera non seulement de telles situations de jeu, mais pourra également les créer, ce qui en fait maintenant un adversaire plus redoutable. <br><br><h3>  Comment comprendre qu'une attaque est un point d'arrêt </h3><br>  Commençons par l'évidence: toute attaque d'une puissance de 4 est un point d'arrêt.  Un seul coup manqué nous donne la possibilité de terminer le jeu, c'est-à-dire  mettre 5 morceaux d'affilée. <br><br>  De plus, si le potentiel d'attaque est de 2, alors nous dépenserons 1 tour de plus pour bloquer une telle attaque, ce qui signifie qu'il y a un point d'arrêt d'une puissance de 3. Mais il n'y a qu'un seul point d'arrêt - c'est une attaque [3: 2]. <br><br>  Et encore plus difficile - <b>"attaques déchirées"</b> . <br>  Nous ne considérerons que les attaques avec une cellule vide au milieu - pas plus.  En effet, pour terminer l'attaque avec deux cellules vides au milieu, vous devez dépenser au moins 2 mouvements - ce n'est clairement pas un point d'arrêt. <br><br>  Comme nous nous en souvenons, nous considérons les attaques déchirées comme plusieurs attaques classiques: une attaque centrale et des attaques latérales.  L'attaque centrale appartient à la cellule scannée, le diviseur latéral en a plus de 1 - cela a été décrit ci-dessus. <br><br>  Algorithme pour trouver un point d'arrêt (plus facile, lire ci-dessous): <br><br><ol><li>  Nous introduisons le <b>score</b> variable </li><li>  On prend l'attaque centrale, on considère le pouvoir </li><li>  Nous prenons l'un des côtés si son diviseur n'est pas plus de 2x. </li><li>  <b>Score</b> - la somme de la puissance des attaques centrales et latérales </li><li>  Si les potentiels des attaques centrales et latérales sont de 2, alors pour bloquer une telle attaque, vous devez passer un tour de plus.  Par conséquent, le score est augmenté de 1 </li><li>  Si <b>score</b> &gt; = 4, alors c'est un point d'arrêt <br>  En fait, les points d'arrêt pouvaient simplement être énumérés, il n'y en a pas beaucoup, mais je n'ai pas tout de suite compris cela. </li></ol><br><pre> <code class="javascript hljs">isBreakPoint( attackLine ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attackLine || ! attackLine.length ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> centAtk; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">1</span></span> ) centAtk = a; }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( centAtk.potential == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; centAtk.capability &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; attackLine.forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> score = centAtk.capability; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.divider == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ <span class="hljs-comment"><span class="hljs-comment">//side attack if( centAtk.potential == 2 &amp;&amp; a.potential == 2 ) score++; if( score + a.capability &gt;= 4 ){ res = true; return; } } }) return res; }</span></span></code> </pre><br><h3>  Oui, nous allons enfin tout rassembler </h3><br>  Ainsi, l'enfer principal derrière est décrit ci-dessus.  Il est temps de façonner quelque chose qui fonctionne à partir de cela.  Fonction <b>countWeight (x, y)</b> - prend les coordonnées de la cellule en entrée et renvoie son poids.  Qu'y a-t-il sous sa capuche? <br><br>  Tout d'abord, nous obtenons un tableau de toutes les attaques auxquelles appartient la cellule.  ( <b>getAllAttacks (x, y)</b> ).  En parcourant toutes les lignes, nous comptons le nombre de points d'arrêt.  S'il y a 2 points d'arrêt, nous rappelons qu'une telle situation peut décider du résultat du jeu et augmenter le poids des cellules de 100. <br>  Cependant, tous les points d'arrêt doivent appartenir à un seul joueur, j'ai donc dû implémenter une vérification en 2 étapes: d'abord les croix, puis les zéros. <br><br>  Étant donné que dans la gamme de poids d'attaque ( <b>ATTACK_WEIGHTS []</b> ), je n'ai pas fourni d'attaques d'une puissance de 6 ou plus, j'ai dû les remplacer par des attaques d'une puissance de 5. Cela ne fait aucune différence - ils mènent tous à la fin du jeu. <br><br>  Eh bien, nous résumons les poids d'attaque - c'est tout. <br><br>  Autre petit point: pour que le bot ne soit pas stupide en fin de partie, quand il a déjà construit une attaque avec une puissance de 4 et pense au coup en cours, il faut augmenter significativement le poids de la cellule pour terminer une telle attaque.  Sans cela, l'IA peut tout simplement commencer à se défendre contre les attaques «dangereuses» de l'adversaire, bien que le jeu semble gagné.  Le dernier mouvement est important. <br><br><pre> <code class="javascript hljs">countWeight( x, y ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attacks = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getAttacks( x, y ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ! attacks ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.x, <span class="hljs-string"><span class="hljs-string">'×'</span></span> ); sum += count.call( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, attacks.o, <span class="hljs-string"><span class="hljs-string">'○'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> atks, curFig </span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weight = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> breakPoints = <span class="hljs-number"><span class="hljs-number">0</span></span>; [ <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"45"</span></span>, <span class="hljs-string"><span class="hljs-string">"90"</span></span>, <span class="hljs-string"><span class="hljs-string">"135"</span></span> ].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> p </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isBreakPoint( atks[p] ) ){ debug( <span class="hljs-string"><span class="hljs-string">"Break point"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ++breakPoints == <span class="hljs-number"><span class="hljs-number">2</span></span> ){ weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; debug( <span class="hljs-string"><span class="hljs-string">"Good cell"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } atks[p].forEach( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> a </span></span></span><span class="hljs-function">)=&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ) a.capability = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a.capability == <span class="hljs-number"><span class="hljs-number">5</span></span> &amp;&amp; curFig == Model.whoPlays.char ) weight += <span class="hljs-number"><span class="hljs-number">100</span></span>; weight += a.getWeight(); }); }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> weight } }</code> </pre><br>  Maintenant, lors de l'appel de cette fonction pour une cellule spécifique, nous obtiendrons son poids.  Nous effectuons cette opération pour toutes les cellules et sélectionnons la meilleure (avec le poids le plus élevé).  Là et allez) <br><br>  Vous pouvez trouver le reste du code sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> .  Il y a déjà beaucoup de matériel, et sa présentation, comme je n'ai pas essayé, laisse beaucoup à désirer.  Mais si vous pouviez lire jusqu'ici, cher lecteur, je vous en serais reconnaissant. <br><br><h3>      </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descends! </font><font style="vertical-align: inherit;">Oui, vous pouvez le battre, mais le faire est un peu problématique pour moi personnellement. </font><font style="vertical-align: inherit;">Peut-être que je ne fais pas assez attention. </font><font style="vertical-align: inherit;">Essayez aussi votre force. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je sais que c'est plus facile, mais je ne sais pas comment. </font><font style="vertical-align: inherit;">Je voudrais écouter les gens qui connaissent ou regardent d'autres implémentations d'un tel bot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je sais ce qui peut être mieux. </font><font style="vertical-align: inherit;">Oui ... vous pouvez utiliser des algorithmes bien connus, tels que minimax, mais pour cela, vous devez avoir une base de connaissances dans le domaine de la théorie des jeux, dont je ne peux malheureusement pas me vanter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À l'avenir, je prévois d'ajouter une analyse des points d'arrêt à plusieurs étapes, ce qui fera du bot un adversaire encore plus sérieux. </font><font style="vertical-align: inherit;">Cependant, maintenant je n'ai pas une idée claire de la mise en œuvre de cela; </font><font style="vertical-align: inherit;">J'ai juste la prochaine session et un diplôme incomplet - ce qui m'attriste. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merci si vous lisez jusqu'au bout.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430708/">https://habr.com/ru/post/fr430708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430694/index.html">Un petit guide pour apprendre le C ++: quoi, quand et sur quoi créer</a></li>
<li><a href="../fr430700/index.html">Un système unifié d'enregistrement des vues de films en ligne commencera à fonctionner en Russie</a></li>
<li><a href="../fr430702/index.html">Formation très étrange</a></li>
<li><a href="../fr430704/index.html">Comment les technologies de l'intelligence artificielle aident les ventes d'avias à se développer: sept exemples</a></li>
<li><a href="../fr430706/index.html">Nouvelle théorie de l'évolution</a></li>
<li><a href="../fr430710/index.html">Que faire si le Black Friday est demain et que vos serveurs ne sont pas prêts</a></li>
<li><a href="../fr430712/index.html">NeurIPS: Comment conquérir la meilleure conférence ML</a></li>
<li><a href="../fr430714/index.html">VMware achète Heptio - qu'est-ce que cela signifie pour Kubernetes</a></li>
<li><a href="../fr430718/index.html">Pour quels objets vaut-il la peine d'utiliser la vidéosurveillance dans le cloud?</a></li>
<li><a href="../fr430720/index.html">Intel RealSense D435i: petite mise à jour et courte digression historique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>