<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçõ üßöüèæ üçá ReactiveX Redux üôèüèª „äóÔ∏è üë∂üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todos los que trabajan con Redux tarde o temprano se encontrar√°n con el problema de las acciones asincr√≥nicas. Pero una aplicaci√≥n moderna no se puede...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ReactiveX Redux</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alfa/blog/460155/">  Todos los que trabajan con Redux tarde o temprano se encontrar√°n con el problema de las acciones asincr√≥nicas.  Pero una aplicaci√≥n moderna no se puede desarrollar sin ellos.  Estas son solicitudes http para el backend y todo tipo de temporizadores / retrasos.  Los propios creadores de Redux hablan sin ambig√ºedades: de forma predeterminada, solo se admite el flujo de datos sincr√≥nico, todas las acciones asincr√≥nicas deben colocarse en el middleware. <br><br>  Por supuesto, esto es demasiado detallado e inconveniente, por lo que es dif√≠cil encontrar un desarrollador que use solo el middleware "nativo".  Las bibliotecas y marcos como Thunk, Saga y similares siempre vienen al rescate. <br><br>  Para la mayor√≠a de las tareas, son suficientes.  Pero, ¬øqu√© pasa si se necesita una l√≥gica un poco m√°s compleja que enviar una solicitud o hacer un temporizador?  Aqu√≠ hay un peque√±o ejemplo: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> dispatch =&gt; { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> .all([fetchOne, fetchTwo]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[respOne, respTwo]</span></span></span><span class="hljs-function">) =&gt;</span></span> { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SUCCESS'</span></span>, respOne, respTwo }); }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FAILED'</span></span>, error }); } }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }</code> </pre> <br>  Es doloroso incluso mirar ese c√≥digo, pero es simplemente imposible de mantener y expandir.  ¬øQu√© hacer cuando se necesita un manejo de errores m√°s sofisticado?  ¬øQu√© pasa si necesita una solicitud repetida?  ¬øY si quiero reutilizar esta funci√≥n? <br><br>  Mi nombre es Dmitry Samokhvalov, y en esta publicaci√≥n les dir√© cu√°l es el concepto de Observable y c√≥mo ponerlo en pr√°ctica junto con Redux, y tambi√©n comparar√© todo esto con las capacidades de Redux-Saga. <br><a name="habracut"></a><br>  Como regla, en tales casos, tome redux-saga.  OK, reescribimos las sagas: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(delay, <span class="hljs-number"><span class="hljs-number">2000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [respOne, respTwo] = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> [ call(fetchOne), call(fetchTwo) ]; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SUCCESS'</span></span>, respOne, respTwo }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FAILED'</span></span>, error }); }</code> </pre><br>  Se ha vuelto notablemente mejor: el c√≥digo es casi lineal, se ve y se lee mejor.  Pero expandirse y reutilizarse sigue siendo dif√≠cil, porque la saga es tan imprescindible como el thunk. <br><br>  Hay otro enfoque.  Este es exactamente el enfoque, y no solo otra biblioteca para escribir c√≥digo asincr√≥nico.  Se llama Rx (tambi√©n son observables, corrientes reactivas, etc.).  Lo usaremos y reescribiremos el ejemplo en Observable: <br><br><pre> <code class="javascript hljs">action$ .delay(<span class="hljs-number"><span class="hljs-number">2000</span></span>) .switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable.merge(fetchOne, fetchTwo) .map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[respOne, respTwo]</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SUCCESS'</span></span>, respOne, respTwo })) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FAILED'</span></span>, error }))</code> </pre> <br>  El c√≥digo no solo se volvi√≥ plano y disminuy√≥ en volumen, sino que el principio mismo de describir acciones asincr√≥nicas ha cambiado.  Ahora no trabajamos directamente con consultas, sino que realizamos operaciones en objetos especiales llamados Observable. <br><br>  Es conveniente representar Observable como una funci√≥n que proporciona una secuencia (secuencia) de valores.  Observable tiene tres estados principales: siguiente ("dar el siguiente valor"), error ("se produjo un error") y completo ("los valores han terminado, no hay nada m√°s que dar").  En este sentido, es un poco como Promise, pero difiere en que es posible iterar sobre estos valores (y esta es una de las superpotencias observables).  Puede envolver cualquier cosa en Observable: tiempos de espera, solicitudes http, eventos DOM, solo objetos js. <br><br><img src="https://habrastorage.org/webt/be/qu/yr/bequyrg-gjvichysgtzom-c0mju.png" width="540"><br><br>  La segunda superpotencia observable son los operadores.  Un operador es una funci√≥n que acepta y devuelve un Observable, pero realiza alguna acci√≥n en la secuencia de valores.  La analog√≠a m√°s cercana es el mapa y el filtro de JavaScript (por cierto, dichos operadores est√°n en Rx). <br><br><img src="https://habrastorage.org/webt/bu/hi/mc/buhimcdgpjmngscttymdt1rzsqk.png" width="540"><br><br>  Los m√°s √∫tiles para m√≠ personalmente fueron los operadores zip, forkJoin y flatMap.  Usando su ejemplo, es m√°s f√°cil explicar el trabajo de los operadores. <br><br>  El operador zip funciona de manera muy simple: toma unos pocos Observables (no m√°s de 9) y devuelve en una matriz los valores que emiten. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = fromEvent(<span class="hljs-string"><span class="hljs-string">"mousedown"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = fromEvent(<span class="hljs-string"><span class="hljs-string">"mouseup"</span></span>); zip(first, second) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${e[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0</span></span></span></span><span class="hljs-string"><span class="hljs-subst">].x}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${e[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">].x}</span></span></span><span class="hljs-string">`</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//output [119,120] [120,233] ‚Ä¶</span></span></code> </pre><br>  En general, el trabajo de zip puede ser representado por el esquema: <br><br><img src="https://habrastorage.org/webt/zu/4j/in/zu4jinxmtwpt4vs3azoy81a6xpc.png" width="540"><br><br>  Zip se usa si tiene varios Observables y necesita recibir constantemente valores de ellos (a pesar de que pueden emitirse a diferentes intervalos, sincr√≥nicamente o no).  Es muy √∫til cuando se trabaja con eventos DOM. <br><br>  La instrucci√≥n forkJoin es similar a zip con una excepci√≥n: solo devuelve los √∫ltimos valores de cada Observable. <br><br><img src="https://habrastorage.org/webt/3p/mb/s6/3pmbs6uzqz4w9c3fklfhslw6j6k.png" width="540"><br><br>  En consecuencia, es razonable usarlo cuando solo se necesitan valores finitos de la secuencia. <br>  Un poco m√°s complicado es el operador flatMap.  Toma un Observable como entrada y devuelve un nuevo Observable, y asigna sus valores al nuevo Observable, utilizando una funci√≥n de selector u otro Observable.  Suena confuso, pero el diagrama es bastante simple: <br><br><img src="https://habrastorage.org/webt/kz/7t/fn/kz7tfnjuhklblx5czaxhbs06_mi.png" width="540"><br><br>  A√∫n m√°s claro en el c√≥digo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${value}</span></span></span><span class="hljs-string"> World`</span></span>); observable .flatMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> promise(value)) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result)); <span class="hljs-comment"><span class="hljs-comment">//output "Hello World"</span></span></code> </pre> <br>  Muy a menudo, flatMap se usa en solicitudes de back-end, junto con switchMap y concatMap. <br>  ¬øC√≥mo puedo usar Rx en Redux?  Hay una maravillosa biblioteca redux-observable para esto.  Su arquitectura se ve as√≠: <br><br><img src="https://habrastorage.org/webt/9p/y1/kv/9py1kvsgrpqjaovs3zrukrghbwc.png" width="540"><br><br>  Todos los operadores y acciones observables en ellos se realizan en forma de middleware especial llamado √©pico.  Cada epopeya toma acci√≥n como entrada, la envuelve en un Observable y debe devolver la acci√≥n, tambi√©n como un Observable.  No puede devolver una acci√≥n normal, esto crea un bucle sin fin.  Escribamos una peque√±a epopeya que hace una solicitud a la API. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fetchEpic = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action$</span></span></span><span class="hljs-function"> =&gt;</span></span> action$ .ofType(<span class="hljs-string"><span class="hljs-string">'FETCH_INFO'</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FETCH_START'</span></span> })) .flatMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable .from(apiRequest) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FETCH_SUCCESS'</span></span>, data })) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'FETCH_ERROR'</span></span>, error })) )</code> </pre><br>  Es imposible hacerlo sin comparar redux-observable y redux-saga.  A muchos les parece que tienen una funcionalidad y capacidades cercanas, pero este no es el caso en absoluto.  Las sagas son una herramienta completamente imprescindible, esencialmente un conjunto de m√©todos para trabajar con efectos secundarios.  Observable es un estilo fundamentalmente diferente de escribir c√≥digo asincr√≥nico, si lo desea, una filosof√≠a diferente. <br><br>  Escrib√≠ varios ejemplos para ilustrar las posibilidades y el enfoque para resolver problemas. <br><br>  Supongamos que necesitamos implementar un temporizador que se detendr√° por acci√≥n.  As√≠ es como se ve en las sagas: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> race({ <span class="hljs-attr"><span class="hljs-attr">stopped</span></span>: take(<span class="hljs-string"><span class="hljs-string">'STOP'</span></span>), <span class="hljs-attr"><span class="hljs-attr">tick</span></span>: call(wait, <span class="hljs-number"><span class="hljs-number">1000</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!timer.stopped) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put(actions.tick()) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } }</code> </pre> <br>  Ahora usa Rx: <br><br><pre> <code class="javascript hljs">interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .takeUntil(action$.ofType(<span class="hljs-string"><span class="hljs-string">'STOP'</span></span>))</code> </pre> <br><br>  Supongamos que hay una tarea para implementar una solicitud con cancelaci√≥n en sagas: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchSaga</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(fetchUser); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(<span class="hljs-string"><span class="hljs-string">'FETCH'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fetchSaga = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fork(fetchSaga); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(<span class="hljs-string"><span class="hljs-string">'FETCH_CANCEL'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> cancel(fetchSaga); }</code> </pre> <br>  Todo es m√°s simple en Rx: <br><br><pre> <code class="javascript hljs">switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchUser()) .takeUntil(action$.ofType(<span class="hljs-string"><span class="hljs-string">'FETCH_CANCEL'</span></span>))</code> </pre> <br>  Finalmente mi favorito.  Implemente una solicitud de API, en caso de falla, no realice m√°s de 5 solicitudes repetidas con un retraso de 2 segundos.  Esto es lo que tenemos en las sagas: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> apiResponse = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(apiRequest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apiResponse; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> delay(<span class="hljs-number"><span class="hljs-number">2000</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(); }</code> </pre> <br>  Lo que sucede en Rx: <br><br><pre> <code class="javascript hljs">.retryWhen(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors</span></span></span><span class="hljs-function"> =&gt;</span></span> errors .delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .take(<span class="hljs-number"><span class="hljs-number">5</span></span>))</code> </pre><br>  Si resume los pros y los contras de la saga, obtendr√° la siguiente imagen: <br><br><img src="https://habrastorage.org/webt/y6/bs/un/y6bsun3cbbwp4tayqhuuhwpudyc.png" width="540"><br><br>  Las sagas son f√°ciles de aprender y muy populares, por lo que en la comunidad puedes encontrar recetas para casi todas las ocasiones.  Desafortunadamente, el estilo imperativo impide el uso de las sagas de manera realmente flexible. <br><br>  Rx tiene una situaci√≥n completamente diferente: <br><br><img src="https://habrastorage.org/webt/mc/5a/wx/mc5awxjs7lszbo9jcq-qzrzg2qa.png" width="540"><br><br>  Puede parecer que Rx es un martillo m√°gico y una bala de plata.  Lamentablemente, esto no es as√≠.  El umbral para ingresar a Rx es mucho m√°s alto, por lo tanto, es m√°s dif√≠cil presentar a una persona nueva a un proyecto que usa Rx activamente. <br><br>  Adem√°s, cuando se trabaja con Observable, es especialmente importante tener cuidado y siempre comprender bien lo que est√° sucediendo.  De lo contrario, puede tropezar con errores no obvios o un comportamiento indefinido. <br><br><pre> <code class="javascript hljs">action$ .ofType(<span class="hljs-string"><span class="hljs-string">'DELETE'</span></span>) .switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable .fromPromise(deleteRequest) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'DELETE_SUCCESS'</span></span>})))</code> </pre> <br>  Una vez que escrib√≠ una epopeya que hizo un trabajo bastante simple, con cada acci√≥n del tipo 'BORRAR', se llam√≥ a un m√©todo API que elimin√≥ el elemento.  Sin embargo, hubo problemas durante las pruebas.  El probador se quej√≥ de un comportamiento extra√±o: a veces, cuando hace clic en el bot√≥n Eliminar, no sucede nada.  Result√≥ que el operador switchMap admite la ejecuci√≥n de un solo Observable a la vez, un tipo de protecci√≥n contra la condici√≥n de carrera. <br><br>  Como resultado, dar√© algunas recomendaciones que sigo e instar√© a todos los que comiencen a trabajar con Rx a seguir: <br><br><ul><li>  Ten cuidado </li><li>  Revisa la documentaci√≥n. </li><li>  Revisa en la caja de arena. </li><li>  Escribe pruebas. </li><li>  No dispares gorriones desde el ca√±√≥n. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460155/">https://habr.com/ru/post/460155/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460143/index.html">M√≥dulo dis de Python y convoluci√≥n de constantes</a></li>
<li><a href="../460147/index.html">Marco de microservicios PHP - Publicaci√≥n de Swoft 2.0.3</a></li>
<li><a href="../460149/index.html">Escritura adecuada: el aspecto subestimado del c√≥digo limpio</a></li>
<li><a href="../460151/index.html">Dise√±o orientado a modelos. Motor DC sin escobillas</a></li>
<li><a href="../460153/index.html">Las aventuras de las firmas electr√≥nicas en Rusia</a></li>
<li><a href="../460157/index.html">C√≥mo las respuestas "correctas" de los encuestados pueden distorsionar los resultados de la encuesta m√°s all√° del reconocimiento</a></li>
<li><a href="../460159/index.html">M√©todo para monitorear el estado actual de las carreteras rusas por los tel√©fonos inteligentes de los usuarios</a></li>
<li><a href="../460161/index.html">FusionPBX y ACL</a></li>
<li><a href="../460163/index.html">Como parec√≠a</a></li>
<li><a href="../460165/index.html">Antecedentes: criptograf√≠a de dedo cu√°ntico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>