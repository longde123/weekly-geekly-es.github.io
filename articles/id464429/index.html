<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛑️ 🧝 👍🏼 10 kesalahan paling umum saat bekerja dengan platform Spring. Bagian 1 🏴󠁧󠁢󠁷󠁬󠁳󠁿 👺 👃🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya. Hari ini kami membagikan bagian pertama artikel, yang terjemahannya disiapkan khusus untuk siswa dari kursus "Pengembang Kerangka Kerja...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 kesalahan paling umum saat bekerja dengan platform Spring. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/464429/">  <i>Halo semuanya.</i>  <i>Hari ini kami membagikan bagian pertama artikel, yang terjemahannya disiapkan khusus untuk siswa dari kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pengembang Kerangka Kerja Musim Semi"</a> .</i>  <i>Ayo mulai!</i> <br><br><img src="https://habrastorage.org/webt/sp/gg/np/spggnpu1e19b9c_yb66nbynmbqq.png"><br><br><hr><br>  Spring mungkin merupakan salah satu platform pengembangan Java yang paling populer.  Ini adalah alat yang kuat, tetapi agak sulit dipelajari.  Konsep dasarnya cukup mudah dipahami dan dipelajari, tetapi perlu waktu dan upaya untuk menjadi pengembang Spring yang berpengalaman. <br><br>  Pada artikel ini, kita akan melihat beberapa kesalahan paling umum yang dibuat ketika bekerja di Spring dan terkait, khususnya, untuk pengembangan aplikasi web dan penggunaan platform Spring Boot.  Sebagaimana dicatat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web Spring Boot</a> , Spring Boot mengambil pendekatan <i>standar</i> untuk membuat aplikasi yang siap digunakan, dan artikel ini akan mengikuti pendekatan ini.  Ini akan memberikan sejumlah rekomendasi yang dapat digunakan secara efektif dalam pengembangan aplikasi web standar berdasarkan Spring Boot. <a name="habracut"></a><br><br>  Jika Anda tidak terlalu mengenal platform Boot Spring, tetapi ingin bereksperimen dengan contoh-contoh dalam artikel ini, saya membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori GitHub dengan bahan tambahan untuk artikel ini</a> .  Jika pada titik tertentu Anda sedikit bingung saat membaca artikel ini, saya akan menyarankan Anda untuk membuat klon dari repositori ini dan bereksperimen dengan kode di komputer Anda. <br><br><h2>  Kesalahan Umum # 1: Pemrograman yang Terlalu Rendah </h2><br>  Kami mudah menyerah pada kesalahan yang tersebar luas ini, karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"sindrom penolakan pengembangan orang lain"</a> cukup khas untuk lingkungan pemrograman.  Salah satu gejalanya adalah penulisan ulang konstan potongan kode yang umum digunakan, dan ini adalah gejala yang dilihat oleh banyak programmer. <br>  Mempelajari struktur internal dan fitur implementasi dari perpustakaan tertentu sering kali merupakan proses yang berguna, perlu dan menarik, tetapi jika Anda terus-menerus menulis jenis kode yang sama saat melakukan implementasi fungsi tingkat rendah, ini mungkin berbahaya bagi Anda sebagai pengembang perangkat lunak.  Itulah mengapa abstraksi dan platform seperti Spring ada dan digunakan - mereka menyelamatkan Anda dari pekerjaan manual berulang dan memungkinkan Anda untuk berkonsentrasi pada objek area subjek Anda dan logika kode program pada level yang lebih tinggi. <br><br>  Karena itu, abstraksi tidak boleh dihindari.  Lain kali Anda dihadapkan dengan kebutuhan untuk menyelesaikan masalah tertentu, pertama-tama lakukan pencarian cepat dan cari tahu apakah perpustakaan yang memecahkan masalah ini sudah ada di Spring - Anda kemungkinan akan menemukan solusi turnkey yang cocok.  Salah satu perpustakaan yang bermanfaat adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Project Lombok</a> , anotasi yang akan saya gunakan dalam contoh-contoh dalam artikel ini.  Lombok digunakan sebagai generator kode templat, sehingga pengembang malas yang tinggal di masing-masing dari kita akan sangat senang berkenalan dengan perpustakaan ini.  Lihat, misalnya, bagaimana tampilan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen JavaBean standar</a> di Lombok: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-meta"><span class="hljs-meta">@Setter</span></span> <span class="hljs-meta"><span class="hljs-meta">@NoArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bean</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstBeanProperty; String secondBeanProperty; }</code> </pre> <br>  Seperti yang mungkin sudah Anda pahami, kode di atas dikonversi ke bentuk berikut: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bean</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstBeanProperty; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String secondBeanProperty; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirstBeanProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstBeanProperty; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSecondBeanProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondBeanProperty; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setFirstBeanProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstBeanProperty)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstBeanProperty = firstBeanProperty; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSecondBeanProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String secondBeanProperty)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondBeanProperty = secondBeanProperty; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre> <br>  Perhatikan bahwa Anda kemungkinan besar harus menginstal plug-in yang sesuai jika Anda ingin menggunakan Lombok di lingkungan pengembangan terintegrasi Anda.  Versi plug-in ini untuk IntelliJ IDEA dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  Kesalahan umum nomor 2. "Kebocoran" dari struktur internal </h2><br>  Memberikan akses ke struktur internal tidak pernah merupakan ide yang baik, karena hal itu merusak fleksibilitas model layanan dan, sebagai hasilnya, berkontribusi pada pembentukan gaya pemrograman yang buruk.  "Kebocoran" struktur internal dimanifestasikan dalam kenyataan bahwa struktur database menjadi dapat diakses dari titik akhir API tertentu.  Misalnya, anggap "objek Jawa tua yang baik" (POJO) berikut ini mewakili tabel di database Anda: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@NoArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TopTalentEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } }</code> </pre> <br>  Asumsikan bahwa ada titik akhir yang perlu mengakses data objek <code>TopTalentEntity</code> .  Untuk mengembalikan instance <code>TopTalentEntity</code> sepertinya ide yang menggoda, tetapi solusi yang lebih fleksibel adalah membuat kelas baru yang mewakili data TopTalentEntity untuk titik akhir API: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@NoArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; }</code> </pre> <br>  Dengan demikian, membuat perubahan pada komponen internal dari basis data tidak akan memerlukan perubahan tambahan pada tingkat layanan.  Mari kita lihat apa yang terjadi jika bidang kata sandi ditambahkan ke kelas <code>TopTalentEntity</code> untuk menyimpan hash kata sandi pengguna dalam database: jika tidak ada konektor, seperti <code>TopTalentData</code> , dan pengembang lupa untuk mengubah bagian antarmuka layanan, ini dapat menyebabkan pengungkapan informasi rahasia yang sangat tidak diinginkan! <br><br><h2>  Nomor kesalahan umum 3. Menggabungkan fungsi yang akan lebih baik untuk didistribusikan dalam kode </h2><br>  Mengelola kode aplikasi seiring pertumbuhannya menjadi tugas yang semakin penting.  Anehnya, sebagian besar prinsip pemrograman efektif berhenti bekerja ketika skala pengembangan tertentu tercapai, terutama jika arsitektur aplikasi belum dipikirkan dengan baik.  Dan salah satu kesalahan yang paling sering dibuat adalah kombinasi fungsi dalam kode yang lebih masuk akal untuk diterapkan secara terpisah. <br><br>  Alasan pelanggaran prinsip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemisahan tanggung jawab</a> biasanya adalah penambahan fungsi baru ke kelas yang ada.  Mungkin ini adalah solusi sesaat yang baik (khususnya, membutuhkan penulisan kode dalam jumlah yang lebih kecil), tetapi di masa depan itu pasti akan menjadi masalah, termasuk pada tahap pengujian dan pemeliharaan kode dan di antara mereka.  Pertimbangkan pengontrol berikut yang mengembalikan <code>TopTalentData</code> dari repositori: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TopTalentRepository topTalentRepository; <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/toptal/get"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;TopTalentData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTopTalent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> topTalentRepository.findAll() .stream() .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::entityToData) .collect(Collectors.toList()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TopTalentData </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entityToData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TopTalentEntity topTalentEntity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TopTalentData(topTalentEntity.getName()); } }</code> </pre> <br>  Pada pandangan pertama, tampaknya tidak ada kesalahan yang jelas dalam fragmen kode ini.  Ini memberikan daftar objek <code>TopTalentData</code> , yang diambil dari instance kelas <code>TopTalentEntity</code> .  Tetapi jika Anda melihat kode lebih dekat, kita akan melihat bahwa dalam kenyataannya <code>TopTalentController</code> melakukan beberapa tindakan di sini, yaitu, itu menghubungkan permintaan dengan titik akhir tertentu, mengambil data dari repositori dan mengubah objek yang diterima dari <code>TopTalentRepository</code> ke dalam format yang berbeda.  Solusi yang lebih bersih harus memisahkan fungsi-fungsi ini ke dalam kelas yang terpisah.  Misalnya, mungkin terlihat seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/toptal"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TopTalentService topTalentService; <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/get"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;TopTalentData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTopTalent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> topTalentService.getTopTalent(); } } <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TopTalentRepository topTalentRepository; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TopTalentEntityConverter topTalentEntityConverter; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;TopTalentData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTopTalent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> topTalentRepository.findAll() .stream() .map(topTalentEntityConverter::toResponse) .collect(Collectors.toList()); } } <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopTalentEntityConverter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TopTalentData </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TopTalentEntity topTalentEntity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TopTalentData(topTalentEntity.getName()); } }</code> </pre> <br>  Keuntungan tambahan dari hierarki ini adalah ia memungkinkan kita untuk memahami di mana fungsi berada hanya dengan melihat nama kelas.  Selanjutnya, selama pengujian, kita dapat dengan mudah mengganti kode dari kelas-kelas ini dengan kode pengganti, jika perlu. <br><br><h2>  Nomor kesalahan umum 4. Kode seragam dan penanganan kesalahan buruk </h2><br>  Topik keseragaman kode tidak unik untuk Spring (atau untuk Java pada umumnya), tetapi, bagaimanapun, merupakan aspek penting yang harus dipertimbangkan ketika bekerja dengan proyek-proyek di Spring.  Memilih gaya pemrograman tertentu dapat menjadi topik diskusi (dan biasanya konsisten di dalam tim pengembangan atau di seluruh perusahaan), tetapi dalam hal apa pun, keberadaan standar umum untuk penulisan kode berkontribusi pada peningkatan efisiensi kerja.  Ini benar terutama jika beberapa orang mengerjakan kode.  Kode seragam dapat diteruskan dari pengembang ke pengembang tanpa menghabiskan banyak usaha untuk mempertahankannya atau pada penjelasan yang panjang tentang mengapa ini atau kelas-kelas itu diperlukan. <br><br>  Bayangkan ada proyek Musim Semi di mana terdapat berbagai file konfigurasi, layanan, dan pengontrol.  Mengikuti keseragaman semantik dalam penamaan mereka, kami membuat struktur tempat Anda dapat dengan mudah mencari dan di mana pengembang mana pun dapat dengan mudah memahami kode tersebut.  Misalnya, Anda bisa menambahkan akhiran Config ke nama kelas konfigurasi, akhiran Layanan ke nama layanan, dan akhiran Controller ke nama controller. <br><br>  Penanganan kesalahan sisi server terkait erat dengan keseragaman kode dan perlu mendapat perhatian khusus.  Jika Anda pernah menangani pengecualian yang berasal dari API yang ditulis dengan buruk, Anda mungkin tahu betapa sulitnya memahami dengan benar makna pengecualian ini, dan bahkan lebih sulit untuk menentukan mengapa mereka benar-benar terjadi. <br>  Sebagai pengembang API, idealnya Anda ingin membahas semua titik akhir yang digunakan pengguna dan mengarahkan mereka untuk menggunakan format pesan kesalahan tunggal.  Biasanya ini berarti bahwa Anda perlu menggunakan kode kesalahan standar dan deskripsinya dan mengabaikan keputusan yang meragukan seperti memberikan pengguna pesan "500 Internal Server Error" atau hasil dari jejak tumpukan (opsi terakhir, omong-omong, harus dihindari dengan segala cara, karena Anda mengungkapkan data internal, dan selain itu, hasil seperti itu sulit untuk diproses di sisi klien). <br>  Di sini, misalnya, seperti apa bentuk umum dari pesan kesalahan: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrorResponse</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer errorCode; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String errorMessage; }</code> </pre> <br>  Format yang mirip dengan ini sering ditemukan di API paling populer dan, biasanya, berfungsi dengan baik karena dapat dengan mudah dan sistematis didokumentasikan.  Anda bisa mengonversi pengecualian ke format ini dengan menambahkan anotasi <code>@ExceptionHandler</code> ke metode (untuk contoh anotasi, lihat bagian "Kesalahan Umum # 6"). <br><br><h2>  Nomor kesalahan umum 5. Pekerjaan salah dengan multithreading </h2><br>  Mengimplementasikan multithreading bisa menjadi tugas yang sulit, terlepas dari apakah itu digunakan dalam aplikasi desktop atau dalam aplikasi web, dalam proyek Musim Semi atau proyek untuk platform lain.  Masalah yang disebabkan oleh eksekusi paralel program sulit dilacak, dan mengatasinya dengan debugger seringkali sangat sulit.  Jika Anda memahami bahwa Anda berurusan dengan kesalahan eksekusi paralel, maka kemungkinan besar Anda harus meninggalkan debugger dan memeriksa kode secara manual sampai akar penyebab kesalahan ditemukan.  Sayangnya, tidak ada cara standar untuk menyelesaikan masalah tersebut.  Dalam setiap kasus, perlu untuk menilai situasi dan "menyerang" masalah dengan metode yang tampaknya terbaik dalam kondisi yang diberikan. <br><br>  Idealnya, tentu saja, Anda ingin sepenuhnya menghindari kesalahan yang terkait dengan multithreading.  Dan meskipun tidak ada resep universal di sini, saya masih dapat menawarkan beberapa rekomendasi praktis. <br><br><h3>  Hindari menggunakan negara global </h3><br>  Pertama, selalu ingat masalah "negara global".  Jika Anda mengembangkan aplikasi multi-utas, Anda perlu memonitor dengan cermat semua variabel yang dapat dimodifikasi secara global, dan jika mungkin, singkirkan semuanya.  Jika Anda masih memiliki alasan mengapa variabel global harus dapat dimodifikasi, terapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sinkronisasi</a> dengan benar dan pantau kinerja aplikasi Anda - Anda harus memastikan bahwa itu tidak melambat karena penambahan masa tunggu. <br><br><h3>  Hindari benda yang bisa berubah </h3><br>  Gagasan ini datang langsung dari prinsip-prinsip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemrograman fungsional</a> dan, yang disesuaikan dengan prinsip-prinsip OOP, menyatakan bahwa kelas yang bisa berubah dan keadaan yang bisa berubah harus dihindari.  Singkatnya, ini berarti Anda harus menahan diri dari pengaturan metode (setter) dan memiliki bidang pribadi dengan pengubah akhir di semua kelas model.  Satu-satunya waktu nilainya berubah adalah ketika objek dibuat.  Dalam hal ini, Anda dapat yakin bahwa tidak ada masalah yang terkait dengan persaingan untuk sumber daya, dan ketika mengakses properti objek, nilai yang benar akan selalu diperoleh. <br><br><h3>  Catat data penting </h3><br>  Mengevaluasi di mana masalah dapat terjadi dalam aplikasi, dan mengatur pencatatan semua data penting sebelumnya.  Jika terjadi kesalahan, Anda akan senang memiliki informasi tentang permintaan apa yang telah diterima, dan Anda akan dapat lebih memahami alasan kegagalan fungsi aplikasi Anda.  Namun, perlu diingat bahwa logging melibatkan file I / O tambahan dan tidak boleh disalahgunakan, karena ini dapat mempengaruhi kinerja aplikasi. <br><br><h3>  Gunakan implementasi utas yang sudah jadi </h3><br>  Saat Anda perlu menelurkan utas Anda (misalnya, untuk membuat permintaan asinkron ke berbagai layanan), gunakan implementasi utas aman yang sudah jadi alih-alih membuat sendiri.  Dalam kebanyakan kasus, Anda dapat menggunakan abstraksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ExecutorService</a> dan abstraksi fungsional spektakuler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CompletableFuture</a> untuk Java 8. Untuk membuat utas, platform Spring juga memungkinkan Anda untuk menangani permintaan asinkron menggunakan kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DeferredResult</a> . <br><br>  Akhir dari bagian pertama. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca bagian kedua.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464429/">https://habr.com/ru/post/id464429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464413/index.html">PVS-Studio - mesin kemajuan</a></li>
<li><a href="../id464415/index.html">Layanan petunjuk baru untuk mencari hh.ru</a></li>
<li><a href="../id464417/index.html">10 kerangka kerja PHP Populer pada tahun 2019</a></li>
<li><a href="../id464421/index.html">Radio Viber - semua stasiun radio di messenger online</a></li>
<li><a href="../id464423/index.html">Bagaimana cara mengatur waktu? Tanggapan Freelancer</a></li>
<li><a href="../id464433/index.html">Platform Pengujian Cloud Mobile</a></li>
<li><a href="../id464435/index.html">Bagaimana tidak tenggelam dalam lautan teknologi dan pendekatan: pengalaman 50 ahli</a></li>
<li><a href="../id464437/index.html">Bagaimana tim pengembangan dapat menghasilkan lebih banyak dengan membuat situs lalu lintas [Panduan Penerapan]</a></li>
<li><a href="../id464443/index.html">Natas Web. Passage dari platform KKP bertujuan untuk mengeksploitasi kerentanan Web. Bagian 2</a></li>
<li><a href="../id464445/index.html">Mengapa benar-benar mustahil menjadi vegetarian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>