<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💰 🧖🏿 💅🏼 PVS-Studio Mengunjungi Apache Hive 🧖🏼 🈸 🗒️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selama sepuluh tahun terakhir, gerakan open-source telah menjadi salah satu pendorong utama pengembangan industri TI, dan komponen krusialnya. Peran p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio Mengunjungi Apache Hive</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/463753/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/2d0/eb3/0ad2d0eb30d726eefba9c913edaa346a.png" alt="Gambar 1"></div><br>  Selama sepuluh tahun terakhir, gerakan open-source telah menjadi salah satu pendorong utama pengembangan industri TI, dan komponen krusialnya.  Peran proyek-proyek sumber terbuka menjadi semakin menonjol tidak hanya dalam hal kuantitas tetapi juga dalam hal kualitas, yang mengubah konsep bagaimana mereka diposisikan di pasar TI pada umumnya.  Tim PVS-Studio kami yang berani tidak duduk diam dan mengambil peran aktif dalam memperkuat keberadaan perangkat lunak sumber terbuka dengan menemukan bug tersembunyi di kedalaman basis kode yang sangat besar dan menawarkan opsi lisensi gratis kepada penulis proyek semacam itu.  Artikel ini hanyalah bagian lain dari aktivitas itu!  Hari ini kita akan berbicara tentang Apache Hive.  Saya sudah mendapat laporannya - dan ada beberapa hal yang layak untuk dilihat. <br><a name="habracut"></a><br><h2>  Tentang PVS-Studio </h2><br>  Penganalisa kode statis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio</a> , yang telah ada selama lebih dari 10 tahun sekarang, adalah solusi perangkat lunak multi-fungsional dan mudah diintegrasikan.  Saat ini, ia mendukung C, C ++, C #, dan Java dan berjalan pada Windows, Linux, dan macOS. <br><br>  PVS-Studio adalah solusi B2B berbayar yang digunakan oleh banyak tim di sejumlah perusahaan.  Jika Anda ingin mencoba penganalisa, kunjungi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman</a> ini untuk mengunduh distribusi dan meminta kunci percobaan. <br><br>  Jika Anda seorang geek sumber terbuka atau, misalnya, seorang siswa, Anda dapat memanfaatkan salah satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opsi</a> lisensi gratis kami. <br><br><h2>  Tentang Apache Hive </h2><br>  Jumlah data telah tumbuh pada tingkat yang sangat besar selama beberapa tahun terakhir.  Basis data standar tidak dapat lagi menghadapi pertumbuhan yang cepat ini, yang merupakan asal istilah Big Data berasal bersama dengan gagasan terkait lainnya (seperti pemrosesan, penyimpanan, dan operasi lainnya pada data besar). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Hadoop</a> saat ini dianggap sebagai salah satu teknologi Big Data perintis.  Tugas utamanya adalah menyimpan, memproses, dan mengelola sejumlah besar data.  Komponen utama yang terdiri dari kerangka kerja adalah Hadoop Common, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HDFS</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hadoop MapReduce</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hadoop YARN</a> .  Seiring waktu, ekosistem besar proyek dan teknologi terkait telah berkembang di sekitar Hadoop, banyak di antaranya awalnya dimulai sebagai bagian dari proyek dan kemudian beranjak untuk menjadi mandiri.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Hive</a> adalah salah satunya. <br><br>  Apache Hive adalah gudang data terdistribusi.  Ini mengelola data yang disimpan dalam HDFS dan menyediakan bahasa query berdasarkan SQL (HiveQL) untuk menangani data itu.  Detail lebih lanjut tentang proyek ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  Menjalankan analisis </h2><br>  Tidak butuh banyak usaha atau waktu untuk memulai analisis.  Inilah algoritma saya: <br><br><ul><li>  Unduh Apache Hive dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> ; </li><li>  Baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan</a> tentang memulai analisis Java dan meluncurkan analisis; </li><li>  Dapatkan laporan penganalisa, mempelajarinya, dan menulis kasus yang paling menarik. </li></ul><br>  Hasil analisis adalah sebagai berikut: 1456 peringatan tingkat Tinggi dan Sedang (masing-masing 602 dan 854) pada 6500+ file. <br><br>  Tidak semua peringatan merujuk pada bug asli.  Itu cukup normal;  Anda harus mengubah pengaturan penganalisa sebelum mulai menggunakannya secara teratur.  Setelah itu, Anda biasanya mengharapkan tingkat positif palsu yang cukup rendah ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> ). <br><br>  Saya mengabaikan 407 peringatan (177 Tinggi dan 230 Tingkat Menengah) yang dipicu oleh file uji.  Saya juga mengabaikan diagnostik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6022</a> (karena Anda tidak dapat dengan andal membedakan fragmen yang salah dan benar ketika Anda tidak terbiasa dengan kode), yang dipicu sebanyak 482 kali.  Saya juga tidak memeriksa 179 peringatan yang dihasilkan oleh diagnostik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6021</a> . <br><br>  Pada akhirnya, saya masih memiliki cukup peringatan untuk diikuti, dan karena saya tidak mengubah pengaturan, masih ada beberapa persentase positif palsu di antara mereka.  Tidak ada gunanya memasukkan terlalu banyak peringatan dalam artikel seperti ini :).  Jadi kita hanya akan berbicara tentang apa yang menarik perhatian saya dan terlihat cukup penasaran. <br><br><h2>  Kondisi yang ditentukan sebelumnya </h2><br>  Di antara diagnostik yang diperiksa untuk analisis ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6007</a> memegang rekor untuk jumlah peringatan yang dikeluarkan.  Sedikit lebih dari 200 pesan !!!  Beberapa terlihat tidak berbahaya, yang lain mencurigakan, dan beberapa yang lain adalah bug asli!  Mari kita lihat beberapa di antaranya. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6007</a> Expression 'key.startsWith ("hplsql.")' Selalu benar.  Exec.java (675) <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initOptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == null || value == null || !key.startsWith(<span class="hljs-string"><span class="hljs-string">"hplsql."</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } else if (key.compareToIgnoreCase(Conf.CONN_DEFAULT) == 0) { .... } else if (key.startsWith("hplsql.conn.init.")) { .... } else if (key.startsWith(Conf.CONN_CONVERT)) { .... } else if (key.startsWith("hplsql.conn.")) { .... } else if (key.startsWith("hplsql.")) { // &lt;= .... } }</span></span></code> </pre> <br>  Itu cukup panjang jika-jika-jika membangun!  Penganalisis tidak menyukai kondisi di <i>if</i> terakhir <i>(key.startsWith ("hplsql."))</i> Karena jika eksekusi mencapainya, itu berarti itu benar.  Memang, jika Anda melihat baris pertama dari seluruh konstruksi if-else-if ini, Anda akan melihat bahwa itu sudah berisi cek yang berlawanan, jadi jika string tidak dimulai dengan <i>"hplsql."</i>  , eksekusi akan segera dilewati ke iterasi berikutnya. <br><br>  Ekspresi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6007</a> ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">columnNameProperty.length</a> () == 0' selalu salah.  OrcRecordUpdater.java (238) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDescription </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTypeDescriptionFromTableProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tableProperties != null) { final String columnNameProperty = ....; final String columnTypeProperty = ....; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !Strings.isNullOrEmpty(columnNameProperty) &amp;&amp; !Strings.isNullOrEmpty(columnTypeProperty)) { List&lt;String&gt; columnNames = columnNameProperty.length() == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;() : ....; List&lt;TypeInfo&gt; columnTypes = columnTypeProperty.length() == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;TypeInfo&gt;() : ....; .... } } } .... }</code> </pre> <br>  Perbandingan panjang string <i>columnNameProperty</i> dengan nol akan selalu menghasilkan <i>false</i> .  Ini terjadi karena perbandingan ini mengikuti <i>cek! Strings.isNullOrEmpty (columnNameProperty)</i> .  Jadi jika eksekusi mencapai kondisi kita, itu berarti bahwa string <i>columnNameProperty</i> pasti bukan nol atau kosong. <br><br>  Hal yang sama berlaku untuk string <i>columnTypeProperty</i> satu baris nanti: <br><br><ul><li>  Ekspresi V6007 'columnTypeProperty.length () == 0' selalu salah.  OrcRecordUpdater.java (239) </li></ul><br>  Ekspresi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6007</a> 'colOrScalar1.equals ("Column")' selalu salah.  GenVectorCode.java (3469) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateDateTimeArithmeticIntervalYearMonth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] tdesc)</span></span></span><span class="hljs-function"> throws Exception </span></span>{ .... String colOrScalar1 = tdesc[<span class="hljs-number"><span class="hljs-number">4</span></span>]; .... String colOrScalar2 = tdesc[<span class="hljs-number"><span class="hljs-number">6</span></span>]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Col"</span></span>) &amp;&amp; colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... } else if (colOrScalar1.equals("Col") &amp;&amp; colOrScalar1.equals("Scalar")) { .... } else if (colOrScalar1.equals("Scalar") &amp;&amp; colOrScalar1.equals("Column")) { .... } }</span></span></code> </pre><br>  Copy-paste tua yang bagus.  Dari sudut pandang logika saat ini, string <i>colOrScalar1</i> mungkin memiliki dua nilai yang berbeda sekaligus, yang tidak mungkin.  Jelas, cek harus memiliki variabel <i>colOrScalar1</i> di sebelah kiri dan <i>colOrScalar2</i> di sebelah kanan. <br><br>  Peringatan serupa beberapa baris di bawah ini: <br><br><ul><li>  Ekspresi V6007 'colOrScalar1.equals ("Scalar")' selalu salah.  GenVectorCode.java (3475) </li><li>  Ekspresi V6007 'colOrScalar1.equals ("Column")' selalu salah.  GenVectorCode.java (3486) </li></ul><br>  Akibatnya, konstruksi if-else-if ini tidak akan pernah melakukan apa pun. <br><br>  Beberapa peringatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6007</a> lagi: <br><br><ul><li>  Ekspresi V6007 'karakter == null' selalu salah.  RandomTypeUtil.java (43) </li><li>  Ekspresi V6007 'writeIdHwm&gt; 0' selalu salah.  TxnHandler.java (1603) </li><li>  Ekspresi V6007 'fields.equals ("*")' selalu benar.  Server.java (983) </li><li>  Ekspresi V6007 'currentGroups! = Null' selalu benar.  GenericUDFCurrentGroups.java (90) </li><li>  Ekspresi V6007 'this.wh == null' selalu salah.  Pengembalian baru bukan-null referensi.  StorageBasedAuthorizationProvider.java (93), StorageBasedAuthorizationProvider.java (92) </li><li>  dan seterusnya ... </li></ul><br><h2>  NPE </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6008</a> Potensi null dereference dari 'dagLock'.  QueryTracker.java (557), QueryTracker.java (553) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleFragmentCompleteExternalQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QueryInfo queryInfo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryInfo.isExternalQuery()) { ReadWriteLock dagLock = getDagLock(queryInfo.getQueryIdentifier()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dagLock == null) { LOG.warn(<span class="hljs-string"><span class="hljs-string">"Ignoring fragment completion for unknown query: {}"</span></span>, queryInfo.getQueryIdentifier()); } boolean locked = dagLock.writeLock().tryLock(); ..... } }</code> </pre> <br>  Objek nol ditangkap, dicatat, dan ... program tetap berjalan.  Akibatnya, pemeriksaan diikuti oleh dereference pointer nol.  Aduh! <br><br>  Pengembang harus benar-benar menginginkan program untuk keluar dari fungsi atau melemparkan beberapa pengecualian khusus dalam kasus mendapatkan referensi nol. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6008</a> Null dereference 'buffer' dalam fungsi 'unlockSingleBuffer'.  MetadataCache.java (410), MetadataCache.java (465) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lockBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LlapBufferOrBuffers buffers, ....)</span></span></span><span class="hljs-function"> </span></span>{ LlapAllocatorBuffer buffer = buffers.getSingleLlapBuffer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer != null) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return lockOneBuffer(buffer, doNotifyPolicy); } LlapAllocatorBuffer[] bufferArray = buffers.getMultipleLlapBuffers(); for (int i = 0; i &lt; bufferArray.length; ++i) { if (lockOneBuffer(bufferArray[i], doNotifyPolicy)) continue; for (int j = 0; j &lt; i; ++j) { unlockSingleBuffer(buffer, true); // &lt;= } .... } .... } .... private void unlockSingleBuffer(LlapAllocatorBuffer buffer, ....) { boolean isLastDecref = (buffer.decRef() == 0); // &lt;= if (isLastDecref) { .... } }</span></span></code> </pre> <br>  NPE potensial lainnya.  Jika eksekusi mencapai metode <i>unlockSingleBuffer</i> , itu berarti objek <i>buffer</i> adalah nol.  Misalkan itulah yang terjadi!  Jika Anda melihat metode <i>unlockSingleBuffer</i> , Anda akan melihat bagaimana objek kami ditereferensi langsung di baris pertama.  Gotcha! <br><br><h2>  Pergeseran menjadi liar </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6034</a> Shift dengan nilai 'bitShiftsInWord - 1' bisa tidak konsisten dengan ukuran tipe: 'bitShiftsInWord - 1' = [-1 ... 30].  UnsignedInt128.java (1791) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shiftRightDestructive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wordShifts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitShiftsInWord, boolean roundUp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bitShiftsInWord == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } assert (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); assert (bitShiftsInWord &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); assert (bitShiftsInWord &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { zeroClear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } final <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shiftRestore = <span class="hljs-number"><span class="hljs-number">32</span></span> - bitShiftsInWord; <span class="hljs-comment"><span class="hljs-comment">// check this because "123 &lt;&lt; 32" will be 123. final boolean noRestore = bitShiftsInWord == 0; final int roundCarryNoRestoreMask = 1 &lt;&lt; 31; final int roundCarryMask = (1 &lt;&lt; (bitShiftsInWord - 1)); // &lt;= .... }</span></span></code> </pre> <br>  Ini adalah potensi pergeseran sebesar -1.  Jika metode ini dipanggil dengan, katakanlah, <i>wordShifts == 3</i> dan <i>bitShiftsInWord == 0</i> , baris yang dilaporkan akan berakhir dengan 1 &lt;&lt; -1.  Apakah itu perilaku yang direncanakan? <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6034</a> Shift dengan nilai 'j' bisa tidak konsisten dengan ukuran tipe: 'j' = [0 ... 63].  IoTrace.java (272) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logSargResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stripeIx, boolean[] rgsToRead)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, valOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; elements; ++i, valOffset += <span class="hljs-number"><span class="hljs-number">64</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">64</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ix = valOffset + j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rgsToRead.length == ix) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rgsToRead[ix]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; val = val | (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; j); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } .... } .... }</span></span></code> </pre> <br>  Pada baris yang dilaporkan, variabel <i>j</i> dapat memiliki nilai dalam rentang [0 ... 63].  Karena itu, perhitungan nilai <i>val</i> dalam loop dapat berjalan secara tak terduga.  Dalam ekspresi <i>(1 &lt;&lt; j)</i> , nilai 1 adalah tipe <i>int</i> , jadi menggesernya dengan 32 bit dan lebih banyak membawa kita melampaui batas kisaran tipe.  Ini dapat diperbaiki dengan menulis <i>((panjang) 1 &lt;&lt; j)</i> . <br><br><h2>  Dibawa oleh logging </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6046</a> Format salah.  Jumlah item format yang berbeda diharapkan.  Argumen tidak digunakan: 1, 2. StatsSources.java (89) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ImmutableList&lt;PersistedRuntimeStats&gt; extractStatsFromPlanMapper (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stat.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> || sig.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { StringBuffer sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuffer(); sb.append(String.format( <span class="hljs-string"><span class="hljs-string">"expected(stat-sig) 1-1, got {}-{} ;"</span></span>, <span class="hljs-comment"><span class="hljs-comment">// &lt;= stat.size(), sig.size() )); .... } .... if (e.getAll(OperatorStats.IncorrectRuntimeStatsMarker.class).size() &gt; 0) { LOG.debug( "Ignoring {}, marked with OperatorStats.IncorrectRuntimeStatsMarker", sig.get(0) ); continue; } .... }</span></span></code> </pre> <br>  Saat menulis kode untuk memformat string menggunakan <i>String.format ()</i> , pengembang menggunakan sintaks yang salah.  Akibatnya, parameter yang diteruskan tidak pernah sampai ke string yang dihasilkan.  Dugaan saya adalah bahwa pengembang telah mengerjakan penebangan sebelum menulis ini, di mana mereka meminjam sintaks. <br><br><h2>  Pengecualian yang dicuri </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6051</a> Penggunaan pernyataan 'kembali' di blok 'akhirnya' dapat menyebabkan hilangnya pengecualian yang tidak ditangani.  ObjectStore.java (9080) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;MPartitionColumnStatistics&gt; getMPartitionColumnStatistics(....) throws NoSuchObjectException, MetaException { boolean committed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... <span class="hljs-comment"><span class="hljs-comment">/*some actions*/</span></span> committed = commitTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LOG.error(<span class="hljs-string"><span class="hljs-string">"Error retrieving statistics via jdo"</span></span>, ex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ex instanceof MetaException) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (MetaException) ex; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MetaException(ex.getMessage()); } finally { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!committed) { rollbackTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lists.newArrayList(); } } }</code> </pre> <br>  Mengembalikan apa pun dari blok <i>terakhir</i> adalah praktik yang sangat buruk, dan contoh ini dengan jelas menunjukkan alasannya. <br><br>  Di blok <i>percobaan</i> , program membentuk permintaan dan mengakses penyimpanan.  Variabel yang <i>dikomit</i> memiliki nilai <i>false</i> secara default dan mengubah statusnya hanya setelah semua tindakan sebelumnya di blok <i>percobaan</i> telah berhasil dieksekusi.  Ini berarti bahwa jika pengecualian dikemukakan, variabel itu akan selalu <i>salah</i> .  Blok <i>penangkap</i> akan menangkap pengecualian, sesuaikan sedikit, dan buang.  Jadi ketika giliran blok <i>akhirnya</i> , eksekusi akan memasuki kondisi dari mana daftar kosong akan dikembalikan.  Berapa pengembalian ini kepada kita?  Yah, itu biaya kita mencegah pengecualian tertangkap dari dibuang ke luar di mana itu bisa ditangani dengan benar.  Tidak ada pengecualian yang ditentukan dalam tanda tangan metode yang akan dilemparkan;  mereka hanya menyesatkan. <br><br>  Pesan diagnostik serupa: <br><br><ul><li>  V6051 Penggunaan pernyataan 'kembali' di blok 'akhirnya' dapat menyebabkan hilangnya pengecualian yang tidak ditangani.  ObjectStore.java (808) </li></ul><br><h2>  Lain-lain </h2><br>  Fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6009</a> 'compareTo' menerima argumen aneh.  Objek 'o2.getWorkerIdentity ()' digunakan sebagai argumen untuk metode sendiri.  LlapFixedRegistryImpl.java (244) <br><br><pre> <code class="cpp hljs">@Override <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;LlapServiceInstance&gt; getAllInstancesOrdered(....) { .... Collections.sort(<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Comparator&lt;LlapServiceInstance&gt;() { @Override <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> compare(LlapServiceInstance o1, LlapServiceInstance o2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o2.getWorkerIdentity().compareTo(o2.getWorkerIdentity()); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } }); .... }</span></span></code> </pre> <br>  Mungkin ada sejumlah penyebab yang menyebabkan kesalahan konyol: copy-paste, kecerobohan, terburu-buru, dan sebagainya.  Kita sering melihat kesalahan seperti itu dalam proyek open-source dan bahkan memiliki seluruh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> tentang itu. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6020</a> Bagilah dengan nol.  Kisaran nilai penyebut 'pembagi' termasuk nol.  SqlMathUtil.java (265) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divideUnsignedLong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dividend, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divisor &lt; <span class="hljs-number"><span class="hljs-number">0L</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*some comments*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (compareUnsignedLong(dividend, divisor)) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0L</span></span> : <span class="hljs-number"><span class="hljs-number">1L</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dividend &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Both inputs non-negative return dividend / divisor; // &lt;= } else { .... } }</span></span></code> </pre> <br>  Yang ini cukup sepele.  Serangkaian cek tidak berdaya untuk mencegah pembagian dengan nol. <br><br>  Beberapa peringatan lagi: <br><br><ul><li>  V6020 Mod dengan nol.  Kisaran nilai penyebut 'pembagi' termasuk nol.  SqlMathUtil.java (309) </li><li>  V6020 Bagilah dengan nol.  Kisaran nilai penyebut 'pembagi' termasuk nol.  SqlMathUtil.java (276) </li><li>  V6020 Bagilah dengan nol.  Kisaran nilai penyebut 'pembagi' termasuk nol.  SqlMathUtil.java (312) </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6030</a> Metode yang terletak di sebelah kanan '|'  operator akan dipanggil terlepas dari nilai operan kiri.  Mungkin, lebih baik menggunakan '||'.  OperatorUtils.java (573) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Operator&lt;? extends OperatorDesc&gt; findSourceRS(....) { .... List&lt;Operator&lt;? extends OperatorDesc&gt;&gt; parents = ....; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parents == null | parents.isEmpty()) { <span class="hljs-comment"><span class="hljs-comment">// reached end eg TS operator return null; } .... }</span></span></code> </pre> <br>  Programmer menulis operator bitwise |  bukannya logis ||.  Itu berarti bagian kanan akan dieksekusi tidak peduli hasil dari yang kiri.  Jika <i>orang tua == null</i> , kesalahan ketik ini akan berakhir dengan NPE tepat di subekspresi logis berikutnya. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6042</a> Ekspresi diperiksa untuk kompatibilitas dengan tipe 'A' tetapi dilemparkan ke tipe 'B'.  VectorColumnAssignFactory.java (347) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VectorColumnAssign </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildObjectAssign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VectorizedRowBatch outputBatch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outColIndex, PrimitiveCategory category)</span></span></span><span class="hljs-function"> throws HiveException </span></span>{ VectorColumnAssign outVCA = null; ColumnVector destCol = outputBatch.cols[outColIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destCol == null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destCol instanceof LongColumnVector) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(category) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LONG: outVCA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VectorLongColumnAssign() { .... } .init(.... , (LongColumnVector) destCol); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TIMESTAMP: outVCA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VectorTimestampColumnAssign() { .... }.init(...., (TimestampColumnVector) destCol); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case DATE: outVCA = new VectorLongColumnAssign() { .... } .init(...., (LongColumnVector) destCol); break; case INTERVAL_YEAR_MONTH: outVCA = new VectorLongColumnAssign() { .... }.init(...., (LongColumnVector) destCol); break; case INTERVAL_DAY_TIME: outVCA = new VectorIntervalDayTimeColumnAssign() { .... }.init(...., (IntervalDayTimeColumnVector) destCol);// &lt;= break; default: throw new HiveException(....); } } else if (destCol instanceof DoubleColumnVector) { .... } .... else { throw new HiveException(....); } return outVCA; }</span></span></code> </pre> <br>  Kami tertarik pada kelas yang <i>LongColumnVector memperluas ColumnVector</i> dan <i>TimestampColumnVector memperluas ColumnVector</i> .  Pemeriksaan bahwa objek <i>destCol</i> adalah turunan dari <i>LongColumnVector</i> secara eksplisit menunjukkan bahwa itu adalah objek kelas ini yang akan ditangani dalam tubuh pernyataan bersyarat.  Meskipun demikian, bagaimanapun, itu masih dilemparkan ke <i>TimestampColumnVector</i> !  Seperti yang Anda lihat, ini adalah kelas yang berbeda kecuali bahwa mereka berasal dari orangtua yang sama.  Sebagai hasilnya, kami mendapatkan <i>ClassCastException</i> . <br><br>  Hal yang sama berlaku untuk casting ke <i>IntervalDayTimeColumnVector</i> : <br><br><ul><li>  V6042 Ekspresi diperiksa untuk kompatibilitas dengan tipe 'A' tetapi dilemparkan ke tipe 'B'.  VectorColumnAssignFactory.java (390) </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V6060</a> Referensi 'var' digunakan sebelum diverifikasi terhadap nol.  Var.java (402), Var.java (395) <br><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getClass() != obj.getClass()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return false; } Var var = (Var)obj; if (this == var) { return true; } else if (var == null || // &lt;= var.value == null || this.value == null) { return false; } .... }</span></span></code> </pre> <br>  Di sini Anda melihat pemeriksaan aneh objek <i>var</i> untuk <i>null</i> setelah dereference telah terjadi.  Dalam konteks ini, <i>var</i> dan <i>obj</i> adalah objek yang sama ( <i>var = (Var) obj</i> ).  Kehadiran cek <i>nol</i> menyiratkan bahwa objek yang dikirimkan mungkin nol.  Jadi, memanggil <i>equals (null)</i> akan menghasilkan NPE, bukannya <i>false yang</i> diharapkan, tepat di baris pertama.  Ya, ceknya ada di sana, tapi, sayangnya, ada di tempat yang salah. <br><br>  Beberapa kasus serupa lainnya, di mana objek digunakan sebelum pemeriksaan: <br><br><ul><li>  V6060 Referensi 'nilai' digunakan sebelum diverifikasi terhadap nol.  ParquetRecordReaderWrapper.java (168), ParquetRecordReaderWrapper.java (166) </li><li>  V6060 Referensi 'defaultConstraintCols' digunakan sebelum diverifikasi terhadap nol.  HiveMetaStore.java (2539), HiveMetaStore.java (2530) </li><li>  V6060 Referensi 'projIndxLst' digunakan sebelum diverifikasi terhadap nol.  RelOptHiveTable.java (683), RelOptHiveTable.java (682) </li><li>  V6060 Referensi 'oldp' digunakan sebelum diverifikasi terhadap nol.  ObjectStore.java (4343), ObjectStore.java (4339) </li><li>  dan seterusnya ... </li></ul><br><h2>  Kesimpulan </h2><br>  Jika Anda pernah tertarik pada Big Data jika hanya sedikit, maka Anda tidak akan menyadari betapa pentingnya Apache Hive.  Ini adalah proyek yang populer, dan cukup besar, terdiri dari lebih dari 6500 file sumber (* .java).  Banyak pengembang telah menulisnya selama bertahun-tahun, yang berarti ada banyak hal yang dapat ditemukan oleh penganalisa statis di sana.  Ini membuktikan sekali lagi bahwa analisis statis sangat penting dan berguna ketika mengembangkan proyek-proyek menengah dan besar! <br><br>  Catatan  Pemeriksaan satu kali seperti yang saya lakukan di sini baik untuk menunjukkan kemampuan penganalisa tetapi skenario yang benar-benar tidak tepat untuk menggunakannya.  Gagasan ini diuraikan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Analisis statis akan digunakan secara teratur! <br><br>  Pemeriksaan Hive ini mengungkapkan beberapa cacat dan fragmen yang mencurigakan.  Jika penulis Apache Hive menemukan artikel ini, kami akan dengan senang hati membantu kerja keras meningkatkan proyek. <br><br>  Anda tidak dapat membayangkan Apache Hive tanpa Apache Hadoop, jadi Unicorn dari PVS-Studio juga dapat berkunjung ke sana.  Tapi itu saja untuk hari ini.  Sementara itu, saya mengundang Anda untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengunduh</a> penganalisa dan memeriksa proyek Anda sendiri. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463753/">https://habr.com/ru/post/id463753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463741/index.html">Firefox (sudah diperbaiki) dan Chrome memungkinkan Anda menggunakan header Alt-Svc untuk memindai port intranet</a></li>
<li><a href="../id463745/index.html">Komplikasi C ++ tidak bisa dihindari. Dan tidak hanya C ++</a></li>
<li><a href="../id463747/index.html">Akses properti di dalam bidang Jsonb untuk Npgsql</a></li>
<li><a href="../id463749/index.html">Scrum vs Kanban: Tetap Tenang dan Pilih Yang Cocok Untukmu</a></li>
<li><a href="../id463751/index.html">iOS 13: Apa yang Anda butuhkan dan apa yang benar-benar tidak perlu Anda lakukan saat mengembangkan untuk OS baru</a></li>
<li><a href="../id463755/index.html">Perbedaan antara "Juni", "Tengah" dan "Senior". Dan apa yang harus dilakukan untuk naik satu level</a></li>
<li><a href="../id463759/index.html">PVS-Studio mengunjungi Apache Hive</a></li>
<li><a href="../id463761/index.html">Kerangka kerja microservice PHP - Swoft</a></li>
<li><a href="../id463763/index.html">Sederhanakan migrasi dari OpenShift 3 ke OpenShift 4</a></li>
<li><a href="../id463765/index.html">Slurm DevOps: mengapa kita tidak akan membahas filosofi DevOps dan apa yang akan terjadi sebagai gantinya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>