<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöê üëßüèΩ üëáüèæ Desenvolva seu navegador a partir do zero. Parte Um: HTML üë∂üèø üë©üèø‚Äçü§ù‚Äçüë©üèΩ üë®üèª‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! 


 Continuamos a s√©rie de artigos sobre o desenvolvimento do mecanismo do navegador. 


 Neste artigo, mostrarei como criar o analisador...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desenvolva seu navegador a partir do zero. Parte Um: HTML</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430736/"><p><img src="https://habrastorage.org/webt/qu/3l/02/qu3l02mug029as5w74y2zznn0yc.jpeg"></p><br><p>  Ol√° pessoal! </p><br><p>  Continuamos a s√©rie de artigos sobre o desenvolvimento do mecanismo do navegador. </p><br><p>  Neste artigo, mostrarei como criar o analisador HTML mais r√°pido com o DOM.  Veremos a especifica√ß√£o HTML e por que ela √© ruim em rela√ß√£o ao desempenho e consumo de recursos ao analisar o HTML. </p><br><p>  Com este t√≥pico, relatei o HighLoad ++ passado.  Nem todos podem participar da confer√™ncia, al√©m do artigo ter mais detalhes. </p><br><p>  Suponho que o leitor tenha conhecimento b√°sico de HTML: tags, n√≥s, elementos, espa√ßo para nome. </p><a name="habracut"></a><br><h2 id="specifikaciya-html">  Especifica√ß√£o HTML </h2><br><p>  Antes de come√ßar a tocar na implementa√ß√£o do analisador HTML, voc√™ precisa entender em que especifica√ß√µes HTML acreditar. </p><br><p>  Existem duas especifica√ß√µes HTML: </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WHATWG</a> <br><ul><li> Apple, Mozilla, Google, Microsoft </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">W3c</a> <br><ul><li>  Grande lista de empresas </li></ul></li></ol><br><p> Naturalmente, a escolha recaiu sobre os l√≠deres do setor - <strong><code>WHATWG</code></strong> .  Padr√£o de vida, grandes empresas, cada uma com seu pr√≥prio navegador / mecanismo de navegador. </p><br><p>  ATUALIZA√á√ÉO: Infelizmente, os links fornecidos para as especifica√ß√µes n√£o abrem da R√∫ssia.  Aparentemente, o "eco da guerra" com os telegramas. </p><br><h2 id="process-parsinga-html">  Processo de an√°lise de HTML </h2><br><p>  O processo de constru√ß√£o de uma √°rvore HTML pode ser dividido em quatro partes: </p><br><ol><li>  Decodificador </li><li>  Pr√©-tratamento </li><li>  Tokenizer </li><li>  Construindo uma √°rvore </li></ol><br><p>  Consideramos cada est√°gio separadamente. </p><br><h3 id="dekoder">  Decodificador </h3><br><p>  O tokenizer aceita caracteres Unicode (pontos de c√≥digo) como entrada.  Portanto, precisamos converter o fluxo de bytes atual em caracteres Unicode.  Para fazer isso, use a especifica√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Encoding</a> . </p><br><p>  Se tivermos HTML com uma codifica√ß√£o desconhecida (sem cabe√ßalho HTTP), precisaremos determin√°-lo antes do in√≠cio da decodifica√ß√£o.  Para fazer isso, usaremos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">algoritmo de detec√ß√£o de codifica√ß√£o</a> . </p><br><p>  Se muito brevemente, a ess√™ncia do algoritmo √© que esperamos <strong><code>500</code></strong> ou os primeiros <strong><code>1024 </code></strong> do fluxo de bytes e executamos o algoritmo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pr√©-digitaliza√ß√£o de um fluxo de bytes para determinar sua codifica√ß√£o</a> que tenta encontrar a <strong><code>&lt;meta&gt;</code></strong> com os atributos <strong><code>http-equiv</code></strong> , <strong><code>content</code></strong> ou <strong><code>charset</code></strong> e tenta entender o que a codifica√ß√£o indicada pelo desenvolvedor HTML. </p><br><p>  A especifica√ß√£o de <strong><code>Encoding</code></strong> estipula o conjunto m√≠nimo de codifica√ß√µes suportadas pelo mecanismo do navegador (21 no total): UTF-8, ISO-8859-2, ISO-8859-7, ISO-8859-8, windows-874, windows-1250, windows-1251, windows -1252, windows-1254, windows-1255, windows-1256, windows-1257, windows-1258, gb18030, Big5, ISO-2022-JP, Shift_JIS, EUC-KR, UTF-16BE, UTF-16LE e x-usu√°rio -definido. </p><br><h3 id="predvaritelnaya-obrabotka">  Pr√©-tratamento </h3><br><p>  Depois de decodificar os bytes em caracteres Unicode, precisamos "limpar".  Substitua todos os caracteres de retorno de carro ( <strong><code>\r</code></strong> ) seguidos por um caractere de avan√ßo de linha ( <strong><code>\n</code></strong> ) por um caractere de retorno de carro ( <strong><code>\r</code></strong> ).  Em seguida, substitua todos os caracteres de retorno de carro por um caractere de nova linha ( <strong><code>\n</code></strong> ). </p><br><p>  Assim descrito na especifica√ß√£o.  Ou seja, <strong><code>\r\n</code></strong> =&gt; <strong><code>\r</code></strong> , <strong><code>\r</code></strong> =&gt; <strong><code>\n</code></strong> . </p><br><p>  Mas, de fato, ningu√©m faz.  Facilite: </p><br><p>  Se voc√™ obtiver um caractere de retorno de carro ( <strong><code>\r</code></strong> ), verifique se h√° um caractere de avan√ßo de linha ( <strong><code>\n</code></strong> ).  Se houver, alteramos os dois caracteres para o caractere de avan√ßo de linha ( <strong><code>\n</code></strong> ); caso contr√°rio, alteramos apenas o primeiro caractere ( <strong><code>\r</code></strong> ) para o avan√ßo de linha ( <strong><code>\n</code></strong> ). </p><br><p>  Isso completa o processamento preliminar de dados.  Sim, voc√™ s√≥ precisa se livrar dos s√≠mbolos de retorno de carro para que eles n√£o caiam no tokenizador.  O tokenizador n√£o espera e n√£o sabe o que fazer com o s√≠mbolo de retorno de carro. </p><br><h3 id="oshibki-parsinga">  Erros de an√°lise </h3><br><p>  Para que no futuro n√£o haja perguntas, voc√™ deve informar imediatamente o que √© um <code> </code> ( <strong><code>parse error</code></strong> ). </p><br><p>  Nada realmente errado.  Parece amea√ßador, mas na verdade isso √© apenas um aviso de que est√°vamos esperando um, mas temos outro. </p><br><p>  Um erro de an√°lise n√£o interrompe o processamento de dados ou a constru√ß√£o de √°rvores.  Esta √© uma mensagem que indica que n√£o temos HTML v√°lido. </p><br><p>  O erro de an√°lise pode ser obtido para pares substitutos, <code>\0</code> , local incorreto da marca, <strong><code>&lt;!DOCTYPE&gt;</code></strong> incorreto e todo tipo de outras coisas. </p><br><p>  A prop√≥sito, alguns erros de an√°lise levam a consequ√™ncias.  Por exemplo, se voc√™ especificar "bad" <strong><code>&lt;!DOCTYPE&gt;</code></strong> , a √°rvore HTML ser√° marcada como <strong><code>QUIRKS</code></strong> e a l√≥gica de algumas fun√ß√µes do DOM ser√° alterada. </p><br><h3 id="tokenizator">  Tokenizer </h3><br><p>  Como mencionado anteriormente, o tokenizer aceita caracteres Unicode como entrada.  Esta √© uma m√°quina de estado que possui <strong><code>80</code></strong> estados.  Em cada estado, condi√ß√µes para caracteres Unicode.  Dependendo do caractere recebido, o tokenizador pode: </p><br><ol><li>  Mude seu estado </li><li>  Gere um token e mude de estado </li><li>  N√£o fa√ßa nada, aguarde o pr√≥ximo personagem </li></ol><br><p>  O tokenizer cria seis tipos de tokens: DOCTYPE, Tag inicial, Tag final, Coment√°rio, Caractere, Fim do arquivo.  Que entram no est√°gio de constru√ß√£o de uma √°rvore. </p><br><p>  Vale ressaltar que o tokenizer n√£o conhece todos os seus estados, mas onde cerca de 40% (retirado do teto, por exemplo).  "Por que o resto?"  - voc√™ pergunta.  Cerca dos 60% restantes conhecem o est√°gio de constru√ß√£o de uma √°rvore. </p><br><p>  Isso √© feito para analisar corretamente tags como <strong><code>&lt;textarea&gt;</code></strong> , <strong><code>&lt;style&gt;</code></strong> , <strong><code>&lt;script&gt;</code></strong> , <strong><code>&lt;title&gt;</code></strong> e assim por diante.  Ou seja, geralmente aquelas tags nas quais n√£o esperamos outras, mas apenas fechando a n√≥s mesmos. </p><br><p>  Por exemplo, a <strong><code>&lt;title&gt;</code></strong> n√£o pode conter outras tags.  Qualquer tag em <strong><code>&lt;title&gt;</code></strong> ser√° percebida como texto at√© encontrar uma tag de fechamento <strong><code>&lt;/title&gt;</code></strong> . </p><br><p>  Por que isso √© feito?  Afinal, voc√™ pode simplesmente dizer ao tokenizer que, se encontrarmos a <strong><code>&lt;title&gt;</code></strong> seguiremos o "caminho que precisamos".  E isso seria verdade se n√£o os namespaces!  Sim, o espa√ßo para nome afeta o comportamento do est√°gio de constru√ß√£o da √°rvore, que por sua vez altera o comportamento do tokenizador. </p><br><p>  Como exemplo, considere o comportamento da <strong><code>&lt;title&gt;</code></strong> nos espa√ßos para nome HTML e SVG: </p><br><p>  <strong>HTML</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  O resultado da constru√ß√£o de uma √°rvore: </p><br><pre> <code class="plaintext hljs">&lt;title&gt; "&lt;span&gt;&lt;/span&gt;"</code> </pre> <br><p>  <strong>Svg</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  O resultado da constru√ß√£o de uma √°rvore: </p><br><pre> <code class="plaintext hljs">&lt;svg&gt; &lt;title&gt; &lt;span&gt; ""</code> </pre> <br><p>  Vimos que, no primeiro caso (espa√ßo de nome HTML), a <strong><code>&lt;span&gt;</code></strong> √© texto, o elemento <strong><code>span</code></strong> n√£o foi criado.  No segundo caso (espa√ßo de nome SVG), um elemento foi criado com base na tag <strong><code>&lt;span&gt;</code></strong> .  Ou seja, dependendo do espa√ßo para nome, as tags se comportam de maneira diferente. </p><br><p>  Mas isso n√£o √© tudo.  O bolo desta "celebra√ß√£o da vida" √© o fato de que o pr√≥prio tokenizador deve saber em que espa√ßo de nome est√° localizado o est√°gio de constru√ß√£o da √°rvore.  E isso √© necess√°rio apenas para lidar adequadamente com o <strong><code>CDATA</code></strong> . </p><br><p>  Considere dois exemplos com <strong><code>CDATA</code></strong> , dois espa√ßos para nome: </p><br><p>  <strong>HTML</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>&lt;![CDATA[  ]]&gt;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  O resultado da constru√ß√£o de uma √°rvore: </p><br><pre> <code class="plaintext hljs">&lt;div&gt; &lt;!--[CDATA[  ]]--&gt;</code> </pre> <br><p>  <strong>Svg</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span>&lt;![CDATA[  ]]&gt;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  O resultado da constru√ß√£o de uma √°rvore: </p><br><pre> <code class="plaintext hljs">&lt;div&gt; &lt;svg&gt; "  "</code> </pre> <br><p>  No primeiro caso (espa√ßo para nome HTML), o tokenizer levou o <strong><code>CDATA</code></strong> para comentar.  No segundo caso, o tokenizer desmontou a estrutura <strong><code>CDATA</code></strong> e recebeu dados dela.  Em geral, a regra √© a seguinte: se encontrarmos <strong><code>CDATA</code></strong> n√£o est√° no espa√ßo de nomes HTML, analisamos-o, caso contr√°rio, o consideraremos como um coment√°rio. </p><br><p>  Essa √© a conex√£o estreita entre o tokenizer e a constru√ß√£o da √°rvore.  O tokenizer deve saber em qual espa√ßo de nomes est√° localizado o est√°gio de constru√ß√£o da √°rvore e o est√°gio de constru√ß√£o da √°rvore pode alterar o estado do tokenizador. </p><br><h3 id="tokeny">  Tokens </h3><br><p>  Abaixo, consideraremos todos os seis tipos de tokens criados pelo tokenizer.  Vale ressaltar que todos os tokens prepararam dados, isto √©, j√° foram processados ‚Äã‚Äãe ‚Äúprontos para uso‚Äù.  Isso significa que todas as refer√™ncias de caracteres nomeadas, como <strong><code>&amp;copy</code></strong> , ser√£o convertidas em caracteres unicode. </p><br><h3 id="doctype-token">  DOCTYPE Token </h3><br><p>  O token DOCTYPE possui sua pr√≥pria estrutura n√£o semelhante a outras tags.  O token cont√©m: </p><br><ol><li>  Primeiro nome </li><li>  Identificador p√∫blico </li><li>  Identificador do sistema </li></ol><br><p>  No HTML moderno, o √∫nico DOCTYPE v√°lido / v√°lido deve ficar assim: </p><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span></code> </pre> <br><p>  Todos os outros <strong><code>&lt;!DOCTYPE&gt;</code></strong> ser√£o considerados um erro de an√°lise. </p><br><h3 id="start-tag-token">  Iniciar token de tag </h3><br><p>  A tag de abertura pode conter: </p><br><ol><li>  Nome da tag </li><li>  Atributos </li><li>  Bandeiras </li></ol><br><p>  Por exemplo, </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  A tag de abertura pode conter um sinalizador de <strong><code>self-closing</code></strong> .  Esse sinalizador n√£o afeta o fechamento da tag, mas pode causar um erro de an√°lise para elementos n√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nulos</a> . </p><br><h3 id="end-tag-token">  Finalizar token da tag </h3><br><p>  Tag de fechamento.  Ele possui todas as propriedades do token da tag de abertura, mas possui uma barra <strong><code>/</code></strong> na frente do nome da tag. </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br><p>  A tag de fechamento pode conter um sinalizador de <strong><code>self-closing</code></strong> que causar√° um erro de an√°lise.  Al√©m disso, o erro de an√°lise ser√° causado pelos atributos da marca de fechamento.  Eles ser√£o analisados ‚Äã‚Äãcorretamente, mas jogados fora na fase de constru√ß√£o das √°rvores. </p><br><h3 id="comment-token">  Token de coment√°rio </h3><br><p>  O token de coment√°rio cont√©m todo o texto do coment√°rio.  Ou seja, √© completamente copiado do fluxo para o token. </p><br><p>  Exemplo </p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--  --&gt;</span></span></code> </pre> <br><h3 id="character-token">  Token de personagem </h3><br><p>  Talvez o token mais interessante.  S√≠mbolo de token Unicode.  Pode conter um (apenas um) caractere. </p><br><p>  Um token ser√° criado para cada caractere em HTML e enviado ao est√°gio de constru√ß√£o da √°rvore.  Isso √© muito caro. <br>  Vamos ver como isso funciona. </p><br><p>  Pegue os dados HTML: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> ! &amp;reg;<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  O que voc√™ acha quantos tokens ser√£o criados para este exemplo?  Resposta: 22. </p><br><p>  Considere a lista de tokens criados: </p><br><pre> <code class="plaintext hljs">Start tag token: &lt;span&gt; Character token:  Character token:  Character token:  Character token:  Character token:  Character token: Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token:  Character token: ! Character token: Character token: End tag token: &lt;/span&gt; End-of-file token</code> </pre> <br><p>  N√£o √© reconfortante, certo?  Mas, √© claro, muitos criadores de analisadores de HTML de fato t√™m apenas um token durante o processamento.  Executando-o em um c√≠rculo e substituindo-o por novos dados a cada vez. </p><br><p>  Vamos seguir em frente e responder √† pergunta: por que isso √© feito?  Por que n√£o levar esse texto em uma √∫nica pe√ßa?  A resposta est√° na fase de constru√ß√£o da √°rvore. </p><br><p>  Um tokenizador √© in√∫til sem o est√°gio de constru√ß√£o de uma √°rvore HTML.  √â na fase de constru√ß√£o de uma √°rvore que o texto √© colado com diferentes condi√ß√µes. </p><br><p>  As condi√ß√µes s√£o aproximadamente as seguintes: </p><br><ol><li>  Se um token de caractere com <strong><code>U+0000</code></strong> ( <strong><code>NULL</code></strong> ) chegar, causamos um erro de an√°lise e ignoramos o token. </li><li>  Se um dos <strong><code>CHARACTER TABULATION</code></strong> <strong><code>U+0009</code></strong> ( <strong><code>CHARACTER TABULATION</code></strong> ), <strong><code>U+000A</code></strong> ( <strong><code>LINE FEED (LF)</code></strong> ), <strong><code>U+000C</code></strong> ( <strong><code>FORM FEED (FF)</code></strong> ) ou <strong><code>U+0020</code></strong> ( <strong><code>SPACE</code></strong> ) vier, chame o algoritmo para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">restaurar os elementos de formata√ß√£o ativos</a> e insira o token na √°rvore. </li></ol><br><p>  O token de s√≠mbolo √© adicionado √† √°rvore de acordo com o algoritmo: </p><br><ol><li>  Se a posi√ß√£o de inser√ß√£o atual n√£o for um n√≥ de texto, crie um n√≥ de texto, insira-o na √°rvore e adicione dados do token a ele. </li><li>  Caso contr√°rio, adicione dados do token a um n√≥ de texto existente. </li></ol><br><p>  Esse comportamento cria muitos problemas.  A necessidade de cada s√≠mbolo criar um token e enviar para an√°lise ao est√°gio de constru√ß√£o de uma √°rvore.  N√£o sabemos o tamanho do n√≥ de texto e temos que alocar muita mem√≥ria antecipadamente ou fazer realoks.  Tudo isso √© extremamente caro de mem√≥ria ou tempo. </p><br><h3 id="end-of-file-token">  Token de fim de arquivo </h3><br><p>  Token simples e claro.  Os dados acabaram - vamos inform√°-lo sobre esta etapa da constru√ß√£o das √°rvores. </p><br><h3 id="postroenie-dereva">  Construindo uma √°rvore </h3><br><p>  A constru√ß√£o de √°rvores √© uma m√°quina <strong><code>23</code></strong> estados com <strong><code>23</code></strong> estados com muitas condi√ß√µes para tokens (tags, texto).  O est√°gio de constru√ß√£o de uma √°rvore √© o maior, ocupa uma parte significativa da especifica√ß√£o e tamb√©m √© capaz de causar irrita√ß√£o e sono let√°rgico. </p><br><p>  Tudo √© organizado de maneira muito simples.  Os tokens s√£o recebidos na entrada e, dependendo do token, o estado da constru√ß√£o da √°rvore √© alternado.  Na sa√≠da, temos um DOM real. </p><br><h2 id="problemy">  Problemas? </h2><br><p>  Os seguintes problemas parecem bastante √≥bvios: </p><br><p>  <strong>C√≥pia por caractere</strong> </p><br><p>  Cada estado do tokenizer recebe um caractere na entrada, que copia / converte quando necess√°rio: nomes de tags, atributos, coment√°rios, s√≠mbolos. </p><br><p>  Isso √© muito in√∫til, tanto na mem√≥ria quanto no tempo.  Somos for√ßados a pr√©-alocar uma quantidade desconhecida de mem√≥ria para cada atributo, nome da tag, coment√°rio e assim por diante.  E isso, consequentemente, leva a realoks, e realoks levam a tempo perdido. </p><br><p>  E se voc√™ imagina que o HTML cont√©m 1000 tags e cada tag possui pelo menos um atributo, obtemos um analisador infernalmente lento. </p><br><p>  <strong>Token de personagem</strong> </p><br><p>  O segundo problema √© o token de caractere.  Acontece que criamos um token para cada s√≠mbolo e damos para construir uma √°rvore.  Construir uma √°rvore n√£o sabe quantos desses tokens teremos e n√£o podemos alocar mem√≥ria imediatamente para o n√∫mero necess√°rio de caracteres.  Assim, aqui todos os mesmos realoks + constantes verificam a presen√ßa de um n√≥ de texto no estado atual da √°rvore. </p><br><p>  <strong>Sistema monol√≠tico</strong> </p><br><p>  O grande problema √© a depend√™ncia de tudo em tudo.  Ou seja, o tokenizer depende do estado de constru√ß√£o da √°rvore, e a constru√ß√£o da √°rvore pode controlar o tokenizer.  E tudo √© o culpado pelo namespace (namespaces). </p><br><h2 id="kak-budem-reshat-problemy">  Como vamos resolver os problemas? </h2><br><p>  A seguir, descreverei a implementa√ß√£o do analisador de HTML no meu projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lexbor</a> , bem como a solu√ß√£o para todos os problemas expressos. </p><br><h3 id="predvaritelnaya-obrabotka-1">  Pr√©-tratamento </h3><br><p>  Removemos o processamento preliminar de dados.  Treinaremos o tokenizador para entender o retorno de carro ( <strong><code>\r</code></strong> ) como um caractere de espa√ßo.  Assim, ele ser√° jogado no est√°gio de constru√ß√£o de uma √°rvore onde descobriremos isso. </p><br><h3 id="tokeny-1">  Tokens </h3><br><p>  Com um movimento do pulso, unificamos todos os tokens.  Teremos um token para tudo.  Em geral, haver√° apenas um token em todo o processo de an√°lise. </p><br><p>  Nosso token unificado conter√° os seguintes campos: </p><br><ol><li>  ID da tag </li><li>  Iniciar </li><li>  Fim </li><li>  Atributos </li><li>  Bandeiras </li></ol><br><h4 id="tag-id">  ID da tag </h4><br><p>  N√£o trabalharemos com a representa√ß√£o textual do nome da tag.  N√≥s traduzimos tudo em n√∫meros.  Os n√∫meros s√£o f√°ceis de comparar, mais f√°ceis de trabalhar. </p><br><p>  Criamos uma tabela de hash est√°tica de todas as tags conhecidas.  Criamos enum a partir de todas as tags conhecidas.  Ou seja, precisamos atribuir rigidamente um identificador para cada tag.  Assim, na tabela de hash, a chave √© o nome da marca e o valor √© gravado na enumera√ß√£o. </p><br><p>  Por exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { LXB_TAG__UNDEF = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>, LXB_TAG__END_OF_FILE = <span class="hljs-number"><span class="hljs-number">0x0001</span></span>, LXB_TAG__TEXT = <span class="hljs-number"><span class="hljs-number">0x0002</span></span>, LXB_TAG__DOCUMENT = <span class="hljs-number"><span class="hljs-number">0x0003</span></span>, LXB_TAG__EM_COMMENT = <span class="hljs-number"><span class="hljs-number">0x0004</span></span>, LXB_TAG__EM_DOCTYPE = <span class="hljs-number"><span class="hljs-number">0x0005</span></span>, LXB_TAG_A = <span class="hljs-number"><span class="hljs-number">0x0006</span></span>, LXB_TAG_ABBR = <span class="hljs-number"><span class="hljs-number">0x0007</span></span>, LXB_TAG_ACRONYM = <span class="hljs-number"><span class="hljs-number">0x0008</span></span>, LXB_TAG_ADDRESS = <span class="hljs-number"><span class="hljs-number">0x0009</span></span>, LXB_TAG_ALTGLYPH = <span class="hljs-number"><span class="hljs-number">0x000a</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Como voc√™ pode ver no exemplo, criamos tags para o token <strong>END-OF-FILE</strong> , para texto, para um documento.  Tudo isso para maior conveni√™ncia.  Abrindo a cortina, direi que no n√≥ ( <strong><code>DOM Node Interface</code></strong> ) teremos um <strong><code>Tag ID</code></strong> .  Isso √© feito para n√£o fazer duas compara√ß√µes: no tipo de n√≥ e no elemento.  Ou seja, se precisarmos de um elemento <strong><code>DIV</code></strong> , faremos uma verifica√ß√£o no n√≥: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;tag_id == LXB_TAG_DIV) { <span class="hljs-comment"><span class="hljs-comment">/* Best code */</span></span> }</code> </pre> <br><p>  Mas, √© claro, voc√™ pode fazer isso: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;type == LXB_DOM_NODE_TYPE_ELEMENT &amp;&amp; node-&gt;tag_id == LXB_TAG_DIV) { <span class="hljs-comment"><span class="hljs-comment">/* Oh, code */</span></span> }</code> </pre> <br><p>  S√£o necess√°rios dois sublinhados em <strong><code>LXB_TAG__</code></strong> para separar tags comuns das tags do sistema.  Em outras palavras, o usu√°rio pode criar uma tag com o nome <strong><code>text</code></strong> ou no <strong><code>end-of-file</code></strong> e <strong><code>end-of-file</code></strong> se procurarmos pelo nome da tag, nenhum erro ocorrer√°.  Todas as tags do sistema come√ßam com um <strong><code>#</code></strong> . </p><br><p>  Ainda assim, um n√≥ pode armazenar uma representa√ß√£o textual do nome da marca.  Para 98.99999% de n√≥s, esse par√¢metro ser√° <strong><code>NULL</code></strong> .  Em alguns espa√ßos para nome, precisamos especificar um prefixo ou nome de marca com um registro fixo.  Por exemplo, <strong><code>baseProfile</code></strong> no espa√ßo de nome SVG. </p><br><p>  A l√≥gica do trabalho √© simples.  Se tivermos uma tag com um registro claramente definido, ent√£o: </p><br><ol><li>  Adicione-o √† base geral de tags em min√∫sculas.  Obtenha o ID da tag. </li><li>  Adicione o identificador de marca e o nome da marca original na representa√ß√£o de texto ao n√≥. </li></ol><br><p>  <strong>Tags personalizadas</strong> </p><br><p>  Um desenvolvedor pode criar qualquer tag em HTML.  Como temos apenas as tags que conhecemos em uma tabela hash est√°tica e o usu√°rio pode criar uma, precisamos de uma tabela hash din√¢mica. </p><br><p>  Tudo parece muito simples.  Quando a tag chegar, veremos se est√° na tabela de hash est√°tica.  Se n√£o houver uma tag, vejamos a din√¢mica, se n√£o houver, aumentamos o contador do identificador em um e adicionamos a tag √† tabela din√¢mica. </p><br><p>  Tudo descrito acontece no est√°gio do tokenizer.  Dentro do tokenizer e depois de todas as compara√ß√µes, v√° pelo <strong><code>Tag ID</code></strong> (com raras exce√ß√µes). </p><br><h4 id="begin-and-end">  In√≠cio e fim </h4><br><p>  Agora, no tokenizer, n√£o teremos processamento de dados.  N√£o copiaremos e converteremos nada.  Apenas indicamos o in√≠cio e o fim dos dados. </p><br><p>  Todo o processamento de dados, como links simb√≥licos, ocorrer√° no est√°gio de constru√ß√£o da √°rvore. <br>  Assim, saberemos o tamanho dos dados para a aloca√ß√£o subsequente de mem√≥ria. </p><br><h4 id="attributes">  Atributos </h4><br><p>  Tudo √© t√£o simples aqui.  N√≥s n√£o copiamos nada, mas simplesmente salvamos os ponteiros no in√≠cio / fim dos valores de nome e atributo.  Todas as transforma√ß√µes ocorrem no momento em que a √°rvore √© constru√≠da. </p><br><h4 id="flags">  Bandeiras </h4><br><p>  Como temos tokens unificados, precisamos informar a constru√ß√£o de √°rvores sobre o tipo de token.  Para fazer isso, use o campo de bitmap Flags. </p><br><p>  O campo pode conter os seguintes valores: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { LXB_HTML_TOKEN_TYPE_OPEN = <span class="hljs-number"><span class="hljs-number">0x0000</span></span>, LXB_HTML_TOKEN_TYPE_CLOSE = <span class="hljs-number"><span class="hljs-number">0x0001</span></span>, LXB_HTML_TOKEN_TYPE_CLOSE_SELF = <span class="hljs-number"><span class="hljs-number">0x0002</span></span>, LXB_HTML_TOKEN_TYPE_TEXT = <span class="hljs-number"><span class="hljs-number">0x0004</span></span>, LXB_HTML_TOKEN_TYPE_DATA = <span class="hljs-number"><span class="hljs-number">0x0008</span></span>, LXB_HTML_TOKEN_TYPE_RCDATA = <span class="hljs-number"><span class="hljs-number">0x0010</span></span>, LXB_HTML_TOKEN_TYPE_CDATA = <span class="hljs-number"><span class="hljs-number">0x0020</span></span>, LXB_HTML_TOKEN_TYPE_NULL = <span class="hljs-number"><span class="hljs-number">0x0040</span></span>, LXB_HTML_TOKEN_TYPE_FORCE_QUIRKS = <span class="hljs-number"><span class="hljs-number">0x0080</span></span>, LXB_HTML_TOKEN_TYPE_DONE = <span class="hljs-number"><span class="hljs-number">0x0100</span></span> };</code> </pre> <br><p>  Al√©m do tipo de token que abre ou fecha, h√° valores para o conversor de dados.  Somente o tokenizador sabe como converter os dados corretamente.  Assim, o tokenizador marca no token como os dados devem ser processados. </p><br><h4 id="character-token-1">  Token de personagem </h4><br><p>  Do descrito anteriormente, pode-se concluir que o token de s√≠mbolo desapareceu de n√≥s.  Sim, agora temos um novo tipo de token: <strong><code>LXB_HTML_TOKEN_TYPE_TEXT</code></strong> .  Agora, criamos um token para o texto inteiro entre as tags, marcando como ele deve ser processado no futuro. </p><br><p>  Por isso, teremos que alterar as condi√ß√µes na constru√ß√£o da √°rvore.  Precisamos trein√°-lo para trabalhar n√£o com tokens simb√≥licos, mas com tokens de texto: converter, excluir caracteres desnecess√°rios, pular espa√ßos e assim por diante. </p><br><p>  Mas, n√£o h√° nada complicado.  Na fase de constru√ß√£o de uma √°rvore, as altera√ß√µes ser√£o m√≠nimas.  Mas o tokenizador agora n√£o corresponde √† especifica√ß√£o da palavra.  Mas n√£o precisamos dele, √© normal.  Nossa tarefa √© obter uma √°rvore HTML / DOM que esteja em total conformidade com as especifica√ß√µes. </p><br><h3 id="stadii-tokenizatora">  Etapas do tokenizador </h3><br><p>  Para garantir o processamento de dados em alta velocidade no tokenizer, adicionaremos nosso iterador a cada est√°gio.  De acordo com a especifica√ß√£o, cada est√°gio aceita um s√≠mbolo para n√≥s e, dependendo do s√≠mbolo que chegou, toma decis√µes.  Mas, a verdade √© que √© muito caro. </p><br><p>  Por exemplo, para passar do est√°gio <strong><code>ATTRIBUTE_NAME</code></strong> para o est√°gio <strong><code>ATTRIBUTE_VALUE</code></strong> precisamos encontrar um espa√ßo em branco no nome do atributo, o que indicar√° seu fim.  De acordo com a especifica√ß√£o, devemos alimentar por caractere o est√°gio <strong><code>ATTRIBUTE_NAME</code></strong> at√© que <strong><code>ATTRIBUTE_NAME</code></strong> um caractere de espa√ßo em branco, e esse est√°gio n√£o muda para outro.  Isso √© muito caro, geralmente √© implementado atrav√©s de uma chamada de fun√ß√£o para cada caractere ou retorno de chamada como "tkz-&gt; next_code_point ()". </p><br><p>  Adicionamos um loop ao est√°gio <strong><code>ATTRIBUTE_NAME</code></strong> e passamos todo o buffer de entrada.  No loop, procuramos os s√≠mbolos que precisamos alternar e continuamos a trabalhar no pr√≥ximo est√°gio.  Aqui temos muitos ganhos, at√© otimiza√ß√µes de compilador. </p><br><p>  Mas!  O pior √© que, dessa forma, quebramos o suporte de peda√ßos (peda√ßos) da caixa.  Gra√ßas ao processamento de caractere por s√≠mbolo em cada est√°gio do tokenizer, t√≠nhamos suporte para peda√ßos e agora o quebramos. </p><br><p>  Como consertar isso?  Como implementar o suporte para peda√ßos ?!  √â simples, apresentamos o conceito de buffers de entrada (buffer de entrada). </p><br><h3 id="incoming-buffer">  Buffer de entrada </h3><br><p>  Frequentemente, o HTML analisa em peda√ßos.  Por exemplo, se recebermos dados pela rede.  Para n√£o ficar ocioso enquanto aguarda os dados restantes, podemos enviar dados j√° recebidos para processamento / an√°lise.  Naturalmente, os dados podem ser extra√≠dos em qualquer lugar.  Por exemplo, temos dois buffers: </p><br><p>  <strong>Primeiro</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">clas</span></span></span></span></code> </pre> <br><p>  <strong>Segundo</strong> </p><br><pre> <code class="html hljs xml">s="oh-no-oh-no"&gt;</code> </pre> <br><p>  Como n√£o copiamos nada no est√°gio de tokeniza√ß√£o, mas apenas levamos ponteiros para o in√≠cio e o fim dos dados, temos um problema.  Ponteiros para diferentes buffers de usu√°rio.  E, como os desenvolvedores costumam usar o mesmo buffer para dados, estamos lidando com um ponteiro para o in√≠cio de dados inexistentes. </p><br><p>               . <br>   : </p><br><ol><li>              (Incoming Buffer). </li><li>     ( )  ,        ?  ,          .       ,           .  99%        . </li></ol><br><p>  "  "  .      . </p><br><p> ,      .      ,       ( )          .     . ,  ,   ,  .         . </p><br><h3 id="problema-dannye-v-tokene"> :    </h3><br><p>      ,  . ,        :          .     .             (    ),      .              . </p><br><p>    :      .  ,                . </p><br><h2 id="stadiya-postroeniya-dereva">    </h2><br><p>   . </p><br><p>      ,    . ,         . </p><br><p>    : </p><br><p> <strong> </strong> </p><br><pre> <code class="cpp hljs">tree_build_in_body_character(token) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.code_point == <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Parse error, ignore token */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token.code_point == whitespaces) { <span class="hljs-comment"><span class="hljs-comment">/* Insert element */</span></span><span class="hljs-string"><span class="hljs-string">' } /* ... */ }</span></span></code> </pre> <br><p> <strong> Lexbor HTML</strong> </p><br><pre> <code class="cpp hljs">tree_build_in_body_character(token) { <span class="hljs-keyword"><span class="hljs-keyword">lexbor_str_t</span></span> str = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">lxb_html_parser_char_t</span></span> pc = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; pc.drop_null = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; tree-&gt;status = lxb_html_token_parse_data(token, &amp;pc, &amp;str, tree-&gt;document-&gt;mem-&gt;text); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token-&gt;type &amp; LXB_HTML_TOKEN_TYPE_NULL) { <span class="hljs-comment"><span class="hljs-comment">/* Parse error */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* Insert element if not empty */</span></span> }</code> </pre> <br><p>   ,               .           : </p><br><pre> <code class="cpp hljs">pc.replace_null <span class="hljs-comment"><span class="hljs-comment">/*   '\0'    (REPLACEMENT CHARACTER (U+FFFD)) */</span></span> pc.drop_null <span class="hljs-comment"><span class="hljs-comment">/*   '\0' */</span></span> pc.is_attribute <span class="hljs-comment"><span class="hljs-comment">/*          " " */</span></span> pc.state <span class="hljs-comment"><span class="hljs-comment">/*  .        . */</span></span></code> </pre> <br><p>           . -   <strong><code>\0</code></strong> ,  -    <strong><code>REPLACEMENT CHARACTER</code></strong> . -    ,  - .        . </p><br><p>  ,     .      .  ,       <strong><code>&lt;head&gt;</code></strong>   .  ,           ,   : "    ".              ,           . </p><br><div class="spoiler"> <b class="spoiler_title">  &lt;sarcasm&gt;</b> <div class="spoiler_text"><p>  HTML  (   )    <strong><code>sarcasm</code></strong> .            . </p><br><pre> <code class="plaintext hljs">An end tag whose tag name is "sarcasm" Take a deep breath, then act as described in the "any other end tag" entry below.</code> </pre> <br><p>   . </p></div></div><br><h2 id="itog">  </h2><br><p>            HTML    DOM/HTML Interfaces   HTML/DOM    HTML . </p><br><p>    ,   : </p><br><ol><li>    (  ) </li><li>  <br><ul><li>  Incoming Buffer </li><li>   </li><li>   Tag ID </li><li> ÃÜ :  ,  N+  </li><li> ÃÜ     </li><li>      </li><li>    Ãà </li></ul></li><li>   <br><ul><li>      </li></ul></li></ol><br><p>  i7 2012 ,   ,      235MB   (Amazon-). </p><br><p>  ,        1.5/2 ,     . ,    . ,    CSS     (Grammar,  ,       Grammar).     HTML,  CSS  ,    "". </p><br><h2 id="ishodniki">  C√≥digo fonte </h2><br><p>      HTML    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lexbor HTML</a> . </p><br><h2 id="ps">  PS </h2><br><p>      CSS  Grammar.  ,     .  - 6-8 . </p><br><div class="spoiler"> <b class="spoiler_title"> ,    </b> <div class="spoiler_text"><p>    .  ,        . <br>      (      ).    . </p></div></div><br><p>  Obrigado pela aten√ß√£o! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430736/">https://habr.com/ru/post/pt430736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430724/index.html">DEFCON 21. A confer√™ncia DNS pode ser perigosa para sua sa√∫de. Parte 1</a></li>
<li><a href="../pt430728/index.html">Ensine-me a dar feedback</a></li>
<li><a href="../pt430730/index.html">O que a P&D ABBYY faz: Grupo de Pesquisa Avan√ßada em PNL</a></li>
<li><a href="../pt430732/index.html">Para a quest√£o da divis√£o e TI</a></li>
<li><a href="../pt430734/index.html">Atualiza√ß√µes inteligentes x contratos inteligentes</a></li>
<li><a href="../pt430738/index.html">Seja um ninja de seguran√ßa: n√≠vel secreto</a></li>
<li><a href="../pt430740/index.html">Como ordenhar vacas com rob√¥s e criar uma startup industrial nela. Hist√≥rico de Desenvolvimento do R-SEPT</a></li>
<li><a href="../pt430742/index.html">Olimp√≠ada Estudantil "Sou Profissional": dire√ß√£o "Programa√ß√£o e Tecnologia da Informa√ß√£o"</a></li>
<li><a href="../pt430746/index.html">Por que as baterias Tesla n√£o funcionam no t√°xi a√©reo</a></li>
<li><a href="../pt430748/index.html">A luta por recursos, parte 6: cpuset ou compartilhamento nem sempre est√° certa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>