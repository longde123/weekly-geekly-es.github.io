<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçü§ù‚Äçüë®üèª ü§¶üèº üòº Meta Crush Saga: juego en tiempo de compilaci√≥n üòò üíî üôéüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el proceso de pasar al tan esperado t√≠tulo de Over Senior Engineer principal de C ++ , el a√±o pasado decid√≠ reescribir el juego que desarrollo dura...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meta Crush Saga: juego en tiempo de compilaci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414465/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif" alt="imagen"></div><br>  En el proceso de pasar al tan esperado t√≠tulo de <strong>Over Senior Engineer principal de C ++</strong> , el a√±o pasado decid√≠ reescribir el juego que desarrollo durante las horas de trabajo (Candy Crush Saga), utilizando la quintaesencia del C ++ moderno (C ++ 17).  Y as√≠ naci√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Meta Crush Saga</a> : un <strong>juego que se ejecuta en la etapa de compilaci√≥n</strong> .  Me inspir√≥ mucho el juego <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nibbler de</a> Matt Birner, que utiliz√≥ metaprogramaci√≥n pura en plantillas para recrear la famosa Snake con el Nokia 3310. <br><br>  ‚Äú¬øQu√© tipo de <strong>juego se est√° ejecutando en la etapa de compilaci√≥n</strong> ?‚Äù, ‚Äú¬øC√≥mo se ve?‚Äù, ‚Äú¬øQu√© funcionalidad de <strong>C ++ 17</strong> usaste en este proyecto?‚Äù, ‚Äú¬øQu√© aprendiste?‚Äù  - Preguntas similares pueden venir a su mente.  Para responderlas, tendr√°s que leer la publicaci√≥n completa o soportar tu pereza interna y ver una versi√≥n en video de la publicaci√≥n: mi informe del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">evento Meetup</a> en Estocolmo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XV1lXtB3sqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Nota: en aras de su salud mental y debido a la <em>errare humanum est</em> , en este art√≠culo se ofrecen algunos datos alternativos. <br><a name="habracut"></a><br><h2>  ¬øUn juego que se ejecuta en tiempo de compilaci√≥n? </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61c/1ab/166/61c1ab166775d7f49e32620b72abb6e4.png"></div><br>  Creo que para comprender lo que quiero decir con el "concepto" de un <strong>juego ejecutado en la etapa de compilaci√≥n</strong> , es necesario comparar el ciclo de vida de un juego con el ciclo de vida de un juego ordinario. <br><br><h3>  El ciclo de vida de un juego normal: </h3><br>  Como desarrollador habitual de juegos con una vida normal, trabajando en un trabajo normal con un nivel normal de salud mental, generalmente comienza escribiendo la <strong>l√≥gica del juego</strong> en su lenguaje favorito (¬°en C ++, por supuesto!), Y luego ejecuta el <strong>compilador</strong> para convertir esto, con demasiada frecuencia como espagueti l√≥gica en un <strong>archivo ejecutable</strong> .  Despu√©s de hacer doble clic en el <strong>archivo ejecutable</strong> (o comenzar desde la consola), el sistema operativo genera un <strong>proceso</strong> .  Este <strong>proceso</strong> ejecutar√° la <strong>l√≥gica</strong> del <strong>juego</strong> , que consiste en un <strong>ciclo de juego</strong> en el 99.42% del tiempo.  <strong>El ciclo del juego</strong> <strong>actualiza el</strong> estado del juego de acuerdo con ciertas reglas y <strong>la entrada del usuario</strong> , <strong>representa el</strong> nuevo estado calculado del juego en p√≠xeles, una y otra vez, y otra vez. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/e6c/3b2/7bce6c3b238299f98b6c16e339aa5b10.png"></div><br><h3>  El ciclo de vida de un juego que se ejecuta durante el proceso de compilaci√≥n: </h3><br>  Como sobre-ingeniero que crea su nuevo y genial juego de compilaci√≥n, todav√≠a usas tu lenguaje favorito (¬°todav√≠a C ++, por supuesto!) Para escribir la <strong>l√≥gica del juego</strong> .  Luego, como antes, <strong>la fase de compilaci√≥n</strong> contin√∫a, pero hay un giro en la trama: <strong>ejecutas</strong> la <strong>l√≥gica del juego</strong> en la etapa de compilaci√≥n.  Puede llamarlo "ejecuci√≥n" (compilaci√≥n).  Y aqu√≠ C ++ es muy √∫til;  Tiene caracter√≠sticas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Template Meta Programming (TMP)</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">constexpr</a> que le permiten realizar <strong>c√°lculos</strong> en la <strong>fase de compilaci√≥n</strong> .  M√°s adelante consideraremos la funcionalidad que se puede usar para esto.  Como en esta etapa ejecutamos la <strong>l√≥gica del</strong> juego, en este momento tambi√©n necesitamos insertar la <strong>entrada del jugador</strong> .  Obviamente, nuestro compilador seguir√° creando un <strong>archivo ejecutable</strong> en la salida.  ¬øPara qu√© se puede usar?  El archivo ejecutable ya no contendr√° <strong>el ciclo del juego</strong> , pero tiene una misi√≥n muy simple: mostrar un nuevo <strong>estado calculado</strong> .  Llamemos a este <strong>archivo ejecutable el</strong> <strong>procesador</strong> y se <strong>procesan</strong> <strong>los datos que</strong> <strong>representa</strong> .  En nuestra <strong>representaci√≥n,</strong> no se contendr√°n ni los hermosos efectos de part√≠culas ni las sombras de oclusi√≥n ambiental, ser√°n ASCII.  La <strong>representaci√≥n</strong> ASCII <strong>del</strong> nuevo <strong>estado</strong> calculado es una propiedad conveniente que se puede demostrar f√°cilmente al jugador, pero adem√°s, la copiamos a un archivo de texto.  ¬øPor qu√© un archivo de texto?  Obviamente, porque de alguna manera se puede combinar con el <strong>c√≥digo</strong> y volver a realizar todos los pasos anteriores, obteniendo as√≠ un <strong>bucle</strong> . <br><br>  Como ya puedes entender, el juego <strong>ejecutado durante el proceso de compilaci√≥n</strong> consiste en un <strong>ciclo de juego</strong> en el que cada <strong>cuadro del</strong> juego es una <strong>etapa de compilaci√≥n</strong> .  Cada <strong>etapa de compilaci√≥n</strong> calcula un nuevo <strong>estado del</strong> juego, que puede mostrarse al jugador e insertarse en el siguiente <strong>cuadro</strong> / <strong>etapa de compilaci√≥n</strong> . <br><br>  Puedes contemplar este magn√≠fico diagrama tanto como quieras hasta que entiendas lo que acabo de escribir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/2b8/d88/95c2b8d88aa04173139e82f9b4410cd9.png"></div><br>  Antes de entrar en detalles sobre la implementaci√≥n de dicho ciclo, estoy seguro de que quieres hacerme la √∫nica pregunta ... <br><br><h3>  "¬øPor qu√© molestarse en hacer esto?" </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/695/1db/ec8/6951dbec8feeb002a132f801ea6866ed.png"></div><br>  ¬øRealmente crees que arruinar mi idilio de metaprogramaci√≥n C ++ es una pregunta tan fundamental?  S√≠, por nada en la vida! <br><br><ul><li>  Lo primero y m√°s importante es <strong>que el juego ejecutado en la etapa de compilaci√≥n</strong> tendr√° una incre√≠ble velocidad de tiempo de ejecuci√≥n, porque la mayor parte de los c√°lculos se realizan en la <strong>fase de compilaci√≥n</strong> .  ¬°La velocidad de ejecuci√≥n es la clave del √©xito de nuestro juego AAA con gr√°ficos ASCII! </li><li>  Reduce la probabilidad de que aparezcan crust√°ceos en su repositorio y le pide que vuelva a escribir el juego en <strong>Rust</strong> .  Su discurso bien preparado se desmoronar√° tan pronto como le explique que no puede existir un puntero inv√°lido en el momento de la compilaci√≥n.  <strong>Los</strong> programadores seguros <strong>de</strong> s√≠ mismos <strong>de Haskell</strong> pueden incluso confirmar la <strong>seguridad de tipo</strong> en su c√≥digo. </li><li>  Ganar√° el respeto del reino hipster de <strong>Javascript</strong> , en el que cualquier marco redise√±ado con un s√≠ndrome NIH fuerte puede gobernar, siempre que tenga un nombre genial. </li><li>  Un amigo m√≠o sol√≠a decir que cualquier l√≠nea de c√≥digo Perl puede usarse de facto como una contrase√±a muy segura.  Estoy seguro de que nunca intent√≥ generar contrase√±as a partir del <strong>tiempo de compilaci√≥n</strong> de <strong>C ++</strong> . </li></ul><br>  Como?  ¬øEst√°s satisfecho con mis respuestas?  Entonces, tal vez tu pregunta deber√≠a ser: "¬øC√≥mo logras hacer esto?" <br><br>  En realidad, realmente quer√≠a experimentar con la funcionalidad agregada en <strong>C ++ 17</strong> .  Se pretende que algunas caracter√≠sticas aumenten la efectividad del lenguaje, as√≠ como para la metaprogramaci√≥n (principalmente constexpr).  Pens√© que en lugar de escribir ejemplos de c√≥digo peque√±o ser√≠a mucho m√°s interesante convertir todo esto en un juego.  Los proyectos de mascotas son una excelente manera de aprender conceptos que a menudo no tienes que usar en tu trabajo.  La capacidad de ejecutar la l√≥gica b√°sica del juego en tiempo de compilaci√≥n demuestra nuevamente que las plantillas y constepxr son subconjuntos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">completos de Turing</a> del lenguaje C ++. <br><br><h2>  Rese√±a del juego Meta Crush Saga </h2><br><h3>  Juego de combinar 3: </h3><br>  <strong>Meta Crush Saga</strong> es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">juego de uni√≥n de fichas</a> similar a <strong>Bejeweled</strong> y <strong>Candy Crush Saga</strong> .  El n√∫cleo de las reglas del juego es conectar tres fichas con el mismo patr√≥n para obtener puntos.  Aqu√≠ hay un vistazo r√°pido al <strong>estado del juego</strong> que "abandon√©" (descargar ASCII es bastante f√°cil de obtener): <br><br><pre>  R "(
     Saga Meta Crush      
 ------------------------  
 El |  El | 
 El |  RBGBBYGR | 
 El |  El | 
 El |  El | 
 El |  YYGRBGBR | 
 El |  El | 
 El |  El | 
 El |  RBYRGRYG | 
 El |  El | 
 El |  El | 
 El |  RYBY (R) YGY | 
 El |  El | 
 El |  El | 
 El |  BGYRYGGR | 
 El |  El | 
 El |  El | 
 El |  RYBGYBBG | 
 El |  El | 
 ------------------------  
 &gt; puntuaci√≥n: 9009
 &gt; movimientos: 27
 ) " </pre><br><br>  La jugabilidad de este juego Match-3 en s√≠ no es particularmente interesante, pero ¬øqu√© pasa con la arquitectura en la que todo funciona?  Para que lo entiendas, intentar√© explicarte cada parte del ciclo de vida de este juego en <strong>tiempo de compilaci√≥n</strong> en t√©rminos de c√≥digo. <br><br><h3>  Inyecci√≥n del estado del juego: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/20f/ffa/94220fffabe5eca432d47b90491fe7e7.png"></div><br>  Si eres un apasionado de C ++ amante o pedante, es posible que hayas notado que el volcado de estado del juego anterior comienza con el siguiente patr√≥n: <strong>R "(</strong> . De hecho, este es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">literal de cadena C ++ 11 sin formato</a> , lo que significa que no necesito escapar de caracteres especiales, por ejemplo, <strong>traducci√≥n cadenas</strong> : el literal de cadena sin procesar se almacena en un archivo llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">current_state.txt</a> . <br><br>  ¬øC√≥mo inyectamos este estado actual del juego en un estado de compilaci√≥n?  ¬°A√±√°dalo a las entradas de bucle! <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr KeyboardInput keyboard_input = KeyboardInput::KEYBOARD_INPUT; //       constexpr auto get_game_state_string = []() constexpr { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br>  Ya sea que se trate de un archivo <em>.txt</em> o un archivo <em>.h</em> , la directiva de <strong>inclusi√≥n</strong> del preprocesador C funcionar√° de la misma manera: copia el contenido del archivo en su ubicaci√≥n.  Aqu√≠ copio el literal de cadena sin procesar del estado del juego en ascii a una variable llamada <strong>game_state_string</strong> . <br><br>  Tenga en cuenta que el <a href="">archivo de</a> encabezado <a href="">loop_inputs.hpp</a> tambi√©n expande la entrada del teclado al paso de compilaci√≥n / marco actual.  A diferencia del estado del juego, el estado del teclado es bastante peque√±o y puede obtenerse f√°cilmente como una definici√≥n de preprocesador. <br><br><h3>  Calcular un nuevo estado en tiempo de compilaci√≥n: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/adb/e44/b1aadbe44035019fdc8bdb89a02b31b1.png"></div><br>  Ahora que hemos recopilado suficientes datos, podemos calcular el nuevo estado.  Finalmente, hemos llegado al punto donde necesitamos escribir el archivo <a href="">main.cpp</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// main.cpp #include "loop_inputs.hpp" //   ,   . // :    . constexpr auto current_state = parse_game_state(get_game_state_string); //      . constexpr auto new_state = game_engine(current_state) //    , .update(keyboard_input); //  ,    . constexpr auto array = print_game_state(new_state); //      std::array&lt;char&gt;. // :    . //  :   . for (const char&amp; c : array) { std::cout &lt;&lt; c; }</span></span></code> </pre> <br>  Es extra√±o, pero este c√≥digo C ++ no parece tan confuso teniendo en cuenta lo que hace.  La mayor parte del c√≥digo se ejecuta en la fase de compilaci√≥n, sin embargo, sigue los paradigmas tradicionales de programaci√≥n de procedimientos y OOP.  Solo la √∫ltima l√≠nea, la representaci√≥n, es un obst√°culo para realizar c√°lculos completos en tiempo de compilaci√≥n.  Como veremos a continuaci√≥n, lanzando un poco de constexpr en los lugares correctos, podemos obtener una metaprogramaci√≥n bastante elegante en C ++ 17.  Me encanta la libertad que C ++ nos da cuando se trata de ejecuci√≥n mixta en tiempo de ejecuci√≥n y compilaci√≥n. <br><br>  Tambi√©n notar√° que este c√≥digo ejecuta solo un cuadro, no hay <strong>bucle de juego</strong> .  ¬°Resolvamos este problema! <br><br><h3>  Pegamos todo junto: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d0/c65/870/8d0c65870264bfff26fde91c230bb8db.png"></div><br>  Si disgusta mis trucos con <strong>C ++</strong> , espero que no le importe ver mis habilidades de <strong>Bash</strong> .  De hecho, mi <strong>ciclo de juego</strong> no es m√°s que un <a href="">script bash</a> que se compila constantemente. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  !  ,    !!! while; do : #      G++ g++ -o renderer main.cpp -DKEYBOARD_INPUT="$keypressed" keypressed=get_key_pressed() #  . clear #   current_state=$(./renderer) echo $current_state #    #     current_state.txt file       . echo "R\"(" &gt; current_state.txt echo $current_state &gt;&gt; current_state.txt echo ")\"" &gt;&gt; current_state.txt done</span></span></code> </pre> <br>  De hecho, estaba teniendo problemas para obtener la entrada del teclado desde la consola.  Inicialmente, quer√≠a ponerme en paralelo con la compilaci√≥n.  Despu√©s de muchas pruebas y errores, logr√© que algo funcionara m√°s o menos con el comando de <code>read</code> de <strong>Bash</strong> .  Nunca me atrevo a luchar contra el mago <strong>Bash</strong> en un duelo: ¬°este lenguaje es demasiado siniestro! <br><br>  Entonces, debo admitir que para administrar el ciclo del juego tuve que recurrir a otro idioma.  Aunque t√©cnicamente nada me impidi√≥ escribir esta parte del c√≥digo en C ++.  Adem√°s, esto no niega el hecho de que el 90% de la l√≥gica de mi juego se ejecuta dentro del equipo de compilaci√≥n de <strong>g ++</strong> , ¬°lo cual es bastante sorprendente! <br><br><h3>  Un peque√±o juego para que tus ojos descansen: </h3><br>  Ahora que has experimentado el tormento de explicar la arquitectura del juego, ha llegado el momento de las pinturas llamativas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif"></div><br>  Este gif pixelado es un registro de c√≥mo juego <strong>Meta Crush Saga</strong> .  Como puede ver, el juego funciona sin problemas para ser jugable en tiempo real.  Obviamente, no es tan atractiva como para que pueda transmitir su Twitch y convertirme en la nueva Pewdiepie, ¬°pero funciona! <br><br>  Uno de los aspectos divertidos de almacenar el <strong>estado de un juego</strong> en un archivo <em>.txt</em> es la capacidad de hacer trampa o probar casos extremos muy conveniente. <br><br>  Ahora que le he presentado brevemente la arquitectura, profundizaremos en la funcionalidad de C ++ 17 utilizada en este proyecto.  No considerar√© la l√≥gica del juego en detalle, porque se refiere exclusivamente a Match-3, sino que hablar√© sobre aspectos de C ++ que se pueden aplicar en otros proyectos. <br><br><h2>  Mis tutoriales sobre C ++ 17: </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3f/325/d96/c3f325d9618c2a89dadb2873c61a7921.png"></div><br>  A diferencia de C ++ 14, que principalmente conten√≠a correcciones menores, el nuevo est√°ndar C ++ 17 nos puede ofrecer mucho.  Hab√≠a esperanzas de que finalmente aparecieran las caracter√≠sticas tan esperadas (m√≥dulos, corutinas, conceptos ...), pero ... en general ... no aparecieron;  nos molest√≥ a muchos de nosotros.  Pero despu√©s de eliminar el luto, encontramos muchos peque√±os tesoros inesperados que, sin embargo, cayeron en el est√°ndar. <br><br>  ¬°Me atrevo a decir que los ni√±os que aman la metaprogramaci√≥n est√°n demasiado mimados este a√±o!  Los cambios menores y las adiciones al idioma ahora le permiten escribir c√≥digo que funciona mucho en tiempo de compilaci√≥n y despu√©s, en tiempo de ejecuci√≥n. <br><br><h3>  Constepxr en todos los campos: </h3><br>  Como Ben Dean y Jason Turner predijeron en su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe sobre C ++ 14</a> , C ++ le permite mejorar r√°pidamente la compilaci√≥n de valores en tiempo de compilaci√≥n con la palabra clave omnipotente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">constexpr</a> .  Al ubicar esta palabra clave en los lugares correctos, puede decirle al compilador que la expresi√≥n es constante y <strong>se puede</strong> evaluar directamente en tiempo de compilaci√≥n.  En <strong>C ++ 11,</strong> ya podr√≠amos escribir este c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//    constexpr       . { return n &lt;= 1? 1 : (n * factorial(n - 1)); } int i = factorial(5); //  constexpr-. //      : // int i = 120;</span></span></span></span></code> </pre> <br>  Aunque la palabra clave <strong>constexpr</strong> es muy poderosa, tiene bastantes restricciones de uso, lo que dificulta escribir c√≥digo expresivo de esta manera. <br><br>  <strong>C ++ 14 ha</strong> reducido en gran medida los requisitos para <strong>constexpr</strong> y se ha vuelto mucho m√°s natural de usar.  Nuestra funci√≥n factorial anterior se puede reescribir de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  <strong>C ++ 14</strong> <strong>elimin√≥</strong> la regla de que una <strong>funci√≥n constexpr</strong> deber√≠a consistir en una sola declaraci√≥n de retorno, lo que nos oblig√≥ a usar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">operador ternario</a> como el bloque de construcci√≥n principal.  ¬°Ahora <strong>C ++ 17</strong> trae a√∫n m√°s aplicaciones de palabras clave <strong>constexpr</strong> que podemos explorar! <br><br><h4>  Ramificaci√≥n en tiempo de compilaci√≥n: </h4><br>  ¬øAlguna vez ha estado en una situaci√≥n en la que necesita obtener un comportamiento diferente seg√∫n el par√°metro de plantilla que est√© manipulando?  Supongamos que necesitamos una funci√≥n parametrizada <code>serialize</code> , que llamar√° a <code>.serialize()</code> si el objeto lo proporciona, de lo contrario, recurrir√° a llamar a <code>to_string</code> para ello.  Como se explica con m√°s detalle en esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n sobre SFINAE</a> , lo m√°s probable es que tenga que escribir un c√≥digo extraterrestre: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.serialize(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(obj); }</code> </pre> <br>  Solo en un sue√±o podr√≠as reescribir este feo <strong>truco del truco de SFINAE</strong> a <strong>C ++ 14</strong> en un c√≥digo tan magn√≠fico: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize -  constexpr-,  serialize  . // .    SFINAE,  ,    . template &lt;class T&gt; constexpr bool has_serialize(const T&amp; /*t*/); template &lt;class T&gt; std::string serialize(const T&amp; obj) { //  ,  constexpr    . if (has_serialize(obj)) { return obj.serialize(); } else { return std::to_string(obj); } }</span></span></code> </pre> <br>  Desafortunadamente, cuando despert√≥ y comenz√≥ a escribir <strong>c√≥digo C ++ 14</strong> real, su compilador arroj√≥ un mensaje desagradable acerca de llamar a <code>serialize(42);</code>  .  Explic√≥ que un <code>obj</code> tipo <code>int</code> no tiene una funci√≥n miembro <code>serialize()</code> .  No importa c√≥mo te enfurezca, ¬°el compilador tiene raz√≥n!  Con este c√≥digo, siempre intentar√° compilar ambas ramas: <code>return obj.serialize();</code>  y <br> <code>return std::to_string(obj);</code>  .  Para <code>int</code> branch <code>return obj.serialize();</code>  Puede resultar ser alg√∫n tipo de c√≥digo muerto, porque <code>has_serialize(obj)</code> siempre devolver√° <code>false</code> , pero el compilador a√∫n tendr√° que compilarlo. <br><br>  Como probablemente haya adivinado, <strong>C ++ 17</strong> nos salva de una situaci√≥n tan desagradable, porque permiti√≥ agregar <strong>constexpr</strong> despu√©s de la declaraci√≥n if para "forzar" la ramificaci√≥n en el momento de la compilaci√≥n y descartar las construcciones no utilizadas: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize... // ... template &lt;class T&gt; std::string serialize(const T&amp; obj) if constexpr (has_serialize(obj)) { //     constexpr   'if'. return obj.serialize(); //    ,    ,  obj  int. } else { return std::to_string(obj);branch } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/ae3/4d8/6deae34d807b14eb8ac178647abce09d.png"></div><br>  Obviamente, esta es una gran mejora <strong>sobre el truco de SFINAE</strong> que tuvimos que aplicar antes.  Despu√©s de eso, comenzamos a tener la misma adicci√≥n que Ben y Jason: comenzamos a usar <strong>constexpr en</strong> todas partes y siempre.  Por desgracia, hay otro lugar donde la palabra clave <strong>constexpr</strong> encajar√≠a, pero a√∫n no se usa: <strong>par√°metros constexpr</strong> . <br><br><h4>  Par√°metros Constexpr: </h4><br>  Si tiene cuidado, puede notar un patr√≥n extra√±o en el ejemplo de c√≥digo anterior.  Estoy hablando de entradas de bucle: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr auto get_game_state_string = []() constexpr // ? { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br>  ¬øPor qu√© la variable <strong>game_state_string est√°</strong> encapsulada en una constexpr lambda?  ¬øPor qu√© no la convierte en una <strong>variable global constexpr</strong> ? <br><br>  Quer√≠a pasar esta variable y su contenido a algunas funciones.  Por ejemplo, debe pasarlo a mi <strong>parse_board</strong> y usarlo en algunas expresiones constantes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;GemType, parse_board_size(game_state_string)&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^ 'game_state_string' -   - // ... } parse_board(‚Äú...something...‚Äù);</span></span></code> </pre> <br>  Si seguimos este camino, el compilador <strong>gru√±√≥n</strong> se quejar√° de que el par√°metro <strong>game_state_string</strong> no <strong>es</strong> una expresi√≥n constante.  Cuando creo mi matriz de mosaico, necesito calcular directamente su capacidad fija (no podemos usar vectores en tiempo de compilaci√≥n porque requieren asignaci√≥n de memoria) y pasarla como un argumento a la plantilla de valor en <strong>std :: array</strong> .  Por lo tanto, la <strong>expresi√≥n parse_board_size (game_state_string)</strong> debe ser una expresi√≥n constante.  Aunque <strong>parse_board_size est√°</strong> expl√≠citamente marcado como <strong>constexpr</strong> , <strong>game_state_string</strong> no es ni puede serlo.  En este caso, dos reglas interfieren con nosotros: <br><br><ul><li>  ¬°Los argumentos de una funci√≥n constexpr no son constexpr! </li><li>  ¬°Y no podemos agregar constexpr delante de ellos! </li></ul><br>  Todo esto se reduce al hecho de que <strong>las funciones constexpr</strong> DEBEN ser aplicables para calcular tanto el tiempo de ejecuci√≥n como el tiempo de compilaci√≥n.  Suponiendo la existencia de <strong>par√°metros constexpr</strong> , esto no permitir√° que se usen en tiempo de ejecuci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/9a7/1be/02f9a71be0409a96415fd5b4a542e70d.jpg"></div><br>  Afortunadamente, hay una manera de nivelar este problema.  En lugar de aceptar el valor como un par√°metro regular de una funci√≥n, podemos encapsular este valor en un tipo y pasar este tipo como un par√°metro de plantilla: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&amp;&amp;) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(GameStringType::value())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ... } struct GameString { static constexpr auto value() { return "...something..."; } }; parse_board(GameString{});</span></span></code> </pre> <br>  En este ejemplo de c√≥digo, estoy creando un tipo estructural <strong>GameString</strong> que tiene una funci√≥n miembro est√°tica constexpr <strong>value ()</strong> que devuelve el literal de cadena que quiero pasar a <strong>parse_board</strong> .  En <strong>parse_board,</strong> obtengo este tipo a trav√©s del <strong>par√°metro de</strong> plantilla <strong>GameStringType</strong> , usando las reglas para extraer argumentos de plantilla.  Teniendo un <strong>GameStringType</strong> , debido al hecho de que <strong>value ()</strong> es constexpr, simplemente puedo llamar al <strong>valor de</strong> funci√≥n miembro est√°tico <strong>()</strong> en el momento adecuado para obtener un literal de cadena incluso en lugares donde se necesitan expresiones constantes. <br><br>  Logramos encapsular el literal para pasarlo de alguna manera a <strong>parse_board</strong> usando constexpr.  Sin embargo, es muy molesto necesitar definir un nuevo tipo cada vez que necesita enviar un nuevo literal <strong>parse_board</strong> : "... something1 ...", "... something2 ...".  Para resolver este problema en <strong>C ++ 11</strong> , podr√≠a aplicar algunas direcciones macro e indirectas feas usando uni√≥n an√≥nima y lambda.  Michael Park explic√≥ bien este tema en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una de sus publicaciones</a> . <br><br>  En <strong>C ++ 17, la</strong> situaci√≥n es a√∫n mejor.  Si enumeramos los requisitos para pasar nuestro literal de cadena, obtenemos lo siguiente: <br><br><ul><li>  Funci√≥n generada </li><li>  Eso es constexpr </li><li>  Con un nombre √∫nico o an√≥nimo </li></ul><br>  Estos requisitos deber√≠an darle una pista.  ¬°Lo que necesitamos es <strong>constexpr lambda</strong> !  Y en <strong>C ++ 17,</strong> agregaron completamente la capacidad de usar la <strong>palabra clave constexpr</strong> para las funciones lambda.  Podemos reescribir nuestro c√≥digo de muestra de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_game_state_string</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(get_game_state_string())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^      constexpr-. } parse_board([]() constexpr -&gt; { return ‚Äú...something...‚Äù; }); // ^    constexpr.</span></span></code> </pre> <br>  Cr√©ame, esto ya parece mucho m√°s conveniente que la pirater√≠a anterior en <strong>C ++ 11</strong> usando macros.  Descubr√≠ este incre√≠ble truco gracias a <strong>Bjorn Fahler</strong> , miembro del grupo m ++ de C ++ en el que participo.  Lea m√°s sobre este truco en su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blog</a> .  Tambi√©n vale la pena considerar que, de hecho, la palabra clave <strong>constexpr</strong> es opcional en este caso: todas las <strong>lambdas</strong> con la capacidad de convertirse en <strong>constexpr</strong> ser√°n por defecto.  <strong>Agregar</strong> expl√≠citamente <strong>constexpr</strong> es una firma que simplifica nuestra soluci√≥n de problemas. <br><br>  Ahora debes entender por qu√© me obligaron a usar una <strong>constexpr</strong> lambda para pasar una cadena que representa el estado del juego.  Mire esta funci√≥n lambda y nuevamente tendr√° otra pregunta.  ¬øQu√© es este tipo <strong>constexpr_string</strong> que tambi√©n uso para ajustar el literal de stock? <br><br><h5>  constexpr_string y constexpr_string_view: </h5><br>  Cuando trabaje con cadenas, no debe procesarlas en el estilo C. ¬°Debe olvidar todos estos algoritmos molestos que realizan iteraciones sin procesar y verificar que no se completen!  La alternativa que ofrece <strong>C ++</strong> son los <strong>algoritmos</strong> omnipotentes <strong>std :: string</strong> y <strong>STL</strong> .  Desafortunadamente, <strong>std :: string</strong> puede requerir asignaci√≥n de memoria en el mont√≥n (incluso con Small String Optimization) para almacenar su contenido.  Una o dos normas anteriores, podr√≠amos usar <strong>constexpr new / delete</strong> o podr√≠amos pasar los <strong>asignadores constexpr</strong> a <strong>std :: string</strong> , pero ahora necesitamos encontrar otra soluci√≥n. <br><br>  Mi enfoque era escribir una clase <strong>constexpr_string</strong> con una capacidad fija.  Esta capacidad se pasa como un par√°metro a la plantilla de valor.  Aqu√≠ hay una breve descripci√≥n de mi clase: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { private: std::array&lt;char, N&gt; data_; //  N char   -. std::size_t size_; //   . public: constexpr constexpr_string(const char(&amp;a)[N]): data_{}, size_(N -1) { //   data_ } // ... constexpr iterator begin() { return data_; } //    . constexpr iterator end() { return data_ + size_; } //     . // ... };</span></span></code> </pre> <br>  Mi clase <a href="">constexpr_string</a> busca imitar la interfaz <strong>std :: string lo</strong> m√°s cerca posible (para las operaciones que necesito): podemos solicitar <strong>iteradores del principio y el final</strong> , obtener el <strong>tama√±o (tama√±o)</strong> , acceder a los <strong>datos (datos)</strong> , <strong>eliminar (borrar)</strong> parte de ellos, obtener subcadena usando <strong>substr</strong> y as√≠ sucesivamente.  Esto <strong>hace</strong> que <strong>sea</strong> muy f√°cil convertir un fragmento de c√≥digo de <strong>std :: string</strong> a <strong>constexpr_string</strong> .  Quiz√°s se pregunte qu√© sucede cuando necesitamos usar operaciones que generalmente requieren resaltado en <strong>std :: string</strong> .  En tales casos, me vi obligado a convertirlos en <strong>operaciones inmutables</strong> que crean una nueva instancia de <strong>constexpr_string</strong> . <br><br>  Echemos un vistazo a la operaci√≥n de <strong>agregar</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { // ... template &lt;std::size_t M&gt; // M -    . constexpr auto append(const constexpr_string&lt;M&gt;&amp; other) { constexpr_string&lt;N + M&gt; output(*this, size() + other.size()); // ^    . ^     output. for (std::size_t i = 0; i &lt; other.size(); ++i) { output[size() + i] = other[i]; ^     output. } return output; } // ... };</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/481/745/1d0/4817451d03f8a4214afad8896e71b2b3.jpg"></div><br>  No es necesario tener un premio Fields para suponer que si tenemos una cadena de tama√±o <strong>N</strong> y una cadena de tama√±o <strong>M</strong> , entonces una cadena de tama√±o <strong>N + M</strong> ser√° suficiente para almacenar su concatenaci√≥n.  Podemos desperdiciar parte del "repositorio en tiempo de compilaci√≥n", ya que ambas l√≠neas pueden no usar toda la capacidad, pero este es un precio bastante peque√±o por conveniencia.  Obviamente, tambi√©n escrib√≠ un duplicado de <strong>std :: string_view</strong> , que se llama <a href="">constexpr_string_view</a> . <br><br>  Con estas dos clases, estaba listo para escribir c√≥digo elegante para analizar mi <strong>estado de juego</strong> .  Piensa en algo como esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> game_state = constexpr_string(‚Äú...something...‚Äù); <span class="hljs-comment"><span class="hljs-comment">//          : constexpr auto blue_gem = find_if(game_state.begin(), game_state.end(), [](char c) constexpr -&gt; { return c == 'B'; } );</span></span></code> </pre> <br>  Fue bastante f√°cil recorrer las joyas en el campo de juego. Por cierto, ¬ønotaste otra caracter√≠stica preciosa de <strong>C ++ 17</strong> en este ejemplo de c√≥digo? <br><br>  Si!  No tuve que especificar expl√≠citamente la capacidad de <strong>constexpr_string</strong> al construirlo.  Anteriormente, cuando se usaba una <strong>plantilla de clase</strong> , ten√≠amos que indicar expl√≠citamente sus argumentos.  Para evitar estos dolores, creamos funciones <em>make_xxx</em> porque se pueden rastrear los par√°metros <strong>de las plantillas de funciones</strong> .  Vea c√≥mo el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguimiento de los argumentos de la plantilla de clase</a> cambia nuestras vidas para mejor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr_string</span></span></span><span class="hljs-class"> {</span></span> constexpr_string(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>(&amp;a)[N]) {} <span class="hljs-comment"><span class="hljs-comment">// .. }; // ****  C++17 **** template &lt;int N&gt; constexpr_string&lt;N&gt; make_constexpr_string(const char(&amp;a)[N]) { //      N ^   return constexpr_string&lt;N&gt;(a); // ^    . } auto test2 = make_constexpr_string("blablabla"); // ^      . constexpr_string&lt;7&gt; test("blabla"); // ^      ,    . // ****  C++17 **** constexpr_string test("blabla"); // ^    ,  .</span></span></code> </pre> <br>  En algunas situaciones dif√≠ciles, deber√° ayudar al compilador a calcular correctamente los argumentos.  Si encuentra ese problema, estudie los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manuales para los c√°lculos de argumentos definidos por el usuario</a> . <br><br><h4>  Comida gratis de STL: </h4><br>  Bueno, siempre podemos reescribir todo por nuestra cuenta.  ¬øPero tal vez los miembros del comit√© han preparado generosamente algo para nosotros en la biblioteca est√°ndar? <br><br><h5>  Nuevos tipos de ayuda: </h5><br>  En <strong>C ++ 17</strong> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">std :: variant</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">std :: opcional se</a> agregan a los tipos de diccionario est√°ndar, basados ‚Äã‚Äãen <strong>constexpr</strong> .  El primero es muy interesante porque nos permite expresar asociaciones de tipo seguro, pero la implementaci√≥n en la <strong>biblioteca libstdc ++</strong> con <strong>GCC 7.2</strong> tiene problemas al usar expresiones constantes.  Por lo tanto, abandon√© la idea de agregar <strong>std :: variant</strong> a mi c√≥digo y usar solo <strong>std :: opcional</strong> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con el tipo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T, el</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tipo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: opcional</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nos permite crear un nuevo tipo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: opcional &lt;T&gt;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que puede contener un valor de tipo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o nada. Esto es bastante similar a los </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipos significativos que permiten un valor indefinido</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C #</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Veamos la funci√≥n </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_in_board</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que devuelve la posici√≥n del primer elemento en un campo que confirma que el predicado es correcto. Es posible que no haya tal elemento en el campo. Para manejar esta situaci√≥n, el tipo de posici√≥n debe ser opcional:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Predicate</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; find_in_board(GameBoard&amp;&amp; g, Predicate&amp;&amp; p) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> item : g.items()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p(item)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {item.x, item.y}; } <span class="hljs-comment"><span class="hljs-comment">//   ,     . } return std::nullopt; //      . } auto item = find_in_board(g, [](const auto&amp; item) { return true; }); if (item) { // ,   optional. do_something(*item); //    optional, ""   *. /* ... */ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente, ten√≠amos que recurrir a la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sem√°ntica de los punteros</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o agregar un "estado vac√≠o" directamente al tipo de posici√≥n, o devolver un booleano y tomar el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√°metro de salida</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . ¬°Es cierto que eso fue bastante inc√≥modo! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algunos tipos preexistentes tambi√©n recibieron soporte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tuple</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pair</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . No explicar√© en detalle su uso, porque ya se ha escrito mucho sobre ellos, pero compartir√© una de mis decepciones. El comit√© agreg√≥ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">az√∫car sint√°ctico</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al </font><font style="vertical-align: inherit;">est√°ndar </font><font style="vertical-align: inherit;">para extraer los valores contenidos en una </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tupla</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Este nuevo tipo de declaraci√≥n llamada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace estructurado</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, utiliza par√©ntesis para especificar en qu√© variables almacenar la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tupla</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dividida </font><font style="vertical-align: inherit;">o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">1337</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// x = 42, y = 1337.</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muy inteligente! </font><font style="vertical-align: inherit;">Pero es una pena que los miembros del comit√© [no pudieron, no quisieron, no encontraron el tiempo, olvidaron] hacerlos amigables con </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esperar√≠a algo como esto:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// OR auto [x, y] constexpr = foo();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora tenemos contenedores complejos y tipos de ayuda, pero ¬øc√≥mo los manipulamos convenientemente? </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritmos </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actualizar un contenedor para procesar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una tarea bastante mon√≥tona. </font><font style="vertical-align: inherit;">Comparado con esto, portar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmos no </font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">modificables</font></strong><font style="vertical-align: inherit;"> parece bastante simple. </font><font style="vertical-align: inherit;">Pero es bastante extra√±o que en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no vimos progreso en esta √°rea, solo aparecer√° en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por ejemplo, los maravillosos algoritmos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: find</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no recibieron firmas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero no tengas miedo! </font><font style="vertical-align: inherit;">Como explicaron Ben y Jason, puede convertir f√°cilmente el algoritmo en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simplemente copiando la implementaci√≥n actual (pero no se olvide de los derechos de autor); </font><font style="vertical-align: inherit;">La preferencia es buena. </font><font style="vertical-align: inherit;">Damas y caballeros, les presento a su atenci√≥n</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr std :: find</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) // ^ !!!    </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class">. {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; first != last; ++first) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*first == value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> last; } <span class="hljs-comment"><span class="hljs-comment">//  http://en.cppreference.com/w/cpp/algorithm/find</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Ya puedo escuchar desde los stands los gritos de los fan√°ticos de la optimizaci√≥n! </font><font style="vertical-align: inherit;">S√≠, solo agregar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> delante del c√≥digo de muestra proporcionado amablemente por </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cppreference</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> podr√≠a no darnos la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">velocidad</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ideal </font><strong><font style="vertical-align: inherit;">en tiempo de ejecuci√≥n</font></strong><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pero si tenemos que mejorar este algoritmo, ser√° necesario para la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">velocidad en tiempo de compilaci√≥n</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Hasta donde s√©, cuando se trata de la velocidad de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compilaci√≥n</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , las soluciones simples son las mejores.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Velocidad y errores: </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los desarrolladores de cualquier juego AAA deber√≠an invertir en resolver estos problemas, ¬øverdad? </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Velocidad: </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando logr√© crear una versi√≥n a medias de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , el trabajo fue m√°s f√°cil. De hecho, logr√© alcanzar un poco m√°s de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (cuadros por segundo) en mi vieja computadora port√°til con i5 overclockeado a 1.80 GHz (la frecuencia es importante en este caso). Como en cualquier proyecto, r√°pidamente me di cuenta de que el c√≥digo escrito anteriormente era asqueroso, y comenc√© a reescribir el an√°lisis del estado del juego usando </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr_string</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y algoritmos est√°ndar. Aunque esto hizo que el c√≥digo fuera mucho m√°s conveniente de mantener, los cambios afectaron seriamente la velocidad; El nuevo techo es de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.5 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pesar del viejo dicho sobre C ++, las "abstracciones de cabeza cero" no son aplicables a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">los c√°lculos en tiempo de compilaci√≥n</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto es bastante l√≥gico si consideramos al compilador como un int√©rprete de alg√∫n "c√≥digo de tiempo de compilaci√≥n". </font><font style="vertical-align: inherit;">Todav√≠a son posibles mejoras para varios compiladores, pero tambi√©n hay oportunidades de crecimiento para nosotros, los autores de dicho c√≥digo. </font><font style="vertical-align: inherit;">Aqu√≠ hay una lista incompleta de observaciones y consejos que encontr√©, posiblemente espec√≠ficos para GCC:</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las matrices C</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funcionan mucho mejor que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un poco de cosm√©ticos modernos de C ++ adem√°s </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de una matriz de estilo C</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y tiene que pagar un precio por usarlo en tales condiciones.</font></font></li><li>  ,  <strong> </strong>   (   )     <strong>  </strong> .  ,   ,          ,    .    :  ,         ,     ,    ,   (  )      ,        . </li><li>      ,      .        ,        . </li><li>         .            GCC.  ,     ¬´¬ª. </li></ul><br><h4> : </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78c/000/4e9/78c0004e91d753a658fa8190626c3be9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muchas veces mi compilador arroj√≥ terribles errores de compilaci√≥n, y mi l√≥gica de c√≥digo sufri√≥. Pero, ¬øc√≥mo encontrar el lugar donde se esconde el error? Sin un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depurador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf, las</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cosas se vuelven m√°s complicadas. Si su metaf√≥rica "barba del programador" a√∫n no se ha puesto de rodillas (tanto la metaf√≥rica como la verdadera barba m√≠a a√∫n est√°n lejos de estas expectativas), entonces tal vez no tenga motivaci√≥n para usar la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">luz de techo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o depurar el compilador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestro primer amigo ser√° </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lo que nos da la oportunidad de verificar el valor booleano del tiempo de compilaci√≥n. Nuestro segundo amigo ser√° una macro que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habilite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y deshabilite </font><strong><font style="vertical-align: inherit;">constexpr</font></strong><font style="vertical-align: inherit;"> siempre que sea posible:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONSTEXPR constexpr </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      //  #define CONSTEXPR //    </span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Con esta macro, podemos hacer que la l√≥gica funcione en tiempo de ejecuci√≥n, lo que significa que podemos adjuntarle un depurador. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meta Crush Saga II: lucha por el juego completamente en tiempo de ejecuci√≥n: </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no ganar√° los </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">premios The Game Awards</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> este a√±o </font><font style="vertical-align: inherit;">. Tiene un gran potencial, pero el juego no se ejecuta completamente </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en tiempo de compilaci√≥n</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto puede molestar a los jugadores hardcore ... No puedo deshacerme del script bash a menos que alguien agregue </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entrada de teclado</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y l√≥gica impura en la fase de compilaci√≥n (¬°y esto es una locura franca!). Pero creo que alg√∫n d√≠a podr√© abandonar por completo el archivo ejecutable del </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renderizador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y mostrar el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado del juego</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">momento de la compilaci√≥n</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/661/efc/26d/661efc26dbb41f0b8800916058993a56.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El loco con el alias </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saarraz </font></font></strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extendi√≥ GCC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para agregar la construcci√≥n </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_print</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al lenguaje </font><font style="vertical-align: inherit;">. Esta construcci√≥n debe tomar varias expresiones constantes o literales de cadena y generarlos en la etapa de compilaci√≥n. Me alegrar√≠a si dicha herramienta se agregara al est√°ndar, o al menos extendiera </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que </font><strong><font style="vertical-align: inherit;">aceptara</font></strong><font style="vertical-align: inherit;"> expresiones constantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede haber una forma de lograr este resultado. Los compiladores ya generan dos cosas: ¬° </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errores</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">advertencias</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! Si de alguna manera podemos gestionar o cambiar las </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">advertencias</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a nuestras necesidades, ya recibiremos una conclusi√≥n digna. Prob√© varias soluciones, en particular</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atributo en desuso</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... words&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useless</span></span></span><span class="hljs-class"> {</span></span> [[deprecated]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// Will trigger a warning. }; template &lt;char... words&gt; void output_as_warning() { useless&lt;words...&gt;().call(); } output_as_warning&lt;'a', 'b', 'c'&gt;(); // warning: 'void useless&lt;words&gt;::call() [with char ...words = {'a', 'b', 'c'}]' is deprecated // [-Wdeprecated-declarations]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque la salida obviamente est√° presente y se puede analizar, desafortunadamente, ¬°el c√≥digo no se puede reproducir! </font><font style="vertical-align: inherit;">Si, por pura coincidencia, eres miembro de una sociedad secreta de programadores de C ++ que puede realizar la producci√≥n durante la compilaci√≥n, ¬°estar√© encantado de contratarte en mi equipo para crear la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga II</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perfecta </font><font style="vertical-align: inherit;">!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusiones: </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Termin√© vendi√©ndote mi </font><font style="vertical-align: inherit;">juego de </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estafa</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Espero que encuentres esta publicaci√≥n curiosa y aprendas algo nuevo en el proceso de leerla. </font><font style="vertical-align: inherit;">Si encuentra errores o formas de mejorar el art√≠culo, cont√°cteme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quiero agradecer </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al equipo de SwedenCpp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por </font><strong><font style="vertical-align: inherit;">permitirme</font></strong><font style="vertical-align: inherit;"> realizar el informe de mi proyecto en uno de sus eventos. </font><font style="vertical-align: inherit;">Adem√°s, quiero expresar mi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">profunda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gratitud a </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Alexander Gurdeev</font></a><font style="vertical-align: inherit;"> , quien me ayud√≥ a mejorar los aspectos significativos de la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saga Meta Crush</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414465/">https://habr.com/ru/post/es414465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414451/index.html">"Calendario de pruebas" para junio. El probador debe atrapar el error, leer a Caner y organizar el movimiento.</a></li>
<li><a href="../es414453/index.html">Implemente Path Finder para agentes de IA con NavMesh</a></li>
<li><a href="../es414455/index.html">Algoritmo de generaci√≥n de paleta de colores</a></li>
<li><a href="../es414459/index.html">Detectores y descriptores de puntos singulares R√ÅPIDO, BREVE, ORB</a></li>
<li><a href="../es414463/index.html">La IA misma aprendi√≥ a construir un cubo de Rubik</a></li>
<li><a href="../es414467/index.html">Art√≠culos de la Conferencia de Minsk C ++ CoreHard Spring 2018</a></li>
<li><a href="../es414469/index.html">Semana de la seguridad 22: dos segundas cerraduras inteligentes</a></li>
<li><a href="../es414471/index.html">11 c√≠rculos del infierno para aquellos que carecen de experiencia en un nuevo trabajo</a></li>
<li><a href="../es414473/index.html">Ninja DVR: Neoline G-Tech X27 Dual review</a></li>
<li><a href="../es414475/index.html">"Usuarios finales: estamos con usted": sobre el desarrollo de Android en CFT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>