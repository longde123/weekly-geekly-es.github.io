<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏻 🤦🏼 😼 Meta Crush Saga: juego en tiempo de compilación 😘 💔 🙎🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el proceso de pasar al tan esperado título de Over Senior Engineer principal de C ++ , el año pasado decidí reescribir el juego que desarrollo dura...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meta Crush Saga: juego en tiempo de compilación</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414465/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif" alt="imagen"></div><br>  En el proceso de pasar al tan esperado título de <strong>Over Senior Engineer principal de C ++</strong> , el año pasado decidí reescribir el juego que desarrollo durante las horas de trabajo (Candy Crush Saga), utilizando la quintaesencia del C ++ moderno (C ++ 17).  Y así nació <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Meta Crush Saga</a> : un <strong>juego que se ejecuta en la etapa de compilación</strong> .  Me inspiró mucho el juego <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nibbler de</a> Matt Birner, que utilizó metaprogramación pura en plantillas para recrear la famosa Snake con el Nokia 3310. <br><br>  “¿Qué tipo de <strong>juego se está ejecutando en la etapa de compilación</strong> ?”, “¿Cómo se ve?”, “¿Qué funcionalidad de <strong>C ++ 17</strong> usaste en este proyecto?”, “¿Qué aprendiste?”  - Preguntas similares pueden venir a su mente.  Para responderlas, tendrás que leer la publicación completa o soportar tu pereza interna y ver una versión en video de la publicación: mi informe del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">evento Meetup</a> en Estocolmo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XV1lXtB3sqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Nota: en aras de su salud mental y debido a la <em>errare humanum est</em> , en este artículo se ofrecen algunos datos alternativos. <br><a name="habracut"></a><br><h2>  ¿Un juego que se ejecuta en tiempo de compilación? </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61c/1ab/166/61c1ab166775d7f49e32620b72abb6e4.png"></div><br>  Creo que para comprender lo que quiero decir con el "concepto" de un <strong>juego ejecutado en la etapa de compilación</strong> , es necesario comparar el ciclo de vida de un juego con el ciclo de vida de un juego ordinario. <br><br><h3>  El ciclo de vida de un juego normal: </h3><br>  Como desarrollador habitual de juegos con una vida normal, trabajando en un trabajo normal con un nivel normal de salud mental, generalmente comienza escribiendo la <strong>lógica del juego</strong> en su lenguaje favorito (¡en C ++, por supuesto!), Y luego ejecuta el <strong>compilador</strong> para convertir esto, con demasiada frecuencia como espagueti lógica en un <strong>archivo ejecutable</strong> .  Después de hacer doble clic en el <strong>archivo ejecutable</strong> (o comenzar desde la consola), el sistema operativo genera un <strong>proceso</strong> .  Este <strong>proceso</strong> ejecutará la <strong>lógica</strong> del <strong>juego</strong> , que consiste en un <strong>ciclo de juego</strong> en el 99.42% del tiempo.  <strong>El ciclo del juego</strong> <strong>actualiza el</strong> estado del juego de acuerdo con ciertas reglas y <strong>la entrada del usuario</strong> , <strong>representa el</strong> nuevo estado calculado del juego en píxeles, una y otra vez, y otra vez. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/e6c/3b2/7bce6c3b238299f98b6c16e339aa5b10.png"></div><br><h3>  El ciclo de vida de un juego que se ejecuta durante el proceso de compilación: </h3><br>  Como sobre-ingeniero que crea su nuevo y genial juego de compilación, todavía usas tu lenguaje favorito (¡todavía C ++, por supuesto!) Para escribir la <strong>lógica del juego</strong> .  Luego, como antes, <strong>la fase de compilación</strong> continúa, pero hay un giro en la trama: <strong>ejecutas</strong> la <strong>lógica del juego</strong> en la etapa de compilación.  Puede llamarlo "ejecución" (compilación).  Y aquí C ++ es muy útil;  Tiene características como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Template Meta Programming (TMP)</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">constexpr</a> que le permiten realizar <strong>cálculos</strong> en la <strong>fase de compilación</strong> .  Más adelante consideraremos la funcionalidad que se puede usar para esto.  Como en esta etapa ejecutamos la <strong>lógica del</strong> juego, en este momento también necesitamos insertar la <strong>entrada del jugador</strong> .  Obviamente, nuestro compilador seguirá creando un <strong>archivo ejecutable</strong> en la salida.  ¿Para qué se puede usar?  El archivo ejecutable ya no contendrá <strong>el ciclo del juego</strong> , pero tiene una misión muy simple: mostrar un nuevo <strong>estado calculado</strong> .  Llamemos a este <strong>archivo ejecutable el</strong> <strong>procesador</strong> y se <strong>procesan</strong> <strong>los datos que</strong> <strong>representa</strong> .  En nuestra <strong>representación,</strong> no se contendrán ni los hermosos efectos de partículas ni las sombras de oclusión ambiental, serán ASCII.  La <strong>representación</strong> ASCII <strong>del</strong> nuevo <strong>estado</strong> calculado es una propiedad conveniente que se puede demostrar fácilmente al jugador, pero además, la copiamos a un archivo de texto.  ¿Por qué un archivo de texto?  Obviamente, porque de alguna manera se puede combinar con el <strong>código</strong> y volver a realizar todos los pasos anteriores, obteniendo así un <strong>bucle</strong> . <br><br>  Como ya puedes entender, el juego <strong>ejecutado durante el proceso de compilación</strong> consiste en un <strong>ciclo de juego</strong> en el que cada <strong>cuadro del</strong> juego es una <strong>etapa de compilación</strong> .  Cada <strong>etapa de compilación</strong> calcula un nuevo <strong>estado del</strong> juego, que puede mostrarse al jugador e insertarse en el siguiente <strong>cuadro</strong> / <strong>etapa de compilación</strong> . <br><br>  Puedes contemplar este magnífico diagrama tanto como quieras hasta que entiendas lo que acabo de escribir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/2b8/d88/95c2b8d88aa04173139e82f9b4410cd9.png"></div><br>  Antes de entrar en detalles sobre la implementación de dicho ciclo, estoy seguro de que quieres hacerme la única pregunta ... <br><br><h3>  "¿Por qué molestarse en hacer esto?" </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/695/1db/ec8/6951dbec8feeb002a132f801ea6866ed.png"></div><br>  ¿Realmente crees que arruinar mi idilio de metaprogramación C ++ es una pregunta tan fundamental?  Sí, por nada en la vida! <br><br><ul><li>  Lo primero y más importante es <strong>que el juego ejecutado en la etapa de compilación</strong> tendrá una increíble velocidad de tiempo de ejecución, porque la mayor parte de los cálculos se realizan en la <strong>fase de compilación</strong> .  ¡La velocidad de ejecución es la clave del éxito de nuestro juego AAA con gráficos ASCII! </li><li>  Reduce la probabilidad de que aparezcan crustáceos en su repositorio y le pide que vuelva a escribir el juego en <strong>Rust</strong> .  Su discurso bien preparado se desmoronará tan pronto como le explique que no puede existir un puntero inválido en el momento de la compilación.  <strong>Los</strong> programadores seguros <strong>de</strong> sí mismos <strong>de Haskell</strong> pueden incluso confirmar la <strong>seguridad de tipo</strong> en su código. </li><li>  Ganará el respeto del reino hipster de <strong>Javascript</strong> , en el que cualquier marco rediseñado con un síndrome NIH fuerte puede gobernar, siempre que tenga un nombre genial. </li><li>  Un amigo mío solía decir que cualquier línea de código Perl puede usarse de facto como una contraseña muy segura.  Estoy seguro de que nunca intentó generar contraseñas a partir del <strong>tiempo de compilación</strong> de <strong>C ++</strong> . </li></ul><br>  Como?  ¿Estás satisfecho con mis respuestas?  Entonces, tal vez tu pregunta debería ser: "¿Cómo logras hacer esto?" <br><br>  En realidad, realmente quería experimentar con la funcionalidad agregada en <strong>C ++ 17</strong> .  Se pretende que algunas características aumenten la efectividad del lenguaje, así como para la metaprogramación (principalmente constexpr).  Pensé que en lugar de escribir ejemplos de código pequeño sería mucho más interesante convertir todo esto en un juego.  Los proyectos de mascotas son una excelente manera de aprender conceptos que a menudo no tienes que usar en tu trabajo.  La capacidad de ejecutar la lógica básica del juego en tiempo de compilación demuestra nuevamente que las plantillas y constepxr son subconjuntos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">completos de Turing</a> del lenguaje C ++. <br><br><h2>  Reseña del juego Meta Crush Saga </h2><br><h3>  Juego de combinar 3: </h3><br>  <strong>Meta Crush Saga</strong> es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">juego de unión de fichas</a> similar a <strong>Bejeweled</strong> y <strong>Candy Crush Saga</strong> .  El núcleo de las reglas del juego es conectar tres fichas con el mismo patrón para obtener puntos.  Aquí hay un vistazo rápido al <strong>estado del juego</strong> que "abandoné" (descargar ASCII es bastante fácil de obtener): <br><br><pre>  R "(
     Saga Meta Crush      
 ------------------------  
 El |  El | 
 El |  RBGBBYGR | 
 El |  El | 
 El |  El | 
 El |  YYGRBGBR | 
 El |  El | 
 El |  El | 
 El |  RBYRGRYG | 
 El |  El | 
 El |  El | 
 El |  RYBY (R) YGY | 
 El |  El | 
 El |  El | 
 El |  BGYRYGGR | 
 El |  El | 
 El |  El | 
 El |  RYBGYBBG | 
 El |  El | 
 ------------------------  
 &gt; puntuación: 9009
 &gt; movimientos: 27
 ) " </pre><br><br>  La jugabilidad de este juego Match-3 en sí no es particularmente interesante, pero ¿qué pasa con la arquitectura en la que todo funciona?  Para que lo entiendas, intentaré explicarte cada parte del ciclo de vida de este juego en <strong>tiempo de compilación</strong> en términos de código. <br><br><h3>  Inyección del estado del juego: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/20f/ffa/94220fffabe5eca432d47b90491fe7e7.png"></div><br>  Si eres un apasionado de C ++ amante o pedante, es posible que hayas notado que el volcado de estado del juego anterior comienza con el siguiente patrón: <strong>R "(</strong> . De hecho, este es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">literal de cadena C ++ 11 sin formato</a> , lo que significa que no necesito escapar de caracteres especiales, por ejemplo, <strong>traducción cadenas</strong> : el literal de cadena sin procesar se almacena en un archivo llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">current_state.txt</a> . <br><br>  ¿Cómo inyectamos este estado actual del juego en un estado de compilación?  ¡Añádalo a las entradas de bucle! <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr KeyboardInput keyboard_input = KeyboardInput::KEYBOARD_INPUT; //       constexpr auto get_game_state_string = []() constexpr { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br>  Ya sea que se trate de un archivo <em>.txt</em> o un archivo <em>.h</em> , la directiva de <strong>inclusión</strong> del preprocesador C funcionará de la misma manera: copia el contenido del archivo en su ubicación.  Aquí copio el literal de cadena sin procesar del estado del juego en ascii a una variable llamada <strong>game_state_string</strong> . <br><br>  Tenga en cuenta que el <a href="">archivo de</a> encabezado <a href="">loop_inputs.hpp</a> también expande la entrada del teclado al paso de compilación / marco actual.  A diferencia del estado del juego, el estado del teclado es bastante pequeño y puede obtenerse fácilmente como una definición de preprocesador. <br><br><h3>  Calcular un nuevo estado en tiempo de compilación: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/adb/e44/b1aadbe44035019fdc8bdb89a02b31b1.png"></div><br>  Ahora que hemos recopilado suficientes datos, podemos calcular el nuevo estado.  Finalmente, hemos llegado al punto donde necesitamos escribir el archivo <a href="">main.cpp</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// main.cpp #include "loop_inputs.hpp" //   ,   . // :    . constexpr auto current_state = parse_game_state(get_game_state_string); //      . constexpr auto new_state = game_engine(current_state) //    , .update(keyboard_input); //  ,    . constexpr auto array = print_game_state(new_state); //      std::array&lt;char&gt;. // :    . //  :   . for (const char&amp; c : array) { std::cout &lt;&lt; c; }</span></span></code> </pre> <br>  Es extraño, pero este código C ++ no parece tan confuso teniendo en cuenta lo que hace.  La mayor parte del código se ejecuta en la fase de compilación, sin embargo, sigue los paradigmas tradicionales de programación de procedimientos y OOP.  Solo la última línea, la representación, es un obstáculo para realizar cálculos completos en tiempo de compilación.  Como veremos a continuación, lanzando un poco de constexpr en los lugares correctos, podemos obtener una metaprogramación bastante elegante en C ++ 17.  Me encanta la libertad que C ++ nos da cuando se trata de ejecución mixta en tiempo de ejecución y compilación. <br><br>  También notará que este código ejecuta solo un cuadro, no hay <strong>bucle de juego</strong> .  ¡Resolvamos este problema! <br><br><h3>  Pegamos todo junto: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d0/c65/870/8d0c65870264bfff26fde91c230bb8db.png"></div><br>  Si disgusta mis trucos con <strong>C ++</strong> , espero que no le importe ver mis habilidades de <strong>Bash</strong> .  De hecho, mi <strong>ciclo de juego</strong> no es más que un <a href="">script bash</a> que se compila constantemente. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  !  ,    !!! while; do : #      G++ g++ -o renderer main.cpp -DKEYBOARD_INPUT="$keypressed" keypressed=get_key_pressed() #  . clear #   current_state=$(./renderer) echo $current_state #    #     current_state.txt file       . echo "R\"(" &gt; current_state.txt echo $current_state &gt;&gt; current_state.txt echo ")\"" &gt;&gt; current_state.txt done</span></span></code> </pre> <br>  De hecho, estaba teniendo problemas para obtener la entrada del teclado desde la consola.  Inicialmente, quería ponerme en paralelo con la compilación.  Después de muchas pruebas y errores, logré que algo funcionara más o menos con el comando de <code>read</code> de <strong>Bash</strong> .  Nunca me atrevo a luchar contra el mago <strong>Bash</strong> en un duelo: ¡este lenguaje es demasiado siniestro! <br><br>  Entonces, debo admitir que para administrar el ciclo del juego tuve que recurrir a otro idioma.  Aunque técnicamente nada me impidió escribir esta parte del código en C ++.  Además, esto no niega el hecho de que el 90% de la lógica de mi juego se ejecuta dentro del equipo de compilación de <strong>g ++</strong> , ¡lo cual es bastante sorprendente! <br><br><h3>  Un pequeño juego para que tus ojos descansen: </h3><br>  Ahora que has experimentado el tormento de explicar la arquitectura del juego, ha llegado el momento de las pinturas llamativas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif"></div><br>  Este gif pixelado es un registro de cómo juego <strong>Meta Crush Saga</strong> .  Como puede ver, el juego funciona sin problemas para ser jugable en tiempo real.  Obviamente, no es tan atractiva como para que pueda transmitir su Twitch y convertirme en la nueva Pewdiepie, ¡pero funciona! <br><br>  Uno de los aspectos divertidos de almacenar el <strong>estado de un juego</strong> en un archivo <em>.txt</em> es la capacidad de hacer trampa o probar casos extremos muy conveniente. <br><br>  Ahora que le he presentado brevemente la arquitectura, profundizaremos en la funcionalidad de C ++ 17 utilizada en este proyecto.  No consideraré la lógica del juego en detalle, porque se refiere exclusivamente a Match-3, sino que hablaré sobre aspectos de C ++ que se pueden aplicar en otros proyectos. <br><br><h2>  Mis tutoriales sobre C ++ 17: </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3f/325/d96/c3f325d9618c2a89dadb2873c61a7921.png"></div><br>  A diferencia de C ++ 14, que principalmente contenía correcciones menores, el nuevo estándar C ++ 17 nos puede ofrecer mucho.  Había esperanzas de que finalmente aparecieran las características tan esperadas (módulos, corutinas, conceptos ...), pero ... en general ... no aparecieron;  nos molestó a muchos de nosotros.  Pero después de eliminar el luto, encontramos muchos pequeños tesoros inesperados que, sin embargo, cayeron en el estándar. <br><br>  ¡Me atrevo a decir que los niños que aman la metaprogramación están demasiado mimados este año!  Los cambios menores y las adiciones al idioma ahora le permiten escribir código que funciona mucho en tiempo de compilación y después, en tiempo de ejecución. <br><br><h3>  Constepxr en todos los campos: </h3><br>  Como Ben Dean y Jason Turner predijeron en su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe sobre C ++ 14</a> , C ++ le permite mejorar rápidamente la compilación de valores en tiempo de compilación con la palabra clave omnipotente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">constexpr</a> .  Al ubicar esta palabra clave en los lugares correctos, puede decirle al compilador que la expresión es constante y <strong>se puede</strong> evaluar directamente en tiempo de compilación.  En <strong>C ++ 11,</strong> ya podríamos escribir este código: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//    constexpr       . { return n &lt;= 1? 1 : (n * factorial(n - 1)); } int i = factorial(5); //  constexpr-. //      : // int i = 120;</span></span></span></span></code> </pre> <br>  Aunque la palabra clave <strong>constexpr</strong> es muy poderosa, tiene bastantes restricciones de uso, lo que dificulta escribir código expresivo de esta manera. <br><br>  <strong>C ++ 14 ha</strong> reducido en gran medida los requisitos para <strong>constexpr</strong> y se ha vuelto mucho más natural de usar.  Nuestra función factorial anterior se puede reescribir de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  <strong>C ++ 14</strong> <strong>eliminó</strong> la regla de que una <strong>función constexpr</strong> debería consistir en una sola declaración de retorno, lo que nos obligó a usar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">operador ternario</a> como el bloque de construcción principal.  ¡Ahora <strong>C ++ 17</strong> trae aún más aplicaciones de palabras clave <strong>constexpr</strong> que podemos explorar! <br><br><h4>  Ramificación en tiempo de compilación: </h4><br>  ¿Alguna vez ha estado en una situación en la que necesita obtener un comportamiento diferente según el parámetro de plantilla que esté manipulando?  Supongamos que necesitamos una función parametrizada <code>serialize</code> , que llamará a <code>.serialize()</code> si el objeto lo proporciona, de lo contrario, recurrirá a llamar a <code>to_string</code> para ello.  Como se explica con más detalle en esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicación sobre SFINAE</a> , lo más probable es que tenga que escribir un código extraterrestre: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.serialize(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(obj); }</code> </pre> <br>  Solo en un sueño podrías reescribir este feo <strong>truco del truco de SFINAE</strong> a <strong>C ++ 14</strong> en un código tan magnífico: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize -  constexpr-,  serialize  . // .    SFINAE,  ,    . template &lt;class T&gt; constexpr bool has_serialize(const T&amp; /*t*/); template &lt;class T&gt; std::string serialize(const T&amp; obj) { //  ,  constexpr    . if (has_serialize(obj)) { return obj.serialize(); } else { return std::to_string(obj); } }</span></span></code> </pre> <br>  Desafortunadamente, cuando despertó y comenzó a escribir <strong>código C ++ 14</strong> real, su compilador arrojó un mensaje desagradable acerca de llamar a <code>serialize(42);</code>  .  Explicó que un <code>obj</code> tipo <code>int</code> no tiene una función miembro <code>serialize()</code> .  No importa cómo te enfurezca, ¡el compilador tiene razón!  Con este código, siempre intentará compilar ambas ramas: <code>return obj.serialize();</code>  y <br> <code>return std::to_string(obj);</code>  .  Para <code>int</code> branch <code>return obj.serialize();</code>  Puede resultar ser algún tipo de código muerto, porque <code>has_serialize(obj)</code> siempre devolverá <code>false</code> , pero el compilador aún tendrá que compilarlo. <br><br>  Como probablemente haya adivinado, <strong>C ++ 17</strong> nos salva de una situación tan desagradable, porque permitió agregar <strong>constexpr</strong> después de la declaración if para "forzar" la ramificación en el momento de la compilación y descartar las construcciones no utilizadas: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize... // ... template &lt;class T&gt; std::string serialize(const T&amp; obj) if constexpr (has_serialize(obj)) { //     constexpr   'if'. return obj.serialize(); //    ,    ,  obj  int. } else { return std::to_string(obj);branch } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/ae3/4d8/6deae34d807b14eb8ac178647abce09d.png"></div><br>  Obviamente, esta es una gran mejora <strong>sobre el truco de SFINAE</strong> que tuvimos que aplicar antes.  Después de eso, comenzamos a tener la misma adicción que Ben y Jason: comenzamos a usar <strong>constexpr en</strong> todas partes y siempre.  Por desgracia, hay otro lugar donde la palabra clave <strong>constexpr</strong> encajaría, pero aún no se usa: <strong>parámetros constexpr</strong> . <br><br><h4>  Parámetros Constexpr: </h4><br>  Si tiene cuidado, puede notar un patrón extraño en el ejemplo de código anterior.  Estoy hablando de entradas de bucle: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr auto get_game_state_string = []() constexpr // ? { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br>  ¿Por qué la variable <strong>game_state_string está</strong> encapsulada en una constexpr lambda?  ¿Por qué no la convierte en una <strong>variable global constexpr</strong> ? <br><br>  Quería pasar esta variable y su contenido a algunas funciones.  Por ejemplo, debe pasarlo a mi <strong>parse_board</strong> y usarlo en algunas expresiones constantes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;GemType, parse_board_size(game_state_string)&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^ 'game_state_string' -   - // ... } parse_board(“...something...”);</span></span></code> </pre> <br>  Si seguimos este camino, el compilador <strong>gruñón</strong> se quejará de que el parámetro <strong>game_state_string</strong> no <strong>es</strong> una expresión constante.  Cuando creo mi matriz de mosaico, necesito calcular directamente su capacidad fija (no podemos usar vectores en tiempo de compilación porque requieren asignación de memoria) y pasarla como un argumento a la plantilla de valor en <strong>std :: array</strong> .  Por lo tanto, la <strong>expresión parse_board_size (game_state_string)</strong> debe ser una expresión constante.  Aunque <strong>parse_board_size está</strong> explícitamente marcado como <strong>constexpr</strong> , <strong>game_state_string</strong> no es ni puede serlo.  En este caso, dos reglas interfieren con nosotros: <br><br><ul><li>  ¡Los argumentos de una función constexpr no son constexpr! </li><li>  ¡Y no podemos agregar constexpr delante de ellos! </li></ul><br>  Todo esto se reduce al hecho de que <strong>las funciones constexpr</strong> DEBEN ser aplicables para calcular tanto el tiempo de ejecución como el tiempo de compilación.  Suponiendo la existencia de <strong>parámetros constexpr</strong> , esto no permitirá que se usen en tiempo de ejecución. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/9a7/1be/02f9a71be0409a96415fd5b4a542e70d.jpg"></div><br>  Afortunadamente, hay una manera de nivelar este problema.  En lugar de aceptar el valor como un parámetro regular de una función, podemos encapsular este valor en un tipo y pasar este tipo como un parámetro de plantilla: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&amp;&amp;) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(GameStringType::value())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ... } struct GameString { static constexpr auto value() { return "...something..."; } }; parse_board(GameString{});</span></span></code> </pre> <br>  En este ejemplo de código, estoy creando un tipo estructural <strong>GameString</strong> que tiene una función miembro estática constexpr <strong>value ()</strong> que devuelve el literal de cadena que quiero pasar a <strong>parse_board</strong> .  En <strong>parse_board,</strong> obtengo este tipo a través del <strong>parámetro de</strong> plantilla <strong>GameStringType</strong> , usando las reglas para extraer argumentos de plantilla.  Teniendo un <strong>GameStringType</strong> , debido al hecho de que <strong>value ()</strong> es constexpr, simplemente puedo llamar al <strong>valor de</strong> función miembro estático <strong>()</strong> en el momento adecuado para obtener un literal de cadena incluso en lugares donde se necesitan expresiones constantes. <br><br>  Logramos encapsular el literal para pasarlo de alguna manera a <strong>parse_board</strong> usando constexpr.  Sin embargo, es muy molesto necesitar definir un nuevo tipo cada vez que necesita enviar un nuevo literal <strong>parse_board</strong> : "... something1 ...", "... something2 ...".  Para resolver este problema en <strong>C ++ 11</strong> , podría aplicar algunas direcciones macro e indirectas feas usando unión anónima y lambda.  Michael Park explicó bien este tema en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una de sus publicaciones</a> . <br><br>  En <strong>C ++ 17, la</strong> situación es aún mejor.  Si enumeramos los requisitos para pasar nuestro literal de cadena, obtenemos lo siguiente: <br><br><ul><li>  Función generada </li><li>  Eso es constexpr </li><li>  Con un nombre único o anónimo </li></ul><br>  Estos requisitos deberían darle una pista.  ¡Lo que necesitamos es <strong>constexpr lambda</strong> !  Y en <strong>C ++ 17,</strong> agregaron completamente la capacidad de usar la <strong>palabra clave constexpr</strong> para las funciones lambda.  Podemos reescribir nuestro código de muestra de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_game_state_string</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(get_game_state_string())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^      constexpr-. } parse_board([]() constexpr -&gt; { return “...something...”; }); // ^    constexpr.</span></span></code> </pre> <br>  Créame, esto ya parece mucho más conveniente que la piratería anterior en <strong>C ++ 11</strong> usando macros.  Descubrí este increíble truco gracias a <strong>Bjorn Fahler</strong> , miembro del grupo m ++ de C ++ en el que participo.  Lea más sobre este truco en su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blog</a> .  También vale la pena considerar que, de hecho, la palabra clave <strong>constexpr</strong> es opcional en este caso: todas las <strong>lambdas</strong> con la capacidad de convertirse en <strong>constexpr</strong> serán por defecto.  <strong>Agregar</strong> explícitamente <strong>constexpr</strong> es una firma que simplifica nuestra solución de problemas. <br><br>  Ahora debes entender por qué me obligaron a usar una <strong>constexpr</strong> lambda para pasar una cadena que representa el estado del juego.  Mire esta función lambda y nuevamente tendrá otra pregunta.  ¿Qué es este tipo <strong>constexpr_string</strong> que también uso para ajustar el literal de stock? <br><br><h5>  constexpr_string y constexpr_string_view: </h5><br>  Cuando trabaje con cadenas, no debe procesarlas en el estilo C. ¡Debe olvidar todos estos algoritmos molestos que realizan iteraciones sin procesar y verificar que no se completen!  La alternativa que ofrece <strong>C ++</strong> son los <strong>algoritmos</strong> omnipotentes <strong>std :: string</strong> y <strong>STL</strong> .  Desafortunadamente, <strong>std :: string</strong> puede requerir asignación de memoria en el montón (incluso con Small String Optimization) para almacenar su contenido.  Una o dos normas anteriores, podríamos usar <strong>constexpr new / delete</strong> o podríamos pasar los <strong>asignadores constexpr</strong> a <strong>std :: string</strong> , pero ahora necesitamos encontrar otra solución. <br><br>  Mi enfoque era escribir una clase <strong>constexpr_string</strong> con una capacidad fija.  Esta capacidad se pasa como un parámetro a la plantilla de valor.  Aquí hay una breve descripción de mi clase: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { private: std::array&lt;char, N&gt; data_; //  N char   -. std::size_t size_; //   . public: constexpr constexpr_string(const char(&amp;a)[N]): data_{}, size_(N -1) { //   data_ } // ... constexpr iterator begin() { return data_; } //    . constexpr iterator end() { return data_ + size_; } //     . // ... };</span></span></code> </pre> <br>  Mi clase <a href="">constexpr_string</a> busca imitar la interfaz <strong>std :: string lo</strong> más cerca posible (para las operaciones que necesito): podemos solicitar <strong>iteradores del principio y el final</strong> , obtener el <strong>tamaño (tamaño)</strong> , acceder a los <strong>datos (datos)</strong> , <strong>eliminar (borrar)</strong> parte de ellos, obtener subcadena usando <strong>substr</strong> y así sucesivamente.  Esto <strong>hace</strong> que <strong>sea</strong> muy fácil convertir un fragmento de código de <strong>std :: string</strong> a <strong>constexpr_string</strong> .  Quizás se pregunte qué sucede cuando necesitamos usar operaciones que generalmente requieren resaltado en <strong>std :: string</strong> .  En tales casos, me vi obligado a convertirlos en <strong>operaciones inmutables</strong> que crean una nueva instancia de <strong>constexpr_string</strong> . <br><br>  Echemos un vistazo a la operación de <strong>agregar</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { // ... template &lt;std::size_t M&gt; // M -    . constexpr auto append(const constexpr_string&lt;M&gt;&amp; other) { constexpr_string&lt;N + M&gt; output(*this, size() + other.size()); // ^    . ^     output. for (std::size_t i = 0; i &lt; other.size(); ++i) { output[size() + i] = other[i]; ^     output. } return output; } // ... };</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/481/745/1d0/4817451d03f8a4214afad8896e71b2b3.jpg"></div><br>  No es necesario tener un premio Fields para suponer que si tenemos una cadena de tamaño <strong>N</strong> y una cadena de tamaño <strong>M</strong> , entonces una cadena de tamaño <strong>N + M</strong> será suficiente para almacenar su concatenación.  Podemos desperdiciar parte del "repositorio en tiempo de compilación", ya que ambas líneas pueden no usar toda la capacidad, pero este es un precio bastante pequeño por conveniencia.  Obviamente, también escribí un duplicado de <strong>std :: string_view</strong> , que se llama <a href="">constexpr_string_view</a> . <br><br>  Con estas dos clases, estaba listo para escribir código elegante para analizar mi <strong>estado de juego</strong> .  Piensa en algo como esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> game_state = constexpr_string(“...something...”); <span class="hljs-comment"><span class="hljs-comment">//          : constexpr auto blue_gem = find_if(game_state.begin(), game_state.end(), [](char c) constexpr -&gt; { return c == 'B'; } );</span></span></code> </pre> <br>  Fue bastante fácil recorrer las joyas en el campo de juego. Por cierto, ¿notaste otra característica preciosa de <strong>C ++ 17</strong> en este ejemplo de código? <br><br>  Si!  No tuve que especificar explícitamente la capacidad de <strong>constexpr_string</strong> al construirlo.  Anteriormente, cuando se usaba una <strong>plantilla de clase</strong> , teníamos que indicar explícitamente sus argumentos.  Para evitar estos dolores, creamos funciones <em>make_xxx</em> porque se pueden rastrear los parámetros <strong>de las plantillas de funciones</strong> .  Vea cómo el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguimiento de los argumentos de la plantilla de clase</a> cambia nuestras vidas para mejor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr_string</span></span></span><span class="hljs-class"> {</span></span> constexpr_string(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>(&amp;a)[N]) {} <span class="hljs-comment"><span class="hljs-comment">// .. }; // ****  C++17 **** template &lt;int N&gt; constexpr_string&lt;N&gt; make_constexpr_string(const char(&amp;a)[N]) { //      N ^   return constexpr_string&lt;N&gt;(a); // ^    . } auto test2 = make_constexpr_string("blablabla"); // ^      . constexpr_string&lt;7&gt; test("blabla"); // ^      ,    . // ****  C++17 **** constexpr_string test("blabla"); // ^    ,  .</span></span></code> </pre> <br>  En algunas situaciones difíciles, deberá ayudar al compilador a calcular correctamente los argumentos.  Si encuentra ese problema, estudie los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manuales para los cálculos de argumentos definidos por el usuario</a> . <br><br><h4>  Comida gratis de STL: </h4><br>  Bueno, siempre podemos reescribir todo por nuestra cuenta.  ¿Pero tal vez los miembros del comité han preparado generosamente algo para nosotros en la biblioteca estándar? <br><br><h5>  Nuevos tipos de ayuda: </h5><br>  En <strong>C ++ 17</strong> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">std :: variant</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">std :: opcional se</a> agregan a los tipos de diccionario estándar, basados ​​en <strong>constexpr</strong> .  El primero es muy interesante porque nos permite expresar asociaciones de tipo seguro, pero la implementación en la <strong>biblioteca libstdc ++</strong> con <strong>GCC 7.2</strong> tiene problemas al usar expresiones constantes.  Por lo tanto, abandoné la idea de agregar <strong>std :: variant</strong> a mi código y usar solo <strong>std :: opcional</strong> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con el tipo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T, el</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tipo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: opcional</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nos permite crear un nuevo tipo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: opcional &lt;T&gt;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que puede contener un valor de tipo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o nada. Esto es bastante similar a los </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipos significativos que permiten un valor indefinido</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C #</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Veamos la función </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_in_board</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que devuelve la posición del primer elemento en un campo que confirma que el predicado es correcto. Es posible que no haya tal elemento en el campo. Para manejar esta situación, el tipo de posición debe ser opcional:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Predicate</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; find_in_board(GameBoard&amp;&amp; g, Predicate&amp;&amp; p) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> item : g.items()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p(item)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {item.x, item.y}; } <span class="hljs-comment"><span class="hljs-comment">//   ,     . } return std::nullopt; //      . } auto item = find_in_board(g, [](const auto&amp; item) { return true; }); if (item) { // ,   optional. do_something(*item); //    optional, ""   *. /* ... */ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente, teníamos que recurrir a la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semántica de los punteros</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o agregar un "estado vacío" directamente al tipo de posición, o devolver un booleano y tomar el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parámetro de salida</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . ¡Es cierto que eso fue bastante incómodo! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algunos tipos preexistentes también recibieron soporte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tuple</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pair</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . No explicaré en detalle su uso, porque ya se ha escrito mucho sobre ellos, pero compartiré una de mis decepciones. El comité agregó </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">azúcar sintáctico</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al </font><font style="vertical-align: inherit;">estándar </font><font style="vertical-align: inherit;">para extraer los valores contenidos en una </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tupla</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Este nuevo tipo de declaración llamada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace estructurado</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, utiliza paréntesis para especificar en qué variables almacenar la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tupla</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dividida </font><font style="vertical-align: inherit;">o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">1337</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// x = 42, y = 1337.</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muy inteligente! </font><font style="vertical-align: inherit;">Pero es una pena que los miembros del comité [no pudieron, no quisieron, no encontraron el tiempo, olvidaron] hacerlos amigables con </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esperaría algo como esto:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// OR auto [x, y] constexpr = foo();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora tenemos contenedores complejos y tipos de ayuda, pero ¿cómo los manipulamos convenientemente? </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritmos </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actualizar un contenedor para procesar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una tarea bastante monótona. </font><font style="vertical-align: inherit;">Comparado con esto, portar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmos no </font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">modificables</font></strong><font style="vertical-align: inherit;"> parece bastante simple. </font><font style="vertical-align: inherit;">Pero es bastante extraño que en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no vimos progreso en esta área, solo aparecerá en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por ejemplo, los maravillosos algoritmos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: find</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no recibieron firmas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero no tengas miedo! </font><font style="vertical-align: inherit;">Como explicaron Ben y Jason, puede convertir fácilmente el algoritmo en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simplemente copiando la implementación actual (pero no se olvide de los derechos de autor); </font><font style="vertical-align: inherit;">La preferencia es buena. </font><font style="vertical-align: inherit;">Damas y caballeros, les presento a su atención</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr std :: find</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) // ^ !!!    </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class">. {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; first != last; ++first) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*first == value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> last; } <span class="hljs-comment"><span class="hljs-comment">//  http://en.cppreference.com/w/cpp/algorithm/find</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Ya puedo escuchar desde los stands los gritos de los fanáticos de la optimización! </font><font style="vertical-align: inherit;">Sí, solo agregar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> delante del código de muestra proporcionado amablemente por </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cppreference</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> podría no darnos la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">velocidad</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ideal </font><strong><font style="vertical-align: inherit;">en tiempo de ejecución</font></strong><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pero si tenemos que mejorar este algoritmo, será necesario para la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">velocidad en tiempo de compilación</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Hasta donde sé, cuando se trata de la velocidad de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compilación</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , las soluciones simples son las mejores.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Velocidad y errores: </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los desarrolladores de cualquier juego AAA deberían invertir en resolver estos problemas, ¿verdad? </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Velocidad: </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando logré crear una versión a medias de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , el trabajo fue más fácil. De hecho, logré alcanzar un poco más de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (cuadros por segundo) en mi vieja computadora portátil con i5 overclockeado a 1.80 GHz (la frecuencia es importante en este caso). Como en cualquier proyecto, rápidamente me di cuenta de que el código escrito anteriormente era asqueroso, y comencé a reescribir el análisis del estado del juego usando </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr_string</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y algoritmos estándar. Aunque esto hizo que el código fuera mucho más conveniente de mantener, los cambios afectaron seriamente la velocidad; El nuevo techo es de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.5 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pesar del viejo dicho sobre C ++, las "abstracciones de cabeza cero" no son aplicables a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">los cálculos en tiempo de compilación</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto es bastante lógico si consideramos al compilador como un intérprete de algún "código de tiempo de compilación". </font><font style="vertical-align: inherit;">Todavía son posibles mejoras para varios compiladores, pero también hay oportunidades de crecimiento para nosotros, los autores de dicho código. </font><font style="vertical-align: inherit;">Aquí hay una lista incompleta de observaciones y consejos que encontré, posiblemente específicos para GCC:</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las matrices C</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funcionan mucho mejor que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un poco de cosméticos modernos de C ++ además </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de una matriz de estilo C</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y tiene que pagar un precio por usarlo en tales condiciones.</font></font></li><li>  ,  <strong> </strong>   (   )     <strong>  </strong> .  ,   ,          ,    .    :  ,         ,     ,    ,   (  )      ,        . </li><li>      ,      .        ,        . </li><li>         .            GCC.  ,     «». </li></ul><br><h4> : </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78c/000/4e9/78c0004e91d753a658fa8190626c3be9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muchas veces mi compilador arrojó terribles errores de compilación, y mi lógica de código sufrió. Pero, ¿cómo encontrar el lugar donde se esconde el error? Sin un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depurador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf, las</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cosas se vuelven más complicadas. Si su metafórica "barba del programador" aún no se ha puesto de rodillas (tanto la metafórica como la verdadera barba mía aún están lejos de estas expectativas), entonces tal vez no tenga motivación para usar la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">luz de techo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o depurar el compilador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestro primer amigo será </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lo que nos da la oportunidad de verificar el valor booleano del tiempo de compilación. Nuestro segundo amigo será una macro que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habilite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y deshabilite </font><strong><font style="vertical-align: inherit;">constexpr</font></strong><font style="vertical-align: inherit;"> siempre que sea posible:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONSTEXPR constexpr </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      //  #define CONSTEXPR //    </span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Con esta macro, podemos hacer que la lógica funcione en tiempo de ejecución, lo que significa que podemos adjuntarle un depurador. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meta Crush Saga II: lucha por el juego completamente en tiempo de ejecución: </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no ganará los </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">premios The Game Awards</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> este año </font><font style="vertical-align: inherit;">. Tiene un gran potencial, pero el juego no se ejecuta completamente </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en tiempo de compilación</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esto puede molestar a los jugadores hardcore ... No puedo deshacerme del script bash a menos que alguien agregue </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entrada de teclado</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y lógica impura en la fase de compilación (¡y esto es una locura franca!). Pero creo que algún día podré abandonar por completo el archivo ejecutable del </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renderizador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y mostrar el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado del juego</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">momento de la compilación</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/661/efc/26d/661efc26dbb41f0b8800916058993a56.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El loco con el alias </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saarraz </font></font></strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extendió GCC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para agregar la construcción </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_print</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al lenguaje </font><font style="vertical-align: inherit;">. Esta construcción debe tomar varias expresiones constantes o literales de cadena y generarlos en la etapa de compilación. Me alegraría si dicha herramienta se agregara al estándar, o al menos extendiera </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que </font><strong><font style="vertical-align: inherit;">aceptara</font></strong><font style="vertical-align: inherit;"> expresiones constantes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, en </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede haber una forma de lograr este resultado. Los compiladores ya generan dos cosas: ¡ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errores</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">advertencias</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! Si de alguna manera podemos gestionar o cambiar las </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">advertencias</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a nuestras necesidades, ya recibiremos una conclusión digna. Probé varias soluciones, en particular</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atributo en desuso</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... words&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useless</span></span></span><span class="hljs-class"> {</span></span> [[deprecated]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// Will trigger a warning. }; template &lt;char... words&gt; void output_as_warning() { useless&lt;words...&gt;().call(); } output_as_warning&lt;'a', 'b', 'c'&gt;(); // warning: 'void useless&lt;words&gt;::call() [with char ...words = {'a', 'b', 'c'}]' is deprecated // [-Wdeprecated-declarations]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque la salida obviamente está presente y se puede analizar, desafortunadamente, ¡el código no se puede reproducir! </font><font style="vertical-align: inherit;">Si, por pura coincidencia, eres miembro de una sociedad secreta de programadores de C ++ que puede realizar la producción durante la compilación, ¡estaré encantado de contratarte en mi equipo para crear la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga II</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perfecta </font><font style="vertical-align: inherit;">!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusiones: </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terminé vendiéndote mi </font><font style="vertical-align: inherit;">juego de </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estafa</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Espero que encuentres esta publicación curiosa y aprendas algo nuevo en el proceso de leerla. </font><font style="vertical-align: inherit;">Si encuentra errores o formas de mejorar el artículo, contácteme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quiero agradecer </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al equipo de SwedenCpp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por </font><strong><font style="vertical-align: inherit;">permitirme</font></strong><font style="vertical-align: inherit;"> realizar el informe de mi proyecto en uno de sus eventos. </font><font style="vertical-align: inherit;">Además, quiero expresar mi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">profunda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gratitud a </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Alexander Gurdeev</font></a><font style="vertical-align: inherit;"> , quien me ayudó a mejorar los aspectos significativos de la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saga Meta Crush</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414465/">https://habr.com/ru/post/es414465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414451/index.html">"Calendario de pruebas" para junio. El probador debe atrapar el error, leer a Caner y organizar el movimiento.</a></li>
<li><a href="../es414453/index.html">Implemente Path Finder para agentes de IA con NavMesh</a></li>
<li><a href="../es414455/index.html">Algoritmo de generación de paleta de colores</a></li>
<li><a href="../es414459/index.html">Detectores y descriptores de puntos singulares RÁPIDO, BREVE, ORB</a></li>
<li><a href="../es414463/index.html">La IA misma aprendió a construir un cubo de Rubik</a></li>
<li><a href="../es414467/index.html">Artículos de la Conferencia de Minsk C ++ CoreHard Spring 2018</a></li>
<li><a href="../es414469/index.html">Semana de la seguridad 22: dos segundas cerraduras inteligentes</a></li>
<li><a href="../es414471/index.html">11 círculos del infierno para aquellos que carecen de experiencia en un nuevo trabajo</a></li>
<li><a href="../es414473/index.html">Ninja DVR: Neoline G-Tech X27 Dual review</a></li>
<li><a href="../es414475/index.html">"Usuarios finales: estamos con usted": sobre el desarrollo de Android en CFT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>