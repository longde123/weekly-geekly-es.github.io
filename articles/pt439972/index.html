<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßìüèæ ‚òùüèΩ üë©üèΩ‚Äçüíº io_submit: uma alternativa ao epoll de que voc√™ nunca ouviu falar üë®‚Äç‚ù§Ô∏è‚Äçüë® üë©üèæ‚Äçüè≠ üçπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, a aten√ß√£o do autor foi atra√≠da para um artigo no LWN sobre uma nova interface do kernel para pesquisas. Ele discute o novo mecanismo de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>io_submit: uma alternativa ao epoll de que voc√™ nunca ouviu falar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/439972/"><img src="https://habrastorage.org/webt/sq/pn/nd/sqpnnd88db_ax0ark-6wxrqkobc.jpeg"><br><br>  Recentemente, a aten√ß√£o do autor foi atra√≠da para um artigo no LWN sobre uma nova interface do kernel para pesquisas.  Ele discute o novo mecanismo de pesquisa na API AIO do Linux (uma interface para manipula√ß√£o de arquivos ass√≠ncrona), que foi adicionada √† vers√£o 4.18 do kernel.  A ideia √© bastante interessante: o autor do patch sugere o uso da API Linux AIO para trabalhar com a rede. <br><br>  Mas espere um momento!  Afinal, o Linux AIO foi criado para trabalhar com E / S ass√≠ncrona de disco para disco!  Os arquivos no disco n√£o s√£o iguais √†s conex√µes de rede.  √â poss√≠vel usar a API do Linux AIO para redes? <br><br>  Acontece que sim, √© poss√≠vel!  Este artigo explica como usar os pontos fortes da API AIO do Linux para criar servidores de rede mais r√°pidos e melhores. <br><br>  Mas vamos come√ßar explicando o que √© o Linux AIO. <br><a name="habracut"></a><br><h1>  Introdu√ß√£o ao Linux AIO </h1><br>  O Linux AIO fornece E / S de disco para disco ass√≠ncronas para o software do usu√°rio. <br><br>  Historicamente, no Linux, todas as opera√ß√µes do disco foram bloqueadas.  Se voc√™ chamar <code>open()</code> , <code>read()</code> , <code>write()</code> ou <code>fsync()</code> , o fluxo ser√° interrompido at√© que os metadados apare√ßam no cache do disco.  Isso geralmente n√£o √© um problema.  Se voc√™ n√£o tiver muitas opera√ß√µes de E / S e mem√≥ria suficiente, as chamadas do sistema preencher√£o gradualmente o cache e tudo funcionar√° r√°pido o suficiente. <br><br>  O desempenho das opera√ß√µes de E / S diminui quando seu n√∫mero √© grande o suficiente, por exemplo, nos casos com bancos de dados e proxies.  Para tais aplicativos, √© inaceit√°vel interromper todo o processo, aguardando uma chamada de sistema <code>read()</code> . <br><br>  Para resolver esse problema, os aplicativos podem usar tr√™s m√©todos: <br><br><ol><li>  Use conjuntos de encadeamentos e fun√ß√µes de bloqueio de chamada em encadeamentos separados.  √â assim que o POSIX AIO funciona na glibc (n√£o confunda com o Linux AIO).  Para mais informa√ß√µes, consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IBM</a> .  Foi assim que resolvemos o problema no Cloudflare: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">usamos o pool de threads</a> para chamar <code>read()</code> e <code>open()</code> . <br></li><li>  Aque√ßa o cache do disco com <code>posix_fadvise(2)</code> e espere o melhor. <br></li><li>  Use o Linux AIO em conjunto com o sistema de arquivos XFS, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">abrindo arquivos com o sinalizador O_DIRECT</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">evitando problemas n√£o documentados</a> . <br></li></ol><br>  No entanto, nenhum desses m√©todos √© ideal.  Mesmo o Linux AIO, quando usado sem pensar, pode ser bloqueado na chamada <code>io_submit()</code> .  Isso foi mencionado recentemente em outro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo no LWN</a> : <br><blockquote>  ‚ÄúA interface de E / S ass√≠ncrona do Linux tem muitos cr√≠ticos e poucos apoiadores, mas a maioria das pessoas espera pelo menos assincronismo.  De fato, a opera√ß√£o da AIO pode ser bloqueada no kernel por v√°rios motivos em situa√ß√µes em que o encadeamento de chamada n√£o pode pagar. ‚Äù </blockquote>  Agora que conhecemos os pontos fracos da API Linux AIO, vejamos seus pontos fortes. <br><br><h2>  Um programa simples usando o Linux AIO </h2><br>  Para usar o Linux AIO, primeiro voc√™ deve <a href="">determinar todas as cinco chamadas de sistema necess√°rias</a> - a glibc n√£o as fornece. <br><br><ol><li>  Primeiro voc√™ precisa chamar <code>io_setup()</code> para inicializar a estrutura <code>aio_context</code> .  O kernel retornar√° um ponteiro opaco para a estrutura. <br></li><li>  Depois disso, voc√™ pode chamar <code>io_submit()</code> para adicionar o vetor de "blocos de controle de E / S" √† fila de processamento na forma de uma estrutura struct iocb. <br></li><li>  Agora, finalmente, podemos chamar <code>io_getevents()</code> e aguardar uma resposta dele na forma de um vetor de estruturas struct <code>io_event</code> - os resultados de cada um dos blocos iocb. <br></li></ol><br>  Existem oito comandos que voc√™ pode usar no iocb.  Dois comandos para leitura, dois para grava√ß√£o, duas op√ß√µes fsync e o comando POLL, que foi adicionado na vers√£o 4.18 do kernel (o oitavo comando √© NOOP): <br><br><pre> <code class="plaintext hljs">IOCB_CMD_PREAD = 0, IOCB_CMD_PWRITE = 1, IOCB_CMD_FSYNC = 2, IOCB_CMD_FDSYNC = 3, IOCB_CMD_POLL = 5,   /* from 4.18 */ IOCB_CMD_NOOP = 6, IOCB_CMD_PREADV = 7, IOCB_CMD_PWRITEV = 8,</code> </pre> <br>  <a href=""><code> iocb</code></a> , que √© passada para a fun√ß√£o <code>io_submit</code> , √© bastante grande e projetada para funcionar com o disco.  Aqui est√° sua vers√£o simplificada: <br><br><pre> <code class="plaintext hljs">struct iocb { __u64 data;           /* user data */ ... __u16 aio_lio_opcode; /* see IOCB_CMD_ above */ ... __u32 aio_fildes;     /* file descriptor */ __u64 aio_buf;        /* pointer to buffer */ __u64 aio_nbytes;     /* buffer size */ ... }</code> </pre> <br>  A estrutura <code>io_event</code> completa que <code>io_getevents</code> retorna: <br><br><pre> <code class="plaintext hljs">struct io_event { __u64  data; /* user data */ __u64  obj; /* pointer to request iocb */ __s64  res; /* result code for this event */ __s64  res2; /* secondary result */ };</code> </pre><br>  <b>Um exemplo</b>  Um programa simples que l√™ o arquivo / etc / passwd usando a API AIO do Linux: <br><br><pre> <code class="plaintext hljs">fd = open("/etc/passwd", O_RDONLY); aio_context_t ctx = 0; r = io_setup(128, &amp;ctx); char buf[4096]; struct iocb cb = {.aio_fildes = fd,                 .aio_lio_opcode = IOCB_CMD_PREAD,                 .aio_buf = (uint64_t)buf,                 .aio_nbytes = sizeof(buf)}; struct iocb *list_of_iocb[1] = {&amp;cb}; r = io_submit(ctx, 1, list_of_iocb); struct io_event events[1] = {{0}}; r = io_getevents(ctx, 1, 1, events, NULL); bytes_read = events[0].res; printf("read %lld bytes from /etc/passwd\n", bytes_read);</code> </pre> <br>  Naturalmente, fontes completas est√£o <a href="">dispon√≠veis no GitHub</a> .  Aqui est√° a sa√≠da strace deste programa: <br><br><pre> <code class="plaintext hljs">openat(AT_FDCWD, "/etc/passwd", O_RDONLY) io_setup(128, [0x7f4fd60ea000]) io_submit(0x7f4fd60ea000, 1, [{aio_lio_opcode=IOCB_CMD_PREAD, aio_fildes=3, aio_buf=0x7ffc5ff703d0, aio_nbytes=4096, aio_offset=0}]) io_getevents(0x7f4fd60ea000, 1, 1, [{data=0, obj=0x7ffc5ff70390, res=2494, res2=0}], NULL)</code> </pre> <br>  Tudo correu bem, mas a leitura do disco n√£o era ass√≠ncrona: a chamada io_submit foi bloqueada e fez todo o trabalho, a fun√ß√£o <code>io_getevents</code> executada instantaneamente.  Poder√≠amos tentar ler de forma ass√≠ncrona, mas isso requer o sinalizador O_DIRECT, com o qual as opera√ß√µes de disco ignoram o cache. <br><br>  Vamos ilustrar melhor como o <code>io_submit</code> bloqueado em arquivos regulares.  Aqui est√° um exemplo semelhante que mostra a sa√≠da do strace como resultado da leitura de um bloco de 1 GB em <code>/dev/zero</code> : <br><br><pre> <code class="plaintext hljs">io_submit(0x7fe1e800a000, 1, [{aio_lio_opcode=IOCB_CMD_PREAD, aio_fildes=3, aio_buf=0x7fe1a79f4000, aio_nbytes=1073741824, aio_offset=0}]) \   = 1 &lt;0.738380&gt; io_getevents(0x7fe1e800a000, 1, 1, [{data=0, obj=0x7fffb9588910, res=1073741824, res2=0}], NULL) \   = 1 &lt;0.000015&gt;</code> </pre> <br>  O kernel gastou 738 ms em uma chamada <code>io_submit</code> e apenas 15 ns em <code>io_getevents</code> .  Ele se comporta de maneira semelhante √†s conex√µes de rede - todo o trabalho √© realizado pelo <code>io_submit</code> . <br><br><img src="https://habrastorage.org/webt/e6/kw/kf/e6kwkfffjb-qvsfqgfdyl2ibmaq.jpeg"><br>  <a href="">Foto</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Helix84</a> CC / BY-SA / 3.0 <br><br><h2>  AIO e rede Linux </h2><br>  A implementa√ß√£o <code>io_submit</code> bastante conservadora: se o descritor de arquivo passado n√£o foi aberto com o sinalizador O_DIRECT, a fun√ß√£o simplesmente bloqueia e executa a a√ß√£o especificada.  No caso de conex√µes de rede, isso significa que: <br><br><ul><li>  para bloquear conex√µes, IOCV_CMD_PREAD aguardar√° um pacote de resposta; <br></li><li>  para conex√µes sem bloqueio, IOCB_CMD_PREAD retornar√° o c√≥digo -11 (EAGAIN). <br></li></ul><br>  A mesma sem√¢ntica tamb√©m √© usada na chamada regular do sistema <code>read()</code> , portanto, podemos dizer que io_submit ao trabalhar com conex√µes de rede n√£o √© mais inteligente do que as boas e antigas chamadas <code>read() / write()</code> . <br><br>  √â importante observar que <code>iocb</code> solicita√ß√µes <code>iocb</code> executadas pelo kernel sequencialmente. <br><br>  Apesar do Linux AIO n√£o nos ajudar com opera√ß√µes ass√≠ncronas, ele pode ser usado para combinar chamadas do sistema em lotes. <br><br>  Se o servidor da web precisar enviar e receber dados de centenas de conex√µes de rede, usar o <code>io_submit</code> pode ser uma √≥tima id√©ia, pois evita centenas de chamadas de envio e recv.  Isso melhorar√° o desempenho - alternar do espa√ßo do usu√°rio para o kernel e vice-versa n√£o √© gratuito, especialmente ap√≥s a introdu√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">medidas para combater o Spectre e o Meltdown</a> . <br><br><table><tbody><tr><td></td><td align="center">  <b>Um buffer</b> <br></td><td align="center">  <b>V√°rios buffers</b> <br></td></tr><tr><td>  Descritor de um arquivo <br></td><td>  read () <br></td><td>  readv () <br></td></tr><tr><td>  V√°rios descritores de arquivo <br></td><td>  io_submit + IOCB_CMD_PREAD <br></td><td>  io_submit + IOCB_CMD_PREADV <br></td></tr></tbody></table><br>  Para ilustrar o agrupamento de chamadas do sistema em pacotes usando <code>io_submit</code> vamos escrever um pequeno programa que envia dados de uma conex√£o TCP para outra.  Na sua forma mais simples (sem Linux AIO), √© algo como isto: <br><br><pre> <code class="plaintext hljs">while True: d = sd1.read(4096) sd2.write(d)</code> </pre> <br>  Podemos expressar a mesma funcionalidade atrav√©s do Linux AIO.  O c√≥digo nesse caso ser√° assim: <br><br><pre> <code class="plaintext hljs">struct iocb cb[2] = {{.aio_fildes = sd2,                     .aio_lio_opcode = IOCB_CMD_PWRITE,                     .aio_buf = (uint64_t)&amp;buf[0],                     .aio_nbytes = 0},                    {.aio_fildes = sd1,                    .aio_lio_opcode = IOCB_CMD_PREAD,                    .aio_buf = (uint64_t)&amp;buf[0],                    .aio_nbytes = BUF_SZ}}; struct iocb *list_of_iocb[2] = {&amp;cb[0], &amp;cb[1]}; while(1) { r = io_submit(ctx, 2, list_of_iocb); struct io_event events[2] = {}; r = io_getevents(ctx, 2, 2, events, NULL); cb[0].aio_nbytes = events[1].res; }</code> </pre> <br>  Esse c√≥digo adiciona dois trabalhos ao <code>io_submit</code> : primeiro um pedido de grava√ß√£o no <code>sd2</code> e, em seguida, um pedido de leitura do sd1.  Ap√≥s a leitura, o c√≥digo corrige o tamanho do buffer de grava√ß√£o e repete o loop desde o in√≠cio.  H√° um truque: a primeira vez que uma grava√ß√£o ocorre com um buffer de tamanho 0. Isso √© necess√°rio porque temos a capacidade de combinar grava√ß√£o + leitura em uma chamada <code>io_submit</code> (mas n√£o leitura + grava√ß√£o). <br><br>  Esse c√≥digo √© mais r√°pido que o regular <code>read()</code> / <code>write()</code> ?  Ainda n√£o.  Ambas as vers√µes usam duas chamadas de sistema: leitura + grava√ß√£o e io_submit + io_getevents.  Mas, felizmente, o c√≥digo pode ser melhorado. <br><br><h2>  Livrar-se de io_getevents </h2><br>  No tempo de execu√ß√£o <code>io_setup()</code> kernel aloca v√°rias p√°ginas de mem√≥ria para o processo.  √â assim que este bloco de mem√≥ria se parece nos mapas / proc //: <br><br><pre> <code class="plaintext hljs">marek:~$ cat /proc/`pidof -s aio_passwd`/maps ... 7f7db8f60000-7f7db8f63000 rw-s 00000000 00:12 2314562     /[aio] (deleted) ...</code> </pre> <br>  O bloco de mem√≥ria [aio] (12 Kb neste caso) foi alocado <code>io_setup</code> .  √â usado para o buffer circular onde os eventos s√£o armazenados.  Na maioria dos casos, n√£o h√° motivo para chamar <code>io_getevents</code> - os dados de conclus√£o do evento podem ser obtidos no buffer de anel sem a necessidade de alternar para o modo kernel.  Aqui est√° a vers√£o corrigida do c√≥digo: <br><br><pre> <code class="plaintext hljs">int io_getevents(aio_context_t ctx, long min_nr, long max_nr,                struct io_event *events, struct timespec *timeout) {   int i = 0;   struct aio_ring *ring = (struct aio_ring*)ctx;   if (ring == NULL || ring-&gt;magic != AIO_RING_MAGIC) {       goto do_syscall;   }   while (i &lt; max_nr) {       unsigned head = ring-&gt;head;       if (head == ring-&gt;tail) {           /* There are no more completions */           break;       } else {           /* There is another completion to reap */           events[i] = ring-&gt;events[head];           read_barrier();           ring-&gt;head = (head + 1) % ring-&gt;nr;           i++;       }   }   if (i == 0 &amp;&amp; timeout != NULL &amp;&amp; timeout-&gt;tv_sec == 0 &amp;&amp; timeout-&gt;tv_nsec == 0) {       /* Requested non blocking operation. */       return 0;   }   if (i &amp;&amp; i &gt;= min_nr) {       return i;   } do_syscall:   return syscall(__NR_io_getevents, ctx, min_nr-i, max_nr-i, &amp;events[i], timeout); }</code> </pre> <br>  A vers√£o completa do c√≥digo est√° dispon√≠vel <a href="">no GitHub</a> .  A interface desse buffer de anel est√° mal documentada; o autor adaptou o c√≥digo do <a href="">projeto axboe / fio</a> . <br><br>  Ap√≥s essa altera√ß√£o, nossa vers√£o do c√≥digo usando o Linux AIO requer apenas uma chamada do sistema em um loop, o que o torna um pouco mais r√°pido que o c√≥digo original usando leitura + grava√ß√£o. <br><br><img src="https://habrastorage.org/webt/xq/er/7t/xqer7tve9zpg23gh2zfjjl_bb-i.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Foto fotos de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">trem</a> CC / BY-SA / 2.0 <br><br><h2>  Alternativa Epoll </h2><br>  Com a adi√ß√£o de IOCB_CMD_POLL √† vers√£o do kernel 4.18, tornou-se poss√≠vel usar <code>io_submit</code> como um substituto para select / poll / epoll.  Por exemplo, este c√≥digo espera dados de uma conex√£o de rede: <br><br><pre> <code class="plaintext hljs">struct iocb cb = {.aio_fildes = sd,                 .aio_lio_opcode = IOCB_CMD_POLL,                 .aio_buf = POLLIN}; struct iocb *list_of_iocb[1] = {&amp;cb}; r = io_submit(ctx, 1, list_of_iocb); r = io_getevents(ctx, 1, 1, events, NULL);</code> </pre><br>  <a href="">C√≥digo completo</a> .  Aqui est√° sua sa√≠da strace: <br><br><pre> <code class="plaintext hljs">io_submit(0x7fe44bddd000, 1, [{aio_lio_opcode=IOCB_CMD_POLL, aio_fildes=3}]) \   = 1 &lt;0.000015&gt; io_getevents(0x7fe44bddd000, 1, 1, [{data=0, obj=0x7ffef65c11a8, res=1, res2=0}], NULL) \   = 1 &lt;1.000377&gt;</code> </pre> <br>  Como voc√™ pode ver, desta vez a assincronia funcionou: io_submit executado instantaneamente e <code>io_getevents</code> bloqueados por um segundo, aguardando dados.  Isso pode ser usado em vez da chamada do sistema <code>epoll_wait()</code> . <br><br>  Al√©m disso, trabalhar com <code>epoll</code> geralmente requer o uso das chamadas do sistema epoll_ctl.  E os desenvolvedores de aplicativos tentam evitar chamadas frequentes para essa fun√ß√£o - para entender os motivos, basta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ler os</a> sinalizadores EPOLLONESHOT e EPOLLET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no manual</a> .  Usando io_submit para consultar conex√µes, voc√™ pode evitar essas dificuldades e chamadas adicionais ao sistema.  Apenas adicione as conex√µes ao vetor iocb, chame io_submit uma vez e aguarde a execu√ß√£o.  Tudo √© muito simples. <br><br><h2>  Sum√°rio </h2><br>  Nesta postagem, abordamos a API AIO do Linux.  Essa API foi projetada originalmente para funcionar com o disco, mas tamb√©m funciona com conex√µes de rede.  No entanto, diferentemente das chamadas regulares de leitura () + grava√ß√£o (), o uso do io_submit permite agrupar chamadas do sistema e, assim, aumentar o desempenho. <br><br>  A partir da vers√£o 4.18 do kernel, <code>io_submit  io_getevents</code> no caso de conex√µes de rede podem ser usados ‚Äã‚Äãpara eventos do formato POLLIN e POLLOUT.  Esta √© uma alternativa ao <code>epoll()</code> . <br><br>  Eu posso imaginar um servi√ßo de rede que use apenas <code>io_submit  io_getevents</code> vez do conjunto padr√£o de leitura, grava√ß√£o, epoll_ctl e epoll_wait.  Nesse caso, as chamadas de sistema de agrupamento no <code>io_submit</code> podem oferecer uma grande vantagem, pois esse servidor seria muito mais r√°pido. <br><br>  Infelizmente, mesmo ap√≥s melhorias recentes na API do Linux AIO, as discuss√µes sobre sua utilidade continuam.  √â sabido que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Linus o odeia</a> : <br><br><blockquote>  ‚ÄúAIO √© um exemplo terr√≠vel de design na altura dos joelhos, onde a principal desculpa √©:‚Äú outras pessoas menos talentosas inventaram isso, ent√£o precisamos cumprir a compatibilidade para que os desenvolvedores do banco de dados (que raramente s√£o de bom gosto) possam us√°-lo. ‚Äù  Mas a AIO sempre foi muito, muito torta. ‚Äù </blockquote><br>  V√°rias tentativas foram feitas para criar uma interface melhor para agrupar chamadas e assincronia, mas elas careciam de uma vis√£o comum.  Por exemplo, a recente <a href="">adi√ß√£o de sendto (MSG_ZEROCOPY)</a> permite transfer√™ncia de dados verdadeiramente ass√≠ncrona, mas n√£o fornece agrupamento.  <code>io_submit</code> fornece agrupamento, mas n√£o assincronia.  Pior ainda - atualmente existem tr√™s maneiras de fornecer eventos ass√≠ncronos no Linux: sinais, <code>io_getevents</code> e MSG_ERRQUEUE. <br><br>  De qualquer forma, √© √≥timo que haja novas maneiras de acelerar o trabalho dos servi√ßos de rede. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439972/">https://habr.com/ru/post/pt439972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439962/index.html">Trabalhamos com o Atlassian Service Desk, obtemos o m√°ximo do plug-in Riada Insight - um relat√≥rio da reuni√£o do Atlassian User Group</a></li>
<li><a href="../pt439964/index.html">Runc CVE-2019-5736 Vulnerabilidade em um host</a></li>
<li><a href="../pt439966/index.html">Analisador simples para opera√ß√µes aritm√©ticas</a></li>
<li><a href="../pt439968/index.html">Espa√ßo de gera√ß√£o e espa√ßo de oportunidade</a></li>
<li><a href="../pt439970/index.html">Relat√≥rio sobre problemas e acessibilidade da Internet em 2018-2019</a></li>
<li><a href="../pt439974/index.html">Transforma√ß√£o √°gil pessoal: uma jornada flex√≠vel para a produtividade</a></li>
<li><a href="../pt439976/index.html">O Node.js sempre ser√° mais lento que o Golang?</a></li>
<li><a href="../pt439978/index.html">Docker de aprendizagem, parte 2: termos e conceitos</a></li>
<li><a href="../pt439980/index.html">Docker de aprendizagem, parte 3: arquivos do Dockerfile</a></li>
<li><a href="../pt439982/index.html">Tutorial Reagir, Parte 16: A quarta fase do trabalho em um aplicativo TODO, processamento de eventos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>