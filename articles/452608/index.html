<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ûüèª üõÄüèΩ üõí Parte 1. QInst: es mejor perder un d√≠a, luego volar en cinco minutos (escribir instrumentos es trivial) ‚ò£Ô∏è ‚è© üë®‚Äçüë©‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la parte anterior, describ√≠ aproximadamente c√≥mo puede cargar funciones eBPF desde un archivo ELF. Ahora es el momento de pasar de los dibujos anim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Parte 1. QInst: es mejor perder un d√≠a, luego volar en cinco minutos (escribir instrumentos es trivial)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452608/"><p>  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte anterior,</a> describ√≠ aproximadamente c√≥mo puede cargar funciones eBPF desde un archivo ELF.  Ahora es el momento de pasar de los dibujos animados de fantas√≠a a los sovi√©ticos, y siguiendo sabios consejos, despu√©s de gastar una cierta cantidad de esfuerzo una vez, hacer una herramienta de instrumentaci√≥n universal <del>  <em>(o, en resumen, UII !!!)</em> </del>  .  Al hacerlo, aprovechar√© el dise√±o antipatr√≥n Golden Hammer y construir√© una herramienta de la relativamente familiar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">QEMU</a> .  Como beneficio adicional para esto, obtenemos instrumentaci√≥n de arquitectura cruzada, as√≠ como instrumentaci√≥n a nivel de toda la computadora virtual.  La instrumentaci√≥n tendr√° la forma de "un peque√±o archivo nativo + un peque√±o archivo .o con eBPF".  En este caso, las funciones de eBPF se sustituir√°n antes que las instrucciones correspondientes de la representaci√≥n interna de QEMU antes de la optimizaci√≥n y la generaci√≥n de c√≥digo. </p><br><p> Como resultado, la instrumentaci√≥n en s√≠, que se <strong>agrega durante la generaci√≥n del c√≥digo</strong> (es decir, sin contar un par de kilobytes de tiempo de ejecuci√≥n normal del sistema), se ve as√≠, y este <strong>no</strong> es <strong>un</strong> pseudoc√≥digo: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; extern uint8_t *__afl_area_ptr; extern uint64_t prev; void inst_qemu_brcond_i64(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; } void inst_qemu_brcond_i32(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; }</span></span></span></span></code> </pre> <br><p>  Bueno, es hora de cargar a nuestro elfo en Matrix.  Bueno, como descargar, m√°s bien <del>  golpe </del>  spray. </p><a name="habracut"></a><br><p>  Como ya se mencion√≥ en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo sobre QEMU.js</a> , uno de los modos de operaci√≥n de QEMU es la generaci√≥n JIT de c√≥digo de m√°quina host desde el invitado (potencialmente, para una arquitectura completamente diferente).  Si la √∫ltima vez que implement√© mi backend de generaci√≥n de c√≥digo, esta vez voy a procesar la representaci√≥n interna encajando justo en frente del optimizador.  ¬øEs esta una decisi√≥n arbitraria?  No  Existe la esperanza de que el optimizador elimine el exceso de esquinas, arroje variables innecesarias, etc.  Seg√∫n tengo entendido, √©l, de hecho, hace cosas simples y r√°pidamente factibles: empujar constantes, tirar expresiones como "x: = x + 0" y eliminar el c√≥digo inalcanzable.  Y podemos obtener una cantidad decente. </p><br><h1 id="konfiguraciya-sborochnyh-skriptov">  Configuraci√≥n de script de ensamblaje </h1><br><p>  Primero, agreguemos nuestros archivos fuente: <code>tcg/bpf-loader.c</code> y <code>tcg/instrument.c</code> a los Makefiles.  En t√©rminos generales, existe el deseo de alg√∫n d√≠a llevar esto a la corriente ascendente, por lo que deber√° hacerlo sabiamente al final, pero por ahora agregar√© incondicionalmente estos archivos al ensamblado.  Y tomar√© los par√°metros en las mejores tradiciones de AFL - a trav√©s de variables de entorno.  Por cierto, probar√© esto nuevamente en la instrumentaci√≥n para AFL. </p><br><p>  Simplemente busque la menci√≥n del "vecino": el archivo <code>optimize.c</code> con <code>grep -R</code> y no encontraremos nada.  Debido a que era necesario buscar <code>optimize.o</code> : </p><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/Makefile.target +++ b/Makefile.target @@ -110,7 +110,7 @@ obj-y += trace/ obj-y += exec.o obj-y += accel/ obj-$(CONFIG_TCG) += tcg/tcg.o tcg/tcg-op.o tcg/tcg-op-vec.o tcg/tcg-op-gvec.o -obj-$(CONFIG_TCG) += tcg/tcg-common.o tcg/optimize.o +obj-$(CONFIG_TCG) += tcg/tcg-common.o tcg/optimize.o tcg/instrument.o tcg/bpf-loader.o obj-$(CONFIG_TCG_INTERPRETER) += tcg/tci.o obj-$(CONFIG_TCG_INTERPRETER) += disas/tci.o obj-$(CONFIG_TCG) += fpu/softfloat.o</span></span></code> </pre> <br><h1 id="tak-vot-ty-kakoe-metaprogrammirovanie-na-c">  As√≠ que aqu√≠ est√°s, metaprogramando en C ... </h1><br><p>  Primero, agreguemos <code>bpf-loader.c</code> de la √∫ltima serie con un c√≥digo que extraiga los puntos de entrada correspondientes a las operaciones QEMU.  Y el misterioso archivo <code>tcg-opc.h</code> nos ayudar√° con esto.  Se ve as√≠: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * DEF(name, oargs, iargs, cargs, flags) */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* predefined ops */</span></span> DEF(discard, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, TCG_OPF_NOT_PRESENT) DEF(set_label, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, TCG_OPF_BB_END | TCG_OPF_NOT_PRESENT) <span class="hljs-comment"><span class="hljs-comment">/* variable number of parameters */</span></span> DEF(call, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, TCG_OPF_CALL_CLOBBER | TCG_OPF_NOT_PRESENT) DEF(br, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, TCG_OPF_BB_END) <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  ¬øQu√© tonter√≠a?  Y la cuesti√≥n es simplemente que no est√° conectado en el encabezado de origen: debe definir la macro <code>DEF</code> , incluir este archivo e inmediatamente eliminar la macro.  Mira, √©l ni siquiera tiene guardia. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *inst_function_names[] = { #define DEF(name, a, b, c, d) stringify(inst_qemu_##name), #include <span class="hljs-string"><span class="hljs-string">"tcg-opc.h"</span></span> #undef DEF <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> };</code> </pre> <br><p>  Como resultado, obtenemos una ordenada matriz de nombres de funciones de destino, indexados por c√≥digos de operaci√≥n y terminando con NULL, que podemos ejecutar para cada car√°cter en el archivo.  Entiendo que esto no es efectivo.  Pero es simple, lo cual es importante, dada la naturaleza √∫nica de esta operaci√≥n.  A continuaci√≥n, omitimos todos los caracteres para los que </p><br><pre> <code class="cpp hljs">ELF64_ST_BIND(sym-&gt;st_info) == STB_LOCAL || ELF64_ST_TYPE(sym-&gt;st_info) != STT_FUNC</code> </pre> <br><p>  El resto se compara con la lista. </p><br><h1 id="privyazyvaemsya-k-potoku-vypolneniya">  Estamos unidos a un flujo de ejecuci√≥n </h1><br><p>  Ahora necesita levantarse en alg√∫n lugar del flujo del mecanismo de generaci√≥n de c√≥digo y esperar hasta que pasen las instrucciones de inter√©s.  Pero primero debe definir sus funciones <code>instrumentation_init</code> , <code>tcg_instrument</code> y <code>instrumentation_shutdown</code> en el <code>tcg/tcg.h</code> y anotar sus llamadas: inicializaci√≥n - despu√©s de que se inicializa el backend, instrumentaci√≥n - justo antes de la llamada <code>tcg_optimize</code> .  Parece que <code>instrumentation_shutdown</code> puede colgarse en <code>instrumentation_init</code> en <code>atexit</code> y no <code>atexit</code> .  Yo tambi√©n lo pens√©, y lo m√°s probable es que funcione en el modo de emulaci√≥n de sistema completo, pero en el modo de emulaci√≥n de modo de usuario, QEMU traduce las <code>exit_group</code> sistema <code>exit_group</code> y, a veces, <code>exit</code> a la <code>_exit</code> funci√≥n <code>_exit</code> , que ignora todos estos manejadores de atexit, por lo tanto, lo buscaremos en <code>linux-user/syscall.c</code> y <code>linux-user/syscall.c</code> llamada a nuestro c√≥digo delante de √©l. </p><br><h1 id="interpretiruem-baytkod">  Interpretar Bytecode </h1><br><p>  As√≠ que es hora de leer lo que el compilador gener√≥ para nosotros.  Esto se hace convenientemente usando <code>llvm-objdump</code> con la opci√≥n <code>-x</code> , o mejor, inmediatamente <code>-d -t -r</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de salida</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ ./compile-bpf.sh test-bpf.o: file format ELF64-BPF Disassembly of section .text: 0000000000000000 inst_brcond_i64: 0: 18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r2 = 0 ll 0000000000000000: R_BPF_64_64 prev 2: 79 23 00 00 00 00 00 00 r3 = *(u64 *)(r2 + 0) 3: 77 03 00 00 01 00 00 00 r3 &gt;&gt;= 1 4: 7b 32 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r3 5: af 13 00 00 00 00 00 00 r3 ^= r1 6: 57 03 00 00 ff ff 00 00 r3 &amp;= 65535 7: 18 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r4 = 0 ll 0000000000000038: R_BPF_64_64 __afl_area_ptr 9: 79 44 00 00 00 00 00 00 r4 = *(u64 *)(r4 + 0) 10: 0f 34 00 00 00 00 00 00 r4 += r3 11: 71 43 00 00 00 00 00 00 r3 = *(u8 *)(r4 + 0) 12: 07 03 00 00 01 00 00 00 r3 += 1 13: 73 34 00 00 00 00 00 00 *(u8 *)(r4 + 0) = r3 14: 7b 12 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r1 15: 95 00 00 00 00 00 00 00 exit 0000000000000080 inst_brcond_i32: 16: 18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r2 = 0 ll 0000000000000080: R_BPF_64_64 prev 18: 79 23 00 00 00 00 00 00 r3 = *(u64 *)(r2 + 0) 19: 77 03 00 00 01 00 00 00 r3 &gt;&gt;= 1 20: 7b 32 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r3 21: af 13 00 00 00 00 00 00 r3 ^= r1 22: 57 03 00 00 ff ff 00 00 r3 &amp;= 65535 23: 18 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r4 = 0 ll 00000000000000b8: R_BPF_64_64 __afl_area_ptr 25: 79 44 00 00 00 00 00 00 r4 = *(u64 *)(r4 + 0) 26: 0f 34 00 00 00 00 00 00 r4 += r3 27: 71 43 00 00 00 00 00 00 r3 = *(u8 *)(r4 + 0) 28: 07 03 00 00 01 00 00 00 r3 += 1 29: 73 34 00 00 00 00 00 00 *(u8 *)(r4 + 0) = r3 30: 7b 12 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r1 31: 95 00 00 00 00 00 00 00 exit SYMBOL TABLE: 0000000000000000 l df *ABS* 00000000 test-bpf.c 0000000000000000 ld .text 00000000 .text 0000000000000000 *UND* 00000000 __afl_area_ptr 0000000000000080 g F .text 00000080 inst_brcond_i32 0000000000000000 g F .text 00000080 inst_brcond_i64 0000000000000008 g O *COM* 00000008 prev</code> </pre> </div></div><br><p>  Si intenta buscar una descripci√≥n de los c√≥digos de operaci√≥n eBPF, resulta que en lugares obvios (fuente y p√°ginas de manual del kernel de Linux) hay descripciones de c√≥mo usarlo, c√≥mo compilar, etc.  Luego se encuentra con la <a href="">p√°gina del</a> equipo de la herramienta iovisor con una conveniente referencia no oficial de eBPF. </p><br><p>  La instrucci√≥n ocupa una palabra de 64 bits (algunas dos) y tiene la forma </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> opcode; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dst:<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> src:<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> imm; };</code> </pre> <br><p>  Aquellos que ocupan dos palabras simplemente consisten en la primera instrucci√≥n con toda la l√≥gica y un "trailer" con 32 bits m√°s de valor inmediato y son muy claramente visibles en el desensamblador de objdump. </p><br><p>  Los propios c√≥digos de operaci√≥n tambi√©n tienen una estructura regular: los tres bits inferiores son la clase de operaci√≥n: ALU de 32 bits, ALU de 64 bits, carga / almacenamiento, ramificaci√≥n condicional.  Por lo tanto, es muy conveniente implementarlos en macros en las mejores tradiciones de QEMU.  No conducir√© instrucciones detalladas sobre la base del c√≥digo <del>  no estamos en revisi√≥n de c√≥digo </del>  Ser√° mejor que te cuente sobre las trampas. </p><br><p>  Mi primer problema fue que hice un asignador perezoso de registros eBPF en forma de QEMU- <code>local_temp</code> , y comenc√© a transferir sin <code>local_temp</code> la llamada de esta funci√≥n a la macro.  Result√≥ como en un famoso meme: "Insertamos una abstracci√≥n en una abstracci√≥n para que pueda generar una instrucci√≥n mientras genera una instrucci√≥n".  Despu√©s del hecho, ya no entiendo muy bien qu√© se rompi√≥ en ese momento, pero aparentemente algo extra√±o estaba sucediendo con el orden de las instrucciones generadas.  Despu√©s de eso, hice an√°logos de las funciones <code>tcg_gen_...</code> para insertar nuevas instrucciones en el medio de la lista, tomando los operandos como argumentos de la funci√≥n, y el orden se convirti√≥ autom√°ticamente como deber√≠a (ya que los argumentos se calculan completamente exactamente una vez antes de la llamada). </p><br><p>  El segundo problema fue tratar de empujar la constante TCG como el operando de una instrucci√≥n arbitraria al mirar el operando inmediato en eBPF.  Solicitando el <code>tcg-opc.h</code> ya mencionado, la composici√≥n de la lista de argumentos de la operaci√≥n es estrictamente fija: <code>n</code> argumentos de entrada, <code>m</code> salida y <code>k</code> constante.  Por cierto, al depurar dicho c√≥digo, ayuda a pasar QEMU el argumento de la l√≠nea de comando <code>-d op,op_opt</code> o incluso <code>-d op,op_opt,out_asm</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Posibles argumentos</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ ./x86_64-linux-user/qemu-x86_64 -d help Log items (comma separated): out_asm show generated host assembly code for each compiled TB in_asm show target assembly code for each compiled TB op show micro ops for each compiled TB op_opt show micro ops after optimization op_ind show micro ops before indirect lowering int show interrupts/exceptions in short format exec show trace before each executed TB (lots of logs) cpu show CPU registers before entering a TB (lots of logs) fpu include FPU registers in the 'cpu' logging mmu log MMU-related activities pcall x86 only: show protected mode far calls/returns/exceptions cpu_reset show CPU state before CPU resets unimp log unimplemented functionality guest_errors log when the guest OS does something invalid (eg accessing a non-existent register) page dump pages at beginning of user mode emulation nochain do not chain compiled TBs so that "exec" and "cpu" show complete traces trace:PATTERN enable trace events Use "-d trace:help" to get a list of trace events.</code> </pre> </div></div><br><p>  Bueno, no repita mis errores: el desensamblador de instrucciones internas est√° bastante avanzado, y si ve algo como <code>add_i64 loc15,loc15,$554412123213</code> , entonces esto despu√©s del signo de d√≥lar no es un puntero.  M√°s precisamente, esto, por supuesto, es un puntero, pero tal vez colgado de banderas y en el papel del valor literal del operando, y no el puntero.  Todo esto se aplica, por supuesto, si sabe que deber√≠a haber un n√∫mero espec√≠fico, como <code>$0</code> o <code>$ff</code> , no tiene que tener miedo de los punteros.  :) C√≥mo <code>movi</code> con esto: solo necesita crear una funci√≥n que devuelva una <code>temp</code> nueva, en la que a trav√©s de <code>movi</code> la constante deseada. </p><br><p>  Por cierto, si comenta <code>#define USE_TCG_OPTIMIZATIONS</code> en el <code>#define USE_TCG_OPTIMIZATIONS</code> <code>tcg/tcg.c</code> , entonces, de repente, la optimizaci√≥n se desactivar√° y ser√° m√°s f√°cil analizar las transformaciones de c√≥digo. </p><br><p>  Para sim, enviar√© un lector interesado en elegir QEMU en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> , ¬°incluso el oficial!  Por lo dem√°s, demostrar√© la instrumentaci√≥n prometida para AFL. </p><br><h1 id="te-zhe-i-krolik">  Lo mismo y el conejo </h1><br><p>  Para el texto completo del tiempo de ejecuci√≥n, nuevamente enviar√© al lector al repositorio, ya que (el texto) no tiene valor art√≠stico y honestamente est√° endurecido de <code>qemu_mode</code> de la entrega de AFL, y en general, es una pieza regular de c√≥digo C. Pero as√≠ es como se ve la instrumentaci√≥n en s√≠ : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; extern uint8_t *__afl_area_ptr; extern uint64_t prev; void inst_qemu_brcond_i64(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; } void inst_qemu_brcond_i32(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; }</span></span></span></span></code> </pre> <br><p>  Es importante que las funciones de <code>iargs</code> tengan tantos argumentos como <code>iargs</code> para la operaci√≥n QEMU correspondiente.  Dos <code>extern</code> en el encabezado se vincular√°n al tiempo de ejecuci√≥n durante el proceso de reubicaci√≥n.  En principio, <code>prev</code> podr√≠a definirse aqu√≠ mismo, pero luego debe definirse como <code>static</code> , de lo contrario caer√° en la secci√≥n COM√öN que no soporto.  En realidad, nosotros, de hecho, simplemente reescribimos el pseudoc√≥digo de la documentaci√≥n, ¬°pero aqu√≠ es legible por m√°quina! </p><br><p>  Para verificar, cree el archivo <code>bug.c</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { char buf[16]; int res = read(0, buf, 4); if (buf[0] == 'T' &amp;&amp; buf[1] == 'E' &amp;&amp; buf[2] == 'S' &amp;&amp; buf[3] == 'T') abort(); return res * 0; }</span></span></span></span></code> </pre> <br><p>  Y tambi√©n - archivo <code>forksrv</code> , que es conveniente para alimentar AFL: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash export NATIVE_INST=./instrumentation-examples/afl/afl-native.so export BPF_INST=./instrumentation-examples/afl/afl-bpf.co exec ./x86_64-linux-user/qemu-x86_64 ./instrumentation-examples/afl/bug</span></span></code> </pre> <br><p>  Y corre fuzzing: </p><br><pre> <code class="bash hljs">AFL_SKIP_BIN_CHECK=1 afl-fuzz -i ../input -o ../output -m none -- ./forksrv</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">American Fuzzy Lop</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">1234 T234 TE34 TES4 TEST &lt;-     crashes,    2200  </code> </pre> </div></div><br><p>  Hasta ahora, la velocidad no es tan alta, pero como excusa dir√© que aqu√≠ (por ahora) una caracter√≠stica importante del <code>qemu_mode</code> original no se usa: enviar direcciones de c√≥digo ejecutable al servidor fork.  Pero ahora no hay nada AFL en la base de c√≥digo QEMU, y hay esperanzas de que esta instrumentaci√≥n generalizada alg√∫n d√≠a se acumule en sentido ascendente. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Proyecto GitHub</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452608/">https://habr.com/ru/post/452608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452592/index.html">Parte 0. Requiere un elfo para trabajar en Matrix. La reubicaci√≥n es posible</a></li>
<li><a href="../452596/index.html">Se tomaron 735,000 direcciones IPv4 de un estafador y se devolvieron al registro</a></li>
<li><a href="../452598/index.html">Gesti√≥n de un equipo de programadores: ¬øc√≥mo y c√≥mo motivarlos correctamente? Primera parte</a></li>
<li><a href="../452602/index.html">Cisco Hyperflex para sistemas de administraci√≥n de bases de datos de alta carga</a></li>
<li><a href="../452606/index.html">UDB Que es esto Parte 8. Abordar UDB</a></li>
<li><a href="../452610/index.html">Ayuda y solicitud por ella. Art√≠culo sobre seguridad de la informaci√≥n para usuarios comunes.</a></li>
<li><a href="../452612/index.html">Aprendizaje autom√°tico reforzado de redes neuronales profundas en tensorflow.js: trucos</a></li>
<li><a href="../452614/index.html">C√≥mo comenzar a programar en Adobe Illustrator. Parte dos</a></li>
<li><a href="../452618/index.html">Lo que se dijo en Google I / O 2019: Android 10, aplicaciones AR y mucho m√°s</a></li>
<li><a href="../452620/index.html">Derivar un tipo de acci√≥n usando el mecanografiado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>