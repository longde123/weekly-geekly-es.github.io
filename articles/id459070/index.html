<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë• üôèüèΩ üçº Menciptakan Tower Defense in Unity: Towers and Shooting Enemies ü§õ üÜí ‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Bagian pertama dan kedua tutorial] 



- Kami menempatkan di bidang menara. 
- Kami membidik musuh dengan bantuan fisika. 
- Kami melacak mereka sel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menciptakan Tower Defense in Unity: Towers and Shooting Enemies</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459070/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian pertama</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a> tutorial] <br><br><ul><li>  Kami menempatkan di bidang menara. </li><li>  Kami membidik musuh dengan bantuan fisika. </li><li>  Kami melacak mereka selagi mungkin. </li><li>  Kami menembak mereka dengan sinar laser. </li></ul><br>  Ini adalah bagian ketiga dari serangkaian tutorial tentang cara membuat genre menara pertahanan sederhana.  Ini menggambarkan penciptaan menara, membidik dan menembak musuh. <br><br>  Tutorial dibuat di Unity 2018.3.0f2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/470/ceb/183/470ceb1832b49ee7372fb79b8425b567.jpg" width="512" height="256"></div><br>  <i>Mari kita panaskan musuh.</i> <br><br><h2>  Penciptaan menara </h2><br>  Dinding hanya memperlambat musuh, menambah panjang jalan yang harus dilalui.  Tetapi tujuan permainan ini adalah untuk menghancurkan musuh sebelum mereka mencapai titik akhir.  Masalah ini diselesaikan dengan menempatkan menara di lapangan yang akan menembak mereka. <br><a name="habracut"></a><br><h3>  Konten Ubin </h3><br>  Towers adalah tipe lain dari konten ubin, jadi <code>GameTileContent</code> tambahkan entri untuk mereka di <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall, SpawnPoint, Tower‚Ç¨ }</code> </pre> <br>  Dalam tutorial ini, kami hanya akan mendukung satu jenis menara, yang dapat diimplementasikan dengan memberikan satu tautan ke prefab menara kepada <code>GameTileContentFactory</code> , sebuah instance yang juga dapat dibuat melalui <code>Get</code> . <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Tower‚Ç¨: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(towerPrefab); } ‚Ä¶ }</code> </pre> <br>  Tetapi menara harus menembak, sehingga kondisinya perlu diperbarui dan mereka membutuhkan kode mereka sendiri.  Buat kelas <code>Tower</code> untuk tujuan ini yang memperluas kelas <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tower</span></span> : <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> {}</code> </pre> <br>  Anda dapat membuat prefab menara memiliki komponennya sendiri dengan mengubah jenis bidang pabrik ke <code>Tower</code> .  Karena kelas masih dianggap sebagai <code>GameTileContent</code> , tidak ada lagi yang perlu diubah. <br><br><pre> <code class="cs hljs"> Tower towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><h3>  Cetakan rumah </h3><br>  Buat cetakan untuk menara.  Anda bisa mulai dengan menduplikasi prefab dinding dan mengganti komponen <code>GameTileContent</code> dengan komponen <code>Tower</code> , dan kemudian ubah tipenya menjadi <em>Tower</em> .  Untuk membuat menara sesuai dengan dinding, simpan kubus dinding sebagai dasar menara.  Kemudian letakkan kubus lain di atasnya.  Saya memberinya skala 0,5.  Letakkan kubus lain di atasnya, menunjukkan menara, bagian ini akan bertujuan dan menembak musuh. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/e5d/633/392e5d63397672627c3b5ec018df0444.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/dec/c33/d92decc33036a1e973a7f20a3df2c00e.png" width="320" height="120"></div><br>  <i>Tiga kubus membentuk menara.</i> <br><br>  Menara akan berputar, dan karena memiliki collider, itu akan dilacak oleh mesin fisik.  Tetapi kita tidak perlu begitu tepat, karena kita menggunakan penghubung menara hanya untuk memilih sel.  Ini dapat dilakukan kira-kira.  Lepaskan collider kubus menara dan ubah collider menara kubus sehingga menutupi kedua kubus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/11e/3b7/e0111e3b7221bbbe4e5b0d23373e4b3a.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/857/09b/a1f85709bd504d176a18930240edea5a.png" width="320" height="152"></div><br>  <i>Menara kubus collider.</i> <br><br>  Menara akan menembakkan sinar laser.  Ini dapat divisualisasikan dalam banyak cara, tetapi kami hanya menggunakan kubus transparan, yang akan kami regangkan untuk membentuk balok.  Setiap menara harus memiliki balok sendiri, jadi tambahkan ke prefab menara.  Tempatkan di dalam turret sehingga tersembunyi secara default dan berikan skala yang lebih kecil, misalnya 0,2.  Mari kita menjadikannya anak dari root prefab, bukan kubus menara. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19a/1dc/29e/19a1dc29e70adb158e07f29653db2d66.png" width="190" height="260" alt="sinar laser"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/273/081/45a273081365aa9e483f1aa97cbe39c8.png" width="226" height="108" alt="hierarki"></div><br>  <i>Kubus tersembunyi dari sinar laser.</i> <br><br>  Buat bahan yang cocok untuk sinar laser.  Saya hanya menggunakan bahan hitam tembus standar dan mematikan semua pantulan, dan juga memberinya warna merah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fb/e49/860/2fbe498604cc4cc4ed6ee60a45eea63d.png" width="320" height="284" alt="warna"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/b46/483/0ebb4648376a7fe68c96b7a16ce27db9.png" width="320" height="56" alt="tidak ada refleksi"></div><br>  <i>Bahan dari sinar laser.</i> <br><br>  Pastikan sinar laser tidak memiliki collider, dan matikan juga cast dan shadow-nya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecf/f21/0ad/ecff210ad75ef4b12cb0a74102365492.png" width="320" height="162"></div><br>  <i>Sinar laser tidak berinteraksi dengan bayangan.</i> <br><br>  Setelah menyelesaikan pembuatan prefab menara, kami akan menambahkannya ke pabrik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/626/37c/935/62637c9353cf1e20e170e82bbefcdb11.png" width="320" height="114"></div><br>  <i>Pabrik dengan menara.</i> <br><br><h3>  Penempatan menara </h3><br>  Kami akan menambah dan menghapus menara menggunakan metode switching lain.  Anda cukup menduplikasi <code>GameBoard.ToggleWall</code> dengan mengubah nama metode dan tipe konten. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower‚Ç¨) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower‚Ç¨); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } }</code> </pre> <br>  Di <code>Game.HandleTouch</code> , menahan tombol shift akan beralih menara daripada dinding. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { board.ToggleTower(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.ToggleWall(tile); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/926/804/2ac/9268042acc19a28d6ff1a6d74d83144f.png" width="230" height="230"></div><br>  <i>Menara di lapangan.</i> <br><br><h3>  Pemblokiran jalur </h3><br>  Sejauh ini, hanya dinding yang dapat menghalangi pencarian jalan, sehingga musuh bergerak melalui menara.  Mari kita tambahkan properti tambahan ke <code>GameTileContent</code> yang menunjukkan apakah konten memblokir jalan.  Jalan itu diblokir jika itu adalah dinding atau menara. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BlocksPath =&gt; Type == GameTileContentType.Wall || Type == GameTileContentType.Tower‚Ç¨;</code> </pre> <br>  Gunakan properti ini di <code>GameTile.GrowPathTo</code> alih-alih memeriksa jenis konten. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor, Direction direction</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">//neighbor.Content.Type != GameTileContentType.Wall ? neighbor : null; neighbor.Content.BlocksPath ? null : neighbor; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/93f/eed/6fa93feedb4925ee12decb4233612a4c.png" width="230" height="230"></div><br>  <i>Sekarang jalan terhalang oleh dinding dan menara.</i> <br><br><h3>  Pasang kembali dinding </h3><br>  Kemungkinan besar, pemain akan sering mengganti dinding dengan menara.  Ini akan merepotkan baginya untuk menghapus dinding terlebih dahulu, dan selain itu, musuh dapat menembus celah yang muncul sementara ini.  Anda dapat menerapkan penggantian langsung dengan memaksa <code>GameBoard.ToggleTower</code> untuk memeriksa apakah dinding saat ini ada di ubin.  Jika demikian, maka segera ganti dengan menara.  Dalam hal ini, kita tidak perlu mencari cara lain, karena ubin masih memblokirnya. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); } }</code> </pre> <br><h2>  Kami membidik musuh </h2><br>  Sebuah menara dapat memenuhi tugasnya hanya ketika menemukan musuh.  Setelah menemukan musuh, dia harus memutuskan bagian mana yang akan dibidik. <br><br><h3>  Membidik titik </h3><br>  Untuk mendeteksi target, kami akan menggunakan mesin fisika.  Seperti dalam kasus collider menara, kita tidak perlu collider musuh untuk bertepatan dengan bentuknya.  Anda dapat memilih collider yang paling sederhana, yaitu sphere.  Setelah mendeteksi musuh, kita akan menggunakan posisi objek permainan dengan collider yang melekat padanya sebagai titik untuk membidik. <br><br>  Kami tidak dapat melampirkan collider ke objek root musuh, karena itu tidak selalu bertepatan dengan posisi model dan akan membuat menara mengarah ke tanah.  Artinya, Anda perlu menempatkan collider di suatu tempat pada model.  Mesin fisika akan memberi kita tautan ke objek ini, yang dapat kita gunakan untuk membidik, tetapi kita masih membutuhkan akses ke komponen <code>Enemy</code> dari objek root.  Untuk menyederhanakan tugas, mari kita buat komponen <code>TargetPoint</code> .  Mari kita berikan properti untuk tugas pribadi dan penerimaan publik dari komponen <code>Enemy</code> , dan properti lain untuk mendapatkan posisinya di dunia. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TargetPoint</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Enemy Enemy‚Ç¨ { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Position =&gt; transform.position; }</code> </pre> <br>  Mari berikan metode <code>Awake</code> yang mengatur tautan ke komponen <code>Enemy</code> .  Langsung ke objek root menggunakan <code>transform.root</code> .  Jika komponen <code>Enemy</code> tidak ada, maka kami membuat kesalahan saat membuat musuh, jadi mari kita tambahkan pernyataan untuk ini. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy‚Ç¨ = transform.root.GetComponent&lt;Enemy&gt;(); Debug.Assert(Enemy‚Ç¨ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Selain itu, collider harus dilampirkan ke objek game yang sama dengan <code>TargetPoint</code> dilampirkan. <br><br><pre> <code class="cs hljs"> Debug.Assert(Enemy‚Ç¨ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Debug.Assert( GetComponent&lt;SphereCollider&gt;() != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without sphere collider!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> );</code> </pre> <br>  Tambahkan komponen dan collider ke kubus prefab musuh.  Ini akan membuat menara mengarah ke pusat kubus.  Kami menggunakan collider bola dengan jari-jari 0,25.  Kubus memiliki skala 0,5, sehingga radius sebenarnya dari collider adalah 0,125.  Berkat ini, musuh harus secara visual melintasi lingkaran jangkauan menara, dan hanya setelah beberapa waktu tujuan yang sebenarnya menjadi.  Ukuran collider juga dipengaruhi oleh skala acak musuh, sehingga ukurannya dalam game juga akan sedikit berbeda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85e/5ca/5e4/85e5ca5e47b8d59fa4211c78126bd512.png" width="176" height="176"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/a71/aec/7aea71aecbd64d4e045df141ecd1c711.png" width="320" height="176" alt="inspektur"></div><br>  <i>Musuh dengan titik bidik dan collider di kubus.</i> <br><br><h3>  Lapisan Musuh </h3><br>  Menara hanya peduli pada musuh, dan mereka tidak membidik yang lain, jadi kami akan menempatkan semua musuh di lapisan yang terpisah.  Kami akan menggunakan layer 9. Ubah namanya menjadi <em>Musuh</em> di jendela <em>Layers &amp; Tag</em> , yang dapat dibuka melalui opsi <em>Edit Layers</em> di menu drop-down <em>Layers</em> di sudut kanan atas editor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e6/9a5/762/8e69a5762e8eb1856175f9d9dc1ab388.png" width="320" height="308"></div><br>  <i>Layer 9 akan digunakan untuk musuh.</i> <br><br>  Lapisan ini diperlukan hanya untuk pengenalan musuh, dan bukan untuk interaksi fisik.  Mari kita tunjukkan dengan menonaktifkannya di <em>Layer Collision Matrix</em> , yang terletak di panel <em>Fisika</em> dari parameter proyek. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/876/06e/e7d/87606ee7dfc4777760d81219517125ce.png" width="200" height="200"></div><br>  <i>Matriks tabrakan lapisan.</i> <br><br>  Pastikan bahwa objek game dari titik bidik berada di lapisan yang diinginkan.  Sisa cetakan musuh mungkin ada di lapisan lain, tetapi akan lebih mudah untuk mengoordinasikan semuanya dan menempatkan seluruh cetakan di lapisan <em>Musuh</em> .  Jika Anda mengubah lapisan objek root, Anda akan diminta untuk mengubah lapisan untuk semua objek anaknya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/f75/062/6d1f75062420abadb285e9efca1e1a5e.png" width="320" height="44"></div><br>  <i>Musuh di lapisan kanan.</i> <br><br>  Mari kita tambahkan pernyataan bahwa <code>TargetPoint</code> benar-benar di lapisan kanan. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ Debug.Assert(gameObject.layer == <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point on wrong layer!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Selain itu, tindakan pemain harus diabaikan oleh collider musuh.  Ini bisa dicapai dengan menambahkan argumen layer mask ke <code>Physics.Raycast</code> di <code>GameBoard.GetTile</code> .  Metode ini memiliki bentuk yang mengambil jarak ke balok dan layer mask sebagai argumen tambahan.  Kami akan memberikan jarak maksimum dan layer mask secara default, yaitu 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.MaxValue, <span class="hljs-number"><span class="hljs-number">1</span></span>)) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Bukankah seharusnya layer mask menjadi 0?</b> <div class="spoiler_text">  Indeks lapisan default adalah nol, tapi kami melewati layer mask.  Topeng mengubah bit individu dari integer ke 1 jika lapisan perlu dihidupkan.  Dalam hal ini, Anda hanya perlu menetapkan bit pertama, yaitu yang paling signifikan, yang berarti 2 <sup>0</sup> , yang sama dengan 1. </div></div><br><h3>  Memperbarui Konten Ubin </h3><br>  Towers hanya dapat melakukan tugasnya ketika statusnya diperbarui.  Hal yang sama berlaku untuk isi seluruh ubin, meskipun sisanya tidak melakukan apa-apa sejauh ini.  Oleh karena itu, tambahkan metode virtual <code>GameUpdate</code> ke <code>GameUpdate</code> , yang tidak melakukan apa-apa secara default. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br>  Mari kita buat <code>Tower</code> mendefinisikan ulang, bahkan jika untuk saat ini hanya menampilkan di konsol bahwa ia sedang mencari target. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Searching for target..."</span></span>); }</code> </pre> <br>  <code>GameBoard</code> berurusan dengan ubin dan isinya, sehingga ia juga akan melacak konten apa yang perlu diperbarui.  Untuk melakukan ini, tambahkan daftar ke dalamnya dan metode <code>GameUpdate</code> publik, yang memperbarui semua yang ada dalam daftar. <br><br><pre> <code class="cs hljs"> List&lt;GameTileContent&gt; updatingContent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameTileContent&gt;(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; updatingContent.Count; i++) { updatingContent[i].GameUpdate(); } }</code> </pre> <br>  Dalam tutorial kami, Anda hanya perlu memperbarui menara.  Ubah <code>ToggleTower</code> sehingga menambah dan menghapus konten jika perlu.  Jika konten lain juga diperlukan, kami akan memerlukan pendekatan yang lebih umum, tetapi untuk saat ini, ini sudah cukup. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { updatingContent.Remove(tile.Content); tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower); <span class="hljs-comment"><span class="hljs-comment">//if (!FindPaths()) { if (FindPaths()) { updatingContent.Add(tile.Content); } else { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } else if (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); updatingContent.Add(tile.Content); } }</span></span></code> </pre> <br>  Untuk membuat ini berfungsi, sekarang cukup bagi kami untuk memperbarui bidang di <code>Game.Update</code> .  Kami akan memperbarui bidang setelah musuh.  Berkat ini, menara akan dapat mengarahkan tepat di mana musuh berada.  Jika kami melakukan sebaliknya, menara akan mengarah ke tempat musuh berada di bingkai terakhir. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.GameUpdate(); board.GameUpdate(); }</code> </pre> <br><h3>  Membidik jangkauan </h3><br>  Menara memiliki radius bidik terbatas.  Mari kita membuatnya khusus dengan menambahkan bidang ke kelas <code>Tower</code> .  Jarak diukur dari pusat ubin menara, jadi pada kisaran 0,5 hanya akan mencakup ubin sendiri.  Oleh karena itu, kisaran minimum dan standar yang masuk akal adalah 1,5, yang mencakup sebagian besar ubin tetangga. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1.5f, 10.5f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> targetingRange = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/ae4/ee8/c38ae4ee885cf5d89f24164b9c6bc5fe.png" width="320" height="74"></div><br>  <i>Membidik kisaran 2.5.</i> <br><br>  Mari memvisualisasikan rentang dengan alat.  Kita tidak perlu melihatnya terus-menerus, oleh karena itu kita akan membuat metode <code>OnDrawGizmosSelected</code> yang hanya dipanggil untuk objek yang dipilih.  Kami menggambar kerangka kuning bola dengan jari-jari yang sama dengan jarak dan terpusat relatif terhadap menara.  Tempatkan sedikit di atas tanah agar selalu terlihat jelas. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Gizmos.color = Color.yellow; Vector3 position = transform.localPosition; position.y += <span class="hljs-number"><span class="hljs-number">0.01f</span></span>; Gizmos.DrawWireSphere(position, targetingRange); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/6b7/3cd/6746b73cd2e015fd599b770bb89e1c8a.png" width="230" height="230"></div><br>  <i>Gizmo membidik jangkauan.</i> <br><br>  Sekarang kita bisa melihat musuh mana yang merupakan target yang terjangkau untuk masing-masing menara.  Tetapi memilih menara di jendela adegan tidak nyaman, karena kita harus memilih salah satu kubus anak, dan kemudian beralih ke objek root menara.  Jenis konten ubin lainnya juga mengalami masalah yang sama.  Kami dapat memaksa pemilihan akar konten <code>GameTileContent</code> di jendela adegan dengan menambahkan atribut <code>SelectionBase</code> ke <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SelectionBase</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ }</code> </pre> <br><h3>  Target penangkapan </h3><br>  Tambahkan bidang <code>TargetPoint</code> ke kelas <code>Tower</code> sehingga dapat melacak target yang ditangkap.  Kemudian kami <code>GameUpdate</code> untuk memanggil metode <code>AquireTarget</code> baru, yang mengembalikan informasi tentang apakah ia menemukan target.  Setelah terdeteksi, itu akan menampilkan pesan di konsol. <br><br><pre> <code class="cs hljs"> TargetPoint target; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Acquired target!"</span></span>); } }</code> </pre> <br>  Di <code>AcquireTarget</code> kami mendapatkan semua target yang tersedia dengan memanggil <code>Physics.OverlapSphere</code> dengan posisi menara dan rentang sebagai argumen.  Hasilnya akan menjadi array <code>Collider</code> berisi semua colliders yang bersentuhan dengan bola.  Jika panjang array positif, maka setidaknya ada satu titik tujuan, dan kami cukup memilih yang pertama.  Ambil komponen <code>TargetPoint</code> -nya, yang harus selalu ada, tetapkan ke bidang target dan laporkan keberhasilannya.  Kalau tidak, kami menghapus target dan melaporkan kegagalan. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targets.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targets[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targets[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Kami dijamin mendapatkan poin bidikan yang tepat, jika memperhitungkan colliders hanya pada lapisan musuh.  Ini adalah layer 9, jadi kami akan melewati layer mask yang sesuai. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enemyLayerMask = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange, enemyLayerMask ); ‚Ä¶ }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara kerja bitmask ini?</b> <div class="spoiler_text">  Karena layer musuh memiliki indeks 9, bit kesepuluh dari bitmask harus memiliki nilai 1. Ini terkait dengan bilangan bulat 2 <sup>9</sup> , yaitu 512. Tetapi catatan bitmask semacam itu tidak intuitif.  Kita juga dapat menulis biner literal, misalnya <code>0b10_0000_0000</code> , tetapi kemudian kita harus menghitung nol.  Dalam hal ini, entri yang paling mudah adalah menggunakan operator shift kiri <code>&lt;&lt;</code> , yang menggeser bit ke kiri.  yang sesuai dengan angka dalam kekuatan dua. </div></div><br>  Anda dapat memvisualisasikan target yang ditangkap dengan menggambar garis alat antara posisi menara dan target. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Gizmos.DrawLine(position, target.Position); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a5/e99/4be/7a5e994be6b7d848c2d4bfe7d627c708.png" width="230" height="230"></div><br>  <i>Visualisasi tujuan.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Mengapa tidak menggunakan metode seperti OnTriggerEnter?</b> <div class="spoiler_text">  Keuntungan dari memeriksa sasaran lintas sektor secara manual adalah bahwa kita hanya dapat melakukan ini bila perlu.  Tidak ada alasan untuk memeriksa target jika menara sudah memilikinya.  Selain itu, dengan memperoleh semua sasaran potensial sekaligus, kami tidak harus memproses daftar sasaran potensial untuk setiap menara, yang terus berubah. </div></div><br><h3>  Kunci Target </h3><br>  Target yang dipilih untuk ditangkap tergantung pada urutan di mana mereka diwakili oleh mesin fisik, yaitu, pada kenyataannya, itu sewenang-wenang.  Oleh karena itu, akan terlihat bahwa target yang ditangkap berubah tanpa alasan.  Setelah menara menerima target, lebih logis baginya untuk melacaknya, dan tidak beralih ke yang lain.  Tambahkan metode <code>TrackTarget</code> yang mengimplementasikan pelacakan seperti itu dan mengembalikan informasi tentang apakah itu berhasil.  Pertama, kami akan memberi tahu Anda jika target ditangkap. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Kami akan memanggil metode ini di <code>GameUpdate</code> dan hanya ketika mengembalikan false kita akan memanggil <code>AcquireTarget</code> .  Jika metode itu kembali benar, maka kita memiliki tujuan.  Ini dapat dilakukan dengan menempatkan kedua pemanggilan metode dalam cek <code>if</code> dengan operator ATAU, karena jika operan pertama mengembalikan <code>true</code> , yang kedua tidak akan diperiksa, dan panggilan akan dilewatkan.  Operator AND bertindak dengan cara yang sama. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Locked on target!"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ec/27c/0a2/8ec27c0a2201434cba3725621b68aaa1.png" width="230" height="230"></div><br>  <i>Melacak sasaran.</i> <br><br>  Akibatnya, menara ditetapkan pada target sampai mencapai titik akhir dan dihancurkan.  Jika Anda menggunakan musuh berulang kali, maka alih-alih Anda perlu memeriksa kebenaran tautan, seperti yang dilakukan dengan tautan ke angka yang diproses dalam serangkaian tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Manajemen Objek</a> . <br><br>  Untuk melacak target hanya ketika berada dalam jangkauan, <code>TrackTarget</code> harus melacak jarak antara menara dan target.  Jika melebihi nilai kisaran, maka target harus diatur ulang dan kembali salah.  Anda dapat menggunakan metode <code>Vector3.Distance</code> untuk pemeriksaan ini. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Namun, kode ini tidak memperhitungkan radius collider.  Karena itu, sebagai akibatnya, menara mungkin kehilangan target, lalu menangkapnya lagi, hanya untuk berhenti melacaknya di frame berikutnya, dan seterusnya.  Kita dapat menghindari ini dengan menambahkan radius collider ke rentang. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span>) { ‚Ä¶ }</code> </pre> <br>  Ini memberi kita hasil yang benar, tetapi hanya jika skala musuh tidak berubah.  Karena kami memberikan skala acak kepada setiap musuh, kami harus memperhitungkannya saat mengubah kisaran.  Untuk melakukan ini, kita perlu mengingat skala yang diberikan oleh <code>Enemy</code> dan membukanya menggunakan properti pengambil. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Scale { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { Scale = scale; ‚Ä¶ }</code> </pre> <br>  Sekarang kita dapat memeriksa rentang yang benar di <code>Tower.TrackTarget</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy‚Ç¨.Scale) { ‚Ä¶ }</code> </pre> <br><h3>  Kami menyinkronkan fisika </h3><br>  Semuanya tampak berfungsi dengan baik, tetapi menara yang bisa mengarah ke tengah lapangan mampu menangkap target yang seharusnya berada di luar jangkauan.  Mereka tidak akan dapat melacak tujuan-tujuan ini, sehingga mereka hanya menetapkannya untuk satu frame. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e91/0a1/836/e910a1836ef729d95ebee121a67c3f2c.png" width="230" height="230"></div><br>  <i>Membidik salah.</i> <br><br>  Ini terjadi karena keadaan mesin fisik tidak sempurna disinkronkan dengan keadaan permainan.  Contoh dari semua musuh diciptakan pada asal usul dunia, yang bertepatan dengan pusat lapangan.  Kemudian kita memindahkan mereka ke titik penciptaan, tetapi mesin fisika tidak langsung mengetahuinya. <br><br>  Anda dapat mengaktifkan sinkronisasi sesaat yang terjadi ketika Anda mengubah transformasi objek dengan mengatur <code>Physics.autoSyncTransforms</code> menjadi <code>true</code> .  Tetapi secara default dinonaktifkan, karena jauh lebih efisien untuk menyinkronkan semuanya bersama-sama dan jika perlu.  Dalam kasus kami, sinkronisasi hanya diperlukan saat memperbarui status menara.  Kita bisa menjalankannya dengan memanggil <code>Physics.SyncTransforms</code> antara musuh dan pembaruan bidang di <code>Game.Update</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.GameUpdate(); Physics.SyncTransforms(); board.GameUpdate(); }</code> </pre> <br><h3>  Abaikan ketinggian </h3><br>  Faktanya, gameplay kami berlangsung dalam 2D.  Jadi mari kita ubah <code>Tower</code> sehingga ketika membidik dan melacak hanya memperhitungkan koordinat X dan Z. Mesin fisik bekerja dalam ruang 3D, tetapi pada dasarnya kita dapat melakukan <code>AcquireTarget</code> dalam 2D: rentangkan bola sehingga mencakup semua colliders, terlepas dari dari posisi vertikal mereka.  Ini dapat dilakukan dengan menggunakan kapsul alih-alih bola, titik kedua di mana akan menjadi beberapa unit di atas tanah (misalnya, tiga). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">3f</span></span>; Collider[] targets = Physics.OverlapCapsule( a, b, targetingRange, enemyLayerMask ); ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah tidak mungkin menggunakan mesin 2D fisik?</font></font></b> <div class="spoiler_text">   ,       XZ,   2D-    XY.     ,     ,    2D-   .     3D-. </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga perlu untuk berubah </font></font><code>TrackTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tentu saja, kita dapat menggunakan vektor 2D dan </font></font><code>Vector2.Distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi mari kita lakukan perhitungan sendiri dan alih-alih kita akan membandingkan kuadrat jarak, ini sudah cukup. </font><font style="vertical-align: inherit;">Jadi kita menyingkirkan operasi penghitungan akar kuadrat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = ax - bx; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = az - bz; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy‚Ç¨.Scale; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x * x + z * z &gt; r * r) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana cara perhitungan matematika ini bekerja?</font></font></b> <div class="spoiler_text">     2D-   ,     .     ,       .  ,        ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hindari alokasi memori </font></font></h3><br>   <code>Physics.OverlapCapsule</code>   ,        .   ,         <code>OverlapCapsuleNonAlloc</code>      .       .       .        ,      1. <br><br>   <code>OverlapCapsuleNonAlloc</code>    ,    ,          . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">1</span></span>]; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hits = Physics.OverlapCapsuleNonAlloc( a, b, targetingRange, targetsBuffer, enemyLayerMask ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h2>    </h2><br> ,      ,     .    ,     . <br><br><h3>   </h3><br>     ,  <code>Tower</code>      <code>Transform</code> .           . <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/3be/41b/e0f3be41b0936993268316b8f01e1f67.png" width="320" height="90"></div><br> <i> .</i> <br><br>   <code>GameUpdate</code>   ,      .      .       ,    <code>Transform.LookAt</code>      . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { <span class="hljs-comment"><span class="hljs-comment">//Debug.Log("Locked on target!"); Shoot(); } } void Shoot () { Vector3 point = target.Position; turret.LookAt(point); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/5bb/e9d/00e5bbe9d98e739800bf47435ca574af.png" width="230" height="230"></div><br> <i> .</i> <br><br><h3>   </h3><br>      <code>Tower</code>     . <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, laserBeam = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/c9c/86e/802c9c86eac24112cb2b4f072fd0f410.png" width="320" height="110"></div><br> <i>  .</i> <br><br>       ,    . -,      .   ,   . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua, kami skala sinar laser sehingga panjangnya sama dengan jarak antara titik asal lokal menara dan titik tujuan. </font><font style="vertical-align: inherit;">Kami skala di sepanjang sumbu Z, yaitu, sumbu lokal diarahkan ke target. </font><font style="vertical-align: inherit;">Untuk mempertahankan skala XY asli, kami menuliskan skala aslinya ketika kami membangun menara Awake.</font></font><br><br><pre> <code class="cs hljs"> Vector3 laserBeamScale; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { laserBeamScale = laserBeam.localScale; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = Vector3.Distance(turret.position, point); laserBeamScale.z = d; laserBeam.localScale = laserBeamScale; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ketiga, kami menempatkan sinar laser di tengah-tengah antara menara dan titik tujuan. </font></font><br><br><pre> <code class="cs hljs"> laserBeam.localScale = laserBeamScale; laserBeam.localPosition = turret.localPosition + <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * d * laserBeam.forward;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/288/d96/438/288d96438354bd732fd7a3bb84ead491.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penembakan laser.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah tidak mungkin membuat sinar laser menjadi anak menara?</font></font></b> <div class="spoiler_text">     ,         ,       forward.       ,     .     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini berfungsi saat turet ditetapkan pada target. </font><font style="vertical-align: inherit;">Tetapi ketika tidak ada target, laser tetap aktif. </font><font style="vertical-align: inherit;">Kita dapat mematikan layar laser dengan </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengatur </font><font style="vertical-align: inherit;">skalanya ke </font><font style="vertical-align: inherit;">0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Shoot(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { laserBeam.localScale = Vector3.zero; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/8c8/c23/39b8c8c239e0936137c646f91a4197de.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menara siaga tidak menyala.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesehatan Musuh </font></font></h3><br>              .   ,     .      ,   <code>Enemy</code>  .       ,    100.   ,       ,     . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Health { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Health = <span class="hljs-number"><span class="hljs-number">100f</span></span> * scale; }</code> </pre> <br>     ,    <code>ApplyDamage</code> ,     .   ,   ,     . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyDamage</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> damage</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(damage &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-string"><span class="hljs-string">"Negative damage applied."</span></span>); Health -= damage; }</code> </pre> <br>       ,      .           <code>GameUpdate</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Health &lt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berkat ini, semua menara pada dasarnya akan menembak secara bersamaan, dan tidak pada gilirannya, yang akan memungkinkan mereka untuk beralih ke target lain jika menara sebelumnya menghancurkan musuh, yang juga mereka tuju. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kerusakan per detik </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita perlu menentukan berapa banyak kerusakan yang akan dilakukan laser. </font><font style="vertical-align: inherit;">Untuk melakukan ini, tambahkan ke </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bidang konfigurasi. </font><font style="vertical-align: inherit;">Karena sinar laser memberikan kerusakan terus-menerus, kami akan menyatakannya sebagai kerusakan per detik. </font><font style="vertical-align: inherit;">Kami </font></font><code>Shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menerapkannya pada komponen </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">target dengan penggandaan pada waktu delta.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1f, 100f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> damagePerSecond = <span class="hljs-number"><span class="hljs-number">10f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ target.Enemy.ApplyDamage(damagePerSecond * Time.deltaTime); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/886/18f/199/88618f199c9c08e7eaeb89b16083f545.png" width="320" height="128" alt="inspektur"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/vt/sf/gkvtsfa1ya4igbsjagqhtnzu0wq.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kerusakan setiap menara adalah 20 unit per detik.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membidik acak </font></font></h3><br>        ,     ,       .     ,      ,    ,         .       ,     . <br><br>  ,      ,    .   ,     ,   100. ,              ,       . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">100</span></span>];</code> </pre> <br>             . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, hits)].GetComponent&lt;TargetPoint&gt;(); ‚Ä¶ } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/lt/hi/nvlthij_ixh6lsxgwujtoipjwg4.gif"></div><br> <i> .</i> <br><br><div class="spoiler"> <b class="spoiler_title">       ?</b> <div class="spoiler_text"> , ,        .  ,      ,     .    .             . </div></div><br> ,     ¬´ ¬ª -  .          . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459070/">https://habr.com/ru/post/id459070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459052/index.html">Cara membandingkan: "mobil luar biasa" dan "gubuk jelek", dalam survei pemasaran dan dalam data besar</a></li>
<li><a href="../id459054/index.html">Heatmap of klik - bagaimana perilaku pengguna di situs</a></li>
<li><a href="../id459062/index.html">Intisari materi menarik untuk pengembang seluler # 305 (pada 1 - 7 Juli)</a></li>
<li><a href="../id459066/index.html">Database menulis dan membaca balancing</a></li>
<li><a href="../id459068/index.html">Windows Server 2008 R2 - Sang Raja Mati, Hidup Sang Raja</a></li>
<li><a href="../id459074/index.html">Petty little joy # 7: three untuk harga satu konsol animasi, algoritma dan debugging</a></li>
<li><a href="../id459078/index.html">CERN beralih ke perangkat lunak sumber terbuka - mengapa?</a></li>
<li><a href="../id459080/index.html">Fitur HttpUrlConnection dari java.net</a></li>
<li><a href="../id459082/index.html">Siapa eidetik, bagaimana ingatan salah bekerja, dan tiga mitos populer tentang ingatan</a></li>
<li><a href="../id459084/index.html">Sedikit tentang Google Home Hub, atau bagaimana saya membeli bingkai foto seharga 130 Euro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>