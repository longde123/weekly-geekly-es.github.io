<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏡 💩 🔋 Linux虚拟接口简介：隧道 👩🏿‍🎨 🚯 📏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Linux支持多种类型的隧道。 这使初学者感到困惑，他们难以理解技术的差异，也难以理解在特定情况下哪种隧道更适合使用。 我们今天出版的翻译材料将简要概述Linux内核的常用隧道接口。 我们不会深入研究这个主题，仅考虑隧道的一般功能以及在Linux中使用隧道的选项。 

  

 该材料的作者认为，此...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux虚拟接口简介：隧道</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/457386/"> Linux支持多种类型的隧道。 这使初学者感到困惑，他们难以理解技术的差异，也难以理解在特定情况下哪种隧道更适合使用。 我们今天出版的翻译材料将简要概述Linux内核的常用隧道接口。 我们不会深入研究这个主题，仅考虑隧道的一般功能以及在Linux中使用隧道的选项。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/-0/wg/hq/-0wghqvj6hymntfthlttl1xu6tm.jpeg"></a> <br><br> 该材料的作者认为，此处讨论的内容可能与管理计算机网络有关的每个人都感兴趣。 可以使用iproute2 <code>ip link help</code>命令获取隧道接口列表以及有关特定配置的参考信息。 <br><br> 以下将介绍以下常用接口：IPIP，SIT，ip6tnl，VTI和VTI6，GRE和GRETAP，GRE6和GRE6TAP，FOU，GUE，GENEVE，ERSPAN和IP6ERSPAN。 <br><br> 阅读本文之后，您将了解这些接口的功能并找出它们之间的区别。 您将学习如何创建它们以及如何最好地使用它们。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">IPIP</font> </h2><br> 顾名思义，IPIP隧道是以IP over IP模式（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 2003</a> ）运行的隧道。  IPIP隧道数据包头如下所示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/369/49b/92c/36949b92c3d045185f09095a7a23dbfd.png"></div><br>  <i><font color="#999999">IPIP隧道数据包头</font></i> <br><br> 此类隧道通常用于通过公共IPv4网络（Internet）连接两个内部IPv4子网。  IPIP的使用在系统上产生了最小的额外负载，但是在这种隧道上只能执行单向数据传输（单播）。 即，已经建立了这样的隧道，将不可能将其用于多播数据传输。 <br><br>  IPIP隧道支持IP over IP和MPLS over IP模式。 <br><br> 请注意，在加载ipip模块或首次创建IPIP设备时，Linux内核将在每个名称空间中使用<code>local=any</code>和<code>remote=any</code>属性创建默认的<code>tunl0</code>设备。 在某些情况下，内核在接收IPIP数据包时会将其重定向到<code>tunl0</code>作为默认设备。 当内核找不到另一个<code>local/remote</code>属性与数据包的源地址和目标地址更匹配的设备时，就会发生这种情况。 <br><br> 创建IPIP隧道的方法如下： <br><br> 在服务器A上： <br><br><pre> <code class="plaintext hljs"># ip link add name ipip0 type ipip local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR # ip link set ipip0 up # ip addr add INTERNAL_IPV4_ADDR/24 dev ipip0 Add a remote internal subnet route if the endpoints don't belong to the same subnet # ip route add REMOTE_INTERNAL_SUBNET/24 dev ipip0</code> </pre> <br> 在服务器B上： <br><br><pre> <code class="plaintext hljs"># ip link add name ipip0 type ipip local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR # ip link set ipip0 up # ip addr add INTERNAL_IPV4_ADDR/24 dev ipip0 # ip route add REMOTE_INTERNAL_SUBNET/24 dev ipip0</code> </pre> <br> 请注意，使用此配置时，必须使其与真实数据保持一致。 特别是， <code>LOCAL_IPv4_ADDR</code> ， <code>REMOTE_IPv4_ADDR</code> ， <code>INTERNAL_IPV4_ADDR</code>和<code>REMOTE_INTERNAL_SUBNET</code>需要替换为您环境中使用的地址。 对于其他配置示例也是如此，我们将在后面讨论。 <br><br><h2>  <font color="#3AC1EF">坐</font> </h2><br>  SIT（简单Internet转换）是一种隧道技术，其主要目的是使用IPv4协议通过Internet连接隔离的IPv6网络。 <br><br> 最初，SIT技术只能在“ IPv6 over IPv4”隧道模式下工作。 但是，经过多年的发展，它已经获得了更多政权的支持。 特别是<code>ipip</code> （IPIP隧道也发生了同样的事情）， <code>ip6ip</code> ， <code>mplsip</code>和<code>any</code> 。 <br><br>  <code>any</code>模式都可用于处理IP和IPv6流量，这在某些情况下可能很有用。  SIT隧道还支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ISATAP</a> 。 这是使用此技术<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的示例</a> 。 <br><br>  SIT数据包的标头如下所示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/193/172/49e/19317249ec76200873dabf9aac6bc755.png"></div><br>  <i><font color="#999999">SIT隧道数据包头</font></i> <br><br> 当<code>sit</code>模块加载时，Linux内核会创建默认<code>sit0</code> 。 <br><br> 这是创建SIT隧道的方法（这些步骤必须在服务器A和B上执行）： <br><br><pre> <code class="plaintext hljs"># ip link add name sit1 type sit local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR mode any # ip link set sit1 up # ip addr add INTERNAL_IPV4_ADDR/24 dev sit1</code> </pre> <br><h2>  <font color="#3AC1EF">ip6tnl</font> </h2><br>  ip6tnl接口可在IPv4 / IPv6 over IPv6模式下工作。 它类似于SIT隧道的IPv6版本。 这就是ip6tnl包标头的样子。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e7/b3b/1b6/9e7b3b1b6862d0f3100c9c64db2171b7.png"></div><br>  <i><font color="#999999">ip6tnl隧道数据包头</font></i> <br><br>  ip6tnl隧道支持<code>ip6ip6</code> ， <code>ipip6</code>和<code>any</code>模式。  <code>ipip6</code>模式由IPv4 over IPv6方案表示， <code>ip6ip6</code>模式是IPv6 over IPv6。  <code>any</code>模式都支持两种方案。 <br><br>  <code>ip6tnl</code>模块<code>ip6tnl</code> ，Linux内核会创建一个名为<code>ip6tnl0</code>的默认设备。 <br><br> 以下是创建ip6tnl隧道的方法： <br><br><pre> <code class="plaintext hljs"># ip link add name ipip6 type ip6tnl local LOCAL_IPv6_ADDR remote REMOTE_IPv6_ADDR mode any</code> </pre> <br><h2>  <font color="#3AC1EF">VTI和VTI6</font> </h2><br>  Linux VTI（虚拟隧道接口）接口类似于Cisco VTI接口和安全隧道（st.xx）的Juniper实施。 <br><br> 此隧道驱动程序实现IP封装，可与xfrm一起使用以创建安全隧道，然后在此类隧道上使用内核级路由隧道。 <br><br> 通常，VTI隧道的工作方式与IPIP或SIT隧道非常相似。 例外是它们使用fwmark和IPsec封装/解封装。 <br><br>  VTI6是VTI的IPv6等效项。 <br><br> 以下是创建VTI隧道的方法： <br><br><pre> <code class="plaintext hljs"># ip link add name vti1 type vti key VTI_KEY local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR # ip link set vti1 up # ip addr add LOCAL_VIRTUAL_ADDR/24 dev vti1 # ip xfrm state add src LOCAL_IPv4_ADDR dst REMOTE_IPv4_ADDR spi SPI PROTO ALGR mode tunnel # ip xfrm state add src REMOTE_IPv4_ADDR dst LOCAL_IPv4_ADDR spi SPI PROTO ALGR mode tunnel # ip xfrm policy add dir in tmpl src REMOTE_IPv4_ADDR dst LOCAL_IPv4_ADDR PROTO mode tunnel mark VTI_KEY # ip xfrm policy add dir out tmpl src LOCAL_IPv4_ADDR dst REMOTE_IPv4_ADDR PROTO mode tunnel mark VTI_KEY</code> </pre> <br> 另外，可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">libreswan</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">strongSwan</a>配置IPsec。 <br><br><h2>  <font color="#3AC1EF">GRE和GRETAP</font> </h2><br>  GRE（通用路由封装）技术在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC 2784中​​进行了</a>描述。 在GRE隧道中，在内部和外部IP数据包的标头之间添加了一个额外的GRE标头。 <br><br> 从理论上讲，GRE可以封装具有有效以太网类型的任何第3层协议的数据包。 这将GRE技术与IPIP技术区分开来，后者仅支持IP数据包的封装。 这是使用GRE技术时包头的外观。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22d/b74/b09/22db74b090586084bfe845c7df963139.png"></div><br>  <i><font color="#999999">GRE隧道报文头</font></i> <br><br> 请注意，GRE隧道允许多播和IPv6支持。 <br><br> 加载<code>gre</code>模块时，Linux内核会创建默认<code>gre0</code> 。 <br><br> 以下是创建GRE隧道的方法： <br><br><pre> <code class="plaintext hljs"># ip link add name gre1 type gre local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR [seq] key KEY</code> </pre> <br>  GRE隧道在OSI层3上运行，而GRETAP隧道在OSI层2上运行。 这意味着各个数据包的内部头之一是以太网头。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1da/ec8/099/1daec8099c6cede117df740da4791144.png"></div><br>  <i><font color="#999999">GRETAP隧道包头</font></i> <br><br> 以下是创建GRETAP隧道的方法： <br><br><pre> <code class="plaintext hljs"># ip link add name gretap1 type gretap local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR</code> </pre> <br><h2>  <font color="#3AC1EF">GRE6和GRE6TAP</font> </h2><br>  GRE6是GRE的IPv6等效项。  GRE6隧道使您可以将任何第3层协议封装在IPv6中。 这就是GRE6包标头的样子。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8c/69e/45a/d8c69e45aab1f77ea5948cf2a6e81c35.png"></div><br>  <i><font color="#999999">GRE6隧道包头</font></i> <br><br> 与GRETAP隧道一样，在GRE6TAP隧道中，内部数据包头中也有以太网头。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72c/290/7c7/72c2907c7c649e6390d1e51156bcac57.png"></div><br>  <i><font color="#999999">GRE6TAP隧道包头</font></i> <br><br> 以下是创建GRE隧道的方法： <br><br><pre> <code class="plaintext hljs"># ip link add name gre1 type gre6 local LOCAL_IPv6_ADDR remote REMOTE_IPv6_ADDR # ip link add name gretap1 type gretap6 local LOCAL_IPv6_ADDR remote REMOTE_IPv6_ADDR</code> </pre> <br><h2>  <font color="#3AC1EF">ou</font> </h2><br> 可以在网络堆栈的不同级别执行隧道。  IP层存在IPIP，SIT和GRE隧道。  FOU隧道（根据“ foo over UDP”方案安排）在UDP级别上运行。 <br><br> 通过IP隧道使用UDP隧道有一些优势。 事实是UDP协议可与现有的硬件基础结构一起使用。 <br><br> 例如，这是网卡中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RSS</a> ，交换机中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ECMP</a> ，这些是无需中央处理器参与即可计算校验和的技术。 将适当的FOU <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">修补程序</a>应用到开发人员，可以显着提高SIT和IPIP的性能。 <br><br> 当前，FOU隧道支持基于IPIP，SIT和GRE的协议封装。 这是FOU包标头的样子。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90d/a66/cb9/90da66cb92c6e3083f29ed97b952e0b6.png"></div><br>  <i><font color="#999999">FOU隧道包头</font></i> <br><br> 这是创建FOU隧道的方法： <br><br><pre> <code class="plaintext hljs"># ip fou add port 5555 ipproto 4 # ip link add name tun1 type ipip remote 192.168.1.1 local 192.168.1.2 ttl 225 encap fou encap-sport auto encap-dport 5555</code> </pre> <br> 第一条命令为绑定到5555的IPIP配置接收FOU端口。要使用GRE，需要使用<code>ipproto 47</code> 。 第二个命令配置新的虚拟IPIP接口（ <code>tun1</code> ），该接口专为FOU封装而设计，其目标端口为5555。 <br><br> 请注意，红帽企业版Linux不支持FOU隧道。 <br><br><h2>  <font color="#3AC1EF">ue</font> </h2><br>  GUE（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通用UDP封装</a> ）技术引入了另一种类型的UDP隧道。  FOU和GUE之间的区别在于GUE具有自己的标头，其中包含协议信息和其他数据。 <br><br>  GUE隧道当前支持IPIP，SIT和GRE的内部封装。 这就是GUE包标头的样子。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/412/d7f/d38/412d7fd38350aa55b24cb0b93865d93c.png"></div><br>  <i><font color="#999999">GUE隧道包标题</font></i> <br><br> 以下是创建GUE隧道的方法： <br><br><pre> <code class="plaintext hljs"># ip fou add port 5555 gue # ip link add name tun1 type ipip remote 192.168.1.1 local 192.168.1.2 ttl 225 encap gue encap-sport auto encap-dport 5555</code> </pre> <br> 由于这些命令，将创建绑定到5555号码的IPIP接收GUE端口和为GUE封装配置的IPIP隧道。 <br><br> 红帽企业版Linux不支持GUE隧道。 <br><br><h2>  <font color="#3AC1EF">给予</font> </h2><br>  GENEVE隧道（通用网络虚拟化封装）支持XLAN，NVGRE和STT的所有功能。  GENEVE技术旨在规避这三种技术的已确定限制。 许多人认为，从长远来看，这项技术能够完全替代这三种旧格式。 这是GENEVE隧道数据包标头的样子。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/767/f30/98e/767f3098ee539caf3f03778143fa6106.png"></div><br>  <i><font color="#999999">GENEVE隧道包头</font></i> <br><br> 此标头类似于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VXLAN</a>数据包的标头。 两者之间的主要区别是GENEVE标头更灵活。 通过使用Type-Length-Value（TLV）字段扩展标头，可以非常轻松地实现新功能。 <br><br> 有关GENEVE的详细信息可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到。 <br><br>  GENEVE在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开放式虚拟网络</a> （OVN）SDN解决方案中用作标准封装工具。 以下是创建GENEVE隧道的方法： <br><br><pre> <code class="plaintext hljs"># ip link add name geneve0 type geneve id VNI remote REMOTE_IPv4_ADDR</code> </pre> <br><h2>  <font color="#3AC1EF">ERSPAN和IP6ERSPAN</font> </h2><br> 封装的远程交换端口分析器（ERSPAN）技术使用GRE封装将端口镜像的基本功能从第2层扩展到第3层。 这使您可以通过路由的IP网络转发镜像流量。 这就是ERSPAN包标头的样子。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dee/15d/871/dee15d871a6ee9d433f154b9a6a6e048.png"></div><br>  <i><font color="#999999">ERSPAN隧道包头</font></i> <br><br>  ERSPAN隧道允许Linux主机充当ERSPAN流量源，并将镜像的ERSPAN流量发送到远程主机或ERSPAN目的地，该目的地接收和处理由Cisco交换机或其他支持ERSPAN的设备生成的ERSPAN数据包。 可以使用类似的系统来分析和诊断网络，以检测恶意流量。 <br><br>  Linux当前支持ERSPAN的两个版本的大多数功能-v1（类型II）和v2（类型III）。 <br><br> 以下是创建ERSPAN隧道的方法： <br><br><pre> <code class="plaintext hljs"># ip link add dev erspan1 type erspan local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR seq key KEY erspan_ver 1 erspan IDX</code> </pre> <br> 您也可以这样做： <br><br><pre> <code class="plaintext hljs"># ip link add dev erspan1 type erspan local LOCAL_IPv4_ADDR remote REMOTE_IPv4_ADDR seq key KEY erspan_ver 2 erspan_dir DIRECTION erspan_hwid HWID</code> </pre> <br> 添加一个tc过滤器以监控流量： <br><br><pre> <code class="plaintext hljs"># tc qdisc add dev MONITOR_DEV handle ffff: ingress # tc filter add dev MONITOR_DEV parent ffff: matchall skip_hw action mirred egress mirror dev erspan1</code> </pre> <br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 我们在这里介绍了Linux中的许多隧道技术。 这是它们的摘要表。 <br><br><div class="scrollable-table"><table><tbody><tr><td> 隧道/连接类型 <br></td><td> 外头 <br></td><td> 封装头 <br></td><td> 内页眉 <br></td></tr><tr><td>  ipip <br></td><td>  IPv4 <br></td><td> 无 <br></td><td>  IPv4 <br></td></tr><tr><td> 坐下 <br></td><td>  IPv4 <br></td><td> 无 <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  ip6tnl <br></td><td>  IPv4 <br></td><td> 无 <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  vti <br></td><td>  IPv4 <br></td><td> 安全协议 <br></td><td>  IPv4 <br></td></tr><tr><td>  vti6 <br></td><td>  IPv6 <br></td><td> 安全协议 <br></td><td>  IPv6 <br></td></tr><tr><td> 格蕾 <br></td><td>  IPv4 <br></td><td>  GRE <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td> 格列塔普 <br></td><td>  IPv4 <br></td><td>  GRE <br></td><td> 以太网+ IPv4 / IPv6 <br></td></tr><tr><td>  gre6 <br></td><td>  IPv6 <br></td><td>  GRE <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  gre6tap <br></td><td>  IPv6 <br></td><td>  GRE <br></td><td> 以太网+ IPv4 / IPv6 <br></td></tr><tr><td>  ou <br></td><td>  IPv4 / IPv6 <br></td><td>  UDP协议 <br></td><td>  IPv4 / IPv6 / GRE <br></td></tr><tr><td>  gue <br></td><td>  IPv4 / IPv6 <br></td><td>  UDP + GUE <br></td><td>  IPv4 / IPv6 / GRE <br></td></tr><tr><td> 日内瓦 <br></td><td>  IPv4 / IPv6 <br></td><td>  UDP +日内瓦 <br></td><td> 以太网+ IPv4 / IPv6 <br></td></tr><tr><td> 尔斯潘 <br></td><td>  IPv4 <br></td><td>  GRE + ERSPAN <br></td><td>  IPv4 / IPv6 <br></td></tr><tr><td>  ip6erspan <br></td><td>  IPv6 <br></td><td>  GRE + ERSPAN <br></td><td>  IPv4 / IPv6 <br></td></tr></tbody></table></div><br> 请注意，所有隧道（在此处显示其创建示例）仅在重新启动服务器之前存在。 如果要创建在重新引导后恢复的隧道，请考虑使用守护程序来配置网络，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NetworkManager</a> ，或使用所使用的Linux发行版中的适当机制。 <br><br>  <b>亲爱的读者们！</b> 您使用什么Linux隧道？ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN457386/">https://habr.com/ru/post/zh-CN457386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN457366/index.html">狂热者，铁杆或观众-您是哪种游戏玩家？</a></li>
<li><a href="../zh-CN457374/index.html">减少您的Android项目的构建时间</a></li>
<li><a href="../zh-CN457378/index.html">id Software如何根据Commander Keen的技术创建Wolfenstein 3D</a></li>
<li><a href="../zh-CN457380/index.html">超现代的OpenGL。 第二部分</a></li>
<li><a href="../zh-CN457382/index.html">高性能程序员的7个习惯</a></li>
<li><a href="../zh-CN457390/index.html">马达加斯加-对比之岛</a></li>
<li><a href="../zh-CN457392/index.html">节省移动跨平台开发费用：Skyeng案例研究</a></li>
<li><a href="../zh-CN457396/index.html">热启动后自动解锁根LUKS容器</a></li>
<li><a href="../zh-CN457398/index.html">但是我在胡说八道吗？ 开发人员为什么要去gemba</a></li>
<li><a href="../zh-CN457400/index.html">戏剧性的场面大大夸大了切尔诺贝利这类核灾难的受害者人数</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>