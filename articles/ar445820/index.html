<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚻 🙍🏾 #⃣ MVCC-3. إصدارات الصف 📠 🤟🏿 🧠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="لذلك ، نظرنا في القضايا المتعلقة بالعزلة وقمنا بتراجع حول تنظيم البيانات على مستوى منخفض . وأخيرا حصلت على الأكثر إثارة للاهتمام - إلى إصدار الخطوط. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-3. إصدارات الصف</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/445820/" style=";text-align:right;direction:rtl">  لذلك ، نظرنا في القضايا المتعلقة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بالعزلة</a> وقمنا بتراجع حول <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تنظيم البيانات على مستوى منخفض</a> .  وأخيرا حصلت على الأكثر إثارة للاهتمام - إلى إصدار الخطوط. <br><br><h1 style=";text-align:right;direction:rtl">  رأس </h1><br>  كما قلنا من قبل ، يمكن أن يتواجد كل صف في وقت واحد في قاعدة البيانات في عدة إصدارات.  يجب تمييز إصدار واحد عن الآخر بطريقة أو بأخرى ، ولهذا الغرض ، يحتوي كل إصدار على علامتين تحددان "وقت" إجراء هذا الإصدار (xmin و xmax).  في علامات اقتباس - لأنه ليس الوقت الذي يتم استخدامه على هذا النحو ، ولكن عداد متزايد خاص.  وهذا العداد هو رقم المعاملة. <br><br>  (كالعادة ، يكون الأمر أكثر تعقيدًا في الواقع: لا يمكن أن يزيد رقم المعاملة طوال الوقت نظرًا لقدرته المحدودة على العداد. لكننا سننظر في هذه التفاصيل بالتفصيل عندما نصل إلى مرحلة التجميد.) <br><a name="habracut"></a><br>  عند إنشاء السطر ، يتم تعيين xmin على رقم المعاملة التي نفذت أمر INSERT ، ولم يتم ملء xmax. <br><br>  عند حذف صف ، يتم تمييز قيمة xmax الخاصة بالإصدار الحالي برقم المعاملة الذي أجرى DELETE. <br><br>  عند تعديل سطر باستخدام الأمر UPDATE ، يتم تنفيذ عمليتين بالفعل: DELETE و INSERT.  في الإصدار الحالي من السطر ، يتم تعيين xmax مساوًا لعدد المعاملة التي أجريت UPDATE.  ثم يتم إنشاء نسخة جديدة من نفس الخط ؛  تتطابق قيمة xmin مع قيمة xmax الخاصة بالإصدار السابق. <br><br>  يتم تضمين حقول xmin و xmax في رأس إصدار الصف.  بالإضافة إلى هذه الحقول ، يحتوي الرأس على مجالات أخرى ، على سبيل المثال: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  infomask - سلسلة من البتات التي تحدد خصائص هذا الإصدار.  هناك الكثير منهم ؛  أهمها سوف ننظر تدريجيا. </li><li style=";text-align:right;direction:rtl">  ctid - رابط إلى الإصدار الأحدث ، التالي من نفس السطر.  في الإصدار الأحدث ، الأحدث من السلسلة ، يشير ctid إلى هذا الإصدار نفسه.  يحتوي الرقم على النموذج (x ، y) ، حيث يمثل x رقم الصفحة ، y هو الرقم التسلسلي للمؤشر في الصفيف. </li><li style=";text-align:right;direction:rtl">  صورة نقطية لقيم غير محددة - علامات تلك الأعمدة من هذا الإصدار التي تحتوي على قيمة غير محددة (NULL).  لا تعد NULL واحدة من القيم المعتادة لأنواع البيانات ، لذلك يجب تخزين السمة بشكل منفصل. </li></ul><br>  نتيجة لذلك ، يكون الرأس كبيرًا جدًا - لا يقل عن 23 بايت لكل إصدار من السلسلة ، وعادة ما يكون أكثر بسبب الصورة النقطية NULL.  إذا كان الجدول "ضيق" (أي أنه يحتوي على أعمدة قليلة) ، فقد يستغرق الحمل أكثر من المعلومات المفيدة. <br><br><h1 style=";text-align:right;direction:rtl">  إدراج </h1><br>  دعونا نلقي نظرة فاحصة على كيفية تنفيذ عمليات السلسلة على مستوى منخفض ، ونبدأ بالإدراج. <br><br>  للتجارب ، أنشئ جدولًا جديدًا به عمودين وفهرس على أحدهما: <br><br><pre style=";text-align:right;direction:rtl"><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">text</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t(s);</code> </pre> <br>  أدخل سطر واحد ، بعد بدء المعاملة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>);</code> </pre><br>  هنا هو عدد المعاملات الحالية لدينا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> txid_current -------------- 3664 (1 row)</code> </pre><br>  ألق نظرة على محتويات الصفحة.  توفر الدالة heap_page_items الخاصة بملحق pageinspect معلومات حول المؤشرات وإصدارات الصف: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">-[ RECORD 1 ]------------------- lp | 1 lp_off | 8160 lp_flags | 1 lp_len | 32 t_xmin | 3664 t_xmax | 0 t_field3 | 0 t_ctid | (0,1) t_infomask2 | 2 t_infomask | 2050 t_hoff | 24 t_bits | t_oid | t_data | \x0100000009464f4f</code> </pre><br>  لاحظ أن الكلمة الكومة (الكومة) في PostgreSQL تشير إلى الجداول.  هذا استخدام غريب آخر لمصطلح - الكومة عبارة عن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بنية بيانات</a> معروفة لا علاقة لها بالجدول.  هنا ، يتم استخدام هذه الكلمة بمعنى "كل شيء مكدس في كومة" ، على عكس الفهارس المطلوبة. <br><br>  تعرض الوظيفة البيانات "كما هي" بتنسيق يصعب قراءته.  لفهم ، سنترك جزءًا فقط من المعلومات ونفك تشفيرها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> lp_flags <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'unused'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'redirect to '</span></span>||lp_off <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> state, t_xmin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmin, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">256</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">512</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_aborted, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">1024</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">2048</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_aborted, t_ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">-[ RECORD 1 ]-+------- ctid | (0,1) state | normal xmin | 3664 xmax | 0 xmin_commited | f xmin_aborted | f xmax_commited | f xmax_aborted | t t_ctid | (0,1)</code> </pre><br>  إليك ما فعلناه: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  أضفنا صفرًا إلى رقم الفهرس لنجعله في نفس شكل t_ctid: (رقم الصفحة ، رقم الفهرس). </li><li style=";text-align:right;direction:rtl">  فك تشفير حالة مؤشر lp_flags.  هنا "طبيعي" - وهذا يعني أن المؤشر يشير حقًا إلى إصدار السلسلة.  سيتم النظر في القيم الأخرى في وقت لاحق. </li><li style=";text-align:right;direction:rtl">  من بين جميع أجزاء المعلومات ، تم حتى الآن تخصيص اثنين فقط من الأزواج.  تشير البتتان xmin_committed و xmin_aborted إلى ما إذا كانت المعاملة برقم xmin ملتزمة (تم إلغاؤها).  تشير بتتان متماثلتان إلى رقم المعاملة xmax. </li></ul><br>  ماذا نرى؟  عند إدراج صف في صفحة الجدول ، يظهر مؤشر بالرقم 1 ، يشير إلى الإصدار الأول والوحيد من الصف. <br><br>  في إصدار السطر ، يتم ملء حقل xmin برقم المعاملة الحالية.  لا تزال المعاملة نشطة ، لذلك لم يتم تعيين كلتا البتات xmin_committed و xmin_aborted. <br><br>  يشير الحقل ctid الخاص بإصدار الصف إلى نفس الصف.  هذا يعني أن الإصدار الأحدث غير موجود. <br><br>  يتم ملء حقل xmax برقم وهمية 0 ، لأن هذا الإصدار من الخط لا يتم حذفه وهو ذو صلة.  لن تهتم المعاملات بهذا الرقم ، لأنه تم تعيين بت xmax_aborted. <br><br>  لنأخذ خطوة أخرى لتحسين قابلية القراءة عن طريق إضافة بتات المعلومات إلى أرقام المعاملات.  وسننشئ وظيفة ، حيث أننا سنحتاج إلى الطلب أكثر من مرة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> heap_page_items(get_raw_page(relname,pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  في هذا النموذج ، يكون من الواضح أكثر ما يحدث في رأس إصدار السلسلة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  يمكن الحصول على معلومات متشابهة ، لكن أقل تفصيلاً ، من الجدول نفسه ، باستخدام أعمدة الزائفة xmin و xmax: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3664 | 0 | 1 | FOO (1 row)</code> </pre><br><h1 style=";text-align:right;direction:rtl">  تثبيت </h1><br>  عند الانتهاء بنجاح من الصفقة ، تحتاج إلى تذكر حالتها - لاحظ أنه ثابت.  للقيام بذلك ، استخدم بنية تسمى XACT (وقبل الإصدار 10 كان يطلق عليه CLOG (سجل الالتزام) ولا يزال هذا الاسم موجودًا في أماكن مختلفة). <br><br>  XACT ليس جدول كتالوج نظام؛  هذه هي الملفات في دليل PGDATA / pg_xact.  فيها ، لكل معاملة ، يتم تخصيص وحدتين: الالتزام والإجهاض - تمامًا كما هو الحال في رأس إصدار السطر.  يتم تقسيم هذه المعلومات إلى عدة ملفات للراحة فقط ، وسنعود إلى هذه المشكلة عندما نفكر في التجميد.  ويتم العمل مع هذه الملفات صفحة تلو الأخرى ، كما هو الحال مع جميع الملفات الأخرى. <br><br>  لذلك ، عند ارتكاب معاملة في XACT ، يتم تعيين بت الالتزام لهذه المعاملة.  وهذا كله يحدث أثناء الالتزام (على الرغم من أننا لا نتحدث عن المجلة التمهيدية حتى الآن). <br><br>  عندما تصل أي معاملة أخرى إلى صفحة الجدول التي نظرنا إليها للتو ، فسيتعين عليها الإجابة على بعض الأسئلة. <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  هل اكتملت المعاملة xmin؟  إذا لم يكن الأمر كذلك ، يجب ألا تكون النسخة التي تم إنشاؤها من السلسلة مرئية. <br>  يتم إجراء هذا التحقق من خلال النظر في بنية أخرى ، والتي توجد في الذاكرة المشتركة للمثيل وتسمى ProcArray.  أنه يحتوي على قائمة بجميع العمليات النشطة ، ولكل عدد من المعاملات الحالية (النشطة) المشار إليها. </li><li style=";text-align:right;direction:rtl">  إذا تم الانتهاء ، فكيف - عن طريق التثبيت أو الإلغاء؟  إذا تم الإلغاء ، فلا ينبغي أن يكون إصدار السلسلة مرئيًا أيضًا. <br>  هذا هو بالضبط ما هو XACT ل.  ولكن ، على الرغم من أن صفحات XACT الأخيرة مخزنة في مخازن في ذاكرة الوصول العشوائي ، فإنه ليس من الضروري التحقق من XACT في كل مرة.  لذلك ، يتم تسجيل حالة المعاملة بمجرد توضيحها في بت xmin_committed و xmin_aborted من إصدار الصف.  إذا تم تعيين أحد هذه البتات ، فسيتم اعتبار حالة المعاملة xmin معروفة ولن تحتاج المعاملة التالية إلى الوصول إلى XACT. </li></ol><br>  لماذا لا يتم تعيين هذه البتات بواسطة المعاملة نفسها التي تنفذ عملية الإدراج؟  عند حدوث إدراج ، لا تعرف المعاملة بعد ما إذا كانت ستكتمل بنجاح.  وفي الوقت الحالي ، لا يتم تحديد الخطوط التي تم تغيير الصفحات فيها بالفعل.  قد يكون هناك العديد من هذه الصفحات ، وحفظها غير مؤات.  بالإضافة إلى ذلك ، يمكن إخراج جزء من الصفحات من ذاكرة التخزين المؤقت المخزن المؤقت إلى القرص ؛  قراءتها مرة أخرى لتغيير البتات يعني إبطاء الالتزام بشكل ملحوظ. <br><br>  الجانب السلبي للادخار هو أنه بعد التغييرات ، يمكن لأي معاملة (حتى تنفيذ قراءة بسيطة) البدء في تغيير صفحات البيانات في ذاكرة التخزين المؤقت المخزن المؤقت. <br><br>  لذلك ، إصلاح التغيير. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  لم يتغير شيء في الصفحة (لكننا نعرف أن حالة المعاملة مسجلة بالفعل في XACT): <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  الآن سيتعين على المعاملة التي تصل إلى الصفحة أولاً تحديد حالة المعاملة xmin وكتابتها إلى وحدات بت المعلومات: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 0 (a) | (0,1) (1 row)</code> </pre><br><h1 style=";text-align:right;direction:rtl">  إزالة </h1><br>  عند حذف أحد الخطوط ، يتم تسجيل رقم معاملة الحذف الحالية في حقل xmax من الإصدار الحالي ، وتتم إعادة تعيين بت xmax_aborted. <br><br>  لاحظ أن قيمة مجموعة xmax المقابلة للمعاملة النشطة تعمل بمثابة قفل للصف.  إذا كانت هناك معاملة أخرى على وشك تحديث هذا الصف أو حذفه ، فستضطر إلى الانتظار حتى تكتمل معاملة xmax.  سنتحدث أكثر عن الأقفال في وقت لاحق.  في الوقت الحالي ، نلاحظ فقط أن عدد أقفال الصف غير محدود.  لا يشغلون مكانًا في ذاكرة الوصول العشوائي ولا يعاني أداء النظام من كميتهم.  صحيح أن المعاملات "الطويلة" لها عيوب أخرى ، ولكن المزيد عن ذلك لاحقًا. <br><br>  حذف الخط. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> txid_current -------------- 3665 (1 row)</code> </pre><br>  نرى تسجيل رقم المعاملة في حقل xmax ، لكن لم يتم تعيين بتات المعلومات: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br><h1 style=";text-align:right;direction:rtl">  إلغاء </h1><br>  تعمل عكس التغييرات بشكل مماثل للالتزام ، فقط في XACT للمعاملة يتم تعيين بت إحباط.  الإلغاء هو أسرع وقت الالتزام.  على الرغم من أن الأمر يسمى ROLLBACK ، لا يتم التراجع عن التغيير: كل شيء تمكنت المعاملة من تغييره في صفحات البيانات لم يتغير. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br>  عند الوصول إلى الصفحة ، سيتم التحقق من الحالة وسيتم تعيين بت تلميح xmax_aborted في إصدار السطر.  يبقى رقم xmax نفسه في الصفحة ، لكن لن ينظر إليه أحد. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+----------+-------- (0,1) | normal | 3664 (c) | 3665 (a) | (0,1) (1 row)</code> </pre><br><h1 style=";text-align:right;direction:rtl">  تحديث </h1><br>  يعمل التحديث كما لو كان يحذف أولاً الإصدار الحالي من الصف ، ثم يدرج إصدارًا جديدًا. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> txid_current -------------- 3666 (1 row)</code> </pre><br>  ينتج الطلب سطرًا واحدًا (إصدار جديد): <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> id | s ----+----- 1 | BAR (1 row)</code> </pre><br>  ولكن في الصفحة نرى كلا الإصدارين: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 3666 | (0,2) (0,2) | normal | 3666 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  يتم تمييز الإصدار البعيد برقم المعاملة الحالي في حقل xmax.  علاوة على ذلك ، تتم كتابة هذه القيمة على القيمة القديمة ، حيث تم إلغاء المعاملة السابقة.  تتم إعادة تعيين بت xmax_aborted ، لأن حالة المعاملة الحالية لا تزال غير معروفة. <br><br>  يشير الإصدار الأول من السطر الآن إلى الثاني (حقل t_ctid) ، كإصدار جديد. <br><br>  يظهر مؤشر ثان وسطر ثان في صفحة الفهرس ، مرتبطين بالإصدار الثاني في صفحة الجدول. <br><br>  كما هو الحال مع الحذف ، فإن قيمة xmax في الإصدار الأول من السلسلة هي علامة على أن السلسلة مقفلة. <br><br>  حسنا ، أكمل الصفقة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1 style=";text-align:right;direction:rtl">  مؤشرات </h1><br>  حتى الآن ، تحدثنا فقط عن صفحات الجداول.  وماذا يحدث داخل المؤشرات؟ <br><br>  تعتمد المعلومات الموجودة في صفحات الفهرس اعتمادًا كبيرًا على نوع الفهرس المحدد.  وحتى نوع واحد من الفهرس به أنواع مختلفة من الصفحات.  على سبيل المثال ، تحتوي الشجرة B على صفحة بها بيانات وصفحية وصفحات "عادية". <br><br>  ومع ذلك ، تحتوي الصفحة عادةً على مجموعة من المؤشرات للخطوط والخطوط نفسها (تمامًا كما في صفحة الجدول).  بالإضافة إلى ذلك ، في نهاية الصفحة يوجد مكان للبيانات الخاصة. <br><br>  يمكن أن تحتوي الصفوف في الفهارس أيضًا على هيكل مختلف تمامًا اعتمادًا على نوع الفهرس.  على سبيل المثال ، بالنسبة للشجرة B ، تحتوي الصفوف المرتبطة بصفحات الأوراق على قيمة مفتاح الفهرس ورابط (ctid) بالصف المقابل من الجدول.  بشكل عام ، يمكن ترتيب الفهرس بطريقة مختلفة تمامًا. <br><br>  النقطة الأكثر أهمية هي أنه لا توجد إصدارات صف في أي نوع من الفهرس.  حسنًا ، أو يمكننا افتراض أن كل سطر يمثله إصدار واحد تمامًا.  بمعنى آخر ، لا توجد حقول xmin و xmax في رأس صف الفهرس.  يمكننا أن نفترض أن الروابط من الفهرس تؤدي إلى جميع الإصدارات المجدولة للصفوف - حتى تتمكن فقط من معرفة الإصدار الذي ستراه المعاملة إذا نظرت إلى الجدول.  (كالعادة ، هذه ليست الحقيقة كاملة. في بعض الحالات ، تسمح لك خريطة الرؤية بتحسين العملية ، لكننا سننظر في ذلك بمزيد من التفاصيل لاحقًا.) <br><br>  في الوقت نفسه ، في صفحة الفهرس ، نجد مؤشرات على كلا الإصدارين ، الحالي والقديم: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> itemoffset, ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'t_s_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,1) (2 rows)</code> </pre><br><h1 style=";text-align:right;direction:rtl">  المعاملات الافتراضية </h1><br>  في الممارسة العملية ، يستخدم PostgreSQL تحسينات "لحفظ" أرقام المعاملات. <br><br>  إذا كانت المعاملة تقوم بقراءة البيانات فقط ، فلن يؤثر ذلك على ظهور إصدارات الصف.  لذلك ، في البداية ، تصدر عملية التقديم معاملة رقم ظاهري (xid ظاهري).  يتكون الرقم من معرف العملية ورقم متسلسل. <br><br>  لا يتطلب إصدار هذا الرقم التزامن بين جميع العمليات وبالتالي فهو سريع للغاية.  سنتعرف على سبب آخر لاستخدام الأرقام الافتراضية عندما نتحدث عن التجميد. <br><br>  لا يتم أخذ الأرقام الافتراضية في الاعتبار في لقطات البيانات. <br><br>  في أوقات مختلفة من الزمن ، قد تظهر المعاملات الافتراضية مع الأرقام التي تم استخدامها بالفعل في النظام ، وهذا أمر طبيعي.  ولكن لا يمكن كتابة هذا الرقم في صفحات البيانات ، لأنه في المرة التالية التي تدخل فيها إلى الصفحة ، قد يفقد هذا المعنى. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- (1 row)</code> </pre><br>  إذا بدأت المعاملة في تغيير البيانات ، يتم منحها رقم معاملة حقيقي وفريد. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1.00</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- 3667 (1 row)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1 style=";text-align:right;direction:rtl">  المعاملات المتداخلة </h1><br><h2 style=";text-align:right;direction:rtl">  حفظ النقاط </h2><br>  يحدد SQL savepoints التي تسمح لك بالتراجع عن جزء من الصفقة دون مقاطعة ذلك تماما.  ولكن هذا لا يتناسب مع المخطط أعلاه ، حيث أن حالة المعاملة هي واحدة من كل التغييرات ، ولا يتم إرجاع البيانات فعليًا. <br><br>  لتنفيذ هذه الوظيفة ، يتم تقسيم المعاملة التي تحتوي على نقطة حفظ إلى عدة <em>معاملات متداخلة</em> منفصلة (الترجمة الشفوية) ، يمكن التحكم في حالتها بشكل منفصل. <br><br>  المعاملات المتداخلة لها رقم خاص بها (أعلى من رقم المعاملة الرئيسي).  يتم تسجيل حالة المعاملات المتداخلة بالطريقة المعتادة في XACT ، ومع ذلك ، تعتمد الحالة النهائية على حالة المعاملة الرئيسية: إذا تم إلغاؤها ، فسيتم أيضًا إلغاء جميع المعاملات المتداخلة. <br><br>  يتم تخزين المعلومات حول تداخل المعاملات في ملفات في دليل PGDATA / pg_subtrans.  يتم الوصول إلى الملفات من خلال المخازن المؤقتة في الذاكرة المشتركة للمثيل ، ويتم تنظيمها بنفس الطريقة مثل المخازن المؤقتة XACT. <br><br>  لا تخلط بين المعاملات المتداخلة والمعاملات المستقلة.  المعاملات المستقلة لا تعتمد بأي حال على بعضها البعض ، والمعاملات المتداخلة تعتمد.  لا توجد معاملات مستقلة في PostgreSQL المعتادة ، وربما للأفضل: في حالة الحاجة إليها ، في حالات نادرة جدًا ، ووجودها في قواعد بيانات إدارة قواعد البيانات (DBMS) الأخرى يثير إساءة ، والتي يعاني منها الجميع. <br><br>  امسح الجدول ، وابدأ المعاملة وأدخل السطر: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO (1 row)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (1 row)</code> </pre><br>  الآن وضع savepoint وإدراج صف آخر. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SAVEPOINT</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XYZ'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br>  لاحظ أن الدالة txid_current () تُرجع رقم المعاملة الرئيسية ، غير المتداخلة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3670 | 0 | 3 | XYZ (2 rows)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  نعود إلى نقطة الحفظ ونضيف الصف الثالث. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'BAR'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 | 0 (a) | (0,3) (3 rows)</code> </pre><br>  في الصفحة ، نواصل مشاهدة الصف الذي تمت إضافته بواسطة المعاملة المتداخلة الملغاة. <br><br>  نحن إصلاح التغييرات. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (3 rows)</code> </pre><br>  الآن يمكنك أن ترى بوضوح أن كل معاملة متداخلة لها حالتها الخاصة. <br><br>  لاحظ أنه لا يمكن استخدام المعاملات المتداخلة بشكل صريح في SQL ، أي أنه لا يمكنك بدء معاملة جديدة دون إكمال المعاملة الحالية.  يتم استخدام هذه الآلية ضمنيًا عند استخدام savepoints ، وكذلك عند التعامل مع استثناءات PL / pgSQL وفي عدد من الحالات الأخرى الأكثر غرابة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">BEGIN</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">WARNING: there is already a transaction in progress BEGIN</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">COMMIT</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">WARNING: there is no transaction in progress COMMIT</code> </pre><br><h2 style=";text-align:right;direction:rtl">  أخطاء و atomicity العمليات </h2><br>  ماذا يحدث إذا حدث خطأ أثناء العملية؟  على سبيل المثال ، مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br>  لقد حدث خطأ.  الآن تم اعتبار المعاملة مُجهضة ولا يُسمح بإجراء عملية واحدة فيها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">ERROR: current transaction is aborted, commands ignored until end of transaction block</code> </pre><br>  وحتى إذا حاولت الالتزام بالتغييرات ، فسوف يقوم PostgreSQL بالإبلاغ عن الإلغاء: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">ROLLBACK</code> </pre><br>  لماذا لا يمكنني متابعة المعاملة بعد الفشل؟  والحقيقة هي أنه قد يحدث خطأ حتى نتمكن من الوصول إلى جزء من التغييرات - ذرية لا حتى المعاملة ، ولكن سيتم انتهاك المشغل.  كما في المثال الخاص بنا ، حيث تمكن المشغل من تحديث سطر واحد قبل الخطأ: <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 3672 | (0,4) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (0,4) | normal | 3672 | 0 (a) | (0,4) (4 rows)</code> </pre><br>  يجب أن أقول أنه يوجد في psql وضع لا يزال يسمح لك بمتابعة المعاملة بعد الفشل ، كما لو أن إجراءات المشغل الخاطئ قد تراجعت. <br><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ON_ERROR_ROLLBACK <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre style=";text-align:right;direction:rtl"> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  من السهل تخمين أنه في هذا الوضع ، تقوم psql بالفعل بتعيين نقطة حفظ ضمنية أمام كل أمر ، وفي حالة الفشل تبدأ في التراجع عنها.  لا يتم استخدام هذا الوضع افتراضيًا ، حيث إن إعداد نقاط الحفظ (حتى بدون الرجوع إليها) يرتبط بحمولات كبيرة. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">أن تستمر.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar445820/">https://habr.com/ru/post/ar445820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar445804/index.html">تغليف للساموراي الحقيقي ، أو الفروق الدقيقة المرتبطة الكلمة الأساسية في C #</a></li>
<li><a href="../ar445806/index.html">كيف الذكاء الاصطناعي يغير العلم</a></li>
<li><a href="../ar445808/index.html">نحن نكره ونطارد: الحياة الخطيرة لمفرقع الفيروسات الذي يصنع أعداء أقوياء</a></li>
<li><a href="../ar445814/index.html">كيف غير روبوت التسليم عادات الطهي للطلاب الأميركيين</a></li>
<li><a href="../ar445816/index.html">كيف رأينا تقديم الخادم وما جاء منه</a></li>
<li><a href="../ar445822/index.html">لماذا يعقوب؟ لماذا مضرب؟</a></li>
<li><a href="../ar445824/index.html">كود الجيل في دارت. الجزء 1. الأساسيات</a></li>
<li><a href="../ar445826/index.html">نسير حول المدينة بحكمة - 2: نسير حول المدينة في دوائر باستخدام الخوارزمية الجينية</a></li>
<li><a href="../ar445828/index.html">الطيف الشمسي الصيني</a></li>
<li><a href="../ar445832/index.html">الإشعاع: القاتل الخفي وبناته أو القليل من غاز الرادون</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>