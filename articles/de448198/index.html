<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äç‚öñÔ∏è ‚ô•Ô∏è üë©üèø‚Äçüöí Sichere Daten√ºbertragung zwischen zwei Anwendungen üò∏ üï¶ üçü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits, heute m√∂chte ich Ihnen einige Optionen f√ºr die √úbertragung von Daten zwischen zwei Android-Anwendungen erl√§utern und diese unter Sic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sichere Daten√ºbertragung zwischen zwei Anwendungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/448198/">  Hallo allerseits, heute m√∂chte ich Ihnen einige Optionen f√ºr die √úbertragung von Daten zwischen zwei Android-Anwendungen erl√§utern und diese unter Sicherheitsgesichtspunkten betrachten.  Ich habe mich aus zwei Gr√ºnden entschlossen, diesen Artikel zu schreiben.  Erstens stie√ü ich oft auf ein Unverst√§ndnis der Entwickler der Mechanismen f√ºr die Arbeit mit den Komponenten einer Android-Anwendung.  Das zweite - Ich habe aufgeh√∂rt zu verstehen, worauf die Wahl dieses oder jenes Mechanismus bei der Implementierung von Funktionen basiert, und wollte vermitteln, wie es auf das Minimum aussehen sollte. <a name="habracut"></a><br><br><h6>  Herausforderung </h6><br>  Wir haben 2 Anwendungen, die auf dieselbe API zugreifen.  Clients k√∂nnen √ºber das Zugriffstoken (sessionId) auf die API zugreifen.  Sie m√ºssen einen nahtlosen √úbergang von einer Anwendung zur anderen implementieren.  Um dies zu tun, m√ºssen Sie zwischen ihnen fummeln, z. B. sessionId. <br><br><h6>  Option 1: QUERY DEEPLINK </h6><br>  Die naheliegendste Option ist die √úbertragung des Tokens an Query DeepLink.  Es wird ungef√§hr so ‚Äã‚Äãaussehen: <br> <code>slave://main?sessionId=686A885A4FB644053C584B9BE2A70C7D</code> <br>  In diesem Fall kann der Empf√§nger die Sitzungs-ID extrahieren und verwenden, ohne die Autorisierung des Benutzers anzufordern.  Aus Entwicklerseite sieht es so aus, als w√§re die Aufgabe abgeschlossen, aber lassen Sie uns etwas tiefer gehen. <br><br><h4>  Deeplink-Entf√ºhrung </h4><br>  Da jede Anwendung das Tinkoff: // Schema registrieren kann, kann das Betriebssystem die falsche Anwendung √∂ffnen.  Dies ist m√∂glich, weil es keine Registrierung gibt und die Verwendung von Systemen eingeschr√§nkt ist.  Eine b√∂swillige Anwendung kann das Schema tinkoff: // registrieren, die Anforderung an die Tinkoff-Anwendung abfangen und sich selbst starten.  In diesem Fall ger√§t die sessionId in die falschen H√§nde und Ihr Konto wird gef√§hrdet.  Dar√ºber hinaus k√∂nnen Sie mit DeepLink Hijacking Phishing durchf√ºhren, indem Sie beispielsweise Felder zur Eingabe eines Benutzernamens und eines Kennworts anzeigen. <br><br>  Konzeptionell sieht der Prozess folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/jr/ql/kk/jrqlkkybrv_js21icrnk5hjeqme.png" alt="Bild"><br><br>  F√ºr dieses Problem gibt es zwei L√∂sungen.  Erstens k√∂nnen Entwickler mit der AppLinks-Technologie das Schema nicht mehr anpassen. Stattdessen wird http / https verwendet.  In diesem Fall nimmt das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Betriebssystem den</a> Link <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slave.com/profile</a> und kontaktiert den Host von Slave.com zur √úberpr√ºfung.  Die zweite - Intent URL - anstelle des Aufrufs von Slave: //, Intent: // wird aufgerufen, wobei die eindeutige Kennung der zu startenden Anwendung √ºbergeben wird.  Es sieht so aus: <br><br><pre> <code class="plaintext hljs">intent://main/#Intent;scheme=slave;package=com.example.slave.client.android;end"</code> </pre> <br>  In diesem Fall kann der Start der Anwendung nicht abgefangen werden, da ein bestimmtes Paket angegeben ist.  Das Problem bleibt jedoch, dass der Benutzer die Anwendung von einer Quelle eines Drittanbieters mit derselben Paket-ID wie Ihr Slave installieren kann.  In diesem Fall wird die sch√§dliche Anwendung Ihr Token installieren und empfangen, wenn Sie keine legitime Slave-Anwendung hatten. <br><br><h4>  Sitzungsfixierung </h4><br>  Dies ist ein Angriff, bei dem ein Angreifer den Client zwingt, eine Sitzung mit der Zielsoftware unter Verwendung der vom Angreifer bereitgestellten Sitzungs-ID einzurichten.  Sobald sich der Benutzer authentifiziert, kann der Angreifer diese bereits privilegierte Kennung f√ºr seine eigenen Zwecke verwenden.  Der Angriff nutzt die Tatsache aus, dass die Zielsoftware nach der Eskalation von Berechtigungen dieselbe Sitzungs-ID verwendet. <br><br><img src="https://habrastorage.org/webt/pm/s2/_1/pms2_1zmdejnjxlb_duw2zjqzau.png"><br>  Wie es in unserem Fall aussieht: <br><br><ol><li>  Der Angreifer erh√§lt eine anonyme Sitzung von der Anwendung </li><li>  wirft wundersch√∂n einen Brief an das Opfer im Namen der Bank, in dem er eingeladen wird, auf sein pers√∂nliches Konto zu gehen </li><li>  Wenn wir auf den Link klicken, gelangen wir mit einem Angreifersitzungs-Slave zu DeepLink: // main? sessionId = 686A885A4FB644053C584B9BE2A70C7D </li><li>  Die mobile Anwendung nimmt an einer Sitzung teil, versteht, dass sie nicht √ºber gen√ºgend Rechte verf√ºgt, und fordert den Benutzer zur Authentifizierung auf </li><li>  Wenn der Benutzer es √ºbergibt, hat die Sitzung erh√∂hte Rechte </li><li>  Benutzer in der Anwendung, ein Angreifer mit einer privilegierten Sitzung, Gewinn </li></ol><br>  Es w√§re richtig, dies in der API zu beheben und nach der Eskalation von Berechtigungen eine weitere Sitzungs-ID auszugeben, aber wir schreiben eine mobile Anwendung.  Und unser Weg ist es, die √úbertragung des Tokens vom Master zum Slave zu verweigern.  Au√üerdem erhalten wir so einen umfassenden Schutz. Wenn die API besch√§digt wird und sich die Token nicht √§ndern, wenn die Berechtigungen erh√∂ht werden, ist ein Angriff immer noch unm√∂glich. <br><br><h4>  Leckage von Drittanbietern </h4><br>  Ein weiteres Minus dieser Option.  Viele Leute nutzen Dienste von Drittanbietern f√ºr DeepLink, weil sie bequem Links, Analysen und andere coole Dinge generieren k√∂nnen.  In diesem Fall geben Sie Ihren Token einfach an ein Drittunternehmen weiter. <br><br><h6>  Option 2: INHALTSANBIETER </h6><br>  Wie machen wir das?  Wir definieren den Master-Inhaltsanbieter und lassen den Slave f√ºr das Token zu diesem Inhaltsanbieter gehen. <br><br><img src="https://habrastorage.org/webt/lq/am/ip/lqamiplsbcmfslxdcb_u1whnv7a.png"><br><br>  Auf diese Weise wird das Risiko beseitigt, dass das Token im Fall von DeepLink-Hijacking an die falsche Anwendung √ºbertragen wird, und der Angriff auf die Sitzungsfixierung wird unm√∂glich.  Wir haben jedoch andere Probleme: In der aktuellen Version kann im Allgemeinen jede Anwendung jederzeit ein Token anfordern, auch wenn wir den Start nicht initiiert haben. <br><br><h4>  Schutzstufe </h4><br>  In den meisten F√§llen m√ºssen Sie √ºberpr√ºfen, ob der Slave mit demselben Schl√ºssel wie der Master signiert ist, dh, er geh√∂rt demselben Autor.  In diesem Fall verf√ºgt der Paketmanager √ºber eine checkSignatures-Methode, mit der Anwendungssignaturen √ºberpr√ºft werden.  Um diese Funktion nutzen zu k√∂nnen, m√ºssen Sie im Anwendungsanbieter im Anwendungsmanifest eine Berechtigung mit protectedLevel = "Signatur" hinzuf√ºgen: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">permission</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.example.contentprovider.access"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:protectionLevel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"signature"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">provider</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:readPermission</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.example.contentprovider.access"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Das Schema wird sich kaum von der vorherigen Abbildung √§ndern. Es wird nur eine Garantie angezeigt, dass nur Anwendungen mit einer Signatur desselben Autors Zugriff auf das Token erhalten. <br><br><h4>  Erlaubnis Race Bedingung </h4><br>  Es gibt eine sehr unangenehme Eigenschaft, dass Berechtigungsnamen nicht eindeutig sind, die von einer b√∂swilligen Anwendung verwendet werden k√∂nnen und die Berechtigung mit unserem Namen und Schutzlevel = "normal" vor uns registrieren.  In diesem Fall ist bei der Installation unserer Anwendung bereits eine Berechtigung auf dem Betriebssystem vorhanden, die nicht √ºberschrieben wird.  Folglich bleibt unser Inhaltsanbieter ungesch√ºtzt und hat von jeder Anwendung aus autorisierten Zugriff. <br><br><h4>  Unterschiedliche Signaturen </h4><br>  Leider werden Anwendungen nicht immer mit einem Schl√ºssel signiert, zum Beispiel werden einige Anwendungen gekauft oder "so historisch", aber ein nahtloser √úbergang ist immer noch erforderlich.  In diesem Fall nehmen wir die Unterschriften√ºberpr√ºfung selbst in die Hand. <br>  Wie kann dies umgesetzt werden: <br>  Der Inhaltsanbieter verf√ºgt √ºber eine getCallingPackage () -Methode, mit der wir die packageId der Anwendung abrufen k√∂nnen, die Daten beantragt hat, und mit packageId die Liste der Signaturen abrufen und diese mit den integrierten √ºberpr√ºfen k√∂nnen. <br><br><pre> <code class="java hljs">String pkg = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getCallingPackage(); PackageInfo pkgInfo = pkgmgr.getPackageInfo(pkg, GET_SIGNATURES); Signatures[] signatures = pkgInfo.signatures; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Signature sig: signatures) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sig.equals(TRUSTED_SIGNATURE)) { <span class="hljs-comment"><span class="hljs-comment">// trusted signature found, trust the application } }</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/zh/nx/p4/zhnxp4g2s8znhxf1ushb3ooo7fo.png"><br><br>  Es scheint, dass wir alles perfekt gemacht haben, aber nein. <br><br><h4>  Gef√§lschte ID-Sicherheitsl√ºcke </h4><br>  Das Problem ist, dass beim Erstellen einer Vertrauenskette durch Android der √úberpr√ºfungsprozess nur den Betreff vergleicht und die Signatur im Unterzeichnerfeld des Zertifikats nicht √ºberpr√ºft.  Infolgedessen kann ein Angreifer eine Vertrauenskette ohne tats√§chliche Signatur aufbauen. <br><br>  Aufgrund dieses Fehlers wird eine falsche Zertifikatkette generiert, die m√∂glicherweise legitime Zertifikate enth√§lt, die in das APK eingebettet sind, aber nicht zum Signieren der Anwendung verwendet werden.  Am Ende werde ich einen Link zum Commit hinterlassen, der diese Sicherheitsanf√§lligkeit behebt.  Das Problem wurde in Android 4.4 behoben, sodass wir die API-Stufe nur auf 19 erh√∂hen k√∂nnen. <br><br><h6>  Schlussfolgerungen </h6><br>  Heute haben wir untersucht, wie Features w√§hrend der Entwicklung analysiert werden sollten. <br>  Wir haben auch die Optionen f√ºr die √úbertragung des Geheimnisses zwischen zwei Anwendungen untersucht. Dabei haben wir die Probleme jeder Option analysiert und M√∂glichkeiten gefunden, sie zu vermeiden. <br><br>  Alle sicheren Anwendungen! <br><br><h6>  Referenzen </h6><br><ul><li>  Fake ID Vulnerability Fix <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit</a> </li><li>  Gef√§lschte ID-Schwachstellenpr√§sentation </li><li>  CWE: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sitzungsfixierung</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448198/">https://habr.com/ru/post/de448198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448188/index.html">Zeitkapsel: HP iPaq h1940 "out of the box". Wof√ºr ist ein PDA aus den 2000er Jahren?</a></li>
<li><a href="../de448190/index.html">Visual Logic Editor f√ºr Unity3d. Teil 1</a></li>
<li><a href="../de448192/index.html">Warum brauchen wir bei der Produktion von AR und VR</a></li>
<li><a href="../de448194/index.html">Erfahrung in der Rekrutierung von Softwareentwicklern. Teil 2</a></li>
<li><a href="../de448196/index.html">Die Zukunft (oder geheime Gegenwart) von Plasmamotoren oder wie man einen maximalen Schwung von 27 in der Atmosph√§re erreicht</a></li>
<li><a href="../de448202/index.html">Wir steuern den Generator oder den Kampf gegen den ADC im STM32F030</a></li>
<li><a href="../de448204/index.html">B√∂hmische Inseln</a></li>
<li><a href="../de448206/index.html">Modulare Entwicklung oder Weg dorthin, nicht zur√ºck</a></li>
<li><a href="../de448208/index.html">20, 100, 3, 19 - InoThings in Zahlen</a></li>
<li><a href="../de448210/index.html">Kanone f√ºr Satelliten, einen Blaster und ein Solarschiff: neugierige und paradoxe Projekte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>