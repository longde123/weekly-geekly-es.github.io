<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔩 📫 🧛🏾 Refactoring program on Go: akselerasi hingga 23 kali 🌬️ 🎅🏻 🛒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Nama saya Marco, saya bekerja untuk Badoo di departemen Platform. Kami memiliki banyak hal yang ditulis dalam Go, dan seringkali ini penting untuk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Refactoring program on Go: akselerasi hingga 23 kali</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/415919/"><img src="https://habrastorage.org/webt/fw/oq/ji/fwoqjijc84e50kqfhpyzqfl-oay.jpeg"><br><br>  <i>Hai</i>  <i>Nama saya Marco, saya bekerja untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Badoo</a> di departemen Platform.</i>  <i>Kami memiliki banyak hal yang ditulis dalam Go, dan seringkali ini penting untuk kinerja sistem.</i>  <i>Itulah sebabnya hari ini saya menawarkan terjemahan sebuah artikel yang sangat saya sukai dan, saya yakin, akan sangat berguna bagi Anda.</i>  <i>Penulis menunjukkan langkah demi langkah bagaimana ia mendekati masalah kinerja dan bagaimana mereka memecahkannya.</i>  <i>Termasuk Anda akan berkenalan dengan alat kaya yang tersedia di Go untuk pekerjaan seperti itu.</i>  <i>Selamat membaca!</i> <br><br>  Beberapa minggu yang lalu, saya membaca artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode yang Baik Melawan Kode Buruk di Go,</a> " di mana penulis, langkah demi langkah, menunjukkan refactoring aplikasi nyata yang memecahkan masalah bisnis nyata.  Ini berfokus pada mengubah "kode buruk" menjadi "kode yang baik": lebih idiomatik, lebih dapat dimengerti, sepenuhnya memanfaatkan spesifikasi Go.  Namun penulis juga menyatakan pentingnya kinerja aplikasi yang dimaksud.  Keingintahuan melompat ke saya: mari kita coba mempercepatnya! <br><a name="habracut"></a><br>  Program, secara kasar, membaca file input, mem-parsingnya baris demi baris dan mengisi objek dalam memori. <br><br><img src="https://habrastorage.org/webt/q0/ar/rr/q0arrrwx11e7qz627mj4ttz1r7y.png"><br><br>  Penulis tidak hanya memposting <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode sumber di GitHub</a> , tetapi juga menulis patokan.  Ini ide yang bagus.  Bahkan, penulis mengundang semua orang untuk bermain-main dengan kode dan mencoba mempercepatnya.  Untuk mereproduksi hasil penulis, gunakan perintah berikut: <br><br><pre><code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=.</code> </pre> <br><img src="https://habrastorage.org/webt/jw/x2/6w/jwx26wyngj_sqokfhrbk-3u3yeo.png"><br>  <i>μs per panggilan (kurang - lebih baik)</i> <br><br>  Ternyata di komputer saya "kode yang baik" adalah 16% lebih cepat.  Bisakah kita mempercepatnya? <br><br>  Dalam pengalaman saya, ada korelasi antara kualitas kode dan kinerja.  Jika Anda berhasil refactored kode, membuatnya lebih bersih dan kurang terhubung, Anda kemungkinan besar membuatnya lebih cepat karena menjadi kurang berantakan (dan tidak ada instruksi yang tidak perlu yang sebelumnya dieksekusi dengan sia-sia).  Mungkin selama refactoring Anda memperhatikan beberapa peluang pengoptimalan, atau sekarang Anda hanya memiliki kesempatan untuk membuatnya.  Tetapi di sisi lain, jika Anda ingin membuat kode lebih produktif, Anda mungkin harus melepaskan diri dari kesederhanaan dan menambahkan berbagai peretasan.  Anda benar-benar menghemat milidetik, tetapi kualitas kodenya akan menderita: akan semakin sulit untuk membacanya dan membicarakannya, itu akan menjadi lebih rapuh dan fleksibel. <br><br><img src="https://habrastorage.org/webt/c9/lz/zd/c9lzzdc9yi73nsxn6cm93vwbvei.gif"><br>  <i>Kami mendaki gunung Kesederhanaan, dan kemudian turun dari sana</i> <br><br>  Ini adalah kompromi: seberapa jauh Anda bersedia melangkah? <br><br>  Untuk memprioritaskan pekerjaan akselerasi dengan benar, strategi optimal adalah menemukan kemacetan dan fokus padanya.  Untuk melakukan ini, gunakan alat profil.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pprof</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jejak</a> adalah teman Anda: <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. -cpuprofile cpu.prof $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool pprof -svg cpu.prof &gt; cpu.svg</code> </pre> <br> <a href=""><img src="https://habrastorage.org/webt/dc/j4/vf/dcj4vfmpccf5k2gjyxumvbtxj-k.png"></a> <br>  <i>Grafik penggunaan CPU yang cukup besar (klik untuk SVG)</i> <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -bench=. -trace trace.out $ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool trace trace.out</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/dd/tf/pk/ddtfpkssk98xhs_6o2ncqbxkucq.png"></a> <br>  <i>Pelacakan pelangi: banyak tugas kecil (klik untuk membuka, hanya berfungsi di Google Chrome)</i> <br><br>  Tracing mengonfirmasi bahwa semua inti prosesor sibuk (garis di bawah 0, 1, dll.), Dan, pada pandangan pertama, ini bagus.  Tapi dia juga menunjukkan ribuan "perhitungan" warna kecil dan beberapa area kosong di mana core tidak digunakan.  Mari memperbesar: <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/h3/-w/qe/h3-wqeqyb3xiiwyyvott4cwywg4.png"></a> <br>  <i>“Jendela” dalam 3 ms (klik untuk membuka, hanya berfungsi di Google Chrome)</i> <br><br>  Setiap inti menganggur selama beberapa waktu, dan juga "melompat" di antara tugas mikro setiap saat.  Tampaknya rincian tugas-tugas ini tidak terlalu optimal, yang mengarah ke sejumlah besar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saklar konteks</a> dan persaingan karena sinkronisasi. <br><br>  Mari kita lihat apa yang dikatakan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">detektor penerbangan</a> .  Apakah ada masalah dalam akses sinkron ke data (jika ada, maka kita memiliki masalah yang jauh lebih besar daripada kinerja)? <br><br><pre> <code class="go hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> test -race PASS</code> </pre> <br>  Hebat!  Semuanya benar.  Tidak ditemukan penerbangan.  Fungsi tes dan fungsi benchmark adalah fungsi yang berbeda ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat dokumentasi</a> ), tetapi di sini mereka memanggil fungsi <i>ParseAdexpMessage yang</i> sama, jadi apa yang kami periksa untuk penerbangan data dengan tes tidak apa-apa. <br><br>  Model kompetitif dalam versi "baik" terdiri dari pemrosesan setiap baris dari file input dalam goroutine terpisah (untuk menggunakan semua core).  Intuisi penulis di sini bekerja dengan baik, karena goroutine memiliki reputasi untuk fitur yang mudah dan murah.  Tetapi berapa banyak yang kita menangkan melalui eksekusi paralel?  Mari kita bandingkan dengan kode yang sama tetapi tidak menggunakan goroutine (hapus saja kata yang datang sebelum pemanggilan fungsi): <br><br><img src="https://habrastorage.org/webt/up/1q/0f/up1q0fy6bggo-62uevoioyo0huq.png"><br><img src="https://habrastorage.org/webt/ae/v3/go/aev3gocqbxle0pa3_lmeeyyczrg.png"><br><br>  Ups, sepertinya kode menjadi lebih cepat tanpa menggunakan konkurensi.  Ini berarti bahwa overhead (non-nol) untuk meluncurkan goroutine melebihi waktu yang kami menangkan dengan menggunakan beberapa core secara bersamaan.  Langkah alami selanjutnya adalah menghapus overhead (bukan nol) untuk menggunakan saluran untuk mengirim hasilnya.  Mari kita ganti dengan irisan biasa: <br><br><img src="https://habrastorage.org/webt/p_/sm/dl/p_smdl6hi439zezi4dygfvuyvtc.png"><br>  <i>μs per panggilan (lebih sedikit lebih baik)</i> <br><br>  Kami mendapat akselerasi sekitar 40% dibandingkan dengan versi "baik", menyederhanakan kode dan menghapus kompetisi (berbeda). <br><br><img src="https://habrastorage.org/webt/qr/in/pi/qrinpifpqvwgdb65z1yflyywjhg.png"><br>  <i>Dengan satu goroutine, hanya satu inti yang bekerja pada satu waktu</i> <br><br>  Sekarang mari kita lihat fungsi-fungsi panas dalam grafik pprof: <br><br> <a href=""><img src="https://habrastorage.org/webt/89/sd/bk/89sdbk8fhme8ixv37a2hmnxpj54.png"></a> <br>  <i>Mencari kemacetan</i> <br><br>  Patokan versi saat ini (operasi berurutan, irisan) menghabiskan 86% dari waktu penguraian pesan, dan ini normal.  Tetapi kami akan segera menyadari bahwa 43% dari waktu dihabiskan untuk menggunakan ekspresi reguler dan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(* Regexp) .FindAll</a> . <br><br>  Terlepas dari kenyataan bahwa ekspresi reguler adalah cara yang mudah dan fleksibel untuk mendapatkan data dari teks biasa, mereka memiliki kelemahan, termasuk penggunaan sejumlah besar sumber daya dan prosesor, dan memori.  Mereka adalah alat yang ampuh, tetapi seringkali penggunaannya tidak perlu. <br><br>  Dalam program kami, templat <br><br><pre> <code class="go hljs">patternSubfield = <span class="hljs-string"><span class="hljs-string">"-.[^-]*"</span></span></code> </pre> <br>  Ini terutama dimaksudkan untuk menyorot perintah yang dimulai dengan tanda hubung (-), dan mungkin ada beberapa baris.  Ini, setelah menarik sedikit kode, dapat dilakukan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bytes.Split</a> .  Mari kita adaptasikan kode ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komit</a> ) untuk mengubah ekspresi reguler menjadi Berpisah: <br><br><img src="https://habrastorage.org/webt/ks/8l/s2/ks8ls2upltp-tnqnpinp2tauqkc.png"><br>  <i>μs per panggilan (lebih sedikit</i> <i>lebih baik)</i> <br><br>  Wow!  40% kode lebih produktif!  Grafik konsumsi CPU sekarang terlihat seperti ini: <br><br> <a href=""><img src="https://habrastorage.org/webt/be/ux/dy/beuxdy132ncb8resbitn2gndy1a.png"></a> <br><br>  Tidak ada lagi waktu yang terbuang untuk ekspresi reguler.  Sebagian besar darinya (40%) digunakan untuk alokasi memori dari lima fungsi yang berbeda.  Menariknya, sekarang 21% dari waktu dihabiskan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">byte.</a> Fungsi utama: <br><br><img src="https://habrastorage.org/webt/8f/if/md/8fifmdma-hteqqu_p85umbyo1ly.png"><br>  <i>Fitur ini menggelitik saya.</i>  <i>Apa yang bisa kita lakukan di sini?</i> <i><br><br></i>  <i>bytes.Trim</i> mengharapkan string dengan karakter yang "terpotong" sebagai argumen, tetapi karena string ini kita meneruskan string dengan hanya satu karakter - spasi.  Ini hanya sebuah contoh bagaimana Anda bisa mendapatkan akselerasi karena kerumitan: mari kita buat fungsi trim kami alih-alih yang standar.  Fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">trim</a> khusus kami akan bekerja dengan satu byte, bukan seluruh baris: <br><br><img src="https://habrastorage.org/webt/xs/cv/np/xscvnpnpkjo9ml4yq8chimeimv4.png"><br><img src="https://habrastorage.org/webt/h-/is/7x/h-is7xreexvfn_s537mdqtdkmrc.png"><br>  <i>μs per panggilan (lebih sedikit lebih baik)</i> <br><br>  Hore, potongan 20% lagi!  Versi saat ini empat kali lebih cepat dari versi "buruk" asli dan pada saat yang sama hanya menggunakan satu inti.  Tidak buruk! <br><br><hr><br><br>  Sebelumnya, kami meninggalkan daya saing di tingkat pemrosesan garis, tetapi saya berpendapat bahwa akselerasi dapat dicapai dengan menggunakan daya saing di tingkat yang lebih tinggi.  Misalnya, memproses 6.000 file (6.000 pesan) lebih cepat di komputer saya jika setiap file diproses di goroutine sendiri: <br><br><img src="https://habrastorage.org/webt/r0/lf/oo/r0lfoof3kljocawz0tjcmogrww4.png"><br>  <i>μs per panggilan (lebih sedikit lebih baik; ungu adalah solusi kompetitif)</i> <br><br>  Keuntungannya adalah 66% (yaitu akselerasi tiga kali).  Ini bagus, tetapi tidak terlalu, mengingat bahwa semua 12 core prosesor yang saya miliki digunakan.  Ini mungkin berarti bahwa kode baru yang dioptimalkan yang memproses seluruh file masih merupakan "tugas kecil", yang mana biaya overhead untuk membuat goroutine dan biaya sinkronisasi tidak signifikan.  Cukup menarik, meningkatkan jumlah pesan dari 6.000 menjadi 120.000 tidak memiliki efek pada versi single-threaded dan mengurangi kinerja pada versi "satu goroutine per pesan".  Ini karena, terlepas dari kenyataan bahwa membuat sejumlah besar goroutine adalah mungkin dan kadang-kadang berguna, ia membawa overhead sendiri di area runtime- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sheduler</a> . <br><br>  Kami dapat mengurangi waktu eksekusi lebih lanjut (bukan 12 kali, tetapi masih) dengan menciptakan hanya beberapa pekerja.  Misalnya, 12 goroutine berumur panjang, masing-masing akan memproses bagian dari pesan: <br><br><img src="https://habrastorage.org/webt/re/v2/wf/rev2wf-q7cfgvhxsfj15n30l6xa.png"><br>  <i>μs per panggilan (lebih sedikit lebih baik; ungu adalah solusi kompetitif)</i> <br><br>  Opsi ini mengurangi waktu eksekusi hingga 79% dibandingkan dengan versi single-threaded.  Perhatikan bahwa strategi ini hanya masuk akal jika Anda memiliki banyak file untuk diproses. <br><br>  Penggunaan optimal semua inti prosesor adalah dengan menggunakan beberapa goroutine, yang masing-masing memproses sejumlah besar data tanpa interaksi atau sinkronisasi sebelum pekerjaan diselesaikan. <br><br>  Biasanya mereka mengambil sebanyak proses (goroutine) sebagai inti dari prosesor, tetapi ini tidak selalu merupakan pilihan terbaik: semuanya tergantung pada tugas tertentu.  Misalnya, jika Anda membaca sesuatu dari sistem file atau membuat banyak panggilan jaringan, maka untuk mendapatkan lebih banyak kinerja, Anda harus menggunakan lebih banyak goroutine daripada inti Anda. <br><br><img src="https://habrastorage.org/webt/gd/m-/ic/gdm-icxpy5qq_n2fw5-zru20gu4.png"><br>  <i>μs per panggilan (lebih sedikit lebih baik; ungu adalah solusi kompetitif)</i> <br><br>  Kami sampai pada titik di mana kinerja penguraian sulit ditingkatkan dengan beberapa perubahan yang dilokalkan.  Runtime didominasi oleh waktu untuk alokasi memori dan pengumpulan sampah.  Ini terdengar logis karena fungsi manajemen memori agak lambat.  Optimalisasi lebih lanjut dari proses yang terkait dengan alokasi tetap sebagai pekerjaan rumah bagi pembaca. <br><br><hr><br><br>  Menggunakan algoritme lain juga dapat menghasilkan peningkatan kinerja yang besar. <br><br>  Di sini saya terinspirasi oleh kuliah oleh Lexical Scanning in Go dari Rob Pike, <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HxaD_trXwRE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  untuk membuat lexer khusus ( <a href="">sumber</a> ) dan parser khusus ( <a href="">sumber</a> ).  Kode ini belum siap (saya tidak memproses banyak kasus sudut), kurang jelas dari algoritma asli, dan kadang-kadang sulit untuk menulis penanganan kesalahan yang benar.  Tetapi ini kecil dan 30% lebih cepat dari versi yang paling optimal. <br><br><img src="https://habrastorage.org/webt/ey/c3/n7/eyc3n7fnc1lu_szlyn2fnn0lzti.png"><br>  <i>μs per panggilan (lebih sedikit lebih baik; ungu adalah solusi kompetitif)</i> <br><br>  Ya  Akibatnya, kami mendapat akselerasi 23 kali dibandingkan dengan kode sumber. <br><br><hr><br><br>  Itu saja untuk hari ini.  Saya harap Anda menikmati petualangan ini.  Berikut beberapa catatan dan kesimpulan: <br><br><ul><li>  Produktivitas dapat ditingkatkan pada berbagai tingkat abstraksi, menggunakan teknik yang berbeda, dan keuntungannya sering meningkat. <br></li><li>  Tuning harus dimulai dengan abstraksi tingkat tinggi: struktur data, algoritma, decoupling modul yang benar.  Ambil abstraksi tingkat rendah nanti: I / O, batching, daya saing, menggunakan perpustakaan standar, bekerja dengan memori, mengalokasikan memori. <br></li><li>  Analisis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Big O</a> sangat penting, tetapi biasanya bukan alat yang paling cocok untuk mempercepat program. <br></li><li>  Menulis tolok ukur adalah kerja keras.  Gunakan profiling dan tolok ukur untuk menemukan kemacetan dan mendapatkan pemahaman yang lebih luas tentang apa yang terjadi dalam program.  Ingatlah bahwa hasil tolok ukur tidak sama dengan yang akan dialami pengguna Anda dalam pekerjaan nyata. <br></li><li>  Untungnya, satu set alat ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bench</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pprof</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">trace</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Race Detector</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cover</a> ) membuat penelitian tentang kinerja kode terjangkau dan menarik. <br></li><li>  Menulis tes yang baik dan relevan bukanlah tugas yang sepele.  Tetapi mereka sangat penting untuk tidak pergi ke alam liar.  Anda dapat melakukan refactor, memastikan kode tetap benar. <br></li><li>  Berhentilah dan tanyakan pada diri sendiri seberapa cepat "cukup cepat."  Jangan buang waktu Anda mengoptimalkan beberapa naskah satu kali.  Jangan lupa bahwa pengoptimalan tidak gratis: waktu insinyur, kompleksitas, bug, dan hutang teknis. <br></li><li>  Berpikir dua kali sebelum menyulitkan kode. <br></li><li>  Algoritma dengan kompleksitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ω</a> (n²) dan di atas biasanya terlalu mahal. <br></li><li>  Algoritma dengan kompleksitas O (n) atau O (n log n) dan di bawah ini biasanya ok. <br></li><li>  Berbagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">faktor tersembunyi</a> tidak dapat diabaikan.  Sebagai contoh, semua perbaikan dalam artikel dibuat dengan mengurangi faktor-faktor ini, dan bukan dengan mengubah kelas kompleksitas algoritma. <br></li><li>  I / O sering menjadi hambatan: kueri jaringan, kueri basis data, sistem file. <br></li><li>  Ekspresi reguler seringkali terlalu mahal dan tidak perlu. <br></li><li>  Alokasi memori lebih mahal daripada perhitungan. <br></li><li>  Objek yang dialokasikan pada stack lebih murah daripada objek yang dialokasikan pada heap. <br></li><li>  Irisan bermanfaat sebagai alternatif dari pergerakan memori yang mahal. <br></li><li>  String efektif ketika hanya-baca (termasuk reslicing).  Dalam semua kasus lain, [] byte lebih efektif. <br></li><li>  Sangat penting bahwa data yang Anda proses dekat (cache prosesor). <br></li><li>  Daya saing dan paralelisme sangat bermanfaat, tetapi sulit untuk dipersiapkan. <br></li><li>  Saat Anda menggali dalam dan bawah, ingatlah "lantai kaca" yang tidak ingin Anda buka.  Jika tangan Anda gatal untuk mencoba instruksi assembler, instruksi SIMD, Anda mungkin perlu menggunakan Go only untuk prototyping, dan kemudian beralih ke bahasa tingkat yang lebih rendah untuk mendapatkan kontrol penuh dari perangkat keras dan setiap nanodetik! <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415919/">https://habr.com/ru/post/id415919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415909/index.html">Ekstensi web lintas browser untuk skrip khusus Bagian 2</a></li>
<li><a href="../id415911/index.html">Akses ke indeks array yang tidak ada</a></li>
<li><a href="../id415913/index.html">Lakukan pemanasan untuk mereka yang bisa menggunakan Python</a></li>
<li><a href="../id415915/index.html">Praktik keras: apa jenis nirkabel yang kita miliki untuk pelaku bisnis perhotelan</a></li>
<li><a href="../id415917/index.html">"Hukum Musim Semi" mulai berlaku: selanjutnya apa?</a></li>
<li><a href="../id415923/index.html">Apakah Persatuan Lambat? Perhatian LINQ</a></li>
<li><a href="../id415925/index.html">MasterCard mematenkan teknologi blockchain anonim</a></li>
<li><a href="../id415927/index.html">Lampu Industri Breeze 50</a></li>
<li><a href="../id415929/index.html">Optimalisasi Arsitektur Kecerdasan Buatan: Perlombaan Dimulai</a></li>
<li><a href="../id415933/index.html">Bagaimana membangun arsitektur IIoT do-it-yourself</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>