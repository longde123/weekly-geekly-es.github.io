<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👧‍👧 👩‍🏫 👎🏽 合并之战。 带有结论和道德的纪事 🔂 🤮 🐁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在重要的提交庆典之前的几周-PostgreSQL 11的feature freeze版本之前的最后一个- 黑客通讯，压缩左侧包装中的芯片组，观看了MERGE惊悚片。 2ndQuadrant的惊悚导演兼首席执行官Simon Riggs试图推出一个补丁，以令人印​​象深刻的毅力和独创性实现MERGE命令...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>合并之战。 带有结论和道德的纪事</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/412605/">在重要的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">提交庆典</a>之前的几周<b>-PostgreSQL 11</b>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>feature freeze</code></a>版本之前的最后一个- <b>黑客</b>通讯，压缩左侧包装中的芯片组，观看了<b>MERGE</b>惊悚片。  <b>2ndQuadrant</b>的惊悚导演兼首席执行官<b><i>Simon Riggs</i></b>试图推出一个补丁，以令人印​​象深刻的毅力和独创性实现MERGE命令的语法。  Riggs自2009年以来一直是喜剧演员，您可以凭借自己的喜剧演员身份来批准补丁。 他同样受到备受尊敬的PostgreSQL委员会和退伍军人的反对。 激情清晰而隐含地泛滥成灾，甚至没有引起直接侮辱，这对于许多国内论坛的常客来说是一个令人惊讶的事实。 但是，当问题解决后，到目前为止仍然存在一些紧张局势，没有什么可争辩的。 <a name="habracut"></a><br><br> 但是，激情就是激情（将在后面进行讨论），我想无动于衷地梳理出这个完全牵强的问题的实质。 <br><br><img src="https://habrastorage.org/webt/t5/zc/ra/t5zcramwnjffszncwjkkkl9xt2g.jpeg"><br><h3> 外部合并 </h3><br> 如果要完全简化，那就是这样：我们有2个表，它们具有相同的字段和不同的数据。 假设姓名和年龄。 我们需要将它们合并为一个。 但是有必要决定如何处理两个表中的个性。 我们很可能希望将所有内容都保留在决赛桌中，并将信息更新为匹配的个人。 显然，即使在这种情况下，这也是非常常见的任务。 它可以在没有<code>MERGE</code>情况下解决，而发出复杂的请求，也可以使用触发器等。 但这很不方便。 但是，MERGE的非规范版本称为UPSERT（UPdate + inSERT）解决了此问题。 <br><br>  MERGE运算符符合SQL-2003标准，并且在SQL-2008中已具有很高的声誉。 它是在Oracle，DB2和MS SQL中实现的，这意味着缺少MERGE将使那些考虑从这些DBMS迁移到PostgreSQL的人感到沮丧。 西蒙·里格斯（Simon Riggs）尽可能快的渴望已在PostgreSQL 11中，这是由2ndQuadrant客户的愿望所推动的，而不是出于野心或争吵。 <br><br> 实际上，MERGE具有丰富的功能，不必从表中特别是结构相似的表中获取数据。 <br><br> 命令语法如下： <br><br><pre> <code class="sql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">MERGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tablename <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> table_reference <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (condition) <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> column1 = value1 [, column2 = value2 ...] <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> (column1 [, column2 ...]) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (value1 [, value2 ...]);</code> </pre> <br> 但是，您可以这样： <br><br><pre> <code class="hljs powershell">MERGE <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">hint</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">INTO</span></span></span></span> <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">schema</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">.</span></span></span><span class="hljs-function">] {</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">table</span></span></span></span> | view} <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">table_alias</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">USING</span></span></span></span> { subquery | <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">schema</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">.</span></span></span><span class="hljs-function">] { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">table</span></span></span></span> | view}} <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">table_alias</span></span></span><span class="hljs-function">] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ON</span></span></span></span> ( condition ) [ <span class="hljs-type"><span class="hljs-type">merge_update_clause</span></span> ] [ <span class="hljs-type"><span class="hljs-type">merge_insert_clause</span></span> ] [ <span class="hljs-type"><span class="hljs-type">error_logging_clause</span></span> ] ;</code> </pre> <br> 该语法在Oracle中实现。 换句话说，然后MERGE执行操作以单个SQL命令中使用data_source修改目标表target_table_name中的记录，该命令可以根据条件对target_table_name中的记录执行INSERT，UPDATE或DELETE。 在这种情况下，target_table_name可以是一个视图，data_source可以是一组<b>表或视图，这是子查询的结果</b> 。 <br><br> 首先， <code>MERGE</code>使用<code>target_table_name</code>在<code>data_source</code>上执行<code>left outer join</code> <code>target_table_name</code> ，建议使用0个或更多候选更改记录；  <code>WHEN</code>子句按指定顺序计算； 只要满足条件，就会执行相应的操作。 关键字<code>WHEN [NOT] MATCH THEN</code>在<code>SQL</code>不是很常见，因此我们提醒您，这是其他语言中的<code>if-else</code>类的控件构造。 对于<code>target_table_name</code> ， <code>MERGE</code>行为与<code>UPDATE, INSERT</code>或<code>DELETE</code>相同，只是整个命令的语法不同。 <br><br> 带有<code>ON</code>的子句必须在主键的所有列上建立连接，或者，如果指定了其他列，则必须使用一些唯一索引，以便<code>[NOT] MATCHED</code>立即确定候选记录的操作，以排除与其他事务的交互。 <br><br>  <code>MERGE</code>确定性命令：您不能在同一MERGE命令中多次更新同一记录。 <br> 一个例子： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">MERGE</span></span> CustomerAccount CA <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> RecentTransactions T <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> T.CustomerId = CA.CustomerId <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> Balance = Balance + TransactionValue <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> (CustomerId, Balance) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (T.CustomerId, T.TransactionValue);</code> </pre> <br> 或使用子查询： <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">MERGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bonuses D <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> employee_id, salary, department_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> department_id = <span class="hljs-number"><span class="hljs-number">80</span></span>) S <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (D.employee_id = S.employee_id) <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> D.bonus = D.bonus + S.salary*<span class="hljs-number"><span class="hljs-number">.01</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (S.salary &gt; <span class="hljs-number"><span class="hljs-number">8000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MATCHED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> (D.employee_id, D.bonus) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (S.employee_id, S.salary*<span class="hljs-number"><span class="hljs-number">.01</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (S.salary &lt;= <span class="hljs-number"><span class="hljs-number">8000</span></span>);</code> </pre> <br> 在<b>IBM DB2中，</b>语法也将起作用。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">正如他们所说</a> ，“在幕后”将与<code>UPDATE FROM</code>构造类似。 <br> 自2008年以来， <b>MS SQL</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">还拥有</a> <code>MERGE</code> 。 <br><br> 但是即使在单一的标准语法之后，也开始出现从大量机制和实现方法中进行选择的问题。 团队应在不同级别的事务隔离下工作，并使用不同的锁定算法，重点关注竞争激烈或不太合适的操作模式。 而且，您可能已经猜到，要实现这种复杂的逻辑，您需要接触许多DBMS组件。 <br><br><h3>  UPSERT，伪合并 </h3><br> 显然，DBMS开发人员正在寻找折衷解决方案，拒绝从字面上重现标准语法。 这种方法的优点是自由。 您可以使用针对特定DBMS的有机机制，可以优化您认为与用户最相关的任务的实现。 <br><br> 例如，在<b>MySQL中，</b>有一个<code>REPLACE</code>命令可用作<code>INSERT</code> ，但如果新行和旧行在<code>PRIMARY KEY</code>或<code>UNIQUE</code>索引中具有相同的值，则在插入新行之前，旧行将被杀死。 但是也有<code>INSERT ... ON DUPLICATE KEY UPDATE</code>发生<code>INSERT</code>和<code>UPDATE</code> （而不是<code>REPLACE</code>的<code>DELETE</code> ）。 这是<code>UPSERT</code> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">还有</a> <code>INSERT IGNORE</code> ，它只是不执行插入，而不会在目标表的某些限制下引发错误（但警告）。 <br><br><h3>  PG合并编年史 </h3><br> 在PostgreSQL社区中，关于MERGE的讨论始于2005年，当时Jaime Casanova询问<i>社区中是否有人已经开始开发</i> <code>MERGE</code> 。  <i>彼得·埃森特拉特</i> <a href="">（</a> <i>Peter Eisentraut）</i> <a href="">建议讨论</a> <i>PostgreSQL是否应该开发MERGE选项之一：类似于MySQL的实现，还是更好地将工作指向Oracle的<code>MERGE</code>类型的功能轻量级版本。</i>  <i>但是，朝这个方向努力是值得的吗？</i> <br><br> 在简短的讨论中， <i>西蒙·里格斯</i> （ <i>Simon Riggs）的</i>故事主角出现了： <br>  <i>MERGE对于OLTP系统和DW（数据仓库-数据仓库，即分析应用程序）都非常有用，在这些应用程序中，复杂的查询但竞争不太激烈的环境和数据很少更新，如果更新，通常通常是大块。&lt;...&gt;我们可以将MERGE作为COPY FROM的变体来实现，这将非常酷。</i> <br><br> 每个人都同意：是的，很酷。 更准确地说，几乎是所有东西： <i>Stephen Frost</i> ： <i>我并不是唯一一个说我需要成熟，合规的MERGE标准的人。</i> <br><br>  Bruce Momjian有一个不同的，更务实的建议： <i>在我看来，我们需要在</i> <code>MERGE</code> <i>实现</i> <i>一些我们可以实现的选项，而在其他情况下，我们将给出一个错误（在需要阻塞整个表的情况下）。</i>  <i>在获得用户反馈后，我们将思考下一步该怎么做。</i> <br><br> 但是到目前为止，什么都没有发生。 <br><br><h3> 冰破了 </h3><br>  <b>2008年，</b> <i>西蒙·里格斯</i> <b>（</b> <i>Simon Riggs）</i>再次敦促与MERGE合作-选择哪种方式（到那时，仍在起草中的SQL-2008标准的新版本MERGE已经出现）。 他详细描述了当时Oracle，IBM和MS SQL的当前实现以及MySQL和Teradata的替代语法。 不久之后，他已经提到<b>在2ndQuadrant朝</b>这个方向<b>开始工作</b> 。 <br><br>  Peter Eisentraut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在他的博客上写道</a> ： <i>当然，Riggs是最有资格的专家之一，他可以领导MERGE的实施工作。</i> <br><br> 但是，这里出现了第一个意外的转折：一个<b>学生</b>卷入了这个问题-参与了<b>GSoC</b>程序（即Google Summer of Code）开发的参与者。 他的名字叫<i>Boxuan Bxzhai-</i>我不打算抄写姓氏。 不久，他写道工作已经完成。 <br><br> 但几乎不算在内。  2ndQuadrant（即Simon Riggs盟友）的<i>Greg Smith</i>写道： <br>  <i>因此，我们的代码中有一个补丁，其中有六个严重的未解决的问题。</i>  <i>我对那些小人物保持沉默。</i>  <i>问题太深，无法最终确定commitfest的代码。</i>  <i>同时，很长一段时间以来，Boxuan都没有听到任何声音。</i>  <i>我们可以帮助他，但是他在哪里？</i>  <i>谁知道？</i> <br><br> 关于实现路径的讨论在<b>2014年</b>再次爆发，但再次没有发生：没有代码。 <br><br> 最后，早在<b>2017年，</b> <i>西蒙·里格斯</i> （ <i>Simon Riggs）</i>写道： <br>  <i>我正在研究将<code>MERGE</code>提交到<b>PostgreSQL</b>版本<b>11的</b>代码。</i>  <i>我们使用已经在起作用的<code>INSERT ON CONFLICT</code>基础相同的机制，因此不需要更改基础结构，基本上只是在可用的基础上实现语法。</i>  <i>但是我从头开始编写代码，不使用以前的开发。</i> <br><br> 我们正在谈论的是那时的Peter Geoghegan（ <b>VMware</b> ）已经以9.5替代<code>INSERT .. ON CONFLICT UPDATE</code>语法实现了<code>INSERT .. ON CONFLICT UPDATE</code> ，不同于SQL标准，但仍与MySQL中的<code>MERGE</code>和<code>REPLACE</code>有关。 <br><br> 起初，西蒙的作品受到尼斯作品的感叹！ 但是， <i>罗伯特·哈斯</i> （ <i>Robert Haas</i> ）虽然支持，但警告可能存在序列化异常。 例如，要处理<code>INSERT .. ON CONFLICT UPDATE</code> ，如果没有MERGE的基础，它就比较平静。 <br><br>  PostgreSQL <code>UPSERT</code>作者<code>UPSERT</code>本人： <br>  <i>我不会混合使用<code>ON CONFLICT DO UPDATE</code>和<code>MERGE</code> 。</i>  <i>&lt;...&gt;例如，对于加载大块数据（ <code>bulk load</code> ），我将使用<code>merge join</code>算法。</i>  <i>&lt;...&gt;通常， <code>MERGE</code>的优点与正常连接将以通常的方式在那里工作有关： <code>nested loop, hash, merge</code> 。</i>  <i>在<code>INSERT … ON CONFLICT</code>根本没有任何联接。</i> <br><br>  Haas： <i>像Peter一样，我认为如果这样做，那么执行<code>DML</code>请求时的锁定很强。</i>  <i>只有一个人一次可以与<code>MERGE</code> ，这不太可能使任何人高兴。</i> <br><br> 出于好奇：Geigan在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>分解了<code>MERGE</code>和<code>MERGE</code>之间的细微差别和明显差异（我们在我们的网站上存储了PostgreSQL的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">归档通信</a> ）。 <br><br> 西蒙抗拒。 他呼吁最近的历史。 就像关于断面一样，他们还说“一种新语法，仅此而已”。 但是事实证明这是非常有用的事情。  <i>但是我不建议立即意识到MERGE中的所有内容。</i>  <i>我们将像分区一样做-我们将开发划分为多个阶段。</i> <br><br> 在我看来，还有一种说法是很有说服力的： <i>好。</i>  <i>但是让我们选择。</i>  <i>我建议一个实用的选择。</i>  <i>从认真尝试开发<code>MERGE</code> <b>十年即将到来</b> 。</i>  <i>是不是该开始做某件事，获得一些有用的解决方案，而不是再等10年的完美解决方案了？</i>  <i>假设它存在。</i> <br><br> 最终，补丁到达社区。 几号 想象一下。 不，他们没有想到：西蒙（Simon）在2017年12月30日寄给他。 并规定这是一个WIP补丁，即“进行中的工作”-一个正在工作的补丁。 <br><br> 西蒙，一月： <br>  <i>补丁已完成，没有任何特殊错误。</i>  <i><b>1200行代码</b>以及测试和文档。</i>  <i>我将把他委托给这个commitfest，稍后我们将完成RLS（行级安全性-记录级的保护）和分区支持。</i> <br><br><h3> 委员会等级 </h3><br> 在这里，我们必须退一步，解释专员在社区中的作用。 历史上，专员的功能（即有权接受下一版本补丁的专员）的功能已发生变化。 很久以前，在开发人员很少的情况下，慷慨地分配了提交权。 例如，著名的（在完全不同的领域中） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>朱利安·阿桑奇</b></a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>Julian Assange）</b></a>获得了司令官头衔，只有六个补丁的作者。 现在要成为专员并不容易，几十个人中就没有新贵。  Boyus Momdjan（ <b>EnterpriseDB</b> ）有13,363次提交，Tom Lane（Tom Lane， <b>Crunchy Data</b> ）13127，Robert Haas（ <b>EnterpriseDB</b> ）-2074。顺便说一下， <b>来自俄罗斯</b>的<b>唯一提交人</b>是<i>Fedor Sigaev</i> （Postodors <b>Professional的</b> Teodor Sigaev）进行了383次提交。 。 西蒙·里格斯（Simon Riggs）本人有449个人，我再说一遍：作为专员，他有足够的权力来接管和提交补丁-他和他的雇员。 另一件事是，坦率地忽略其他主要知名委员会的意见，这样做是不值得的。 他们还可以剥夺专员的身份，但是至少他们会<code>revert</code>补丁。 <br><br><h3> 战斗中的骨折 </h3><br> 当然，通常在草率的“无希望”补丁中，他们发现了新的错误。 新版本随之而来。 <br><br>  1月底，出现了一个新角色：2ndQuadrant <i>Pavan</i> （他的名字叫所有人；完全是Pavan Deolasee）的开发者。 现在，社区正在处理一连串的问题：Pavan发送了新版本并感谢批评，而Simon则以巨大的营销压力打破了它们。 <br><br> 哈斯（Haas）： <i>我不认为就排除适用于所有地方的功能做出单方面的决定是不值得的。</i>  <i>如果我们同意此修补程序中不包含某些功能-这是一回事。</i>  <i>与此不同的是，所有人在这次评论中都表示了不同意见。</i>  <i>而且我们实际上没有听到为什么应该排除这些功能的原因。</i> <br><br> 逻辑表示如下： <br><br><ul><li> 先验地，存在着严重的问题，因为它们不能不以“骑兵进攻”的方式发展。 </li><li> 即使在当前版本中接受补丁之后，也可以完成对重要功能的支持，例如版本10-11中的新分区，CTE（公用表表达式= WITH查询）或RLS（行级安全性），但前提是所提议的体系结构适合在顶部构建她想要的功能。 </li></ul><br> 第二位Peter Geigan提出了这一点： <br>  <i>通常，我会注意<b>各种功能</b>的<b>支持，因为如果有的话，它会增强人们普遍认为设计应按要求进行的认识</b> 。</i>  <i>并且，如果这样的问题是由于<code>WITH</code>表达式的支持（即<code>CTE</code> ）引起的，那么我的想法是，底层体系结构会在这里和那里引起问题。</i> <br><br> 同时，第X个小时（最后一个委员会节日）临近，MERGE上的乌云正在聚集。 创始之父并不是专门在Simon和Pavan制作的补丁的体系结构中发现严重问题。 我不必寻找问题；他们愿意开放自己。 <br><br><h3> 结局即将来临 </h3><br> 情节正在加速。 尽管其他委员会对此工作态度冷淡，但<b>在4月2日，</b> Simon决定在<b>SQL：2016</b>补丁后提交<b>Command</b> ，添加了文件，Depesz（Hubert Lubachevsky）设法在他的博客上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">宣布</a>了该文件，但在同一天，Simon将所有内容回滚了，因为错误。 <br><br> 第二天，通过添加<code>WITH</code>支持再次提交。 <br><br> 作为回应，这些指控确实是严肃的。  <i>Andres Freund</i> （ <b>EnterpriseDB</b> ）写道： <br>  <i>解析器和执行程序中MERGE的体系结构并没有给我留下深刻的印象。</i>  <i>在解析分析期间创建隐藏的联接是一个非常糟糕的主意。</i>  <i>执行程序的这种结构必须完全更改。</i> <br><br> 汤姆·莱恩： <br>  <i>解析树的设计很弱。</i> <br><br><br><br>  <i>您重载了<code>InsertStmt</code>函数，他继续说，它根本不会执行<code>INSERT</code> ，但是它随机地具有与原始字段相同的字段。</i>  <i>不是全部，而是一些。</i>  <i>这是不好的，它导致混乱。</i> <br><br> 让我们添加对<i>Fedor Sigayev</i>的观察： <br>  <i>在解析器中， <code>MERGE</code>与<code>MERGE</code>相关的<code>INSERT</code>节点， <code>MERGE</code>节点上悬挂着许多其他字段。</i>  <i>如果您在<code>ANALIZE</code>查看执行计划，则不会立即了解您是在处理常规<code>INSERT</code>还是在处理<code>MERGE</code> ：要了解，您需要查看其他字段。</i> <br><br><br> 西蒙，冷静地说： <i>好，我们将更改它，明天再发送一个新文件</i> 。 <br> 哈斯： <i>我同意彼得的看法。</i>  <i>架构的选择是不成功的。</i> <br><br> 西蒙不放弃。  <b>4月6日</b> ，响应对Tom Lane的批评，提交了一个新的修补程序，该修补程序已在解析器中进行了修改。 <br><br><h3> 谈判与投降 </h3><br> 布鲁斯·莫姆扬（Bruce Momjan） <b>4月6日</b> ： <br>  <i>我想指出的是，人们并没有要求您努力解决紧急问题。</i>  <i>他们要求您撤回补丁。</i>  <i>当然，您可以努力工作，希望他们会改变主意，但是-再次-他们没有问您。</i> <br><br> 西蒙： <i>如果汤姆[Lane]和安德烈斯[Freund]在接下来的几天中仍然感到他们的恐惧没有消除，我<b>将很乐意退一步</b> 。</i> <br><br> 汤姆·莱恩（Tom Lane）： <i>我仍然投票赞成将补丁回滚。</i>  <i>即使他现在很完美，现在人们也没有时间相信这一点-涉及其他紧急问题。</i> <br><br> 仅此而已。 <br><br> 西蒙说好了，在<code>MERGE</code>的战斗结束了。 所有补丁都被抽回，主题已移动到下一个commitfest，状态为“等待作者完成”。 表演的参加者取得了和平。 <br><br><img src="https://habrastorage.org/webt/ad/zw/ry/adzwryarovhxoldwxewpneljyms.jpeg"><br> 然而，从最近几周的往来来看，似乎仍然存在一些紧张局势。 <br><br><h3> 应许的道德 </h3><br><ul><li> 幸运的是，PostgreSQL社区拥有自然的和正式的机制，可以（几乎）无冲突地筛选未成熟解决方案的尝试。 即使他们受到公司负责人的尊敬，也为PostgreSQL的发展做出了巨大贡献。 缺乏功能的客户正在努力进行投资。 </li><li> 不幸的是，社区经常停滞不前。 采用甚至明确相关的发展都是惯性的。 有时包括非理性的完美主义。 我工作的Postgres Professional的经验证实了这一点。 我们打了3年的重要重要补丁<b>INCLUDE</b> 。 用于<b>JSON / JSONB的</b>一系列有用补丁仍在等待中。  “将自己的发展带给社区”一词的意思<b>并不是真正的</b>付出<b>，而是一拳打定</b> ：向来宾张开双臂迎接客人，并陪同隔离。 </li></ul><br>  PS： <i>作者的免责声明</i> ：我们只是想展示一些社区生活。 所有名称匹配都是随机的:) <br>  PPS：武士<i>Natalia Levshina</i> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN412605/">https://habr.com/ru/post/zh-CN412605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN412591/index.html">建造喷气背包：5月29日是温德尔·摩尔纪念日</a></li>
<li><a href="../zh-CN412593/index.html">新产品，平台和全方位服务：HPE网络研讨会</a></li>
<li><a href="../zh-CN412595/index.html">《 2018年罗马俱乐部报告》第1.1.2章：“财务”</a></li>
<li><a href="../zh-CN412597/index.html">杰夫·贝佐斯（Jeff Bezos）将在月球表面建立一个殖民地</a></li>
<li><a href="../zh-CN412603/index.html">奇怪的php语句</a></li>
<li><a href="../zh-CN412607/index.html">可逆焊台HI-END级</a></li>
<li><a href="../zh-CN412609/index.html">跨平台C / C ++ IDE CLion的10个提高生产力的技巧</a></li>
<li><a href="../zh-CN412611/index.html">有效的挖掘和博弈论有什么共同点</a></li>
<li><a href="../zh-CN412613/index.html">整数运算。 将结果四舍五入。 第一部分</a></li>
<li><a href="../zh-CN412615/index.html">PE与CE之间的BGP公告中存在路由目标</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>