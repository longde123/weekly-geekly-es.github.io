<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏻 🙆🏻 🧔🏼 Programación asíncrona C #: ¿Cómo le va con el rendimiento? 🕵🏽 🍭 🕝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Más recientemente, ya hablamos sobre si anular Equals y GetHashCode al programar en C #. Hoy nos ocuparemos de los parámetros de rendimiento de los mé...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programación asíncrona C #: ¿Cómo le va con el rendimiento?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/420627/">  Más recientemente, ya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hablamos</a> sobre si anular Equals y GetHashCode al programar en C #.  Hoy nos ocuparemos de los parámetros de rendimiento de los métodos asincrónicos.  Únete ahora! <br><br><img src="https://habrastorage.org/webt/ag/zp/yy/agzpyy85elnfvb3vg4qotz0wt6s.jpeg"><a name="habracut"></a><br><br>  En los últimos dos artículos en el blog msdn, observamos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estructura interna de los métodos asincrónicos en C #</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los puntos de extensión</a> que el compilador de C # proporciona para controlar el comportamiento de los métodos asincrónicos. <br><br>  Según la información del primer artículo, el compilador realiza muchas transformaciones para hacer que la programación asincrónica sea lo más parecida posible a la sincrónica.  Para hacer esto, crea una instancia de la máquina de estados, se la pasa al constructor del método asincrónico, que llama al objeto camarero para la tarea, etc. Por supuesto, esa lógica tiene un precio, pero ¿cuánto nos cuesta? <br><br>  Hasta que apareció la biblioteca TPL, las operaciones asincrónicas no se utilizaron en una cantidad tan grande, por lo tanto, los costos no eran altos.  Pero hoy, incluso una aplicación relativamente simple puede realizar cientos, si no miles, de operaciones asincrónicas por segundo.  La biblioteca de tareas paralelas de TPL se creó con esa carga de trabajo en mente, pero aquí no hay magia y hay que pagar por todo. <br><br>  Para estimar los costos de los métodos asincrónicos, utilizaremos un ejemplo ligeramente modificado del primer artículo. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StockPrices</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name, <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> price)&gt; _stockPricesCache; <span class="hljs-comment"><span class="hljs-comment">// Async version public async Task&lt;decimal&gt; GetStockPriceForAsync(string companyId) { await InitializeMapIfNeededAsync(); return DoGetPriceFromCache(companyId); } // Sync version that calls async init public decimal GetStockPriceFor(string companyId) { InitializeMapIfNeededAsync().GetAwaiter().GetResult(); return DoGetPriceFromCache(companyId); } // Purely sync version public decimal GetPriceFromCacheFor(string companyId) { InitializeMapIfNeeded(); return DoGetPriceFromCache(companyId); } private decimal DoGetPriceFromCache(string name) { foreach (var kvp in _stockPricesCache) { if (kvp.name == name) { return kvp.price; } } throw new InvalidOperationException($"Can't find price for '{name}'."); } [MethodImpl(MethodImplOptions.NoInlining)] private void InitializeMapIfNeeded() { // Similar initialization logic. } private async Task InitializeMapIfNeededAsync() { if (_stockPricesCache != null) { return; } await Task.Delay(42); // Getting the stock prices from the external source. // Generate 1000 items to make cache hit somewhat expensive _stockPricesCache = Enumerable.Range(1, Count) .Select(n =&gt; (name: n.ToString(), price: (decimal)n)) .ToList(); _stockPricesCache.Add((name: "MSFT", price: 42)); } }</span></span></code> </pre> <br>  La clase <code>StockPrices</code> los precios de las acciones de una fuente externa y le permite solicitarlos a través de la API.  La principal diferencia con el ejemplo del primer artículo es la transición de un diccionario a una lista de precios.  Para estimar los costos de varios métodos asincrónicos en comparación con los métodos sincrónicos, la operación en sí misma debe hacer un cierto trabajo, en nuestro caso, es una búsqueda lineal de precios de acciones. <br><br>  El método <code>GetPricesFromCache</code> construye intencionalmente alrededor de un bucle simple para evitar la asignación de recursos. <br><br><h2>  Comparación de métodos sincrónicos y métodos asincrónicos basados ​​en tareas </h2><br>  En la primera prueba de rendimiento, comparamos el método asincrónico que llama al método de inicialización asincrónica ( <code>GetStockPriceForAsync</code> ), el método síncrono que llama al método de inicialización asincrónica ( <code>GetStockPriceFor</code> ) y el método síncrono que llama al método de inicialización síncrona. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> StockPrices _stockPrices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StockPrices(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SyncVsAsyncBenchmark</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Warming up the cache _stockPrices.GetStockPriceForAsync("MSFT").GetAwaiter().GetResult(); } [Benchmark] public decimal GetPricesDirectlyFromCache() { return _stockPrices.GetPriceFromCacheFor("MSFT"); } [Benchmark(Baseline = true)] public decimal GetStockPriceFor() { return _stockPrices.GetStockPriceFor("MSFT"); } [Benchmark] public decimal GetStockPriceForAsync() { return _stockPrices.GetStockPriceForAsync("MSFT").GetAwaiter().GetResult(); }</span></span></code> </pre><br>  Los resultados se muestran a continuación: <br><br><img src="https://habrastorage.org/webt/nc/cb/zd/nccbzd9-gv5ehroih0zxvdofc20.png"><br><br>  Ya en esta etapa recibimos datos bastante interesantes: <br><br><ul><li>  El método asincrónico es bastante rápido.  <code>GetPricesForAsync</code> ejecuta sincrónicamente en esta prueba y es aproximadamente un 15% (*) más lento que el método puramente sincrónico. </li><li>  El método sincrónico <code>GetPricesFor</code> , que llama al método asincrónico <code>InitializeMapIfNeededAsync</code> , tiene costos aún más bajos, pero lo más sorprendente es que no asigna recursos en absoluto (en la columna Asignada en la tabla anterior, cuesta 0 para <code>GetPricesDirectlyFromCache</code> y <code>GetStockPriceFor</code> ). </li></ul><br>  <i>(*) Por supuesto, no se puede decir que los costos de ejecutar sincrónicamente el método asincrónico son del 15% para todos los casos posibles.</i>  <i>Este valor depende directamente de la carga de trabajo realizada por el método.</i>  <i>La diferencia entre la sobrecarga de una invocación pura de un método asincrónico (que no hace nada) y un método síncrono (que no hace nada) será enorme.</i>  <i>La idea de esta prueba comparativa es mostrar que los costos del método asincrónico, que realiza una cantidad relativamente pequeña de trabajo, son relativamente bajos.</i> <br><br>  ¿Cómo es que cuando llamas a <code>InitializeMapIfNeededAsync</code> , los recursos no se asignan en absoluto?  En el primer artículo de esta serie, mencioné que un método asincrónico debería asignar al menos un objeto en el encabezado administrado: la instancia de la tarea misma.  Analicemos este punto con más detalle. <br><br><h2>  Optimización n. ° 1: instancias de tareas de almacenamiento en caché cuando sea posible </h2><br>  La respuesta a la pregunta anterior es muy simple: <code>AsyncMethodBuilder</code> <b>utiliza una instancia de la tarea para cada operación asincrónica completada con éxito</b> .  El método asincrónico que devuelve <code>Task</code> utiliza <code>AsyncMethodBuilder</code> con la siguiente lógica en el método <code>SetResult</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// AsyncMethodBuilder.cs from mscorlib public void SetResult() { // Ie the resulting task for all successfully completed // methods is the same -- s_cachedCompleted. m_builder.SetResult(s_cachedCompleted); }</span></span></code> </pre> <br>  El método <code>SetResult</code> llama solo para métodos asincrónicos completados con éxito, y un <b>resultado exitoso para cada método basado en <code>Task</code> se puede usar libremente juntos</b> .  Incluso podemos rastrear este comportamiento con la siguiente prueba: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncVoidBuilderCachesResultingTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = Foo(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = Foo(); Assert.AreSame(t1, t2); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } }</code> </pre><br>  Pero esta no es la única optimización posible.  <code>AsyncTaskMethodBuilder&lt;T&gt;</code> optimiza el trabajo de manera similar: almacena en caché las tareas para la <code>Task&lt;bool&gt;</code> y algunos otros tipos simples.  Por ejemplo, almacena en caché todos los valores predeterminados para un grupo de tipos enteros y utiliza una memoria caché especial para la <code>Task&lt;int&gt;</code> , colocando valores del rango [-1;  9] (para más detalles, vea <code>AsyncTaskMethodBuilder&lt;T&gt;.GetTaskForResult()</code> ). <br><br>  Esto se confirma con la siguiente prueba: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncTaskBuilderCachesResultingTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// These values are cached Assert.AreSame(Foo(-1), Foo(-1)); Assert.AreSame(Foo(8), Foo(8)); // But these are not Assert.AreNotSame(Foo(9), Foo(9)); Assert.AreNotSame(Foo(int.MaxValue), Foo(int.MaxValue)); async Task&lt;int&gt; Foo(int n) =&gt; n; }</span></span></code> </pre><br>  <b>No confíe demasiado en ese comportamiento</b> , pero siempre es bueno darse cuenta de que los creadores del lenguaje y la plataforma están haciendo todo lo posible para aumentar la productividad en todas las formas disponibles.  El almacenamiento en caché de tareas es un método de optimización popular que también se usa en otras áreas.  Por ejemplo, una nueva implementación de <code>Socket</code> en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio de</a> repositorios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">corefx hace</a> un uso extensivo de este método y aplica <a href="">tareas en caché</a> siempre <a href="">que</a> sea ​​posible. <br><br><h2>  Optimización # 2: Uso de <code>ValueTask</code> </h2><br>  El método de optimización descrito anteriormente solo funciona en algunos casos.  Por lo tanto, en lugar de ello, podemos usar <code>ValueTask&lt;T&gt;</code> (**), un tipo especial de valor similar a la tarea;  no asignará recursos si el método se ejecuta sincrónicamente. <br><br>  <code>ValueTask&lt;T&gt;</code> es una combinación distinguible de <code>T</code> y <code>Task&lt;T&gt;</code> : si se completa la "tarea de valor", se utilizará el valor base.  Si la asignación básica aún no se ha agotado, se asignarán recursos para la tarea. <br><br>  Este tipo especial ayuda a evitar el aprovisionamiento excesivo de almacenamiento dinámico cuando se realiza una operación sincrónicamente.  Para usar <code>ValueTask&lt;T&gt;</code> , debe cambiar el tipo de retorno para <code>GetStockPriceForAsync</code> : en lugar de <code>Task&lt;decimal&gt;</code> debe especificar <code>ValueTask&lt;decimal&gt;</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> InitializeMapIfNeededAsync(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DoGetPriceFromCache(companyId); }</code> </pre><br>  Ahora podemos evaluar la diferencia usando una prueba comparativa adicional: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Benchmark</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceValueTaskForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); }</code> </pre><br><img src="https://habrastorage.org/webt/ek/pm/o5/ekpmo5bxsquftyndmelvwgsgjsc.png"><br><br>  Como puede ver, la versión con <code>ValueTask</code> es solo un poco más rápida que la versión con Task.  La principal diferencia es que se evita la asignación del montón.  En un minuto discutiremos la viabilidad de tal transición, pero antes de eso me gustaría hablar sobre una optimización difícil. <br><br><h2>  Optimización No. 3: abandono de métodos asincrónicos dentro de una ruta común </h2><br>  Si a menudo usa algún método asincrónico y desea reducir los costos aún más, le sugiero la siguiente optimización: elimine el modificador asincrónico y luego verifique el estado de la tarea dentro del método y realice toda la operación de forma sincrónica, abandonando por completo los enfoques asincrónicos. <br><br>  ¿Parece complicado?  Considera un ejemplo. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = InitializeMapIfNeededAsync(); <span class="hljs-comment"><span class="hljs-comment">// Optimizing for acommon case: no async machinery involved. if (task.IsCompleted) { return new ValueTask&lt;decimal&gt;(DoGetPriceFromCache(companyId)); } return DoGetStockPricesForAsync(task, companyId); async ValueTask&lt;decimal&gt; DoGetStockPricesForAsync(Task initializeTask, string localCompanyId) { await initializeTask; return DoGetPriceFromCache(localCompanyId); } }</span></span></code> </pre><br>  En este caso, el modificador <code>async</code> no se usa en el método <code>GetStockPriceWithValueTaskAsync_Optimized</code> , por lo que cuando recibe una tarea del método <code>InitializeMapIfNeededAsync</code> , verifica su estado de ejecución.  Si la tarea se completa, el método simplemente usa <code>DoGetPriceFromCache</code> para obtener el resultado inmediatamente.  Si la tarea de inicialización aún está en progreso, el método llama a una función local y espera los resultados. <br><br>  Usar una función local no es la única, sino una de las formas más fáciles.  Pero hay una advertencia.  Durante la implementación más natural, la función local recibirá un estado externo (variable local y argumento): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Oops! This will lead to a closure allocation at the beginning of the method! var task = InitializeMapIfNeededAsync(); // Optimizing for acommon case: no async machinery involved. if (task.IsCompleted) { return new ValueTask&lt;decimal&gt;(DoGetPriceFromCache(companyId)); } return DoGetStockPricesForAsync(); async ValueTask&lt;decimal&gt; DoGetStockPricesForAsync() { await task; return DoGetPriceFromCache(companyId); } }</span></span></code> </pre><br>  Pero, desafortunadamente, debido a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un error del compilador,</a> este código generará un cierre, incluso si el método se ejecuta dentro de la ruta común.  Así es como se ve este método desde adentro: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closure = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> __DisplayClass0_0() { __this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, companyId = companyId, task = InitializeMapIfNeededAsync() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (closure.task.IsCompleted) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ... } <span class="hljs-comment"><span class="hljs-comment">// The rest of the code }</span></span></code> </pre><br>  Como se discutió en el artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Disección de las funciones locales en C #</a> , el compilador utiliza una instancia común de cierre para todas las variables y argumentos locales en un área específica.  En consecuencia, tiene cierto sentido en dicha generación de código, pero hace que toda la lucha con la asignación de montones sea inútil. <br><br>  <b>CONSEJO</b>  Tal optimización es una cosa muy insidiosa.  Los beneficios son insignificantes, e incluso si escribe la función local original <b>correcta</b> , puede obtener accidentalmente un estado externo que hace que se asigne el montón.  Todavía puede recurrir a la optimización si trabaja con una biblioteca de uso común (por ejemplo, BCL) en un método que definitivamente se utilizará en una sección de código cargada. <br><br><h4>  Costos asociados con la espera de una tarea. </h4><br>  Por el momento, hemos considerado solo un caso específico: la sobrecarga de un método asincrónico que se ejecuta sincrónicamente.  Esto se hace a propósito.  Cuanto más pequeño es el método asincrónico, más notables son los costos en su rendimiento general.  Los métodos asincrónicos más detallados, como regla, se ejecutan sincrónicamente y realizan una carga de trabajo más pequeña.  Y generalmente los llamamos con más frecuencia. <br><br>  Pero debemos ser conscientes de los costos del mecanismo asincrónico cuando el método "espera" la finalización de una tarea pendiente.  Para estimar estos costos, realizaremos cambios en <code>InitializeMapIfNeededAsync</code> y llamaremos a <code>Task.Yield()</code> incluso cuando se inicialice el caché: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeMapIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_stockPricesCache != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Yield(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Old initialization logic }</span></span></code> </pre><br>  Agregamos los siguientes métodos a nuestro paquete de referencia para pruebas comparativas: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Benchmark</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceFor_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceFor(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceForAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceValueTaskForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); }</code> </pre><br><img src="https://habrastorage.org/webt/d9/hm/qt/d9hmqtsqod_pexw3xdmfprfww2m.png"><br><br>  Como puede ver, la diferencia es palpable, tanto en términos de velocidad como en términos de uso de memoria.  Explica brevemente los resultados. <br><br><ul><li>  Cada operación en espera para una tarea inacabada toma aproximadamente 4 microsegundos y asigna casi 300 bytes (**) para cada llamada.  Es por eso que GetStockPriceFor se ejecuta casi el doble de rápido que GetStockPriceForAsync y asigna menos memoria. </li><li>  Un método asincrónico basado en ValueTask tarda un poco más que la variante con Task, cuando este método no se ejecuta sincrónicamente.  Una máquina de estado de un método basado en ValueTask &lt;T&gt; debería almacenar más datos que una máquina de estado de un método basado en la Tarea &lt;T&gt;. </li></ul><br>  <i>(**) Depende de la plataforma (x64 o x86) y varias variables locales y argumentos del método asincrónico.</i> <br><br><h4>  Método asincrónico Rendimiento 101 </h4><br><ul><li>  Si el método asincrónico se ejecuta sincrónicamente, la sobrecarga es bastante pequeña. </li><li>  Si el método asincrónico se ejecuta sincrónicamente, se produce la siguiente sobrecarga de memoria: para los métodos de Tarea asíncrona, no hay sobrecarga, y para los métodos de Tarea asíncrona &lt;T&gt;, la saturación es de 88 bytes por operación (para plataformas x64). </li><li>  ValueTask &lt;T&gt; elimina la sobrecarga antes mencionada para los métodos asincrónicos ejecutados sincrónicamente. </li><li>  Cuando un método asincrónico basado en ValueTask &lt;T&gt; se ejecuta sincrónicamente, lleva un poco menos de tiempo que el método con la Tarea &lt;T&gt;, de lo contrario, existen ligeras diferencias a favor de la segunda opción. </li><li>  La sobrecarga de rendimiento para los métodos asincrónicos que esperan completar una tarea sin terminar es significativamente mayor (aproximadamente 300 bytes por operación para plataformas x64). </li></ul><br>  Por supuesto, las medidas son nuestro todo.  Si ve que una operación asincrónica está causando problemas de rendimiento, puede cambiar de la <code>Task&lt;T&gt;</code> a <code>ValueTask&lt;T&gt;</code> , almacenar en caché la tarea o hacer que la ruta de ejecución general sea síncrona, si es posible.  También puede intentar agregar sus operaciones asincrónicas.  Esto ayudará a mejorar el rendimiento, simplificar la depuración y el análisis de código en general.  <b>No todas las piezas pequeñas de código deben ser asíncronas.</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420627/">https://habr.com/ru/post/es420627/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420615/index.html">JavaScript: explorar objetos</a></li>
<li><a href="../es420617/index.html">Guía de diseño web para desarrolladores</a></li>
<li><a href="../es420619/index.html">Imágenes receptivas: trucos CSS que ahorran tiempo</a></li>
<li><a href="../es420623/index.html">Aplicaciones C ++ distribuidas con un mínimo de esfuerzo.</a></li>
<li><a href="../es420625/index.html">KDD 2018, Día uno, tutoriales</a></li>
<li><a href="../es420629/index.html">PHP Digest No. 137 (6 al 20 de agosto de 2018)</a></li>
<li><a href="../es420631/index.html">No tenemos miedo a las "nubes"</a></li>
<li><a href="../es420633/index.html">Escribir un exportador GeoIP para Prometheus con visualizaciones en Grafana en 15 minutos</a></li>
<li><a href="../es420635/index.html">AI, curso práctico. El modelo básico para reconocer emociones en imágenes.</a></li>
<li><a href="../es420637/index.html">Revisión de la impresora 3D WANHAO D9 / 300: video</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>