<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Programaci贸n as铆ncrona C #: 驴C贸mo le va con el rendimiento? 叼  </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="M谩s recientemente, ya hablamos sobre si anular Equals y GetHashCode al programar en C #. Hoy nos ocuparemos de los par谩metros de rendimiento de los m茅...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programaci贸n as铆ncrona C #: 驴C贸mo le va con el rendimiento?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/420627/">  M谩s recientemente, ya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hablamos</a> sobre si anular Equals y GetHashCode al programar en C #.  Hoy nos ocuparemos de los par谩metros de rendimiento de los m茅todos asincr贸nicos.  nete ahora! <br><br><img src="https://habrastorage.org/webt/ag/zp/yy/agzpyy85elnfvb3vg4qotz0wt6s.jpeg"><a name="habracut"></a><br><br>  En los 煤ltimos dos art铆culos en el blog msdn, observamos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estructura interna de los m茅todos asincr贸nicos en C #</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los puntos de extensi贸n</a> que el compilador de C # proporciona para controlar el comportamiento de los m茅todos asincr贸nicos. <br><br>  Seg煤n la informaci贸n del primer art铆culo, el compilador realiza muchas transformaciones para hacer que la programaci贸n asincr贸nica sea lo m谩s parecida posible a la sincr贸nica.  Para hacer esto, crea una instancia de la m谩quina de estados, se la pasa al constructor del m茅todo asincr贸nico, que llama al objeto camarero para la tarea, etc. Por supuesto, esa l贸gica tiene un precio, pero 驴cu谩nto nos cuesta? <br><br>  Hasta que apareci贸 la biblioteca TPL, las operaciones asincr贸nicas no se utilizaron en una cantidad tan grande, por lo tanto, los costos no eran altos.  Pero hoy, incluso una aplicaci贸n relativamente simple puede realizar cientos, si no miles, de operaciones asincr贸nicas por segundo.  La biblioteca de tareas paralelas de TPL se cre贸 con esa carga de trabajo en mente, pero aqu铆 no hay magia y hay que pagar por todo. <br><br>  Para estimar los costos de los m茅todos asincr贸nicos, utilizaremos un ejemplo ligeramente modificado del primer art铆culo. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StockPrices</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name, <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> price)&gt; _stockPricesCache; <span class="hljs-comment"><span class="hljs-comment">// Async version public async Task&lt;decimal&gt; GetStockPriceForAsync(string companyId) { await InitializeMapIfNeededAsync(); return DoGetPriceFromCache(companyId); } // Sync version that calls async init public decimal GetStockPriceFor(string companyId) { InitializeMapIfNeededAsync().GetAwaiter().GetResult(); return DoGetPriceFromCache(companyId); } // Purely sync version public decimal GetPriceFromCacheFor(string companyId) { InitializeMapIfNeeded(); return DoGetPriceFromCache(companyId); } private decimal DoGetPriceFromCache(string name) { foreach (var kvp in _stockPricesCache) { if (kvp.name == name) { return kvp.price; } } throw new InvalidOperationException($"Can't find price for '{name}'."); } [MethodImpl(MethodImplOptions.NoInlining)] private void InitializeMapIfNeeded() { // Similar initialization logic. } private async Task InitializeMapIfNeededAsync() { if (_stockPricesCache != null) { return; } await Task.Delay(42); // Getting the stock prices from the external source. // Generate 1000 items to make cache hit somewhat expensive _stockPricesCache = Enumerable.Range(1, Count) .Select(n =&gt; (name: n.ToString(), price: (decimal)n)) .ToList(); _stockPricesCache.Add((name: "MSFT", price: 42)); } }</span></span></code> </pre> <br>  La clase <code>StockPrices</code> los precios de las acciones de una fuente externa y le permite solicitarlos a trav茅s de la API.  La principal diferencia con el ejemplo del primer art铆culo es la transici贸n de un diccionario a una lista de precios.  Para estimar los costos de varios m茅todos asincr贸nicos en comparaci贸n con los m茅todos sincr贸nicos, la operaci贸n en s铆 misma debe hacer un cierto trabajo, en nuestro caso, es una b煤squeda lineal de precios de acciones. <br><br>  El m茅todo <code>GetPricesFromCache</code> construye intencionalmente alrededor de un bucle simple para evitar la asignaci贸n de recursos. <br><br><h2>  Comparaci贸n de m茅todos sincr贸nicos y m茅todos asincr贸nicos basados en tareas </h2><br>  En la primera prueba de rendimiento, comparamos el m茅todo asincr贸nico que llama al m茅todo de inicializaci贸n asincr贸nica ( <code>GetStockPriceForAsync</code> ), el m茅todo s铆ncrono que llama al m茅todo de inicializaci贸n asincr贸nica ( <code>GetStockPriceFor</code> ) y el m茅todo s铆ncrono que llama al m茅todo de inicializaci贸n s铆ncrona. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> StockPrices _stockPrices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StockPrices(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SyncVsAsyncBenchmark</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Warming up the cache _stockPrices.GetStockPriceForAsync("MSFT").GetAwaiter().GetResult(); } [Benchmark] public decimal GetPricesDirectlyFromCache() { return _stockPrices.GetPriceFromCacheFor("MSFT"); } [Benchmark(Baseline = true)] public decimal GetStockPriceFor() { return _stockPrices.GetStockPriceFor("MSFT"); } [Benchmark] public decimal GetStockPriceForAsync() { return _stockPrices.GetStockPriceForAsync("MSFT").GetAwaiter().GetResult(); }</span></span></code> </pre><br>  Los resultados se muestran a continuaci贸n: <br><br><img src="https://habrastorage.org/webt/nc/cb/zd/nccbzd9-gv5ehroih0zxvdofc20.png"><br><br>  Ya en esta etapa recibimos datos bastante interesantes: <br><br><ul><li>  El m茅todo asincr贸nico es bastante r谩pido.  <code>GetPricesForAsync</code> ejecuta sincr贸nicamente en esta prueba y es aproximadamente un 15% (*) m谩s lento que el m茅todo puramente sincr贸nico. </li><li>  El m茅todo sincr贸nico <code>GetPricesFor</code> , que llama al m茅todo asincr贸nico <code>InitializeMapIfNeededAsync</code> , tiene costos a煤n m谩s bajos, pero lo m谩s sorprendente es que no asigna recursos en absoluto (en la columna Asignada en la tabla anterior, cuesta 0 para <code>GetPricesDirectlyFromCache</code> y <code>GetStockPriceFor</code> ). </li></ul><br>  <i>(*) Por supuesto, no se puede decir que los costos de ejecutar sincr贸nicamente el m茅todo asincr贸nico son del 15% para todos los casos posibles.</i>  <i>Este valor depende directamente de la carga de trabajo realizada por el m茅todo.</i>  <i>La diferencia entre la sobrecarga de una invocaci贸n pura de un m茅todo asincr贸nico (que no hace nada) y un m茅todo s铆ncrono (que no hace nada) ser谩 enorme.</i>  <i>La idea de esta prueba comparativa es mostrar que los costos del m茅todo asincr贸nico, que realiza una cantidad relativamente peque帽a de trabajo, son relativamente bajos.</i> <br><br>  驴C贸mo es que cuando llamas a <code>InitializeMapIfNeededAsync</code> , los recursos no se asignan en absoluto?  En el primer art铆culo de esta serie, mencion茅 que un m茅todo asincr贸nico deber铆a asignar al menos un objeto en el encabezado administrado: la instancia de la tarea misma.  Analicemos este punto con m谩s detalle. <br><br><h2>  Optimizaci贸n n. 掳 1: instancias de tareas de almacenamiento en cach茅 cuando sea posible </h2><br>  La respuesta a la pregunta anterior es muy simple: <code>AsyncMethodBuilder</code> <b>utiliza una instancia de la tarea para cada operaci贸n asincr贸nica completada con 茅xito</b> .  El m茅todo asincr贸nico que devuelve <code>Task</code> utiliza <code>AsyncMethodBuilder</code> con la siguiente l贸gica en el m茅todo <code>SetResult</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// AsyncMethodBuilder.cs from mscorlib public void SetResult() { // Ie the resulting task for all successfully completed // methods is the same -- s_cachedCompleted. m_builder.SetResult(s_cachedCompleted); }</span></span></code> </pre> <br>  El m茅todo <code>SetResult</code> llama solo para m茅todos asincr贸nicos completados con 茅xito, y un <b>resultado exitoso para cada m茅todo basado en <code>Task</code> se puede usar libremente juntos</b> .  Incluso podemos rastrear este comportamiento con la siguiente prueba: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncVoidBuilderCachesResultingTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = Foo(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = Foo(); Assert.AreSame(t1, t2); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } }</code> </pre><br>  Pero esta no es la 煤nica optimizaci贸n posible.  <code>AsyncTaskMethodBuilder&lt;T&gt;</code> optimiza el trabajo de manera similar: almacena en cach茅 las tareas para la <code>Task&lt;bool&gt;</code> y algunos otros tipos simples.  Por ejemplo, almacena en cach茅 todos los valores predeterminados para un grupo de tipos enteros y utiliza una memoria cach茅 especial para la <code>Task&lt;int&gt;</code> , colocando valores del rango [-1;  9] (para m谩s detalles, vea <code>AsyncTaskMethodBuilder&lt;T&gt;.GetTaskForResult()</code> ). <br><br>  Esto se confirma con la siguiente prueba: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncTaskBuilderCachesResultingTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// These values are cached Assert.AreSame(Foo(-1), Foo(-1)); Assert.AreSame(Foo(8), Foo(8)); // But these are not Assert.AreNotSame(Foo(9), Foo(9)); Assert.AreNotSame(Foo(int.MaxValue), Foo(int.MaxValue)); async Task&lt;int&gt; Foo(int n) =&gt; n; }</span></span></code> </pre><br>  <b>No conf铆e demasiado en ese comportamiento</b> , pero siempre es bueno darse cuenta de que los creadores del lenguaje y la plataforma est谩n haciendo todo lo posible para aumentar la productividad en todas las formas disponibles.  El almacenamiento en cach茅 de tareas es un m茅todo de optimizaci贸n popular que tambi茅n se usa en otras 谩reas.  Por ejemplo, una nueva implementaci贸n de <code>Socket</code> en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio de</a> repositorios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">corefx hace</a> un uso extensivo de este m茅todo y aplica <a href="">tareas en cach茅</a> siempre <a href="">que</a> sea posible. <br><br><h2>  Optimizaci贸n # 2: Uso de <code>ValueTask</code> </h2><br>  El m茅todo de optimizaci贸n descrito anteriormente solo funciona en algunos casos.  Por lo tanto, en lugar de ello, podemos usar <code>ValueTask&lt;T&gt;</code> (**), un tipo especial de valor similar a la tarea;  no asignar谩 recursos si el m茅todo se ejecuta sincr贸nicamente. <br><br>  <code>ValueTask&lt;T&gt;</code> es una combinaci贸n distinguible de <code>T</code> y <code>Task&lt;T&gt;</code> : si se completa la "tarea de valor", se utilizar谩 el valor base.  Si la asignaci贸n b谩sica a煤n no se ha agotado, se asignar谩n recursos para la tarea. <br><br>  Este tipo especial ayuda a evitar el aprovisionamiento excesivo de almacenamiento din谩mico cuando se realiza una operaci贸n sincr贸nicamente.  Para usar <code>ValueTask&lt;T&gt;</code> , debe cambiar el tipo de retorno para <code>GetStockPriceForAsync</code> : en lugar de <code>Task&lt;decimal&gt;</code> debe especificar <code>ValueTask&lt;decimal&gt;</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> InitializeMapIfNeededAsync(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DoGetPriceFromCache(companyId); }</code> </pre><br>  Ahora podemos evaluar la diferencia usando una prueba comparativa adicional: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Benchmark</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceValueTaskForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); }</code> </pre><br><img src="https://habrastorage.org/webt/ek/pm/o5/ekpmo5bxsquftyndmelvwgsgjsc.png"><br><br>  Como puede ver, la versi贸n con <code>ValueTask</code> es solo un poco m谩s r谩pida que la versi贸n con Task.  La principal diferencia es que se evita la asignaci贸n del mont贸n.  En un minuto discutiremos la viabilidad de tal transici贸n, pero antes de eso me gustar铆a hablar sobre una optimizaci贸n dif铆cil. <br><br><h2>  Optimizaci贸n No. 3: abandono de m茅todos asincr贸nicos dentro de una ruta com煤n </h2><br>  Si a menudo usa alg煤n m茅todo asincr贸nico y desea reducir los costos a煤n m谩s, le sugiero la siguiente optimizaci贸n: elimine el modificador asincr贸nico y luego verifique el estado de la tarea dentro del m茅todo y realice toda la operaci贸n de forma sincr贸nica, abandonando por completo los enfoques asincr贸nicos. <br><br>  驴Parece complicado?  Considera un ejemplo. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = InitializeMapIfNeededAsync(); <span class="hljs-comment"><span class="hljs-comment">// Optimizing for acommon case: no async machinery involved. if (task.IsCompleted) { return new ValueTask&lt;decimal&gt;(DoGetPriceFromCache(companyId)); } return DoGetStockPricesForAsync(task, companyId); async ValueTask&lt;decimal&gt; DoGetStockPricesForAsync(Task initializeTask, string localCompanyId) { await initializeTask; return DoGetPriceFromCache(localCompanyId); } }</span></span></code> </pre><br>  En este caso, el modificador <code>async</code> no se usa en el m茅todo <code>GetStockPriceWithValueTaskAsync_Optimized</code> , por lo que cuando recibe una tarea del m茅todo <code>InitializeMapIfNeededAsync</code> , verifica su estado de ejecuci贸n.  Si la tarea se completa, el m茅todo simplemente usa <code>DoGetPriceFromCache</code> para obtener el resultado inmediatamente.  Si la tarea de inicializaci贸n a煤n est谩 en progreso, el m茅todo llama a una funci贸n local y espera los resultados. <br><br>  Usar una funci贸n local no es la 煤nica, sino una de las formas m谩s f谩ciles.  Pero hay una advertencia.  Durante la implementaci贸n m谩s natural, la funci贸n local recibir谩 un estado externo (variable local y argumento): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Oops! This will lead to a closure allocation at the beginning of the method! var task = InitializeMapIfNeededAsync(); // Optimizing for acommon case: no async machinery involved. if (task.IsCompleted) { return new ValueTask&lt;decimal&gt;(DoGetPriceFromCache(companyId)); } return DoGetStockPricesForAsync(); async ValueTask&lt;decimal&gt; DoGetStockPricesForAsync() { await task; return DoGetPriceFromCache(companyId); } }</span></span></code> </pre><br>  Pero, desafortunadamente, debido a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un error del compilador,</a> este c贸digo generar谩 un cierre, incluso si el m茅todo se ejecuta dentro de la ruta com煤n.  As铆 es como se ve este m茅todo desde adentro: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closure = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> __DisplayClass0_0() { __this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, companyId = companyId, task = InitializeMapIfNeededAsync() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (closure.task.IsCompleted) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ... } <span class="hljs-comment"><span class="hljs-comment">// The rest of the code }</span></span></code> </pre><br>  Como se discuti贸 en el art铆culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Disecci贸n de las funciones locales en C #</a> , el compilador utiliza una instancia com煤n de cierre para todas las variables y argumentos locales en un 谩rea espec铆fica.  En consecuencia, tiene cierto sentido en dicha generaci贸n de c贸digo, pero hace que toda la lucha con la asignaci贸n de montones sea in煤til. <br><br>  <b>CONSEJO</b>  Tal optimizaci贸n es una cosa muy insidiosa.  Los beneficios son insignificantes, e incluso si escribe la funci贸n local original <b>correcta</b> , puede obtener accidentalmente un estado externo que hace que se asigne el mont贸n.  Todav铆a puede recurrir a la optimizaci贸n si trabaja con una biblioteca de uso com煤n (por ejemplo, BCL) en un m茅todo que definitivamente se utilizar谩 en una secci贸n de c贸digo cargada. <br><br><h4>  Costos asociados con la espera de una tarea. </h4><br>  Por el momento, hemos considerado solo un caso espec铆fico: la sobrecarga de un m茅todo asincr贸nico que se ejecuta sincr贸nicamente.  Esto se hace a prop贸sito.  Cuanto m谩s peque帽o es el m茅todo asincr贸nico, m谩s notables son los costos en su rendimiento general.  Los m茅todos asincr贸nicos m谩s detallados, como regla, se ejecutan sincr贸nicamente y realizan una carga de trabajo m谩s peque帽a.  Y generalmente los llamamos con m谩s frecuencia. <br><br>  Pero debemos ser conscientes de los costos del mecanismo asincr贸nico cuando el m茅todo "espera" la finalizaci贸n de una tarea pendiente.  Para estimar estos costos, realizaremos cambios en <code>InitializeMapIfNeededAsync</code> y llamaremos a <code>Task.Yield()</code> incluso cuando se inicialice el cach茅: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeMapIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_stockPricesCache != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Yield(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Old initialization logic }</span></span></code> </pre><br>  Agregamos los siguientes m茅todos a nuestro paquete de referencia para pruebas comparativas: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Benchmark</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceFor_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceFor(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceForAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceValueTaskForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); }</code> </pre><br><img src="https://habrastorage.org/webt/d9/hm/qt/d9hmqtsqod_pexw3xdmfprfww2m.png"><br><br>  Como puede ver, la diferencia es palpable, tanto en t茅rminos de velocidad como en t茅rminos de uso de memoria.  Explica brevemente los resultados. <br><br><ul><li>  Cada operaci贸n en espera para una tarea inacabada toma aproximadamente 4 microsegundos y asigna casi 300 bytes (**) para cada llamada.  Es por eso que GetStockPriceFor se ejecuta casi el doble de r谩pido que GetStockPriceForAsync y asigna menos memoria. </li><li>  Un m茅todo asincr贸nico basado en ValueTask tarda un poco m谩s que la variante con Task, cuando este m茅todo no se ejecuta sincr贸nicamente.  Una m谩quina de estado de un m茅todo basado en ValueTask &lt;T&gt; deber铆a almacenar m谩s datos que una m谩quina de estado de un m茅todo basado en la Tarea &lt;T&gt;. </li></ul><br>  <i>(**) Depende de la plataforma (x64 o x86) y varias variables locales y argumentos del m茅todo asincr贸nico.</i> <br><br><h4>  M茅todo asincr贸nico Rendimiento 101 </h4><br><ul><li>  Si el m茅todo asincr贸nico se ejecuta sincr贸nicamente, la sobrecarga es bastante peque帽a. </li><li>  Si el m茅todo asincr贸nico se ejecuta sincr贸nicamente, se produce la siguiente sobrecarga de memoria: para los m茅todos de Tarea as铆ncrona, no hay sobrecarga, y para los m茅todos de Tarea as铆ncrona &lt;T&gt;, la saturaci贸n es de 88 bytes por operaci贸n (para plataformas x64). </li><li>  ValueTask &lt;T&gt; elimina la sobrecarga antes mencionada para los m茅todos asincr贸nicos ejecutados sincr贸nicamente. </li><li>  Cuando un m茅todo asincr贸nico basado en ValueTask &lt;T&gt; se ejecuta sincr贸nicamente, lleva un poco menos de tiempo que el m茅todo con la Tarea &lt;T&gt;, de lo contrario, existen ligeras diferencias a favor de la segunda opci贸n. </li><li>  La sobrecarga de rendimiento para los m茅todos asincr贸nicos que esperan completar una tarea sin terminar es significativamente mayor (aproximadamente 300 bytes por operaci贸n para plataformas x64). </li></ul><br>  Por supuesto, las medidas son nuestro todo.  Si ve que una operaci贸n asincr贸nica est谩 causando problemas de rendimiento, puede cambiar de la <code>Task&lt;T&gt;</code> a <code>ValueTask&lt;T&gt;</code> , almacenar en cach茅 la tarea o hacer que la ruta de ejecuci贸n general sea s铆ncrona, si es posible.  Tambi茅n puede intentar agregar sus operaciones asincr贸nicas.  Esto ayudar谩 a mejorar el rendimiento, simplificar la depuraci贸n y el an谩lisis de c贸digo en general.  <b>No todas las piezas peque帽as de c贸digo deben ser as铆ncronas.</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420627/">https://habr.com/ru/post/es420627/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420615/index.html">JavaScript: explorar objetos</a></li>
<li><a href="../es420617/index.html">Gu铆a de dise帽o web para desarrolladores</a></li>
<li><a href="../es420619/index.html">Im谩genes receptivas: trucos CSS que ahorran tiempo</a></li>
<li><a href="../es420623/index.html">Aplicaciones C ++ distribuidas con un m铆nimo de esfuerzo.</a></li>
<li><a href="../es420625/index.html">KDD 2018, D铆a uno, tutoriales</a></li>
<li><a href="../es420629/index.html">PHP Digest No. 137 (6 al 20 de agosto de 2018)</a></li>
<li><a href="../es420631/index.html">No tenemos miedo a las "nubes"</a></li>
<li><a href="../es420633/index.html">Escribir un exportador GeoIP para Prometheus con visualizaciones en Grafana en 15 minutos</a></li>
<li><a href="../es420635/index.html">AI, curso pr谩ctico. El modelo b谩sico para reconocer emociones en im谩genes.</a></li>
<li><a href="../es420637/index.html">Revisi贸n de la impresora 3D WANHAO D9 / 300: video</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>