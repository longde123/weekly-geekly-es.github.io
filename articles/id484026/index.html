<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸµï¸ ğŸ¤›ğŸ¿ ğŸ’‰ Bagian 6: Porting MemTest86 + ke RISC-V ğŸš ğŸ§—ğŸ¼ ğŸ‘©ğŸ»â€ğŸ¤â€ğŸ‘¨ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mungkin sedikit orang IT yang perlu menjelaskan apa itu Memtest86 + - mungkin sudah menjadi kurang lebih standar dalam pengujian RAM pada PC. Ketika d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagian 6: Porting MemTest86 + ke RISC-V</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484026/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ne/fb/ha/nefbhar5ihkfmvccfwp0jqrm78u.png"></div><br><p> Mungkin sedikit orang IT yang perlu menjelaskan apa itu Memtest86 + - mungkin sudah menjadi kurang lebih standar dalam pengujian RAM pada PC.  Ketika di salah satu bagian <a href="https://habr.com/ru/post/459470/">sebelumnya</a> saya menemukan bilah memori yang rusak yang dibundel dengan papan, itu (bersama dengan netbook yang diaktifkan DDR2) tampak solusi yang jelas.  Pertanyaan lain adalah bahwa di sana, pada prinsipnya, operasi sistem yang tidak stabil terlihat dengan mata telanjang.  Dalam kasus yang lebih rumit, saya mendengar bahwa selain "penyadapan" dangkal sel memori hingga tak terbatas, alat ini menggunakan beberapa pola data khusus di mana kesalahan DDR lebih mungkin terdeteksi.  Secara umum, hal yang luar biasa, sangat disayangkan bahkan dalam namanya tertulis: 86 - "Hanya untuk sistem yang kompatibel dengan x86."  Atau tidak? </p><br><p>  Di bawah potongan Anda akan melihat upaya saya untuk port MemTest86 + v5.1 ke RISC-V dan subtotal.  <em>Spoiler: bergerak!</em> </p><a name="habracut"></a><br><p>  <strong>PENOLAKAN: proyek yang dihasilkan minimal diuji secara khusus oleh saya pada perakitan RocketChip tertentu pada papan tertentu.</strong>  <strong>Keakuratan dan keamanan (terutama pada sistem lain) tidak dijamin.</strong>  <strong>Gunakan dengan risiko Anda sendiri.</strong>  <strong>Secara khusus, area memori yang dipesan saat ini tidak diproses dengan cara apa pun jika masuk dalam kisaran RAM.</strong> </p><br><p>  Seperti yang sudah saya katakan, belum lama ini saya membeli motherboard dengan Cyclone IV di AliExpress, tetapi memori di dalamnya bermasalah.  Untungnya, salah satu fitur penting dari board ini adalah penggunaan modul DDR2 SO-DIMM konvensional - sama seperti pada netbook lama saya.  Namun demikian, itu akan menarik untuk mendapatkan, sehingga untuk berbicara, solusi self-host untuk menguji modul memori (dan, pada kenyataannya, juga pengontrol).  Prospek kesalahan saya debugging dalam kondisi memori buruk entah bagaimana sama sekali tidak menyenangkan.  Terutama tidak berharap untuk solusi cepat dan secara mental bersiap untuk menunda penulisan ulang lengkap di assembler lain untuk waktu yang lama, saya membuka artikel Wikipedia tentang Memtest86 + dan tiba-tiba melihat "Ditulis dalam: C dan perakitan" di kartu.  Hmm, yaitu, dia, meskipun "... 86", tetapi tidak sepenuhnya ditulis assembler?  Ini menggembirakan.  Tetap hanya untuk memahami hubungan. </p><br><p>  Jadi, buka <a href="http://www.memtest.org/" rel="nofollow">memtest.org</a> dan unduh versi 5.01 di bawah GPL2.  Untuk kemudahan pengembangan, saya <a href="https://github.com/atrosinenko/memtest86-plus-riscv" rel="nofollow">memuatnya</a> kembali di GitHub.  Untungnya, tepat di arsip sumber, kami disambut oleh file <a href="https://github.com/atrosinenko/memtest86-plus-riscv/blob/68b365d13cf22accd52f88af49c33f57c6643ae5/README.background" rel="nofollow">README.background</a> , berhak </p><br><blockquote>  Anatomi &amp; Fisiologi Memtest86-SMP </blockquote><p> Ini menjelaskan secara rinci (dan bahkan dengan gambar dalam bentuk ASCII-art) operasi kode tingkat tinggi.  Di awal dokumen, kita melihat <em>tata letak Biner</em> , yang terdiri dari <code>bootsect.o</code> , <code>setup.o</code> , <code>head.o</code> dan beberapa <code>memtest_shared</code> .  Sangat mudah untuk melihat bahwa ketiga file objek ini diperoleh dari sumber assembler yang sesuai.  Sepintas, semua yang lain ditulis dalam C!  Tidak buruk, tidak buruk ... </p><br><p>  Akibatnya, saya menyalin <code>Makefile</code> ke <code>Makefile.arch</code> dan mulai menulis ulang semuanya, dan mencoba untuk membuang yang tidak sesuai.  Pertama-tama, tentu saja, saya membutuhkan toolchain untuk RISC-V, yang, untungnya, masih bersama saya sejak percobaan sebelumnya.  Pada awalnya saya berpikir untuk membuat port untuk arsitektur 32-bit, tetapi kemudian saya ingat bahwa prosesor 64-bit diunggah ke papan, dan saya memiliki <code>riscv64-</code> dengan <code>riscv64-</code> awalan. </p><br><p>  <em>Penyimpangan liris:</em> tentu saja, hal pertama adalah mempelajari masalah kompatibilitas kode 32-dan 64-bit.  Sebagai hasilnya, spesifikasi untuk bagian yang tidak terjangkau dari ISA (Instruction Set Architecture) ditemukan dalam paragraf <code>1.3 RISC-V ISA Overview</code> pernyataan <code>1.3 RISC-V ISA Overview</code> : </p><br><blockquote>  Keuntungan utama dari memisahkan ISA basis secara eksplisit adalah bahwa setiap ISA basis dapat dioptimalkan untuk kebutuhannya tanpa perlu mendukung semua operasi yang diperlukan untuk ISA basis lainnya.  Misalnya, RV64I dapat menghilangkan instruksi dan CSR yang hanya diperlukan untuk mengatasi register yang lebih sempit di RV32I.  Opsi RV32I dapat menggunakan ruang enkode yang disediakan untuk instruksi hanya diperlukan oleh varian ruang alamat yang lebih luas. </blockquote><p>  Saya juga ingin mencatat bahwa toolchain dengan <code>riscv64-</code> awalan cenderung dengan mudah mengumpulkan kode 32-bit jika arsitektur target dipilih dengan benar - lebih lanjut tentang itu nanti. </p><br><p>  Dalam proses porting, membuat dokumen-dokumen ini berguna: </p><br><ul><li>  <a href="https://riscv.org/specifications/" rel="nofollow">Instruksi Set Manual RISC-V Volume I: ISA yang tidak terjangkau</a> </li><li>  <a href="https://riscv.org/specifications/privileged-isa/" rel="nofollow">Manual Set Instruksi RISC-V Volume II: Arsitektur Privileged</a> </li><li>  Juga, beberapa <a href="https://sifive.cdn.prismic.io/sifive%252F834354f0-08e6-423c-bf1f-0cb58ef14061_fu540-c000-v1.0.pdf" rel="nofollow">SiFive FU540-C000 Manual</a> - manual untuk chip, serupa dalam perilaku dengan prosesor lunak, yang digunakan untuk debugging di FPGA, tidak akan keluar dari tempatnya </li></ul><br><h2 id="nastroyka-sborki">  Penyiapan bangun </h2><br><p>  Mari kita mulai dengan menyetujui: Saya ingin mendapatkan port yang cocok untuk porting lebih lanjut ke arsitektur selain x86 dan RISC-V.  Saya juga mengusulkan untuk membuang disket boot dan spesifik x86 lainnya dari cross-platform build. </p><br><p>  Apa yang akhirnya kita miliki: ada tiga file assembler: <code>bootsect.S</code> , <code>setup.S</code> dan <code>head.S</code>  Dua yang pertama diperlukan hanya pada saat startup, dan yang ketiga diperlukan nanti ketika pindah ke area memori lain.  Faktanya adalah bahwa untuk menguji memori "di bawah diri sendiri", kode pengujian pertama-tama harus pindah ke tempat baru.  File Sich dikumpulkan dalam ELF, dari mana bagian kode, data, dll. Kemudian diambil.  Selain itu, dikumpulkan dalam bentuk PIC (Position Independent Code) - pada awalnya saya bahkan terkejut: meskipun kode tersebut berdiri bebas (yaitu, tanpa kernel, libc, dll.), Ia menggunakan fitur-fitur canggih seperti itu. </p><br><p>  Selanjutnya, parameter yang mendefinisikan arsitektur secara berkala menemukan di Makefile: <code>-march=i486</code> , <code>-m32</code> dan sejenisnya.  Saya perlu menulis sesuatu seperti itu, <del>  dan kemudian seperti pengisap </del>  .  Dengan indikasi arsitektur, situasi dengan RISC-V adalah sesuatu seperti ini: ada opsi untuk <code>rv32</code> dan <code>rv64</code> (seperti, masih ada embedded paling terpotong dan dicadangkan untuk <code>rv128</code> masa depan, tetapi kami tidak terlalu tertarik pada mereka), dan nama ISA dibentuk dengan memberikan huruf pada awalan ini. ekstensi: <code>i</code> - kumpulan integer dasar instruksi, perkalian dan pembagian <code>m</code> - integer, ... Tentu saja, saya ingin melakukan <code>rv64i</code> , tetapi Memtest86 tidak akan dengan mudah dipindahkan ke arsitektur tanpa perkalian.  Benar, tampaknya kompiler hanya akan menghasilkan panggilan fungsi daripada instruksi "bermasalah", tetapi ada risiko yang tersisa dengan kinerja sangat berkurang (belum lagi bahwa fungsi-fungsi ini perlu ditulis atau dibawa ke suatu tempat). </p><br><p>  Anda juga akan membutuhkan garis ABI.  Pada prinsipnya, dasar-dasar konvensi pemanggilan sudah dijelaskan dalam <code>Volume I</code> ditentukan dalam "Buku Pegangan Programmer Perakitan RISC-V", jadi saya akan melakukan sesuatu seperti: </p><br><pre> <code class="plaintext hljs">$ riscv64-linux-gnu-gcc-9 -mabi=help riscv64-linux-gnu-gcc-9: error: unrecognized argument in option '-mabi=help' riscv64-linux-gnu-gcc-9: note: valid arguments to '-mabi=' are: ilp32 ilp32d ilp32e ilp32f lp64 lp64d lp64f riscv64-linux-gnu-gcc-9: fatal error: no input files compilation terminated.</code> </pre> <br><p>  Dan tanpa berpikir <code>lp64</code> , saya akan mengambil <code>lp64</code> .  <em>Ke depan, saya akan mengatakan bahwa dengan ABI ini, file header dari perpustakaan standar tidak berfungsi, jadi saya mengambil <code>lp64f</code> , dan ARCH "ditingkatkan" ke <code>rv64imf</code> .</em>  <em>Tanpa panik, saya tidak berencana untuk benar-benar menggunakan floating point di port saya.</em> </p><br><p>  Karena saya entah bagaimana tidak ingin menulis skrip linker lintas platform - dan karenanya saya tidak dapat segera <em>menemukan kunci untuk menemukan</em> , saya memutuskan untuk bertahan dengan file assembler <code>head.S</code> ., Berpegang teguh pada sisa fungsi menggunakan <code>memtest_shared.arch.lds</code> .  Saya membuang indikasi format output dan arsitektur darinya (setelah semua, lebih mudah untuk mengubahnya dari variabel di Makefile), dan juga untuk sementara mengomentari <code>DISCARD</code> pada akhirnya, tidak dapat mengetahui bagian tertentu dari informasi debug yang saya butuhkan.  <em>(Melihat ke depan: informasi debug yang bagus, tetapi <code>.rela</code> harus ditambahkan)</em> Secara umum, versi x86 menekankan perlunya memuat dalam 64k - Saya harap ini hanya terkait dengan fitur mode nyata dan tidak menjadi perhatian kami pada RISC-V .  Akibatnya, objek bersama dengan PIC akan dikumpulkan, seperti dalam aslinya, kode dan data yang akan dimuat ke dalam memori akan digigit keluar dari itu. </p><br><p>  Kami mengumpulkan ... dan kompilasi jatuh pada file <code>reloc.c</code> pertama - itu, tampaknya, diambil dari beberapa <code>ld-linux.so</code> dan bertanggung jawab untuk mendukung Global Offset Table, dll.  sesuai dengan konvensi pemanggilan untuk x86.  Ternyata diperlukan kerja langsung dengan register menggunakan insert assembler.  Tapi kami berada di RISC-V - ini awalnya dibuat untuk mendukung PIC secara <code>reloc.c</code> , jadi silakan melempar <code>reloc.c</code> .  Selanjutnya, masih ada sisipan, terkadang cukup panjang.  Untungnya, mereka berada dalam kode tes segera setelah kode C yang dikomentari, yang mereka optimalkan (dari mereka saya kembali membuat potongan kode yang diubah oleh arahan preprocessor) atau sesuatu yang bergantung pada platform, yang tanpanya, dalam kasus ekstrim, saya dapat (mungkin) lakukan (seperti menyalakan / mematikan cache, mengurangi CPUID, dll.).  Akhirnya, ada beberapa hal seperti panggilan <code>rdtsc</code> , yang saya <code>rdtsc</code> , tanpa masalah besar dimasukkan ke header platform-dependent dan mengimplementasikannya sesuai dengan dokumentasi pada RISC-V. </p><br><p>  Hasilnya, kami mendapatkan direktori <code>arch/i386</code> , tempat sejumlah besar kode dukungan PCI dipindahkan, membaca informasi dari chipset, definisi platform-spesifik dari alamat yang dipetakan dengan memori, dll.  Juga, awal dari fungsi <code>test_start</code> , yang merupakan titik masuk dari <code>setup.S</code> ke kode C. Berapa lama, pendek, tetapi mengomentari segala sesuatu yang mungkin dan menyadari segala sesuatu yang tidak dapat dikomentari di bawah RISC-V (seperti <code>setup.S</code> dan kode untuk bekerja dengan port serial dalam implementasi SiFive), saya mendapat <code>arch/riscv</code> , yang semuanya dikompilasi. </p><br><p>  Di sini saya dipaksa untuk mengklarifikasi bahwa percobaan itu sendiri sebagian dilakukan sebelum penulisan artikel, sehingga <em>urutan</em> tindakan tertentu mungkin mengandung sejumlah "fiksi artistik".  Namun, saya mencoba untuk setidaknya melakukan presentasi sedemikian rupa sehingga dalam hal apa pun itu merupakan salah satu jalur yang mungkin <em>(saya seorang programmer, saya ingat itu)</em> .  Jadi mari kita lihat bagaimana memulai semuanya. </p><br><h2 id="zapusk-na-zheleze">  Berlari di atas besi </h2><br><p>  Sejak percobaan sebelumnya, saya masih memiliki "dudukan" berdebu dari Raspberry Pi, yang disambungkan ke papan debug.  Kabel menyediakan UART, JTAG dan adaptor dengan kartu SD.  Prosesor RV64 tertentu dengan pengontrol DDR2 dijahit ke dalam memori konfigurasi.  Seperti pada waktu sebelumnya, saya menyalakan "raspberry", buka dua sesi SSH sebelumnya, salah satunya meneruskan 3333 port TCP untuk menghubungkan gdb ke OpenOCD.  Dalam salah satu sesi, saya memulai minicom untuk menonton UART, di sesi lain - openocd untuk debug dari host melalui JTAG.  Saya menyalakan daya papan - dan pesan di konsol tentang bagaimana memuat data dari SD berlari. </p><br><p>  Sekarang Anda dapat menjalankan perintah: </p><br><pre> <code class="plaintext hljs">riscv64-unknown-elf-gdb \ -ex 'target remote 127.0.0.1:3333' \ -ex 'restore /path/to/memtest_shared.bin binary 0x80010000' \ -ex 'add-symbol-file /path/to/memtest_shared 0x80010000' -ex 'set $pc=0x80010000'</code> </pre> <br><p>  opsi <code>-ex</code> gdb untuk berpura-pura bahwa pengguna telah memasukkan perintah-perintah ini dari konsol: </p><br><ul><li>  yang pertama membuat koneksi dengan OpenOCD </li><li>  yang kedua menyalin isi dari file host yang ditentukan ke alamat yang ditentukan </li><li>  yang ketiga menjelaskan kepada gdb bahwa informasi tentang kode sumber harus diambil dari file <em>ini</em> , dengan mempertimbangkan fakta bahwa kode itu diunduh di alamat <em>ini</em> (dan bukan apa yang ditunjukkan di dalamnya) <br><ul><li>  catatan: kita mengambil karakter dari file ELF, dan memuat biner "mentah" </li></ul></li><li>  akhirnya, yang keempat secara paksa menerjemahkan pointer perintah saat ini ke kode kami </li></ul><br><p>  Sayangnya, tidak semuanya berjalan lancar, dan meskipun baris kode di debugger ditampilkan dengan benar, tetapi di semua variabel global - nol.  Bahkan, jika kita menjalankan perintah form <code>p &amp;global_var</code> di gdb, sayangnya, kita lihat alamatnya sesuai dengan alamat unduhan awal (saya punya <code>0x0</code> ), yang tidak ditentukan menggunakan <code>add-symbol-file</code> .  Sebagai penopang, tetapi solusi yang sangat sederhana, saya hanya menambahkan <code>0x80010000</code> ke alamat yang ditentukan secara manual dan melihat isi memori melalui <code>x/x 0xADDR</code> .  Bahkan, mungkin untuk sementara menunjukkan alamat awal yang benar dalam skrip tautan, yang <em>saat ini</em> akan bertepatan dengan alamat unduhan dalam <em>konfigurasi pengujian ini</em> . </p><br><h2 id="osobennosti-relokacii-na-sovremennyh-arhitekturah">  Fitur relokasi pada arsitektur modern </h2><br><p>  Nah, bagaimana cara mengunduh kodenya, entah bagaimana caranya - kita memulainya.  Tidak bekerja  Langkah-demi-langkah debugging menunjukkan bahwa kita jatuh selama operasi fungsi <code>switch_to_main_stack</code> - tampaknya masih mencoba untuk menggunakan nilai yang tidak terkait dari alamat simbol yang sesuai dengan tumpukan kerja. </p><br><p>  Semua sama, volume pertama dari dokumentasi memberi tahu kita tentang berbagai instruksi semu dan kerja mereka dengan PIC hidup dan mati: </p><br><p><img src="https://habrastorage.org/webt/vj/7-/_u/vj7-_uqmqyqjloo1webrgpqsdc8.png" alt="Beberapa pengajaran semu RISC-V"></p><br><p>  Seperti yang Anda lihat, prinsip umum adalah bahwa alamat dalam memori dihitung dari instruksi saat ini, dengan yang pertama menambahkan bagian atas offset, dan selanjutnya <code>add</code> memoles bit urutan rendah.  Hampir tidak membantu untuk mendeklarasikan variabel global like </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vars</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">variables</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br><p>  Oleh karena itu, kami mengambil dokumentasi RISC-V ELF psABI dengan <a href="" rel="nofollow">deskripsi jenis relokasi</a> dan menulis bagian platform khusus untuk <code>reloc.c</code> .  Di sini harus dicatat bahwa file asli, tampaknya, diambil dari kode lintas platform.  Di sana, bahkan alih-alih menentukan kedalaman bit tertentu, makro jenis <code>ElfW(Addr)</code> , <code>Elf32_Addr</code> ke <code>Elf32_Addr</code> atau <code>Elf64_Addr</code> .  Tidak di mana-mana, bagaimanapun, itu sebabnya kami menambahkan mereka di mana mereka tidak berada dalam kode umum (juga dalam kode <a href="" rel="nofollow"><code>arch/riscv/reloc.inc.c</code></a> - lagipula, untuk RISC-V tidak ada rasa khusus untuk terikat pada kedalaman bit tertentu, di mana tidak ada wajib). </p><br><p>  Akibatnya, <code>switch_to_main_stack</code> mulai lulus (bukan tanpa instruksi assembler yang tergantung platform, tentu saja).  Debugger menunjukkan variabel global masih bengkok.  Baiklah, oke :( </p><br><h2 id="opredelenie-oborudovaniya">  Definisi Perangkat Keras </h2><br><p>  Tentu saja, untuk pengujian akan mungkin untuk menggunakan konstanta hard-coded bukan kode definisi peralatan yang dibuang, tetapi untuk setiap perakitan prosesor tertentu, membangun kembali memtest bahkan terlalu mahal menurut standar aplikasi saya.  Karena itu, kita akan bertindak "sebagai orang dewasa yang serius."  Untungnya, pada RISC-V (dan mungkin pada kebanyakan arsitektur modern), sudah biasa bagi bootloader untuk meneruskan kode ke <a href="https://en.wikipedia.org/wiki/Device_tree" rel="nofollow">Device Tree Blob</a> , yang merupakan versi kompilasi dari deskripsi DTS seperti ini: </p><br><div class="spoiler">  <b class="spoiler_title">zeowaa-1gb.dts</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/dts-v1/; / { #address-cells = ^_^lt gt^_^; #size-cells = ^_^lt gt^_^; compatible = "freechips,rocketchip-unknown-dev"; model = "freechips,rocketchip-unknown"; chosen { bootargs = "console=ttySIF0,125200 debug loglevel=7"; }; firmware { sifive,uboot = "YYYY-MM-DD"; }; L16: aliases { serial0 = &amp;L8; }; L15: cpus { #address-cells = ^_^lt gt^_^; #size-cells = ^_^lt&amp;#0;gt^_^; timebase-frequency = ^_^ltó´‰€gt^_^; L5: cpu@0 { device_type = "cpu"; clock-frequency = ^_^lt&amp;#0;gt^_^; compatible = "sifive,rocket0", "riscv"; d-cache-block-size = ^_^lt gt^_^; d-cache-sets = ^_^lt@gt^_^; d-cache-size = ^_^ltá€€gt^_^; d-tlb-sets = ^_^lt gt^_^; d-tlb-size = ^_^lt gt^_^; i-cache-block-size = ^_^lt gt^_^; i-cache-sets = ^_^lt@gt^_^; i-cache-size = ^_^ltá€€gt^_^; i-tlb-sets = ^_^lt gt^_^; i-tlb-size = ^_^lt gt^_^; mmu-type = "riscv,sv39"; next-level-cache = &lt;&amp;L10&gt;; reg = &lt;0x0&gt;; riscv,isa = "rv64imafdc"; status = "okay"; timebase-frequency = ^_^ltó´‰€gt^_^; tlb-split; L3: interrupt-controller { #interrupt-cells = ^_^lt gt^_^; compatible = "riscv,cpu-intc"; interrupt-controller; }; }; }; L10: ram@80000000 { device_type = "memory"; reg = &lt;0x0 0x80000000 0x0 0x40000000&gt;; reg-names = "mem"; }; L14: soc { #address-cells = ^_^lt gt^_^; #size-cells = ^_^lt gt^_^; compatible = "freechips,rocketchip-unknown-soc", "simple-bus"; ranges; L1: clint@2000000 { compatible = "riscv,clint0"; interrupts-extended = &lt;&amp;L3 3 &amp;L3 7&gt;; reg = &lt;0x2000000 0x10000&gt;; reg-names = "control"; }; L2: debug-controller@0 { compatible = "sifive,debug-013", "riscv,debug-013"; interrupts-extended = &lt;&amp;L3 65535&gt;; reg = &lt;0x0 0x1000&gt;; reg-names = "control"; }; L9: gpio@64002000 { #gpio-cells = ^_^lt gt^_^; #interrupt-cells = ^_^lt gt^_^; compatible = "sifive,gpio0"; gpio-controller; interrupt-controller; interrupt-parent = &lt;&amp;L0&gt;; interrupts = &lt;3 4 5 6 7 8&gt;; reg = &lt;0x64002000 0x1000&gt;; reg-names = "control"; }; L0: interrupt-controller@c000000 { #interrupt-cells = ^_^lt gt^_^; compatible = "riscv,plic0"; interrupt-controller; interrupts-extended = &lt;&amp;L3 11 &amp;L3 9&gt;; reg = &lt;0xc000000 0x4000000&gt;; reg-names = "control"; riscv,max-priority = ^_^lt gt^_^; riscv,ndev = ^_^lt gt^_^; }; L6: rom@10000 { compatible = "sifive,maskrom0"; reg = &lt;0x10000 0x2000&gt;; reg-names = "mem"; }; L8: serial@64000000 { compatible = "sifive,uart0"; interrupt-parent = &lt;&amp;L0&gt;; clocks = &lt;&amp;tlclk&gt;; interrupts = ^_^lt gt^_^; reg = &lt;0x64000000 0x1000&gt;; reg-names = "control"; }; L7: spi@64001000 { #address-cells = ^_^lt gt^_^; #size-cells = ^_^lt&amp;#0;gt^_^; compatible = "sifive,spi0"; interrupt-parent = &lt;&amp;L0&gt;; interrupts = ^_^lt gt^_^; reg = &lt;0x64001000 0x1000&gt;; clocks = &lt;&amp;tlclk&gt;; reg-names = "control"; L12: mmc@0 { compatible = "mmc-spi-slot"; disable-wp; reg = &lt;0x0&gt;; spi-max-frequency = ^_^lt gt^_^; voltage-ranges = &lt;3300 3300&gt;; }; }; tlclk: tlclk { #clock-cells = ^_^lt&amp;#0;gt^_^; clock-frequency = ^_^lt gt^_^; clock-output-names = "tlclk"; compatible = "fixed-clock"; }; }; };</code> </pre> </div></div><br><p>  Saya dulu mem-parsing file ELF, tapi sekarang saya kembali yakin dengan FDT (tree device datar): <a href="https://github.com/devicetree-org/devicetree-specification/releases/download/v0.2/devicetree-specification-v0.2.pdf" rel="nofollow">spesifikasi</a> <em>semacam</em> <a href="https://github.com/devicetree-org/devicetree-specification/releases/download/v0.2/devicetree-specification-v0.2.pdf" rel="nofollow">ini</a> ditulis oleh <em>orang yang peduli</em> <del>  (Namun, mereka sendiri kemudian menguraikannya!) </del>  dan parsing file seperti itu (setidaknya sampai Anda perlu memproses input yang tidak dipercaya) tidak menimbulkan masalah tertentu.  Jadi di sini: di awal file ada struktur header sederhana yang berisi angka ajaib <code>0xd00dfeed</code> dan beberapa bidang lagi.  Kami tertarik dengan offset "flat tree" <code>off_dt_struct</code> dan tabel baris <code>off_dt_strings</code> .  Sebenarnya, Anda juga perlu memproses <code>off_mem_rsvmap</code> , yang menyebutkan area memori yang sebaiknya dihindari.  Saya masih mengabaikan mereka (mereka tidak di papan saya), tetapi <strong>jangan ulangi ini di rumah</strong> . </p><br><p>  Pada prinsipnya, pemrosesan tidak terlalu sulit: Anda hanya perlu berjalan di atas pohon datar sesuai dengan token.  <em>Ada</em> tiga token <em>utama</em> : </p><br><ul><li>  <code>FDT_BEGIN_NODE</code> - dalam data tambahan segera setelah itu, muncul nama elemen subtree dalam bentuk string yang diakhiri null.  Cukup tambahkan nama ke tumpukan </li><li>  <code>FDT_END_NODE</code> - subtree selesai, hapus elemen dari tumpukan </li><li>  <code>FDT_PROP</code> - ini sedikit rumit: diikuti oleh struktur, diikuti oleh len byte data tambahan.  Nama "variabel" terletak di offset <code>nameoff</code> dalam tabel string <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> len; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> nameoff; }</code> </pre> </li></ul><br><p>  Nah, secara umum, itu saja: kita melewati bagian ini, tidak lupa untuk mengamati perataan dengan 4 byte.  Oh ya, lalat di salep: angka dalam FDT dalam format big endian, jadi kami membuat fungsi sederhana </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">be32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | (x &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | ((x &amp; <span class="hljs-number"><span class="hljs-number">0xff0000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | ((x &amp; <span class="hljs-number"><span class="hljs-number">0xff00</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); }</code> </pre> <br><p>  Akibatnya, di <code>riscv_entry</code> hal pertama yang harus dilakukan adalah mengurai FDT, dan bagian <code>head.S</code> Yang bertanggung jawab untuk mentransfer kontrol ke <code>riscv_entry</code> terlihat seperti ini </p><br><pre> <code class="plaintext hljs"> .globl startup_32 #  --    ... startup_32: lla sp, boot_stack_top mv s0, a0 # s0, s1 -- callee-saved mv s1, a1 # ...  .bss #   jal _dl_start #      mv a0, s0 mv a1, s1 j riscv_entry</code> </pre> <br><p>  Dalam register <code>a0</code> kita diberi id hart (hart adalah sesuatu seperti aliran perangkat keras dalam terminologi RISC-V) - Saya belum menggunakannya, saya harus mencari tahu dalam case single-threaded.  Dalam <code>a1</code> bootloader menempatkan pointer ke FDT.  Kami meneruskannya ke fungsi <code>void riscv_entry(ulong hartid, uint8_t *fdt_address)</code> . </p><br><p>  Sekarang, dengan munculnya parsilka FDT dalam kode saya, urutan pemuatan papan menjadi seperti ini: </p><br><ul><li>  nyalakan daya </li><li>  tunggu konsol U-boot </li><li>  masukkan perintah di dalamnya untuk menyiapkan FDT yang benar.  Khususnya, <code>/chosen/bootargs</code> command <code>/chosen/bootargs</code> menyimpan baris perintah kernel.  Segala sesuatu yang saya ambil dari FDT - rentang RAM, alamat UART, ... - dapat dan harus dibiarkan apa adanya <br><pre> <code class="plaintext hljs">run fdtsetup fdt set /chosen bootargs "console=ttyS0 btrace"</code> </pre> </li><li>  menggunakan perintah <code>fdt addr</code> , cari tahu alamat unduhan FDT, jika Anda belum melihat </li></ul><br><p>  Dan dari sisi gdb, perintah ditambahkan </p><br><ul><li> <code>-ex 'set $a1=0xfdtaddr'</code> </li> </ul><br><h2 id="vyvod-informacii-na-ekran">  Output informasi ke layar </h2><br><p>  Ternyata, selain insert assembler, ada juga alamat memori yang dikenal.  Misalnya <code>SCREEN_ADR</code> (persis seperti itu, dengan satu <code>D</code> ), yang menunjuk ke area yang sesuai dengan apa yang ditampilkan di layar.  Ketika saya menemukan ini, saya hanya menempatkan dengan gerakan lebar segala sesuatu yang merujuknya di bawah <code>#if HAS_SCREEN</code> , dan kemudian debugged secara membabi buta untuk waktu yang lama.  Saya pikir sudah secara manual sekali dalam beberapa waktu untuk membuang ini semua ke konsol, tetapi kemudian saya perhatikan bahwa kode yang sama menyakitkan banyak keluaran urutan keluaran ke port serial.  Ternyata semuanya sudah ditulis sebelum kita, Anda hanya perlu menempatkan definisi lebih akurat - dan ini dia, antarmuka yang akrab (walaupun hitam dan putih) di jendela minicom!  (Saat ini, HAS_SCREEN tidak digunakan sama sekali - saya baru saja memulai array <code>dummy_con</code> untuk mengubah kode asli minimum.) </p><br><h2 id="otladka-na-qemu">  Debug pada QEMU </h2><br><p>  Jadi saya men-debug semua yang ada di papan nyata, dan untuk beberapa waktu sekarang - bahkan tanpa membabi buta.  Tapi semuanya melambat di JTAG - horor!  Yah, pada akhirnya, semuanya harus bekerja pada perangkat keras nyata, tapi alangkah baiknya untuk debug pada QEMU.  Setelah sejumlah percobaan, sesuatu ternyata menjadi penopang, tetapi sangat mirip dengan bekerja dengan papan: </p><br><pre> <code class="plaintext hljs">$ qemu-system-riscv64 -M help Supported machines are: none empty machine sifive_e RISC-V Board compatible with SiFive E SDK sifive_u RISC-V Board compatible with SiFive U SDK spike_v1.10 RISC-V Spike Board (Privileged ISA v1.10) (default) spike_v1.9.1 RISC-V Spike Board (Privileged ISA v1.9.1) virt RISC-V VirtIO Board (Privileged ISA v1.10)</code> </pre> <br><p>  Kami melihat papan mana yang QEMU siap tiru.  Saya tertarik pada perangkat keras yang kompatibel dengan <code>sifive_u</code> . </p><br><pre> <code class="plaintext hljs">$ qemu-system-riscv64 -M sifive_u,dumpdtb -m 1g # - QEMU      on --  strace   $ ls -l on -rw-rw-r-- 1 trosinenko trosinenko 1923  19 20:14 on $ dtc -I dtb &lt; on &gt; on.dts #   $ vim on.dts #  bootargs $ dtc &lt; on.dts &gt; on.dtb &lt;stdout&gt;: Warning (clocks_property): /soc/ethernet@100900fc:clocks: cell 0 is not a phandle reference &lt;stdout&gt;: Warning (clocks_property): /soc/ethernet@100900fc:clocks: cell 1 is not a phandle reference &lt;stdout&gt;: Warning (clocks_property): /soc/ethernet@100900fc:clocks: cell 2 is not a phandle reference &lt;stdout&gt;: Warning (interrupts_extended_property): /soc/interrupt-controller@c000000:interrupts-extended: cell 0 is not a phandle reference &lt;stdout&gt;: Warning (interrupts_extended_property): /soc/interrupt-controller@c000000:interrupts-extended: cell 2 is not a phandle reference &lt;stdout&gt;: Warning (interrupts_extended_property): /soc/clint@2000000:interrupts-extended: cell 0 is not a phandle reference &lt;stdout&gt;: Warning (interrupts_extended_property): /soc/clint@2000000:interrupts-extended: cell 2 is not a phandle reference</code> </pre> <br><p>  Sekarang kita memiliki gumpalan pohon perangkat "tetap".  <strong>Tanpa mengubah konfigurasi VM</strong> (kruk!), Jalankan: </p><br><pre> <code class="plaintext hljs">qemu-system-riscv64 \ -M sifive_u -m 1g \ -serial stdio \ -s -S</code> </pre> <br><p>  <code>-serial stdio</code> mengarahkan port serial ke konsol, karena escape sequence akan digunakan secara aktif.  Opsi <code>-s -S</code> meningkatkan gdbserver dan membuat VM untuk jeda, masing-masing.  Anda dapat mengunduh kode menggunakan <code>loader</code> , tetapi Anda harus memulai ulang QEMU setiap saat. </p><br><p>  Anda dapat terhubung menggunakan </p><br><pre> <code class="plaintext hljs">riscv64-unknown-elf-gdb \ -ex 'target remote 127.0.0.1:1234' \ -ex 'restore /path/to/on.dtb binary 0x80100000' \ -ex 'restore /path/to/memtest_shared.bin binary 0x80020000' \ -ex 'add-symbol-file memtest_shared 0x80100000' \ -ex 'set $a1=0x80020000' \ -ex 'set $pc=0x80100000'</code> </pre> <br><p>  Hasilnya, semuanya bekerja lebih dari sekadar cerdas! </p><br><h2 id="obschiy-princip-raboty">  Prinsip kerja umum </h2><br><p> , ,  ,   Memtest86+   <code>btrace</code> ,        ,      (  ,     QEMU): </p><br><p><img src="https://habrastorage.org/webt/su/lr/qh/sulrqhzmiona327osxqzaikijf0.png" alt="mode btrace"></p><br><p>  ,      , memtest          .     ,      (, trap):  ,   ,   QEMU - !  Â«Â»   <code>Illegal instruction</code>  ,    .      <code>mcause</code> (?),   â€” <code>mepc</code> (?),   â€” <code>mtval</code> (    ?),    . </p><br><p><img src="https://habrastorage.org/webt/lc/is/ho/lcishowkkjngpnorx_gkyav-svg.png" alt="Instruksi ilegal"></p><br><p>   ,      : </p><br><p> <strong>head.S:</strong> </p><br><pre> <code class="plaintext hljs">#       #   = 0 ---   ,   #  ,    ,     ... lla t1, _trap_entry csrw mtvec, t1 # ... _trap_entry: csrr a0, mcause csrr a1, mepc csrr a2, mtval jal riscv_trap_entry</code> </pre> <br><p>  ,        calling convention,  .        memtest,    HiFive_U-Boot,      <code>Volume II</code> : </p><br><p> <strong>arch.c:</strong> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *errors[] = { <span class="hljs-string"><span class="hljs-string">"Instruction address misaligned"</span></span>, <span class="hljs-string"><span class="hljs-string">"Instruction access fault"</span></span>, <span class="hljs-string"><span class="hljs-string">"Illegal instruction"</span></span>, <span class="hljs-string"><span class="hljs-string">"Breakpoint"</span></span>, <span class="hljs-string"><span class="hljs-string">"Load address misaligned"</span></span>, <span class="hljs-string"><span class="hljs-string">"Load access fault"</span></span>, <span class="hljs-string"><span class="hljs-string">"Store/AMO address misaligned"</span></span>, <span class="hljs-string"><span class="hljs-string">"Store/AMO access fault"</span></span>, ^_^quot quot^_^, ^_^quot quot^_^, ^_^quot quot^_^, ^_^quot quot^_^, <span class="hljs-string"><span class="hljs-string">"Instruction page fault"</span></span>, <span class="hljs-string"><span class="hljs-string">"Load page fault"</span></span>, ^_^quot quot^_^, <span class="hljs-string"><span class="hljs-string">"Store/AMO page fault"</span></span>, }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">riscv_trap_entry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ulong cause, ulong epc, ulong tval)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">32</span></span>]; cprint(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"EXCP: "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cause &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(errors) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(errors[<span class="hljs-number"><span class="hljs-number">0</span></span>])) { cprint(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, errors[cause]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { itoa(buf, cause); cprint(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, buf); } cprint(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"PC: "</span></span>); hprint3(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, epc, <span class="hljs-number"><span class="hljs-number">8</span></span>); cprint(<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Addr: "</span></span>); hprint3(<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, tval, <span class="hljs-number"><span class="hljs-number">8</span></span>); HALT(); }</code> </pre> <br><p>        â€”    Â« Â»   .   ,   Â«Â»    ,  ,      ,  . </p><br><p>         :     .       ,  memtest  :    : Â«       ,   ,    .        Â».    :  <code>do_test</code>   <code>main.c</code>    2,   (    ),       â€”    Â«Â» ,    memtest.       ,    <code>run_at</code> ,    memtest  <code>_start</code>  <code>_end</code>    (   Â«Â»  ),  -     spinlock'        <code>goto *addr;</code>        . ,  ,      Â«Â»    ,    Â«Â». </p><br><p>      ,    <strong> </strong>  <code>bss</code>    â€”    <code>_dl_start</code>  ,   <code>riscv_entry</code>  ,   trap entry. ,   :     L1I-,   .    ,     <code>fence.i</code> . </p><br><p>   ,  Memtest86+ â€” ,         <code>barrier_s</code>    .       ,          . ,   ,       . </p><br><h2 id="podvodnye-kamni">   </h2><br><p>    ,   :   .   :           .    <em></em> : ,  -       (Own Address,     )   .     ,     ,   .       . -    .   ,   x86 , ,    <code>uint64_t</code>   <code>0x80000002</code>       . ,     : <a href="https://stackoverflow.com/questions/12491578/whats-the-actual-effect-of-successful-unaligned-accesses-on-x86" rel="nofollow"> </a> ,   load/store  x86   ,     â€” .    ,    QEMU    ,  Â«  ,      Â». </p><br><p> ,     ,  <em>  </em> â€”   unaligned access  .. </p><br><p> ,   ,     RocketChip,   â€” QEMU,   ,  ,   RocketChip â€” unaligned access trap,  QEMU  Â«  Â». <br>   Â«misalignedÂ»            ,   </p><br><blockquote> Changed description of misaligned load and store behavior. The specification now allows visible misaligned address traps in execution environment interfaces, rather than just mandating invisible handling of misaligned loads and stores in user mode. Also, now allows access exceptions to be reported for misaligned accesses (including atomics) that should not be emulated. </blockquote><p>  , ,  â€”   ,  user-mode code   ,             .     .   , ,   .   ,       â€” -   machine mode    . ,     <code>rdtsc</code> (x86)  <code>rdtime</code> (rv64),   trap,     . , ,                memory-mapped . </p><br><p>    :      ,  <em> </em>   <code>low_test_addr</code> (       ),  ,   fdt   .   ,  ,  <code>low_test_addr</code>   ,  ,      2   <code>high_test_adr</code>    â€¦ ,     â€”   : <code>head.S</code>       <code>initial_load_addr</code> ,    <code>riscv_entry</code>    <code>move_to_correct_addr</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move_to_correct_addr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> cur_start = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)&amp;_start; <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> cur_end = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)&amp;_end; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur_start == low_test_addr || cur_start == high_test_adr) { <span class="hljs-comment"><span class="hljs-comment">//  ,     return; } if (cur_start == initial_load_addr &amp;&amp; (cur_start - low_test_addr) &lt; (cur_end - cur_start) ) { //   " ":   , //           //     ,    ,   //     ... serial_echo_print("FIRST STARTUP RELOCATION...\n"); void *temp_addr = (((uintptr_t)&amp;_end &gt;&gt; 12) + 1) &lt;&lt; 12; run_at(temp_addr, 0); } else { // ,    --- ,  . serial_echo_print("FINAL STARTUP RELOCATION...\n"); run_at(low_test_addr, 0); } }</span></span></code> </pre> <br><p> ,     â€”   ,  memtest ,  RAM  -   .  RISC-V    ,        <code>v-&gt;plim_lower</code> . </p><br><p>     ,   Â«Â» ,    -,   â€”  <code>test.c</code>    <code>ulong</code> (  <code>unsigneg long</code> ),   32- x86   <code>uint32_t</code> ,    Â« 64 Â»   <code>uint64_t</code> .       Â«!!! Good: ffffffff Real: ffffffff Bad bits: 00000000Â».   ?       - -1,  32    1.   ,         ,        0â€¦  ,     : ,  <code>ulong</code>      ( <code>uint32_t</code> ),          ( <code>uintptr_t</code> ). ,       . ,     <code>uint64_t</code>   4. RISC-V  <em></em>  ,       C, ,    â€”    UB. <del>     memtest  UBSan. </del>  ,  ,  UBSan   trap-on-error        JTAG. </p><br><h2 id="upakovyvaem-dlya-zagruzchika">    </h2><br><p> ,  memtest -  ,    ,          U-Boot. </p><br><p>       :    <code>mkimage</code>   U-Boot   <em>  Linux</em> : </p><br><pre> <code class="plaintext hljs">mkimage -A riscv -O linux -T kernel -C none \ -a 0x80000000 -e 0x80000000 \ -n memtest -d memtest.bin memtest.uboot</code> </pre> <br><p>      SD-      </p><br><pre> <code class="plaintext hljs">run mmcsetup; run fdtsetup; fdt set /chosen bootargs "console=ttyS0"; fatload mmc 0:1 82000000 memtest.uboot; bootm fdt; bootm 82000000 - ${fdtaddr}</code> </pre> <br><p> (   ,   <code>run</code>     â€”        ). </p><br><p>      :       FDT: <code>0xbffb7c80</code> . ,  :    <code>ffffffff</code> ,     .     ,         (     ),    :   HiFive_U-Boot      : </p><br><pre> <code class="cpp hljs"> theKernel(machid, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)images-&gt;ft_addr);</code> </pre> <br><p>    ,     </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*theKernel)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arch, uint params);</code> </pre> <br><p>  ,     , ,  ,  32        ,     <code>head.S</code> : </p><br><pre> <code class="plaintext hljs"> li t0, 0xffffffffL and a1, a1, t0</code> </pre> <br><h2 id="promezhutochnyy-itog">   </h2><br><p> ,  , - ,  ,     ,  : </p><br><ul><li>     x86.       â€”       review         <strong>   </strong> </li><li>   SMP   RISC-V </li><li>        <code>arch/</code> -  </li><li>     <code>test.c</code>  RISC-V (      <code>-O0</code> !) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484026/">https://habr.com/ru/post/id484026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484012/index.html">Merampingkan proses penulisan dalam bloknot notebook</a></li>
<li><a href="../id484014/index.html">10 Mitos SEO untuk Ditinggalkan di Tahun 2020</a></li>
<li><a href="../id484016/index.html">Dasar-dasar pembelajaran mendalam pada contoh debug otomatisencoder, bagian nomor 1</a></li>
<li><a href="../id484018/index.html">Sisi teknis TI berperahu pesiar</a></li>
<li><a href="../id484020/index.html">Siapa yang coba Anda buat terkesan dengan tenggat waktu Anda?</a></li>
<li><a href="../id484028/index.html">Horseshoe Bend - tablet konversi dengan layar lipat</a></li>
<li><a href="../id484034/index.html">Implementasi skema kerja penyimpanan target barang berdasarkan unit akuntansi gudang 1C Otomasi Terpadu 2</a></li>
<li><a href="../id484036/index.html">Grup industri baru menciptakan standar universal untuk rumah pintar</a></li>
<li><a href="../id484046/index.html">Memeriksa Emby dengan PVS-Studio</a></li>
<li><a href="../id484048/index.html">PHP dan persamaan reguler: dasar-dasar untuk pemula</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>