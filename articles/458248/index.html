<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐂 📠 🤞🏼 Simplifique su código con Rocket Science: operador de nave espacial de C ++ 20 🚔 👨🏼‍🎨 👈🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ 20 agrega un nuevo operador, apodado cariñosamente como el operador de "nave espacial": <=> . Hubo una publicación hace un tiempo por nuestra pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Simplifique su código con Rocket Science: operador de nave espacial de C ++ 20</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/458248/"> C ++ 20 agrega un nuevo operador, apodado cariñosamente como el operador de "nave espacial": <code>&lt;=&gt;</code> .  Hubo una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicación hace</a> un tiempo por nuestra propia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Simon Brand que</a> detallaba información sobre este nuevo operador junto con información conceptual sobre lo que es y hace.  El objetivo de esta publicación es explorar algunas aplicaciones concretas de este extraño operador nuevo y su contraparte asociada, el <code>operator==</code> (¡sí, se ha cambiado, para mejor!), Mientras se proporcionan algunas pautas para su uso en el código diario. <br><br><img src="https://habrastorage.org/webt/ny/pa/bp/nypabpd9lxsd9ifx_f7_zitj7ti.png"><a name="habracut"></a><br><br><h2>  Comparaciones </h2><br>  No es raro ver código como el siguiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value == rhs.value; }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value;  }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;        }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt; rhs);    } };</code> </pre> <br>  <i>Nota: los lectores con ojos de águila notarán que esto es incluso menos detallado de lo que debería ser en el código anterior a C ++ 20 porque estas funciones deberían ser en realidad amigos no miembros, más sobre eso más adelante.</i> <br><br>  Ese es un montón de código repetitivo para escribir solo para asegurarme de que mi tipo sea comparable a algo del mismo tipo.  Bueno, está bien, lo tratamos por un tiempo.  Luego viene alguien que escribe esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(is_lt(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  Lo primero que notará es que este programa no se compilará. <br><br> <code>error C3615: constexpr function 'is_lt' cannot result in a constant expression</code> <br> <br>  Ah!  El problema es que olvidamos <code>constexpr</code> en nuestra función de comparación, ¡drat!  Entonces uno va y agrega <code>constexpr</code> a todos los operadores de comparación.  Unos días después, alguien va y agrega un ayudante <code>is_gt</code> pero se da cuenta de que todos los operadores de comparación no tienen una especificación de excepción y pasa por el mismo proceso tedioso de agregar <code>noexcept</code> a cada una de las 5 sobrecargas. <br><br>  Aquí es donde interviene el nuevo operador de la nave espacial C ++ 20 para ayudarnos.  Veamos cómo se puede escribir el <code>IntWrapper</code> original en un mundo C ++ 20: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  La primera diferencia que puede notar es la nueva inclusión de <code>&lt;compare&gt;</code> .  El encabezado <code>&lt;compare&gt;</code> es responsable de llenar el compilador con todos los tipos de categoría de comparación necesarios para que el operador de la nave espacial devuelva un tipo apropiado para nuestra función predeterminada.  En el fragmento anterior, el tipo de retorno <code>auto</code> se deducirá a <code>std::strong_ordering</code> . <br><br>  No solo eliminamos 5 líneas superfluas, sino que ni siquiera tenemos que definir nada, ¡el compilador lo hace por nosotros!  Nuestro <code>is_lt</code> permanece sin cambios y simplemente funciona mientras sigue siendo <code>constexpr</code> , aunque no lo especificamos explícitamente en nuestro <code>operator&lt;=&gt;</code> predeterminado <code>operator&lt;=&gt;</code> .  Eso está muy bien, pero algunas personas pueden estar rascándose la cabeza sobre por qué <code>is_lt</code> todavía puede compilar aunque ni siquiera use el operador de la nave espacial.  Exploremos la respuesta a esta pregunta. <br><br><h2>  Reescribiendo expresiones </h2><br>  En C ++ 20, el compilador presenta un nuevo concepto referido a expresiones "reescritas".  El operador de la nave espacial, junto con el <code>operator==</code> , se encuentran entre los dos primeros candidatos sujetos a expresiones reescritas.  Para un ejemplo más concreto de reescritura de expresiones, analicemos el ejemplo proporcionado en <code>is_lt</code> . <br><br>  Durante la resolución de sobrecarga, el compilador seleccionará de un conjunto de candidatos viables, todos los cuales coinciden con el operador que estamos buscando.  El proceso de recopilación de candidatos se modifica ligeramente para el caso de operaciones relacionales y de equivalencia en las que el compilador también debe reunir candidatos especiales reescritos y sintetizados ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">[over.match.oper] /3.4</a> ). <br><br>  Para nuestra expresión <code>a &lt; b</code> el estándar establece que podemos buscar el tipo de a para un <code>operator&lt;=&gt;</code> o un <code>operator&lt;=&gt;</code> función de alcance de espacio de nombres <code>operator&lt;=&gt;</code> que acepta su tipo.  Entonces el compilador lo hace y descubre que, de hecho, el tipo de un sí <code>IntWrapper::operator&lt;=&gt;</code> .  El compilador puede usar ese operador y reescribir la expresión <code>a &lt; b</code> as <code>(a &lt;=&gt; b) &lt; 0</code> .  Esa expresión reescrita se utiliza como candidato para la resolución de sobrecarga normal. <br><br>  Puede que te preguntes por qué esta expresión reescrita es válida y correcta.  La exactitud de la expresión en realidad proviene de la semántica que proporciona el operador de la nave espacial.  El <code>&lt;=&gt;</code> es una comparación de tres vías que implica que usted obtiene no solo un resultado binario, sino un ordenamiento (en la mayoría de los casos) y si tiene un ordenamiento puede expresar ese ordenamiento en términos de cualquier operación relacional.  Un ejemplo rápido, la expresión 4 &lt;=&gt; 5 en C ++ 20 le devolverá el resultado <code>std::strong_ordering::less</code> .  El resultado <code>std::strong_ordering::less</code> implica que <code>4</code> no solo es diferente de <code>5</code> sino que es estrictamente menor que ese valor, esto hace que la aplicación de la operación <code>(4 &lt;=&gt; 5) &lt; 0</code> correcta y exacta para describir nuestro resultado. <br><br>  El uso de la información anterior del compilador puede tomar cualquier operador relacional generalizado (es decir, <code>&lt;</code> , <code>&gt;</code> , etc.) y reescribirlo en términos del operador de la nave espacial.  En el estándar, la expresión reescrita a menudo se denomina <code>(a &lt;=&gt; b) @ 0</code> donde <code>@</code> representa cualquier operación relacional. <br><br><h2>  Sintetizar expresiones </h2><br>  Los lectores pueden haber notado la mención sutil de las expresiones "sintetizadas" arriba y también juegan un papel en este proceso de reescritura del operador.  Considere una función de predicado diferente: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_gt_42</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> &lt; a; }</code> </pre> <br>  Si usamos nuestra definición original para <code>IntWrapper</code> este código no se compilará. <br><br> <code>error C2677: binary '&lt;': no global operator found which takes type 'const IntWrapper' (or there is no acceptable conversion)</code> <br> <br>  Esto tiene sentido en la tierra anterior a C ++ 20, y la forma de resolver este problema sería agregar algunas funciones de <code>friend</code> adicionales a <code>IntWrapper</code> que toman un lado izquierdo de <code>int</code> .  Si intenta compilar esa muestra con un compilador C ++ 20 y nuestra definición C ++ 20 de <code>IntWrapper</code> , puede notar que, de nuevo, "simplemente funciona", otro rascador de cabeza.  Examinemos por qué el código anterior aún se puede compilar en C ++ 20. <br><br>  Durante la resolución de sobrecarga, el compilador también reunirá lo que el estándar se refiere como candidatos "sintetizados", o una expresión reescrita con el orden de los parámetros invertidos.  En el ejemplo anterior, el compilador intentará usar la expresión reescrita <code>(42 &lt;=&gt; a) &lt; 0</code> pero encontrará que no hay conversión de <code>IntWrapper</code> a <code>int</code> para satisfacer el lado izquierdo de modo que la expresión reescrita se descarte.  El compilador también evoca la expresión "sintetizada" <code>0 &lt; (a &lt;=&gt; 42)</code> y descubre que hay una conversión de <code>int</code> a <code>IntWrapper</code> través de su constructor de conversión, por lo que se utiliza este candidato. <br><br>  El objetivo de las expresiones sintetizadas es evitar el desorden de la necesidad de escribir el repetitivo de las funciones de <code>friend</code> para completar los espacios en los que su objeto podría convertirse de otros tipos.  Las expresiones sintetizadas se generalizan a <code>0 @ (b &lt;=&gt; a)</code> . <br><br><h2>  Tipos más complejos </h2><br>  El operador de nave espacial generado por el compilador no se detiene en miembros individuales de clases, generará un conjunto correcto de comparaciones para todos los subobjetos dentro de sus tipos: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Basics</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f;  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d;  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Basics&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arrays</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai[<span class="hljs-number"><span class="hljs-number">1</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ac[<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> af[<span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ad[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arrays&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bases</span></span></span><span class="hljs-class"> :</span></span> Basics, Arrays {  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Bases&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases a = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases b = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a == b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a != b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &lt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &lt;= b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &gt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &gt;= b); }</code> </pre> <br>  El compilador sabe cómo expandir miembros de clases que son matrices en sus listas de subobjetos y compararlos recursivamente.  Por supuesto, si desea escribir los cuerpos de estas funciones usted mismo, aún tiene el beneficio de las expresiones de reescritura del compilador para usted. <br><br><h2>  Parece un pato, nada como un pato y grazna como <code>operator==</code> </h2><br>  Algunas personas muy inteligentes en el comité de estandarización notaron que el operador de la nave espacial siempre realizará una comparación lexicográfica de elementos sin importar qué.  La realización incondicional de comparaciones lexicográficas puede conducir a un código generado ineficiente con el operador de igualdad en particular. <br><br>  El ejemplo canónico es comparar dos cadenas.  Si tiene la cadena <code>"foobar"</code> y la compara con la cadena <code>"foo"</code> usando == uno esperaría que la operación sea casi constante.  El algoritmo eficiente de comparación de cadenas es así: <br><br><ul><li>  Primero compare el tamaño de las dos cadenas, si los tamaños difieren devuelven <code>false</code> , de lo contrario </li><li>  recorra cada elemento de las dos cadenas al unísono y compare hasta que una difiera o se llegue al final, devuelva el resultado. </li></ul><br>  Según las reglas del operador de la nave espacial, primero debemos comenzar con la comparación profunda de cada elemento hasta encontrar el que es diferente.  En nuestro ejemplo de <code>"foobar"</code> y <code>"foo"</code> solo al comparar <code>'b'</code> con <code>'\0'</code> finalmente devuelve <code>false</code> . <br><br>  Para combatir esto, había un documento, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P1185R2</a> que detalla una forma para que el compilador reescriba y genere el <code>operator==</code> independientemente del operador de la nave espacial.  Nuestro <code>IntWrapper</code> podría escribirse de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default;  bool operator==(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Solo un paso más ... sin embargo, hay buenas noticias;  en realidad no necesita escribir el código anterior, ya que simplemente escribir el <code>auto operator&lt;=&gt;(const IntWrapper&amp;) const = default</code> es suficiente para que el compilador genere implícitamente el <code>operator==</code> por separado y más eficiente para usted. <br><br>  El compilador aplica una regla de "reescritura" ligeramente modificada específica para <code>==</code> y <code>!=</code> Donde en estos operadores se reescriben en términos de <code>operator==</code> y no <code>operator&lt;=&gt;</code> .  Esto significa que <code>!=</code> También se beneficia de la optimización, también. <br><br><h2>  El viejo código no se romperá </h2><br>  En este punto, podría estar pensando, OK, si el compilador puede realizar este negocio de reescritura del operador, ¿qué sucede cuando intento burlarme del compilador? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }</code> </pre> <br>  La respuesta aquí es que no lo hiciste.  El modelo de resolución de sobrecarga en C ++ tiene esta arena donde todos los candidatos luchan, y en esta batalla específica tenemos 3 candidatos: <br><br><ul><li> <code>IntWrapper::operator&lt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> <li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> </ul><br>  (reescrito) <br><br><ul><li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; b, const IntWrapper&amp; a)</code> </li> </ul><br>  (sintetizado) <br><br>  Si aceptamos las reglas de resolución de sobrecarga en C ++ 17, el resultado de esa llamada habría sido ambiguo, pero las reglas de resolución de sobrecarga de C ++ 20 se cambiaron para permitir que el compilador resuelva esta situación a la sobrecarga más lógica. <br><br>  Hay una fase de resolución de sobrecarga en la que el compilador debe realizar una serie de desempates.  En C ++ 20, hay un nuevo desempate que establece que debemos preferir las sobrecargas que no se reescriben o sintetizan, esto hace que nuestra sobrecarga <code>IntWrapper::operator&lt;</code> el mejor candidato y resuelva la ambigüedad.  Esta misma maquinaria evita que los candidatos sintetizados pisoteen expresiones regulares reescritas. <br><br><h2>  Pensamientos finales </h2><br>  El operador de nave espacial es una adición bienvenida a C ++ y es una de las características que simplificará y ayudará a escribir <i>menos</i> código y, a veces, menos es más.  ¡Así que abróchate el cinturón con el operador de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nave espacial</a> C ++ 20! <br><br>  Le instamos a salir y probar el operador de la nave espacial, ¡está disponible ahora mismo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Visual Studio 2019</a> en <code>/std:c++latest</code> !  Como nota, los cambios introducidos a través de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P1185R2</a> estarán disponibles en Visual Studio 2019 versión 16.2.  Tenga en cuenta que el operador de la nave espacial es parte de C ++ 20 y está sujeto a algunos cambios hasta el momento en que se finalice C ++ 20. <br><br>  Como siempre, agradecemos sus comentarios.  No dude en enviar cualquier comentario por correo electrónico a <a href="">visualcpp@microsoft.com</a> , a través de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Twitter @visualc</a> o Facebook en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Microsoft Visual Cpp</a> .  Además, siéntase libre de seguirme en Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@starfreakclone</a> . <br><br>  Si encuentra otros problemas con MSVC en VS 2019, infórmenos a través de la opción <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informar un problema</a> , ya sea desde el instalador o desde el IDE de Visual Studio.  Para sugerencias o informes de errores, háganos saber a través de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DevComm.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458248/">https://habr.com/ru/post/458248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458228/index.html">¿Por qué necesitamos funciones virtuales?</a></li>
<li><a href="../458230/index.html">Cómo la IA, los drones y las cámaras mantienen nuestras carreteras y puentes seguros</a></li>
<li><a href="../458240/index.html">Cómo la inteligencia artificial, los drones y las cámaras garantizan la seguridad de carreteras y puentes</a></li>
<li><a href="../458244/index.html">Una lista interminable y ridícula de lo que necesita saber para usar de forma segura las redes Wi-Fi públicas</a></li>
<li><a href="../458246/index.html">Coincidencias aleatorias en la vida, o cómo resultó que te presentaron un pastel en una fábrica de tractores</a></li>
<li><a href="../458250/index.html">BTRFS para los más pequeños</a></li>
<li><a href="../458252/index.html">Modelo matemático de un radiotelescopio superlargo</a></li>
<li><a href="../458256/index.html">¿No es hora de lavar el cerebro?</a></li>
<li><a href="../458260/index.html">Otra forma de optimizar las imágenes de Docker para aplicaciones Java</a></li>
<li><a href="../458262/index.html">Diseñador en línea de la sala de reuniones: selección de la solución óptima para la videoconferencia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>