<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÇ üì† ü§ûüèº Simplifique su c√≥digo con Rocket Science: operador de nave espacial de C ++ 20 üöî üë®üèº‚Äçüé® üëàüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ 20 agrega un nuevo operador, apodado cari√±osamente como el operador de "nave espacial": <=> . Hubo una publicaci√≥n hace un tiempo por nuestra pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Simplifique su c√≥digo con Rocket Science: operador de nave espacial de C ++ 20</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/458248/"> C ++ 20 agrega un nuevo operador, apodado cari√±osamente como el operador de "nave espacial": <code>&lt;=&gt;</code> .  Hubo una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n hace</a> un tiempo por nuestra propia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Simon Brand que</a> detallaba informaci√≥n sobre este nuevo operador junto con informaci√≥n conceptual sobre lo que es y hace.  El objetivo de esta publicaci√≥n es explorar algunas aplicaciones concretas de este extra√±o operador nuevo y su contraparte asociada, el <code>operator==</code> (¬°s√≠, se ha cambiado, para mejor!), Mientras se proporcionan algunas pautas para su uso en el c√≥digo diario. <br><br><img src="https://habrastorage.org/webt/ny/pa/bp/nypabpd9lxsd9ifx_f7_zitj7ti.png"><a name="habracut"></a><br><br><h2>  Comparaciones </h2><br>  No es raro ver c√≥digo como el siguiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value == rhs.value; }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value;  }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;        }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt; rhs);    } };</code> </pre> <br>  <i>Nota: los lectores con ojos de √°guila notar√°n que esto es incluso menos detallado de lo que deber√≠a ser en el c√≥digo anterior a C ++ 20 porque estas funciones deber√≠an ser en realidad amigos no miembros, m√°s sobre eso m√°s adelante.</i> <br><br>  Ese es un mont√≥n de c√≥digo repetitivo para escribir solo para asegurarme de que mi tipo sea comparable a algo del mismo tipo.  Bueno, est√° bien, lo tratamos por un tiempo.  Luego viene alguien que escribe esto: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(is_lt(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  Lo primero que notar√° es que este programa no se compilar√°. <br><br> <code>error C3615: constexpr function 'is_lt' cannot result in a constant expression</code> <br> <br>  Ah!  El problema es que olvidamos <code>constexpr</code> en nuestra funci√≥n de comparaci√≥n, ¬°drat!  Entonces uno va y agrega <code>constexpr</code> a todos los operadores de comparaci√≥n.  Unos d√≠as despu√©s, alguien va y agrega un ayudante <code>is_gt</code> pero se da cuenta de que todos los operadores de comparaci√≥n no tienen una especificaci√≥n de excepci√≥n y pasa por el mismo proceso tedioso de agregar <code>noexcept</code> a cada una de las 5 sobrecargas. <br><br>  Aqu√≠ es donde interviene el nuevo operador de la nave espacial C ++ 20 para ayudarnos.  Veamos c√≥mo se puede escribir el <code>IntWrapper</code> original en un mundo C ++ 20: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  La primera diferencia que puede notar es la nueva inclusi√≥n de <code>&lt;compare&gt;</code> .  El encabezado <code>&lt;compare&gt;</code> es responsable de llenar el compilador con todos los tipos de categor√≠a de comparaci√≥n necesarios para que el operador de la nave espacial devuelva un tipo apropiado para nuestra funci√≥n predeterminada.  En el fragmento anterior, el tipo de retorno <code>auto</code> se deducir√° a <code>std::strong_ordering</code> . <br><br>  No solo eliminamos 5 l√≠neas superfluas, sino que ni siquiera tenemos que definir nada, ¬°el compilador lo hace por nosotros!  Nuestro <code>is_lt</code> permanece sin cambios y simplemente funciona mientras sigue siendo <code>constexpr</code> , aunque no lo especificamos expl√≠citamente en nuestro <code>operator&lt;=&gt;</code> predeterminado <code>operator&lt;=&gt;</code> .  Eso est√° muy bien, pero algunas personas pueden estar rasc√°ndose la cabeza sobre por qu√© <code>is_lt</code> todav√≠a puede compilar aunque ni siquiera use el operador de la nave espacial.  Exploremos la respuesta a esta pregunta. <br><br><h2>  Reescribiendo expresiones </h2><br>  En C ++ 20, el compilador presenta un nuevo concepto referido a expresiones "reescritas".  El operador de la nave espacial, junto con el <code>operator==</code> , se encuentran entre los dos primeros candidatos sujetos a expresiones reescritas.  Para un ejemplo m√°s concreto de reescritura de expresiones, analicemos el ejemplo proporcionado en <code>is_lt</code> . <br><br>  Durante la resoluci√≥n de sobrecarga, el compilador seleccionar√° de un conjunto de candidatos viables, todos los cuales coinciden con el operador que estamos buscando.  El proceso de recopilaci√≥n de candidatos se modifica ligeramente para el caso de operaciones relacionales y de equivalencia en las que el compilador tambi√©n debe reunir candidatos especiales reescritos y sintetizados ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">[over.match.oper] /3.4</a> ). <br><br>  Para nuestra expresi√≥n <code>a &lt; b</code> el est√°ndar establece que podemos buscar el tipo de a para un <code>operator&lt;=&gt;</code> o un <code>operator&lt;=&gt;</code> funci√≥n de alcance de espacio de nombres <code>operator&lt;=&gt;</code> que acepta su tipo.  Entonces el compilador lo hace y descubre que, de hecho, el tipo de un s√≠ <code>IntWrapper::operator&lt;=&gt;</code> .  El compilador puede usar ese operador y reescribir la expresi√≥n <code>a &lt; b</code> as <code>(a &lt;=&gt; b) &lt; 0</code> .  Esa expresi√≥n reescrita se utiliza como candidato para la resoluci√≥n de sobrecarga normal. <br><br>  Puede que te preguntes por qu√© esta expresi√≥n reescrita es v√°lida y correcta.  La exactitud de la expresi√≥n en realidad proviene de la sem√°ntica que proporciona el operador de la nave espacial.  El <code>&lt;=&gt;</code> es una comparaci√≥n de tres v√≠as que implica que usted obtiene no solo un resultado binario, sino un ordenamiento (en la mayor√≠a de los casos) y si tiene un ordenamiento puede expresar ese ordenamiento en t√©rminos de cualquier operaci√≥n relacional.  Un ejemplo r√°pido, la expresi√≥n 4 &lt;=&gt; 5 en C ++ 20 le devolver√° el resultado <code>std::strong_ordering::less</code> .  El resultado <code>std::strong_ordering::less</code> implica que <code>4</code> no solo es diferente de <code>5</code> sino que es estrictamente menor que ese valor, esto hace que la aplicaci√≥n de la operaci√≥n <code>(4 &lt;=&gt; 5) &lt; 0</code> correcta y exacta para describir nuestro resultado. <br><br>  El uso de la informaci√≥n anterior del compilador puede tomar cualquier operador relacional generalizado (es decir, <code>&lt;</code> , <code>&gt;</code> , etc.) y reescribirlo en t√©rminos del operador de la nave espacial.  En el est√°ndar, la expresi√≥n reescrita a menudo se denomina <code>(a &lt;=&gt; b) @ 0</code> donde <code>@</code> representa cualquier operaci√≥n relacional. <br><br><h2>  Sintetizar expresiones </h2><br>  Los lectores pueden haber notado la menci√≥n sutil de las expresiones "sintetizadas" arriba y tambi√©n juegan un papel en este proceso de reescritura del operador.  Considere una funci√≥n de predicado diferente: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_gt_42</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> &lt; a; }</code> </pre> <br>  Si usamos nuestra definici√≥n original para <code>IntWrapper</code> este c√≥digo no se compilar√°. <br><br> <code>error C2677: binary '&lt;': no global operator found which takes type 'const IntWrapper' (or there is no acceptable conversion)</code> <br> <br>  Esto tiene sentido en la tierra anterior a C ++ 20, y la forma de resolver este problema ser√≠a agregar algunas funciones de <code>friend</code> adicionales a <code>IntWrapper</code> que toman un lado izquierdo de <code>int</code> .  Si intenta compilar esa muestra con un compilador C ++ 20 y nuestra definici√≥n C ++ 20 de <code>IntWrapper</code> , puede notar que, de nuevo, "simplemente funciona", otro rascador de cabeza.  Examinemos por qu√© el c√≥digo anterior a√∫n se puede compilar en C ++ 20. <br><br>  Durante la resoluci√≥n de sobrecarga, el compilador tambi√©n reunir√° lo que el est√°ndar se refiere como candidatos "sintetizados", o una expresi√≥n reescrita con el orden de los par√°metros invertidos.  En el ejemplo anterior, el compilador intentar√° usar la expresi√≥n reescrita <code>(42 &lt;=&gt; a) &lt; 0</code> pero encontrar√° que no hay conversi√≥n de <code>IntWrapper</code> a <code>int</code> para satisfacer el lado izquierdo de modo que la expresi√≥n reescrita se descarte.  El compilador tambi√©n evoca la expresi√≥n "sintetizada" <code>0 &lt; (a &lt;=&gt; 42)</code> y descubre que hay una conversi√≥n de <code>int</code> a <code>IntWrapper</code> trav√©s de su constructor de conversi√≥n, por lo que se utiliza este candidato. <br><br>  El objetivo de las expresiones sintetizadas es evitar el desorden de la necesidad de escribir el repetitivo de las funciones de <code>friend</code> para completar los espacios en los que su objeto podr√≠a convertirse de otros tipos.  Las expresiones sintetizadas se generalizan a <code>0 @ (b &lt;=&gt; a)</code> . <br><br><h2>  Tipos m√°s complejos </h2><br>  El operador de nave espacial generado por el compilador no se detiene en miembros individuales de clases, generar√° un conjunto correcto de comparaciones para todos los subobjetos dentro de sus tipos: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Basics</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f;  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d;  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Basics&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arrays</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai[<span class="hljs-number"><span class="hljs-number">1</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ac[<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> af[<span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ad[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arrays&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bases</span></span></span><span class="hljs-class"> :</span></span> Basics, Arrays {  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Bases&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases a = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases b = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a == b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a != b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &lt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &lt;= b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &gt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &gt;= b); }</code> </pre> <br>  El compilador sabe c√≥mo expandir miembros de clases que son matrices en sus listas de subobjetos y compararlos recursivamente.  Por supuesto, si desea escribir los cuerpos de estas funciones usted mismo, a√∫n tiene el beneficio de las expresiones de reescritura del compilador para usted. <br><br><h2>  Parece un pato, nada como un pato y grazna como <code>operator==</code> </h2><br>  Algunas personas muy inteligentes en el comit√© de estandarizaci√≥n notaron que el operador de la nave espacial siempre realizar√° una comparaci√≥n lexicogr√°fica de elementos sin importar qu√©.  La realizaci√≥n incondicional de comparaciones lexicogr√°ficas puede conducir a un c√≥digo generado ineficiente con el operador de igualdad en particular. <br><br>  El ejemplo can√≥nico es comparar dos cadenas.  Si tiene la cadena <code>"foobar"</code> y la compara con la cadena <code>"foo"</code> usando == uno esperar√≠a que la operaci√≥n sea casi constante.  El algoritmo eficiente de comparaci√≥n de cadenas es as√≠: <br><br><ul><li>  Primero compare el tama√±o de las dos cadenas, si los tama√±os difieren devuelven <code>false</code> , de lo contrario </li><li>  recorra cada elemento de las dos cadenas al un√≠sono y compare hasta que una difiera o se llegue al final, devuelva el resultado. </li></ul><br>  Seg√∫n las reglas del operador de la nave espacial, primero debemos comenzar con la comparaci√≥n profunda de cada elemento hasta encontrar el que es diferente.  En nuestro ejemplo de <code>"foobar"</code> y <code>"foo"</code> solo al comparar <code>'b'</code> con <code>'\0'</code> finalmente devuelve <code>false</code> . <br><br>  Para combatir esto, hab√≠a un documento, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P1185R2</a> que detalla una forma para que el compilador reescriba y genere el <code>operator==</code> independientemente del operador de la nave espacial.  Nuestro <code>IntWrapper</code> podr√≠a escribirse de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default;  bool operator==(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Solo un paso m√°s ... sin embargo, hay buenas noticias;  en realidad no necesita escribir el c√≥digo anterior, ya que simplemente escribir el <code>auto operator&lt;=&gt;(const IntWrapper&amp;) const = default</code> es suficiente para que el compilador genere impl√≠citamente el <code>operator==</code> por separado y m√°s eficiente para usted. <br><br>  El compilador aplica una regla de "reescritura" ligeramente modificada espec√≠fica para <code>==</code> y <code>!=</code> Donde en estos operadores se reescriben en t√©rminos de <code>operator==</code> y no <code>operator&lt;=&gt;</code> .  Esto significa que <code>!=</code> Tambi√©n se beneficia de la optimizaci√≥n, tambi√©n. <br><br><h2>  El viejo c√≥digo no se romper√° </h2><br>  En este punto, podr√≠a estar pensando, OK, si el compilador puede realizar este negocio de reescritura del operador, ¬øqu√© sucede cuando intento burlarme del compilador? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }</code> </pre> <br>  La respuesta aqu√≠ es que no lo hiciste.  El modelo de resoluci√≥n de sobrecarga en C ++ tiene esta arena donde todos los candidatos luchan, y en esta batalla espec√≠fica tenemos 3 candidatos: <br><br><ul><li> <code>IntWrapper::operator&lt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> <li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> </ul><br>  (reescrito) <br><br><ul><li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; b, const IntWrapper&amp; a)</code> </li> </ul><br>  (sintetizado) <br><br>  Si aceptamos las reglas de resoluci√≥n de sobrecarga en C ++ 17, el resultado de esa llamada habr√≠a sido ambiguo, pero las reglas de resoluci√≥n de sobrecarga de C ++ 20 se cambiaron para permitir que el compilador resuelva esta situaci√≥n a la sobrecarga m√°s l√≥gica. <br><br>  Hay una fase de resoluci√≥n de sobrecarga en la que el compilador debe realizar una serie de desempates.  En C ++ 20, hay un nuevo desempate que establece que debemos preferir las sobrecargas que no se reescriben o sintetizan, esto hace que nuestra sobrecarga <code>IntWrapper::operator&lt;</code> el mejor candidato y resuelva la ambig√ºedad.  Esta misma maquinaria evita que los candidatos sintetizados pisoteen expresiones regulares reescritas. <br><br><h2>  Pensamientos finales </h2><br>  El operador de nave espacial es una adici√≥n bienvenida a C ++ y es una de las caracter√≠sticas que simplificar√° y ayudar√° a escribir <i>menos</i> c√≥digo y, a veces, menos es m√°s.  ¬°As√≠ que abr√≥chate el cintur√≥n con el operador de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nave espacial</a> C ++ 20! <br><br>  Le instamos a salir y probar el operador de la nave espacial, ¬°est√° disponible ahora mismo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Visual Studio 2019</a> en <code>/std:c++latest</code> !  Como nota, los cambios introducidos a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">P1185R2</a> estar√°n disponibles en Visual Studio 2019 versi√≥n 16.2.  Tenga en cuenta que el operador de la nave espacial es parte de C ++ 20 y est√° sujeto a algunos cambios hasta el momento en que se finalice C ++ 20. <br><br>  Como siempre, agradecemos sus comentarios.  No dude en enviar cualquier comentario por correo electr√≥nico a <a href="">visualcpp@microsoft.com</a> , a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Twitter @visualc</a> o Facebook en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Microsoft Visual Cpp</a> .  Adem√°s, si√©ntase libre de seguirme en Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@starfreakclone</a> . <br><br>  Si encuentra otros problemas con MSVC en VS 2019, inf√≥rmenos a trav√©s de la opci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informar un problema</a> , ya sea desde el instalador o desde el IDE de Visual Studio.  Para sugerencias o informes de errores, h√°ganos saber a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DevComm.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458248/">https://habr.com/ru/post/458248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458228/index.html">¬øPor qu√© necesitamos funciones virtuales?</a></li>
<li><a href="../458230/index.html">C√≥mo la IA, los drones y las c√°maras mantienen nuestras carreteras y puentes seguros</a></li>
<li><a href="../458240/index.html">C√≥mo la inteligencia artificial, los drones y las c√°maras garantizan la seguridad de carreteras y puentes</a></li>
<li><a href="../458244/index.html">Una lista interminable y rid√≠cula de lo que necesita saber para usar de forma segura las redes Wi-Fi p√∫blicas</a></li>
<li><a href="../458246/index.html">Coincidencias aleatorias en la vida, o c√≥mo result√≥ que te presentaron un pastel en una f√°brica de tractores</a></li>
<li><a href="../458250/index.html">BTRFS para los m√°s peque√±os</a></li>
<li><a href="../458252/index.html">Modelo matem√°tico de un radiotelescopio superlargo</a></li>
<li><a href="../458256/index.html">¬øNo es hora de lavar el cerebro?</a></li>
<li><a href="../458260/index.html">Otra forma de optimizar las im√°genes de Docker para aplicaciones Java</a></li>
<li><a href="../458262/index.html">Dise√±ador en l√≠nea de la sala de reuniones: selecci√≥n de la soluci√≥n √≥ptima para la videoconferencia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>