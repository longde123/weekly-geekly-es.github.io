<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§šğŸ¿ ğŸ•µğŸ» ğŸ—ºï¸ Generalisasi penanda cepat pada peta WebGL âš—ï¸ ğŸ¦ ğŸ”­</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penanda adalah hal yang baik. Berguna dalam jumlah yang wajar. Ketika jumlah mereka terlalu banyak, manfaatnya akan hilang. Apa yang harus dilakukan j...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generalisasi penanda cepat pada peta WebGL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/2gis/blog/442720/"><p><img src="https://habrastorage.org/webt/wl/if/9y/wlif9yuvumhoa16egkvqphgdzyo.png" alt="gambar"></p><br><p>  Penanda adalah hal yang baik.  Berguna dalam jumlah yang wajar.  Ketika jumlah mereka terlalu banyak, manfaatnya akan hilang.  Apa yang harus dilakukan jika Anda ingin menandai hasil pencarian di peta, di mana puluhan ribu objek?  Dalam artikel ini saya akan memberi tahu Anda bagaimana kami memecahkan masalah ini pada kartu WebGL tanpa mengorbankan penampilan dan kinerjanya. </p><a name="habracut"></a><br><h1 id="predystoriya">  Latar belakang </h1><br><p>  Pada tahun 2016, 2GIS meluncurkan proyek WebGL pertamanya, Lantai: denah bangunan 3D. </p><br><p><img src="https://habrastorage.org/webt/dt/90/4v/dt904vhpl-gjcyju0tuf_n-nefc.png" alt="gambar"><br>  <em>Lantai pusat perbelanjaan Novosibirsk Aura</em> </p><br><p>  Segera setelah rilis Floors, tim kami mulai mengembangkan mesin kartografi tiga dimensi penuh di WebGL.  Mesin dikembangkan bersama dengan versi baru 2gis.ru dan sekarang dalam status <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beta publik</a> . </p><br><p><img src="https://habrastorage.org/webt/_9/nl/q9/_9nlq9yh87m2vbaznj3_tvji6q8.png" alt="gambar"><br>  <em>Kotak merah digambar di WebGL.</em>  <em>Rencana bangunan sekarang terintegrasi langsung ke dalam peta.</em> </p><br><h1 id="zadacha-generalizacii-podpisey">  Tugas generalisasi tanda tangan </h1><br><p>  Siapa pun yang ingin menulis mesin peta mereka sendiri cepat atau lambat akan menghadapi masalah menempatkan tanda tangan di peta.  Ada banyak objek di peta, dan tidak mungkin untuk menandatangani masing-masing sehingga tanda tangan tidak tumpang tindih. </p><br><p><img src="https://habrastorage.org/webt/si/0j/cf/si0jcfdcbaz8tqeazopjba1f1b8.png" alt="gambar"><br>  <em>Apa yang akan terjadi jika dalam Novosibirsk semua objek ditandatangani sekaligus</em> </p><br><p>  Untuk mengatasi masalah ini, diperlukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">generalisasi</a> tanda tangan.  Generalisasi dalam pengertian umum adalah transformasi data peta sehingga cocok untuk ditampilkan pada skala kecil.  Itu dapat dilakukan dengan metode yang berbeda.  Untuk tanda tangan, metode pemilihan biasanya digunakan: dari jumlah total, bagian dari tanda tangan paling prioritas yang tidak berpotongan dengan satu sama lain dipilih. </p><br><p>  Prioritas tanda tangan ditentukan oleh jenisnya, serta skala peta saat ini.  Misalnya, dalam skala kecil, tanda tangan kota dan negara diperlukan, dan dalam skala besar, tanda tangan jalan dan nomor rumah menjadi jauh lebih penting.  Seringkali prioritas nama pemukiman ditentukan oleh ukuran populasi.  Semakin besar, semakin penting tanda tangannya. </p><br><p>  Generalisasi diperlukan tidak hanya untuk tanda tangan, tetapi juga untuk penanda yang menandai hasil pencarian di peta.  Misalnya, ketika mencari "toko" di Moskow, ada lebih dari 15.000 hasil.  Menandai semuanya di peta sekaligus jelas merupakan ide yang buruk. </p><br><p><img src="https://habrastorage.org/webt/2a/in/jj/2ainjj57s8zfmdjv4103va5trqm.png" alt="gambar"><br>  <em>Semua toko Moskow di peta.</em>  <em>Tidak ada cara untuk melakukannya tanpa generalisasi</em> </p><br><p> Setiap interaksi pengguna dengan peta (memindahkan, memperbesar, memutar dan memiringkan) mengarah ke perubahan posisi penanda pada layar, sehingga Anda harus dapat menghitung ulang generalisasi dengan cepat.  Karena itu, harus cepat. </p><br><p>  Dalam artikel ini, menggunakan contoh generalisasi marker, saya akan menunjukkan berbagai cara untuk menyelesaikan masalah ini, yang digunakan pada waktu yang berbeda dalam proyek kami. </p><br><h1 id="obschiy-podhod-k-generalizacii">  Pendekatan umum untuk generalisasi </h1><br><ol><li>  Proyeksikan setiap penanda pada bidang layar dan hitung untuknya sebuah batas - area persegi panjang yang ditempati layar. </li><li>  Urutkan penanda berdasarkan prioritas. </li><li>  Secara berurutan periksa setiap marker dan letakkan di layar jika tidak berpotongan dengan marker lain yang diletakkan di depannya. </li></ol><br><p>  Dengan poin 1, semuanya jelas - itu hanya perhitungan.  Dengan item 2, kami juga beruntung: daftar marker yang datang kepada kami dari backend sudah diurutkan berdasarkan prioritas oleh algoritma pencarian.  Hasil paling relevan yang paling mungkin menarik bagi pengguna berada di bagian atas hasil. </p><br><p>  Masalah utama adalah pada paragraf 3: waktu penghitungan generalisasi dapat sangat bergantung pada bagaimana penerapannya. </p><br><p>  Untuk mencari persimpangan antara penanda, kita memerlukan beberapa struktur data yang: </p><br><ol><li>  Menyimpan batas penanda yang ditambahkan ke layar. </li><li> Memiliki metode <code>insert(marker)</code> untuk menambahkan penanda ke layar. </li><li>  Ini memiliki metode <code>collides(marker)</code> untuk memeriksa penanda untuk persimpangan dengan yang sudah ditambahkan ke layar. </li></ol><br><p>  Pertimbangkan beberapa implementasi dari struktur ini.  Semua contoh lebih lanjut akan ditulis dalam TypeScript, yang kami gunakan di sebagian besar proyek kami.  Dalam semua contoh, spidol akan diwakili oleh objek dari bentuk berikut: </p><br><pre> <code class="plaintext hljs">interface Marker { minX: number; maxX: number; minY: number; maxY: number; }</code> </pre> <br><p>  Semua pendekatan yang dipertimbangkan akan menjadi implementasi dari antarmuka berikut: </p><br><pre> <code class="plaintext hljs">interface CollisionDetector { insert(item: Marker): void; collides(item: Marker): boolean; }</code> </pre> <br><p>  Untuk membandingkan kinerja, waktu eksekusi kode berikut akan diukur: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> marker <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> markers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!impl.collides(marker)) { impl.insert(marker); } }</code> </pre> <br><p>  Array <code>markers</code> akan berisi 100.000 elemen 30x50 yang ditempatkan secara acak pada bidang berukuran 1920x1080. </p><br><p>  Kinerja akan diukur pada Macbook Air 2012. </p><br><p>  Contoh pengujian dan kode yang disediakan dalam artikel juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diposting di GitHub</a> . </p><br><h1 id="naivnaya-realizaciya">  Implementasi naif </h1><br><p>  Untuk memulai, pertimbangkan opsi paling sederhana, ketika marker diperiksa untuk persimpangan dengan yang lain dalam siklus sederhana. </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NaiveImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private markers: Marker[]; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers = []; } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers.push(marker); } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (marker <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.markers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( candidate.minX &lt;= marker.maxX &amp;&amp; candidate.minY &lt;= marker.maxY &amp;&amp; candidate.maxX &gt;= marker.minX &amp;&amp; candidate.maxY &gt;= marker.minY ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><p>  Waktu perhitungan generalisasi untuk 100.000 penanda: <strong>420 ms</strong> .  Terlalu banyak  Bahkan jika perhitungan generalisasi dilakukan pada pekerja web dan tidak memblokir utas utama, penundaan seperti itu akan terlihat oleh mata, terutama karena operasi ini harus dilakukan setelah setiap gerakan kartu.  Terlebih lagi, pada perangkat seluler dengan prosesor yang lemah, penundaannya bisa lebih besar. </p><br><h1 id="realizaciya-s-primeneniem-r-dereva">  Implementasi R-tree </h1><br><p>  Karena dalam implementasi yang naif setiap penanda diperiksa untuk persimpangan dengan semua yang sebelumnya, dalam kasus terburuk, kompleksitas algoritma ini kuadratik.  Anda dapat memperbaikinya dengan menerapkan struktur data R-tree.  Sebagai implementasi dari R-tree, ambil perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RBush</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> rbush <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rbush'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RTreeImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private tree: rbush.RBush&lt;Marker&gt;; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree = rbush(); } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree.insert(marker); } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tree.collides(candidate); } }</code> </pre> <br><p>  Waktu perhitungan generalisasi untuk 100.000 penanda: <strong>173 ms</strong> .  Secara signifikan lebih baik.  Kami menggunakan pendekatan ini di Lantai (ini disebutkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel saya sebelumnya</a> ). </p><br><p><img src="https://habrastorage.org/webt/44/mp/v5/44mpv5pc8gwyqr4jfr5mqcibwqu.png" alt="gambar"><br>  <em>Visualisasi penyimpanan poin di R-tree.</em>  <em>Pembagian hierarkis pesawat menjadi persegi panjang memungkinkan Anda untuk dengan cepat mempersempit area pencarian dan tidak memilah-milah semua objek</em> </p><br><h1 id="realizaciya-s-primeneniem-bufera-kolliziy">  Implementasi collision buffer </h1><br><p>  Menggambar peta adalah tugas yang jauh lebih rumit daripada menggambar rencana satu bangunan.  Ini juga memanifestasikan dirinya dalam generalisasi.  Bahkan di pusat perbelanjaan terbesar di dunia, 1.000 organisasi jarang berada di lantai yang sama.  Pada saat yang sama, permintaan pencarian sederhana di kota besar dapat menghasilkan puluhan ribu hasil. </p><br><p>  Ketika kami mulai mengembangkan peta WebGL, kami mulai berpikir: apakah masih mungkin untuk mempercepat generalisasi.  Sebuah ide menarik ditawarkan kepada kami oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">stellarator</a> yang bekerja untuk kami: alih-alih R-tree, gunakan buffer untuk menyimpan status setiap piksel layar (sibuk atau tidak sibuk).  Saat memasukkan penanda di layar, "isi" tempat yang sesuai di buffer, dan saat memeriksa kemungkinan menempel, periksa nilai piksel di area yang diperlukan. </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionBufferByteImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private buffer: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>; private height: number; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(width: number, height: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(width * height); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = minX; i &lt; maxX; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { buffer[i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height + j] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } collides(candidate: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = candidate; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = minX; i &lt; maxX; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height + j]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><p>  Waktu perhitungan generalisasi untuk 100.000 penanda: <strong>46 ms</strong> . </p><br><p>  Kenapa begitu cepat?  Pendekatan ini tampaknya naif pada pandangan pertama, dan loop bersarang di kedua metode tidak seperti kode cepat.  Namun, jika Anda melihat lebih dekat pada kode, Anda akan melihat bahwa waktu eksekusi kedua metode tidak tergantung pada jumlah total penanda.  Jadi, untuk ukuran tetap marker WxH, kami memperoleh kompleksitas O (W * H * n), yaitu linear! </p><br><h1 id="optimizaciya-podhoda-s-buferom-kolliziy">  Pendekatan Penyangga Tabrakan Dioptimalkan </h1><br><p>  Anda dapat meningkatkan pendekatan sebelumnya dalam kecepatan dan memori yang digunakan, jika Anda memastikan bahwa satu piksel direpresentasikan dalam memori bukan oleh satu byte, tetapi dengan satu bit.  Kode setelah optimasi ini, bagaimanapun, terasa rumit dan ditumbuhi sedikit keajaiban bit: </p><br><div class="spoiler">  <b class="spoiler_title">Kode sumber</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionBufferBitImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CollisionDetector</span></span></span><span class="hljs-class"> </span></span>{ private width: number; private height: number; private buffer: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(width: number, height: number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.ceil(width / <span class="hljs-number"><span class="hljs-number">8</span></span>) * <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height / <span class="hljs-number"><span class="hljs-number">8</span></span>); } insert(marker: Marker): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { width, buffer } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = j * width + minX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = j * width + maxX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start === end) { buffer[start] = buffer[start] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { buffer[start] = buffer[start] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { buffer[i] = <span class="hljs-number"><span class="hljs-number">255</span></span>; } buffer[end] = buffer[end] | (<span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } } } collides(marker: Marker): boolean { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { minX, minY, maxX, maxY } = marker; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { width, buffer } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = minY; j &lt; maxY; j++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = j * width + minX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = j * width + maxX &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start === end) { sum = buffer[start] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sum = buffer[start] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &gt;&gt; (minX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { sum = buffer[i] | sum; } sum = buffer[end] &amp; (<span class="hljs-number"><span class="hljs-number">255</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">8</span></span> - (maxX &amp; <span class="hljs-number"><span class="hljs-number">7</span></span>))) | sum; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum !== <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> </div></div><br><p>  Waktu perhitungan generalisasi untuk 100.000 penanda: <strong>16 ms</strong> .  Seperti yang Anda lihat, kompleksitas logika membenarkan dirinya sendiri dan memungkinkan kami untuk mempercepat perhitungan generalisasi hampir tiga kali lipat. </p><br><h1 id="ogranicheniya-bufera-kolliziy">  Keterbatasan Buffer Tabrakan </h1><br><p>  Penting untuk dipahami bahwa buffer tabrakan bukanlah pengganti yang lengkap untuk R-tree.  Ini memiliki fitur jauh lebih sedikit dan lebih banyak batasan: </p><br><ol><li>  Anda tidak dapat memahami apa yang persis bersinggungan dengan marker.  Buffer hanya menyimpan data tentang piksel mana yang sibuk dan mana yang tidak.  Oleh karena itu, tidak mungkin untuk mengimplementasikan operasi yang mengembalikan daftar marker yang bersinggungan dengan yang diberikan. </li><li>  Tidak dapat menghapus penanda yang ditambahkan sebelumnya.  Buffer tidak menyimpan data tentang berapa banyak marker dalam piksel yang diberikan.  Oleh karena itu, tidak mungkin untuk menerapkan operasi menghapus penanda dari buffer dengan benar. </li><li>  Sensitivitas tinggi terhadap ukuran elemen.  Jika Anda mencoba menambahkan penanda yang menempati seluruh layar ke buffer tabrakan, kinerja akan turun secara dramatis. </li><li>  Bekerja di area terbatas.  Ukuran buffer diatur saat dibuat, dan tidak mungkin untuk menempatkan penanda di dalamnya yang melampaui ukuran ini.  Oleh karena itu, ketika menggunakan pendekatan ini, perlu untuk memfilter penanda secara manual yang tidak muncul di layar. </li></ol><br><p>  Semua pembatasan ini tidak mengganggu solusi dari masalah generalisasi marker.  Sekarang metode ini berhasil digunakan untuk spidol dalam versi beta 2gis.ru. </p><br><p>  Namun, untuk menggeneralisasi tanda tangan utama pada peta, persyaratannya lebih kompleks.  Sebagai contoh, bagi mereka perlu untuk memastikan bahwa ikon POI tidak dapat "membunuh" tanda tangannya sendiri.  Karena buffer tabrakan tidak membedakan apa yang sebenarnya terjadi dengan persimpangan, itu tidak memungkinkan untuk mengimplementasikan logika tersebut.  Karena itu, mereka harus meninggalkan solusi dengan RBush. </p><br><h1 id="vyvod">  Kesimpulan </h1><br><p><img src="https://habrastorage.org/webt/cl/ey/uq/cleyuqjc1utr1xm4elsi2g_uxxs.png" alt="gambar"><br>  Artikel ini menunjukkan jalur yang kami gunakan dari solusi paling sederhana ke solusi yang digunakan sekarang. </p><br><p>  Penggunaan R-tree adalah langkah penting pertama yang memungkinkan kami untuk mempercepat implementasi naif berkali-kali.  Ini berfungsi dengan baik di Lantai, tetapi pada kenyataannya kami hanya menggunakan sebagian kecil dari kemampuan struktur data ini. </p><br><p>  Setelah meninggalkan R-tree dan menggantinya dengan array dua dimensi yang sederhana, yang melakukan persis apa yang kita butuhkan, dan tidak ada yang lain, kita mendapatkan peningkatan produktivitas yang lebih besar. </p><br><p>  Contoh ini menunjukkan kepada kita betapa pentingnya, memilih solusi untuk masalah dari beberapa pilihan, untuk memahami dan menyadari keterbatasan masing-masing.  Keterbatasan itu penting dan bermanfaat, dan Anda tidak perlu takut pada mereka: dengan terampil membatasi diri Anda pada sesuatu yang tidak penting, Anda bisa mendapatkan manfaat besar sebagai imbalan di mana itu benar-benar dibutuhkan.  Misalnya, untuk menyederhanakan solusi masalah, atau untuk melindungi diri Anda dari seluruh kelas masalah, atau, seperti dalam kasus kami, untuk meningkatkan produktivitas beberapa kali. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442720/">https://habr.com/ru/post/id442720/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442708/index.html">Apa yang menentukan Penghasilan Penambang?</a></li>
<li><a href="../id442710/index.html">Tinjau Google IoT Platform</a></li>
<li><a href="../id442714/index.html">Suka cacat</a></li>
<li><a href="../id442716/index.html">Alas kaki</a></li>
<li><a href="../id442718/index.html">Karyawan Google menemukan bahwa pekerjaan pada versi mesin pencari untuk China berlanjut</a></li>
<li><a href="../id442722/index.html">Berhenti mengunduh dan menyimpan angka nol</a></li>
<li><a href="../id442724/index.html">Film "Office Space" berusia 20 tahun: bagaimana ia mengubah pekerjaan kami</a></li>
<li><a href="../id442726/index.html">Robot cheetah MIT dapat melakukan back flips dan berlari cepat</a></li>
<li><a href="../id442730/index.html">Microsoft: Rusia lebih maju dari AS dan Eropa dalam penerapan kecerdasan buatan</a></li>
<li><a href="../id442732/index.html">My Little Relay: Triple Brainfuck, atau What Is Madness</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>