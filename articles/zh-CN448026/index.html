<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💽 👩🏾‍⚕️ 🏸 软件项目和OOP演进 🚟 ◼️ 🔵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我掌握了有效开发软件项目的秘诀，试图为自己找到使使用SOLID体系结构的开发原理有用的原因（文章如何不了解SOLID体系结构的开发原理 ）。 


 对这些原理的分析使得可以挑选出开发中存在的几个关键模式和基本要素。 他们使我们能够在软件项目的实际工作中描述，理解和实施SOLID。 


 对这些概...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>软件项目和OOP演进</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448026/"><p> 我掌握了有效开发软件项目的秘诀，试图为自己找到使使用SOLID体系结构的开发原理有用的原因（文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何不了解SOLID体系结构的开发原理</a> ）。 </p><br><p> 对这些原理的分析使得可以挑选出开发中存在的几个关键模式和基本要素。 他们使我们能够在软件项目的实际工作中描述，理解和实施SOLID。 </p><br><p> 对这些概念对普遍接受的编程范例（例如，面向对象编程）的适用性进行分析变得很有趣。 好吧，如果这项工作的结果对您有用。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/291/b01/aa4/291b01aa4949513c726bbf5cb33fad80.jpg" alt="图片"></p><a name="habracut"></a><br><p> 如今，有许多用于设计和随后实施软件项目的方法。 处理大型软件项目时最需要的是： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结构编程</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">功能编程</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">面向对象的编程</a> 。 </p><br><p> 对我来说，分析这些设计方法的原因变得很有趣。 在分析过程中，意外发现是它们全部隐式基于以下前提： </p><br><pre><code class="plaintext hljs">          ,      .</code> </pre> <br><h2 id="razvitie-programmnogo-proekta"> 软件项目开发 </h2><br><p> 什么是不需要开发的项目？ 这类项目很少见，主要特点是快速计件付款，程序员无需承担任何后续义务，例如： </p><br><ul><li> 可以用一种方法编写的小项目； </li><li> 一个没有结构复杂代码，负担大量关系的项目； </li><li> 软件产品，无需其支持和用户支持。 </li></ul><br><p> 在这种情况下，程序员在维护例如面向对象方法方面的工作被浪费了。 经常发生的情况是，在开发一次性控制台实用程序的过程中，我陷入了毫无意义的课，当时我突然意识到，在该项目中编写四年级的文字会耽误我15分钟的时间，并没有使我更接近结果。 最可悲的是，几乎没有在此类项目中编写的所有类都被遗忘并且不被重用，也就是说，它们不会为将来的工作提供便利。 </p><br><p> 在所有其他情况下，程序员必须尽量减少其工作，必须开发一个结构上复杂的项目，即： </p><br><ul><li> 通过分析代码并查找产生这些错误的位置来纠正错误。 </li><li> 在保持所有以前可用功能的功能的同时引入新功能。 这样做时，请在执行这些新任务时使用现有代码（编写并经过测试）。 </li><li> 在使用软件产品时提供支持。 </li><li> 对项目所有版本的功能进行描述和协调。 </li><li> 保持项目使用的所有数据格式（即使是过时的）都可操作。 </li><li> 并执行因框架变更或对过时的OS的支持终止而导致与竞争对手对抗的许多其他任务... </li></ul><br><p> 如果您寻求与软件项目开发的类比，则可以回忆起生物物种的进化。 </p><br><pre> <code class="plaintext hljs">     "".     -       .       -  .</code> </pre> <br><p> 程序员的工作并不容易，但是程序员有一个“助手”。 该帮助器隐藏在我们世界结构的深处，其中具有两个功能： </p><br><ul><li> 能够编写一种有用的算法并将其用于许多类似任务的能力， </li><li> 解决方案中存在许多相似的任务。 </li></ul><br><p> 为了简便起见，该算法在许多领域都有用，将被称为<em>通用</em>算法。 它针对特定应用领域的实现可以称为专业化，因为改进算法以在狭窄应用领域中使用的过程类似于生物体内细胞的进化专业化。 </p><br><p> 显然，要创建算法，必须确定确保算法适用性的特征。 必须在输入数据和初始情况（上下文）的描述中寻找这些符号。 为了创建<em>通用</em>算法，有必要在每个主题领域（具有自己的数据符号和情况符号集）中识别适用于所有领域的符号。  <em>通用</em>算法会忽略所有其他不提供适用性的符号。 对<em>通用</em>算法进行形式化，我们已经得出使用<em>抽象</em>的必要性- <em>抽象</em>是OOP的最重要原理之一。 而且，OOP的特征在于仅强调数据抽象。 </p><br><p> 在这里，我将尝试写出在不同领域使用<em>抽象的</em>示例。 </p><br><table><thead><tr><th> 抽象化 </th><th> 演算法 </th><th> 应用领域 </th></tr></thead><tbody><tr><td> 自然数 </td><td> 定量计算算法 </td><td> 经济价值核算任务 </td></tr><tr><td> 材料体的质量特性 </td><td> 比较物质含量的算法 </td><td> 比较非问责产品价值的任务 </td></tr><tr><td> 与操作接口以收集元素：完全爬网，比较和位置交换 </td><td> 集合排序算法 </td><td> 程式设计 </td></tr><tr><td> 树中“结束节点”和“分支节点”具有相同操作的接口 </td><td> 基于布局设计模式的算法 </td><td> 开发复杂的软件项目 </td></tr><tr><td> 关键概念“员工” </td><td>  “雇用合同”一节中的措词 </td><td> 劳动法 </td></tr></tbody></table><br><h2 id="stroitelnyy-blok-programmnogo-proekta"> 软件项目的构建块 </h2><br><p> 程序员使用各种抽象技术，以一段代码的形式实现该算法，这是他工作的一个独立而完整的元素。 根据所使用的编程语言，该元素可以是函数，对象和指令序列。 为了便于进一步讨论，我们将此代码段称为“ <strong>component</strong> ”一词。 </p><br><p>  <strong>组件</strong> -一段代码（过程，类，部署组件等）： </p><br><ul><li> 它实现了一些完整的算法，该算法可以在某些初始情况下和某些输入数据下工作， </li><li> 可以在一个项目中多次使用（甚至在不同项目中可以多次使用）， </li><li> 所有指令的位置都非常靠近并且可以查看，而无需在开发环境中进行其他搜索操作， </li><li> 相对于其余代码，程序员可以相对独立地执行的更改。 </li></ul><br><h2 id="zakonomernosti-v-razvitii-programmnogo-proekta"> 软件项目开发中的模式 </h2><br><p> 使用术语“ <strong>组件”</strong> ，可以制定出一套在软件项目开发中存在的简单定律。 我将以以下语句的形式介绍这些模式，分为3类。 </p><br><ol><li> 描述<strong>组件</strong>属性的语句。 <br>  1.1。 必须使用正确编写的<strong>组件，</strong>并且经常使用几次。 <br>  1.2。 在使用该<strong>组件的</strong>每个地方，都期望它具有恒定的行为，从而导致可重复的结果。 <br>  1.3。 在多个地方使用<strong>组件</strong>时，结果应满足每个地方的使用要求。 <br>  1.4。 嵌入在<strong>组件中</strong>的行为会限制该<strong>组件</strong>的使用位置。 <br>  1.5。 在<strong>组件的</strong>每个使用位置，都可能涉及其所有限制。 <br>  1.6。 对<strong>组件的</strong>任何更改都会改变其局限性，并且需要验证其使用的所有位置，这导致程序员浪费时间。 <br>  1.7。 建议在一种情况下以代码形式编写<strong>组件</strong> ，即有必要消除相同代码的重复。 更改<strong>组件</strong>时，这将减少编辑次数。 </li><li> 描述程序员在执行新任务时的模式的语句。 <br>  2.1。建议选择一个用于执行新任务的选项，同时尽量减少程序员花费的时间。 <br>  2.2。 为了执行新任务，程序员可以添加新<strong>组件</strong>或更改旧<strong>组件</strong>的行为。 <br>  2.3。 基本上，添加<strong>组件</strong>仅需要在新使用的地方进行检查，并为程序员节省了最少的时间。 <br>  2.4。 根据陈述[1.6]，由新任务引起的<strong>组件</strong>行为的变化需要在新使用场所和所有旧使用场所进行验证，与陈述[2.3]的情况相比，这会增加程序员的时间成本。 对于已发布的<strong>组件，</strong>这要求所有程序员使用修改后的<strong>组件进行工作</strong> 。 </li><li> 描述<em>通用</em>算法及其专业领域交互中的模式的语句： <br>  3.1。 有机会编写一个<em>基本</em> <strong>组件</strong> （名称是与基类类似地引入的，为了简洁起见，我们将使用“ <em>base</em> ”一词）。  <em>该库</em>仅满足某些<em>通用</em>算法的最重要特征。 <br>  3.2。 可以编写一个<strong>组件-</strong>专业化（为简便起见，在下文中，我们将使用“ <em>专业化</em> ”一词）。  <em>专业化</em>是对<em>基础</em> <em>通用</em>算法的补充，使其适用于特定的使用领域。 <br>  3.3。 语句[3.1]，[3.2]中的基础比<em>专门化</em>具有更少的复杂性和更少的应用程序限制。 <br>  3.4。 根据陈述[1.7]，建议在不重复<em>数据库</em> <em>通用</em>算法代码的情况下发展<em>专业化</em> 。 <br>  3.5。 在更改了正确形成的<em>专业化条件</em>后，无需验证<em>数据库</em>的使用场所。 </li></ol><br><h2 id="ponyatiya-obektno-orientirovannogo-programmirovaniya"> 面向对象的编程概念 </h2><br><p> 我将尝试使用以上语句来分析面向对象编程的基本概念。 这种分析绕过了<em>抽象</em>的概念，因为前面已经在构造<em>通用</em>算法的方法的形式化中对其进行了描述。 </p><br><h3 id="klass-obekt"> 类，对象 </h3><br><p> 这些OOP概念增强了使用一种特殊类型的<strong>组件</strong>的可行性，该<strong>组件</strong>由一些内部数据和使用这些数据的方法的组合来描述。 组[1]和[2]的所有语句都被转换为OOP，为此，术语<strong>组件</strong>替换为<em>class</em>的概念。 </p><br><p> 同时，乍看之下， <em>类</em>和<em>对象</em>之间的关系被一组语句[3]穷尽，其中用<em>基</em> <em>类</em>的概念代替了<em>基</em> ，而<em>用对象</em>的概念代替了<em>实现</em> 。 此外， <em>实现</em>是动态的，即在程序执行期间可以更改。 </p><br><h3 id="inkapsulyaciya"> 封装形式 </h3><br><p>  “ <em>封装</em> ”的概念可以从两个“侧面”考虑。 </p><br><p>  “ <em>封装</em> ”概念的第一面是将<strong>组件</strong>与代码的其他部分隔离。 此属性使程序员可以在“接近”位置的代码区域中进行操作以对<strong>组件</strong>进行更改。 也就是说，通过从工作中排除搜索和分析程序的不同交互元素来最大程度地减少程序员所花费的时间。 此面由<strong>组件</strong>的属性（根据其定义）定义。 </p><br><p>  “ <em>封装</em> ”概念的第二面是隐藏了<strong>组件</strong>的内部实现。 使用语句组[3]中描述的<em>基础</em>和<em>实现</em>的概念，这种隐藏是可能的。 为此，将<em>基</em> <em>类</em>标识公共<em>类</em>方法，并用<em>实现</em>标识私有和受保护的类方法。 在使用场所，使用了由<em>基础</em>构成的限制，因此可以在<em>实现</em>中进行与<em>基本</em>限制无关的更改。 这些<em>实现的</em>更改无需在使用<em>数据库</em>的地方进行检查[3.5]，从而最大程度地减少了程序员的工作量。 </p><br><p> 值得注意的是，“ <em>包封</em> ”的概念在生物学上有一个类比。 第一个过程类似于“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">细胞膜</a> ”的生物学功能。 </p><br><h3 id="nasledovanie"> 传承 </h3><br><p>  “ <em>继承</em> ”的概念继续增强了使用<em>base</em> + <em>实现</em>组合的重要性。 为此，在语句组[3]中，有必要用<em>基</em>标识父类的方法，并用<em>实现</em>标识后继类的方法。 </p><br><p> 在其实现中，“ <em>继承</em> ”的概念允许使用语句[2.3]，即使用代码的添加而不是对其进行更改和复制。 在这种情况下，有必要排除<em>基本</em>算法的重复。 但是，使用<em>继承</em>来专门化<em>通用</em>算法的方法要差很多。 缺点是存在两个牢固连接的<strong>组件</strong> ，这两个<strong>组件</strong>很难独立更改。 这些依赖关系是由父子关系生成的。 </p><br><p> 有多种使用<em>base</em> + <em>实现</em>捆绑包的方法。 我将进一步举例说明这种方法。 </p><br><table><thead><tr><th>  <em>基数</em> </th><th>  <em>实作</em> </th><th> 应用领域 </th></tr></thead><tbody><tr><td> 公共类方法 </td><td> 私人课方法 </td><td>  <em>封装形式</em> </td></tr><tr><td> 父类的受保护方法 </td><td> 继承类方法 </td><td>  <em>传承</em> </td></tr><tr><td> 动态库界面 </td><td> 动态库功能 </td><td>  <strong>组件</strong> =动态库 </td></tr><tr><td> 模板（通用）方法和类（模板，通用） </td><td> 使用指定的参数实例化模板 </td><td> 通用编程 </td></tr><tr><td> 接受委托的泛型方法 </td><td> 指示特定处理程序的方法的专业化 </td><td> 排序或形成树的过程，指示评估元素顺序的方法 </td></tr><tr><td> 允许与Visitor模板进行交互的类 </td><td> 形成具有所需功能的“访客” </td><td> 访客设计模式 </td></tr><tr><td>  NPP控制面板 </td><td> 核电站的自动化设备一套 </td><td>  NPP运营商隐瞒系统复杂性 </td></tr></tbody></table><br><p> 同时，我注意到，对于来自巴解组织的“ <em>继承</em> ”概念，人们也可以在生物进化过程中找到一个类比。 在生物学中，术语“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>遗传</em></a> ”用于此目的。 </p><br><h3 id="polimorfizm"> 多态性 </h3><br><p> 我认为，“ <em>多态性</em> ”的概念是查看<em>通用</em>算法创建过程的第二方面。 第一面（ <em>抽象</em> ）是从如何创建<em>通用</em>算法的角度出发的观点。 同时，从用户的角度看<em>通用</em>算法时，我们记录了<em>多态性</em>的概念。 即， <em>多态性</em>是函数（ <strong>组件</strong> ）处理各种类型的数据的有用能力。 将这一概念添加到OOP中可以增强在软件项目开发中使用<em>通用</em>算法的有用性。 </p><br><p> 不同编程语言中的多态实现非常不同。 在Wikipedia上有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">多态的</a>文章中，根据其实现方式，有4个子类型：参数，包含（或子类型），重载，类型转换。 这些实现具有显着差异，但是所有实现都由一个目标结合在一起-这是编写一种<em>通用</em>算法，对于其特定的<em>专业化</em>无需重复。 </p><br><p> 这次，几乎没有惊奇，他发现了生物学中“ <em>多态性</em> ”概念的类比。 这个生物学术语的名称与OOP的概念完全吻合。  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>多态性</em></a> ”-一种生物以不同内部结构或不同外部形式存在的能力。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 因此，OOP的几乎所有基本概念都可以表示为基于软件项目开发定律形成的一组简单陈述。 此外，对于OOP，术语<strong>组件是</strong>用<em>class</em>的概念<strong>来</strong>标识的。 如果我们为术语`` <strong>组件''</strong> （例如<em>函数）选择</em>了不同的含义，则可以表述<em>函数式</em> <em>编程</em>的基本概念。 </p><br><p> 在撰写本文的过程中，发现了用于编程的概念的生物学类比。 这些类比的出现是由于软件产品的开发方法和某些生物进化过程的相似性。 </p><br><p> 恕我直言，建议同时考虑这两个科学领域。 在这种情况下，有可能进行法律从一个行业到另一行业的转移，从而确保信息技术的发展和生物学过程的形式描述。 </p><br><p> 谢谢您的关注。 </p><br><h2 id="otzyvy"> 评论 </h2><br><p> 我将非常感谢您的反馈，建议和意见，因为它们有助于我调整该领域工作的发展方向。 </p><br><h2 id="ssylki"> 参考文献 </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wiki算法的一般理论</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该系列的第一篇文章</a> </li></ul><br><p> 由Borisova M.V.编辑 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN448026/">https://habr.com/ru/post/zh-CN448026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN448010/index.html">使用Galaxy S10的3周：优缺点</a></li>
<li><a href="../zh-CN448016/index.html">在试纸上在家中进行尿液的临床分析：利弊</a></li>
<li><a href="../zh-CN448018/index.html">4月15日至4月21日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN448022/index.html">200行Angular编译器</a></li>
<li><a href="../zh-CN448024/index.html">欧洲监管机构反对饼干横幅</a></li>
<li><a href="../zh-CN448030/index.html">在网络上显示和优化终端输出</a></li>
<li><a href="../zh-CN448032/index.html">更多机器人：沃尔玛在其商店中引入了数千台机器进行操作</a></li>
<li><a href="../zh-CN448034/index.html">搜索JIRA（简单语言）中的任务。 第1部分：快速和基本搜索</a></li>
<li><a href="../zh-CN448036/index.html">导入到J。通过API从用户列表文件连接</a></li>
<li><a href="../zh-CN448038/index.html">Visual Studio 2019 v.16.1中扩展作者的新功能</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>