<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôã üë©üèΩ‚Äçüöí ü§¶ Creaci√≥n de la defensa de la torre en la unidad: escenarios y olas de enemigos üçé üë®‚Äçüëß‚Äçüë¶ üå≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ La primera , segunda , tercera y cuarta partes del tutorial] 



- Soporte para enemigos de tama√±os peque√±o, mediano y grande. 
- Crea escenarios de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Creaci√≥n de la defensa de la torre en la unidad: escenarios y olas de enemigos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466855/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La primera</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">segunda</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tercera</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuarta</a> partes del tutorial] <br><br><ul><li>  Soporte para enemigos de tama√±os peque√±o, mediano y grande. </li><li>  Crea escenarios de juego con m√∫ltiples oleadas de enemigos. </li><li>  Separaci√≥n de la configuraci√≥n de activos y el estado del juego. </li><li>  Inicia, pausa, gana, derrota y acelera el juego. </li><li>  Crea escenarios que se repiten sin cesar. </li></ul><br>  Esta es la quinta parte de una serie de tutoriales sobre c√≥mo crear un juego de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">defensa de torre</a> simple.  En √©l, aprenderemos c√≥mo crear escenarios de juego que generen oleadas de varios enemigos. <br><br>  El tutorial fue creado en Unity 2018.4.6f1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/6aa/945/b126aa94582cc44651853c3ee69be82b.jpg" width="512" height="256"></div><br>  <i>Se est√° volviendo bastante c√≥modo.</i> <br><a name="habracut"></a><br><h2>  M√°s enemigos </h2><br>  No es muy interesante crear el mismo cubo azul cada vez.  El primer paso para soportar escenarios de juego m√°s interesantes ser√° soportar varios tipos de enemigos. <br><br><h3>  Configuraciones enemigas </h3><br>  Hay muchas maneras de hacer que los enemigos sean √∫nicos, pero no los complicaremos: los clasificamos como peque√±os, medianos y grandes.  Para etiquetarlos, cree una enumeraci√≥n <code>EnemyType</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EnemyType { Small, Medium, Large }</code> </pre> <br>  Cambia <code>EnemyFactory</code> para que admita los tres tipos de enemigos en lugar de uno.  Para los tres enemigos, se necesitan los mismos campos de configuraci√≥n, por lo que agregamos la clase anidada <code>EnemyConfig</code> los contiene a todos, y luego agregamos tres campos de configuraci√≥n de este tipo a la f√°brica.  Como esta clase se usa solo para la configuraci√≥n y no la usaremos en ning√∫n otro lugar, simplemente puede hacer p√∫blicos sus campos para que la f√°brica pueda acceder a ellos.  <code>EnemyConfig</code> s√≠ no <code>EnemyConfig</code> obligado a ser p√∫blico. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyFactory</span></span> : <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> { [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyConfig</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Enemy prefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">2f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange scale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">5f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange speed = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); [FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">-0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange pathOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">0f</span></span>); } [SerializeField] EnemyConfig small = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, medium = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, large = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ‚Ä¶ }</code> </pre> <br>  Tambi√©n hagamos que la salud sea personalizable para cada enemigo, porque es l√≥gico que los enemigos grandes tengan m√°s que los peque√±os. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">FloatRangeSlider(10f, 1000f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> FloatRange health = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">100f</span></span>);</code> </pre> <br>  Agregue un par√°metro de tipo a <code>Get</code> para que pueda obtener un tipo de enemigo espec√≠fico, y el tipo predeterminado ser√° medio.  Usaremos el tipo para obtener la configuraci√≥n correcta, para la cual es √∫til un m√©todo separado, y luego crearemos e inicializaremos al enemigo como antes, solo con el argumento de salud agregado. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">EnemyConfig </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetConfig</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Small: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> small; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Medium: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> medium; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EnemyType.Large: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> large; } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported enemy type!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyType type = EnemyType.Medium</span></span></span><span class="hljs-function">)</span></span> { EnemyConfig config = GetConfig(type); Enemy instance = CreateGameObjectInstance(config.prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize( config.scale.RandomValueInRange, config.speed.RandomValueInRange, config.pathOffset.RandomValueInRange, config.health.RandomValueInRange ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br>  Agregue el par√°metro de salud requerido a <code>Enemy.Initialize</code> y <code>Enemy.Initialize</code> para establecer la salud en lugar de determinarlo por el tama√±o del enemigo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> health </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Health = health; }</code> </pre> <br><h3>  Creamos el dise√±o de diferentes enemigos. </h3><br>  Puedes elegir cu√°l ser√° el dise√±o de los tres enemigos, pero en el tutorial me esforzar√© por lograr la m√°xima simplicidad.  Dupliqu√© el prefabricado original del enemigo y lo us√© para los tres tama√±os, cambiando solo el material: amarillo por peque√±o, azul por mediano y rojo por grande.  No cambi√© la escala del cubo prefabricado, pero utilic√© la configuraci√≥n de escala de f√°brica para establecer las dimensiones.  Adem√°s, dependiendo del tama√±o, aument√© su salud y reduje la velocidad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/070/231/bd707023151022e921c5b6956bb20c02.png" width="320" height="348"></div><br>  <i>F√°brica de cubos enemigos de tres tama√±os.</i> <br><br>  La forma m√°s r√°pida es hacer que los tres tipos aparezcan en el juego cambiando <code>Game.SpawnEnemy</code> para que obtenga un tipo aleatorio de enemigo en lugar del medio. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile spawnPoint = board.GetSpawnPoint(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, board.SpawnPointCount)); Enemy enemy = enemyFactory.Get((EnemyType)(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>))); enemy.SpawnOn(spawnPoint); enemies.Add(enemy); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/537/73b/b92/53773bb9299a8ec9c56b485718049e5b.png" width="230" height="230"></div><br>  <i>Enemigos de diferentes tipos.</i> <br><br><h3>  Varias f√°bricas </h3><br>  Ahora la f√°brica de enemigos establece muchos tres enemigos.  La f√°brica existente crea cubos de tres tama√±os, pero nada nos impide hacer otra f√°brica que cree algo m√°s, por ejemplo, esferas de tres tama√±os.  Podemos cambiar los enemigos creados al nombrar otra f√°brica en el juego, cambiando as√≠ a un tema diferente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65f/7e5/330/65f7e5330945ea654f1caef579fe567f.png" width="230" height="230"></div><br>  <i>Enemigos esf√©ricos.</i> <br><br><h2>  Olas de enemigos </h2><br>  El segundo paso para crear escenarios de juego ser√° el rechazo de los enemigos engendrados con una frecuencia constante.  Los enemigos deben crearse en oleadas sucesivas hasta que finalice el gui√≥n o el jugador pierda. <br><br><h3>  Secuencias de creaci√≥n </h3><br>  Una ola de enemigos consiste en un grupo de enemigos creados uno tras otro hasta que se completa la ola.  Una ola puede contener diferentes tipos de enemigos, y el retraso entre su creaci√≥n puede variar.  Para no complicar la implementaci√≥n, comenzaremos con una secuencia de desove simple que crea el mismo tipo de enemigos con una frecuencia constante.  Entonces la ola ser√° solo una lista de tales secuencias. <br><br>  Para configurar cada secuencia, cree una clase <code>EnemySpawnSequence</code> .  Como es bastante complicado, p√≥ngalo en un archivo separado.  La secuencia debe saber qu√© f√°brica usar, qu√© tipo de enemigo crear, su n√∫mero y frecuencia.  Para simplificar la configuraci√≥n, haremos una pausa en el √∫ltimo par√°metro, que determina cu√°nto tiempo debe pasar antes de crear el pr√≥ximo enemigo.  Tenga en cuenta que este enfoque le permite utilizar varias f√°bricas enemigas en la ola. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { [SerializeField] EnemyFactory factory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField] EnemyType type = EnemyType.Medium; [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = <span class="hljs-number"><span class="hljs-number">1</span></span>; [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cooldown = <span class="hljs-number"><span class="hljs-number">1f</span></span>; }</code> </pre> <br><h3>  Las olas </h3><br>  Una ola es un conjunto simple de secuencias de creaci√≥n enemigas.  Cree un tipo de <code>EnemyWave</code> EnemyWave para √©l que comience con una secuencia est√°ndar. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyWave</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemySpawnSequence[] spawnSequences = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnemySpawnSequence() }; }</code> </pre> <br>  Ahora podemos crear oleadas de enemigos.  Por ejemplo, cre√© una ola que genera un grupo de enemigos c√∫bicos, comenzando con diez peque√±os, con una frecuencia de dos por segundo.  Les siguen cinco promedios, creados una vez por segundo, y, finalmente, un gran enemigo con una pausa de cinco segundos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b16/af3/47f/b16af347f057760db35703515642db89.png" width="320" height="376"></div><br>  <i>Una ola de cubos crecientes.</i> <br><br><div class="spoiler">  <b class="spoiler_title">¬øPuedo agregar un retraso entre secuencias?</b> <div class="spoiler_text">  Puedes implementarlo indirectamente.  Por ejemplo, inserte un retraso de cuatro segundos entre cubos peque√±os y medianos, reduzca el n√∫mero de cubos peque√±os en uno e inserte una secuencia de un cubo peque√±o con una pausa de cuatro segundos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59b/ff4/3f9/59bff43f9a71002c0bd562f270b755ea.png" width="320" height="272"></div><br>  <i>Cuatro segundos de retraso entre cubos peque√±os y medianos.</i> </div></div><br><h3>  Escenarios </h3><br>  El escenario de juego se crea a partir de una secuencia de olas.  Para esto, cree un <code>GameScenario</code> activo <code>GameScenario</code> con una sola matriz de ondas y luego <code>GameScenario</code> para crear el escenario. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameScenario</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemyWave[] waves = {}; }</code> </pre> <br>  Por ejemplo, cre√© un escenario con dos oleadas de enemigos peque√±os, medianos y grandes (MSC), primero con cubos y luego con esferas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/df0/73b/796df073b24d092d35093b6e56b8be79.png" width="320" height="142"></div><br>  <i>Escenario con dos olas de MSC.</i> <br><br><h3>  Movimiento de secuencia </h3><br>  Los tipos de activos se utilizan para crear scripts, pero como son activos, deben contener datos que no cambien durante el juego.  Sin embargo, para avanzar en el escenario, de alguna manera necesitamos rastrear su estado.  Una forma es duplicar el activo utilizado en el juego para que el duplicado rastree su condici√≥n.  Pero no necesitamos duplicar todo el activo, solo el estado y los enlaces al activo son suficientes.  As√≠ que <code>EnemySpawnSequence</code> una clase de <code>State</code> separada, primero para <code>EnemySpawnSequence</code> .  Como se aplica solo a una secuencia, la hacemos anidada.  Es v√°lido solo cuando tiene una referencia a una secuencia, por lo que le daremos un m√©todo constructor con un par√°metro de secuencia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18c/752/4fd/18c7524fdac87c062a6c683bbdee1866.png" width="315" height="50"></div><br>  <i>Un tipo de estado anidado que se refiere a su secuencia.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { EnemySpawnSequence sequence; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemySpawnSequence sequence</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sequence = sequence; } } }</code> </pre> <br>  Cuando queremos comenzar a avanzar en una secuencia, necesitamos una nueva instancia del estado para esto.  Agregue secuencias al m√©todo <code>Begin</code> , que construye y devuelve el estado.  Gracias a esto, todos los que llamen a <code>Begin</code> ser√°n responsables de hacer coincidir el estado, y la secuencia misma seguir√° sin estado.  Incluso ser√° posible avanzar en paralelo varias veces en la misma secuencia. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawnSequence</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { ‚Ä¶ } }</code> </pre> <br>  Para que el estado sobreviva despu√©s de reinicios en caliente, debe hacerlo serializable. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">State</span></span> { ‚Ä¶ }</code> </pre> <br>  La desventaja de este enfoque es que cada vez que ejecutamos una secuencia, necesitamos crear un nuevo objeto de estado.  Podemos evitar la asignaci√≥n de memoria convirti√©ndola en una estructura en lugar de una clase.  Esto es normal siempre que la afecci√≥n permanezca peque√±a.  Solo tenga en cuenta que el estado es un tipo de valor.  Cuando se transfiere, se copia, as√≠ que s√≠guelo en un solo lugar. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { ‚Ä¶ }</code> </pre> <br>  El estado de la secuencia consta de solo dos aspectos: el n√∫mero de enemigos generados y el progreso del tiempo de pausa.  Agregamos el m√©todo <code>Progress</code> , que aumenta el valor de la pausa por delta de tiempo, y luego lo restablece cuando se alcanza el valor configurado, similar a lo que sucede con el tiempo de generaci√≥n en <code>Game.Update</code> .  Incrementaremos la cuenta de enemigos cada vez que esto suceda.  Adem√°s, el valor de pausa debe comenzar con el valor m√°ximo para que la secuencia cree enemigos sin pausa al principio. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cooldown; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemySpawnSequence sequence</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sequence = sequence; count = <span class="hljs-number"><span class="hljs-number">0</span></span>; cooldown = sequence.cooldown; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cooldown += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { cooldown -= sequence.cooldown; count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/aba/5e5/50caba5e50d89e05a6cb9a631feb1c6d.png" width="315" height="74"></div><br>  <i>El estado contiene solo los datos necesarios.</i> <br><br><div class="spoiler">  <b class="spoiler_title">¬øPuedo acceder a EnemySpawnSequence.cooldown desde State?</b> <div class="spoiler_text">  S√≠, porque el <code>State</code> se establece en el mismo √°mbito.  Por lo tanto, los tipos anidados conocen los miembros privados de los tipos que los contienen. </div></div><br>  El progreso debe continuar hasta que se cree el n√∫mero deseado de enemigos y finalice la pausa.  En este punto, el <code>Progress</code> debe informar la finalizaci√≥n, pero lo m√°s probable es que saltemos un poco por encima del valor.  Por lo tanto, en este momento debemos devolver el tiempo extra para usarlo en la secuencia siguiente.  Para que esto funcione, debe convertir el delta de tiempo en un par√°metro.  Tambi√©n debemos indicar que a√∫n no hemos terminado, y esto se puede lograr devolviendo un valor negativo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { cooldown += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { cooldown -= sequence.cooldown; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt;= sequence.amount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cooldown; } count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Crea enemigos en cualquier lugar </h3><br>  Para que las secuencias generen enemigos, necesitamos convertir <code>Game.SpawnEnemy</code> a otro m√©todo est√°tico p√∫blico. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyFactory factory, EnemyType type</span></span></span><span class="hljs-function">)</span></span> { GameTile spawnPoint = instance.board.GetSpawnPoint( Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, instance.board.SpawnPointCount) ); Enemy enemy = factory.Get(type); enemy.SpawnOn(spawnPoint); instance.enemies.Add(enemy); }</code> </pre> <br>  Dado que el <code>Game</code> s√≠ ya no generar√° enemigos, podemos eliminar la <code>Update</code> la f√°brica enemiga, la velocidad de creaci√≥n, el proceso de promoci√≥n de creaci√≥n y el c√≥digo de creaci√≥n del enemigo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Llamaremos a <code>Game.SpawnEnemy</code> en <code>EnemySpawnSequence.State.Progress</code> despu√©s de aumentar el recuento de enemigos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { cooldown += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (cooldown &gt;= sequence.cooldown) { ‚Ä¶ count += <span class="hljs-number"><span class="hljs-number">1</span></span>; Game.SpawnEnemy(sequence.factory, sequence.type); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Avance de la ola </h3><br>  Tomemos el mismo enfoque para moverse a lo largo de una secuencia que cuando se mueve a lo largo de una onda completa.  Vamos a darle a <code>EnemyWave</code> su propio m√©todo <code>Begin</code> , que devuelve una nueva instancia de la estructura de <code>State</code> anidada.  En este caso, el estado contiene el √≠ndice de onda y el estado de la secuencia activa, que inicializamos con el comienzo de la primera secuencia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9eb/9f8/bc7/9eb9f8bc7769dd0c65624802ac2a97b8.png" width="315" height="128"></div><br>  <i>Un estado de onda que contiene el estado de una secuencia.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyWave</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemySpawnSequence[] spawnSequences = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnemySpawnSequence() }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { EnemyWave wave; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; EnemySpawnSequence.State sequence; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EnemyWave wave</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wave = wave; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; Debug.Assert(wave.spawnSequences.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Empty wave!"</span></span>); sequence = wave.spawnSequences[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } } }</code> </pre> <br>  Tambi√©n agregamos el m√©todo <code>EnemyWave.State</code> <code>Progress</code> , que utiliza el mismo enfoque que antes, con cambios menores.  Comenzamos movi√©ndonos a lo largo de la secuencia activa y reemplazamos el delta de tiempo con el resultado de esta llamada.  Mientras queda tiempo, pasamos a la siguiente secuencia, si se accede a ella, y avanzamos en ella.  Si no quedan secuencias, entonces devolvemos el tiempo restante;  de lo contrario, devuelve un valor negativo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { deltaTime = sequence.Progress(deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= wave.spawnSequences.Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deltaTime; } sequence = wave.spawnSequences[index].Begin(); deltaTime = sequence.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1f</span></span>; }</code> </pre> <br><h3>  Promoci√≥n de guiones </h3><br>  Agregue <code>GameScenario</code> el mismo procesamiento.  En este caso, el estado contiene el √≠ndice de onda y el estado de la onda activa. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameScenario</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { [SerializeField] EnemyWave[] waves = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Begin</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> State { GameScenario scenario; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; Debug.Assert(scenario.waves.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Empty scenario!"</span></span>); wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } } }</code> </pre> <br>  Como estamos en el nivel superior, el m√©todo <code>Progress</code> no requiere un par√°metro y puede usar <code>Time.deltaTime</code> directamente.  No necesitamos devolver el tiempo restante, pero debemos mostrar si el script se ha completado.  Volveremos <code>false</code> despu√©s del final de la √∫ltima ola y <code>true</code> para mostrar que el script a√∫n est√° activo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Script ejecutado </h3><br>  Para jugar un script de <code>Game</code> , necesita un campo de configuraci√≥n de script y un seguimiento de su estado.  Simplemente ejecutaremos el script en Awake y ejecutaremos <code>Update</code> en √©l hasta que se <code>Update</code> el estado del resto del juego. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameScenario scenario = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; GameScenario.State activeScenario; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); board.ShowGrid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; activeScenario = scenario.Begin(); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ activeScenario.Progress(); enemies.GameUpdate(); Physics.SyncTransforms(); board.GameUpdate(); nonEnemies.GameUpdate(); }</code> </pre> <br>  Ahora el script configurado se lanzar√° al comienzo del juego.  La promoci√≥n se llevar√° a cabo hasta su finalizaci√≥n, y despu√©s de eso no pasa nada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mk/x0/uf/mkx0ufxshpgvy29wjr_nxdmneu4.gif"></div><br>  <i>Dos olas aceleraron 10 veces.</i> <br><br><h2>  Iniciar y finalizar juegos </h2><br>  Podemos reproducir un escenario, pero despu√©s de su finalizaci√≥n no aparecer√°n nuevos enemigos.  Para que el juego contin√∫e, necesitamos hacer posible comenzar un nuevo escenario, ya sea manualmente o porque el jugador perdi√≥ / gan√≥.  Tambi√©n puede implementar una selecci√≥n de varios escenarios, pero en este tutorial no lo consideraremos. <br><br><h3>  El comienzo de un nuevo juego. </h3><br>  Idealmente, necesitamos la oportunidad de comenzar un nuevo juego en cualquier momento.  Para hacer esto, debes restablecer el estado actual de todo el juego, es decir, tendremos que restablecer muchos objetos.  Primero, agregue un m√©todo <code>Clear</code> a <code>GameBehaviorCollection</code> que utilice todos sus comportamientos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; behaviors.Count; i++) { behaviors[i].Recycle(); } behaviors.Clear(); }</code> </pre> <br>  Esto sugiere que todos los comportamientos pueden eliminarse, pero hasta ahora este no es el caso.  Para que esto funcione, agregue <code>GameBehavior</code> m√©todo de <code>Recycle</code> abstracto a <code>GameBehavior</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>;</code> </pre> <br>  El m√©todo de <code>Recycle</code> de la clase <code>WarEntity</code> debe anularlo expl√≠citamente. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { originFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  <code>Enemy</code> a√∫n no tiene un m√©todo de <code>Recycle</code> , as√≠ que agr√©galo.  Todo lo que tiene que hacer es obligar a la f√°brica a devolverlo.  Luego llamamos a <code>Recycle</code> donde accedemos directamente a la f√°brica. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Health &lt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } progress += Time.deltaTime * progressFactor; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ } ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  <code>GameBoard</code> tambi√©n debe reiniciarse, as√≠ que demos el m√©todo <code>Clear</code> , que vac√≠a todos los mosaicos, restablece todos los puntos de creaci√≥n y actualiza el contenido, y luego establece los puntos de inicio y finalizaci√≥n est√°ndar.  Luego, en lugar de repetir el c√≥digo, podemos llamar a <code>Clear</code> al final de <code>Initialize</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { ‚Ä¶ } } Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.Content = contentFactory.Get(GameTileContentType.Empty); } spawnPoints.Clear(); updatingContent.Clear(); ToggleDestination(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]); ToggleSpawnPoint(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br>  Ahora podemos agregar el m√©todo <code>BeginNewGame</code> al <code>Game</code> , eliminar enemigos, otros objetos y el campo, y luego comenzar un nuevo script. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginNewGame</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { enemies.Clear(); nonEnemies.Clear(); board.Clear(); activeScenario = scenario.Begin(); }</code> </pre> <br>  Llamaremos a este m√©todo en <code>Update</code> si presiona B antes de pasar al script. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.B)) { BeginNewGame(); } activeScenario.Progress(); ‚Ä¶ }</code> </pre> <br><h3>  Perdiendo </h3><br>  El objetivo del juego es derrotar a todos los enemigos antes de que un cierto n√∫mero de ellos llegue al punto final.  El n√∫mero de enemigos necesarios para activar la condici√≥n de derrota depende de la salud inicial del jugador, para lo cual agregaremos un campo de configuraci√≥n al <code>Game</code> .  Como contamos enemigos, usaremos enteros, no flotantes. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0, 100)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startingPlayerHealth = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f3/9c5/11a/4f39c511ab9d362b1cc7e55610a317aa.png" width="320" height="38"></div><br>  <i>Inicialmente, un jugador tiene 10 puntos de vida.</i> <br><br>  En el caso de Despertar o el comienzo de un nuevo juego, asignamos el valor inicial a la salud actual del jugador. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> playerHealth; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { playerHealth = startingPlayerHealth; ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginNewGame</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { playerHealth = startingPlayerHealth; ‚Ä¶ }</code> </pre> <br>  Agrega un m√©todo p√∫blico est√°tico <code>EnemyReachedDestination</code> que los enemigos puedan decirle a <code>Game</code> que han llegado al punto final.  Cuando esto sucede, reduce la salud del jugador. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnemyReachedDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance.playerHealth -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Llame a este m√©todo en <code>Enemy.GameUpdate</code> en el momento apropiado. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Game.EnemyReachedDestination(); Recycle(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Ahora podemos verificar la condici√≥n de la derrota en <code>Game.Update</code> .  Si la salud del jugador es igual o inferior a cero, se activa la condici√≥n de derrota.  Simplemente registramos esta informaci√≥n e inmediatamente comenzamos un nuevo juego antes de seguir adelante.  Pero haremos esto solo con una salud inicial positiva.  Esto nos permite usar 0 como salud inicial, por lo que es imposible perder.  Por lo tanto, ser√° conveniente para nosotros probar los guiones. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (playerHealth &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; startingPlayerHealth &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Defeat!"</span></span>); BeginNewGame(); } activeScenario.Progress();</code> </pre> <br><h3>  Victoria </h3><br>  Una alternativa a la derrota es la victoria, que se logra al final del escenario, si el jugador a√∫n est√° vivo.  Es decir, cuando el resultado de <code>GameScenario.Progess</code> es <code>false</code> , mostramos un mensaje de victoria en el registro, iniciamos un nuevo juego e inmediatamente <code>GameScenario.Progess</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (playerHealth &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Defeat!"</span></span>); BeginNewGame(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!activeScenario.Progress()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Victory!"</span></span>); BeginNewGame(); activeScenario.Progress(); }</code> </pre> <br>  Sin embargo, la victoria llegar√° despu√©s del final de la √∫ltima pausa, incluso si todav√≠a hay enemigos en el campo.  Necesitamos posponer la victoria hasta que todos los enemigos desaparezcan, lo que se puede lograr verificando si la colecci√≥n de enemigos est√° vac√≠a.  Suponemos que tiene la propiedad <code>IsEmpty</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!activeScenario.Progress() &amp;&amp; enemies.IsEmpty) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Victory!"</span></span>); BeginNewGame(); activeScenario.Progress(); }</code> </pre> <br>  Agregue la propiedad deseada a <code>GameBehaviorCollection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsEmpty =&gt; behaviors.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><h3>  Control del tiempo </h3><br>  Implementemos tambi√©n la funci√≥n de gesti√≥n del tiempo, esto ayudar√° en las pruebas y a menudo es una funci√≥n de juego.  Para comenzar, deja que <code>Game.Update</code> una barra espaciadora y usa este evento para habilitar / deshabilitar pausas en el juego.  Esto se puede hacer cambiando los valores de <code>Time.timeScale</code> entre cero y uno.  Esto no cambiar√° la l√≥gica del juego, pero har√° que todos los objetos se congelen en su lugar.  O puede usar un valor muy peque√±o en lugar de 0, por ejemplo 0.01, para crear una c√°mara extremadamente lenta. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pausedTimeScale = <span class="hljs-number"><span class="hljs-number">0f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.Space)) { Time.timeScale = Time.timeScale &gt; pausedTimeScale ? pausedTimeScale : <span class="hljs-number"><span class="hljs-number">1f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.B)) { BeginNewGame(); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En segundo lugar, agregaremos </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la velocidad del juego </font><font style="vertical-align: inherit;">al </font><font style="vertical-align: inherit;">control deslizante para que pueda acelerar el tiempo.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1f, 10f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> playSpeed = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5d/641/4e9/b5d6414e9cd53d7ac89c5c1b3699b806.png" width="320" height="38"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Velocidad de juego </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la pausa no est√° activada y el valor de pausa no est√° asignado a la escala de tiempo, lo hacemos igual a la velocidad del juego. </font><font style="vertical-align: inherit;">Adem√°s, al eliminar una pausa, usamos la velocidad del juego en lugar de la unidad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.Space)) { Time.timeScale = Time.timeScale &gt; pausedTimeScale ? pausedTimeScale : playSpeed; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Time.timeScale &gt; pausedTimeScale) { Time.timeScale = playSpeed; }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escenarios de bucle </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En algunos escenarios, puede ser necesario atravesar todas las olas varias veces. </font><font style="vertical-align: inherit;">Es posible implementar el soporte para dicha funci√≥n haciendo posible repetir los escenarios recorriendo todas las ondas varias veces. </font><font style="vertical-align: inherit;">Puede mejorar a√∫n m√°s esta funci√≥n, por ejemplo, habilitando la repetici√≥n de solo la √∫ltima ola, pero en este tutorial solo repetiremos todo el script.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avance c√≠clico sobre las olas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue al </font></font><code>GameScenario</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">control deslizante de configuraci√≥n para establecer el n√∫mero de ciclos, por defecto, as√≠gnele un valor de 1. Como m√≠nimo, haga cero, y el script se repetir√° sin cesar. </font><font style="vertical-align: inherit;">Entonces crearemos un escenario de supervivencia que no puede ser derrotado, y el punto es verificar cu√°nto puede resistir el jugador.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0, 10)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycles = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0c/5d0/9df/d0c5d09dfd50e0e088c1848aaa32d531.png" width="320" height="38"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escenario de dos ciclos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora </font></font><code>GameScenario.State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deber√≠a seguir el n√∫mero del ciclo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cycle, index; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><code>Progress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ejecutaremos despu√©s de completar el incremento del ciclo, y regresaremos </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo si ha pasado un n√∫mero suficiente de ciclos. </font><font style="vertical-align: inherit;">De lo contrario, restablecemos el √≠ndice de onda a cero y continuamos movi√©ndonos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= scenario.cycles &amp;&amp; scenario.cycles &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } index = <span class="hljs-number"><span class="hljs-number">0</span></span>; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aceleraci√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el jugador logr√≥ derrotar el ciclo una vez, entonces podr√° derrotarlo nuevamente sin ning√∫n problema. Para mantener el escenario complejo, necesitamos aumentar la complejidad. La forma m√°s f√°cil de hacerlo, reduciendo en ciclos posteriores todas las pausas entre la creaci√≥n de enemigos. Entonces los enemigos aparecer√°n m√°s r√°pido e inevitablemente vencer√°n al jugador en el escenario de supervivencia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un </font></font><code>GameScenario</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">control deslizante de configuraci√≥n para controlar la aceleraci√≥n por ciclo. Este valor se agrega a la escala de tiempo despu√©s de cada ciclo solo para reducir las pausas. Por ejemplo, con una aceleraci√≥n de 0.5, el primer ciclo tiene una velocidad de pausa de √ó 1, el segundo ciclo tiene una velocidad de √ó 1.5, el tercero √ó 2, el cuarto √ó 2.5, y as√≠ sucesivamente.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cycleSpeedUp = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora necesita agregar la escala de tiempo y </font></font><code>GameScenario.State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Siempre es inicialmente igual a 1 y aumenta en un valor dado de aceleraci√≥n despu√©s de cada ciclo. </font><font style="vertical-align: inherit;">√öselo para escalar </font></font><code>Time.deltaTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antes de moverse a lo largo de la ola.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timeScale; EnemyWave.State wave; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameScenario scenario</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scenario = scenario; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; index = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeScale = <span class="hljs-number"><span class="hljs-number">1f</span></span>; wave = scenario.waves[<span class="hljs-number"><span class="hljs-number">0</span></span>].Begin(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Progress</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> deltaTime = wave.Progress(timeScale * Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (deltaTime &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++index &gt;= scenario.waves.Length) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= scenario.cycles &amp;&amp; scenario.cycles &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } index = <span class="hljs-number"><span class="hljs-number">0</span></span>; timeScale += scenario.cycleSpeedUp; } wave = scenario.waves[index].Begin(); deltaTime = wave.Progress(deltaTime); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qv/-d/3s/qv-d3srpikyuiorxx9vjk06wir8.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tres ciclos con mayor velocidad de creaci√≥n del enemigo; </font><font style="vertical-align: inherit;">acelerado diez veces. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øDesea recibir informaci√≥n sobre el lanzamiento de nuevos tutoriales? </font><font style="vertical-align: inherit;">¬°Sigue mi p√°gina en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Art√≠culo en PDF del </font></a></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositorio</font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466855/">https://habr.com/ru/post/466855/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466839/index.html">La historia de la creaci√≥n de Norton Commander. Parte 1/3</a></li>
<li><a href="../466841/index.html">Por qu√© una almohadilla t√©rmica, si hay una computadora port√°til: el estudio de la resistencia t√©rmica a nivel at√≥mico</a></li>
<li><a href="../466845/index.html">Entrevista inversa: ¬øqu√© preguntas hacerle a la empresa?</a></li>
<li><a href="../466849/index.html">noexcept-ctcheck o algunas macros simples para ayudar al compilador a escribir c√≥digo noexcept</a></li>
<li><a href="../466851/index.html">L√≠nea Agilex - 10nm Intel FPGA</a></li>
<li><a href="../466857/index.html">Ejecuci√≥n de la aplicaci√≥n en segundo plano en iOS 13</a></li>
<li><a href="../466859/index.html">Uso del Servicio de federaci√≥n de AD para autorizar a los usuarios de AWS con distribuci√≥n de derechos</a></li>
<li><a href="../466861/index.html">C√≥mo escapar de la realidad usando un hackathon</a></li>
<li><a href="../466863/index.html">Configurar la as√≠ntota</a></li>
<li><a href="../466865/index.html">Esperando el primero de noviembre: prohibici√≥n o legalizaci√≥n de las criptomonedas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>