<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📂 👧🏽 ♨️ Bidang logis dalam database, apakah ada penangkal? 👨‍🌾 🎩 🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seringkali tabel berisi sejumlah besar bidang logis, tidak ada cara untuk mengindeks semuanya, dan efektivitas pengindeksan seperti itu rendah. Namun ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bidang logis dalam database, apakah ada penangkal?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483056/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gv/ls/ke/gvlskeckr84dlji3r0xb3pmnk1k.jpeg" width="500"></div><br>  Seringkali tabel berisi sejumlah besar bidang logis, tidak ada cara untuk mengindeks semuanya, dan efektivitas pengindeksan seperti itu rendah.  Namun demikian, untuk bekerja dengan ekspresi logis sewenang-wenang dalam SQL, mekanisme pengindeksan multidimensi cocok, yang akan dibahas di bawah cat. <br><a name="habracut"></a><br>  Dalam SQL, bidang logis digunakan terutama dalam dua kasus.  Pertama, ketika Anda benar-benar membutuhkan atribut biner, misalnya, 'beli / jual' di tabel transaksi.  Atribut seperti itu jarang berubah seiring waktu. <br><br>  Kedua, untuk merekam <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">keadaan mesin negara</a> yang menggambarkan catatan.  Dipahami bahwa objek logis yang berhubungan dengan catatan tabel melewati serangkaian keadaan, jumlah yang dan transisi di antara mereka ditentukan oleh logika yang diterapkan.  Contoh sederhana adalah teknik "hapus lunak", ketika catatan tidak secara fisik dihancurkan, tetapi hanya ditandai sebagai dihapus. <br><br>  Jika mesinnya kompleks, mungkin ada cukup banyak bidang seperti itu, di salah satu tabel <a href="https://arqatech.com/ru/products/qort/">kami</a> ada 58 (+14 ketinggalan zaman) bidang tersebut (termasuk set bendera) dan ini bukan sesuatu yang luar biasa.  Ini pada awalnya tidak dimaksudkan, tetapi ketika produk berkembang dan persyaratan eksternal berubah, mesin yang sesuai berkembang, pengembang datang dan pergi, analis berubah ... pada titik tertentu mungkin lebih aman untuk mendapatkan bendera baru daripada memahami semua seluk-beluk.  Selain itu, data historis telah terakumulasi dan kondisinya harus tetap memadai. <br><br><div class="spoiler">  <b class="spoiler_title">offtopic</b> <div class="spoiler_text">  Dalam beberapa hal, ini mirip dengan proses evolusi, ketika massa informasi / mekanisme disimpan dalam genom, yang pada pandangan pertama tidak diperlukan sama sekali, tetapi tidak mungkin untuk menghilangkannya.  Di sisi lain, ada baiknya memperlakukan mekanisme ini dengan rasa hormat, karena merekalah yang memungkinkan para pendahulu evolusi untuk bertahan hidup (termasuk selama <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2581%25D1%2581%25D0%25BE%25D0%25B2%25D0%25BE%25D0%25B5_%25D0%25B2%25D1%258B%25D0%25BC%25D0%25B8%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">kepunahan besar</a> ) dan memenangkan perlombaan evolusi.  Lagi, siapa yang tahu ke mana evolusi akan membawa kita dan apa yang terbukti bermanfaat di masa depan. <br></div></div><br>  Menempatkan bendera berarti tidak hanya menambahkan bidang dari jenis yang sesuai, tetapi juga memperhitungkannya dalam pengoperasian automaton, kondisi apa yang memengaruhinya, di mana transisi yang dilibatkannya.  Dalam praktiknya, tampilannya seperti ini: <br><br><ul><li>  suatu proses atau serangkaian proses, sebut saja mereka "penulis", buat catatan baru di kondisi awal (mungkin di salah satu kondisi awal) </li><li>  sejumlah proses, sebut saja mereka "pembaca", dari waktu ke waktu mereka membaca objek yang ada di negara yang mereka butuhkan </li><li>  sejumlah proses, sebut saja "penangan", pantau status spesifik dan, berdasarkan logika yang diterapkan, ubah status ini.  Yaitu  mengoperasikan mesin negara. </li></ul><br>  Untuk memilih catatan yang berada dalam kondisi tertentu, cukup jarang bila pemfilteran oleh salah satu bidang Boolean sudah cukup.  Biasanya ini adalah ekspresi keseluruhan, terkadang non-sepele.  Tampaknya Anda perlu mengindeks bidang ini dan prosesor SQL akan mengetahuinya.  Tapi tidak sesederhana itu. <br><br>  Pertama, bisa ada banyak bidang Boolean, mengindeks semuanya akan terlalu boros. <br><br>  Kedua, itu bisa berubah menjadi tidak berguna sejak itu  selektivitas untuk masing-masing bidang akan rendah, dan probabilitas gabungan tidak tercakup oleh statistik prosesor SQL. <br><br>  Misalkan dalam tabel T1 ada dua bidang Boolean: F1 &amp; F2, dan kueri <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> F1, F2, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> F1, F2</code> </pre> <br>  memberi <br><div class="scrollable-table"><table><tbody><tr><th>  F1 </th><th>  F2 </th><th>  COUNT </th></tr><tr><td>  salah </td><td>  salah </td><td align="center">  499 </td></tr><tr><td>  salah </td><td>  benar </td><td align="center">  1 </td></tr><tr><td>  benar </td><td>  salah </td><td align="center">  1 </td></tr><tr><td>  benar </td><td>  benar </td><td align="center">  499 </td></tr></tbody></table></div><br>  Yaitu  meskipun, menurut F1 &amp; F2, benar dan salah sama-sama memungkinkan, kombinasi (benar, salah) hanya keluar sekali dari seribu.  Akibatnya, jika kita mengindeks F1 &amp; F2 secara terpisah <u>dan memaksanya untuk digunakan dalam kueri</u> , prosesor SQL harus membaca setengah dari kedua indeks dan melewati hasilnya.  Mungkin lebih murah untuk membaca seluruh tabel dan menghitung ekspresi untuk setiap baris. <br><br>  Dan bahkan jika Anda mengumpulkan statistik pada permintaan yang sudah selesai, itu tidak akan banyak berguna.  statistik khusus untuk bidang yang bertanggung jawab untuk keadaan mesin mengapung sangat banyak.  Memang, setiap saat "penangan" dapat datang dan mentransfer setengah dari garis S1 negara ke S2. <br><br>  Untuk bekerja dengan ekspresi seperti itu, indeks multidimensi menunjukkan dirinya, algoritma yang <a href="https://habr.com/post/464057/">disajikan sebelumnya</a> dan terbukti cukup baik. <br><br>  Tetapi pertama-tama Anda perlu mencari tahu bagaimana ekspresi logis sewenang-wenang akan berubah menjadi permintaan untuk indeks. <br><br><h4>  Bentuk normal disjungtif </h4><br>  Kueri tunggal ke indeks multidimensi adalah persegi panjang multidimensi yang membatasi ruang kueri.  Jika bidang berpartisipasi dalam permintaan, batasan ditetapkan untuk itu.  Jika tidak, persegi panjang dalam koordinat ini hanya dibatasi oleh lebar koordinat ini.  Koordinat logis memiliki kapasitas 1. <br><br>  Kueri pencarian dalam indeks tersebut adalah rantai &amp; (kata hubung), misalnya, ekspresi: v1 &amp; v2 &amp; v3 &amp; (! V4), setara dengan v1: [1,1], v2: [1,1], v3: [1, 1], v4: [0,0].  Dan semua bidang lainnya memiliki rentang: [0,1]. <br><br>  Mengingat hal ini, pandangan kami segera beralih ke <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25B7%25D1%258A%25D1%258E%25D0%25BD%25D0%25BA%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BD%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0">DNF</a> - salah satu bentuk kanonik dari ekspresi logis.  Dikatakan bahwa ungkapan apa pun dapat diwakili sebagai disjungsi dari konjungsi sastra.  Literal di sini mengacu pada bidang logis atau negasinya. <br><br>  Dengan kata lain, melalui manipulasi sederhana, ekspresi logis apa pun dapat direpresentasikan sebagai disjungsi dari beberapa pertanyaan ke indeks logis multidimensi. <br><br>  Ada satu NAMUN.  Transformasi semacam itu dalam beberapa kasus dapat menyebabkan peningkatan ukuran ekspresi yang eksponensial.  Misalnya, konversi dari <br><br><img src="https://habrastorage.org/webt/sn/fg/gd/snfggdwldqn3fggm4ymvhrfa_xa.png"><br><br>  mengarah ke ekspresi 2 ** n istilah.  Dalam kasus seperti itu, pengembang aplikasi harus memikirkan makna fisik dari apa yang dia lakukan, dan pada bagian dari prosesor SQL, Anda selalu dapat menolak untuk menggunakan indeks logis jika jumlah konjungsi melebihi batas yang wajar. <br><br><h4>  Algoritma Pengindeksan Multidimensi </h4><br>  Untuk pengindeksan multidimensi, sifat-sifat kurva penomoran yang mirip sendiri berdasarkan pada simpleks hiper-kubik dengan sisi 2. Digunakan <a href="https://habr.com/post/464057/">, ternyata</a> , dua versi kurva tersebut sangat penting secara praktis - kurva Z dan kurva Hilbert. <br><br><img src="https://habrastorage.org/webt/ij/pk/p2/ijpkp2sneivmayqaie38y91mylc.png" alt="gambar"><br>  <i>Gambar 1 kurva Z dua dimensi, iterasi 3 dan 6</i> <br><br><img src="https://habrastorage.org/webt/bo/ar/oq/boaroq7scpwqyvargccwvv6i7li.png" alt="gambar"><br>  <i>Gambar 2 kurva Hilbert dua dimensi, iterasi 3 dan 6</i> <br><br><ul><li>  Simpleks N-dimensi dengan sisi 2 memiliki 2 simpul ** ** dan (2 ** n-1) transisi di antaranya. </li><li>  Iterasi dasar simpleks mengubah setiap simpul simpleks menjadi simpleks level bawah. </li><li>  Setelah melakukan jumlah iterasi yang diperlukan, kita dapat membuat kisi hiper-kubik dengan berbagai ukuran. </li><li>  Selain itu, setiap simpul kisi ini akan memiliki nomor uniknya sendiri - jalur yang diambil sepanjang kurva penomoran sejak awal.  Selain itu, setiap node kisi ini memiliki nilai di setiap koordinat.  Faktanya, <u>kurva penomoran menerjemahkan titik multidimensi menjadi nilai satu dimensi yang cocok untuk pengindeksan dengan B-tree reguler</u> . </li><li>  Semua node yang terletak di dalam simpleks level apa pun berada dalam interval yang sama dan interval ini tidak bersinggungan dengan simpleks apa pun dari level yang sama. </li><li>  Oleh karena itu, kotak pencarian (kotak) apa pun dapat dibagi menjadi sejumlah kecil subqueries hiper-kubik, di mana masing-masing indeks dapat dibaca oleh satu pencarian / lintasan. <br></li><li>  Untuk ini kami menambahkan keajaiban pekerjaan tingkat rendah dengan B-tree agar tidak membuat permintaan yang tidak berguna dan ... algoritma siap. </li></ul><br>  Begini cara kerjanya dalam praktik: <br><br><img src="https://habrastorage.org/webt/to/hc/pq/tohcpqixfqjdnwh_hhnqlx8lgio.png"><br>  <i>Gambar 3 Contoh pencarian dalam indeks dua dimensi (kurva-Z)</i> <br><br>  Gambar 3 menunjukkan pembagian tingkat pencarian asli ke dalam sub-kueri dan poin yang ditemukan.  Indeks dua dimensi digunakan, dibangun di atas serangkaian 100.000.000 titik acak yang terdistribusi secara seragam [1.000.000, 1.000.000]. <br><br><h4>  Indeks multidimensi logis </h4><br>  Karena kita berbicara tentang pengindeksan multidimensi, sekarang saatnya untuk memikirkan berapa multidimensi itu?  Apakah ada batasan objektif? <br><br>  Tentu saja, karena B-tree memiliki organisasi halaman dan untuk menjadi pohon, setidaknya dua elemen harus dijamin agar sesuai pada halaman.  Jika Anda mengambil halaman untuk 8K, maka menyimpan satu item tidak bisa lebih dari 4K.  Dalam 4K, tanpa kompresi, sekitar 1000 nilai 32-bit cocok.  Ini cukup banyak, di luar batas aplikasi yang masuk akal, kita dapat mengatakan bahwa batas fisik praktis tidak tersedia. <br><br>  Ada sisi lain, setiap dimensi tambahan sama sekali tidak gratis, ini memakan ruang disk dan memperlambat pekerjaan.  Dari sudut pandang "makna fisik", bidang yang berubah pada saat yang sama harus dimasukkan dalam indeks yang sama dan pencarian untuk mereka juga berjalan bersamaan.  Tidak ada gunanya mengindeks semuanya dalam satu baris. <br><br>  Bidang logis berbeda.  Seperti yang telah kita lihat, lusinan bidang logis dapat dilibatkan dalam mekanisme yang sama.  Dan biaya penyimpanan / membaca cukup kecil.  Ada godaan untuk mengumpulkan semua bidang logis dalam satu indeks dan melihat apa yang terjadi. <br><br>  Benar, ada nuansa: <br><br><ul><li>  Sampai sekarang, dalam nilai yang diindeks, angka-angka dari koordinat yang berbeda dicampur, dalam angka-angka paling penting dari kunci adalah bit-bit paling tidak signifikan dari koordinat ... Oleh karena itu, urutan bidang selama pengindeksan tidak menjadi masalah. </li><li>  Sekarang, satu bit dihabiskan untuk menyimpan nilai satu bidang logis.  Yaitu  beberapa bidang logis akan menuju ke akhir kunci, dan beberapa ke awal.  Ini berarti bahwa pemfilteran sebagian bidang akan sangat efektif, dan sebagian akan sangat tidak efisien.  Bahkan, jika kita melakukan pencarian dalam urutan terendah, kita harus membaca seluruh indeks untuk mendapatkan jawaban.  Tapi ini (kemungkinan besar) lebih baik daripada membaca seluruh tabel untuk menjawab pertanyaan yang sama. </li><li>  Ada masalah pilihan - semua bidang logis sama, tetapi beberapa akan lebih sama daripada yang lain.  Dari pertimbangan umum, perlu untuk melihat distorsi statistik, semakin kuat rasio benar / salah untuk bidang tertentu jauh dari kesetimbangan, semakin tua harus menjadi debit di mana nilainya muncul. </li><li>  Pemartisian berdasarkan jenis kurva penomoran menghilang, jika sebelumnya perlu memilih antara kurva Z dan kurva Hilbert, tidak ada perbedaan praktis pada data bit tunggal. </li><li>  NULLs.  Berdasarkan fakta bahwa NULL bukan nilai yang tidak diketahui, tetapi tidak adanya nilai apa pun, catatan tersebut tidak boleh dimasukkan dalam indeks.  Dalam indeks satu dimensi, inilah yang terjadi.  Tetapi dalam kasus kami, mungkin ternyata beberapa bidang logis berisi nilai, dan beberapa tidak.  Akibatnya, kami tidak dapat memasukkan ini ke dalam indeks sejak saat itu  algoritma pencarian tidak tahu cara bekerja dengan logika ternary.  Dan oleh karena itu, catatan seperti itu seharusnya tidak mungkin untuk dimasukkan ke dalam tabel (jika ada indeks multidimensi, tidak harus yang logis, omong-omong) </li></ul><br>  Diharapkan bahwa indeks multidimensi logis dalam beberapa kasus mungkin tidak bekerja dengan sangat efisien.  Sebenarnya, indeks apa pun dapat bekerja secara tidak efisien jika terlalu banyak data masuk ke area pencarian.  Tetapi untuk indeks multi-dimensi yang logis, ini diperparah dengan ketergantungan pada urutan bidang yang dijelaskan di atas, ketika demi hasil kecil Anda harus membaca seluruh indeks.  Sejauh ini merupakan masalah dalam praktiknya, hanya eksperimen yang dapat ditampilkan. <br><br><h4>  Eksperimen numerik </h4><br>  Membangun indeks: <br><br><ul><li>  indeks akan menjadi 128-bit yaitu  dibangun di 128 bidang logis </li><li>  dan akan mengandung 2 ** 30 elemen </li><li>  nilai elemen indeks akan menjadi angka dari 0 hingga 2 ** 30 </li><li>  kunci elemen indeks akan menjadi nomor yang sama bergeser 48 bit ke kiri, mis.  bidang logis 48 hingga 78 akan diisi dengan angka angka dalam urutan yang sama </li><li>  sebagai hasilnya, kita mendapatkan 30 bidang logis yang signifikan di tengah kunci, bit yang tersisa akan diisi 0 <br></li><li>  Setiap bidang boolean memiliki statistik yang sama benar / salah </li><li>  Semuanya independen secara statistik. </li></ul><br>  Cari: <br><br><ul><li>  Setiap percobaan sesuai dengan pemilihan beberapa bidang logis berturut-turut dan penetapan nilai pencarian untuk mereka.  Bukan karena algoritme hanya dapat mencari dalam garis, tetapi karena dimungkinkan untuk memvisualisasikan hasil percobaan lebih jelas, kami hanya memiliki dua dimensi - lebar strip dan posisinya </li><li>  Sebanyak 24 seri percobaan.  Di setiap seri kita akan mencari nilai di mana strip bidang logis dari lebar N yang sesuai (dari 1 hingga 24 bit) menjadikan nilai tersebut benar. </li><li>  Di setiap seri akan ada subseries percobaan di mana satu strip bidang logis dari lebar yang dipilih terletak dengan pergeseran S yang berbeda dari awal strip menjadi 30 bidang logis yang signifikan.  Total (30-N) percobaan di subseries. </li><li>  Di setiap percobaan, pencarian dilakukan untuk semua elemen indeks yang memenuhi kondisi, yaitu  bidang dengan angka dalam interval [48 + S, 48 + S + N -1] akan dicari dalam interval [1,1], sisanya dalam interval [0,1] <br></li><li>  Pencarian dilakukan dari awal yang dingin </li><li>  Hasilnya adalah jumlah halaman disk yang dibaca, termasuk caching (4096 halaman cache) </li><li>  Kontrol operasi yang benar dilakukan dengan dua cara - jumlah elemen yang ditemukan harus sama dengan 2 ** (30-N) dan dalam nilai yang ditemukan Anda dapat memeriksa digit yang sesuai <br></li></ul><br>  Jadi <br><br><img src="https://habrastorage.org/webt/1p/5a/bn/1p5abn4kb0b6myjlusbnoen308w.png"><br>  <i>Gambar 4 Hasil, jumlah halaman yang dibaca dalam seri berbeda</i> <br><br>  By Y - jumlah halaman yang dibaca ditunda. <br>  Pada X - pengalihan strip dari kategori termuda (48) ke senior.  Garis-garis dengan lebar berbeda ditandatangani dan ditandai dengan warna berbeda. <br><br><img src="https://habrastorage.org/webt/lf/t0/7x/lft07xucczbi19oxdskdrvzb-ia.png"><br>  <i>Gambar 5 Data yang sama seperti Gambar 4, tampilan lain</i> <br><br>  Pergeseran X-band <br>  Y - bandwidth <br><br>  Apa yang harus diperhatikan: <br><br><ul><li>  Meskipun ini tidak langsung terlihat dalam gambar, indeks berfungsi dengan benar, itu terlihat baik dalam jumlah elemen yang ditemukan maupun dalam konten elemen itu sendiri. </li><li>  semua garis dengan lebar tidak lebih dari 10 dengan pergeseran 0 memerlukan pembacaan indeks yang berkelanjutan </li><li>  garis-garis dengan lebar 1 hingga 18 dengan peningkatan pergeseran mencapai asimtot 2 ** (- N) dari ukuran seluruh indeks, yang logis </li><li>  untuk pita yang lebih lebar dari asymptote - ketinggian pohon, tidak boleh ada sedikit bacaan </li><li>  sedikit lebih dari 1000 elemen ditempatkan pada halaman lembar indeks, ini dapat dilihat pada strip lebar 10, yang ketika menggeser 0 tidak lagi membutuhkan membaca seluruh indeks, beberapa halaman dapat dilewati </li><li>  penyaringan tingkat rendah bekerja sangat baik.  Pertimbangkan strip dengan lebar 10. Pilihan pencarian yang ideal adalah dengan pergeseran 20 (total 30 bidang signifikan), ketika tidak ada bidang yang tidak ditentukan dalam awalan sama sekali, data dapat ditemukan dengan satu balok.  Dalam situasi ini, sekitar 1/1000 indeks dibaca selama pencarian - 779 halaman. <br>  Kasus menengah adalah pergeseran 10, kami memiliki awalan dan akhiran dari 10 bidang yang tidak diketahui.  Jumlah halaman adalah 2484, hanya tiga kali lebih buruk daripada dalam kasus yang ideal. <br>  Dan bahkan dalam kasus terburuk, dengan pergeseran 0 (awalan 20 bidang yang tidak diketahui), Anda dapat melewati beberapa halaman. </li></ul><br>  Secara keseluruhan, algoritma pengindeksan multidimensi dapat dikenali sebagai efisien bahkan dalam kasus yang absurd.  <u>Tetapi opsi yang paling tidak berhasil dari sudut pandang indeks logis dipertimbangkan - keadaan yang dapat disetel dalam semua bidang logis independen.</u> <br><br><h4>  Eksperimen dengan data nyata </h4><br>  Tabel <i>perdagangan</i> , total 278.479.918 baris, data dari salah satu loop tes. <br>  Hasil beberapa kueri dalam tabel di bawah: <br><br><div class="scrollable-table"><table><tbody><tr><th>  N </th><th>  Minta </th><th>  Jumlah baris sebagai hasilnya </th><th>  Baca halaman </th></tr><tr><td>  1 </td><td align="right">  Diproses == 0 &amp;&amp; NullStatus == 0 </td><td align="right">  6,273 </td><td align="right">  9 </td></tr><tr><td>  2 </td><td align="right">  IsProcessed == 0 &amp;&amp; NullStatus == 0 &amp;&amp; IsCoverage == 0 </td><td align="right">  6,273 </td><td align="right">  9 </td></tr><tr><td>  3 </td><td align="right">  IsCoverage == 1 &amp;&amp; QF_ICEBERG == 1 </td><td align="right">  1 388 128 </td><td align="right">  386 </td></tr><tr><td>  4 </td><td align="right">  PutStatus == 1 &amp;&amp; PayStatus == 0 </td><td align="right">  61 788 376 </td><td align="right">  16.486 </td></tr><tr><td>  5 </td><td align="right">  Diproses == 1 &amp;&amp; NullStatus == 0 &amp;&amp; <br>  QF_CURR_PFI == 0 &amp;&amp; QF_TERMINATION == 0 </td><td align="right">  278 473 645 </td><td align="right">  74.285 </td></tr><tr><td>  6 </td><td align="right">  Diproses == 1 &amp;&amp; PutStatus == 0 &amp;&amp; <br>  IsCoverage == 1 <br></td><td align="right">  1 650 240 </td><td align="right">  447 </td></tr><tr><td>  7 </td><td align="right">  QF_UNK3 == 0 &amp;&amp; QF_UNK4 == 0 </td><td align="right">  23.392 </td><td align="right">  19 </td></tr></tbody></table></div><br>  Membaca / memproses satu halaman membutuhkan rata-rata 0,8 ms. <br><br>  Tidak perlu mendeskripsikan arti dari pertanyaan spesifik, mereka di sini hanya untuk menunjukkan operabilitas.  Omong-omong, yang dikonfirmasi. <br><br>  Tetapi sebelum teknik ini dapat digunakan secara praktis, masih banyak yang harus dilakukan.  Jadi, untuk dilanjutkan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483056/">https://habr.com/ru/post/id483056/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483042/index.html">9 Tips Kinerja Vue</a></li>
<li><a href="../id483048/index.html">Terminal Fun: 10 lelucon klasik</a></li>
<li><a href="../id483050/index.html">5 Perusahaan Pengembangan Top ReactJS</a></li>
<li><a href="../id483052/index.html">Piramida bukannya bola: pengelompokan atom emas yang tidak standar</a></li>
<li><a href="../id483054/index.html">“There Will Be No No Massacre” - kisah terjemahan The Worm</a></li>
<li><a href="../id483058/index.html">Hasil Survei Liburan</a></li>
<li><a href="../id483064/index.html">Vue untuk blog kecil alias terkecil di semua kanon</a></li>
<li><a href="../id483066/index.html">The 5 Buku Tradisional oleh Bill Gates</a></li>
<li><a href="../id483068/index.html">Membalikkan rekayasa BattlEye anti-cheat populer</a></li>
<li><a href="../id483074/index.html">TensorRT 6.xxx - inferensi kinerja tinggi untuk model pembelajaran dalam (Deteksi Objek dan Segmentasi)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>