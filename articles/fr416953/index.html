<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💯 🛕 👵🏻 Créez un shader d'eau de dessin animé pour le Web. Partie 1 🤰🏻 🦔 👇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans mon tutoriel «Création de shaders», j'ai principalement examiné les shaders de fragments, qui sont suffisants pour implémenter des effets 2D et d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Créez un shader d'eau de dessin animé pour le Web. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416953/"> Dans mon tutoriel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Création de shaders»,</a> j'ai principalement examiné les shaders de fragments, qui sont suffisants pour implémenter des effets 2D et des exemples sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">ShaderToy</a> .  Mais il existe toute une catégorie de techniques qui nécessitent l'utilisation de vertex shaders.  Dans ce didacticiel, je vais parler de la création d'un shader d'eau de dessin animé stylisé et vous présenter les vertex shaders.  Je parlerai également du tampon de profondeur et de la façon de l'utiliser pour obtenir plus d'informations sur la scène et créer des lignes d'écume de mer. <br><br>  Voici à quoi ressemblera l'effet fini.  Une démo interactive peut être vue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">ici</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/58d/814/c3858d814aa8ca99c2c0c58535503482.jpg"></div><br>  Cet effet se compose des éléments suivants: <br><br><ol><li>  Un maillage d'eau translucide avec des polygones subdivisés et des sommets décalés pour créer des vagues. </li><li>  Lignes d'eau statiques à la surface. </li><li>  Flottabilité simulée du bateau. </li><li>  Lignes dynamiques de mousse autour des limites des objets dans l'eau. </li><li>  Post-traitement pour créer une distorsion de tout sous l'eau. </li></ol><br>  Dans cet effet, j'aime le fait qu'il touche à de nombreux concepts différents de l'infographie, il nous permettra donc d'utiliser les idées des didacticiels précédents, ainsi que de développer des techniques qui peuvent être appliquées dans de nouveaux effets. <br><a name="habracut"></a><br>  Dans ce tutoriel, j'utiliserai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">PlayCanvas</a> , simplement parce que c'est un IDE Web gratuit et pratique, mais tout peut être appliqué à n'importe quel autre environnement WebGL sans aucun problème.  À la fin de l'article, la version du code source de Three.js sera présentée.  Nous supposerons que vous connaissez déjà bien les shaders de fragments et l'interface PlayCanvas.  Vous pouvez actualiser vos connaissances sur les shaders <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et vous familiariser avec PlayCanvas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  Réglage de l'environnement </h2><br>  Le but de cette section est de configurer notre projet PlayCanvas et d'y insérer plusieurs objets environnementaux que l'eau influencera. <br><br>  Si vous n'avez pas de compte PlayCanvas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">enregistrez-le</a> et créez un nouveau <strong>projet vierge</strong> .  Par défaut, vous devriez avoir quelques objets dans la scène, une caméra et une source de lumière. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f57/00e/57f/f5700e57f7434006e48831c30378d0df.png"></div><br><h3>  Insérer des modèles </h3><br>  Le projet Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">Poly</a> est une excellente ressource pour trouver des modèles 3D pour le Web.  J'ai pris le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">modèle</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">bateau à</a> partir de là.  Après avoir téléchargé et déballé l'archive, vous y trouverez des fichiers <code>.obj</code> et <code>.png</code> . <br><br><ol><li>  Faites glisser les deux fichiers dans la fenêtre Actifs du projet PlayCanvas. </li><li>  Sélectionnez le matériau généré automatiquement et sélectionnez le fichier <code>.png</code> comme carte diffuse. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b60/499/7cc/b604997ccaad7c5d0d97a81f6da3be98.png"></div><br>  Vous pouvez maintenant faire glisser <strong>Tugboat.json</strong> dans la scène et supprimer les objets Box et Plane.  Si le bateau semble trop petit, vous pouvez augmenter son échelle (j'ai réglé la valeur à 50). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4c/307/250/c4c30725001beeacf4a2149735f95a1b.png"></div><br>  De même, vous pouvez ajouter d'autres modèles à la scène. <br><br><h3>  Caméra en orbite </h3><br>  Pour configurer la caméra volant en orbite, nous allons copier le script de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">cet exemple PlayCanvas</a> .  Suivez le lien et cliquez sur <strong>Editeur</strong> pour ouvrir le projet. <br><br><ol><li>  Copiez le contenu de <code>mouse-input.js</code> et <code>orbit-camera.js</code> de ce projet de didacticiel dans des fichiers portant les mêmes noms que ceux de votre projet. </li><li>  Ajoutez un composant <strong>Script</strong> à la caméra. </li><li>  Attachez deux scripts à la caméra. </li></ol><br><blockquote>  <em>Astuce: pour organiser le projet, vous pouvez créer des dossiers dans la fenêtre Actifs.</em>  <em>J'ai mis ces deux scripts de caméra dans le dossier Scripts / Camera /, mon modèle dans Models / et le matériel dans le dossier Materials /.</em> </blockquote><br>  Maintenant, lorsque vous démarrez le jeu (le bouton de lancement dans la partie supérieure droite de la fenêtre de la scène), vous devriez voir un bateau que vous pouvez inspecter avec une caméra en le déplaçant en orbite avec la souris. <br><br><h2>  Division du polygone de surface de l'eau </h2><br>  Le but de cette section est de créer un maillage subdivisé qui sera utilisé comme surface de l'eau. <br><br>  Pour créer une surface d'eau, nous adaptons une partie du code du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">tutoriel de génération de relief</a> .  Créez un nouveau <code>Water.js</code> script <code>Water.js</code> .  Ouvrez ce script pour le modifier et créez une nouvelle fonction <code>GeneratePlaneMesh</code> qui ressemblera à ceci: <br><br><pre> <code class="javascript hljs">Water.prototype.GeneratePlaneMesh = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1 -    ,     if(options === undefined) options = {subdivisions:100, width:10, height:10}; // 2 -  , UV   var positions = []; var uvs = []; var indices = []; var row, col; var normals; for (row = 0; row &lt;= options.subdivisions; row++) { for (col = 0; col &lt;= options.subdivisions; col++) { var position = new pc.Vec3((col * options.width) / options.subdivisions - (options.width / 2.0), 0, ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0)); positions.push(position.x, position.y, position.z); uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions); } } for (row = 0; row &lt; options.subdivisions; row++) { for (col = 0; col &lt; options.subdivisions; col++) { indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + (row + 1) * (options.subdivisions + 1)); } } //   normals = pc.calculateNormals(positions, indices); //    var node = new pc.GraphNode(); var material = new pc.StandardMaterial(); //   var mesh = pc.createMesh(this.app.graphicsDevice, positions, { normals: normals, uvs: uvs, indices: indices }); var meshInstance = new pc.MeshInstance(node, mesh, material); //      var model = new pc.Model(); model.graph = node; model.meshInstances.push(meshInstance); this.entity.addComponent('model'); this.entity.model.model = model; this.entity.model.castShadows = false; //   ,       };</span></span></code> </pre> <br>  Maintenant, nous pouvons l'appeler dans la fonction <code>initialize</code> : <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GeneratePlaneMesh({<span class="hljs-attr"><span class="hljs-attr">subdivisions</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">width</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">height</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}); };</code> </pre> <br>  Maintenant, lorsque vous démarrez le jeu, vous ne devriez voir qu'une surface plane.  Mais ce n'est pas seulement une surface plane, c'est un maillage composé de milliers de pics.  Comme exercice, essayez de le vérifier vous-même (c'est une bonne raison d'étudier le code que vous venez de copier). <br><br><blockquote>  <em>Problème 1: décaler la coordonnée Y de chaque sommet d'une valeur aléatoire de sorte que le plan ressemble à la figure ci-dessous.</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/397/111/391/397111391bbb4e1cafd0e658005ed1cc.jpg"></div><br><h2>  Les vagues </h2><br>  Le but de cette section est de désigner la surface de l'eau de votre propre matériel et de créer des vagues animées. <br><br>  Pour obtenir les effets dont nous avons besoin, vous devez configurer votre propre matériel.  La plupart des moteurs 3D ont un ensemble de shaders prédéfinis pour le rendu des objets et un moyen de les redéfinir.  Voici un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">bon lien</a> sur la façon de procéder dans PlayCanvas. <br><br><h3>  Attachement Shader </h3><br>  Créons une nouvelle fonction <code>CreateWaterMaterial</code> qui <code>CreateWaterMaterial</code> nouveau matériau avec un shader modifié et le renvoie: <br><br><pre> <code class="javascript hljs">Water.prototype.CreateWaterMaterial = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     var material = new pc.Material(); //    ,       material.name = "DynamicWater_Material"; //    //        . var gd = this.app.graphicsDevice; var fragmentShader = "precision " + gd.precision + " float;\n"; fragmentShader = fragmentShader + this.fs.resource; var vertexShader = this.vs.resource; //       . var shaderDefinition = { attributes: { aPosition: pc.gfx.SEMANTIC_POSITION, aUv0: pc.SEMANTIC_TEXCOORD0, }, vshader: vertexShader, fshader: fragmentShader }; //     this.shader = new pc.Shader(gd, shaderDefinition); //      material.setShader(this.shader); return material; };</span></span></code> </pre> <br>  Cette fonction prend le vertex et le fragment shader code des attributs de script.  Définissons-les donc en haut du fichier (après la ligne <code>pc.createScript</code> ): <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'vs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Vertex Shader'</span></span> }); Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Fragment Shader'</span></span> });</code> </pre> <br>  Nous pouvons maintenant créer ces fichiers shader et les attacher à notre script.  Retournez dans l'éditeur et créez deux fichiers shader: <strong>Water.frag</strong> et <strong>Water.vert</strong> .  Attachez ces shaders au script comme indiqué dans la figure ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/fa4/d8a/0a2fa4d8a998e8abe1fc63da301f0ad9.png"></div><br>  Si les nouveaux attributs ne sont pas affichés dans l'éditeur, cliquez sur le bouton <strong>Analyser</strong> pour mettre à jour le script. <br><br>  <strong>Collez</strong> maintenant ce shader de base dans <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); gl_FragColor = color; }</code> </pre> <br>  Et celui-ci est dans <strong>Water.vert</strong> : <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Enfin, revenez à <strong>Water.js</strong> pour utiliser notre nouveau matériel au lieu du matériel standard.  Autrement dit, au lieu de: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pc.StandardMaterial();</code> </pre> <br>  insérer: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CreateWaterMaterial();</code> </pre> <br>  Maintenant, après avoir commencé le jeu, l'avion doit être bleu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e79/797/8ff/e797978ff286ff2f15b3b8465debf767.png"></div><br><h3>  Redémarrage à chaud </h3><br>  Pour l'instant, nous venons de mettre en place des flans de shader pour notre nouveau matériau.  Avant de commencer à écrire des effets réels, je souhaite configurer le rechargement automatique du code. <br><br>  Après avoir décommenté la fonction d' <code>swap</code> dans n'importe quel fichier de script (par exemple, dans Water.js), nous activerons le rechargement à chaud.  Plus tard, nous verrons comment l'utiliser pour maintenir l'état même lors de la mise à jour du code en temps réel.  Mais pour l'instant, nous voulons simplement réappliquer les shaders après avoir apporté les modifications.  Avant de s'exécuter dans WebGL, les shaders sont compilés, donc pour ce faire, nous devons recréer notre matériel. <br><br>  Nous vérifierons si le contenu de notre code shader a changé, et si c'est le cas, recréer le matériel.  Tout d'abord, enregistrez les shaders actuels dans <strong>initialize</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  initialize,       Water.prototype.initialize = function() { this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br>  Et dans la <strong>mise</strong> à <strong>jour,</strong> nous vérifions si des changements sont survenus: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  update,     Water.prototype.update = function(dt) { if(this.savedFS != this.fs.resource || this.savedVS != this.vs.resource){ //   ,      var newMaterial = this.CreateWaterMaterial(); //     var model = this.entity.model.model; model.meshInstances[0].material = newMaterial; //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; } };</span></span></code> </pre> <br>  Maintenant, pour vous assurer que cela fonctionne, démarrez le jeu et changez la couleur de l'avion dans <strong>Water.frag</strong> en un bleu plus agréable.  Après avoir enregistré le fichier, il doit être mis à jour même sans redémarrage et redémarrez!  Voici la couleur que j'ai choisie: <br><br><pre> <code class="javascript hljs">vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>);</code> </pre> <br><h4>  Vertex Shaders </h4><br>  Pour créer des vagues, nous devons déplacer chaque sommet de notre maillage dans chaque image.  Il semble que ce sera très inefficace, mais chaque sommet de chaque modèle est déjà transformé dans chaque image rendue.  C'est ce que fait le vertex shader. <br><br>  Si nous percevons un fragment shader comme une fonction qui est exécutée pour chaque pixel, obtient sa position et renvoie la couleur, alors un <em>vertex shader est une fonction qui s'exécute pour chaque sommet, obtient sa position et renvoie sa position</em> . <br><br>  Un vertex shader obtient par défaut une <em>position dans le monde du</em> modèle et renvoie sa <em>position à l'écran</em> .  Notre scène 3D est définie en coordonnées x, y et z, mais le moniteur est un plan plat à deux dimensions, nous projetons donc un monde 3D sur un écran 2D.  Les matrices du type, de la projection et du modèle sont impliquées dans une telle projection, nous ne la considérerons donc pas dans ce tutoriel.  Mais si vous voulez comprendre ce qui se passe exactement à chaque étape, voici un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">très bon guide</a> . <br><br>  Autrement dit, cette ligne: <br><br><pre> <code class="javascript hljs">gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  reçoit <code>aPosition</code> comme position dans le monde 3D d'un sommet particulier et le convertit en <code>gl_Position</code> , c'est-à-dire en position finale sur l'écran 2D.  Le préfixe «a» dans aPosition indique que cette valeur est un <em>attribut</em> .  N'oubliez pas que l' <em>uniforme</em> variable est une valeur que nous pouvons définir dans le CPU et la transmettre au shader.  Il conserve la même valeur pour tous les pixels / sommets.  D'un autre côté, la valeur d'attribut est obtenue à partir du <em>tableau</em> CPU spécifié.  Un vertex shader est appelé pour chaque valeur de ce tableau d'attributs. <br><br>  Vous pouvez voir que ces attributs sont configurés dans la définition de shader que nous avons définie dans Water.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shaderDefinition = { <span class="hljs-attr"><span class="hljs-attr">attributes</span></span>: { <span class="hljs-attr"><span class="hljs-attr">aPosition</span></span>: pc.gfx.SEMANTIC_POSITION, <span class="hljs-attr"><span class="hljs-attr">aUv0</span></span>: pc.SEMANTIC_TEXCOORD0, }, <span class="hljs-attr"><span class="hljs-attr">vshader</span></span>: vertexShader, <span class="hljs-attr"><span class="hljs-attr">fshader</span></span>: fragmentShader };</code> </pre> <br>  PlayCanvas prend soin de configurer et de transmettre un tableau de positions de vertex pour une position lors du passage de cette énumération, mais dans le cas général, nous pouvons transmettre n'importe quel tableau de données au vertex shader. <br><br><h3>  Mouvement du sommet </h3><br>  Supposons que nous voulons compresser tout le plan en multipliant toutes les valeurs <code>x</code> par 0,5.  Faut-il changer <code>aPosition</code> ou <code>gl_Position</code> ? <br><br>  Essayons d'abord <code>aPosition</code> .  Nous ne pouvons pas changer l'attribut directement, mais nous pouvons créer une copie: <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; pos.x *= <span class="hljs-number"><span class="hljs-number">0.5</span></span>; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  L'avion devrait maintenant ressembler davantage à un rectangle.  Et cela n'a rien d'étrange.  Mais que se passe-t-il si nous essayons de changer <code>gl_Position</code> ? <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; <span class="hljs-comment"><span class="hljs-comment">//pos.x *= 0.5; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, 1.0); gl_Position.x *= 0.5; }</span></span></code> </pre> <br>  Jusqu'à ce que vous commenciez à déplacer la caméra, elle peut avoir la même apparence.  Nous changeons les coordonnées de l'espace d'écran, c'est-à-dire que l'image dépendra de la <em>façon dont nous la regardons</em> . <br><br>  Nous pouvons donc déplacer les sommets, et en même temps, il est important de faire la distinction entre le travail dans les espaces univers et écran. <br><br><blockquote>  <em>Tâche 2: pouvez-vous déplacer la surface entière du plan de plusieurs unités vers le haut (le long de l'axe Y) dans le vertex shader sans déformer sa forme?</em> </blockquote><br><blockquote>  <em>Tâche 3: J'ai dit que gl_Position est bidimensionnelle, mais gl_Position.z existe également.</em>  <em>Pouvez-vous vérifier si cette valeur affecte quelque chose, et si oui, à quoi sert-elle?</em> </blockquote><br><h3>  Ajouter du temps </h3><br>  La dernière chose dont nous avons besoin avant de commencer à créer des ondes en mouvement est une variable uniforme qui peut être utilisée comme temps.  Déclarez l'uniforme dans le vertex shader: <br><br><pre> <code class="javascript hljs">uniform float uTime;</code> </pre> <br>  Maintenant, pour le passer au shader, <strong>revenons</strong> à <strong>Water.js</strong> et définissons la variable de temps dans initialize: <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/////     this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br>  Maintenant, pour transférer la variable dans le shader, nous utilisons <code>material.setParameter</code> .  Tout d'abord, nous définissons la valeur initiale à la fin de la fonction <code>CreateWaterMaterial</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     this.shader = new pc.Shader(gd, shaderDefinition); //////////////   material.setParameter('uTime',this.time); this.material = material; //      //////////////// //      material.setShader(this.shader); return material;</span></span></code> </pre> <br>  Maintenant, dans la fonction de <code>update</code> , nous pouvons effectuer un incrément de temps et accéder au matériel en utilisant le lien créé pour cela: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.material.setParameter(<span class="hljs-string"><span class="hljs-string">'uTime'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time);</code> </pre> <br>  Enfin, dans la fonction swap, nous copions l'ancienne valeur de temps de sorte que même après avoir changé le code, elle continue d'augmenter sans réinitialiser à 0. <br><br><pre> <code class="javascript hljs">Water.prototype.swap = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">old</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = old.time; };</code> </pre> <br>  Maintenant, tout est prêt.  Exécutez le jeu pour vous assurer qu'il n'y a pas d'erreur.  Maintenant, déplaçons notre avion en utilisant la fonction de temps dans <code>Water.vert</code> : <br><br><pre> <code class="javascript hljs">pos.y += cos(uTime)</code> </pre> <br>  Et notre avion devrait commencer à monter et descendre!  Puisque nous avons maintenant une fonction d'échange, nous pouvons également mettre à jour Water.js sans avoir à redémarrer.  Pour vous assurer que cela fonctionne, essayez de modifier l'incrément de temps. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/9fe/64a/ae99fe64ab5d40e47e3760ac1dae1dd7.gif"></div><br><blockquote>  <em>Tâche 4: pouvez-vous déplacer les sommets pour qu'ils ressemblent aux vagues de la figure ci-dessous?</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1be/c55/056/1bec55056dc955769178773c2d58fe7c.gif"></div><br>  Permettez-moi de vous dire que j'ai examiné en détail le sujet des différentes façons de créer des vagues <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">ici</a> .  L'article est lié à la 2D, mais les calculs mathématiques sont applicables à notre cas.  Si vous voulez juste voir la solution, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">voici l'essentiel</a> . <br><br><h2>  Translucidité </h2><br>  Le but de cette section est de créer une surface d'eau translucide. <br><br>  Vous pouvez remarquer que la couleur renvoyée à Water.frag a une valeur de canal alpha de 0,5, mais la surface reste toujours opaque.  Dans de nombreux cas, la transparence devient toujours un problème non résolu en infographie.  Un moyen peu coûteux de le résoudre est d'utiliser le mélange. <br><br>  Habituellement, avant de dessiner un pixel, il vérifie la valeur dans le <em>tampon de profondeur</em> et la compare à sa propre valeur de profondeur (sa position le long de l'axe Z) pour déterminer s'il faut redessiner ou non le pixel d'écran actuel.  C'est ce qui vous permet de rendre la scène correctement sans avoir à trier les objets de l'arrière vers l'avant. <br><br>  Lors du mixage, au lieu de simplement rejeter le pixel ou l'écraser, nous pouvons combiner la couleur du pixel déjà rendu (cible) avec le pixel que nous allons dessiner (la source).  Une liste de toutes les fonctions de mixage disponibles dans WebGL peut être trouvée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">ici</a> . <br><br>  Pour que le canal alpha fonctionne conformément à nos attentes, nous voulons que la couleur combinée du résultat soit une source multipliée par un canal alpha plus un pixel de destination multiplié par un moins alpha.  En d'autres termes, si alpha = 0,4, alors la couleur finale doit avoir une valeur: <br><br><pre> <code class="javascript hljs">finalColor = source * <span class="hljs-number"><span class="hljs-number">0.4</span></span> + destination * <span class="hljs-number"><span class="hljs-number">0.6</span></span>;</code> </pre> <br>  Dans PlayCanvas, c'est l'opération que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">pc.BLEND_NORMAL effectue</a> . <br><br>  Pour l'activer, définissez simplement la propriété du matériau dans <code>CreateWaterMaterial</code> : <br><br><pre> <code class="javascript hljs">material.blendType = pc.BLEND_NORMAL;</code> </pre> <br>  Si vous commencez maintenant le jeu, l'eau deviendra translucide!  Cependant, il est encore imparfait.  Le problème se pose lorsque la surface translucide se superpose à elle-même, comme illustré ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/6b0/653/6df6b0653c6a86a4cd5d8b0500e22f04.png"></div><br>  Nous pouvons l'éliminer en utilisant l' <em>alpha à la couverture</em> , une technique de multi-échantillonnage pour la transparence, au lieu de mélanger: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//material.blendType = pc.BLEND_NORMAL; material.alphaToCoverage = true;</span></span></code> </pre> <br>  Mais il n'est disponible que dans WebGL 2. Dans la suite du tutoriel, par souci de simplicité, je vais utiliser le mixage. <br><br><h2>  Pour résumer </h2><br>  Nous avons mis en place l'environnement et créé une surface translucide de l'eau avec des ondes animées du vertex shader.  Dans la deuxième partie du didacticiel, nous examinerons la flottabilité des objets, ajouterons des lignes à la surface de l'eau et créerons des lignes de mousse le long des limites des objets se croisant avec la surface. <br><br>  Dans la troisième (dernière) partie, nous examinerons l'application de l'effet de post-traitement des distorsions sous-marines et examinerons des idées d'amélioration. <br><br><h2>  Code source </h2><br>  Le projet PlayCanvas terminé peut être trouvé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">ici</a> .  Notre référentiel possède également un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">port de projet sous Three.js</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416953/">https://habr.com/ru/post/fr416953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416943/index.html">Matériaux utiles pour la conception d'interfaces vocales</a></li>
<li><a href="../fr416945/index.html">Comme nous l'avons fait pour BelAZ. Partie 1 - Fer</a></li>
<li><a href="../fr416947/index.html">Jouez le jeu avant les Jeux olympiques: l'eSport devient officiel</a></li>
<li><a href="../fr416949/index.html">La mise à niveau à grande échelle de M. Steven pour installer un réseau de chasse quadruplé est terminée</a></li>
<li><a href="../fr416951/index.html">Clusters Kubernetes dans le service VPC</a></li>
<li><a href="../fr416955/index.html">Petits trucs avec Elasticsearch</a></li>
<li><a href="../fr416957/index.html">Quelle machine laser acheter? Examen fiable de la machine laser Raylogic 11G</a></li>
<li><a href="../fr416959/index.html">Apple présente une nouvelle fonctionnalité antivol iOS</a></li>
<li><a href="../fr416961/index.html">Résolution automatique des conflits à l'aide de transformations opérationnelles</a></li>
<li><a href="../fr416963/index.html">Comme nous l'avons fait pour BelAZ. Partie 2 - Tests de laboratoire</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>