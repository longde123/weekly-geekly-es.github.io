<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíØ üõï üëµüèª Cr√©ez un shader d'eau de dessin anim√© pour le Web. Partie 1 ü§∞üèª ü¶î üëá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans mon tutoriel ¬´Cr√©ation de shaders¬ª, j'ai principalement examin√© les shaders de fragments, qui sont suffisants pour impl√©menter des effets 2D et d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ez un shader d'eau de dessin anim√© pour le Web. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416953/"> Dans mon tutoriel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Cr√©ation de shaders¬ª,</a> j'ai principalement examin√© les shaders de fragments, qui sont suffisants pour impl√©menter des effets 2D et des exemples sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">ShaderToy</a> .  Mais il existe toute une cat√©gorie de techniques qui n√©cessitent l'utilisation de vertex shaders.  Dans ce didacticiel, je vais parler de la cr√©ation d'un shader d'eau de dessin anim√© stylis√© et vous pr√©senter les vertex shaders.  Je parlerai √©galement du tampon de profondeur et de la fa√ßon de l'utiliser pour obtenir plus d'informations sur la sc√®ne et cr√©er des lignes d'√©cume de mer. <br><br>  Voici √† quoi ressemblera l'effet fini.  Une d√©mo interactive peut √™tre vue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">ici</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/58d/814/c3858d814aa8ca99c2c0c58535503482.jpg"></div><br>  Cet effet se compose des √©l√©ments suivants: <br><br><ol><li>  Un maillage d'eau translucide avec des polygones subdivis√©s et des sommets d√©cal√©s pour cr√©er des vagues. </li><li>  Lignes d'eau statiques √† la surface. </li><li>  Flottabilit√© simul√©e du bateau. </li><li>  Lignes dynamiques de mousse autour des limites des objets dans l'eau. </li><li>  Post-traitement pour cr√©er une distorsion de tout sous l'eau. </li></ol><br>  Dans cet effet, j'aime le fait qu'il touche √† de nombreux concepts diff√©rents de l'infographie, il nous permettra donc d'utiliser les id√©es des didacticiels pr√©c√©dents, ainsi que de d√©velopper des techniques qui peuvent √™tre appliqu√©es dans de nouveaux effets. <br><a name="habracut"></a><br>  Dans ce tutoriel, j'utiliserai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">PlayCanvas</a> , simplement parce que c'est un IDE Web gratuit et pratique, mais tout peut √™tre appliqu√© √† n'importe quel autre environnement WebGL sans aucun probl√®me.  √Ä la fin de l'article, la version du code source de Three.js sera pr√©sent√©e.  Nous supposerons que vous connaissez d√©j√† bien les shaders de fragments et l'interface PlayCanvas.  Vous pouvez actualiser vos connaissances sur les shaders <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et vous familiariser avec PlayCanvas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  R√©glage de l'environnement </h2><br>  Le but de cette section est de configurer notre projet PlayCanvas et d'y ins√©rer plusieurs objets environnementaux que l'eau influencera. <br><br>  Si vous n'avez pas de compte PlayCanvas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">enregistrez-le</a> et cr√©ez un nouveau <strong>projet vierge</strong> .  Par d√©faut, vous devriez avoir quelques objets dans la sc√®ne, une cam√©ra et une source de lumi√®re. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f57/00e/57f/f5700e57f7434006e48831c30378d0df.png"></div><br><h3>  Ins√©rer des mod√®les </h3><br>  Le projet Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">Poly</a> est une excellente ressource pour trouver des mod√®les 3D pour le Web.  J'ai pris le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">mod√®le</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">bateau √†</a> partir de l√†.  Apr√®s avoir t√©l√©charg√© et d√©ball√© l'archive, vous y trouverez des fichiers <code>.obj</code> et <code>.png</code> . <br><br><ol><li>  Faites glisser les deux fichiers dans la fen√™tre Actifs du projet PlayCanvas. </li><li>  S√©lectionnez le mat√©riau g√©n√©r√© automatiquement et s√©lectionnez le fichier <code>.png</code> comme carte diffuse. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b60/499/7cc/b604997ccaad7c5d0d97a81f6da3be98.png"></div><br>  Vous pouvez maintenant faire glisser <strong>Tugboat.json</strong> dans la sc√®ne et supprimer les objets Box et Plane.  Si le bateau semble trop petit, vous pouvez augmenter son √©chelle (j'ai r√©gl√© la valeur √† 50). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4c/307/250/c4c30725001beeacf4a2149735f95a1b.png"></div><br>  De m√™me, vous pouvez ajouter d'autres mod√®les √† la sc√®ne. <br><br><h3>  Cam√©ra en orbite </h3><br>  Pour configurer la cam√©ra volant en orbite, nous allons copier le script de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">cet exemple PlayCanvas</a> .  Suivez le lien et cliquez sur <strong>Editeur</strong> pour ouvrir le projet. <br><br><ol><li>  Copiez le contenu de <code>mouse-input.js</code> et <code>orbit-camera.js</code> de ce projet de didacticiel dans des fichiers portant les m√™mes noms que ceux de votre projet. </li><li>  Ajoutez un composant <strong>Script</strong> √† la cam√©ra. </li><li>  Attachez deux scripts √† la cam√©ra. </li></ol><br><blockquote>  <em>Astuce: pour organiser le projet, vous pouvez cr√©er des dossiers dans la fen√™tre Actifs.</em>  <em>J'ai mis ces deux scripts de cam√©ra dans le dossier Scripts / Camera /, mon mod√®le dans Models / et le mat√©riel dans le dossier Materials /.</em> </blockquote><br>  Maintenant, lorsque vous d√©marrez le jeu (le bouton de lancement dans la partie sup√©rieure droite de la fen√™tre de la sc√®ne), vous devriez voir un bateau que vous pouvez inspecter avec une cam√©ra en le d√©pla√ßant en orbite avec la souris. <br><br><h2>  Division du polygone de surface de l'eau </h2><br>  Le but de cette section est de cr√©er un maillage subdivis√© qui sera utilis√© comme surface de l'eau. <br><br>  Pour cr√©er une surface d'eau, nous adaptons une partie du code du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">tutoriel de g√©n√©ration de relief</a> .  Cr√©ez un nouveau <code>Water.js</code> script <code>Water.js</code> .  Ouvrez ce script pour le modifier et cr√©ez une nouvelle fonction <code>GeneratePlaneMesh</code> qui ressemblera √† ceci: <br><br><pre> <code class="javascript hljs">Water.prototype.GeneratePlaneMesh = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1 -    ,     if(options === undefined) options = {subdivisions:100, width:10, height:10}; // 2 -  , UV   var positions = []; var uvs = []; var indices = []; var row, col; var normals; for (row = 0; row &lt;= options.subdivisions; row++) { for (col = 0; col &lt;= options.subdivisions; col++) { var position = new pc.Vec3((col * options.width) / options.subdivisions - (options.width / 2.0), 0, ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0)); positions.push(position.x, position.y, position.z); uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions); } } for (row = 0; row &lt; options.subdivisions; row++) { for (col = 0; col &lt; options.subdivisions; col++) { indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + (row + 1) * (options.subdivisions + 1)); } } //   normals = pc.calculateNormals(positions, indices); //    var node = new pc.GraphNode(); var material = new pc.StandardMaterial(); //   var mesh = pc.createMesh(this.app.graphicsDevice, positions, { normals: normals, uvs: uvs, indices: indices }); var meshInstance = new pc.MeshInstance(node, mesh, material); //      var model = new pc.Model(); model.graph = node; model.meshInstances.push(meshInstance); this.entity.addComponent('model'); this.entity.model.model = model; this.entity.model.castShadows = false; //   ,       };</span></span></code> </pre> <br>  Maintenant, nous pouvons l'appeler dans la fonction <code>initialize</code> : <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GeneratePlaneMesh({<span class="hljs-attr"><span class="hljs-attr">subdivisions</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">width</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">height</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}); };</code> </pre> <br>  Maintenant, lorsque vous d√©marrez le jeu, vous ne devriez voir qu'une surface plane.  Mais ce n'est pas seulement une surface plane, c'est un maillage compos√© de milliers de pics.  Comme exercice, essayez de le v√©rifier vous-m√™me (c'est une bonne raison d'√©tudier le code que vous venez de copier). <br><br><blockquote>  <em>Probl√®me 1: d√©caler la coordonn√©e Y de chaque sommet d'une valeur al√©atoire de sorte que le plan ressemble √† la figure ci-dessous.</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/397/111/391/397111391bbb4e1cafd0e658005ed1cc.jpg"></div><br><h2>  Les vagues </h2><br>  Le but de cette section est de d√©signer la surface de l'eau de votre propre mat√©riel et de cr√©er des vagues anim√©es. <br><br>  Pour obtenir les effets dont nous avons besoin, vous devez configurer votre propre mat√©riel.  La plupart des moteurs 3D ont un ensemble de shaders pr√©d√©finis pour le rendu des objets et un moyen de les red√©finir.  Voici un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">bon lien</a> sur la fa√ßon de proc√©der dans PlayCanvas. <br><br><h3>  Attachement Shader </h3><br>  Cr√©ons une nouvelle fonction <code>CreateWaterMaterial</code> qui <code>CreateWaterMaterial</code> nouveau mat√©riau avec un shader modifi√© et le renvoie: <br><br><pre> <code class="javascript hljs">Water.prototype.CreateWaterMaterial = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     var material = new pc.Material(); //    ,       material.name = "DynamicWater_Material"; //    //        . var gd = this.app.graphicsDevice; var fragmentShader = "precision " + gd.precision + " float;\n"; fragmentShader = fragmentShader + this.fs.resource; var vertexShader = this.vs.resource; //       . var shaderDefinition = { attributes: { aPosition: pc.gfx.SEMANTIC_POSITION, aUv0: pc.SEMANTIC_TEXCOORD0, }, vshader: vertexShader, fshader: fragmentShader }; //     this.shader = new pc.Shader(gd, shaderDefinition); //      material.setShader(this.shader); return material; };</span></span></code> </pre> <br>  Cette fonction prend le vertex et le fragment shader code des attributs de script.  D√©finissons-les donc en haut du fichier (apr√®s la ligne <code>pc.createScript</code> ): <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'vs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Vertex Shader'</span></span> }); Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Fragment Shader'</span></span> });</code> </pre> <br>  Nous pouvons maintenant cr√©er ces fichiers shader et les attacher √† notre script.  Retournez dans l'√©diteur et cr√©ez deux fichiers shader: <strong>Water.frag</strong> et <strong>Water.vert</strong> .  Attachez ces shaders au script comme indiqu√© dans la figure ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/fa4/d8a/0a2fa4d8a998e8abe1fc63da301f0ad9.png"></div><br>  Si les nouveaux attributs ne sont pas affich√©s dans l'√©diteur, cliquez sur le bouton <strong>Analyser</strong> pour mettre √† jour le script. <br><br>  <strong>Collez</strong> maintenant ce shader de base dans <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); gl_FragColor = color; }</code> </pre> <br>  Et celui-ci est dans <strong>Water.vert</strong> : <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Enfin, revenez √† <strong>Water.js</strong> pour utiliser notre nouveau mat√©riel au lieu du mat√©riel standard.  Autrement dit, au lieu de: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pc.StandardMaterial();</code> </pre> <br>  ins√©rer: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CreateWaterMaterial();</code> </pre> <br>  Maintenant, apr√®s avoir commenc√© le jeu, l'avion doit √™tre bleu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e79/797/8ff/e797978ff286ff2f15b3b8465debf767.png"></div><br><h3>  Red√©marrage √† chaud </h3><br>  Pour l'instant, nous venons de mettre en place des flans de shader pour notre nouveau mat√©riau.  Avant de commencer √† √©crire des effets r√©els, je souhaite configurer le rechargement automatique du code. <br><br>  Apr√®s avoir d√©comment√© la fonction d' <code>swap</code> dans n'importe quel fichier de script (par exemple, dans Water.js), nous activerons le rechargement √† chaud.  Plus tard, nous verrons comment l'utiliser pour maintenir l'√©tat m√™me lors de la mise √† jour du code en temps r√©el.  Mais pour l'instant, nous voulons simplement r√©appliquer les shaders apr√®s avoir apport√© les modifications.  Avant de s'ex√©cuter dans WebGL, les shaders sont compil√©s, donc pour ce faire, nous devons recr√©er notre mat√©riel. <br><br>  Nous v√©rifierons si le contenu de notre code shader a chang√©, et si c'est le cas, recr√©er le mat√©riel.  Tout d'abord, enregistrez les shaders actuels dans <strong>initialize</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  initialize,       Water.prototype.initialize = function() { this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br>  Et dans la <strong>mise</strong> √† <strong>jour,</strong> nous v√©rifions si des changements sont survenus: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  update,     Water.prototype.update = function(dt) { if(this.savedFS != this.fs.resource || this.savedVS != this.vs.resource){ //   ,      var newMaterial = this.CreateWaterMaterial(); //     var model = this.entity.model.model; model.meshInstances[0].material = newMaterial; //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; } };</span></span></code> </pre> <br>  Maintenant, pour vous assurer que cela fonctionne, d√©marrez le jeu et changez la couleur de l'avion dans <strong>Water.frag</strong> en un bleu plus agr√©able.  Apr√®s avoir enregistr√© le fichier, il doit √™tre mis √† jour m√™me sans red√©marrage et red√©marrez!  Voici la couleur que j'ai choisie: <br><br><pre> <code class="javascript hljs">vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>);</code> </pre> <br><h4>  Vertex Shaders </h4><br>  Pour cr√©er des vagues, nous devons d√©placer chaque sommet de notre maillage dans chaque image.  Il semble que ce sera tr√®s inefficace, mais chaque sommet de chaque mod√®le est d√©j√† transform√© dans chaque image rendue.  C'est ce que fait le vertex shader. <br><br>  Si nous percevons un fragment shader comme une fonction qui est ex√©cut√©e pour chaque pixel, obtient sa position et renvoie la couleur, alors un <em>vertex shader est une fonction qui s'ex√©cute pour chaque sommet, obtient sa position et renvoie sa position</em> . <br><br>  Un vertex shader obtient par d√©faut une <em>position dans le monde du</em> mod√®le et renvoie sa <em>position √† l'√©cran</em> .  Notre sc√®ne 3D est d√©finie en coordonn√©es x, y et z, mais le moniteur est un plan plat √† deux dimensions, nous projetons donc un monde 3D sur un √©cran 2D.  Les matrices du type, de la projection et du mod√®le sont impliqu√©es dans une telle projection, nous ne la consid√©rerons donc pas dans ce tutoriel.  Mais si vous voulez comprendre ce qui se passe exactement √† chaque √©tape, voici un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">tr√®s bon guide</a> . <br><br>  Autrement dit, cette ligne: <br><br><pre> <code class="javascript hljs">gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  re√ßoit <code>aPosition</code> comme position dans le monde 3D d'un sommet particulier et le convertit en <code>gl_Position</code> , c'est-√†-dire en position finale sur l'√©cran 2D.  Le pr√©fixe ¬´a¬ª dans aPosition indique que cette valeur est un <em>attribut</em> .  N'oubliez pas que l' <em>uniforme</em> variable est une valeur que nous pouvons d√©finir dans le CPU et la transmettre au shader.  Il conserve la m√™me valeur pour tous les pixels / sommets.  D'un autre c√¥t√©, la valeur d'attribut est obtenue √† partir du <em>tableau</em> CPU sp√©cifi√©.  Un vertex shader est appel√© pour chaque valeur de ce tableau d'attributs. <br><br>  Vous pouvez voir que ces attributs sont configur√©s dans la d√©finition de shader que nous avons d√©finie dans Water.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shaderDefinition = { <span class="hljs-attr"><span class="hljs-attr">attributes</span></span>: { <span class="hljs-attr"><span class="hljs-attr">aPosition</span></span>: pc.gfx.SEMANTIC_POSITION, <span class="hljs-attr"><span class="hljs-attr">aUv0</span></span>: pc.SEMANTIC_TEXCOORD0, }, <span class="hljs-attr"><span class="hljs-attr">vshader</span></span>: vertexShader, <span class="hljs-attr"><span class="hljs-attr">fshader</span></span>: fragmentShader };</code> </pre> <br>  PlayCanvas prend soin de configurer et de transmettre un tableau de positions de vertex pour une position lors du passage de cette √©num√©ration, mais dans le cas g√©n√©ral, nous pouvons transmettre n'importe quel tableau de donn√©es au vertex shader. <br><br><h3>  Mouvement du sommet </h3><br>  Supposons que nous voulons compresser tout le plan en multipliant toutes les valeurs <code>x</code> par 0,5.  Faut-il changer <code>aPosition</code> ou <code>gl_Position</code> ? <br><br>  Essayons d'abord <code>aPosition</code> .  Nous ne pouvons pas changer l'attribut directement, mais nous pouvons cr√©er une copie: <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; pos.x *= <span class="hljs-number"><span class="hljs-number">0.5</span></span>; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  L'avion devrait maintenant ressembler davantage √† un rectangle.  Et cela n'a rien d'√©trange.  Mais que se passe-t-il si nous essayons de changer <code>gl_Position</code> ? <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; <span class="hljs-comment"><span class="hljs-comment">//pos.x *= 0.5; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, 1.0); gl_Position.x *= 0.5; }</span></span></code> </pre> <br>  Jusqu'√† ce que vous commenciez √† d√©placer la cam√©ra, elle peut avoir la m√™me apparence.  Nous changeons les coordonn√©es de l'espace d'√©cran, c'est-√†-dire que l'image d√©pendra de la <em>fa√ßon dont nous la regardons</em> . <br><br>  Nous pouvons donc d√©placer les sommets, et en m√™me temps, il est important de faire la distinction entre le travail dans les espaces univers et √©cran. <br><br><blockquote>  <em>T√¢che 2: pouvez-vous d√©placer la surface enti√®re du plan de plusieurs unit√©s vers le haut (le long de l'axe Y) dans le vertex shader sans d√©former sa forme?</em> </blockquote><br><blockquote>  <em>T√¢che 3: J'ai dit que gl_Position est bidimensionnelle, mais gl_Position.z existe √©galement.</em>  <em>Pouvez-vous v√©rifier si cette valeur affecte quelque chose, et si oui, √† quoi sert-elle?</em> </blockquote><br><h3>  Ajouter du temps </h3><br>  La derni√®re chose dont nous avons besoin avant de commencer √† cr√©er des ondes en mouvement est une variable uniforme qui peut √™tre utilis√©e comme temps.  D√©clarez l'uniforme dans le vertex shader: <br><br><pre> <code class="javascript hljs">uniform float uTime;</code> </pre> <br>  Maintenant, pour le passer au shader, <strong>revenons</strong> √† <strong>Water.js</strong> et d√©finissons la variable de temps dans initialize: <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/////     this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br>  Maintenant, pour transf√©rer la variable dans le shader, nous utilisons <code>material.setParameter</code> .  Tout d'abord, nous d√©finissons la valeur initiale √† la fin de la fonction <code>CreateWaterMaterial</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     this.shader = new pc.Shader(gd, shaderDefinition); //////////////   material.setParameter('uTime',this.time); this.material = material; //      //////////////// //      material.setShader(this.shader); return material;</span></span></code> </pre> <br>  Maintenant, dans la fonction de <code>update</code> , nous pouvons effectuer un incr√©ment de temps et acc√©der au mat√©riel en utilisant le lien cr√©√© pour cela: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.material.setParameter(<span class="hljs-string"><span class="hljs-string">'uTime'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time);</code> </pre> <br>  Enfin, dans la fonction swap, nous copions l'ancienne valeur de temps de sorte que m√™me apr√®s avoir chang√© le code, elle continue d'augmenter sans r√©initialiser √† 0. <br><br><pre> <code class="javascript hljs">Water.prototype.swap = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">old</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = old.time; };</code> </pre> <br>  Maintenant, tout est pr√™t.  Ex√©cutez le jeu pour vous assurer qu'il n'y a pas d'erreur.  Maintenant, d√©pla√ßons notre avion en utilisant la fonction de temps dans <code>Water.vert</code> : <br><br><pre> <code class="javascript hljs">pos.y += cos(uTime)</code> </pre> <br>  Et notre avion devrait commencer √† monter et descendre!  Puisque nous avons maintenant une fonction d'√©change, nous pouvons √©galement mettre √† jour Water.js sans avoir √† red√©marrer.  Pour vous assurer que cela fonctionne, essayez de modifier l'incr√©ment de temps. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/9fe/64a/ae99fe64ab5d40e47e3760ac1dae1dd7.gif"></div><br><blockquote>  <em>T√¢che 4: pouvez-vous d√©placer les sommets pour qu'ils ressemblent aux vagues de la figure ci-dessous?</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1be/c55/056/1bec55056dc955769178773c2d58fe7c.gif"></div><br>  Permettez-moi de vous dire que j'ai examin√© en d√©tail le sujet des diff√©rentes fa√ßons de cr√©er des vagues <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">ici</a> .  L'article est li√© √† la 2D, mais les calculs math√©matiques sont applicables √† notre cas.  Si vous voulez juste voir la solution, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">voici l'essentiel</a> . <br><br><h2>  Translucidit√© </h2><br>  Le but de cette section est de cr√©er une surface d'eau translucide. <br><br>  Vous pouvez remarquer que la couleur renvoy√©e √† Water.frag a une valeur de canal alpha de 0,5, mais la surface reste toujours opaque.  Dans de nombreux cas, la transparence devient toujours un probl√®me non r√©solu en infographie.  Un moyen peu co√ªteux de le r√©soudre est d'utiliser le m√©lange. <br><br>  Habituellement, avant de dessiner un pixel, il v√©rifie la valeur dans le <em>tampon de profondeur</em> et la compare √† sa propre valeur de profondeur (sa position le long de l'axe Z) pour d√©terminer s'il faut redessiner ou non le pixel d'√©cran actuel.  C'est ce qui vous permet de rendre la sc√®ne correctement sans avoir √† trier les objets de l'arri√®re vers l'avant. <br><br>  Lors du mixage, au lieu de simplement rejeter le pixel ou l'√©craser, nous pouvons combiner la couleur du pixel d√©j√† rendu (cible) avec le pixel que nous allons dessiner (la source).  Une liste de toutes les fonctions de mixage disponibles dans WebGL peut √™tre trouv√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">ici</a> . <br><br>  Pour que le canal alpha fonctionne conform√©ment √† nos attentes, nous voulons que la couleur combin√©e du r√©sultat soit une source multipli√©e par un canal alpha plus un pixel de destination multipli√© par un moins alpha.  En d'autres termes, si alpha = 0,4, alors la couleur finale doit avoir une valeur: <br><br><pre> <code class="javascript hljs">finalColor = source * <span class="hljs-number"><span class="hljs-number">0.4</span></span> + destination * <span class="hljs-number"><span class="hljs-number">0.6</span></span>;</code> </pre> <br>  Dans PlayCanvas, c'est l'op√©ration que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">pc.BLEND_NORMAL effectue</a> . <br><br>  Pour l'activer, d√©finissez simplement la propri√©t√© du mat√©riau dans <code>CreateWaterMaterial</code> : <br><br><pre> <code class="javascript hljs">material.blendType = pc.BLEND_NORMAL;</code> </pre> <br>  Si vous commencez maintenant le jeu, l'eau deviendra translucide!  Cependant, il est encore imparfait.  Le probl√®me se pose lorsque la surface translucide se superpose √† elle-m√™me, comme illustr√© ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/6b0/653/6df6b0653c6a86a4cd5d8b0500e22f04.png"></div><br>  Nous pouvons l'√©liminer en utilisant l' <em>alpha √† la couverture</em> , une technique de multi-√©chantillonnage pour la transparence, au lieu de m√©langer: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//material.blendType = pc.BLEND_NORMAL; material.alphaToCoverage = true;</span></span></code> </pre> <br>  Mais il n'est disponible que dans WebGL 2. Dans la suite du tutoriel, par souci de simplicit√©, je vais utiliser le mixage. <br><br><h2>  Pour r√©sumer </h2><br>  Nous avons mis en place l'environnement et cr√©√© une surface translucide de l'eau avec des ondes anim√©es du vertex shader.  Dans la deuxi√®me partie du didacticiel, nous examinerons la flottabilit√© des objets, ajouterons des lignes √† la surface de l'eau et cr√©erons des lignes de mousse le long des limites des objets se croisant avec la surface. <br><br>  Dans la troisi√®me (derni√®re) partie, nous examinerons l'application de l'effet de post-traitement des distorsions sous-marines et examinerons des id√©es d'am√©lioration. <br><br><h2>  Code source </h2><br>  Le projet PlayCanvas termin√© peut √™tre trouv√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">ici</a> .  Notre r√©f√©rentiel poss√®de √©galement un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">port de projet sous Three.js</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416953/">https://habr.com/ru/post/fr416953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416943/index.html">Mat√©riaux utiles pour la conception d'interfaces vocales</a></li>
<li><a href="../fr416945/index.html">Comme nous l'avons fait pour BelAZ. Partie 1 - Fer</a></li>
<li><a href="../fr416947/index.html">Jouez le jeu avant les Jeux olympiques: l'eSport devient officiel</a></li>
<li><a href="../fr416949/index.html">La mise √† niveau √† grande √©chelle de M. Steven pour installer un r√©seau de chasse quadrupl√© est termin√©e</a></li>
<li><a href="../fr416951/index.html">Clusters Kubernetes dans le service VPC</a></li>
<li><a href="../fr416955/index.html">Petits trucs avec Elasticsearch</a></li>
<li><a href="../fr416957/index.html">Quelle machine laser acheter? Examen fiable de la machine laser Raylogic 11G</a></li>
<li><a href="../fr416959/index.html">Apple pr√©sente une nouvelle fonctionnalit√© antivol iOS</a></li>
<li><a href="../fr416961/index.html">R√©solution automatique des conflits √† l'aide de transformations op√©rationnelles</a></li>
<li><a href="../fr416963/index.html">Comme nous l'avons fait pour BelAZ. Partie 2 - Tests de laboratoire</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>