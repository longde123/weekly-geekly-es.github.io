<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèø üòå üç® System.IO.Pipelines - uma ferramenta pouco conhecida para os amantes de alto desempenho üë∑üèº üë©üèΩ‚Äçüéì üèí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° leitor. Muito tempo se passou desde o lan√ßamento do .NET Core 2.1. E inova√ß√µes legais como Span e Memory j√° foram consideradas amplamente, voc√™ po...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.IO.Pipelines - uma ferramenta pouco conhecida para os amantes de alto desempenho</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464921/">  Ol√° leitor.  Muito tempo se passou desde o lan√ßamento do .NET Core 2.1.  E inova√ß√µes legais como Span e Memory j√° foram consideradas amplamente, voc√™ pode ler, ver e ouvir muito sobre elas.  No entanto, infelizmente, uma biblioteca chamada System.IO.Pipelines n√£o recebeu a mesma aten√ß√£o.  Quase tudo o que h√° neste t√≥pico √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√∫nico post</a> que muitos traduziram e publicaram em casa.  Definitivamente, deve haver mais informa√ß√µes para que os interessados ‚Äã‚Äãpossam ver a tecnologia de diferentes √¢ngulos. <br><br><img src="https://habrastorage.org/webt/fe/ff/_q/feff_q0xj_lqisaxmeji-eomyne.jpeg"><br><a name="habracut"></a><br><h2>  1. Introdu√ß√£o </h2><br>  Portanto, esta biblioteca tem como objetivo acelerar o trabalho com o processamento de dados de streaming.  Ele foi originalmente criado e usado pela equipe de desenvolvimento do Kestrel (um servidor Web de plataforma cruzada para o ASP.NET Core), mas atualmente √© entregue por meio de um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pacote de nuget</a> separado. <br>  Antes de nos aprofundarmos no t√≥pico, podemos imaginar o mecanismo da biblioteca como um an√°logo aprimorado do MemoryStream.  O problema com o MemoryStream original √© um n√∫mero excessivo de c√≥pias, o que √© √≥bvio se voc√™ se lembrar de que uma matriz de bytes privada √© usada dentro como um buffer.  Por exemplo, nos m√©todos de <a href="">leitura</a> e <a href="">grava√ß√£o</a> , a c√≥pia √© claramente vis√≠vel.  Assim, para o objeto que queremos gravar no fluxo, uma c√≥pia ser√° criada no buffer interno e, durante a leitura, uma c√≥pia da c√≥pia interna ser√° entregue ao consumidor.  Parece que n√£o √© o uso mais racional do espa√ßo. <br>  O System.IO.Pipelines n√£o tem como objetivo substituir todos os fluxos, √© uma ferramenta adicional no arsenal de um desenvolvedor que escreve c√≥digo de alto desempenho.  Sugiro que voc√™ se familiarize com os m√©todos e classes b√°sicos, veja como eles s√£o organizados por dentro e analise exemplos b√°sicos. <br><br>  Vamos come√ßar com o dispositivo interno, ao mesmo tempo examinando fragmentos de c√≥digo simples.  Depois disso, ficar√° claro o que e como funciona e como deve ser usado.  Ao trabalhar com System.IO.Pipelines, vale lembrar que o conceito b√°sico √© que todas as opera√ß√µes de leitura e grava√ß√£o devem ocorrer sem aloca√ß√µes adicionais.  Mas alguns m√©todos atraentes √† primeira vista contradizem essa regra.  Consequentemente, o c√≥digo que voc√™ est√° tentando com tanta rapidez come√ßa a alocar mem√≥ria para dados novos e novos, carregando o coletor de lixo. <br><br>  A biblioteca interna da biblioteca usa as mais amplas possibilidades das vers√µes mais recentes do idioma e per√≠odo, intervalo, mem√≥ria, conjuntos de objetos, ValueTask etc.  Vale a pena procurar pelo menos um √≥timo exemplo de uso desses recursos na produ√ß√£o. <br>  Ao mesmo tempo, alguns ficaram descontentes com a implementa√ß√£o de fluxos em C #, porque uma classe era usada para leitura e grava√ß√£o.  Mas, como eles dizem, voc√™ n√£o pode jogar m√©todos fora de uma classe.  Mesmo se o fluxo n√£o suportasse a leitura / grava√ß√£o / movimenta√ß√£o do ponteiro, as propriedades CanRead, CanWrite e CanSeek entrariam em vigor, o que parecia uma pequena muleta.  Aqui as coisas s√£o diferentes. <br>  Para trabalhar com tubos, s√£o usadas 2 classes: <a href="">PipeWriter</a> e <a href="">PipeReader</a> .  Essas classes cont√™m cerca de 50 linhas cada e s√£o pseudo-fachadas (n√£o suas encarna√ß√µes mais cl√°ssicas, pois h√° uma √∫nica classe oculta por tr√°s delas, e n√£o muitas) para a classe <a href="">Pipe</a> , que cont√©m toda a l√≥gica b√°sica para trabalhar com dados.  Dos membros p√∫blicos - 2 construtores, 2 propriedades de obten√ß√£o apenas - Reader e Writer, o m√©todo Reset (), que redefine os campos internos para seu estado inicial para que a classe possa ser reutilizada.  Outros m√©todos para o trabalho s√£o chamados usando pseudo-fachadas. <br><br><h2>  Para come√ßar na classe Pipe </h2><br>  A inst√¢ncia da classe ocupa 320 bytes, o que √© bastante (quase um ter√ßo de um kilobyte, dois desses objetos n√£o cabiam na mem√≥ria do Manchester Mark I).  Portanto, aloc√°-lo em grandes quantidades √© uma m√° id√©ia.  Al√©m disso, o significado do objeto √© destinado ao uso a longo prazo.  O uso de pools tamb√©m cria um argumento para esta declara√ß√£o.  Afinal, os objetos usados ‚Äã‚Äãna piscina viver√£o para sempre (em qualquer caso, no padr√£o). <br>  Observe que a classe est√° marcada como lacrada e √© segura para threads - muitas se√ß√µes do c√≥digo s√£o cr√≠ticas e est√£o envolvidas em bloqueios. <br>  Para come√ßar, crie uma inst√¢ncia da classe Pipe e obtenha os objetos PipeReader e PipeWriter usando as propriedades mencionadas. <br><br><div class="spoiler">  <b class="spoiler_title">Inicializa√ß√£o f√°cil</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); PipeWriter pipeWriter = pipe.Writer; PipeReader pipeReader = pipe.Reader;</code> </pre> <br></div></div><br>  Considere os m√©todos para trabalhar com tubos: <br>  Para grava√ß√£o via PipeWriter - WriteAsync, GetMemory / GetSpan, Advance, FlushAsync, Complete, CancelPendingFlush, OnReaderCompleted. <br>  Para ler atrav√©s do PipeReader - AdvanceTo, ReadAsync, TryRead, Complete, CancelPendingRead, OnWriterCompleted. <br><br>  Conforme declarado na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publica√ß√£o</a> , a classe usa uma lista de buffers vinculada individualmente.  Mas, obviamente, eles n√£o s√£o passados ‚Äã‚Äãentre o PipeReader e o PipeWriter - toda a l√≥gica est√° em uma classe.  Esta lista √© usada para leitura e escrita.  Al√©m disso, os dados retornados s√£o armazenados nesta lista. <br>  Tamb√©m existem objetos que indicam o in√≠cio dos dados a serem lidos (ReadHead e √≠ndice), o final dos dados a serem lidos (ReadTail e √≠ndice) e o in√≠cio do local a ser gravado (WriteHead e o n√∫mero de bytes em buffer gravados).  Aqui, ReadHead, ReadTail e WriteHead s√£o um segmento espec√≠fico da lista e o √≠ndice indica uma posi√ß√£o espec√≠fica dentro do segmento.  Assim, a grava√ß√£o pode come√ßar no meio de um segmento, capturar todo o pr√≥ximo segmento e terminar no meio do terceiro.  Esses ponteiros se movem em v√°rios m√©todos. <br><br><h2>  Introdu√ß√£o aos m√©todos PipeWriter </h2><br><h3>  # 1 <a href="">ValueTask &lt;FlushResult&gt; WriteAsync (fonte ReadOnlyMemory &lt;byte&gt;, CancellationToken cancellationToken)</a> </h3><br>  Apenas esse m√©todo tentador.  Tem uma assinatura muito adequada e moderna - aceita ReadOnlyMemory, ass√≠ncrono.  E muitos podem ficar tentados, principalmente lembrando que Span e Memory s√£o t√£o r√°pidos e legais.  Mas n√£o se iluda.  Tudo o que esse m√©todo faz √© copiar o ReadOnlyMemory passado para ele na lista interna.  E "copiar" significa uma chamada para o m√©todo CopyTo, e n√£o copiar o pr√≥prio objeto.  Ou seja, todos os dados que queremos gravar ser√£o copiados, carregando assim a mem√≥ria.  Este m√©todo deve ser estudado apenas para garantir que √© melhor n√£o us√°-lo.  Bem, e talvez para algumas situa√ß√µes raras, esse comportamento √© apropriado. <br>  O corpo do m√©todo √© uma se√ß√£o cr√≠tica, o acesso a ele √© sincronizado atrav√©s de um monitor. <br><br>  Ent√£o pode surgir a quest√£o de como escrever algo, se n√£o atrav√©s do m√©todo mais √≥bvio e √∫nico adequado. <br><br><h3>  # 2 <a href="">Mem√≥ria &lt;byte&gt; GetMemory (int sizeHint)</a> </h3><br>  O m√©todo usa um par√¢metro de um tipo inteiro.  Nele, devemos indicar quantos bytes queremos escrever (ou mais, mas em nenhum caso menos).  Esse m√©todo verifica se h√° espa√ßo suficiente para grava√ß√£o no fragmento atual de mem√≥ria armazenado em _writingHeadMemory.  Se suficiente, _writingHeadMemory √© retornado como mem√≥ria.  Caso contr√°rio, para os dados gravados no buffer, mas para os quais o m√©todo FlushAsync n√£o foi chamado, ele ser√° chamado e outro BufferSegment ser√° selecionado, que ser√° conectado ao anterior (aqui est√° a lista).  Na aus√™ncia de _writingHeadMemory, ele √© inicializado com um novo BufferSegment.  E a aloca√ß√£o do pr√≥ximo buffer √© uma se√ß√£o cr√≠tica e √© feita sob o bloqueio. <br>  Sugiro uma olhada nesse exemplo.  √Ä primeira vista, pode parecer que o compilador (ou tempo de execu√ß√£o) tenha enganado o dem√¥nio. <br><br><div class="spoiler">  <b class="spoiler_title">Devilry</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipeNoOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Memory&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; memoryOne = pipeNoOptions.Writer.GetMemory(<span class="hljs-number"><span class="hljs-number">2</span></span>); Console.WriteLine(memoryOne.Length); <span class="hljs-comment"><span class="hljs-comment">//2048  4096 var pipeWithOptions = new Pipe(new PipeOptions(minimumSegmentSize: 5)); Memory&lt;byte&gt; memoryTwo = pipeWithOptions.Writer.GetMemory(2); Console.WriteLine(memoryTwo.Length); //16</span></span></code> </pre><br></div></div><br>  Mas tudo neste exemplo √© compreens√≠vel e simples. <br>  Ao criar uma inst√¢ncia de Pipe, podemos passar um objeto <a href="">PipeOptions</a> com op√ß√µes para cri√°-lo ao construtor. <br><br>  PipeOptions possui um campo de tamanho de segmento m√≠nimo padr√£o.  H√° pouco tempo, era 2048, mas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esse commit</a> mudou tudo, agora 4096. No momento da reda√ß√£o, a vers√£o com 4096 era um pacote de pr√©-lan√ßamento, na vers√£o mais recente era 2048. Isso explica o comportamento do primeiro exemplo.  Se voc√™ for cr√≠tico ao usar um tamanho menor para o buffer padr√£o, poder√° especific√°-lo em uma inst√¢ncia do tipo PipeOptions. <br><br>  Mas no segundo exemplo, onde o tamanho m√≠nimo √© indicado, o comprimento n√£o corresponde a ele.  E isso j√° est√° acontecendo porque a cria√ß√£o de um novo BufferSegment ocorre usando pools.  Uma das op√ß√µes no PipeOptions √© o pool de mem√≥ria.  Depois disso, o pool especificado ser√° usado para criar um novo segmento.  Se voc√™ n√£o especificou seu conjunto de mem√≥rias, ser√° utilizado o ArrayPool padr√£o, que, como voc√™ sabe, possui v√°rios buckets para tamanhos diferentes de matrizes (cada um deles √© duas vezes maior que o anterior) e, quando solicitado por um tamanho espec√≠fico, procura um bucket com matrizes de tamanho adequado (ent√£o existe o maior ou igual mais pr√≥ximo).  Consequentemente, o novo buffer quase certamente ser√° maior do que o solicitado.  O tamanho m√≠nimo da matriz no ArrayPool padr√£o (System.Buffers.TlsOverPerCoreLockedStacksArrayPool) √© 16. Mas n√£o se preocupe, √© um conjunto de matrizes.  Assim, na grande maioria dos casos, a matriz n√£o pressiona o coletor de lixo e ser√° reutilizada. <br><br><h3>  # 2.5 <a href="">Span &lt;byte&gt; GetSpan (int sizeHint)</a> </h3><br>  Funciona da mesma forma, fornecendo Span from Memory. <br><br>  Portanto, GetMemory () ou GetSpan () s√£o os principais m√©todos de grava√ß√£o.  Eles nos d√£o um objeto para o qual podemos escrever.  Para fazer isso, n√£o precisamos alocar mem√≥ria para novas matrizes de valores, podemos escrever diretamente na estrutura interna.  Qual usar depender√° principalmente da API que voc√™ est√° usando e do m√©todo ass√≠ncrono.  No entanto, tendo em conta o que precede, surge uma quest√£o.  Como o leitor saber√° quanto escrevemos?  Se sempre usamos uma implementa√ß√£o espec√≠fica do pool, que fornece uma matriz exatamente do mesmo tamanho que o solicitado, o leitor pode ler o buffer inteiro de uma s√≥ vez.  No entanto, como j√° dissemos, temos um buffer com alta probabilidade de tamanho maior.  Isso leva ao seguinte m√©todo necess√°rio para a opera√ß√£o. <br><br><h3>  # 3 <a href="">void Advance (int bytes)</a> </h3><br>  Um m√©todo terr√≠vel e simples.  Leva o n√∫mero de bytes escritos como argumento.  Eles incrementam os contadores internos - _unflushedBytes e _writingHeadBytesBuffered, cujos nomes falam por si.  Ele tamb√©m trunca _writingHeadMemory exatamente para o n√∫mero de bytes gravados (usando o m√©todo Slice).  Portanto, depois de chamar esse m√©todo, voc√™ precisar√° solicitar um novo bloco de mem√≥ria na forma de Mem√≥ria ou Extens√£o, n√£o poder√° gravar no anterior.  E todo o corpo do m√©todo √© uma se√ß√£o cr√≠tica e funciona sob um bloqueio. <br><br>  Parece que depois disso o leitor pode receber dados.  Mas √© necess√°rio mais um passo. <br><br><h3>  # 4 <a href="">ValueTask &lt;FlushResult&gt; FlushAsync (CancellationToken cancellationToken)</a> </h3><br>  O m√©todo √© chamado ap√≥s escrevermos os dados necess√°rios na mem√≥ria recebida e indicar quanto escrevemos l√°.  O m√©todo retorna um ValueTask, no entanto, n√£o √© ass√≠ncrono (diferente do StreamPipeWriter descendente).  ValueTask √© um tipo especial (estrutura somente leitura) usado no caso em que a maioria das chamadas n√£o usa assincronia, ou seja, todos os dados necess√°rios estar√£o dispon√≠veis no momento da chamada e o m√©todo terminar√° de forma s√≠ncrona.  No interior, ele cont√©m dados ou Tarefa (caso n√£o funcione de forma s√≠ncrona).  Depende do estado da propriedade _writerAwaitable.IsCompleted.  Se procurarmos o que muda o estado desse objeto em espera, veremos que isso acontece sob a condi√ß√£o de que a quantidade de dados n√£o processados ‚Äã‚Äã(n√£o consumidos) (isso n√£o √© exatamente o mesmo que n√£o lido (n√£o examinado), ser√° explicado mais tarde) exceda um certo limite (_pauseWriterThreshold).  O padr√£o √© 16 tamanhos de segmento.  Se desejado, o valor pode ser alterado em PipeOptions.  Al√©m disso, esse m√©todo inicia a continua√ß√£o do m√©todo ReadAsync, se um foi bloqueado. <br><br>  Retorna um FlushResult contendo 2 propriedades - IsCanceled e IsCompleted.  IsCanceled indica se o Flush foi cancelado (chamada CancelPendingFlush).  IsCompleted indica se o PipeReader foi conclu√≠do (chamando os m√©todos Complete () ou CompleteAsync ()). <br>  A parte principal do m√©todo √© realizada sob Locke Skywalker. <br><br>  Outros m√©todos do PipeWriter n√£o s√£o interessantes do ponto de vista da implementa√ß√£o e s√£o usados ‚Äã‚Äãcom muito menos frequ√™ncia; portanto, apenas uma breve descri√ß√£o ser√° fornecida. <br><br><h3>  # 5 void Complete (exce√ß√£o de exce√ß√£o = null) ou ValueTask CompleteAsync (exce√ß√£o de exce√ß√£o = null) </h3><br>  Marca o tubo fechado para escrever.  Ap√≥s a conclus√£o, uma exce√ß√£o ser√° lan√ßada ao tentar usar os m√©todos de grava√ß√£o.  Se o PipeReader j√° tiver sido conclu√≠do, toda a inst√¢ncia do Pipe tamb√©m ser√° conclu√≠da.  A maior parte do trabalho √© feita sob o bloqueio. <br><br><h3>  # 6 void CancelPendingFlush () </h3><br>  Como o nome indica, ele conclui a opera√ß√£o atual FlushAsync ().  H√° um lok. <br><br><h3>  # 7 void OnReaderCompleted (a√ß√£o &lt;exce√ß√£o, objeto&gt; retorno de chamada, estado do objeto) </h3><br>  Executa o delegado delegado quando o leitor √© conclu√≠do.  H√° tamb√©m uma fechadura. <br>  A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> atualmente diz que esse m√©todo pode n√£o ser chamado em alguns descendentes de PipeWriter e ser√° removido no futuro.  Portanto, voc√™ n√£o deve vincular a l√≥gica a esses m√©todos. <br><br><h2>  V√° para PipeReader </h2><br><h3>  # 1 <a href="">ValueTask &lt;ReadResult&gt; ReadAsync (token CancellationToken)</a> </h3><br>  Aqui, como FlushAsync, um ValueTask √© retornado, o que sugere que o m√©todo √© principalmente s√≠ncrono, mas nem sempre.  Depende do estado de _readerAwaitable.  Assim como no FlushAsync, voc√™ precisa descobrir quando _readerAwaitable est√° definido como incompleto.  Isso acontece quando o PipeReader l√™ tudo da lista (ou cont√©m dados que foram marcados como examinados e precisam de mais dados para continuar).  O que, de fato, √© l√≥gico.  Assim, podemos concluir que √© desej√°vel ajustar o Pipe ao seu trabalho, definir todas as suas op√ß√µes cuidadosamente, com base em estat√≠sticas empiricamente identificadas.  A configura√ß√£o adequada reduzir√° a probabilidade de uma ramifica√ß√£o de execu√ß√£o ass√≠ncrona e permitir√° um processamento mais eficiente dos dados.  Quase todo o m√©todo √© cercado por uma fechadura. <br><br>  Retorna alguns <a href="">ReadResult</a> misteriosos.  Na verdade, √© apenas um buffer + sinalizadores mostrando o status da opera√ß√£o (IsCanceled - se o ReadAsync foi cancelado e IsCompleted indicando se o PipeWriter foi fechado).  Nesse caso, IsCompleted √© um valor que indica se os m√©todos PipeWriter Complete () ou CompleteAsync () foram chamados.  Se esses m√©todos foram chamados com uma exce√ß√£o, eles ser√£o lan√ßados ao tentar ler. <br><br>  O buffer novamente tem um tipo misterioso - <a href="">ReadOnlySequence</a> .  Este, por sua vez, √© um objeto para conter <a href="">segmentos (ReadOnlySequenceSegment) dos</a> √≠ndices <a href="">de</a> in√≠cio e fim + in√≠cio e fim dentro dos segmentos correspondentes.  O que na verdade se parece com a estrutura da pr√≥pria classe Pipe.  A prop√≥sito, BufferSegment √© o sucessor de ReadOnlySequenceSegment, o que sugere que ele seja usado l√°.  Gra√ßas a isso, voc√™ pode se livrar de aloca√ß√µes de mem√≥ria desnecess√°rias para transfer√™ncia de dados do gravador para o leitor. <br>  O ReadOnlySpan pode ser obtido no buffer para processamento adicional.  Para concluir a imagem, voc√™ pode verificar se o buffer cont√©m um √∫nico ReadOnlySpan.  Se ele contiver, n√£o precisamos iterar a cole√ß√£o de um elemento e podemos obt√™-la usando a propriedade First.  Caso contr√°rio, voc√™ precisar√° revisar todos os segmentos no buffer e processar cada ReadOnlySpan. <br><br>  T√≥pico de discuss√£o - na classe ReadOnlySequence, os tipos de refer√™ncia anul√°veis ‚Äã‚Äãs√£o usados ‚Äã‚Äãativamente e existe goto (n√£o para sair do aninhamento e n√£o no c√≥digo gerado) - em particular, <a href="">aqui</a> <br><br>  Ap√≥s o processamento, voc√™ deve deixar claro para a inst√¢ncia do Pipe que lemos os dados. <br><br><h3>  # 2 <a href="">bool TryRead (resultado ReadResult)</a> </h3><br>  Vers√£o s√≠ncrona.  Permite obter o resultado, se for o caso.  Se ainda n√£o estiver l√°, ao contr√°rio do ReadAsync, ele n√£o bloqueia, mas retorna false.  Tamb√©m na fechadura. <br><br><h3>  # 3 <a href="">void AdvanceTo (SequencePosition consumida, SequencePosition examinada)</a> </h3><br>  Neste m√©todo, voc√™ pode especificar quantos bytes lemos e quantos processamos.  Os dados que foram lidos, mas n√£o processados, ser√£o retornados na pr√≥xima vez que forem lidos.  Esse recurso pode parecer estranho √† primeira vista, mas ao processar um fluxo de bytes, raramente √© necess√°rio processar cada byte individualmente.  Normalmente, os dados s√£o trocados usando mensagens.  Pode surgir uma situa√ß√£o em que o leitor, ao ler, recebeu uma mensagem inteira e parte da segunda.  O todo deve ser processado, e parte do segundo deve ser deixada na pr√≥xima vez, para que venha com a parte restante.  O m√©todo AdvanceTo aceita uma SequencePosition, que na verdade √© um segmento + √≠ndice.  Ao processar tudo o que o ReadAsync leu, voc√™ pode especificar buffer.End.  Caso contr√°rio, voc√™ precisar√° criar explicitamente uma posi√ß√£o, indicando o segmento e o √≠ndice em que o processamento foi interrompido.  Sob o cap√¥ lok. <br>  Al√©m disso, se a quantidade de informa√ß√µes brutas for menor que a falha instalada (_resumeWriterThreshold), ela iniciar√° a continua√ß√£o do PipeWriter se estiver bloqueada.  Por padr√£o, esse limite √© de 8 volumes de segmento (metade do limite de bloqueio). <br><br><h3>  # 4 vazio (exce√ß√£o exce√ß√£o = nulo) </h3><br>  Conclui o PipeReader.  Se o PipeWriter estiver completo nesse momento, a inst√¢ncia do Pipe inteira ser√° encerrada.  Trave para dentro. <br><br><h3>  # 5 void CancelPendingRead () </h3><br>  Permite cancelar a leitura atualmente esperada.  Locke. <br><br><h3>  # 6 void OnWriterCompleted (a√ß√£o &lt;exce√ß√£o, objeto&gt; retorno de chamada, estado do objeto) </h3><br>  Permite especificar o delegado a ser executado ap√≥s a conclus√£o do PipeWriter. <br>  Como o m√©todo semelhante para o PipeWriter, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o tem</a> a mesma nota que ser√° removida.  Trave sob o cap√¥. <br><br><h2>  Exemplo </h2><br><br>  A lista abaixo mostra um exemplo de trabalho com tubos. <br>  Desde a introdu√ß√£o do .NET Core Span e Memory, muitas classes para trabalhar com dados foram complementadas por sobrecargas usando esses tipos.  Portanto, o esquema geral de intera√ß√£o ser√° aproximadamente o mesmo.  No meu exemplo, usei pipelines para trabalhar com pipes (eu gosto de palavras raiz), ou seja,  canais - objetos do SO para comunica√ß√£o entre processos.  A API do canal acaba de ser expandida de acordo para ler dados no Span e na Memory.  A vers√£o ass√≠ncrona usa Mem√≥ria, pois o m√©todo ass√≠ncrono ser√° convertido em um m√©todo de modelo usando uma m√°quina de estado finito gerada automaticamente, na qual todas as vari√°veis ‚Äã‚Äãlocais e par√¢metros de m√©todo s√£o armazenados e, como Span √© ref read-only struct, ele n√£o pode estar no heap, respectivamente, usando Span em um m√©todo ass√≠ncrono n√£o √© poss√≠vel.  Mas h√° tamb√©m uma vers√£o s√≠ncrona do m√©todo que permite usar o Span.  No meu exemplo, eu tentei os dois e verificou-se que a vers√£o s√≠ncrona nessa situa√ß√£o se mostra melhor.  Ao us√°-lo, ocorre menos coleta de lixo e o processamento de dados √© mais r√°pido.  Mas isso foi apenas porque havia muitos dados.  No caso de uma situa√ß√£o prov√°vel em que n√£o haver√° dados no momento da inscri√ß√£o para o pr√≥ximo lote, voc√™ dever√° usar a vers√£o ass√≠ncrona para n√£o sobrecarregar o processador. <br>  O exemplo tem coment√°rios que explicam alguns pontos.  Chamo a aten√ß√£o para o fato de que, apesar de os fragmentos do programa respons√°vel pela leitura do pipe e do processamento serem separados, ao gravar em um arquivo, os dados s√£o lidos exatamente no local em que foram gravados ao ler no pipe. <br><br><div class="spoiler">  <b class="spoiler_title">Anos de evolu√ß√£o em prol de um recurso poderoso - maine ass√≠ncrono</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PipeDataWriter(pipe.Writer, <span class="hljs-string"><span class="hljs-string">"testpipe"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataProcessor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataProcessor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleBytesProcessor(), pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAll(dataWriter.ReadFromPipeAsync(cts.Token), dataProcessor.StartProcessingDataAsync(cts.Token)); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pipepatawriter</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PipeDataWriter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NamedPipeClientStream _namedPipe; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeWriter _pipeWriter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Servername = <span class="hljs-string"><span class="hljs-string">"."</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipeDataWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PipeWriter pipeWriter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pipeName</span></span></span><span class="hljs-function">)</span></span> { _pipeWriter = pipeWriter ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeWriter)); _namedPipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedPipeClientStream(Servername, pipeName, PipeDirection.In); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFromPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _namedPipe.ConnectAsync(token); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/       Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> //Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;byte&gt;</span></span></span><span class="hljs-comment"> buffer = _pipeWriter.GetMemory(); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/       Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/         -       . //int readBytes = await _namedPipe.ReadAsync(buffer, token); //         PipeWriter Span //         -       . int readBytes = _namedPipe.Read(_pipeWriter.GetSpan()); //      ,        //         if (readBytes == 0) { await Task.Delay(500, token); continue; } // ,       _pipeWriter.Advance(readBytes); //  ,      PipeReader FlushResult result = await _pipeWriter.FlushAsync(token); //  PipeReader  ,       //        ,      if (result.IsCompleted) { break; } } //  _pipeWriter     Pipe _pipeWriter.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Processador de dados</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DataProcessor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IBytesProcessor _bytesProcessor; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeReader _pipeReader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataProcessor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBytesProcessor bytesProcessor, PipeReader pipeReader</span></span></span><span class="hljs-function">)</span></span> { _bytesProcessor = bytesProcessor ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(bytesProcessor)); _pipeReader = pipeReader ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeReader)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartProcessingDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-comment">//     Pipe ReadResult result = await _pipeReader.ReadAsync(token); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; //      await _bytesProcessor.ProcessBytesAsync(buffer, token); // ,      .       ,   //  ,               //    IBytesProcessor.ProcessBytesAsync   ,    _pipeReader.AdvanceTo(buffer.End); //  PipeWriter  ,      //      ,      if (result.IsCompleted) { break; } } //  _pipeReader     Pipe _pipeReader.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Bytesprocessor</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessBytesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; bytesSequence, CancellationToken token</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleBytesProcessor</span></span> : <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-comment"><span class="hljs-comment">//,         IDisposable readonly FileStream _fileStream = new FileStream("buffer", FileMode.Create); public Task ProcessBytesAsync(ReadOnlySequence&lt;byte&gt; bytesSequence, CancellationToken token) { if (bytesSequence.IsSingleSegment) { ProcessSingle(bytesSequence.First.Span); } else { foreach (var segment in bytesSequence) { ProcessSingle(segment.Span); } } return Task.CompletedTask; } private void ProcessSingle(ReadOnlySpan&lt;byte&gt; span) { _fileStream.Write(span); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464921/">https://habr.com/ru/post/pt464921/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464909/index.html">‚ÄúEles est√£o nos observando‚Äù: o que pode acontecer em uma minivan discreta logo abaixo da sua janela</a></li>
<li><a href="../pt464913/index.html">"Know kaizen": qual √© essa filosofia para melhorar os processos de produ√ß√£o</a></li>
<li><a href="../pt464915/index.html">Otimiza√ß√£o da recurs√£o da cauda do JavaScript</a></li>
<li><a href="../pt464917/index.html">Depois do cyberpunk: o que voc√™ precisa saber sobre os g√™neros atuais de fic√ß√£o cient√≠fica moderna</a></li>
<li><a href="../pt464919/index.html">Controle de recursos embutidos da RAM usada no aplicativo</a></li>
<li><a href="../pt464925/index.html">UX Voice Guide: situa√ß√µes, padr√µes, ferramentas (e um pouco de apoio moral)</a></li>
<li><a href="../pt464927/index.html">Mineiro ASIC em segunda m√£o: riscos, verifica√ß√£o e hashrate religado</a></li>
<li><a href="../pt464929/index.html">Carregamento lento da imagem do navegador (atributo de carregamento)</a></li>
<li><a href="../pt464931/index.html">Assembler insere ... em C #?</a></li>
<li><a href="../pt464933/index.html">Aplicativos para e-books no sistema operacional Android. Parte 4. Jogos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>