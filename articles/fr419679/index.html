<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üçö üõ≥Ô∏è Impl√©mentation de l'API Spring Framework √† partir de z√©ro. Proc√©dure pas √† pas pour les d√©butants. Partie 1 üôáüèª üö¥üèø üë®‚Äçüè≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Spring Framework est l'un des cadres de compr√©hension et d'apprentissage les plus complexes. La plupart des d√©veloppeurs l'apprennent lentement, gr√¢ce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Impl√©mentation de l'API Spring Framework √† partir de z√©ro. Proc√©dure pas √† pas pour les d√©butants. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419679/"><img src="https://habrastorage.org/webt/iw/mz/82/iwmz824_ptetkxwvc6sqtwjmbjw.png"><br><br>  Spring Framework est l'un des cadres de compr√©hension et d'apprentissage les plus complexes.  La plupart des d√©veloppeurs l'apprennent lentement, gr√¢ce √† des t√¢ches pratiques et √† Google.  Cette approche n'est pas efficace, car elle ne donne pas une image compl√®te et en m√™me temps est co√ªteuse. <br><br>  Je voudrais vous proposer une approche fondamentalement nouvelle de l'√©tude du printemps.  Il consiste dans le fait qu'une personne passe par une s√©rie de tutoriels sp√©cialement pr√©par√©s et met en ≈ìuvre ind√©pendamment la fonction du ressort.  La particularit√© de cette approche est qu'en plus d'une compr√©hension √† 100% des aspects √©tudi√©s de Spring, elle donne √©galement une forte augmentation de Java Core (Annotations, R√©flexion, Fichiers, G√©n√©riques). <br><br>  L'article vous offrira une exp√©rience inoubliable et vous fera vous sentir comme un d√©veloppeur Pivotal.  √âtape par √©tape, vous ferez haricoter vos cours et organiserez leur cycle de vie (le m√™me que dans un vrai printemps).  Les classes que vous impl√©menterez sont <b>BeanFactory</b> , <b>Component</b> , <b>Service</b> , <b>BeanPostProcessor</b> , <b>BeanNameAware</b> , <b>BeanFactoryAware</b> , <b>InitializingBean</b> , <b>PostConstruct</b> , <b>PreDestroy</b> , <b>DisposableBean</b> , <b>ApplicationContext</b> , <b>ApplicationListener</b> , <b>ContextClosedEvent</b> . <br><a name="habracut"></a><br><h2>  Un peu de moi </h2><br>  Je m'appelle Yaroslav et je suis d√©veloppeur Java avec 4 ans d'exp√©rience.  En ce moment je travaille pour EPAM Systems (SPB), et je plonge profond√©ment dans les technologies que nous utilisons.  Tr√®s souvent, je dois faire face au printemps, et je vois en lui un terrain d'entente dans lequel vous pouvez grandir (Java tout le monde le sait si bien, et des outils et des technologies trop sp√©cifiques peuvent aller et venir). <br><br>  Il y a quelques mois, j'ai r√©ussi la certification Spring Professional v5.0 (sans suivre de cours).  Apr√®s cela, j'ai r√©fl√©chi √† la fa√ßon d'enseigner √† d'autres personnes qui sautaient.  Malheureusement, il n'existe actuellement aucune m√©thodologie d'enseignement efficace.  La plupart des d√©veloppeurs ont une id√©e tr√®s superficielle du framework et de ses fonctionnalit√©s.  Le d√©bogage des sources printani√®res est trop difficile et absolument inefficace du point de vue de la formation (j'aimais en quelque sorte cela).  Faites 10 projets?  Oui, quelque part, vous pouvez approfondir vos connaissances et acqu√©rir beaucoup d'exp√©rience pratique, mais une grande partie de ce qui est ¬´sous le capot¬ª ne s'ouvrira jamais devant vous.  Lire Printemps en action?  Cool, mais co√ªteux en efforts.  Je l'ai travaill√© √† 40% (lors de la pr√©paration √† la certification), mais ce n'√©tait pas facile. <br><br>  La seule fa√ßon de comprendre quelque chose jusqu'au bout est de le d√©velopper vous-m√™me.  R√©cemment, j'ai eu l'id√©e que vous pouvez guider une personne √† travers un tutoriel int√©ressant qui supervisera le d√©veloppement de son cadre DI.  Sa principale caract√©ristique sera que l'API co√Øncidera avec l'API √©tudi√©e.  L'√©merveillement de cette approche est qu'en plus d'une compr√©hension profonde (sans espaces) du printemps, une personne aura une √©norme exp√©rience dans Java Core.  Franchement, j'ai moi-m√™me appris beaucoup de nouvelles choses lors de la pr√©paration de l'article, √† la fois sur Spring et sur Java Core.  Commen√ßons √† d√©velopper! <br><br><h2>  Projetez √† partir de z√©ro </h2><br>  Donc, la premi√®re chose √† faire est d'ouvrir votre IDE pr√©f√©r√© et de cr√©er un projet √† partir de z√©ro.  Nous ne connecterons aucun Maven ni aucune biblioth√®que tierce.  Nous ne connecterons m√™me pas les d√©pendances Spring.  Notre objectif est de d√©velopper une API qui ressemble le plus √† l'API Spring et de l'impl√©menter nous-m√™mes. <br><br>  Dans un projet propre, cr√©ez 2 packages principaux.  Le premier package est votre application ( <code>com.kciray</code> ) et la classe <code>Main.java</code> int√©rieur.  Le deuxi√®me package est org.springframework.  Oui, nous dupliquerons la structure du package du ressort d'origine, le nom de ses classes et leurs m√©thodes.  Il y a un effet tellement int√©ressant - lorsque vous cr√©ez quelque chose de vous-m√™me, celui de vous-m√™me commence √† sembler simple et compr√©hensible.  Ensuite, lorsque vous travaillez dans de grands projets, il vous semble que tout y est cr√©√© en fonction de votre pi√®ce.  Cette approche peut avoir un effet tr√®s positif sur la compr√©hension du syst√®me dans son ensemble, son am√©lioration, la correction de bogues, la r√©solution de probl√®mes, etc. <br><br>  Si vous avez des probl√®mes, vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prendre un</a> projet de travail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  Cr√©er un conteneur </h2><br>  Pour commencer, d√©finissez la t√¢che.  Supposons que nous ayons 2 classes - <code>ProductFacade</code> et <code>PromotionService</code> .  Imaginez maintenant que vous voulez connecter ces classes les unes aux autres, mais pour que les classes elles-m√™mes ne se connaissent pas (Pattern DI).  Nous avons besoin d'une classe distincte qui g√©rera toutes ces classes et d√©terminera les d√©pendances entre elles.  Appelons cela un conteneur.  Cr√©ons la classe <code>Container</code> ... Bien que non, attendez!  Spring n'a pas de classe de conteneur unique.  Nous avons de nombreuses impl√©mentations de conteneurs, et toutes ces impl√©mentations peuvent √™tre divis√©es en 2 types - les usines bin et les contextes.  La fabrique de bacs cr√©e des beans et les relie entre eux (injection de d√©pendances, DI), et le contexte fait √† peu pr√®s la m√™me chose, en plus d'ajouter des fonctionnalit√©s suppl√©mentaires (par exemple, internationaliser les messages).  Mais nous n'avons pas besoin de ces fonctions suppl√©mentaires maintenant, nous allons donc travailler avec l'usine bin. <br><br>  Cr√©ez une nouvelle classe <code>BeanFactory</code> et placez-la dans le package <code>org.springframework.beans.factory</code> .  Laissez les <code>Map&lt;String, Object&gt; singletons</code> stock√©s dans cette classe, dans laquelle l' <code>id</code> bin est mapp√© au bin lui-m√™me.  Ajoutez-y la <code>Object getBean(String beanName)</code> , qui extrait les beans par identifiant. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Map&lt;String, Object&gt; singletons = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String beanName)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singletons.get(beanName); } }</code> </pre> <br>  Veuillez noter que <code>BeanFactory</code> et <code>BeanFactory</code> sont deux choses diff√©rentes.  La premi√®re est l'usine de bacs (conteneur) et la seconde est l'usine de bacs, qui se trouve √† l'int√©rieur du r√©cipient et produit √©galement des bacs.  Usine √† l'int√©rieur de l'usine.  Si vous √™tes confus entre ces d√©finitions, vous vous souvenez peut-√™tre qu'en anglais, le deuxi√®me nom est le premier et le premier est quelque chose comme un adjectif.  Dans Bean <b>Factory, le</b> mot principal est l'usine et dans Factory <b>Bean</b> , le bean. <br><br>  Maintenant, cr√©ez les classes <code>ProductService</code> et <code>PromotionsService</code> .  <code>ProductService</code> renverra le produit de la base de donn√©es, mais avant cela, vous devez v√©rifier si des remises (promotions) s'appliquent √† ce produit.  Dans le commerce √©lectronique, le travail √† prix r√©duit est souvent attribu√© √† une classe de service distincte (et parfois √† un service Web tiers). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PromotionsService promotionsService; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PromotionsService </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPromotionsService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promotionsService; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPromotionsService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PromotionsService promotionsService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.promotionsService = promotionsService; } }</code> </pre><br>  Nous devons maintenant faire en sorte que notre conteneur ( <code>BeanFactory</code> ) d√©tecte nos classes, les cr√©e pour nous et les injecte l'une dans l'autre.  Les op√©rations telles que le <code>new ProductService()</code> doivent √™tre situ√©es √† l'int√©rieur du conteneur et effectu√©es pour le d√©veloppeur.  Utilisons l'approche la plus moderne (analyse de classe et annotations).  Pour ce faire, nous devons cr√©er une annotation <code>@Component</code> avec les <code>@Component</code> ( <code> org.springframework.beans.factory.stereotype</code> ). <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Component { }</code> </pre><br>  Par d√©faut, les annotations ne sont pas charg√©es en m√©moire pendant l'ex√©cution du programme ( <code>RetentionPolicy.CLASS</code> ).  Nous avons modifi√© ce comportement via une nouvelle strat√©gie de r√©tention ( <code>RetentionPolicy.RUNTIME</code> ). <br><br>  Ajoutez maintenant <code>@Component</code> avant les classes <code>ProductService</code> et avant <code>PromotionService</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } @Component public class PromotionService { //... }</span></span></code> </pre> <br><br>  Nous avons besoin de <code>BeanFactory</code> analyser notre package ( <code>com.kciray</code> ) et y trouver des classes qui sont annot√©es par <code>@Component</code> .  Cette t√¢che est loin d'√™tre anodine.  Il n'y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pas de solution toute faite</a> dans Java Core, et nous devrons faire nous-m√™mes une b√©quille.  Des milliers d'applications √† ressort utilisent le balayage des composants √† travers cette b√©quille.  Vous avez appris la terrible v√©rit√©.  Vous devrez extraire les noms de <code>ClassLoader</code> de <code>ClassLoader</code> et v√©rifier <code>ClassLoader</code> se terminent par ".class" ou non, puis cr√©er leur nom complet et en extraire les objets de classe! <br><br>  Je veux vous avertir imm√©diatement qu'il y aura de nombreuses exceptions v√©rifi√©es, alors soyez pr√™t √† les envelopper.  Mais d'abord, d√©cidons de ce que nous voulons.  Nous voulons ajouter une m√©thode sp√©ciale √† <code>BeanFactory</code> et l'appeler dans <code>Main</code> : <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//BeanFactory.java public class BeanFactory{ public void instantiate(String basePackage) { } } //Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.instantiate("com.kciray");</span></span></code> </pre><br>  Ensuite, nous devons obtenir <code>ClassLoader</code> .  Il est responsable du chargement des classes, et il est extrait tout simplement: <br><br><pre> <code class="java hljs">ClassLoader classLoader = ClassLoader.getSystemClassLoader();</code> </pre> <br>  Vous avez probablement d√©j√† remarqu√© que les packages sont s√©par√©s par un point et les fichiers par une barre oblique.  Nous devons convertir le chemin du lot en chemin du dossier et obtenir quelque chose comme <code>List&lt;URL&gt;</code> (les chemins de votre syst√®me de fichiers o√π vous pouvez rechercher des fichiers de classe). <br><br><pre> <code class="java hljs">String path = basePackage.replace(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//"com.kciray" -&gt; "com/kciray" Enumeration&lt;URL&gt; resources = classLoader.getResources(path);</span></span></code> </pre> <br>  Alors attendez un instant!  <code>Enumeration&lt;URL&gt;</code> n'est pas une <code>List&lt;URL&gt;</code> .  De quoi s'agit-il?  Oh, horreur, c'est l'ancien anc√™tre d' <code>Iterator</code> , disponible depuis Java 1.0.  C'est l'h√©ritage auquel nous devons faire face.  S'il est possible de parcourir <code>Iterable</code> aide de for (toutes les collections l'impl√©mentent), alors dans le cas de l' <code>Enumeration</code> vous devrez faire un bypass de poign√©e, √† travers <code>while(resources.hasMoreElements())</code> et <code>nextElement()</code> .  Et pourtant, il n'y a aucun moyen de supprimer des √©l√©ments de la collection.  Seulement 1996, seulement hardcore.  Oh oui, dans Java 9, ils ont ajout√© la m√©thode <code>Enumeration.asIterator()</code> , afin que vous puissiez y travailler. <br><br>  Allons plus loin.  Nous devons extraire les dossiers et parcourir le contenu de chacun d'eux.  Convertissez l'URL en fichier, puis obtenez son nom.  Il convient de noter ici que nous n'analyserons pas les packages imbriqu√©s afin de ne pas compliquer le code.  Vous pouvez compliquer votre t√¢che et faire une r√©cursion si vous le souhaitez. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (resources.hasMoreElements()) { URL resource = resources.nextElement(); File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(resource.toURI()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(File classFile : file.listFiles()){ String fileName = classFile.getName();<span class="hljs-comment"><span class="hljs-comment">//ProductService.class } }</span></span></code> </pre><br>  Ensuite, nous devons obtenir le nom du fichier sans l'extension.  Dans la cour en 2018, Java a d√©velopp√© des E / S de fichiers (NIO 2) pendant de nombreuses ann√©es, mais ne peut toujours pas s√©parer l'extension du nom de fichier.  Je dois cr√©er mon propre v√©lo, car  nous avons d√©cid√© de ne pas utiliser de biblioth√®ques tierces comme Apache Commons.  Utilisons l'ancienne m√©thode grand-p√®re <code>lastIndexOf(".")</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fileName.endsWith(<span class="hljs-string"><span class="hljs-string">".class"</span></span>)){ String className = fileName.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, fileName.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"."</span></span>)); }</code> </pre> <br>  Ensuite, nous pouvons obtenir l'objet classe en utilisant le nom complet de la classe (pour cela, nous appelons la classe de la classe <code>Class</code> ): <br><br><pre> <code class="java hljs">Class classObject = Class.forName(basePackage + <span class="hljs-string"><span class="hljs-string">"."</span></span> + className);</code> </pre> <br>  D'accord, maintenant nos cours sont entre nos mains.  De plus, il ne reste plus qu'√† mettre en √©vidence parmi eux ceux qui ont l'annotation <code>@Component</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(classObject.isAnnotationPresent(Component.class)){ System.out.println(<span class="hljs-string"><span class="hljs-string">"Component: "</span></span> + classObject); }</code> </pre> <br>  Ex√©cutez et v√©rifiez.  La console devrait ressembler √† ceci: <br><br><pre> <code class="bash hljs">Component: class com.kciray.ProductService Component: class com.kciray.PromotionsService</code> </pre> <br>  Maintenant, nous devons cr√©er notre bean.  Vous devez faire quelque chose comme <code>new ProductService()</code> , mais pour chaque bean, nous avons notre propre classe.  La r√©flexion en Java nous fournit une solution universelle (le constructeur par d√©faut est appel√©): <br><br><pre> <code class="java hljs">Object instance = classObject.newInstance();<span class="hljs-comment"><span class="hljs-comment">//=new CustomClass()</span></span></code> </pre> <br>  Ensuite, nous devons mettre ce bean dans les <code>Map&lt;String, Object&gt; singletons</code> .  Pour ce faire, s√©lectionnez le nom du bean (son id).  En Java, nous appelons des variables comme des classes (seule la premi√®re lettre est en minuscule).  Cette approche peut √©galement √™tre appliqu√©e aux beans, car Spring est un framework Java!  Convertissez le nom du bac de sorte que la premi√®re lettre soit petite et ajoutez-le √† la carte: <br><br><pre> <code class="java hljs">String beanName = className.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toLowerCase() + className.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>); singletons.put(beanName, instance);</code> </pre> <br>  Assurez-vous maintenant que tout fonctionne.  Le conteneur doit cr√©er des beans et ils doivent √™tre r√©cup√©r√©s par leur nom.  Veuillez noter que le nom de votre m√©thode <code>classObject.newInstance();</code> et le nom de la m√©thode <code>classObject.newInstance();</code>  ont une racine commune.  De plus, <code>instantiate()</code> fait partie du cycle de vie du bean.  En Java, tout est interconnect√©! <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.instantiate("com.kciray"); ProductService productService = (ProductService) beanFactory.getBean("productService"); System.out.println(productService);//ProductService@612</span></span></code> </pre> <br><br>  Essayez √©galement d'impl√©menter l'annotation <code>org.springframework.beans.factory.stereotype.Service</code> .  Il remplit exactement la m√™me fonction que <code>@Component</code> , mais il est appel√© diff√©remment.  Tout est dans le nom - vous d√©montrez que la classe est un service, pas seulement un composant.  C'est quelque chose comme la frappe conceptuelle.  Lors de la certification du printemps, il y avait une question ¬´Quelles annotations sont st√©r√©otyp√©es?¬ª  (de ceux √©num√©r√©s). "  Les annotations st√©r√©otyp√©es sont donc celles qui se trouvent dans le package de <code>stereotype</code> . <br><br><h2>  Remplissez les propri√©t√©s </h2><br>  Regardez le sch√©ma ci-dessous, il montre le d√©but du cycle de vie du bean.  Ce que nous avons fait auparavant est Instantiate (cr√©ation de beans via <code>newInstance()</code> ).  L'√©tape suivante est l'injection crois√©e de beans (injection de d√©pendance, c'est aussi l'inversion de contr√¥le (IoC)).  Vous devez parcourir les propri√©t√©s des grains et comprendre quelles propri√©t√©s vous devez injecter.  Si vous appelez <code>productService.getPromotionsService()</code> , vous obtiendrez <code>null</code> , car  d√©pendance non encore ajout√©e. <br><br><img src="https://habrastorage.org/webt/2i/4v/4c/2i4v4cbsb-bdpdrgb0grh_swclu.png"><br><br>  Tout d'abord, cr√©ez le package <code>org.springframework.beans.factory.annotation</code> et ajoutez-y l'annotation <code>@Autowired</code> .  L'id√©e est de marquer les champs qui sont des d√©pendances avec cette annotation. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Autowired { }</code> </pre> <br>  Ensuite, ajoutez-le √† la propri√©t√©: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> PromotionsService promotionsService; <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Maintenant, nous devons apprendre √† notre <code>BeanFactory</code> trouver ces annotations et √† leur injecter des d√©pendances.  Ajoutez une m√©thode distincte pour cela et appelez-la depuis <code>Main</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... public void populateProperties(){ System.out.println("==populateProperties=="); } }</span></span></code> </pre> <br>  Ensuite, nous avons juste besoin de parcourir tous nos bacs dans la carte des <code>singletons</code> , et pour chaque bac de parcourir tous ses champs ( <code>object.getClass().getDeclaredFields()</code> renvoie tous les champs, y compris les champs priv√©s).  Et v√©rifiez si le champ a une annotation <code>@Autowired</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object object : singletons.values()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Field field : object.getClass().getDeclaredFields()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (field.isAnnotationPresent(Autowired.class)) { } } }</code> </pre> <br>  Ensuite, nous devons parcourir tous les bacs une fois de plus et voir leur type - soudain, c'est le type que notre bac veut prendre pour lui-m√™me.  Oui, nous obtenons un cycle en trois dimensions! <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object dependency : singletons.values()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dependency.getClass().equals(field.getType())) { } }</code> </pre> <br>  De plus, lorsque nous avons d√©couvert la d√©pendance, nous devons l'injecter.  La premi√®re chose √† laquelle vous pourriez penser est d'√©crire le champ <code>promotionsService</code> utilisant directement la r√©flexion.  Mais le printemps ne fonctionne pas comme √ßa.  Apr√®s tout, si le champ a un modificateur <code>private</code> , nous devrons d'abord le d√©finir comme <code>public</code> , puis √©crire notre valeur, puis le red√©finir sur <code>private</code> (pour maintenir l'int√©grit√©).  Cela ressemble √† une grosse b√©quille.  Au lieu d'une grande b√©quille, faisons une petite b√©quille (nous formerons le nom du setter et l'appellerons): <br><br><pre> <code class="java hljs">String setterName = <span class="hljs-string"><span class="hljs-string">"set"</span></span> + field.getName().substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toUpperCase() + field.getName().substring(<span class="hljs-number"><span class="hljs-number">1</span></span>);<span class="hljs-comment"><span class="hljs-comment">//setPromotionsService System.out.println("Setter name = " + setterName); Method setter = object.getClass().getMethod(setterName, dependency.getClass()); setter.invoke(object, dependency);</span></span></code> </pre> <br>  Maintenant, ex√©cutez votre projet et assurez-vous qu'en appelant <code>productService.getPromotionsService()</code> au lieu de <code>null</code> , notre bean est retourn√©. <br><br>  Ce que nous avons impl√©ment√©, c'est l'injection par type.  Il existe √©galement une injection par nom (annotation <code>javax.annotation.Resource</code> ).  Il diff√®re en ce qu'au lieu du type du champ, son nom sera extrait, et selon lui - la d√©pendance de la carte.  Tout est similaire ici, m√™me dans quelque chose de plus simple.  Je vous recommande d'exp√©rimenter et de cr√©er votre propre bean, puis de l'injecter avec <code>@Resource</code> et d'√©tendre la m√©thode <code>populateProperties()</code> . <br><br><h2>  Nous soutenons les haricots qui connaissent leur nom </h2><br><img src="https://habrastorage.org/webt/ds/ge/nn/dsgennl2rvz-spa6h51l_yox81o.png"><br><br>  Il y a des moments o√π vous devez mettre son nom dans le bac.  Un tel besoin ne se pose pas souvent, car  les poubelles, par essence, ne devraient pas se conna√Ætre et qu'elles sont des poubelles.  Dans les premi√®res versions du printemps, on supposait que le bean √©tait un POJO (Plain Old Java Objec, le bon vieil objet Java), et toute la configuration √©tait rendue dans des fichiers XML et s√©par√©e de l'impl√©mentation.  Mais nous impl√©mentons cette fonctionnalit√©, car l'injection de nom fait partie du cycle de vie du bac. <br><br>  Comment savons-nous quel haricot veut savoir quel est son nom et ce qu'il ne veut pas?  La premi√®re chose qui vous vient √† l'esprit est de cr√©er une nouvelle annotation de type <code>@InjectName</code> et de la sculpter en champs de type String.  Mais cette solution sera trop g√©n√©rale et vous permet de vous tirer plusieurs fois dans le pied (placez cette annotation sur des champs de types inappropri√©s (pas String), ou essayez d'injecter un nom dans plusieurs champs de la m√™me classe).  Il existe une autre solution, plus pr√©cise - pour cr√©er une interface sp√©ciale avec une m√©thode de d√©finition.  Tous les bacs qui l'impl√©mentent obtiennent leur nom.  Cr√©ez la classe <code>BeanNameAware</code> dans le package <code>org.springframework.beans.factory</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span></span>; }</code> </pre> <br>  Ensuite, laissez notre <code>PromotionsService</code> impl√©menter: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String beanName; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ beanName = name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> beanName; } }</code> </pre> <br>  Et enfin, ajoutez une nouvelle m√©thode √† l'usine de haricots.  Tout est simple ici - nous passons par notre bin-singleton, v√©rifions si le bin impl√©mente notre interface, et appelons le setter: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">injectBeanNames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : singletons.keySet()) { Object bean = singletons.get(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BeanNameAware){ ((BeanNameAware) bean).setBeanName(name); } } }</code> </pre> <br>  Ex√©cutez et assurez-vous que tout fonctionne: <br><br><pre> <code class="java hljs">BeanFactory beanFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanFactory(); beanFactory.instantiate(<span class="hljs-string"><span class="hljs-string">"com.kciray"</span></span>); beanFactory.populateProperties(); beanFactory.injectBeanNames(); <span class="hljs-comment"><span class="hljs-comment">//... System.out.println("Bean name = " + promotionsService.getBeanName());</span></span></code> </pre><br>  Il convient de noter qu'au printemps, il existe d'autres interfaces similaires.  Je vous recommande d'impl√©menter vous- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">m√™me l'</a> interface <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BeanFactoryAware</a> , qui permet aux beans de recevoir un lien vers la fabrique de beans.  Il est mis en ≈ìuvre de mani√®re similaire. <br><br><h2>  Initialiser les haricots </h2><br><img src="https://habrastorage.org/webt/yq/0w/5t/yq0w5t8x0kqrgqwllfuxsi77xug.png"><br><br>  Imaginez que vous ayez une situation o√π vous devez ex√©cuter du code apr√®s que les d√©pendances ont √©t√© inject√©es (les propri√©t√©s du bac sont d√©finies).  En termes simples, nous devons donner au bac la possibilit√© de s'initialiser.  Alternativement, nous pouvons cr√©er une interface <code>InitializingBean</code> et y mettre la signature de la <code>void afterPropertiesSet()</code> .  L'impl√©mentation de ce m√©canisme est exactement la m√™me que celle pr√©sent√©e pour l'interface <code>BeanNameAware</code> , donc la solution est sous le spoiler.  Pratiquez et faites-le vous-m√™me en une minute: <br><br><div class="spoiler">  <b class="spoiler_title">Solution d'initialisation du bean</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//InitializingBean.java package org.springframework.beans.factory; public interface InitializingBean { void afterPropertiesSet(); } //BeanFactory.java public void initializeBeans(){ for (Object bean : singletons.values()) { if(bean instanceof InitializingBean){ ((InitializingBean) bean).afterPropertiesSet(); } } } //Main.java beanFactory.initializeBeans();</span></span></code> </pre> <br></div></div><br><br><h2>  Ajout de post-processeurs </h2><br>  Imaginez-vous √† la place des premiers d√©veloppeurs du printemps.  Votre framework se d√©veloppe et est tr√®s populaire aupr√®s des d√©veloppeurs, des lettres sont envoy√©es chaque jour par mail avec des demandes d'ajout de l'une ou l'autre fonctionnalit√© utile.  Si pour chacune de ces fonctionnalit√©s, vous ajoutez votre propre interface et la v√©rifiez dans le cycle de vie du bean, alors (le cycle de vie) sera obstru√© par des informations inutiles.  Au lieu de cela, nous pouvons cr√©er une interface universelle qui vous permet d'ajouter de la logique (absolument aucune, qu'il s'agisse de v√©rifier l'annotation, de remplacer le bac par un autre bac, de d√©finir des propri√©t√©s sp√©ciales, etc.). <br><br>  R√©fl√©chissons √† quoi sert cette interface.  Il doit effectuer un post-traitement des beans, il peut donc √™tre appel√© BeanPostProcessor.  Mais nous sommes confront√©s √† une question difficile - quand faut-il suivre la logique?  Apr√®s tout, nous pouvons l'ex√©cuter avant l'initialisation, mais nous pouvons l'ex√©cuter apr√®s.  Pour certaines t√¢ches, la premi√®re option est meilleure, pour d'autres - la seconde ... Comment √™tre? <br><br>  Nous pouvons activer les deux options √† la fois.  Laissez un post-processeur transporter deux logiques, deux m√©thodes.  L'un est ex√©cut√© avant l'initialisation (avant la m√©thode <code>afterPropertiesSet()</code> ) et l'autre apr√®s.  R√©fl√©chissons maintenant aux m√©thodes elles-m√™mes - quels param√®tres devraient-elles avoir?  De toute √©vidence, le <code>Object bean</code> lui-m√™me ( <code>Object bean</code> ) doit √™tre l√†.  Pour plus de commodit√©, en plus du bac, vous pouvez transmettre le nom de ce bac.  Vous vous souvenez que le bac lui-m√™me ne conna√Æt pas son nom.  Et nous ne voulons pas forcer tous les beans √† impl√©menter l'interface BeanNameAware.  Mais, au niveau du post-processeur, le nom du bean peut √™tre tr√®s utile.  Par cons√©quent, nous l'ajoutons comme deuxi√®me param√®tre. <br><br>  Et que doit renvoyer la m√©thode lors du post-traitement du bean?  Faisons-le retourner le bac lui-m√™me.  Cela nous donne une super flexibilit√©, car au lieu d'un bac, vous pouvez glisser un objet proxy qui encapsule ses appels (et ajoute de la s√©curit√©).  Ou vous pouvez renvoyer compl√®tement un autre objet en recr√©ant le bac.  Les d√©veloppeurs b√©n√©ficient d'une tr√®s grande libert√© d'action.  Voici la version finale de l'interface con√ßue: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.beans.factory.config; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessBeforeInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessAfterInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span></span>; }</code> </pre> <br>  Ensuite, nous devons ajouter une liste de processeurs simples √† notre fabrique de haricots et la possibilit√© d'en ajouter de nouveaux.  Oui, il s'agit d'une liste de tableaux r√©guli√®re. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//BeanFactory.java private List&lt;BeanPostProcessor&gt; postProcessors = new ArrayList&lt;&gt;(); public void addPostProcessor(BeanPostProcessor postProcessor){ postProcessors.add(postProcessor); }</span></span></code> </pre> <br>  Modifiez maintenant la m√©thode <code>initializeBeans</code> pour qu'elle prenne en compte les post-processeurs: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initializeBeans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : singletons.keySet()) { Object bean = singletons.get(name); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (BeanPostProcessor postProcessor : postProcessors) { postProcessor.postProcessBeforeInitialization(bean, name); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> InitializingBean) { ((InitializingBean) bean).afterPropertiesSet(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (BeanPostProcessor postProcessor : postProcessors) { postProcessor.postProcessAfterInitialization(bean, name); } } }</code> </pre> <br>  Cr√©ons un petit post-processeur qui trace simplement les appels √† la console et l'ajoutons √† notre fabrique de bean: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessBeforeInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"---CustomPostProcessor Before "</span></span> + beanName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bean; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessAfterInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"---CustomPostProcessor After "</span></span> + beanName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bean; } }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.addPostProcessor(new CustomPostProcessor());</span></span></code> </pre> <br><br>  Maintenant, lancez-vous et assurez-vous que tout fonctionne.  En tant que t√¢che de formation, cr√©ez un post-processeur qui fournira l'annotation <code>@PostConstruct (javax.annotation.PostConstruct)</code> .  Il fournit un autre moyen d'initialiser (enracin√© en Java, pas au printemps).  Son essence est que vous placez l'annotation sur une m√©thode, et cette m√©thode sera appel√©e AVANT l'initialisation du ressort standard (InitializingBean). <br><br>  Assurez-vous de cr√©er toutes les annotations et les packages (m√™me javax.annotation) manuellement, ne connectez pas les d√©pendances!  Cela vous aidera √† voir la diff√©rence entre le noyau du ressort et ses extensions (support javax), et √† vous en souvenir.  Cela gardera un style √† l'avenir. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous serez int√©ress√© par le fait que dans un vrai printemps l'annotation </font></font><code>@PostConstruct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est impl√©ment√©e de cette mani√®re, via le post-processeur CommonAnnotationBeanPostProcessor. </font><font style="vertical-align: inherit;">Mais n'y jetez pas un ≈ìil, √©crivez votre impl√©mentation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, je vous recommande d'ajouter une m√©thode </font></font><code>void close()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† la classe </font></font><code>BeanFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et d'√©laborer deux autres m√©canismes. </font><font style="vertical-align: inherit;">La premi√®re est une annotation </font></font><code>@PreDestroy (javax.annotation.PreDestroy)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, destin√©e aux m√©thodes qui doivent √™tre appel√©es lorsque le conteneur est ferm√©. </font><font style="vertical-align: inherit;">La seconde est l'interface </font></font><code>org.springframework.beans.factory.DisposableBean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui contient la m√©thode </font></font><code>void destroy()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tous les bacs ex√©cutant cette interface auront la capacit√© de se d√©truire (lib√©rer des ressources, par exemple).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@PreDestroy + DisposableBean</font></font></b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//DisposableBean.java package org.springframework.beans.factory; public interface DisposableBean { void destroy(); } //PreDestroy.java package javax.annotation; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; @Retention(RetentionPolicy.RUNTIME) public @interface PreDestroy { } //DisposableBean.java public void close() { for (Object bean : singletons.values()) { for (Method method : bean.getClass().getMethods()) { if (method.isAnnotationPresent(PreDestroy.class)) { try { method.invoke(bean); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } if (bean instanceof DisposableBean) { ((DisposableBean) bean).destroy(); } } }</span></span></code> </pre> <br></div></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cycle de vie complet du bean </font></font></h2><img src="https://habrastorage.org/webt/ns/uh/lk/nsuhlk9ko9d9gxtzmcytopfruim.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc mis en ≈ìuvre le cycle de vie complet du bac, dans sa forme moderne. </font><font style="vertical-align: inherit;">J'esp√®re que cette approche vous aidera √† vous en souvenir.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Notre contexte pr√©f√©r√© </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les programmeurs utilisent tr√®s souvent le terme contexte, mais tout le monde ne comprend pas ce qu'il signifie vraiment. </font><font style="vertical-align: inherit;">Maintenant, nous allons tout mettre en ordre. </font><font style="vertical-align: inherit;">Comme je l'ai not√© au d√©but de l'article, le contexte est la mise en ≈ìuvre du conteneur, ainsi que </font></font><code>BeanFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais, en plus des fonctions de base (DI), il ajoute encore quelques fonctionnalit√©s int√©ressantes. </font><font style="vertical-align: inherit;">L'une de ces fonctionnalit√©s est l'envoi et le traitement d'√©v√©nements entre les bacs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'article s'est av√©r√© trop volumineux et le contenu a commenc√© √† √™tre coup√©, j'ai donc mis les informations de contexte sous le spoiler.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous r√©alisons le contexte</font></font></b> <div class="spoiler_text">    .   <code>org.springframework.context</code> ,   <code>ApplicationContext</code>  .        <code>BeanFactory</code> .      ,      <code>close()</code> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationContext</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BeanFactory beanFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanFactory(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplicationContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String basePackage)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ReflectiveOperationException</span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"******Context is under construction******"</span></span>); beanFactory.instantiate(basePackage); beanFactory.populateProperties(); beanFactory.injectBeanNames(); beanFactory.initializeBeans(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ beanFactory.close(); } }</code> </pre> <br><br>     <code>Main</code> ,   ,   : <br><br><pre> <code class="java hljs">ApplicationContext applicationContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationContext(<span class="hljs-string"><span class="hljs-string">"com.kciray"</span></span>); applicationContext.close();</code> </pre> <br>   ,   .       <code>close()</code> ,     ¬´ ¬ª     - .   ,   : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.context.event; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextClosedEvent</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>      <code>ApplicationListener</code> ,      .        ,          ( <code>ApplicationListener&lt;E&gt;</code> ). ,    Java-,         . ,      ,    : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.context; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E event)</span></span></span></span>; }</code> </pre> <br>     <code>ApplicationContext</code> .     <code>close()</code>     ,  ,      .    <code>ApplicationListener&lt;ContextClosedEvent&gt;</code> ,     <code>onApplicationEvent(ContextClosedEvent)</code> .    ,   ? <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ beanFactory.close(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Object bean : beanFactory.getSingletons().values()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ApplicationListener) { } } }</code> </pre> <br>  .   .       <code>bean instanceof ApplicationListener&lt;ContextClosedEvent&gt;</code> .      Java.      <i>  (type erasure)</i> ,    &lt;T&gt;   &lt;Object&gt;.   ,   ?    ,    <code>ApplicationListener&lt;ContextClosedEvent&gt;</code> ,     ? <br><br>   ,       ,       .  ,      ,    ,     ,   : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Type type: bean.getClass().getGenericInterfaces()){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(type <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ParameterizedType){ ParameterizedType parameterizedType = (ParameterizedType) type; } }</code> </pre> <br> ,       ,  ,   ‚Äî   .   ,         : <br><br><pre> <code class="java hljs">Type firstParameter = parameterizedType.getActualTypeArguments()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(firstParameter.equals(ContextClosedEvent.class)){ Method method = bean.getClass().getMethod(<span class="hljs-string"><span class="hljs-string">"onApplicationEvent"</span></span>, ContextClosedEvent.class); method.invoke(bean, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContextClosedEvent()); }</code> </pre> <br>        ApplicationListener: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextClosedEvent</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... @Override public void onApplicationEvent(ContextClosedEvent event) { System.out.println("&gt;&gt; ContextClosed EVENT"); } }</span></span></code> </pre> <br> ,     Main  ,    ,   : <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java void testContext() throws ReflectiveOperationException{ ApplicationContext applicationContext = new ApplicationContext("com.kciray"); applicationContext.close(); }</span></span></code> </pre> <br></div></div><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au d√©part, j'avais pr√©vu cet article pour Baeldung en anglais, mais j'ai ensuite pens√© que le public de l'Habr√© pouvait √©valuer positivement cette approche de la formation. </font><font style="vertical-align: inherit;">Si vous avez aim√© mes id√©es, assurez-vous de soutenir l'article. </font><font style="vertical-align: inherit;">Si elle obtient une note de plus de 30, je promets de continuer. </font><font style="vertical-align: inherit;">Lors de la r√©daction de l'article, j'ai essay√© de montrer exactement les connaissances de Spring Core, qui est le plus souvent utilis√©, et √©galement bas√© sur le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guide d'√©tude de certification Core Spring 5.0</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">√Ä l'avenir, √† l'aide de ces didacticiels, vous pourrez couvrir l'int√©gralit√© de la certification et rendre le printemps plus accessible aux d√©veloppeurs Java.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mise √† jour 05/10/2018 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des lettres me viennent constamment avec des questions "et quand la suite, on l'attend." </font><font style="vertical-align: inherit;">Mais il n'y a pas de temps du tout, et d'autres projets personnels sont une priorit√©. </font><font style="vertical-align: inherit;">Cependant, si l'un d'entre vous a vraiment aim√© l'id√©e, vous pouvez √©tudier la section √©troite du ressort et √©crire un article de suite. </font><font style="vertical-align: inherit;">Si vous n'avez pas de compte habr, je peux publier un article depuis mon compte ou vous aider √† obtenir une invitation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distribution des sujets: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Container - [nom d'utilisateur] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring AOP - [nom d'utilisateur] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Web - [nom d'utilisateur] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Cloud - [nom d'utilisateur]</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419679/">https://habr.com/ru/post/fr419679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr419665/index.html">L'exp√©rience de l'utilisation de LoRaWAN dans le syst√®me ASKUE en conditions r√©elles de la ville</a></li>
<li><a href="../fr419669/index.html">Dix meilleures souris de jeu pour tout portefeuille</a></li>
<li><a href="../fr419671/index.html">Limitations qui doivent √™tre viol√©es ou comment nous avons acc√©l√©r√© trois fois les tests fonctionnels</a></li>
<li><a href="../fr419673/index.html">L'univers primitif 6. La dynamique d'un univers en expansion homog√®ne, partie 2</a></li>
<li><a href="../fr419677/index.html">Comment renifler le trafic HTTPS d'un appareil iOS</a></li>
<li><a href="../fr419683/index.html">Que signifient les m√©triques pour les √©quipes agiles?</a></li>
<li><a href="../fr419685/index.html">Les structures de donn√©es les plus importantes que vous devez savoir sur votre entretien de programmation</a></li>
<li><a href="../fr419687/index.html">Secret Keyboard Level 3 ou comment imprimer un long tiret</a></li>
<li><a href="../fr419689/index.html">I. D√©sadaptation. II. TDAH ou cr√©tin paresseux?</a></li>
<li><a href="../fr419693/index.html">Mikrotik: r√©initialisation, sauvegardes et DualBoot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>