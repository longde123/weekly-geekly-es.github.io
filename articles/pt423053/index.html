<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê° ü§ù üññüèø Struct e readonly: como evitar a degrada√ß√£o do desempenho üå∞ üò§ ü§ΩüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√Äs vezes, o uso do tipo Struct e do modificador readonly pode causar degrada√ß√£o no desempenho. Hoje falaremos sobre como evitar isso usando um analisa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Struct e readonly: como evitar a degrada√ß√£o do desempenho</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/423053/">  √Äs vezes, o uso do tipo Struct e do modificador readonly pode causar degrada√ß√£o no desempenho.  Hoje falaremos sobre como evitar isso usando um analisador de c√≥digo-fonte aberto - ErrorProne.NET. <br><br><img src="https://habrastorage.org/webt/wc/aa/xn/wcaaxny16t6cvqvl2euetypst3o.jpeg"><a name="habracut"></a><br><br>  Como voc√™ provavelmente sabe das minhas publica√ß√µes anteriores, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O modificador 'in' e as estruturas somente leitura em C #</a> " ("O modificador nas estruturas e somente leitura em C #") e " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intercepta√ß√µes de desempenho de locais de refer√™ncia e retornos de ref em C #</a> " (" Armadilhas de desempenho ao usar vari√°veis ‚Äã‚Äãlocais e retornar valores com o modificador ref)), trabalhar com estruturas √© mais dif√≠cil do que parece.  Deixando de lado a quest√£o da mutabilidade, observo que o comportamento de estruturas com modificador somente leitura (somente leitura) e sem ele em contextos somente leitura varia muito. <br><br>  Sup√µe-se que as estruturas sejam usadas em scripts de programa√ß√£o que exijam alto desempenho e, para trabalhar efetivamente com elas, voc√™ deve saber algo sobre as v√°rias opera√ß√µes ocultas geradas pelo compilador para garantir que a estrutura permane√ßa inalterada. <br><br>  Aqui est√° uma breve lista de cuidados que voc√™ deve lembrar: <br><br><ul><li>  O uso de grandes estruturas que s√£o passadas ou retornadas por valor pode causar problemas de desempenho nos caminhos cr√≠ticos de execu√ß√£o do programa. </li><li> <code>xY</code> faz com que uma c√≥pia protetora de x seja criada se: <br><ul><li>  <code>x</code> √© um campo somente leitura; </li><li>  o tipo <code>x</code> √© uma estrutura sem modificador somente leitura; </li><li>  <code>Y</code> n√£o √© um campo. </li></ul></li></ul><br>  As mesmas regras funcionam se x for um par√¢metro com o modificador in, uma vari√°vel local com o modificador readonly ref ou o resultado da chamada de um m√©todo que retorne um valor por meio de uma refer√™ncia readonly. <br><br>  Aqui est√£o algumas regras a serem lembradas.  E, o mais importante, o c√≥digo que se baseia nessas regras √© muito fr√°gil (ou seja, as altera√ß√µes feitas no c√≥digo imediatamente produzem altera√ß√µes significativas em outras partes do c√≥digo ou da documenta√ß√£o - aprox. Transl.).  Quantas pessoas perceber√£o que a substitui√ß√£o do <code>public readonly int X</code> ;  no <code>public int X { get; }</code>  <code>public int X { get; }</code> em uma estrutura frequentemente usada sem modificador somente leitura afeta significativamente o desempenho?  Ou qu√£o f√°cil √© ver que a passagem de um par√¢metro usando o modificador in em vez de a passagem por valor pode diminuir o desempenho?  Isso √© realmente poss√≠vel ao usar a propriedade in de um par√¢metro em um loop, quando uma c√≥pia protetora √© criada a cada itera√ß√£o. <br><br>  Tais propriedades das estruturas apelam literalmente ao desenvolvimento de analisadores.  E a liga√ß√£o foi ouvida.  Conhe√ßa o <a href="">ErrorProne.NET</a> - um conjunto de analisadores que informa sobre a possibilidade de alterar o c√≥digo do programa para melhorar seu design e desempenho ao trabalhar com estruturas. <br><br><h2>  An√°lise de c√≥digo com sa√≠da de mensagem "Tornar a estrutura X somente leitura" </h2><br>  A melhor maneira de evitar erros sutis e impactos negativos no desempenho ao usar estruturas √© torn√°-las somente leitura sempre que poss√≠vel.  O modificador somente leitura na declara√ß√£o da estrutura expressa claramente a inten√ß√£o do desenvolvedor (enfatizando que a estrutura √© imut√°vel) e ajuda o compilador a evitar c√≥pias de seguran√ßa em muitos dos contextos mencionados acima. <br><br><img src="https://habrastorage.org/webt/tx/fp/5v/txfp5vx1h-8wtkuv_9epx4ulsqe.png"><br><br>  Declarar uma estrutura somente leitura n√£o viola a integridade do c√≥digo.  Voc√™ pode executar com seguran√ßa o fixador (o processo de corre√ß√£o do c√≥digo) no modo em lote e declarar todas as estruturas de toda a solu√ß√£o de software como somente leitura. <br><br><h2>  Simpatia pelo modificador readonly ref </h2><br>  O pr√≥ximo passo √© avaliar a seguran√ßa do uso de novos recursos (no modificador, vari√°veis ‚Äã‚Äãlocais de leitura, vari√°veis ‚Äã‚Äãref, etc.).  Isso significa que o compilador n√£o criar√° c√≥pias protetoras ocultas que podem reduzir o desempenho. <br><br>  Tr√™s tipos de tipos podem ser considerados: <br><br><ul><li>  ref estruturas amig√°veis ‚Äã‚Äãsomente para leitura, cujo uso nunca leva √† cria√ß√£o de c√≥pias protetoras; </li><li>  estruturas que n√£o s√£o f√°ceis de refazer somente leitura, cujo uso no contexto de somente leitura sempre leva √† cria√ß√£o de c√≥pias protetoras; </li><li>  estruturas neutras - estruturas cujo uso pode dar origem a c√≥pias protetoras, dependendo do membro usado no contexto somente leitura. </li></ul><br>  A primeira categoria inclui estruturas somente leitura e estruturas POCO.  O compilador nunca ir√° gerar uma c√≥pia protetora se a estrutura for somente leitura.  Tamb√©m √© seguro usar estruturas POCO no contexto somente leitura: o acesso aos campos √© considerado seguro e nenhuma c√≥pia protetora √© criada. <br><br>  A segunda categoria √© estruturas sem modificador somente leitura que n√£o cont√™m campos abertos.  Nesse caso, qualquer acesso ao membro p√∫blico no contexto somente leitura causar√° a cria√ß√£o de uma c√≥pia protetora. <br><br>  A √∫ltima categoria s√£o estruturas com campos p√∫blicos ou internos e propriedades ou m√©todos p√∫blicos ou internos.  Nesse caso, o compilador cria c√≥pias protetoras, dependendo do membro usado. <br><br>  Essa separa√ß√£o ajuda a gerar avisos instantaneamente se a estrutura "hostil" for passada com o modificador in, armazenada na vari√°vel local ref somente leitura, etc. <br><br><img src="https://habrastorage.org/webt/nc/5a/0p/nc5a0pkfa3xsvrzqxznstyxn5yc.png"><br><br>  O analisador n√£o exibe um aviso se a estrutura "hostil" for usada como um campo somente leitura, pois n√£o h√° alternativa nesse caso.  Os modificadores in e ref readonly foram projetados para serem otimizados especificamente para evitar a cria√ß√£o de c√≥pias redundantes.  Se a estrutura for "hostil" com rela√ß√£o a esses modificadores, voc√™ ter√° outras op√ß√µes: passar um argumento por valor ou salvar uma c√≥pia em uma vari√°vel local.  Nesse sentido, os campos somente leitura se comportam de maneira diferente: se voc√™ deseja tornar o tipo imut√°vel, deve usar esses campos.  Lembre-se: o c√≥digo deve ser claro e elegante, e apenas secundariamente r√°pido. <br><br><h2>  An√°lise Cco </h2><br>  O compilador executa muitas a√ß√µes ocultas do usu√°rio.  Como mostrado em uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">postagem</a> anterior, √© muito dif√≠cil ver quando uma c√≥pia protetora est√° sendo criada. <br><br>  O analisador detecta as seguintes c√≥pias ocultas: <br><br><ol><li>  Cco do campo somente leitura. </li><li>  Cco de in. </li><li>  Cco da vari√°vel local somente leitura ref. </li><li>  Cco retornar ref somente leitura. </li><li>  Cco ao chamar um m√©todo de extens√£o que aceita um par√¢metro com esse modificador por valor para uma inst√¢ncia da estrutura. </li></ol><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> NonReadOnlyStruct { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> PublicField; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> PublicProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PublicMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NonReadOnlyStruct _ros; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Samples</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> NonReadOnlyStruct nrs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Ok. Public field access causes no hidden copies var x = nrs.PublicField; // Ok. No hidden copies. x = _ros.PublicField; // Hidden copy: Property access on 'in'-parameter x = nrs.PublicProperty; // Hidden copy: Method call on readonly field _ros.PublicMethod(); ref readonly var local = ref nrs; // Hidden copy: method call on ref readonly local local.PublicMethod(); // Hidden copy: method call on ref readonly return Local().PublicMethod(); ref readonly NonReadOnlyStruct Local() =&gt; ref _ros; } }</span></span></code> </pre> <br>  Observe que os analisadores exibem mensagens de diagn√≥stico apenas se o tamanho da estrutura for ‚â• 16 bytes. <br><br><h2>  Usando analisadores em projetos reais </h2><br>  A transfer√™ncia de grandes estruturas por valor e, como resultado, a cria√ß√£o de c√≥pias protetoras pelo compilador afetam significativamente o desempenho.  Pelo menos isso √© mostrado pelos resultados dos testes de desempenho.  Mas como esses fen√¥menos afetar√£o aplica√ß√µes reais em termos de tempo de ponta a ponta? <br><br>  Para testar os analisadores usando c√≥digo real, usei-os em dois projetos: o projeto Roslyn e o projeto interno no qual estou trabalhando atualmente na Microsoft (o projeto √© um aplicativo de computador aut√¥nomo com requisitos r√≠gidos de desempenho);  vamos cham√°-lo de "Projeto D" para maior clareza. <br><br>  Aqui est√£o os resultados: <br><br><ol><li>  Projetos com requisitos de alto desempenho geralmente cont√™m muitas estruturas, e a maioria delas pode ser somente leitura.  Por exemplo, no projeto Roslyn, o analisador encontrou cerca de 400 estruturas que podem ser apenas de leitura e, no projeto D, cerca de 300. </li><li>  Em projetos com requisitos de alto desempenho, c√≥pias ocultas s√≥ devem ser criadas em situa√ß√µes excepcionais.  Encontrei apenas alguns casos no projeto Roslyn, j√° que a maioria das estruturas possui campos p√∫blicos em vez de propriedades p√∫blicas.  Isso evita a cria√ß√£o de c√≥pias protetoras em situa√ß√µes em que as estruturas s√£o armazenadas em campos somente leitura.  Havia mais c√≥pias ocultas no Projeto D, porque pelo menos metade delas possu√≠a propriedades de obten√ß√£o apenas (acesso somente leitura). </li><li>  A transfer√™ncia de estruturas razoavelmente grandes usando o modificador in provavelmente ter√° muito pouco efeito (quase impercept√≠vel) no tempo de execu√ß√£o do programa. </li></ol><br>  Alterei todas as 300 estruturas no projeto D, tornando-as somente leitura e, em seguida, corrigi centenas de casos de uso, indicando que elas s√£o passadas com o modificador in.  Depois, medi o tempo de tr√¢nsito de ponta a ponta para v√°rios cen√°rios de desempenho.  As diferen√ßas foram estatisticamente insignificantes. <br><br>  Isso significa que os recursos descritos acima s√£o in√∫teis?  Nem um pouco. <br><br>  Trabalhar em um projeto com requisitos de alto desempenho (por exemplo, em Roslyn ou "Projeto D") implica que um grande n√∫mero de pessoas gasta muito tempo em v√°rios tipos de otimiza√ß√£o.  De fato, em alguns casos, estruturas em nosso c√≥digo foram passadas com o modificador ref e alguns campos foram declarados sem o modificador somente leitura para excluir a gera√ß√£o de c√≥pias protetoras.  A falta de crescimento da produtividade durante a transfer√™ncia de estruturas com o modificador in pode significar que o c√≥digo foi bem otimizado e n√£o h√° c√≥pia excessiva de estruturas nos caminhos cr√≠ticos de sua passagem. <br><br><h2>  O que devo fazer com esses recursos? </h2><br>  Acredito que a quest√£o do uso do modificador readonly para estruturas n√£o exija muita reflex√£o.  Se a estrutura for imut√°vel, o modificador somente leitura obriga explicitamente o compilador a tomar uma decis√£o de design.  E a falta de c√≥pias protetoras para essas estruturas √© apenas um b√¥nus. <br><br>  Hoje, minhas recomenda√ß√µes s√£o as seguintes: se a estrutura pode ser apenas de leitura, fa√ßa com que seja assim. <br><br>  O uso das outras op√ß√µes consideradas possui nuances. <br><br><h2>  Pr√©-otimiza√ß√£o versus pr√©-pessimiza√ß√£o? </h2><br>  Herb Sutter introduz o conceito de "pessimiza√ß√£o preliminar" em seu livro incr√≠vel, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C ++ Coding Standards: 101 Rule, Recomendations, and Best Practices</a> . <br><br>  ‚ÄúCeteris paribus, complexidade e legibilidade do c√≥digo, alguns padr√µes de design eficazes e idiomas de codifica√ß√£o devem drenar naturalmente da ponta dos dedos.  Esse c√≥digo n√£o √© mais dif√≠cil de escrever do que suas alternativas pessimizadas.  Voc√™ n√£o faz otimiza√ß√£o preliminar, mas evita a pessimiza√ß√£o volunt√°ria. ‚Äù <br><br>  Do meu ponto de vista, um par√¢metro com o modificador in √© apenas o caso.  Se voc√™ souber que a estrutura √© relativamente grande (40 bytes ou mais), sempre poder√° transmiti-la com o modificador in.  O custo do uso do modificador in √© relativamente baixo, porque voc√™ n√£o precisa ajustar as chamadas e os benef√≠cios podem ser reais. <br><br>  Por outro lado, para vari√°veis ‚Äã‚Äãlocais e valores de retorno com o modificador ref somente leitura, este n√£o √© o caso.  Eu diria que esses recursos devem ser usados ‚Äã‚Äãao codificar bibliotecas, e √© melhor recus√°-los no c√≥digo do aplicativo (somente se a cria√ß√£o de perfil do c√≥digo n√£o revelar que a opera√ß√£o de c√≥pia √© realmente um problema).  O uso desses recursos requer um esfor√ßo adicional e fica mais dif√≠cil para o leitor de c√≥digo entender. <br><br><h2>  Conclus√£o </h2><br><ol><li>  Use modificador somente leitura para estruturas sempre que poss√≠vel. </li><li>  Considere usar o modificador in para estruturas grandes. </li><li>  Considere usar vari√°veis ‚Äã‚Äãlocais e retornar valores com o modificador ref somente leitura para codificar bibliotecas ou nos casos em que os resultados da cria√ß√£o de perfil de c√≥digo indiquem que isso pode ser √∫til. </li><li>  Use o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ErrorProne.NET</a> para detectar problemas de c√≥digo e compartilhar os resultados. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423053/">https://habr.com/ru/post/pt423053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423043/index.html">Devido a uma vulnerabilidade no sistema de prote√ß√£o de ve√≠culo el√©trico Tesla, um carro pode ser roubado em alguns segundos</a></li>
<li><a href="../pt423045/index.html">Qual impressora 3D escolher? Revis√£o de v√≠deo 3Dtool</a></li>
<li><a href="../pt423047/index.html">Reservamos sistemas de TI por dinheiro razo√°vel</a></li>
<li><a href="../pt423049/index.html">Processos de aprendizado no Linux</a></li>
<li><a href="../pt423051/index.html">A luta por recursos, parte 1: No√ß√µes b√°sicas de Cgroups</a></li>
<li><a href="../pt423055/index.html">Analistas de Wall Street: ‚ÄúA Apple nos fez comer nossos chap√©us‚Äù</a></li>
<li><a href="../pt423057/index.html">Python tamb√©m recusa parcialmente os termos mestre / escravo</a></li>
<li><a href="../pt423059/index.html">Melhor do que dizem: Tr√™s itens essenciais para o pr√≥ximo MacBook ser um dos melhores laptops da Apple</a></li>
<li><a href="../pt423061/index.html">ref locais e retornos ref em C #: armadilhas de desempenho</a></li>
<li><a href="../pt423063/index.html">Epson WorkForce Pro: Cr√¥nicas de como um escrit√≥rio a jato de tinta imprime "puxou um cobertor" de um laser e o que aconteceu hoje</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>