<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝️ 📈 🙆🏽 Optimierung relationaler Datenbanken ohne Ausfallzeiten am Beispiel der am meisten geladenen Datenbank in Badoo 📯 👆🏽 👉🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unter Hochlastbedingungen steigt die Komplexität der Optimierung relationaler Datenbanken um eine Größenordnung, da der Kauf noch leistungsfähigerer H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung relationaler Datenbanken ohne Ausfallzeiten am Beispiel der am meisten geladenen Datenbank in Badoo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/433730/"><img src="https://habrastorage.org/webt/kh/bf/3m/khbf3mojp_5d2lgszln2zsljisy.png"><br><br>  Unter Hochlastbedingungen steigt die Komplexität der Optimierung relationaler Datenbanken um eine Größenordnung, da der Kauf noch leistungsfähigerer Hardware teuer ist und es nicht möglich ist, die Anwendung nachts nur für einen langen Datenbankänderungsprozess und eine Datenmigration auszuschalten. <br><br>  Wir haben kürzlich darüber gesprochen, wie wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den PHP-Code für unsere Anwendung optimiert haben</a> .  Jetzt ist die Wende des Artikels gekommen, wie wir die interne Struktur der am meisten geladenen und wichtigsten Datenbank in Badoo vollständig geändert haben, ohne eine einzige Anfrage zu verlieren. <br><a name="habracut"></a><br><h2>  Patient </h2><br>  Users DataBase oder UDB ist ein Dienst, der fast jede Anfrage an Badoo startet.  Es löst mehrere Probleme: Erstens ist es das zentrale Repository der Hauptbenutzerdaten, für die die Autorisierung erfolgt (z. B. E-Mail, Benutzer-ID oder Facebook-ID).  Zusätzlich zum Speichern dieser Daten bietet der Dienst eine Eindeutigkeitskontrolle (sodass sich zwei Benutzer mit derselben E-Mail-Adresse, facebook_id usw. nicht im System registrieren können).  Der gleiche Dienst gibt Auskunft darüber, welcher der Tausenden von Shards alle anderen Benutzerdaten enthält. <br><br>  Ende 2018 speichert UDB Daten von mehr als 800 Millionen Benutzern, die etwa 1 TB Speicherplatz belegen.  All dies wird von zwei Master-Slave-MySQL-Servern in jedem unserer Rechenzentren bereitgestellt.  Insgesamt verarbeiten sie mehr als 140.000 Anfragen pro Sekunde. <br><br>  Der Fall von UDB bedeutet die Unzugänglichkeit aller Badoo, da der Code den Shard nicht finden kann, auf dem die Benutzerdaten liegen.  Daher werden hohe Anforderungen an Zuverlässigkeit und Verfügbarkeit gestellt. <br><br>  Aufgrund dieser Besonderheit ist es sehr teuer, Änderungen an der Speicherstruktur vorzunehmen. Daher haben wir das UDB-Design 2013 sehr ernst genommen.  Im Laufe der Zeit ändern sich jedoch sowohl die Anforderungen als auch die Lastprofile.  In dem Bestreben, das System an neue Anforderungen und Lastniveaus anzupassen, wurden viele kleine und einfache Änderungen vorgenommen, aber leider sind solche Änderungen bei weitem nicht die effektivsten.  Und der Tag kam, an dem es klüger war, anstelle des nächsten Hacks oder des Kaufs teurer Hardware globaler zu optimieren.  Weiter werden wir die Hauptphasen dieses Weges betrachten. <br><br><h2>  Nicht-invasive Optimierungen </h2><br>  Änderungen an der Struktur einer großen und geladenen Datenbank sind aufgrund der Komplexität des Datenmigrationsprozesses recht teuer.  Daher sollten Sie zunächst alle Optimierungsoptionen ausschöpfen, die sich nicht auf die Datenstruktur auswirken, sondern auf Code- und SQL-Abfragen beschränkt sind.  Vielleicht reicht dies aus, um das Problem der übermäßigen Arbeitsbelastung um ein paar Jahre zu verschieben, sodass Sie zu diesem Zeitpunkt etwas Wichtigeres für das Unternehmen tun können. <br><br>  Je besser Sie Ihr System verstehen, desto einfacher wird es für Sie, Ansätze für solche Optimierungen zu finden.  Stellen Sie sicher, dass Sie alle Metriken sammeln, die Ihnen helfen können.  Hierbei handelt es sich nicht nur um Systemmetriken wie CPU-Auslastung und RAM-Auslastung oder die Metriken einer bestimmten Datenbank, sondern auch um Metriken auf Anwendungsebene einer Anwendung, die an eine optimierte Datenbank gebunden ist.  Wie viele Anfragen pro Sekunde haben verschiedene Arten von Operationen?  Was ist ihre Reaktionszeit?  Wie groß ist die Ein- und Ausgabe?  Anhand dieser Metriken können Sie den Erfolg der Optimierung beurteilen.  Es ist unwahrscheinlich, dass Sie eine Optimierung benötigen, die die CPU-Auslastung auf dem Datenbankserver geringfügig verringert, gleichzeitig aber die Antwortzeit Ihrer Anwendung um das Zehnfache erhöht. <br><br><img src="https://habrastorage.org/webt/o_/wv/t0/o_wvt02zorm3oqwxxjvgeuwvz9m.png"><br><br>  Nachdem wir begonnen hatten, zusätzliche Metriken auf Anwendungsebene für UDB zu sammeln, konnten wir besser verstehen, welche der durchgeführten Vorgänge 80% der Last verursachen und die ersten Kandidaten für das Studium sind und welche nur wenig oder gar nicht verwendet werden. <br><br>  Eine detaillierte Analyse des häufigsten Vorgangs (Abrufen von Benutzern, die bestimmte Kriterien erfüllen) ergab, dass die Anwendung in 95% der Fälle nur user_id verwendet, obwohl alle verfügbaren Benutzerdaten aus der Datenbank angefordert werden.  Durch die Aufteilung dieses Falls in eine separate API-Methode, die nur eine Spalte aus der Tabelle extrahiert, konnten wir von der Verwendung des Deckungsindex profitieren und damit etwa 5% der CPU-Auslastung vom Datenbankserver entfernen. <br><br>  Die Analyse eines anderen häufigen Vorgangs ergab, dass die abgerufenen Daten trotz der Tatsache, dass sie für jede HTTP-Anforderung ausgeführt werden, in der Realität äußerst selten sind.  Wir haben diese Anfrage in ein faules Modell übersetzt. <br><br>  Das Hauptziel von Metriken im Fall eines Optimierungsprojekts besteht darin, Ihre Datenbank besser zu verstehen und die dicksten Teile zu finden.  Es macht keinen Sinn, viel Zeit und Mühe in die Optimierung von Abfragen zu investieren, die weniger als 1% Ihres Lastprofils ausmachen.  Wenn Sie keine Metriken haben, mit denen Sie das Profil Ihrer Last verstehen können, sammeln Sie sie.  Mit solchen Optimierungen auf der Codeseite ist es uns gelungen, etwa 15% der CPU-Auslastung aus 80% der verbrauchten Datenbank zu entfernen. <br><br><h2>  Ideen testen </h2><br>  Wenn Sie eine geladene Datenbank durch Ändern ihrer Struktur optimieren möchten, sollten Sie zunächst Ihre Ideen auf einem Prüfstand überprüfen, da selbst Optimierungen, die theoretisch sehr vielversprechend aussehen, in der Praxis möglicherweise keine positiven Auswirkungen haben (und manchmal sogar negative Auswirkungen haben).  Und es ist unwahrscheinlich, dass Sie dies erst nach einer langen Datenmigration in der Produktion wissen möchten. <br><br>  Je näher Ihre Standkonfiguration an der Produktionskonfiguration liegt, desto zuverlässiger erhalten Sie Ergebnisse.  Ein wichtiger Punkt ist die korrekte Belastung des Ständers.  Das Ausführen von zufälligen oder denselben Abfragen kann zu falschen Ergebnissen führen.  Die beste Option ist die Verwendung realer Anforderungen aus der Produktion.  Für UDB haben wir jede zehnte API-Leseanforderung (einschließlich Parameter) in Form eines JSON-Protokolls in einer Datei aus der Produktion protokolliert.  Für einen Tag haben wir aus 700 Millionen Anfragen ein Protokoll mit einer Größe von 65 GB gesammelt. <br><br>  Wir haben den Datensatz nicht getestet, da er im Vergleich zur Anzahl der Leseanforderungen sehr klein ist und unsere Last nicht beeinflusst.  Dies ist jedoch in Ihrem Fall möglicherweise nicht der Fall.  Wenn Sie den Prüfstand mit Schreibanforderungen laden möchten, müssen Sie jede Anforderung erfassen, da das Überspringen von Schreibanforderungen zu Konsistenzfehlern auf dem Prüfstand führen kann. <br><br>  Der nächste Schritt besteht darin, das Protokoll auf dem Stand korrekt zu verlieren.  Wir haben 400 PHP-Mitarbeiter verwendet, die über unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Skript-Cloud</a> gestartet wurden und das gesammelte Protokoll aus der schnellen Warteschlange lesen und Anforderungen nacheinander ausführen.  In diesem Fall wird die Warteschlange mit einem anderen Skript mit einer genau definierten Geschwindigkeit gefüllt.  Zum Testen von Ideen haben wir die Geschwindigkeit von x10 verwendet, die multipliziert mit der Tatsache, dass wir nur jede zehnte Anfrage aus der Produktion gesammelt haben, die gleiche Anzahl von RPS ergab wie in der Produktion. <br><br><img src="https://habrastorage.org/webt/p2/9p/ya/p29pyak41t3rygstxym5kguf3gm.png"><br><br>  Mit diesen Koeffizienten stellt sich heraus, dass der Produktionstag mit allen Lastabfällen auf dem Prüfstand in nur zweieinhalb Stunden fliegt. <br><br>  So sah beispielsweise der erste Test, den wir einen halben Tag lang mit einer Geschwindigkeit von x5 (50% der Produktionslast) im Abfrageprotokoll durchgeführt haben, folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/4l/3z/sg/4l3zsggyvo-yklup3xmnl9x-0de.png"><br><br>  Dieselben Werkzeuge können zur Durchführung eines Fehlertests verwendet werden: Erhöhen der Geschwindigkeit (und damit des RPS), bis sich die Basis am Stand zu verschlechtern beginnt.  Auf diese Weise erhalten Sie ein klares Verständnis dafür, wie viel mehr Last Ihre Datenbank aushalten kann. <br><br>  Nach dem Testen des neuen Datenschemas ist es auch wichtig, einen Kontrolltest für die ursprüngliche Datenbankstruktur durchzuführen.  Wenn die Ergebnisse und die aktuelle Leistung in der Produktion sehr unterschiedlich sind, sollten Sie zuerst die Gründe verstehen.  Möglicherweise ist der Testserver falsch konfiguriert und Sie können den Lasttestdaten nicht vertrauen. <br><br>  Es lohnt sich auch sicherzustellen, dass der neue Code korrekt funktioniert.  Es ist wenig sinnvoll, die Leistung von Abfragen zu testen, die den Job nicht ausführen.  Integrationstests, bei denen überprüft wird, ob die alte und die neue API bei denselben API-Aufrufen dieselben Werte zurückgeben, werden Sie gut bedienen. <br><br>  Nachdem Sie zu allen Ideen Ergebnisse erhalten haben, müssen Sie nur noch Optionen mit dem besten Gleichgewicht zwischen Preis und Qualität auswählen und ein neues Produktionsschema einführen. <br><br><h2>  Schemaänderung </h2><br>  Zunächst stelle ich fest, dass das Ändern des Datenschemas ohne Unterbrechung des Betriebs des Dienstes immer recht schwierig, teuer und riskant ist.  Wenn Sie also die Möglichkeit haben, Ihre Anwendung zu stoppen, während Sie die Struktur ändern, tun Sie es einfach.  Bei UDB konnten wir uns das leider nicht leisten. <br><br>  Der zweite Faktor, der die Komplexität der Änderung einer Schaltung beeinflusst, ist das geplante Ausmaß der Änderung.  Wenn alle vorgeschlagenen Änderungen an den Tabellen nicht über eine Änderung hinausgehen (z. B. Hinzufügen eines Paares neuer Indizes oder Spalten), können Sie sie mit typischen Prozessen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pt-online-schema-change</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gh-ost</a> für MySQL oder einem alternativen Slave <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">starten</a> und anschließend ihre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Positionen</a> ändern . <br><br>  In unserem Fall wurde ein hervorragendes Ergebnis beim vertikalen Sharding einer etwa ein Dutzend kleineren riesigen Tabelle mit anderen Spalten, Indizes und Daten in einem anderen Format gezeigt.  Eine solche Konvertierung mit typischen Werkzeugen ist nicht mehr möglich.  Was tun? <br><br>  Wir haben den folgenden Algorithmus angewendet: <br><br><ol><li>  Wir erreichen einen Zustand, in dem sowohl das alte als auch das neue Schema mit aktuellen Daten gleichzeitig existieren.  Die Aufzeichnung erfolgt in beiden Versionen, und gleichzeitig besteht in beiden Versionen eine Garantie für die Datenkonsistenz.  Wir werden diesen Punkt unten im Detail betrachten. <br></li><li>  Schalten Sie den gesamten Messwert schrittweise auf einen neuen Stromkreis um und steuern Sie die Last. <br></li><li>  Schalten Sie die Aufnahme im alten Schema aus und löschen Sie sie. <br></li></ol><br>  Die Hauptvorteile dieses Ansatzes: <br><br><ul><li>  Sicherheit: Es besteht die Möglichkeit eines sofortigen Rollbacks bis zur letzten Stufe (schalten Sie den Messwert einfach auf das alte Schema zurück, wenn ein Fehler aufgetreten ist). <br></li><li>  Volllastkontrolle während der Datenmigration; <br></li><li>  Es ist keine schwere Änderung des großen Tisches der alten Schaltung erforderlich. <br></li></ul><br>  Es gibt jedoch auch Nachteile: <br><br><ul><li>  Die Notwendigkeit, beide Versionen der Schemas während des Migrationsprozesses auf der Festplatte zu belassen (dies kann ein Problem sein, wenn Sie wenig Speicherplatz haben und die zu migrierende Tabelle sehr groß ist). <br></li><li>  viel temporärer Code zur Unterstützung des Migrationsprozesses, der nach Abschluss abgeschnitten wird; <br></li><li>  Es ist möglich, den Cache durch paralleles Lesen aus zwei Schemata zu waschen.  Es bestand die Befürchtung, dass die alte und die neue Version um RAM konkurrieren könnten, was zu einer Verschlechterung des Dienstes führen könnte (in Wirklichkeit verursachte dies eine zusätzliche Belastung, da die Migration jedoch außerhalb der Spitzenzeiten durchgeführt wurde, verursachte dies keine Probleme für uns). <br></li></ul><br>  Die Hauptschwierigkeit bei diesem Algorithmus ist der erste Punkt.  Wir werden es im Detail betrachten. <br><br><h2>  Synchronisierung ändern </h2><br>  Die Migration statischer Daten ist nicht besonders schwierig.  Was ist jedoch, wenn Sie nicht einfach die gesamte Aufzeichnung stoppen können, während die Datenbank migriert wird? <br><br>  Es gibt verschiedene Optionen, um eine Synchronisierung des neuen Schemas zu erreichen: Migration mit fortlaufendem Protokoll und idempotente Aufzeichnung der Migration. <br><br><h3>  Migrieren eines Datenschnappschusses und anschließende Wiedergabe des Protokolls der folgenden Änderungen </h3><br>  Jede Datenaktualisierungstransaktion wird durch Trigger entweder auf Anwendungsebene in einer speziellen Tabelle protokolliert, oder das Replikations-Binlog wird als Protokoll verwendet.  Nachdem Sie ein solches Protokoll erstellt haben, können Sie eine Transaktion öffnen und einen Datenschnappschuss migrieren, wobei Sie sich die Position im Protokoll merken.  Dann muss noch begonnen werden, das gesammelte Protokoll auf das neue Schema anzuwenden.  In ähnlicher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weise funktioniert</a> beispielsweise das beliebte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Backup-Tool</a> MySQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Percona XtraBackup</a> . <br><br>  Nachdem das neue Schema das Protokoll des aktuellen Datensatzes eingeholt hat, beginnt die wichtigste Phase: Sie müssen die Aufzeichnung im alten Schema noch für einen kurzen Zeitraum anhalten und sicherstellen, dass das gesamte verfügbare Protokoll auf das neue Schema angewendet wird. Dies bedeutet, dass die Daten zwischen den Schemata konsistent sind. Aktivieren Sie auf Anwendungsebene die gleichzeitige Aufzeichnung in beiden Quellen. <br><br>  Die Hauptnachteile dieses Ansatzes sind, dass Sie das Betriebsprotokoll irgendwie speichern müssen, was an sich eine Last im komplexen Schaltprozess erzeugen kann, sowie in der Wahrscheinlichkeit, den Rekord zu brechen, wenn sich die Schaltkreise aus irgendeinem Grund als inkonsistent herausstellen. <br><br><h3>  Idempotenter Rekord </h3><br>  Die Hauptidee dieses Ansatzes besteht darin, parallel zum Schreiben in das alte Schema zu schreiben, bevor die Änderungen vollständig synchronisiert sind, und dann die Migration der verbleibenden Daten abzuschließen.  Ebenso werden normalerweise neue Spalten in große Tabellen gefüllt. <br><br>  Die synchrone Aufzeichnung kann sowohl bei Datenbank-Triggern als auch im Quellcode implementiert werden.  Ich rate Ihnen, dies genau im Code zu tun, da Sie in jedem Fall irgendwann Code schreiben müssen, der Daten in das neue Schema schreibt, und die Implementierung der Migration auf der Codeseite Ihnen mehr Kontrolle bietet. <br><br>  Ein wichtiger zu berücksichtigender Punkt ist, dass sich das neue Schema bis zum Abschluss der Migration in einem inkonsistenten Zustand befindet.  Aus diesem Grund ist ein Szenario möglich, wenn das Aktualisieren einer neuen Tabelle zu einer Verletzung der Datenbankkonstante (Fremdschlüssel oder ein eindeutiger Index) führt, während die Transaktion aus Sicht des aktuellen Schemas vollständig korrekt ist und ausgeführt werden sollte. <br><br>  Diese Situation kann aufgrund des Migrationsprozesses zu einem Rollback guter Transaktionen führen.  Der einfachste Weg, um dieses Problem zu umgehen, besteht darin, den Modifikator IGNORE zu allen Anforderungen hinzuzufügen, um Daten in ein neues Schema zu schreiben oder das Rollback einer solchen Transaktion abzufangen und die Version auszuführen, ohne in das neue Schema zu schreiben. <br><br>  Der Synchronisationsalgorithmus durch idempotente Aufzeichnung ist in unserem Fall wie folgt: <br><br><ol><li>  Wir aktivieren die Aufzeichnung in einem neuen Schema parallel zur Aufzeichnung im alten im Kompatibilitätsmodus (IGNORE). <br></li><li>  Wir führen ein Skript aus, das das neue Schema schrittweise umgeht und inkonsistente Daten erfasst.  Danach sollten die Daten in beiden Tabellen synchronisiert werden. Dies ist jedoch aufgrund möglicher Konflikte in Abschnitt 1 ungenau. <br></li><li>  Wir starten die Datenkonsistenzprüfung - wir öffnen die Transaktion und lesen nacheinander die Zeilen aus den neuen und alten Schemata, um deren Korrespondenz zu vergleichen. <br></li><li>  Wenn es Konflikte gibt, beenden wir und kehren zu Absatz 3 zurück. <br></li><li>  Nachdem der Prüfer gezeigt hat, dass die Daten in beiden Schemata synchronisiert sind, sollte es keine weiteren Diskrepanzen zwischen den Schemata geben, es sei denn, wir haben natürlich eine Nuance übersehen.  Daher warten wir einige Zeit (z. B. eine Woche) und führen eine Kontrollprüfung durch.  Wenn er zeigt, dass alles in Ordnung ist, ist die Aufgabe erfolgreich abgeschlossen und Sie können die Lesung übersetzen. <br></li></ol><br><h2>  Ergebnisse </h2><br>  Durch die Änderung des Datenformats konnten wir die Größe der Haupttabelle von 544 GB auf 226 GB reduzieren, wodurch die Belastung der Festplatte verringert und die Menge nützlicher Daten erhöht wurde, die in den Arbeitsspeicher passen. <br><br>  Insgesamt konnten wir von Beginn des Projekts an mit allen beschriebenen Ansätzen die CPU-Auslastung des Datenbankservers bei Spitzenverkehr von 80% auf 35% reduzieren.  Die Ergebnisse des anschließenden Stresstests zeigten, dass wir bei der aktuellen Wachstumsrate der Last noch mindestens drei Jahre auf der vorhandenen Hardware bleiben können. <br><br>  Das Aufteilen einer großen Tabelle in mehrere vereinfachte die Durchführung zukünftiger Änderungen in der Datenbank und beschleunigte einige Skripte, die Daten für BI sammelten, erheblich. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433730/">https://habr.com/ru/post/de433730/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433720/index.html">10 Gründe, sich für eine Lösung für SAP HANA von HPE zu entscheiden</a></li>
<li><a href="../de433722/index.html">HeisenBug mit den Augen eines Mitarbeiters von SberTech</a></li>
<li><a href="../de433724/index.html">Eine unangenehme Wahrheit über LDAC</a></li>
<li><a href="../de433726/index.html">Erste Schritte mit der Automatisierungs-API: Teil 1 - Übersicht</a></li>
<li><a href="../de433728/index.html">Google hat das chinesische zensierte Suchmaschinenprojekt aufgrund von Meinungsverschiedenheiten innerhalb des Unternehmens geschlossen</a></li>
<li><a href="../de433732/index.html">Alan Kay: „Welche Bücher würden Sie jemandem empfehlen, der Informatik studiert?“</a></li>
<li><a href="../de433734/index.html">Donald Knuth: „Die älteren Kameraden haben Tennis gespielt, wir waren Bälle. Sie haben uns geschlagen, es hat wehgetan. “ (11,12 / 97)</a></li>
<li><a href="../de433738/index.html">Antiquitäten: Spiele unter MS-DOS, die wir nicht ausgewählt haben</a></li>
<li><a href="../de433740/index.html">Die Staatsduma bricht das nationale Roaming in dritter Lesung ab</a></li>
<li><a href="../de433742/index.html">Turbojet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>