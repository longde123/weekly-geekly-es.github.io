<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùÔ∏è üìà üôÜüèΩ Optimierung relationaler Datenbanken ohne Ausfallzeiten am Beispiel der am meisten geladenen Datenbank in Badoo üìØ üëÜüèΩ üëâüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unter Hochlastbedingungen steigt die Komplexit√§t der Optimierung relationaler Datenbanken um eine Gr√∂√üenordnung, da der Kauf noch leistungsf√§higerer H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung relationaler Datenbanken ohne Ausfallzeiten am Beispiel der am meisten geladenen Datenbank in Badoo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/433730/"><img src="https://habrastorage.org/webt/kh/bf/3m/khbf3mojp_5d2lgszln2zsljisy.png"><br><br>  Unter Hochlastbedingungen steigt die Komplexit√§t der Optimierung relationaler Datenbanken um eine Gr√∂√üenordnung, da der Kauf noch leistungsf√§higerer Hardware teuer ist und es nicht m√∂glich ist, die Anwendung nachts nur f√ºr einen langen Datenbank√§nderungsprozess und eine Datenmigration auszuschalten. <br><br>  Wir haben k√ºrzlich dar√ºber gesprochen, wie wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den PHP-Code f√ºr unsere Anwendung optimiert haben</a> .  Jetzt ist die Wende des Artikels gekommen, wie wir die interne Struktur der am meisten geladenen und wichtigsten Datenbank in Badoo vollst√§ndig ge√§ndert haben, ohne eine einzige Anfrage zu verlieren. <br><a name="habracut"></a><br><h2>  Patient </h2><br>  Users DataBase oder UDB ist ein Dienst, der fast jede Anfrage an Badoo startet.  Es l√∂st mehrere Probleme: Erstens ist es das zentrale Repository der Hauptbenutzerdaten, f√ºr die die Autorisierung erfolgt (z. B. E-Mail, Benutzer-ID oder Facebook-ID).  Zus√§tzlich zum Speichern dieser Daten bietet der Dienst eine Eindeutigkeitskontrolle (sodass sich zwei Benutzer mit derselben E-Mail-Adresse, facebook_id usw. nicht im System registrieren k√∂nnen).  Der gleiche Dienst gibt Auskunft dar√ºber, welcher der Tausenden von Shards alle anderen Benutzerdaten enth√§lt. <br><br>  Ende 2018 speichert UDB Daten von mehr als 800 Millionen Benutzern, die etwa 1 TB Speicherplatz belegen.  All dies wird von zwei Master-Slave-MySQL-Servern in jedem unserer Rechenzentren bereitgestellt.  Insgesamt verarbeiten sie mehr als 140.000 Anfragen pro Sekunde. <br><br>  Der Fall von UDB bedeutet die Unzug√§nglichkeit aller Badoo, da der Code den Shard nicht finden kann, auf dem die Benutzerdaten liegen.  Daher werden hohe Anforderungen an Zuverl√§ssigkeit und Verf√ºgbarkeit gestellt. <br><br>  Aufgrund dieser Besonderheit ist es sehr teuer, √Ñnderungen an der Speicherstruktur vorzunehmen. Daher haben wir das UDB-Design 2013 sehr ernst genommen.  Im Laufe der Zeit √§ndern sich jedoch sowohl die Anforderungen als auch die Lastprofile.  In dem Bestreben, das System an neue Anforderungen und Lastniveaus anzupassen, wurden viele kleine und einfache √Ñnderungen vorgenommen, aber leider sind solche √Ñnderungen bei weitem nicht die effektivsten.  Und der Tag kam, an dem es kl√ºger war, anstelle des n√§chsten Hacks oder des Kaufs teurer Hardware globaler zu optimieren.  Weiter werden wir die Hauptphasen dieses Weges betrachten. <br><br><h2>  Nicht-invasive Optimierungen </h2><br>  √Ñnderungen an der Struktur einer gro√üen und geladenen Datenbank sind aufgrund der Komplexit√§t des Datenmigrationsprozesses recht teuer.  Daher sollten Sie zun√§chst alle Optimierungsoptionen aussch√∂pfen, die sich nicht auf die Datenstruktur auswirken, sondern auf Code- und SQL-Abfragen beschr√§nkt sind.  Vielleicht reicht dies aus, um das Problem der √ºberm√§√üigen Arbeitsbelastung um ein paar Jahre zu verschieben, sodass Sie zu diesem Zeitpunkt etwas Wichtigeres f√ºr das Unternehmen tun k√∂nnen. <br><br>  Je besser Sie Ihr System verstehen, desto einfacher wird es f√ºr Sie, Ans√§tze f√ºr solche Optimierungen zu finden.  Stellen Sie sicher, dass Sie alle Metriken sammeln, die Ihnen helfen k√∂nnen.  Hierbei handelt es sich nicht nur um Systemmetriken wie CPU-Auslastung und RAM-Auslastung oder die Metriken einer bestimmten Datenbank, sondern auch um Metriken auf Anwendungsebene einer Anwendung, die an eine optimierte Datenbank gebunden ist.  Wie viele Anfragen pro Sekunde haben verschiedene Arten von Operationen?  Was ist ihre Reaktionszeit?  Wie gro√ü ist die Ein- und Ausgabe?  Anhand dieser Metriken k√∂nnen Sie den Erfolg der Optimierung beurteilen.  Es ist unwahrscheinlich, dass Sie eine Optimierung ben√∂tigen, die die CPU-Auslastung auf dem Datenbankserver geringf√ºgig verringert, gleichzeitig aber die Antwortzeit Ihrer Anwendung um das Zehnfache erh√∂ht. <br><br><img src="https://habrastorage.org/webt/o_/wv/t0/o_wvt02zorm3oqwxxjvgeuwvz9m.png"><br><br>  Nachdem wir begonnen hatten, zus√§tzliche Metriken auf Anwendungsebene f√ºr UDB zu sammeln, konnten wir besser verstehen, welche der durchgef√ºhrten Vorg√§nge 80% der Last verursachen und die ersten Kandidaten f√ºr das Studium sind und welche nur wenig oder gar nicht verwendet werden. <br><br>  Eine detaillierte Analyse des h√§ufigsten Vorgangs (Abrufen von Benutzern, die bestimmte Kriterien erf√ºllen) ergab, dass die Anwendung in 95% der F√§lle nur user_id verwendet, obwohl alle verf√ºgbaren Benutzerdaten aus der Datenbank angefordert werden.  Durch die Aufteilung dieses Falls in eine separate API-Methode, die nur eine Spalte aus der Tabelle extrahiert, konnten wir von der Verwendung des Deckungsindex profitieren und damit etwa 5% der CPU-Auslastung vom Datenbankserver entfernen. <br><br>  Die Analyse eines anderen h√§ufigen Vorgangs ergab, dass die abgerufenen Daten trotz der Tatsache, dass sie f√ºr jede HTTP-Anforderung ausgef√ºhrt werden, in der Realit√§t √§u√üerst selten sind.  Wir haben diese Anfrage in ein faules Modell √ºbersetzt. <br><br>  Das Hauptziel von Metriken im Fall eines Optimierungsprojekts besteht darin, Ihre Datenbank besser zu verstehen und die dicksten Teile zu finden.  Es macht keinen Sinn, viel Zeit und M√ºhe in die Optimierung von Abfragen zu investieren, die weniger als 1% Ihres Lastprofils ausmachen.  Wenn Sie keine Metriken haben, mit denen Sie das Profil Ihrer Last verstehen k√∂nnen, sammeln Sie sie.  Mit solchen Optimierungen auf der Codeseite ist es uns gelungen, etwa 15% der CPU-Auslastung aus 80% der verbrauchten Datenbank zu entfernen. <br><br><h2>  Ideen testen </h2><br>  Wenn Sie eine geladene Datenbank durch √Ñndern ihrer Struktur optimieren m√∂chten, sollten Sie zun√§chst Ihre Ideen auf einem Pr√ºfstand √ºberpr√ºfen, da selbst Optimierungen, die theoretisch sehr vielversprechend aussehen, in der Praxis m√∂glicherweise keine positiven Auswirkungen haben (und manchmal sogar negative Auswirkungen haben).  Und es ist unwahrscheinlich, dass Sie dies erst nach einer langen Datenmigration in der Produktion wissen m√∂chten. <br><br>  Je n√§her Ihre Standkonfiguration an der Produktionskonfiguration liegt, desto zuverl√§ssiger erhalten Sie Ergebnisse.  Ein wichtiger Punkt ist die korrekte Belastung des St√§nders.  Das Ausf√ºhren von zuf√§lligen oder denselben Abfragen kann zu falschen Ergebnissen f√ºhren.  Die beste Option ist die Verwendung realer Anforderungen aus der Produktion.  F√ºr UDB haben wir jede zehnte API-Leseanforderung (einschlie√ülich Parameter) in Form eines JSON-Protokolls in einer Datei aus der Produktion protokolliert.  F√ºr einen Tag haben wir aus 700 Millionen Anfragen ein Protokoll mit einer Gr√∂√üe von 65 GB gesammelt. <br><br>  Wir haben den Datensatz nicht getestet, da er im Vergleich zur Anzahl der Leseanforderungen sehr klein ist und unsere Last nicht beeinflusst.  Dies ist jedoch in Ihrem Fall m√∂glicherweise nicht der Fall.  Wenn Sie den Pr√ºfstand mit Schreibanforderungen laden m√∂chten, m√ºssen Sie jede Anforderung erfassen, da das √úberspringen von Schreibanforderungen zu Konsistenzfehlern auf dem Pr√ºfstand f√ºhren kann. <br><br>  Der n√§chste Schritt besteht darin, das Protokoll auf dem Stand korrekt zu verlieren.  Wir haben 400 PHP-Mitarbeiter verwendet, die √ºber unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Skript-Cloud</a> gestartet wurden und das gesammelte Protokoll aus der schnellen Warteschlange lesen und Anforderungen nacheinander ausf√ºhren.  In diesem Fall wird die Warteschlange mit einem anderen Skript mit einer genau definierten Geschwindigkeit gef√ºllt.  Zum Testen von Ideen haben wir die Geschwindigkeit von x10 verwendet, die multipliziert mit der Tatsache, dass wir nur jede zehnte Anfrage aus der Produktion gesammelt haben, die gleiche Anzahl von RPS ergab wie in der Produktion. <br><br><img src="https://habrastorage.org/webt/p2/9p/ya/p29pyak41t3rygstxym5kguf3gm.png"><br><br>  Mit diesen Koeffizienten stellt sich heraus, dass der Produktionstag mit allen Lastabf√§llen auf dem Pr√ºfstand in nur zweieinhalb Stunden fliegt. <br><br>  So sah beispielsweise der erste Test, den wir einen halben Tag lang mit einer Geschwindigkeit von x5 (50% der Produktionslast) im Abfrageprotokoll durchgef√ºhrt haben, folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/4l/3z/sg/4l3zsggyvo-yklup3xmnl9x-0de.png"><br><br>  Dieselben Werkzeuge k√∂nnen zur Durchf√ºhrung eines Fehlertests verwendet werden: Erh√∂hen der Geschwindigkeit (und damit des RPS), bis sich die Basis am Stand zu verschlechtern beginnt.  Auf diese Weise erhalten Sie ein klares Verst√§ndnis daf√ºr, wie viel mehr Last Ihre Datenbank aushalten kann. <br><br>  Nach dem Testen des neuen Datenschemas ist es auch wichtig, einen Kontrolltest f√ºr die urspr√ºngliche Datenbankstruktur durchzuf√ºhren.  Wenn die Ergebnisse und die aktuelle Leistung in der Produktion sehr unterschiedlich sind, sollten Sie zuerst die Gr√ºnde verstehen.  M√∂glicherweise ist der Testserver falsch konfiguriert und Sie k√∂nnen den Lasttestdaten nicht vertrauen. <br><br>  Es lohnt sich auch sicherzustellen, dass der neue Code korrekt funktioniert.  Es ist wenig sinnvoll, die Leistung von Abfragen zu testen, die den Job nicht ausf√ºhren.  Integrationstests, bei denen √ºberpr√ºft wird, ob die alte und die neue API bei denselben API-Aufrufen dieselben Werte zur√ºckgeben, werden Sie gut bedienen. <br><br>  Nachdem Sie zu allen Ideen Ergebnisse erhalten haben, m√ºssen Sie nur noch Optionen mit dem besten Gleichgewicht zwischen Preis und Qualit√§t ausw√§hlen und ein neues Produktionsschema einf√ºhren. <br><br><h2>  Schema√§nderung </h2><br>  Zun√§chst stelle ich fest, dass das √Ñndern des Datenschemas ohne Unterbrechung des Betriebs des Dienstes immer recht schwierig, teuer und riskant ist.  Wenn Sie also die M√∂glichkeit haben, Ihre Anwendung zu stoppen, w√§hrend Sie die Struktur √§ndern, tun Sie es einfach.  Bei UDB konnten wir uns das leider nicht leisten. <br><br>  Der zweite Faktor, der die Komplexit√§t der √Ñnderung einer Schaltung beeinflusst, ist das geplante Ausma√ü der √Ñnderung.  Wenn alle vorgeschlagenen √Ñnderungen an den Tabellen nicht √ºber eine √Ñnderung hinausgehen (z. B. Hinzuf√ºgen eines Paares neuer Indizes oder Spalten), k√∂nnen Sie sie mit typischen Prozessen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pt-online-schema-change</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gh-ost</a> f√ºr MySQL oder einem alternativen Slave <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">starten</a> und anschlie√üend ihre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Positionen</a> √§ndern . <br><br>  In unserem Fall wurde ein hervorragendes Ergebnis beim vertikalen Sharding einer etwa ein Dutzend kleineren riesigen Tabelle mit anderen Spalten, Indizes und Daten in einem anderen Format gezeigt.  Eine solche Konvertierung mit typischen Werkzeugen ist nicht mehr m√∂glich.  Was tun? <br><br>  Wir haben den folgenden Algorithmus angewendet: <br><br><ol><li>  Wir erreichen einen Zustand, in dem sowohl das alte als auch das neue Schema mit aktuellen Daten gleichzeitig existieren.  Die Aufzeichnung erfolgt in beiden Versionen, und gleichzeitig besteht in beiden Versionen eine Garantie f√ºr die Datenkonsistenz.  Wir werden diesen Punkt unten im Detail betrachten. <br></li><li>  Schalten Sie den gesamten Messwert schrittweise auf einen neuen Stromkreis um und steuern Sie die Last. <br></li><li>  Schalten Sie die Aufnahme im alten Schema aus und l√∂schen Sie sie. <br></li></ol><br>  Die Hauptvorteile dieses Ansatzes: <br><br><ul><li>  Sicherheit: Es besteht die M√∂glichkeit eines sofortigen Rollbacks bis zur letzten Stufe (schalten Sie den Messwert einfach auf das alte Schema zur√ºck, wenn ein Fehler aufgetreten ist). <br></li><li>  Volllastkontrolle w√§hrend der Datenmigration; <br></li><li>  Es ist keine schwere √Ñnderung des gro√üen Tisches der alten Schaltung erforderlich. <br></li></ul><br>  Es gibt jedoch auch Nachteile: <br><br><ul><li>  Die Notwendigkeit, beide Versionen der Schemas w√§hrend des Migrationsprozesses auf der Festplatte zu belassen (dies kann ein Problem sein, wenn Sie wenig Speicherplatz haben und die zu migrierende Tabelle sehr gro√ü ist). <br></li><li>  viel tempor√§rer Code zur Unterst√ºtzung des Migrationsprozesses, der nach Abschluss abgeschnitten wird; <br></li><li>  Es ist m√∂glich, den Cache durch paralleles Lesen aus zwei Schemata zu waschen.  Es bestand die Bef√ºrchtung, dass die alte und die neue Version um RAM konkurrieren k√∂nnten, was zu einer Verschlechterung des Dienstes f√ºhren k√∂nnte (in Wirklichkeit verursachte dies eine zus√§tzliche Belastung, da die Migration jedoch au√üerhalb der Spitzenzeiten durchgef√ºhrt wurde, verursachte dies keine Probleme f√ºr uns). <br></li></ul><br>  Die Hauptschwierigkeit bei diesem Algorithmus ist der erste Punkt.  Wir werden es im Detail betrachten. <br><br><h2>  Synchronisierung √§ndern </h2><br>  Die Migration statischer Daten ist nicht besonders schwierig.  Was ist jedoch, wenn Sie nicht einfach die gesamte Aufzeichnung stoppen k√∂nnen, w√§hrend die Datenbank migriert wird? <br><br>  Es gibt verschiedene Optionen, um eine Synchronisierung des neuen Schemas zu erreichen: Migration mit fortlaufendem Protokoll und idempotente Aufzeichnung der Migration. <br><br><h3>  Migrieren eines Datenschnappschusses und anschlie√üende Wiedergabe des Protokolls der folgenden √Ñnderungen </h3><br>  Jede Datenaktualisierungstransaktion wird durch Trigger entweder auf Anwendungsebene in einer speziellen Tabelle protokolliert, oder das Replikations-Binlog wird als Protokoll verwendet.  Nachdem Sie ein solches Protokoll erstellt haben, k√∂nnen Sie eine Transaktion √∂ffnen und einen Datenschnappschuss migrieren, wobei Sie sich die Position im Protokoll merken.  Dann muss noch begonnen werden, das gesammelte Protokoll auf das neue Schema anzuwenden.  In √§hnlicher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weise funktioniert</a> beispielsweise das beliebte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Backup-Tool</a> MySQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Percona XtraBackup</a> . <br><br>  Nachdem das neue Schema das Protokoll des aktuellen Datensatzes eingeholt hat, beginnt die wichtigste Phase: Sie m√ºssen die Aufzeichnung im alten Schema noch f√ºr einen kurzen Zeitraum anhalten und sicherstellen, dass das gesamte verf√ºgbare Protokoll auf das neue Schema angewendet wird. Dies bedeutet, dass die Daten zwischen den Schemata konsistent sind. Aktivieren Sie auf Anwendungsebene die gleichzeitige Aufzeichnung in beiden Quellen. <br><br>  Die Hauptnachteile dieses Ansatzes sind, dass Sie das Betriebsprotokoll irgendwie speichern m√ºssen, was an sich eine Last im komplexen Schaltprozess erzeugen kann, sowie in der Wahrscheinlichkeit, den Rekord zu brechen, wenn sich die Schaltkreise aus irgendeinem Grund als inkonsistent herausstellen. <br><br><h3>  Idempotenter Rekord </h3><br>  Die Hauptidee dieses Ansatzes besteht darin, parallel zum Schreiben in das alte Schema zu schreiben, bevor die √Ñnderungen vollst√§ndig synchronisiert sind, und dann die Migration der verbleibenden Daten abzuschlie√üen.  Ebenso werden normalerweise neue Spalten in gro√üe Tabellen gef√ºllt. <br><br>  Die synchrone Aufzeichnung kann sowohl bei Datenbank-Triggern als auch im Quellcode implementiert werden.  Ich rate Ihnen, dies genau im Code zu tun, da Sie in jedem Fall irgendwann Code schreiben m√ºssen, der Daten in das neue Schema schreibt, und die Implementierung der Migration auf der Codeseite Ihnen mehr Kontrolle bietet. <br><br>  Ein wichtiger zu ber√ºcksichtigender Punkt ist, dass sich das neue Schema bis zum Abschluss der Migration in einem inkonsistenten Zustand befindet.  Aus diesem Grund ist ein Szenario m√∂glich, wenn das Aktualisieren einer neuen Tabelle zu einer Verletzung der Datenbankkonstante (Fremdschl√ºssel oder ein eindeutiger Index) f√ºhrt, w√§hrend die Transaktion aus Sicht des aktuellen Schemas vollst√§ndig korrekt ist und ausgef√ºhrt werden sollte. <br><br>  Diese Situation kann aufgrund des Migrationsprozesses zu einem Rollback guter Transaktionen f√ºhren.  Der einfachste Weg, um dieses Problem zu umgehen, besteht darin, den Modifikator IGNORE zu allen Anforderungen hinzuzuf√ºgen, um Daten in ein neues Schema zu schreiben oder das Rollback einer solchen Transaktion abzufangen und die Version auszuf√ºhren, ohne in das neue Schema zu schreiben. <br><br>  Der Synchronisationsalgorithmus durch idempotente Aufzeichnung ist in unserem Fall wie folgt: <br><br><ol><li>  Wir aktivieren die Aufzeichnung in einem neuen Schema parallel zur Aufzeichnung im alten im Kompatibilit√§tsmodus (IGNORE). <br></li><li>  Wir f√ºhren ein Skript aus, das das neue Schema schrittweise umgeht und inkonsistente Daten erfasst.  Danach sollten die Daten in beiden Tabellen synchronisiert werden. Dies ist jedoch aufgrund m√∂glicher Konflikte in Abschnitt 1 ungenau. <br></li><li>  Wir starten die Datenkonsistenzpr√ºfung - wir √∂ffnen die Transaktion und lesen nacheinander die Zeilen aus den neuen und alten Schemata, um deren Korrespondenz zu vergleichen. <br></li><li>  Wenn es Konflikte gibt, beenden wir und kehren zu Absatz 3 zur√ºck. <br></li><li>  Nachdem der Pr√ºfer gezeigt hat, dass die Daten in beiden Schemata synchronisiert sind, sollte es keine weiteren Diskrepanzen zwischen den Schemata geben, es sei denn, wir haben nat√ºrlich eine Nuance √ºbersehen.  Daher warten wir einige Zeit (z. B. eine Woche) und f√ºhren eine Kontrollpr√ºfung durch.  Wenn er zeigt, dass alles in Ordnung ist, ist die Aufgabe erfolgreich abgeschlossen und Sie k√∂nnen die Lesung √ºbersetzen. <br></li></ol><br><h2>  Ergebnisse </h2><br>  Durch die √Ñnderung des Datenformats konnten wir die Gr√∂√üe der Haupttabelle von 544 GB auf 226 GB reduzieren, wodurch die Belastung der Festplatte verringert und die Menge n√ºtzlicher Daten erh√∂ht wurde, die in den Arbeitsspeicher passen. <br><br>  Insgesamt konnten wir von Beginn des Projekts an mit allen beschriebenen Ans√§tzen die CPU-Auslastung des Datenbankservers bei Spitzenverkehr von 80% auf 35% reduzieren.  Die Ergebnisse des anschlie√üenden Stresstests zeigten, dass wir bei der aktuellen Wachstumsrate der Last noch mindestens drei Jahre auf der vorhandenen Hardware bleiben k√∂nnen. <br><br>  Das Aufteilen einer gro√üen Tabelle in mehrere vereinfachte die Durchf√ºhrung zuk√ºnftiger √Ñnderungen in der Datenbank und beschleunigte einige Skripte, die Daten f√ºr BI sammelten, erheblich. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433730/">https://habr.com/ru/post/de433730/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433720/index.html">10 Gr√ºnde, sich f√ºr eine L√∂sung f√ºr SAP HANA von HPE zu entscheiden</a></li>
<li><a href="../de433722/index.html">HeisenBug mit den Augen eines Mitarbeiters von SberTech</a></li>
<li><a href="../de433724/index.html">Eine unangenehme Wahrheit √ºber LDAC</a></li>
<li><a href="../de433726/index.html">Erste Schritte mit der Automatisierungs-API: Teil 1 - √úbersicht</a></li>
<li><a href="../de433728/index.html">Google hat das chinesische zensierte Suchmaschinenprojekt aufgrund von Meinungsverschiedenheiten innerhalb des Unternehmens geschlossen</a></li>
<li><a href="../de433732/index.html">Alan Kay: ‚ÄûWelche B√ºcher w√ºrden Sie jemandem empfehlen, der Informatik studiert?‚Äú</a></li>
<li><a href="../de433734/index.html">Donald Knuth: ‚ÄûDie √§lteren Kameraden haben Tennis gespielt, wir waren B√§lle. Sie haben uns geschlagen, es hat wehgetan. ‚Äú (11,12 / 97)</a></li>
<li><a href="../de433738/index.html">Antiquit√§ten: Spiele unter MS-DOS, die wir nicht ausgew√§hlt haben</a></li>
<li><a href="../de433740/index.html">Die Staatsduma bricht das nationale Roaming in dritter Lesung ab</a></li>
<li><a href="../de433742/index.html">Turbojet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>