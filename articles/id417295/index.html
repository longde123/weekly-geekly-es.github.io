<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚔 🤦🏽 🌲 Bagaimana saya menulis library C ++ 11 standar atau mengapa boost sangat menakutkan. Bab 3 👩‍👩‍👧‍👧 ⏮️ 👩🏾‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ringkasan bagian sebelumnya 
 Karena pembatasan pada kemampuan untuk menggunakan kompiler C ++ 11, dan dari kurangnya alternatif, dorongan ingin menul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana saya menulis library C ++ 11 standar atau mengapa boost sangat menakutkan. Bab 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417295/"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="Kami melanjutkan petualangan." width="300" height="350" align="left"><h3>  Ringkasan bagian sebelumnya </h3><br>  Karena pembatasan pada kemampuan untuk menggunakan kompiler C ++ 11, dan dari kurangnya alternatif, dorongan ingin menulis implementasi sendiri dari pustaka C ++ 11 standar di atas pustaka C ++ 98 / C ++ 03 yang disertakan dengan kompiler. <br><br>  <b>Static_assert</b> , <b>noexcept</b> , <b>countof</b> diimplementasikan, dan juga, setelah mempertimbangkan semua definisi non-standar dan fitur kompiler, informasi muncul tentang fungsi yang didukung oleh kompiler saat ini.  Ini melengkapi deskripsi <b>core.h</b> , tetapi itu tidak akan lengkap tanpa <b>nullptr</b> . <br><br>  Tautan ke GitHub dengan hasil untuk hari ini untuk yang tidak sabar dan yang bukan pembaca: <br><br><blockquote>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komitmen dan kritik yang membangun dipersilahkan</a></b> </blockquote><br>  Jadi, mari kita lanjutkan. <br><a name="habracut"></a><br><h4>  Daftar isi </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 1. Viam supervadet vadens</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</a> <br>  <b>Bab 3. Menemukan implementasi nullptr yang sempurna</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 4. C ++ Template Magic</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.1 Kita mulai dari yang kecil</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.2 Tentang berapa banyak kesalahan ajaib yang dikompilasi oleh log untuk kita</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.3 Pointer dan semuanya</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.4 Apa lagi yang diperlukan untuk pustaka templat</a> <br>  Bab 5 <br>  ... <br><br><h3>  Bab 3. Menemukan implementasi nullptr yang sempurna </h3><br>  Setelah seluruh epik dengan makro kompiler non-standar dan penemuan "luar biasa" yang mereka sajikan, saya akhirnya bisa menambahkan <b>nullptr</b> dan itu menghangatkan jiwa saya.  Akhirnya, Anda dapat menyingkirkan semua perbandingan ini dengan 0 atau bahkan <b>NULL</b> . <br><br><img src="https://habrastorage.org/webt/t_/jt/wb/t_jtwbjyvuah5tw2ehe-gvy0fxe.jpeg" alt="gambar" width="300" height="200" align="left">  Kebanyakan programmer mengimplementasikan <b>nullptr</b> sebagai <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> nullptr 0</span></span></code> </pre> <br>  dan ini bisa mengakhiri bab ini.  Jika Anda menginginkan diri Anda <b>nullptr</b> , maka ganti saja 0 dengan definisi seperti itu, karena pada dasarnya ini semua yang diperlukan untuk operasi yang benar. <br><br>  Jangan lupa untuk benar-benar menulis cek, jika tidak, tiba-tiba orang lain akan ditemukan dengan definisi ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> nullptr #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> nullptr 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"nullptr defined already"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Arahan preprocessor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">#error</a> akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menghasilkan</a> kesalahan dengan teks yang dapat dibaca manusia saat kompilasi, dan, ya, ini adalah arahan standar, penggunaannya jarang, tetapi dapat ditemukan. <br><br>  Tetapi dalam implementasi seperti itu, kita kehilangan salah satu poin penting yang dijelaskan dalam standar, yaitu <i>std :: nullptr_t</i> - tipe terpisah, contoh konstan di antaranya adalah <b>nullptr</b> .  Dan pengembang kromium juga pernah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mencoba untuk</a> memecahkan masalah ini (sekarang ada kompiler baru dan <b>nullptr</b> normal) mendefinisikannya sebagai kelas yang dapat dikonversi ke pointer ke jenis apa pun.  Karena, secara standar, ukuran <b>nullptr</b> harus sama dengan ukuran pointer ke <b>void</b> (dan <b>void *</b> juga harus mengandung pointer apa pun, kecuali pointer ke anggota kelas), kami "membakukan" implementasi ini dengan menambahkan pointer nol yang tidak digunakan: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_t_as_class_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: nullptr_t_as_class_impl() { } nullptr_t_as_class_impl(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { } <span class="hljs-comment"><span class="hljs-comment">// Make nullptr convertible to any pointer type. template&lt;typename T&gt; operator T*() const { return 0; } // Make nullptr convertible to any member pointer type. template&lt;typename C, typename T&gt; operator TC::*() { return 0; } bool operator==(nullptr_t_as_class_impl) const { return true; } bool operator!=(nullptr_t_as_class_impl) const { return false; } private: // Do not allow taking the address of nullptr. void operator&amp;(); void *_padding; }; typedef nullptr_t_as_class_impl nullptr_t; #define nullptr nullptr_t(0)</span></span></code> </pre><br>  Konversi kelas ini ke penunjuk apa pun disebabkan oleh operator templat jenis itu, yang disebut jika ada sesuatu yang dibandingkan dengan <b>nullptr</b> .  Yaitu, ekspresi <i>char * my_pointer;</i>  <i>if (my_pointer == nullptr)</i> akan benar-benar dikonversi menjadi <i>if (my_pointer == nullptr.operator char * ())</i> , yang membandingkan pointer ke 0. Operator tipe kedua diperlukan untuk mengonversi <b>nullptr</b> ke pointer ke anggota kelas.  Dan di sini Borland C ++ Builder 6.0 “membedakan dirinya”, yang secara tak terduga memutuskan bahwa kedua operator ini identik dan dapat dengan mudah membandingkan pointer ke anggota kelas dan pointer biasa satu sama lain, sehingga ada ketidakpastian setiap kali <b>nullptr</b> dibandingkan dengan pointer (ini adalah bug, dan mungkin tidak hanya dengan kompiler ini).  Kami sedang menulis implementasi terpisah untuk kasus ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_t_as_class_impl1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: nullptr_t_as_class_impl1() { } nullptr_t_as_class_impl1(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { } <span class="hljs-comment"><span class="hljs-comment">// Make nullptr convertible to any pointer type. template&lt;typename T&gt; operator T*() const { return 0; } bool operator==(nullptr_t_as_class_impl1) const { return true; } bool operator!=(nullptr_t_as_class_impl1) const { return false; } private: // Do not allow taking the address of nullptr. void operator&amp;(); void *_padding; }; typedef nullptr_t_as_class_impl1 nullptr_t; #define nullptr nullptr_t(0)</span></span></code> </pre><br>  Keuntungan dari tampilan <b>nullptr</b> ini adalah bahwa sekarang ada tipe terpisah untuk <i>std :: nullptr_t</i> .  Kerugian?  Konstanta <b>nullptr hilang</b> selama kompilasi dan perbandingan melalui operator ternary, kompilator tidak dapat menyelesaikannya. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>* case5 = argc &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>*)<span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,     ':'    STATIC_ASSERT(nullptr == nullptr &amp;&amp; !(nullptr != nullptr), nullptr_should_be_equal_itself); //  , nullptr     </span></span></code> </pre><br>  Dan saya ingin "dan checker dan pergi."  Solusinya terlintas dalam pikiran hanya satu: <b>enum</b> .  Anggota enumerasi dalam C ++ akan memiliki tipe terpisah mereka sendiri, dan juga akan dikonversi ke <b>int</b> tanpa masalah (dan sebenarnya mereka adalah konstanta integer).  Properti anggota enumerasi ini akan membantu kami, karena 0 yang sangat “spesial” yang digunakan sebagai pengganti <b>nullptr</b> untuk pointer adalah <b>int yang</b> paling umum.  Saya belum melihat implementasi <b>nullptr</b> di Internet, dan mungkin itu juga sesuatu yang buruk, tetapi saya tidak tahu mengapa.  Mari kita tulis implementasi: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> NULL #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STDEX_NULL NULL #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STDEX_NULL 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> namespace ptrdiff_detail { using namespace std; } template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;bool&gt; struct nullptr_t_as_ulong_type { typedef unsigned long type; }; template&lt;&gt; struct nullptr_t_as_ulong_type&lt;false&gt; { typedef unsigned long type; }; template&lt;bool&gt; struct nullptr_t_as_ushort_type { typedef unsigned short type; }; template&lt;&gt; struct nullptr_t_as_ushort_type&lt;false&gt; { typedef nullptr_t_as_long_type&lt;sizeof(unsigned long) == sizeof(void*)&gt;::type type; }; template&lt;bool&gt; struct nullptr_t_as_uint_type { typedef unsigned int type; }; template&lt;&gt; struct nullptr_t_as_uint_type&lt;false&gt; { typedef nullptr_t_as_short_type&lt;sizeof(unsigned short) == sizeof(void*)&gt;::type type; }; typedef nullptr_t_as_uint_type&lt;sizeof(unsigned int) == sizeof(void*)&gt;::type nullptr_t_as_uint; enum nullptr_t_as_enum { _nullptr_val = ptrdiff_detail::ptrdiff_t(STDEX_NULL), _max_nullptr = nullptr_t_as_uint(1) &lt;&lt; (CHAR_BIT * sizeof(void*) - 1) }; typedef nullptr_t_as_enum nullptr_t; #define nullptr nullptr_t(STDEX_NULL)</span></span></span></span></code> </pre><br>  Seperti yang Anda lihat di sini sedikit lebih banyak kode daripada hanya mendeklarasikan <b>enum</b> <i>nullptr_t</i> dengan anggota <i>nullptr = 0</i> .  Pertama, mungkin tidak ada definisi <b>NULL</b> .  Ini harus didefinisikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar header standar yang agak padat</a> , tetapi seperti yang telah ditunjukkan oleh praktik, lebih baik memainkannya dengan aman dan memeriksa makro ini.  Kedua, representasi <b>enum</b> di C ++ sesuai dengan standar yang ditentukan implementasi, yaitu  tipe enumerasi dapat diwakili oleh tipe integer (dengan ketentuan bahwa tipe-tipe ini tidak boleh lebih dari <b>int</b> , asalkan nilai <b>enum cocok</b> dengan itu).  Misalnya, jika Anda mendeklarasikan <i>tes enum {_1, _2},</i> kompiler dapat dengan mudah menyatakannya sebagai <b>pendek,</b> dan sangat mungkin bahwa <b>sizeof (</b> <i>test</i> <b>)</b> <i>! =</i> <b>Sizeof (void *)</b> .  Agar implementasi <b>nullptr mematuhi</b> standar, Anda perlu memastikan bahwa ukuran tipe yang dipilih kompiler untuk <i>nullptr_t_as_enum</i> cocok dengan ukuran penunjuk, mis.  <b>sizeof</b> dasarnya sama <b>(void *)</b> .  Untuk melakukan ini, menggunakan <i>templat nullptr_t_as ...</i> , pilih tipe integer yang akan sama dengan ukuran pointer, dan kemudian atur nilai maksimum elemen dalam enumerasi kami ke nilai maksimum dari tipe integer ini. <br><blockquote>  Saya ingin memperhatikan <b>CHAR_BIT</b> makro yang ditentukan dalam header <b>iklim</b> standar.  Makro ini disetel ke jumlah bit dalam satu <b>karakter</b> , yaitu  jumlah bit per byte pada platform saat ini.  Definisi <u>standar yang</u> berguna yang tidak perlu dilewati oleh pengembang dengan menempel delapan di mana-mana, meskipun di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa tempat dalam satu byte tidak ada 8 bit sama sekali</a> . </blockquote><br>  Dan fitur lainnya adalah penugasan <b>NULL</b> sebagai nilai dari elemen <b>enum</b> .  Beberapa kompiler memberikan peringatan (dan kekhawatiran mereka dapat dipahami) tentang fakta bahwa <b>NULL</b> ditugaskan ke "non-pengindeks".  Kami mengambil <b>namespace</b> standar ke <i>ptrdiff_detail</i> lokal kami, agar tidak mengacaukan sisa namespace, dan kemudian, untuk menenangkan kompilator, kami secara eksplisit mengkonversi <b>NULL</b> ke <i>std :: ptrdiff_t</i> - jenis lain yang agak kurang digunakan dalam C ++, yang berfungsi untuk mewakili hasil operasi aritmatika (pengurangan) dengan pointer dan biasanya merupakan alias dari tipe <i>std :: size_t</i> ( <i>std :: intptr_t</i> di C ++ 11). <br><br><h4>  SFINAE </h4><br>  Di sini, untuk pertama kalinya dalam cerita saya, kita dihadapkan dengan fenomena seperti itu di C ++ karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kegagalan substitusi bukanlah kesalahan (SFINAE)</a> .  Singkatnya, intinya adalah bahwa ketika kompiler "melewati" fungsi yang sesuai kelebihan untuk panggilan tertentu, ia harus memeriksa semuanya, dan tidak berhenti setelah kegagalan pertama atau setelah kelebihan pertama yang cocok.  Dari sini muncul pesannya tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ambiguitas</a> , ketika ada dua kelebihan fungsi yang dipanggil yang identik dari sudut pandang kompiler, serta kemampuan kompiler untuk memilih kelebihan fungsi yang paling tepat untuk panggilan tertentu dengan parameter tertentu.  Fitur kompiler ini memungkinkan Anda untuk melakukan bagian terbesar dari semua templat "ajaib" (omong-omong hi <i>std :: enable_if</i> ), dan itu juga merupakan dasar dari boost dan library saya. <br><br>  Karena, sebagai hasilnya, kami memiliki beberapa implementasi <b>nullptr,</b> kami menggunakan SFINAE "pilih" yang terbaik pada tahap kompilasi.  Kami menyatakan tipe "ya" dan "tidak" untuk memeriksa <b>ukuran</b> fungsi penyelidikan yang dinyatakan di bawah ini. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> nullptr_detail { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _yes_type; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">no_type</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> padding[<span class="hljs-number"><span class="hljs-number">8</span></span>]; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dummy_class</span></span></span><span class="hljs-class"> {</span></span>}; _yes_type _is_convertable_to_void_ptr_tester(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*); _no_type _is_convertable_to_void_ptr_tester(...); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nullptr_detail::dummy_class::*dummy_class_f)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nullptr_detail::dummy_class::*dummy_class_f_const)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; _yes_type _is_convertable_to_member_function_ptr_tester(dummy_class_f); _no_type _is_convertable_to_member_function_ptr_tester(...); _yes_type _is_convertable_to_const_member_function_ptr_tester(dummy_class_f_const); _no_type _is_convertable_to_const_member_function_ptr_tester(...); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">yes_type</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_ptr_tester</span></span></span><span class="hljs-class">(_</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">*);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">no_type</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_ptr_tester</span></span></span><span class="hljs-class">(...);</span></span> }</code> </pre><br><blockquote>  Di sini kita akan menggunakan prinsip yang sama seperti pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bab kedua</a> dengan <b>hitungan</b> dan definisinya melalui <b>ukuran nilai</b> pengembalian (array elemen) dari fungsi templat <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> . </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_void_ptr_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_is_convertable_to_void_ptr_tester((T) (STDEX_NULL))) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_yes_type)); };</code> </pre><br>  Apa yang sedang terjadi di sini?  Pertama, kompiler “ <i>mengulangi</i> ” kelebihan fungsi <i>_is_convertable_to_void_ptr_tester</i> dengan argumen tipe <i>T</i> dan nilai <b>NULL</b> (nilai tidak berperan, hanya <b>NULL yang</b> harus mengetikkan- <i>T</i> ).  Hanya ada dua kelebihan - dengan tipe <b>* kosong</b> dan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar argumen variabel (...)</a> .  Mengganti argumen ke masing-masing kelebihan ini, kompiler akan memilih yang pertama jika tipe dilemparkan ke pointer untuk <b>membatalkan</b> , dan yang kedua jika gips tidak dapat dilakukan.  Dengan kelebihan yang dipilih oleh kompiler, kami menggunakan <b>sizeof untuk</b> menentukan ukuran nilai yang dikembalikan oleh fungsi, dan karena mereka dijamin berbeda ( <b>sizeof (</b> <i>_no_type</i> <b>)</b> <i>== 8</i> , <b>sizeof (</b> <i>_yes_type</i> <b>)</b> <i>== 1</i> ), kami dapat menentukan ukuran kelebihan beban yang diambil oleh kompiler dan karenanya dikonversi apakah tipe kita tidak <b>valid *</b> atau tidak. <br><br>  Kami akan menerapkan templat pemrograman yang sama lebih jauh untuk menentukan apakah objek dari jenis pilihan kami untuk mewakili <i>nullptr_t dikonversi</i> ke sembarang penunjuk (pada dasarnya <i>(T) (</i> <b>STDEX_NULL</b> <i>)</i> adalah definisi masa depan untuk <b>nullptr</b> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_member_function_ptr_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_is_convertable_to_member_function_ptr_tester((T) (STDEX_NULL))) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_yes_type)) &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_is_convertable_to_const_member_function_ptr_tester((T) (STDEX_NULL))) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_yes_type)); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullPtrType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_any_ptr_impl_helper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_is_convertable_to_ptr_tester&lt;T&gt;((NullPtrType) (STDEX_NULL))) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nullptr_detail::_yes_type)); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_any_ptr_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;::value &amp;&amp; _is_convertable_to_any_ptr_impl_helper&lt;T, nullptr_detail::dummy_class&gt;::value; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_convertable_to_ptr_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = ( _is_convertable_to_void_ptr_impl&lt;T&gt;::value == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) &amp;&amp; _is_convertable_to_any_ptr_impl&lt;T&gt;::value == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) &amp;&amp; _is_convertable_to_member_function_ptr_impl&lt;T&gt;::value == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) ); };</code> </pre><br>  Tentu saja, tidak mungkin untuk mengulangi semua petunjuk yang mungkin dan tidak dapat dipahami serta kombinasinya dengan <b>pengubah volatile</b> dan <b>const</b> , oleh karena itu saya membatasi diri hanya pada 9 pemeriksaan ini (dua pada pointer ke fungsi kelas, satu pada pointer ke <b>kosong</b> , tujuh pada pointer ke jenis yang berbeda), yang cukup cukup. <br><br>  Seperti disebutkan di atas, beberapa kompiler (* khe-khe * ... Borland Builder 6.0 ... * khe *) tidak membedakan antara pointer ke tipe dan anggota kelas, oleh karena itu kami akan menulis cek pembantu lain untuk kasus ini sehingga kami kemudian dapat memilih implementasi <i>nullptr_t yang</i> diinginkan melalui kelas. jika dibutuhkan. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">member_ptr_is_same_as_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(test::*member_ptr_type)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = _is_convertable_to_void_ptr_impl&lt;member_ptr_type&gt;::value; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_t_as_class_chooser</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_class_impl type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_t_as_class_chooser</span></span></span><span class="hljs-class">&lt;false&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_class_impl1 type; };</code> </pre><br>  Dan kemudian hanya tinggal memeriksa implementasi yang berbeda dari <i>nullptr_t</i> dan memilih kompiler yang sesuai untuk kompiler. <br><br><div class="spoiler">  <b class="spoiler_title">Memilih implementasi nullptr_t</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_int</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_int type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_enum</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_enum type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_class</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _nullptr_t_as_class_chooser&lt;_member_ptr_is_same_as_ptr::value&gt;::type type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_int</span></span></span><span class="hljs-class">&lt;false&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_void type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_enum</span></span></span><span class="hljs-class">&lt;false&gt; {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">as_int</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_int nullptr_t_as_int; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _is_convertable_to_ptr = _is_convertable_to_ptr_impl&lt;nullptr_t_as_int&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _equal_void_ptr = _is_equal_size_to_void_ptr&lt;nullptr_t_as_int&gt;::value; }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _nullptr_choose_as_int&lt;as_int::_is_convertable_to_ptr == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) &amp;&amp; as_int::_equal_void_ptr == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)&gt;::type type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nullptr_choose_as_class</span></span></span><span class="hljs-class">&lt;false&gt; {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">as_enum</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> nullptr_detail::nullptr_t_as_enum nullptr_t_as_enum; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _is_convertable_to_ptr = _is_convertable_to_ptr_impl&lt;nullptr_t_as_enum&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _equal_void_ptr = _is_equal_size_to_void_ptr&lt;nullptr_t_as_enum&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _can_be_ct_constant = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;<span class="hljs-comment"><span class="hljs-comment">//_nullptr_can_be_ct_constant_impl&lt;nullptr_t_as_enum&gt;::value; }; typedef _nullptr_choose_as_enum&lt;as_enum::_is_convertable_to_ptr == bool(true) &amp;&amp; as_enum::_equal_void_ptr == bool(true) &amp;&amp; as_enum::_can_be_ct_constant == bool(true)&gt;::type type; }; struct _nullptr_chooser { struct as_class { typedef _nullptr_t_as_class_chooser&lt;_member_ptr_is_same_as_ptr::value&gt;::type nullptr_t_as_class; static const bool _equal_void_ptr = _is_equal_size_to_void_ptr&lt;nullptr_t_as_class&gt;::value; static const bool _can_be_ct_constant = _nullptr_can_be_ct_constant_impl&lt;nullptr_t_as_class&gt;::value; }; typedef _nullptr_choose_as_class&lt;as_class::_equal_void_ptr == bool(true) &amp;&amp; as_class::_can_be_ct_constant == bool(true)&gt;::type type; };</span></span></code> </pre><br></div></div><br>  Pertama, kami memeriksa kemungkinan mewakili <i>nullptr_t</i> sebagai kelas, tetapi karena saya tidak menemukan kompiler universal dari solusi <i>independen</i> , saya tidak menemukan objek tipe yang dapat menjadi konstanta waktu kompilasi (omong-omong, saya terbuka untuk saran mengenai subjek ini, karena kemungkinan hal ini memungkinkan), opsi ini selalu <i>dicentang</i> ( <i>_can_be_ct_constant</i> selalu <b>salah</b> ).  Selanjutnya, kita beralih untuk memeriksa varian dengan view through <b>enum</b> .  Jika masih tidak memungkinkan untuk ditampilkan (kompiler tidak dapat menampilkan pointer melalui <b>enum</b> atau ukurannya entah bagaimana salah), maka kami mencoba untuk menggambarkannya sebagai tipe integer (yang ukurannya akan sama dengan ukuran pointer untuk <b>membatalkan</b> ).  Yah, bahkan jika ini tidak berhasil, maka kami memilih implementasi dari tipe <i>nullptr_t</i> via <b>void *</b> . <br><br>  Pada titik ini, sebagian besar kekuatan SFINAE dalam kombinasi dengan templat C ++ terungkap, karena itu dimungkinkan untuk memilih implementasi yang diperlukan tanpa beralih ke makro bergantung-kompiler, dan memang ke makro (tidak seperti boost di mana semua ini akan <b>dijejali</b> dengan <b>#ifdef #else # checking endif</b> ). <br><br>  Tetap hanya untuk menentukan jenis alias untuk <i>nullptr_t</i> di <b>namespace stdex</b> dan define untuk <b>nullptr</b> (untuk memenuhi persyaratan standar lain bahwa alamat <b>nullptr</b> tidak dapat diambil, serta menggunakan <b>nullptr</b> sebagai konstanta waktu kompilasi). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> stdex { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> detail::_nullptr_chooser::type <span class="hljs-keyword"><span class="hljs-keyword">nullptr_t</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> nullptr (stdex::nullptr_t)(STDEX_NULL)</span></span></code> </pre><br>  Akhir bab ketiga.  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bab keempat,</a> akhirnya saya bisa mengetikkan type_traits dan bug apa lagi dalam kompiler yang saya temui selama pengembangan. <br><br>  Terima kasih atas perhatian anda </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417295/">https://habr.com/ru/post/id417295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417283/index.html">Disney memperkenalkan sistem animasi rambut HairControl sendiri</a></li>
<li><a href="../id417285/index.html">Di mana memasukkan tanda kutip di IPv6</a></li>
<li><a href="../id417287/index.html">"Kalender Tester" untuk bulan Juli. Pengujian analitik</a></li>
<li><a href="../id417289/index.html">Trainee Diary: Hari 1. Trainee ke Junior</a></li>
<li><a href="../id417293/index.html">Pemulihan kata sandi dan penyimpanan utama di cloud, atau What's New in Zimbra 8.8.9</a></li>
<li><a href="../id417297/index.html">Kecemasan dan Kebencian Ancaman Intelijen atau 8 Tips Praktis TI</a></li>
<li><a href="../id417299/index.html">Online, offline, dan P2P: cara membeli bitcoin di Rusia</a></li>
<li><a href="../id417301/index.html">Resep Rilis Lancar: Catatan Saya</a></li>
<li><a href="../id417303/index.html">Retas untuk mendukung tombol headset Android Windows</a></li>
<li><a href="../id417305/index.html">Ultima Online: tampilan belakang panggung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>