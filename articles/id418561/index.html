<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📐 🏴 📒 Mesin negara dalam layanan MVP. Kuliah Yandex ⛰️ 🧑🏼 👂🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Model finite-state machine (FSM) digunakan dalam penulisan kode untuk berbagai platform, termasuk Android. Hal ini memungkinkan Anda untuk membuat kod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mesin negara dalam layanan MVP. Kuliah Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/418561/">  Model finite-state machine (FSM) digunakan dalam penulisan kode untuk berbagai platform, termasuk Android.  Hal ini memungkinkan Anda untuk membuat kode kurang rumit, cocok dengan paradigma Model-View-Presenter (MVP) dan cocok untuk pengujian sederhana.  Pengembang Vladislav Kuznetsov mengatakan kepada Droid Party bagaimana model ini membantu dalam pengembangan aplikasi Yandex.Disk. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/U3StVUzqmzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Pertama, mari kita bicara tentang teori.  Saya pikir Anda masing-masing telah mendengar tentang MVP dan mesin negara, tetapi kami akan mengulanginya. <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/ok/59/iy/ok59iyqnwvzdxm3a6_ozothgyka.jpeg"><br><br>  Mari kita bicara tentang motivasi, tentang mengapa semua ini diperlukan dan bagaimana itu dapat membantu kita.  Mari kita beralih ke apa yang kita lakukan, dengan contoh nyata saya akan menunjukkan potongan kode.  Dan pada akhirnya kita akan berbicara tentang pengujian, tentang bagaimana pendekatan ini membantu menguji segalanya dengan mudah. <br><br>  Mesin negara dan MVP, atau yang serupa - mungkin MVI - digunakan oleh semua orang. <br><br>  Ada banyak mesin negara.  Berikut adalah definisi paling sederhana yang dapat diberikan kepada mereka: ini adalah semacam abstraksi matematis, disajikan dalam bentuk set terbatas negara, peristiwa, dan transisi dari keadaan saat ini ke yang baru tergantung pada acara. <br><br><img src="https://habrastorage.org/webt/x_/o0/be/x_o0befettgekq2bf9h8rz4np3u.jpeg"><br><br>  Berikut adalah diagram sederhana dari beberapa programmer abstrak yang kadang-kadang tidur, kadang-kadang makan, tetapi kebanyakan menulis kode.  Ini cukup untuk kita.  Ada banyak jenis mesin dalam kondisi terbatas, tetapi ini cukup bagi kita. <br><br><img src="https://habrastorage.org/webt/5q/hw/iu/5qhwiuh6zfcmumsokpxa8xpethq.jpeg"><br><br>  Ruang lingkup mesin negara cukup besar.  Untuk setiap item digunakan dan berhasil diterapkan. <br><br><img src="https://habrastorage.org/webt/6k/z6/mx/6kz6mxlq_mdtra5x-duehczdoro.jpeg"><br><br>  Seperti pendekatan apa pun, MVP membagi aplikasi kita menjadi beberapa lapisan.  Lihat - paling sering suatu Aktivitas atau Fragmen, tugasnya adalah untuk meneruskan beberapa tindakan kepada pengguna, untuk mengidentifikasi Presenter bahwa pengguna telah melakukan sesuatu.  Kami menganggap Model sebagai penyedia data.  Itu bisa seperti database, jika kita berbicara tentang arsitektur bersih, atau Interactor, apa pun bisa.  Dan Presenter adalah perantara yang menghubungkan View dan model, sementara pada saat yang sama dapat mengambil dan memperbarui View dari model.  Ini cukup untuk kita. <br><br>  Siapa yang bisa mengatakan dalam satu kalimat apa program itu?  Kode yang dapat dieksekusi?  Terlalu umum, lebih detail.  Algoritma?  Algoritme adalah urutan tindakan. <br><br>  Ini adalah kumpulan data dan semacam aliran kontrol.  Tidak masalah siapa yang memanipulasi data ini: pengguna atau tidak.  Ini mengikuti pemikiran bahwa setiap saat keadaan aplikasi ditentukan oleh totalitas semua datanya.  Dan semakin banyak data dalam aplikasi, semakin sulit untuk mengelolanya, situasi yang lebih tidak terduga dapat muncul ketika terjadi kesalahan. <br><br><img src="https://habrastorage.org/webt/nw/zj/ck/nwzjck2q097uwbqk89wzm98pe7e.jpeg"><br><br>  Bayangkan sebuah kelas sederhana dengan tiga bendera boolean.  Untuk memastikan bahwa Anda mencakup semua skenario untuk menggabungkan flag-flag ini, Anda perlu 2³ skenario.  Penting untuk mencakup delapan skenario dengan jaminan untuk mengatakan bahwa saya sedang memproses semua kombinasi flag dengan pasti.  Jika Anda menambahkan bendera lain, itu meningkat secara proporsional. <br><br>  Kami menghadapi masalah yang sama.  Tampaknya itu adalah tugas yang sederhana, tetapi ketika kami mengembangkan dan mengerjakannya, kami mulai menyadari bahwa ada sesuatu yang salah.  Saya akan berbicara tentang fitur yang kami luncurkan.  Ini disebut menghapus foto lokal.  Intinya adalah bahwa pengguna mengunggah beberapa data ke cloud dalam mode otomatis.  Kemungkinan besar, ini adalah foto dan video yang ia ambil di ponselnya.  Ternyata file-file itu tampaknya berada di cloud.  Mengapa menghabiskan ruang berharga di ponsel Anda ketika Anda dapat menghapus foto-foto ini? <br><br><img src="https://habrastorage.org/webt/3n/3p/lh/3n3plhy4_4mu3v2m4p4gkygdkky.jpeg"><br><br>  Desainer menggambar konsep seperti itu.  Sepertinya hanya dialog, memiliki tajuk tempat jumlah ruang yang dapat kita bebaskan digambar, teks pesan dan tanda centang bahwa ada dua mode pembersihan: hapus semua foto yang diunggah pengguna, atau hanya yang lebih dari satu bulan. <br><br><img src="https://habrastorage.org/webt/mx/rh/ww/mxrhwwwyscc58l0l_q0dddos4zk.jpeg"><br><br>  Kami melihat - sepertinya tidak ada yang rumit.  Dialog, dua TextViews, kotak centang, tombol.  Tetapi ketika kami mulai menangani masalah ini secara terperinci - kami menyadari bahwa mendapatkan data tentang berapa banyak file yang dapat kami hapus adalah tugas jangka panjang.  Karena itu, kita harus menunjukkan kepada pengguna semacam rintisan.  Ini adalah kode semu, dalam kehidupan nyata terlihat berbeda, tetapi artinya sama. <br><br><img src="https://habrastorage.org/webt/70/if/kj/70ifkjrvmkxonvj7fybqkwuii_4.jpeg"><br><br>  Kami memeriksa beberapa keadaan, memeriksa apakah kami menghitung, dan menggambar steker "Tunggu". <br><br><img src="https://habrastorage.org/webt/v5/zl/-r/v5zl-rzfbiupzf3xas9oatuev6c.jpeg"><br><br>  Ketika perhitungan selesai, kami memiliki beberapa opsi untuk ditampilkan kepada pengguna.  Misalnya, jumlah file yang dapat kita hapus adalah nol.  Dalam hal ini, kami menggambar pesan kepada pengguna bahwa tidak ada yang perlu dihapus, jadi datanglah lain kali.  Kemudian desainer mendatangi kami dan mengatakan bahwa kami harus membedakan antara situasi di mana pengguna telah membersihkan file atau tidak menghapus apa pun, tidak ada yang dimuat.  Karenanya, muncul kondisi lain bahwa kami sedang menunggu startup dan menariknya pesan lain. <br><br><img src="https://habrastorage.org/webt/o_/_v/qy/o__vqyedqzkarkomv1xtyvpmqr4.jpeg"><br><br>  Lalu ada situasi ketika sesuatu tetap bekerja, dan misalnya, pengguna memiliki tanda centang untuk tidak menghapus file baru.  Dalam hal ini, ada juga dua opsi.  Baik file dapat dibersihkan, atau file tidak dapat dibersihkan, yaitu sudah menghapus semua file, jadi kami memperingatkan bahwa Anda telah menghapus semua file baru. <br><br><img src="https://habrastorage.org/webt/dl/oj/dj/dlojdj0k01zqxtfetujqmgjnwc4.jpeg"><br><img src="https://habrastorage.org/webt/xp/m2/k9/xpm2k931n5l9uj8kkmtl17qjuja.jpeg"><br><br>  Ada satu syarat lagi ketika kita benar-benar dapat menghapus sesuatu.  Tidak dicentang, dan ada opsi untuk menghapus sesuatu.  Anda melihat kode ini dan sepertinya ada sesuatu yang salah.  Saya belum mendaftarkan semuanya, kami memiliki pemeriksaan permishin, karena tidak ada yang berfungsi tanpanya, kami tidak dapat menyentuh file pada kartu, plus kami perlu memeriksa bahwa pengguna telah mengaktifkan secara otomatis, karena fitur tidak berguna tanpa pengisian otomatis, yang mana kami akan untuk membersihkan.  Dan beberapa syarat lagi.  Dan sial, sepertinya ini hal yang sangat sederhana, dan begitu banyak masalah yang muncul karenanya. <br><br>  Dan jelas, beberapa masalah segera muncul.  Pertama-tama, kode ini tidak dapat dibaca.  Di sini pseudo-code tertentu digambarkan, tetapi dalam proyek nyata itu tersebar di berbagai fungsi, potongan-potongan kode, tidak begitu mudah untuk dilihat dengan mata.  Dukungan untuk kode semacam itu juga cukup rumit.  Terutama ketika Anda datang ke proyek baru, Anda diberitahu bahwa Anda perlu membuat fitur seperti itu, Anda menambahkan beberapa kondisi, memeriksa skenario positif, semuanya bekerja, tetapi kemudian penguji datang dan mengatakan bahwa dalam kondisi tertentu semuanya rusak.  Ini terjadi karena Anda sama sekali tidak memperhitungkan skenario apa pun. <br><br>  Plus, itu berlebihan dalam arti bahwa karena kita memiliki cabang besar kondisi, kita harus memeriksa semua kondisi yang tidak sesuai dengan kita sebelumnya.  Mereka negatif sebelumnya, tetapi karena mereka ditulis dengan cabang seperti itu, kita harus memeriksanya.  Faktanya adalah bahwa dalam contoh saya memiliki semacam bendera Boolean, tetapi dalam praktiknya, Anda mungkin memiliki panggilan ke fungsi yang masuk ke suatu tempat lebih dalam ke dalam basis data.  Apa pun bisa, karena redundansi akan ada rem tambahan. <br><br>  Dan hal yang paling menyedihkan adalah beberapa perilaku tak terduga yang terlewatkan selama fase pengujian, tidak ada yang terjadi di sana, dan di suatu tempat dalam produksi pengguna tidak terjadi yang terbaik, semacam kurva UI, dan yang terburuk - itu jatuh atau data hilang .  Hanya saja aplikasinya tidak berperilaku konsisten. <br><br>  Bagaimana cara mengatasi masalah ini?  Dengan kekuatan mesin negara. <br><br><img src="https://habrastorage.org/webt/_7/tj/-0/_7tj-0szm6wntxwaty3doc69isg.jpeg"><br><br>  Tugas utama yang ditangani oleh mesin keadaan adalah mengambil tugas rumit yang besar dan memecahnya menjadi kondisi diskrit kecil yang lebih mudah untuk berinteraksi dengan dan mengelola.  Setelah duduk, berpikir, karena kita mencoba melakukan sesuatu MVP, bagaimana cara mengikat negara kita dengan semua ini?  Kami telah mendekati skema semacam itu.  Siapa pun yang membaca buku GOF adalah pola keadaan klasik, hanya apa yang disebut konteks, saya menyebutnya negara-oner, dan pada kenyataannya itu adalah presenter.  Presenter memiliki status ini, tahu cara mengalihkannya, dan masih dapat memberikan beberapa data ke status kami jika mereka ingin mengetahui sesuatu, misalnya ukuran file atau ingin meminta permintaan asinkron, pilih. <br><br><img src="https://habrastorage.org/webt/9r/kk/dz/9rkkdzixpvbrbgzcijhav5ap22k.jpeg"><br><br>  Tidak ada yang super duper di sini, slide berikutnya lebih penting. <br><br><img src="https://habrastorage.org/webt/w0/ct/ae/w0ctaej1zhv5xticgrxlmaasybo.jpeg"><br><br>  Dengan ini, Anda perlu memulai pengembangan ketika Anda mulai membuat mesin negara.  Anda duduk di depan komputer atau di suatu tempat di sekitar meja, dan di atas selembar kertas atau di alat khusus menggambar diagram keadaan.  Tidak ada yang rumit, tetapi tahap ini memiliki banyak keuntungan.  Pertama, pada tahap awal, Anda dapat segera mendeteksi beberapa inkonsistensi dalam logika bisnis.  Produk Anda mungkin datang, ungkapkan keinginan mereka, semuanya baik-baik saja, tetapi ketika Anda mulai menulis kode, Anda memahami bahwa ada sesuatu yang tidak cocok bersama.  Saya pikir semua orang punya situasi seperti itu.  Tetapi ketika Anda membuat diagram, Anda dapat melihat pada tahap awal bahwa ada sesuatu yang tidak docking.  Ini digambar cukup sederhana, ada alat khusus seperti PlantUML, di mana Anda bahkan tidak perlu dapat menggambar, Anda harus dapat menulis kode pseudocode, dan itu sendiri menghasilkan grafik. <br><br>  Bagan kami terlihat seperti ini, yang menggambarkan keadaan dialog ini.  Ada beberapa negara dan logika transisi di antara mereka. <br><br><img src="https://habrastorage.org/webt/ec/84/hl/ec84hlidyk6-olcmjrar9s2oiq0.jpeg"><br><br>  Mari kita beralih ke kode.  Nyatakan sendiri, tidak ada yang penting, yang utama adalah bahwa ia memiliki tiga metode: onEnter, yang ketika masuk, memanggil invalidateView terlebih dahulu.  Mengapa ini dilakukan?  Sehingga segera setelah kami masuk ke negara, UI diperbarui.  Plus ada metode invalidateView, yang kelebihan beban kita jika kita perlu melakukan sesuatu dengan UI, dan metode onExit, di mana kita dapat melakukan sesuatu jika kita keluar dari keadaan. <br><br><img src="https://habrastorage.org/webt/zo/ld/5s/zold5sqpcjeu_1z3mq48c4jnos4.jpeg"><br><br>  Pemilik Negara.  Antarmuka yang menyediakan kemampuan untuk mengklik status.  Seperti yang kita ketahui, itu akan menjadi presenter masa depan.  Dan ini adalah metode yang menyediakan akses tambahan ke data.  Jika ada data yang digeledah antar negara bagian, kita dapat menyimpannya di presenter dan memberikannya melalui antarmuka ini.  Dalam hal ini, kita dapat memberikan ukuran file yang dapat kita bersihkan, dan memberikan kesempatan untuk membuat semacam permintaan.  Kami dalam keadaan, kami ingin meminta sesuatu dan melalui StateOwner kami dapat memanggil metode. <br><br>  Kegunaan lain yang demikian adalah bahwa ia juga dapat mengembalikan tautan ke tampilan.  Ini dilakukan agar jika Anda memiliki keadaan dan beberapa data tiba, Anda tidak ingin beralih ke keadaan baru, itu hanya berlebihan, Anda dapat langsung memperbarui tampilan, teks.  Kami menggunakan ini untuk memperbarui jumlah digit yang dilihat pengguna ketika dia melihat dialog.  Kami sedang mengunduh file runtime, dia melihat dialog, dan nomor diperbarui.  Kami tidak pindah ke keadaan baru, kami hanya memperbarui tampilan saat ini. <br><br><img src="https://habrastorage.org/webt/og/ug/pq/ogugpqbvlhyh5rfxwyofcz22my8.jpeg"><br><br>  Ini adalah MVP standar, semuanya harus sangat sederhana, tidak ada logika, metode sederhana yang menggambar sesuatu.  Saya mematuhi konsep ini.  Seharusnya tidak ada logika, setidaknya semacam tindakan.  Kami mengambil beberapa Text View, mengubahnya, tidak lagi. <br><br><img src="https://habrastorage.org/webt/8h/-f/zf/8h-fzfwagetflmtss66is8shzly.jpeg"><br><br>  Presenter  Ada hal yang lebih menarik.  Pertama-tama, kita dapat meraba-raba data melewatinya untuk beberapa negara, kita memiliki dua variabel yang ditandai dengan penjelasan Negara.  Siapa yang menggunakan Icepick sudah terbiasa dengannya.  Kami tidak menulis serialisasi dengan tangan kami di Partible, kami menggunakan perpustakaan yang sudah jadi. <br><br>  Berikut ini adalah keadaan awal.  Itu selalu berguna untuk mengatur keadaan awal, bahkan jika itu tidak melakukan apa-apa.  Kegunaannya adalah Anda tidak perlu melakukan cek nol, tetapi jika kami mengatakan itu bisa melakukan sesuatu.  Misalnya, Anda perlu melakukan sesuatu sekali untuk siklus hidup aplikasi Anda, ketika kami mulai, Anda perlu menjalankan prosedur sekali, dan tidak pernah melakukannya lagi.  Ketika kita keluar dari keadaan awal, kita selalu dapat melakukan sesuatu seperti ini, dan kita tidak pernah kembali ke keadaan ini.  Ketik begitu diagram keadaan digambar.  Meski siapa tahu siapa yang akan menggambar, mungkin Anda bisa kembali. <br><br>  Saya mendukung meminimalkan pemeriksaan untuk Null dan sebagainya, jadi di sini saya menyimpan tautan ke implementasi tampilan sederhana.  Kita tidak perlu menyinkronkan apa pun, hanya pada titik tertentu ketika detach terjadi, kita mengganti tampilan dengan yang kosong, dan presenter dapat beralih ke suatu tempat di negara, berpikir bahwa ada tampilan, itu memperbaruinya, tetapi sebenarnya itu berfungsi dengan implementasi kosong. <br><br>  Ada beberapa metode lagi untuk menyelamatkan negara, tetapi kami ingin selamat dari pergolakan Kegiatan, dalam hal ini semua dilakukan melalui konstruktor.  Semuanya sedikit lebih rumit, ini contoh yang dilebih-lebihkan. <br><br><img src="https://habrastorage.org/webt/rk/a2/1m/rka21mszygspy9cjuprcqgv9afi.jpeg"><br><br>  Hal ini diperlukan untuk meneruskan saveState, jika seseorang bekerja dengan perpustakaan yang sama, semuanya sangat sepele.  Anda dapat menulis dengan tangan Anda.  Dan dua metode sangat penting: melampirkan, memanggil onStart, dan melepaskan, dipanggil onStop. <br><br><img src="https://habrastorage.org/webt/p4/dq/n2/p4dqn2m5adpxmsfybd7fctrjc0a.jpeg"><br><br>  Apa pentingnya mereka?  Awalnya, kami berencana untuk melampirkan dan melepaskan di onCreateView, onDestroyView, tetapi ini tidak cukup.  Jika Anda memiliki Tampilan, teks Anda dapat diperbarui, atau fragmen dialog mungkin muncul.  Dan jika Anda tidak terjebak di Stop, dan kemudian mencoba menampilkan fragmen, Anda akan mengetahui pengecualian terkenal bahwa Anda tidak dapat melakukan transaksi ketika kami masih memiliki status.  Baik menggunakan negara kehilangan, atau tidak.  Oleh karena itu, kami dirinci dalam onStop, sementara presenter akan terus bekerja di sana, berganti status, menangkap acara.  Dan pada saat itu ketika mulai terjadi, kami akan memicu tampilan acara terlampir, dan presenter akan memperbarui UI agar sesuai dengan keadaan saat ini. <br><br><img src="https://habrastorage.org/webt/fk/r6/op/fkr6op8zellkewd81kh7omqaxto.jpeg"><br><img src="https://habrastorage.org/webt/my/sb/t8/mysbt8ecs5ap56d5o_jyndzgp_a.jpeg"><br><br>  Ada metode rilis, biasanya disebut di onDestroy, Anda membuat sumber daya terlepas dan melepaskan. <br><br><img src="https://habrastorage.org/webt/f9/lg/-d/f9lg-db1fwe27xwd09pg1yltu44.jpeg"><br><br>  Metode setState penting lainnya.  Karena kami berencana mengubah UI di onEnter dan onExit, ada cek untuk utas utama.  Ini menciptakan batasan bagi kami bahwa kami tidak melakukan sesuatu yang berat di sini, semua permintaan harus ke UI, atau harus tidak sinkron.  Keuntungan dari tempat ini adalah bahwa di sini kita dapat memesan pintu masuk dan keluar dari keadaan, sangat berguna saat debugging, misalnya, ketika terjadi kesalahan, Anda dapat melihat bagaimana sistem mengklik dan memahami apa yang salah. <br><br><img src="https://habrastorage.org/webt/sh/bx/nx/shbxnx_e_4myifye8ucidtdpj7e.jpeg"><br><br>  Beberapa contoh kondisi.  Ada keadaan awal, itu hanya memicu perhitungan berapa banyak ruang yang Anda butuhkan untuk membebaskan pada saat tampilan menjadi tersedia.  Ini akan terjadi setelah onStart.  Begitu onStart terjadi, kami masuk ke keadaan baru, dan sistem mulai meminta data. <br><br><img src="https://habrastorage.org/webt/nt/cy/i3/ntcyi3chfp0yvgyiauig5gegy2c.jpeg"><br><br><img src="https://habrastorage.org/webt/f4/bq/j-/f4bqj-kaebdsnml-dpa-azvgrmm.jpeg"><br><br>  Contoh negara adalah Menghitung, kami akan menyatakan ukuran file dengan stateOwner, entah bagaimana merayapi ke dalam database, dan kemudian masih ada inValidateView, kami memperbarui UI pengguna saat ini.  Dan viewAttached dipanggil jika tampilan disambungkan kembali.  Jika kami berada di latar belakang, Menghitung ada di latar belakang, kami kembali ke Aktivitas kami, metode ini dipanggil dan memperbarui semua data. <br><br><img src="https://habrastorage.org/webt/eu/fg/5f/eufg5fb-rwg6keerfqik_skfo44.jpeg"><br><br>  Sebagai contoh acara, kami bertanya pada stateOwner berapa banyak file yang dapat dibebaskan, dan ia memanggil metode filesSizeUpdated.  Di sini saya terlalu malas, mungkin untuk menulis tiga metode terpisah, seperti diperbarui, ada banyak file lama seperti cara memisahkan berbagai peristiwa.  Tetapi Anda harus mengerti, sekali itu akan sulit bagi Anda, sekali itu akan jauh lebih sederhana.  Tidak perlu mengalami overengineering bahwa setiap peristiwa adalah metode yang terpisah.  Anda dapat bertahan dengan sederhana jika, saya tidak melihat ada yang salah dengan itu. <br><br><img src="https://habrastorage.org/webt/r0/ge/tx/r0getxszg4i3mwlruqqybl-mffm.jpeg"><br><br>  Saya melihat beberapa peningkatan potensial.  Saya tidak suka kita dipaksa untuk menggunakan metode ini, seperti onStart, on Stop, onCreate, onSave, dan banyak lagi.  Anda dapat terhubung dengan Lifecycle, tetapi tidak jelas apa yang harus dilakukan dengan saveState.  Ada ide, misalnya, untuk membuat fragmen presenter.  Kenapa tidak  Sebuah fragmen tanpa UI yang menangkap siklus hidup, dan secara umum kita tidak membutuhkan apa-apa, semuanya akan terbang kepada kita dengan sendirinya. <br><br>  Hal lain yang menarik: presenter ini diciptakan kembali setiap kali, dan jika Anda memiliki data besar yang disimpan dalam presenter, Anda pergi ke database, memegang kursor besar, maka itu tidak dapat diterima untuk meminta setiap kali Anda memutar layar.  Oleh karena itu, Anda dapat men-cache presenter, seperti halnya, misalnya, ViewModule dari Architecture Components, membuat beberapa fragmen yang akan menahan cache presenter dan mengembalikannya untuk setiap tampilan. <br><br>  Anda dapat menggunakan cara tabular untuk menentukan mesin negara, karena pola keadaan yang kami gunakan memiliki satu kelemahan signifikan: segera setelah Anda perlu menambahkan satu metode ke acara baru, Anda harus menambahkan implementasi ke semua keturunan.  Setidaknya kosong.  Atau melakukannya dalam kondisi dasar.  Ini sangat tidak nyaman.  Jadi cara tabular menentukan mesin keadaan digunakan di semua perpustakaan - jika Anda mencari di GitHub untuk kata FSM, Anda akan menemukan sejumlah besar perpustakaan yang memberi Anda semacam pembangun tempat Anda mengatur keadaan awal, acara dan keadaan akhir.  Memperluas dan merawat mesin keadaan seperti itu jauh lebih mudah. <br><br>  Hal lain yang menarik: jika Anda menggunakan pola keadaan, jika mesin negara Anda mulai tumbuh, kemungkinan besar Anda harus menangani beberapa peristiwa dengan cara yang sama sehingga kode tidak disalin, Anda membuat keadaan dasar.  Semakin banyak peristiwa, semakin banyak kondisi dasar mulai muncul, hierarki tumbuh, dan terjadi kesalahan. <br><br>  Seperti kita ketahui, warisan harus diganti oleh delegasi, dan mesin negara hierarkis membantu menyelesaikan masalah ini.  Anda memiliki status yang tidak bergantung pada tingkat warisan - cukup bangun pohon status yang melewati pawang di atas.  Anda juga dapat membaca secara terpisah, suatu hal yang sangat berguna.  Di Android, misalnya, mesin status hierarkis digunakan di WatchDog Wi-Fi, yang memantau status jaringan, mereka ada di sana, tepat di sumber Android. <br><br><img src="https://habrastorage.org/webt/kd/qn/cn/kdqncnx-u10ovabuexg_h-kdxiu.jpeg"><br><br>  Terakhir tapi tidak kalah pentingnya.  Bagaimana ini bisa diuji?  Pertama-tama, keadaan deterministik dapat diuji.  Ada keadaan terpisah, kami membuat sebuah instance, menarik metode onEnter dan melihat bahwa nilai-nilai yang sesuai dipanggil dalam tampilan.  Dengan demikian, kami memvalidasi bahwa negara kami memperbarui Tampilan dengan benar.  Jika Tampilan Anda tidak serius, maka kemungkinan besar Anda akan membahas sejumlah besar skenario. <br><br><img src="https://habrastorage.org/webt/bc/mn/o_/bcmno_pvrehzh447tidyzn3nd5w.jpeg"><br><br>  Anda dapat mengunci beberapa metode dengan fungsi yang mengembalikan ukuran, memanggil acara lain setelah onEnter dan melihat bagaimana keadaan tertentu merespons peristiwa tertentu.  Dalam hal ini, ketika peristiwa filesSizeUpdated terjadi dan ketika AllFilesSize lebih besar dari nol, kita harus beralih ke status CleanAllFiles baru.  Dengan bantuan tata letak, kami memeriksa semua ini. <br><br><img src="https://habrastorage.org/webt/1z/pu/lp/1zpulp09kyd3vcr2xhcevmum4rm.jpeg"><br><br>  Dan yang terakhir - kita dapat menguji keseluruhan sistem.  Kami membangun negara, mengirim acara ke sana dan memeriksa bagaimana sistem berperilaku.  Kami memiliki tiga tahap pengujian.  ,   UI,  ,    ,   ,       . <br><br>      ,     70%.  80%     .  ,    . <br><br><img src="https://habrastorage.org/webt/tu/pz/qx/tupzqxbhu35qyqjpzhx0_xc6kxu.jpeg"><br><br>   ,   ?    — . -        . <br><br> .        .   - ,   ,  -     ,   —    ,          . <br><br>     -  ,  ,    ,    .    ,   ,     .    ,        ,     .    -    ,    ,   .    , ,   .     lock   .   - ,     . <br><br>   — .   ,       ,           ,     ,   . ,   - , ,  -,    ,   .     ,      .   , . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418561/">https://habr.com/ru/post/id418561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418549/index.html">Membuat bot untuk berpartisipasi dalam AI mini cup 2018 berdasarkan pada jaringan saraf berulang (bagian 3)</a></li>
<li><a href="../id418551/index.html">Berapa banyak yang harus diketahui seorang programmer matematika?</a></li>
<li><a href="../id418553/index.html">Kotlin + Bereaksi vs Javasript + Bereaksi</a></li>
<li><a href="../id418557/index.html">Perhitungan proses gelombang dalam saluran hidrolik menggunakan metode karakteristik</a></li>
<li><a href="../id418559/index.html">NL2API: Membuat Antarmuka Bahasa Alami untuk API Web</a></li>
<li><a href="../id418563/index.html">Intisari materi menarik untuk pengembang seluler # 263 (23 Juli - 29 Juli)</a></li>
<li><a href="../id418565/index.html">Dalam perjalanan ke cakupan kode 100% dengan tes di Go menggunakan sql-dumper sebagai contoh</a></li>
<li><a href="../id418567/index.html">Dell akan berhenti menjadi perusahaan swasta dan untuk pertama kalinya dalam 5 tahun akan menempatkan saham di bursa saham</a></li>
<li><a href="../id418569/index.html">Satelit baru - bug baru: Sensor inframerah satelit GOES-17 tidak sejuk</a></li>
<li><a href="../id418573/index.html">Waterius: Transfer pembacaan air ke telepon melalui Wi-Fi (4 tahun dengan baterai)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>