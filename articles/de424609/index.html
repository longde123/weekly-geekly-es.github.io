<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☘️ 🙎🏼 ✌🏿 So erweitern Sie Kubernetes 👦 🚢 👩🏽‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute werden wir über DevOps oder vielmehr hauptsächlich über Ops sprechen. Sie sagen, dass es nur sehr wenige Menschen gibt, die mit dem Automatisier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So erweitern Sie Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/424609/">  Heute werden wir über DevOps oder vielmehr hauptsächlich über Ops sprechen.  Sie sagen, dass es nur sehr wenige Menschen gibt, die mit dem Automatisierungsgrad ihrer Abläufe zufrieden sind.  Aber die Situation scheint reparabel zu sein.  In diesem Artikel wird Nikolai Ryzhikov über seine Erfahrungen mit der Erweiterung von Kubernetes sprechen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1a/4f7/1a2/b1a4f71a2809a5b098e738ed4e0b5d3f.png"><br><br>  Das Material wurde auf der Grundlage von Nikolais Rede auf der Herbstkonferenz DevOops 2017 vorbereitet. Unter dem Schnitt - Video- und Textprotokoll des Berichts. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3BMTNx2xCtQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  <i>Derzeit arbeitet Nikolai Ryzhikov im Gesundheits-IT-Bereich an der Schaffung medizinischer Informationssysteme.</i>  <i>Mitglied der St. Petersburger Community der funktionalen Programmierer FPROG.</i>  <i>Aktives Mitglied der Online Clojure-Community, Mitglied des HL7 FHIR-Standards für den Austausch medizinischer Informationen.</i>  <i>Programmiert seit 15 Jahren.</i> <br><hr><br>  Welche Seite haben wir für DevOps?  Seit 10 Jahren ist unsere DevOps-Formel recht einfach: Entwickler sind für den Betrieb verantwortlich, Entwickler werden bereitgestellt, Entwickler werden gewartet.  Mit diesem Arrangement, das etwas hart aussieht, werden Sie auf jeden Fall zu DevOps.  Wenn Sie DevOps schnell und schmerzhaft implementieren möchten, machen Sie die Entwickler für Ihre Produktion verantwortlich.  Wenn die Jungs klug sind, werden sie anfangen, rauszukommen und alles zu verstehen. <br><img src="https://habrastorage.org/getpro/habr/post_images/8f4/799/e0d/8f4799e0d6f25b897b6bd72f2ba1081a.png"><br>  Unsere Geschichte: Vor langer Zeit, als es keinen Chef und keine Automatisierung gab, haben wir bereits das automatische Capistrano eingesetzt.  Dann fingen sie an, ihn zu langweilen, damit er Mode machen würde.  Aber dann erschien Chef.  Wir wechselten dorthin und gingen in die Cloud: Wir hatten unsere Rechenzentren satt.  Dann erschien Ansible, Docker stand auf.  Danach zogen wir mit dem handgeschriebenen Condo Docker Supervisor auf Camel nach Terraform.  Und jetzt ziehen wir nach Kubernetes. <br><img src="https://habrastorage.org/getpro/habr/post_images/366/af1/be8/366af1be8b4c4cf204553b48c8a76e70.png"><br>  Was ist das Schlimmste an Operationen?  Nur sehr wenige Menschen sind mit dem Automatisierungsgrad ihrer Abläufe zufrieden.  Ich bestätige, dass dies beängstigend ist: Wir haben viele Ressourcen und Anstrengungen aufgewendet, um all diese Stapel für uns selbst zu sammeln, und das Ergebnis ist unbefriedigend. <br><br>  Es besteht das Gefühl, dass sich mit dem Aufkommen von Kubernetes etwas ändern kann.  Ich bin der schlanken Fertigung verpflichtet und aus seiner Sicht sind Operationen im Allgemeinen nicht nützlich.  Ideale Operationen sind das Fehlen oder Minimum von Operationen in einem Projekt.  Wert entsteht, wenn ein Entwickler ein Produkt herstellt.  Wenn es fertig ist, bringt die Lieferung keinen Mehrwert.  Aber Sie müssen die Kosten senken. <br><img src="https://habrastorage.org/getpro/habr/post_images/731/1a4/6e3/7311a46e3eb4d1d73d788f6ee881be3a.png"><br>  Für mich war das Ideal immer Heroku.  Wir haben es für einfache Anwendungen verwendet, bei denen der Entwickler seinen Dienst bereitstellte. Es genügte, git push zu sagen und heroku zu konfigurieren.  Es dauert eine Minute. <br><img src="https://habrastorage.org/getpro/habr/post_images/a57/4c0/12b/a574c012ba1158086cd3578287d6d2a9.png"><br>  Wie man ist  Sie können NoOps kaufen - auch Heroku.  Und ich rate Ihnen zu kaufen, sonst besteht die Möglichkeit, mehr Geld für die Entwicklung des normalen Betriebs auszugeben. <br><br>  Es gibt Deis-Leute, die versuchen, so etwas wie Heroku auf Kubernetes zu machen.  Es gibt eine Cloud-Gießerei, die auch eine Plattform bietet, auf der gearbeitet werden kann. <br><img src="https://habrastorage.org/getpro/habr/post_images/bbd/7b9/7e0/bbd7b97e07aae6af9a54663d633e3cc2.png"><br>  Aber wenn Sie sich mit etwas Komplexerem oder Großem beschäftigen, können Sie es selbst tun.  Zusammen mit Docker und Kubernetes wird dies nun zu einer Aufgabe, die in angemessener Zeit und zu angemessenen Kosten erledigt werden kann.  Früher war es zu hart. <br><img src="https://habrastorage.org/getpro/habr/post_images/299/2d2/90a/2992d290a7167b9fe4a8cf2320528b8e.png"><br><h2>  Ein bisschen über Docker und Kubernetes </h2><br>  Eines der Probleme bei Operationen ist die Wiederholbarkeit.  Das Tolle, was der Docker gebracht hat, sind zwei Phasen.  Wir haben eine Bauphase. <br><br>  Der zweite Punkt, der dem Docker gefällt, ist eine universelle Schnittstelle zum Starten beliebiger Dienste.  Jemand hat Docker zusammengebaut, etwas hineingesteckt und Operationen ausgeführt. Es reicht aus, zu sagen, dass Docker ausgeführt und gestartet wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b4/ca2/5ad/0b4ca25ade4ae7d3513539aaa576d3e7.png"><br><br>  Was ist Kubernetes?  Also haben wir Docker erstellt und müssen es irgendwo starten, integrieren, konfigurieren und mit anderen verbinden.  Mit Kubernetes können Sie dies tun.  Er führt eine Reihe von Abstraktionen ein, die als "Ressource" bezeichnet werden.  Wir werden sie schnell durchgehen und sogar versuchen zu schaffen. <br><br><h2>  Abstraktion </h2><br>  Die erste Abstraktion ist ein POD oder eine Reihe von Containern.  Richtig gemacht, was genau ist ein <b>Satz von</b> Containern und nicht einer.  Sets können untereinander Volumes durchsuchen, die sich über localhost sehen.  Auf diese Weise können Sie ein Muster wie einen Beiwagen verwenden (dies ist der Zeitpunkt, an dem wir den Hauptcontainer starten, und es befinden sich Hilfscontainer in der Nähe, die ihm helfen). <br><br>  Zum Beispiel der Botschafteransatz.  In diesem Fall soll der Container nicht darüber nachdenken, wo sich einige Dienste befinden.  Sie stellen einen Container daneben, der weiß, wo sich diese Dienste befinden.  Und sie werden für den Hauptcontainer auf localhost verfügbar.  Daher sieht die Umgebung so aus, als würden Sie lokal arbeiten. <br><img src="https://habrastorage.org/getpro/habr/post_images/0b8/ab5/bda/0b8ab5bdae5f0d0e7375ff1b08efc6ee.png"><br>  Lassen Sie uns den POD erhöhen und sehen, wie er beschrieben wird.  Vor Ort kann man Minikube entwickeln.  Es verbraucht eine Menge CPUs, aber Sie können einen kleinen Kubernetes-Cluster auf einer Virtualbox erstellen und damit arbeiten. <br><br>  Lassen Sie uns POD bereitstellen.  Ich sagte, Kubernetes bewerben sich und überfluteten den POD.  Ich kann sehen, welche PODs ich habe: Ich sehe, dass ein POD bereitgestellt wird.  Dies bedeutet, dass Kubernetes diese Container gestartet hat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/862/d90/970862d90a9afea1066caa69c1af63c8.png"></div><br>  Ich kann sogar in diesen Container gehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/603/8f7/1226038f78d2c9593826e7f26d611853.png"></div><br>  Aus dieser Perspektive ist Kubernetes für Menschen gemacht.  In der Tat kann das, was wir ständig im Betrieb tun, beispielsweise bei der Kubernetes-Bindung, beispielsweise mit dem Dienstprogramm kubectl, problemlos durchgeführt werden. <br><br>  Aber POD ist sterblich.  Es beginnt als Docker-Lauf: Wenn jemand es stoppt, wird es niemand anheben.  Zusätzlich zu dieser Abstraktion beginnt Kubernetes, Folgendes zu erstellen - beispielsweise ein Replikatset.  Dies ist ein solcher Supervisor, der die PODs überwacht, ihre Anzahl überwacht und wenn die PODs fallen, werden sie angehoben.  Dies ist ein wichtiges Selbstheilungskonzept in Kubernetes, mit dem Sie nachts ruhig schlafen können. <br><br>  Über dem Replikatsatz befindet sich eine Abstraktion der Bereitstellung - auch eine Ressource, mit der Sie eine zeitlose Bereitstellung durchführen können.  Beispielsweise funktioniert ein Replikatsatz.  Wenn wir die Version des Containers, z. B. unsere, innerhalb der Bereitstellung bereitstellen und ändern, steigt ein weiteres Replikatset an.  Wir warten, bis diese Container gestartet sind, durchlaufen ihre Integritätsprüfungen und wechseln dann schnell zum neuen Replikatsatz.  Auch klassische und gute Praxis. <br><img src="https://habrastorage.org/getpro/habr/post_images/02e/d07/f33/02ed07f333733af0155ee539be18c669.png"><br>  Lassen Sie uns einen einfachen Service abholen.  Zum Beispiel haben wir eine Bereitstellung.  Im Inneren beschreibt er das Muster der PODs, die er aufnehmen wird.  Wir können diese Bereitstellung anwenden und sehen, was wir haben.  Coole Funktion von Kubernetes - alles liegt in der Datenbank und wir können beobachten, was im System passiert. <br><br>  Hier sehen wir eine Bereitstellung.  Wenn wir versuchen, die PODs zu betrachten, sehen wir, dass einige PODs gestiegen sind.  Wir können diesen POD nehmen und entfernen.  Was passiert mit PODs?  Einer wird zerstört und der zweite steigt sofort auf.  Dieser Replikatset-Controller hat den gewünschten POD nicht gefunden und einen anderen gestartet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/524/7f4/0d4/5247f40d4fb21eb93bda0ce14124245e.png"></div><br>  Wenn es sich um eine Art Webdienst handelt oder innerhalb unserer Dienste kommunizieren muss, benötigen wir eine Serviceerkennung.  Sie müssen dem Dienst einen Namen und einen Einstiegspunkt geben.  Kubernetes bietet hierfür eine Ressource namens Service an.  Er kann den Lastausgleich übernehmen und für die Serviceerkennung verantwortlich sein. <br><img src="https://habrastorage.org/getpro/habr/post_images/2fa/926/6e5/2fa9266e57c6718a81241ae1ac15da8e.png"><br>  Sehen wir uns einen einfachen Service an.  Wir verbinden es mit Deployment und PODs über Labels: eine solche dynamische Verbindung.  Ein sehr wichtiges Konzept in Kubernetes: Das System ist dynamisch.  Es spielt keine Rolle, in welcher Reihenfolge all dies erstellt wird.  Der Service wird versuchen, PODs mit solchen Etiketten zu finden und deren Lastausgleich zu starten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b48/992/f7d/b48992f7dca832fce9b45276936a4914.png"></div><br>  Service anwenden, schauen Sie, welche Services wir haben.  Wir gehen in unseren Test-POD, der ausgelöst wurde, und machen nslookup.  Kubernetes gibt uns ein DNS-ku, über das Dienste sich gegenseitig sehen und entdecken können. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b05/66f/01e/b0566f01e54210ea26c5b6526b0ed0de.png"></div><br>  Service ist eher eine Schnittstelle.  Es gibt verschiedene Implementierungen, da die Aufgaben des Lastausgleichs und des Dienstes ziemlich kompliziert sind: Auf die eine Weise arbeiten wir mit normalen Datenbanken, auf der anderen mit geladenen und einige einfache sind recht einfach.  Dies ist auch ein wichtiges Konzept in Kubernetes: Einige Dinge können eher als Schnittstellen als als Implementierungen bezeichnet werden.  Sie sind nicht starr festgelegt, und unterschiedliche Cloud-Anbieter bieten beispielsweise unterschiedliche Implementierungen an.  Das heißt, es gibt beispielsweise ein ressourcenbeständiges Volume, das bereits regelmäßig in jeder einzelnen Cloud implementiert ist. <br><br>  Als nächstes möchten wir normalerweise den Webdienst herausbringen.  Kubernetes hat eine Ingress-Abstraktion.  Normalerweise wird dort SSL hinzugefügt. <br><img src="https://habrastorage.org/getpro/habr/post_images/fc7/69e/4e7/fc769e4e7a526588c3f3ae32388d9c11.png"><br>  Der einfachste Eingang sieht ungefähr so ​​aus.  Dort schreiben wir die Regeln: Für welche URLs, für welche Hosts, für welchen internen Service soll die Anfrage umgeleitet werden.  Auf die gleiche Weise können wir unseren Eintritt erhöhen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69d/79c/046/69d79c046478f1fde2a073f2fe37067f.png"></div><br>  Nachdem Sie sich lokal bei den Hosts registriert haben, können Sie diesen Service von hier aus sehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73d/752/75c/73d75275c26a468f49cd192e781595db.png"></div><br>  Dies ist eine so regelmäßige Aufgabe: Wir haben einen bestimmten Webdienst bereitgestellt und uns ein wenig mit Kubernetes getroffen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a3/1f8/c2f/1a31f8c2f639a4758d95719ee6dca1e0.png"></div><br>  Wir werden alles bereinigen, das Eindringen entfernen und alle Ressourcen untersuchen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c75/990/40c/c7599040cd85c2c155e8acf057be0246.png"></div><br>  Es gibt eine Reihe von Ressourcen, wie z. B. configmap und secret.  Hierbei handelt es sich um reine Informationsressourcen, die Sie in einen Container einbinden und dort beispielsweise das Passwort von postgres übertragen können.  Sie können dies Umgebungsvariablen zuordnen, die beim Start in den Container eingefügt werden.  Sie können das Dateisystem mounten.  Alles ist ganz bequem: Standardaufgaben, schöne Lösungen. <br><br>  Es gibt ein dauerhaftes Volumen - eine Schnittstelle, die von verschiedenen Cloud-Anbietern unterschiedlich implementiert wird.  Es ist in zwei Teile unterteilt: Es gibt einen dauerhaften Volumenanspruch (Anforderung), und dann wird ein EBS erstellt, das sich in den Container zieht.  Sie können mit Stateful Service arbeiten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd6/5c1/2f7/cd65c12f71d417ffd11e3e62c76b484c.png"><br><br>  Aber wie funktioniert es innen?  Das Konzept selbst ist sehr einfach und transparent.  Kubernetes besteht aus zwei Teilen.  Eine ist nur eine Datenbank, in der wir alle diese Ressourcen haben.  Ressourcen können als Tablets betrachtet werden: Insbesondere handelt es sich bei diesen Instanzen lediglich um Aufzeichnungen in Tablets.  Zusätzlich zu Kubernetes ist ein API-Server konfiguriert.  Das heißt, wenn Sie einen Kubernetes-Cluster haben, kommunizieren Sie normalerweise mit dem API-Server (genauer gesagt, der Client kommuniziert mit ihm). <br><br>  Dementsprechend wird das, was wir erstellt haben (PODs, Dienste usw.), einfach in die Datenbank geschrieben.  Diese Datenbank wird durch ETCD implementiert, d.h.  so dass es auf dem hochverfügbaren Niveau stabil ist. <br><br>  Was kommt als nächstes?  Weiter gibt es unter jeder Art von Ressourcen einen bestimmten Controller.  Dies ist nur ein Dienst, der seine Art von Ressource überwacht und etwas in der Außenwelt tut.  Wird beispielsweise ein Docker ausgeführt?  Wenn wir PODs haben, gibt es für jeden Knoten einen Kubelet-Dienst, der die PODs überwacht, die an diesen Knoten angeschlossen sind.  Und alles, was er tut, ist, dass Docker nach der nächsten regelmäßigen Überprüfung ausgeführt wird, ob dieser POD nicht vorhanden ist. <br><br>  Was sehr wichtig ist - alles geschieht in Echtzeit, sodass die Leistung dieses Controllers höher als das Minimum ist.  Oft nimmt der Controller immer noch die Metriken und schaut sich an, was er gestartet hat.  Das heißt,  Entfernt das Feedback aus der realen Welt und schreibt es in die Datenbank, damit Sie oder andere Controller es sehen können.  Beispielsweise wird derselbe POD-Status in ETCD zurückgeschrieben. <br><br>  Somit ist alles in Kubernetes implementiert.  Es ist sehr cool, dass das Informationsmodell vom Operationssaal getrennt ist.  In der Datenbank deklarieren wir über die übliche CRUD-Schnittstelle, was sein soll.  Dann versucht der Satz von Controllern, alles richtig zu machen.  Das passiert zwar nicht immer. <br><br>  Dies ist ein kybernetisches Modell.  Wir haben eine bestimmte Voreinstellung, es gibt eine Art Maschine, die versucht, die reale Welt oder Maschine an den Ort zu lenken, der benötigt wird.  Es stellt sich nicht immer so heraus: Wir sollten eine Rückkopplungsschleife haben.  Manchmal kann eine Maschine dies nicht und muss sich an eine Person wenden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/59e/0a9/1e8/59e0a91e8974351a5f0f49fd94709c9a.png"><br><br>  In realen Systemen denken wir in Abstraktionen der nächsten Ebene: Wir haben einige Dienste, Datenbanken und wir verbinden sie alle.  Wir denken nicht an PODs und Ingresss und möchten eine nächste Abstraktionsebene aufbauen. <br><img src="https://habrastorage.org/getpro/habr/post_images/77f/5cb/697/77f5cb6974c6ac85e0b5e8b13921d672.png"><br>  Damit der Entwickler so einfach wie möglich war: Er sagte einfach: „Ich möchte so und so einen Service starten“, und alles andere passierte im Inneren. <br><br>  Es gibt so etwas wie HELM.  Dies ist der falsche Weg - ansible Style Templating, bei dem wir nur versuchen, eine Reihe konfigurierter Ressourcen zu erzeugen und sie in einem Kubernetes-Cluster abzulegen. <br><br>  Das Problem ist zum einen, dass dies nur zum Zeitpunkt des Walzens erfolgt.  Das heißt, er kann nicht viel Logik implementieren.  Zweitens verschwindet diese Abstraktion zur Laufzeit.  Wenn ich mir meinen Cluster anschaue, sehe ich nur PODs und Dienste.  Ich sehe nicht, dass so und so ein Dienst bereitgestellt wird, dass dort so und so eine Basis mit Replikation eingerichtet wird.  Ich sehe dort nur Dutzende von Herden.  Die Abstraktion verschwindet wie in einer Matrix. <br><img src="https://habrastorage.org/getpro/habr/post_images/696/6e6/9bd/6966e69bd8b289229194911f62a11f84.png"><br><h2>  Internes Lösungsmodell </h2><br>  Auf der anderen Seite bietet Kubernetes selbst bereits ein sehr interessantes und einfaches Erweiterungsmodell im Inneren.  Wir können neue Arten von Ressourcen deklarieren, zum Beispiel die Bereitstellung.  Dies ist eine Ressource, die auf PODs oder Replikaten basiert.  Wir können einen Controller in diese Ressource schreiben, diese Ressource in die Datenbank einfügen und unsere kybernetische Schleife ausführen, damit alles funktioniert.  Das klingt interessant und es scheint mir, dass dies der richtige Weg ist, um Kubernetes zu erweitern. <br><img src="https://habrastorage.org/getpro/habr/post_images/39e/491/c51/39e491c511ea25078eda191097d88b24.png"><br>  Ich möchte in der Lage sein, nur ein Manifest für meinen Service im Heroku-Stil zu schreiben.  Ein sehr einfaches Beispiel: Ich möchte eine Art Anwendung in meiner realen Umgebung bereitstellen.  Haben bereits Vereinbarungen, SSL, Domains gekauft.  Ich möchte Entwicklern nur die einfachste Oberfläche bieten, die möglich ist.  Das Manifest sagt mir, welchen Container ich heben soll, welche Ressourcen dieser Container noch benötigt.  Er wirft diese Ankündigung in den Cluster und alles beginnt zu funktionieren. <br><img src="https://habrastorage.org/getpro/habr/post_images/a91/24e/8a8/a9124e8a8309c952cc0a65b32f28d76f.png"><br><br>  Wie wird dies in Bezug auf benutzerdefinierte Ressourcen und Controller aussehen?  Hier haben wir eine Ressourcenanwendung in der Datenbank.  Und der Anwendungscontroller erzeugt drei Ressourcen.  Das heißt, er schreibt eingehende Regeln für die Weiterleitung zu diesem Dienst auf, startet den Dienst für den Lastenausgleich und startet die Bereitstellung mit einer Konfiguration. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/807/938/d22/807938d229cb312ca761214fa30829ed.png"><br><br>  Bevor wir eine benutzerdefinierte Ressource in Kubernetes erstellen, müssen wir sie deklarieren.  Dafür gibt es eine Meta-Ressource namens CustomResourceDefinition. <br><br>  Um eine neue Ressource in Kubernetes zu deklarieren, reicht es aus, eine solche Ankündigung zu veröffentlichen.  Betrachten Sie diese Erstellungs-Tabelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/253/7d3/09e2537d3520f688c7029a357d9773dd.png"></div><br>  Erstellt eine Tabelle.  Danach können wir durch den Kubectl-Zugriff auf die Ressourcen von Drittanbietern schauen, die wir haben.  Sobald wir es angekündigt hatten, bekamen wir auch ein Banner.  Wir können zum Beispiel kubeclt Apps bekommen.  Aber bisher keine App. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5b/c40/9ad/d5bc409ad70866a12358ccb68ba497f8.png"></div><br>  Lass uns eine App schreiben.  Danach können wir eine benutzerdefinierte Ressourceninstanz erstellen.  Schauen wir es uns in YAML an und erstellen es per Post an eine bestimmte URL. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/044/e55/454/044e554549dc4dc00d262ecf49d8d72d.png"></div><br>  Wenn wir durch kubectl laufen und schauen, erscheint eine App.  Aber während nichts passiert, liegt es nur in der Datenbank.  Sie können beispielsweise alle App-Ressourcen übernehmen und anfordern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/701/234/74d/70123474de1bf62ece27d49587098368.png"></div><br>  Wir können eine zweite solche Ressource aus derselben Vorlage erstellen, indem wir einfach den Namen ändern.  Hier ist die zweite Ressource. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/842/a58/4b0/842a584b09631555234babcbd3c7e57c.png"></div><br>  Darüber hinaus sollte unser Controller Vorlagen erstellen, ähnlich wie HELM.  Das heißt, nachdem ich eine Beschreibung unserer App erhalten habe, muss ich eine Ressourcenbereitstellung und einen Ressourcenservice generieren sowie einen Eintrag in Ingress vornehmen.  Dies ist der einfachste Teil: Hier in Clojure ist Erlmacro.  Ich übergebe die Datenstruktur, sie ruft die Bereitstellungsfunktion auf, übergibt sie an das Debugging, das die Pipeline ist.  Und das ist eine reine Funktion: einfaches Templating.  Dementsprechend könnte ich es in der naivsten Form sofort erstellen, in ein Konsolendienstprogramm verwandeln und mit der Verteilung beginnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b33/bf5/2cb/b33bf52cbd901d2c5e0a0641daed9161.png"></div><br>  Dasselbe tun wir für den Service: Die Servicefunktion akzeptiert die Deklaration und generiert die Kubernetes-Ressource für uns. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/daf/e7f/c2edafe7f36d7c0db4573054991c436a.png"></div><br>  Wir machen dasselbe für die eingehende Linie. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d0/22f/156/5d022f15612aa3dcc19f635b0dd9b403.png"></div><br>  Wie wird das alles funktionieren?  Es wird etwas in der realen Welt geben und es wird geben, was wir wollen.  Was wir wollen - wir nehmen die Anwendungsressource und generieren darauf, was sie sein soll.  Und jetzt müssen wir sehen, was ist.  Was wir über die REST-API anfordern.  Wir können alle Dienste, alle Bereitstellungen erhalten. <br><br>  Wie funktioniert unser benutzerdefinierter Controller?  Er wird erhalten, was wir wollen und was ist, von diesem Div nehmen und sich bei Kubernetes bewerben.  Dies ähnelt React.  Ich habe mir ein virtuelles DOM ausgedacht, als einige Funktionen einfach einen Baum von JS-Objekten generieren.  Und dann berechnet ein bestimmter Algorithmus den Patch und wendet ihn auf das reale DOM an. <br><br>  Wir werden das gleiche hier tun.  Dies erfolgt in 50 Codezeilen.  Willst du - alles ist auf Github.  Am Ende sollten wir die Funktion zum Abgleichen von Aktionen erhalten. <br><br>  Wir haben eine Funktion zum Versöhnen von Aktionen, die nichts tut und nur diese Div berechnet.  Sie nimmt, was ist und was gebraucht wird.  Und dann gibt es heraus, was getan werden muss, um das erste zum zweiten zu bringen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/460/49b/90d/46049b90d8fa93dfe9279c02828cfa1c.png"></div><br>  Lass uns an ihr ziehen.  Es ist nichts falsch mit ihr, sie kann entkräftet werden.  Sie sagt, dass Sie einen Ingress-Service erstellen, zwei Einträge darin vornehmen, eine Bereitstellung 1 und 2 erstellen und einen Service 1 und 2 erstellen müssen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c72/c0a/c10/c72c0ac10e4924fde59ed749339345aa.png"></div><br>  In diesem Fall sollte es bereits nur einen Dienst geben.  Wir sehen vom Eingang, dass nur ein Eintrag übrig bleibt. <br><br>  Dann müssen Sie nur noch eine Funktion schreiben, die diesen Patch auf den Kubernetes-Cluster anwendet.  Dazu übergeben wir einfach Abstimmungsaktionen an die Abstimmungsfunktion, und alles wird angewendet.  Und jetzt sehen wir, dass der POD gestiegen ist, die Bereitstellung erfolgt ist und der Dienst gestartet wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66b/144/1a5/66b1441a56d805344c7e734d3b9b2c80.png"></div><br>  Fügen wir einen weiteren Dienst hinzu: Führen Sie die Funktion zum Abgleichen von Aktionen erneut aus.  Mal sehen, was passiert ist.  Alles begann, alles ist in Ordnung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32a/f9f/c1e/32af9fc1e444ed1c135e4bbe828a946f.png"></div><br>  Wie gehe ich damit um?  Wir packen das alles in einen Docker-Container.  Danach schreiben wir eine Funktion, die regelmäßig aufwacht, sich versöhnt und einschläft.  Geschwindigkeit ist nicht sehr wichtig, sie kann fünf Sekunden lang schlafen und nicht so oft Versöhnungsaktionen durchführen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bec/04e/8d1/bec04e8d1791843d80aed4f2b3f2a673.png"></div><br>  Unser benutzerdefinierter Controller ist nur ein Dienst, der den Patch aktiviert und regelmäßig berechnet. <br><br>  Jetzt haben wir zwei Dienste zaddeloino, lassen Sie uns eine der Anwendungen löschen.  Mal sehen, wie unser Cluster reagiert hat: Alles ist in Ordnung.  Wir löschen die zweite: Alles ist gelöscht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ff/a23/96e/5ffa2396ef22187604393a9ae657edd5.png"></div><br>  Lassen Sie uns durch die Augen des Entwicklers sehen.  Er muss nur sagen, dass Kubernetes sich bewerben und den neuen Dienst benennen.  Wir machen das, unser Controller hat alles aufgenommen und erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd6/ca6/3d7/bd6ca63d77dfbadee1587b6f44a680bd.png"></div><br>  Anschließend sammeln wir all dies in einem Bereitstellungsdienst und werfen diesen benutzerdefinierten Controller mithilfe der Kubernetes-Standardtools in den Cluster.  Wir haben eine Abstraktion für 200 Codezeilen erstellt. <br><br>  Es sieht alles nach HELM aus, ist aber tatsächlich mächtiger.  Der Controller arbeitet in einem Cluster: Er sieht die Basis, sieht die Außenwelt und kann intelligent genug gemacht werden. <br><br><h2>  Eigenes CI </h2><br>  Betrachten Sie die Kubernetes-Erweiterungsbeispiele.  Wir haben beschlossen, dass CI Teil der Infrastruktur sein sollte.  Dies ist gut, es ist aus Sicherheitsgründen praktisch - ein privates Repository.  Wir haben versucht, Jenkins zu verwenden, aber es ist ein veraltetes Tool.  Ich wollte einen Hacker CI.  Wir brauchen keine Schnittstellen, wir lieben ChatOps: Lassen Sie es einfach im Chat sagen, ob der Build gefallen ist oder nicht.  Außerdem wollte ich alles lokal debuggen. <br><img src="https://habrastorage.org/getpro/habr/post_images/9a4/ecf/86e/9a4ecf86e022a465ce11072352456728.png"><br>  Wir setzten uns und schrieben unser CI in einer Woche.  Nur als Erweiterung zu Kubernetes.  Wenn Sie an CI denken, ist dies nur ein Tool, mit dem Jobs ausgeführt werden.  Im Rahmen dieses Jobs erstellen wir etwas, führen Tests durch und stellen häufig bereit. <br><br>  Wie funktioniert das alles?  Es basiert auf dem gleichen Konzept von benutzerdefinierten Controllern.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zunächst wird in Kubernetes beschrieben, welchen Repositorys wir folgen. Der Controller geht einfach zu Github und fügt Web-Hook hinzu. Wir haben immer noch Selbstbeobachtung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als nächstes kommt der Web-Hook, dessen einzige Aufgabe darin besteht, den eingehenden JSON zu verarbeiten und in einer benutzerdefinierten Build-Ressource abzulegen, die sich auch zur Kubernetes-Datenbank summiert. Die Build-Ressource wird vom Build-Controller überwacht, der das Manifest im Projekt liest und den POD startet. In diesem POD werden alle erforderlichen Dienste gestartet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In POD ein sehr einfacher Agent, der eine Deklaration im Stil von Travis oder Circleci liest, und in YAML eine Reihe von Schritten. Er beginnt sie zu erfüllen. Am Ende des Builds wirft er sein Ergebnis in Telegramm.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine weitere Funktion, die wir mit Kubernetes erhalten haben, ist, dass einer der Befehle zum Ausführen Ihres CI oder der kontinuierlichen Zustellung einfach während des True Sleep 10 festgelegt werden kann und Ihr POD bei diesem Schritt einfriert. </font><font style="vertical-align: inherit;">Du machst kubectl exec, findest dich in deinem Build wieder und kannst debütieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine weitere Funktion - alles basiert auf Dockern und Sie können das Skript lokal debuggen, indem Sie das Docker starten. </font><font style="vertical-align: inherit;">Es dauerte zwei Wochen und 300 Codezeilen.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/72f/334/ec3/72f334ec33db75d3b32e4c464a24dc03.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbeite mit Postgres </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser Produkt basiert auf Postgres, wir verwenden alle möglichen interessanten Funktionen. Wir haben sogar eine Reihe von Erweiterungen geschrieben. Wir können jedoch kein RDS oder etwas anderes verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind gerade dabei, einen Operator für ein unzerstörbares Postgres zu entwickeln. Ich werde Architektur klingen. Ich möchte sagen: "Cluster, gib mir ein Postgres, das nicht getötet werden kann." Hinzu kommt, dass ich zwei asynchrone Replikate benötige, eines synchron, tägliche Backups und bis zu einem Terabyte. Ich werfe alles, dann beginnt mein Cluster-Controller mit der Orchestrierung und Erweiterung meines Containers. Es werden Pginstance-Ressourcen erstellt, die für jedes Istance-Postgres verantwortlich sind. Dies werden Cluster-Postgres sein.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer Pginstance-Controller, ganz einfach, versucht nur, POD auszuführen oder dort mit diesem Postgres bereitzustellen. Das Herz ist anhaltendes Volumen. Diese ganze Maschine übernimmt die volle Kontrolle über Postgres. Sie geben ihr einen Docker-Container, der nur binäre Postgres enthält. Alles andere: Der Controller selbst übernimmt die Konfiguration und Erstellung des Postgres-Startclusters. Er tut dies, damit wir später neu konfigurieren können und damit er Replikation, Protokollstufen usw. konfigurieren kann. Zu Beginn läuft der temporäre POD über das persistente Volume und erstellt dort einen Postgres-Cluster für den Master. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Darüber hinaus beginnt die Bereitstellung mit dem Master. Dann wird auf die gleiche Weise ein dauerhaftes Volume erstellt. Ein anderer POD fährt durch, erstellt eine grundlegende Sicherung, zieht sie ab und darüber hinaus beginnt die Bereitstellung mit einem Slave.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Nächstes erstellt der Cluster-Controller eine Sicherungsressource (nachdem dies mit Sicherungen beschrieben wurde). Und der Backup-Controller nimmt es bereits und wirft es in einen S3.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/972/b42/457/972b42457c664d988fd8eeee0aaa603c.png"><br><br><h2>  Was weiter? </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns mit Ihnen die nahe Zukunft vorstellen. Es kann vorkommen, dass wir früher oder später über so interessante benutzerdefinierte Ressourcen und benutzerdefinierte Controller verfügen, dass ich sagen werde: "Gib mir Postgres, gib mir Kafka, lass mich CI und starte alles." Alles wird einfach sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir nicht über die nahe Zukunft sprechen, dann denke ich als deklarativer Programmierer, dass nur logische oder relationale Programmierung höher ist als funktionale Programmierung. Dort ist unsere Operationssemantik völlig unabhängig von der Informationssemantik. Wenn wir uns unsere benutzerdefinierten Controller genau ansehen, haben wir beispielsweise eine Ressourcenanwendung in unserer Datenbank. Und wir leiten daraus drei weitere zusätzliche Ressourcen ab. Dies ist der Datenbankansicht sehr ähnlich. Dies ist eine Tatsachenfeststellung. Dies ist eine logische oder Beziehungsansicht.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der nächste Schritt für Kubernetes besteht darin, eine gewisse Illusion einer relationalen oder logischen Basis anstelle einer gehackten REST-API zu vermitteln, in der Sie einfach eine Regel schreiben können. Da früher oder später alles in die Datenbank fließt, einschließlich Feedback, können die Regeln folgendermaßen klingen: "Wenn die Last auf diese Weise gestiegen ist, erhöhen Sie die Replikation auf diese Weise." Wir werden eine kleine SQL- oder logische Regel haben. Alles was Sie brauchen ist eine generische Engine, die diesem folgt. Aber das ist eine glänzende Zukunft.</font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/fb4/f1e/930/fb4f1e930029011d081eeb911203d289.png"><br><br><blockquote>    —   <b>DevOops 2018</b> !     —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">«The DevOps Handbook»</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">«Learning Chef: A Guide to Configuration Management and Automation»</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">«How to containerize your Go code»</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">«Liquid Software: How to Achieve Trusted Continuous Updates in the DevOps World»</a> —      .         -    . <br><br>  :       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ! <br><br>    : <b> 1 </b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> können ein </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Ticket</font></a><font style="vertical-align: inherit;"> für DevOops 2018 mit einem Rabatt buchen.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424609/">https://habr.com/ru/post/de424609/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424599/index.html">Sie müssen auswählen, welche Software Sie benötigen: pünktlich geschrieben oder von hoher Qualität</a></li>
<li><a href="../de424601/index.html">Informationsarchitektur im Internet Teil 1</a></li>
<li><a href="../de424603/index.html">Das Buch „Warum liegen wir falsch? Denkfallen in Aktion. “ Auszüge Teil 1</a></li>
<li><a href="../de424605/index.html">Zuckerberg-Fonds: Zusammenarbeit + Technologie + Open Science</a></li>
<li><a href="../de424607/index.html">Helidons Aufstieg</a></li>
<li><a href="../de424611/index.html">So erstellen Sie einen Mitarbeiter aus einem Freiberufler</a></li>
<li><a href="../de424613/index.html">Erfahrung mit Redux ohne Reduzierstücke</a></li>
<li><a href="../de424615/index.html">Kurvenfunktionsausgabe zur reibungslosen Begrenzung von Parametern, Signalen und nicht nur in Wolfram Mathematica</a></li>
<li><a href="../de424621/index.html">Nicht-Film-Superhelden. Wer und wie schützt die Baustelle des Lakhta Centers vor Bränden?</a></li>
<li><a href="../de424623/index.html">Lassen Sie uns den Sound auf Go verarbeiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>