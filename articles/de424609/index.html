<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òòÔ∏è üôéüèº ‚úåüèø So erweitern Sie Kubernetes üë¶ üö¢ üë©üèΩ‚Äçü§ù‚Äçüë®üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute werden wir √ºber DevOps oder vielmehr haupts√§chlich √ºber Ops sprechen. Sie sagen, dass es nur sehr wenige Menschen gibt, die mit dem Automatisier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So erweitern Sie Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/424609/">  Heute werden wir √ºber DevOps oder vielmehr haupts√§chlich √ºber Ops sprechen.  Sie sagen, dass es nur sehr wenige Menschen gibt, die mit dem Automatisierungsgrad ihrer Abl√§ufe zufrieden sind.  Aber die Situation scheint reparabel zu sein.  In diesem Artikel wird Nikolai Ryzhikov √ºber seine Erfahrungen mit der Erweiterung von Kubernetes sprechen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1a/4f7/1a2/b1a4f71a2809a5b098e738ed4e0b5d3f.png"><br><br>  Das Material wurde auf der Grundlage von Nikolais Rede auf der Herbstkonferenz DevOops 2017 vorbereitet. Unter dem Schnitt - Video- und Textprotokoll des Berichts. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3BMTNx2xCtQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  <i>Derzeit arbeitet Nikolai Ryzhikov im Gesundheits-IT-Bereich an der Schaffung medizinischer Informationssysteme.</i>  <i>Mitglied der St. Petersburger Community der funktionalen Programmierer FPROG.</i>  <i>Aktives Mitglied der Online Clojure-Community, Mitglied des HL7 FHIR-Standards f√ºr den Austausch medizinischer Informationen.</i>  <i>Programmiert seit 15 Jahren.</i> <br><hr><br>  Welche Seite haben wir f√ºr DevOps?  Seit 10 Jahren ist unsere DevOps-Formel recht einfach: Entwickler sind f√ºr den Betrieb verantwortlich, Entwickler werden bereitgestellt, Entwickler werden gewartet.  Mit diesem Arrangement, das etwas hart aussieht, werden Sie auf jeden Fall zu DevOps.  Wenn Sie DevOps schnell und schmerzhaft implementieren m√∂chten, machen Sie die Entwickler f√ºr Ihre Produktion verantwortlich.  Wenn die Jungs klug sind, werden sie anfangen, rauszukommen und alles zu verstehen. <br><img src="https://habrastorage.org/getpro/habr/post_images/8f4/799/e0d/8f4799e0d6f25b897b6bd72f2ba1081a.png"><br>  Unsere Geschichte: Vor langer Zeit, als es keinen Chef und keine Automatisierung gab, haben wir bereits das automatische Capistrano eingesetzt.  Dann fingen sie an, ihn zu langweilen, damit er Mode machen w√ºrde.  Aber dann erschien Chef.  Wir wechselten dorthin und gingen in die Cloud: Wir hatten unsere Rechenzentren satt.  Dann erschien Ansible, Docker stand auf.  Danach zogen wir mit dem handgeschriebenen Condo Docker Supervisor auf Camel nach Terraform.  Und jetzt ziehen wir nach Kubernetes. <br><img src="https://habrastorage.org/getpro/habr/post_images/366/af1/be8/366af1be8b4c4cf204553b48c8a76e70.png"><br>  Was ist das Schlimmste an Operationen?  Nur sehr wenige Menschen sind mit dem Automatisierungsgrad ihrer Abl√§ufe zufrieden.  Ich best√§tige, dass dies be√§ngstigend ist: Wir haben viele Ressourcen und Anstrengungen aufgewendet, um all diese Stapel f√ºr uns selbst zu sammeln, und das Ergebnis ist unbefriedigend. <br><br>  Es besteht das Gef√ºhl, dass sich mit dem Aufkommen von Kubernetes etwas √§ndern kann.  Ich bin der schlanken Fertigung verpflichtet und aus seiner Sicht sind Operationen im Allgemeinen nicht n√ºtzlich.  Ideale Operationen sind das Fehlen oder Minimum von Operationen in einem Projekt.  Wert entsteht, wenn ein Entwickler ein Produkt herstellt.  Wenn es fertig ist, bringt die Lieferung keinen Mehrwert.  Aber Sie m√ºssen die Kosten senken. <br><img src="https://habrastorage.org/getpro/habr/post_images/731/1a4/6e3/7311a46e3eb4d1d73d788f6ee881be3a.png"><br>  F√ºr mich war das Ideal immer Heroku.  Wir haben es f√ºr einfache Anwendungen verwendet, bei denen der Entwickler seinen Dienst bereitstellte. Es gen√ºgte, git push zu sagen und heroku zu konfigurieren.  Es dauert eine Minute. <br><img src="https://habrastorage.org/getpro/habr/post_images/a57/4c0/12b/a574c012ba1158086cd3578287d6d2a9.png"><br>  Wie man ist  Sie k√∂nnen NoOps kaufen - auch Heroku.  Und ich rate Ihnen zu kaufen, sonst besteht die M√∂glichkeit, mehr Geld f√ºr die Entwicklung des normalen Betriebs auszugeben. <br><br>  Es gibt Deis-Leute, die versuchen, so etwas wie Heroku auf Kubernetes zu machen.  Es gibt eine Cloud-Gie√üerei, die auch eine Plattform bietet, auf der gearbeitet werden kann. <br><img src="https://habrastorage.org/getpro/habr/post_images/bbd/7b9/7e0/bbd7b97e07aae6af9a54663d633e3cc2.png"><br>  Aber wenn Sie sich mit etwas Komplexerem oder Gro√üem besch√§ftigen, k√∂nnen Sie es selbst tun.  Zusammen mit Docker und Kubernetes wird dies nun zu einer Aufgabe, die in angemessener Zeit und zu angemessenen Kosten erledigt werden kann.  Fr√ºher war es zu hart. <br><img src="https://habrastorage.org/getpro/habr/post_images/299/2d2/90a/2992d290a7167b9fe4a8cf2320528b8e.png"><br><h2>  Ein bisschen √ºber Docker und Kubernetes </h2><br>  Eines der Probleme bei Operationen ist die Wiederholbarkeit.  Das Tolle, was der Docker gebracht hat, sind zwei Phasen.  Wir haben eine Bauphase. <br><br>  Der zweite Punkt, der dem Docker gef√§llt, ist eine universelle Schnittstelle zum Starten beliebiger Dienste.  Jemand hat Docker zusammengebaut, etwas hineingesteckt und Operationen ausgef√ºhrt. Es reicht aus, zu sagen, dass Docker ausgef√ºhrt und gestartet wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b4/ca2/5ad/0b4ca25ade4ae7d3513539aaa576d3e7.png"><br><br>  Was ist Kubernetes?  Also haben wir Docker erstellt und m√ºssen es irgendwo starten, integrieren, konfigurieren und mit anderen verbinden.  Mit Kubernetes k√∂nnen Sie dies tun.  Er f√ºhrt eine Reihe von Abstraktionen ein, die als "Ressource" bezeichnet werden.  Wir werden sie schnell durchgehen und sogar versuchen zu schaffen. <br><br><h2>  Abstraktion </h2><br>  Die erste Abstraktion ist ein POD oder eine Reihe von Containern.  Richtig gemacht, was genau ist ein <b>Satz von</b> Containern und nicht einer.  Sets k√∂nnen untereinander Volumes durchsuchen, die sich √ºber localhost sehen.  Auf diese Weise k√∂nnen Sie ein Muster wie einen Beiwagen verwenden (dies ist der Zeitpunkt, an dem wir den Hauptcontainer starten, und es befinden sich Hilfscontainer in der N√§he, die ihm helfen). <br><br>  Zum Beispiel der Botschafteransatz.  In diesem Fall soll der Container nicht dar√ºber nachdenken, wo sich einige Dienste befinden.  Sie stellen einen Container daneben, der wei√ü, wo sich diese Dienste befinden.  Und sie werden f√ºr den Hauptcontainer auf localhost verf√ºgbar.  Daher sieht die Umgebung so aus, als w√ºrden Sie lokal arbeiten. <br><img src="https://habrastorage.org/getpro/habr/post_images/0b8/ab5/bda/0b8ab5bdae5f0d0e7375ff1b08efc6ee.png"><br>  Lassen Sie uns den POD erh√∂hen und sehen, wie er beschrieben wird.  Vor Ort kann man Minikube entwickeln.  Es verbraucht eine Menge CPUs, aber Sie k√∂nnen einen kleinen Kubernetes-Cluster auf einer Virtualbox erstellen und damit arbeiten. <br><br>  Lassen Sie uns POD bereitstellen.  Ich sagte, Kubernetes bewerben sich und √ºberfluteten den POD.  Ich kann sehen, welche PODs ich habe: Ich sehe, dass ein POD bereitgestellt wird.  Dies bedeutet, dass Kubernetes diese Container gestartet hat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/970/862/d90/970862d90a9afea1066caa69c1af63c8.png"></div><br>  Ich kann sogar in diesen Container gehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/603/8f7/1226038f78d2c9593826e7f26d611853.png"></div><br>  Aus dieser Perspektive ist Kubernetes f√ºr Menschen gemacht.  In der Tat kann das, was wir st√§ndig im Betrieb tun, beispielsweise bei der Kubernetes-Bindung, beispielsweise mit dem Dienstprogramm kubectl, problemlos durchgef√ºhrt werden. <br><br>  Aber POD ist sterblich.  Es beginnt als Docker-Lauf: Wenn jemand es stoppt, wird es niemand anheben.  Zus√§tzlich zu dieser Abstraktion beginnt Kubernetes, Folgendes zu erstellen - beispielsweise ein Replikatset.  Dies ist ein solcher Supervisor, der die PODs √ºberwacht, ihre Anzahl √ºberwacht und wenn die PODs fallen, werden sie angehoben.  Dies ist ein wichtiges Selbstheilungskonzept in Kubernetes, mit dem Sie nachts ruhig schlafen k√∂nnen. <br><br>  √úber dem Replikatsatz befindet sich eine Abstraktion der Bereitstellung - auch eine Ressource, mit der Sie eine zeitlose Bereitstellung durchf√ºhren k√∂nnen.  Beispielsweise funktioniert ein Replikatsatz.  Wenn wir die Version des Containers, z. B. unsere, innerhalb der Bereitstellung bereitstellen und √§ndern, steigt ein weiteres Replikatset an.  Wir warten, bis diese Container gestartet sind, durchlaufen ihre Integrit√§tspr√ºfungen und wechseln dann schnell zum neuen Replikatsatz.  Auch klassische und gute Praxis. <br><img src="https://habrastorage.org/getpro/habr/post_images/02e/d07/f33/02ed07f333733af0155ee539be18c669.png"><br>  Lassen Sie uns einen einfachen Service abholen.  Zum Beispiel haben wir eine Bereitstellung.  Im Inneren beschreibt er das Muster der PODs, die er aufnehmen wird.  Wir k√∂nnen diese Bereitstellung anwenden und sehen, was wir haben.  Coole Funktion von Kubernetes - alles liegt in der Datenbank und wir k√∂nnen beobachten, was im System passiert. <br><br>  Hier sehen wir eine Bereitstellung.  Wenn wir versuchen, die PODs zu betrachten, sehen wir, dass einige PODs gestiegen sind.  Wir k√∂nnen diesen POD nehmen und entfernen.  Was passiert mit PODs?  Einer wird zerst√∂rt und der zweite steigt sofort auf.  Dieser Replikatset-Controller hat den gew√ºnschten POD nicht gefunden und einen anderen gestartet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/524/7f4/0d4/5247f40d4fb21eb93bda0ce14124245e.png"></div><br>  Wenn es sich um eine Art Webdienst handelt oder innerhalb unserer Dienste kommunizieren muss, ben√∂tigen wir eine Serviceerkennung.  Sie m√ºssen dem Dienst einen Namen und einen Einstiegspunkt geben.  Kubernetes bietet hierf√ºr eine Ressource namens Service an.  Er kann den Lastausgleich √ºbernehmen und f√ºr die Serviceerkennung verantwortlich sein. <br><img src="https://habrastorage.org/getpro/habr/post_images/2fa/926/6e5/2fa9266e57c6718a81241ae1ac15da8e.png"><br>  Sehen wir uns einen einfachen Service an.  Wir verbinden es mit Deployment und PODs √ºber Labels: eine solche dynamische Verbindung.  Ein sehr wichtiges Konzept in Kubernetes: Das System ist dynamisch.  Es spielt keine Rolle, in welcher Reihenfolge all dies erstellt wird.  Der Service wird versuchen, PODs mit solchen Etiketten zu finden und deren Lastausgleich zu starten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b48/992/f7d/b48992f7dca832fce9b45276936a4914.png"></div><br>  Service anwenden, schauen Sie, welche Services wir haben.  Wir gehen in unseren Test-POD, der ausgel√∂st wurde, und machen nslookup.  Kubernetes gibt uns ein DNS-ku, √ºber das Dienste sich gegenseitig sehen und entdecken k√∂nnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b05/66f/01e/b0566f01e54210ea26c5b6526b0ed0de.png"></div><br>  Service ist eher eine Schnittstelle.  Es gibt verschiedene Implementierungen, da die Aufgaben des Lastausgleichs und des Dienstes ziemlich kompliziert sind: Auf die eine Weise arbeiten wir mit normalen Datenbanken, auf der anderen mit geladenen und einige einfache sind recht einfach.  Dies ist auch ein wichtiges Konzept in Kubernetes: Einige Dinge k√∂nnen eher als Schnittstellen als als Implementierungen bezeichnet werden.  Sie sind nicht starr festgelegt, und unterschiedliche Cloud-Anbieter bieten beispielsweise unterschiedliche Implementierungen an.  Das hei√üt, es gibt beispielsweise ein ressourcenbest√§ndiges Volume, das bereits regelm√§√üig in jeder einzelnen Cloud implementiert ist. <br><br>  Als n√§chstes m√∂chten wir normalerweise den Webdienst herausbringen.  Kubernetes hat eine Ingress-Abstraktion.  Normalerweise wird dort SSL hinzugef√ºgt. <br><img src="https://habrastorage.org/getpro/habr/post_images/fc7/69e/4e7/fc769e4e7a526588c3f3ae32388d9c11.png"><br>  Der einfachste Eingang sieht ungef√§hr so ‚Äã‚Äãaus.  Dort schreiben wir die Regeln: F√ºr welche URLs, f√ºr welche Hosts, f√ºr welchen internen Service soll die Anfrage umgeleitet werden.  Auf die gleiche Weise k√∂nnen wir unseren Eintritt erh√∂hen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69d/79c/046/69d79c046478f1fde2a073f2fe37067f.png"></div><br>  Nachdem Sie sich lokal bei den Hosts registriert haben, k√∂nnen Sie diesen Service von hier aus sehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73d/752/75c/73d75275c26a468f49cd192e781595db.png"></div><br>  Dies ist eine so regelm√§√üige Aufgabe: Wir haben einen bestimmten Webdienst bereitgestellt und uns ein wenig mit Kubernetes getroffen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a3/1f8/c2f/1a31f8c2f639a4758d95719ee6dca1e0.png"></div><br>  Wir werden alles bereinigen, das Eindringen entfernen und alle Ressourcen untersuchen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c75/990/40c/c7599040cd85c2c155e8acf057be0246.png"></div><br>  Es gibt eine Reihe von Ressourcen, wie z. B. configmap und secret.  Hierbei handelt es sich um reine Informationsressourcen, die Sie in einen Container einbinden und dort beispielsweise das Passwort von postgres √ºbertragen k√∂nnen.  Sie k√∂nnen dies Umgebungsvariablen zuordnen, die beim Start in den Container eingef√ºgt werden.  Sie k√∂nnen das Dateisystem mounten.  Alles ist ganz bequem: Standardaufgaben, sch√∂ne L√∂sungen. <br><br>  Es gibt ein dauerhaftes Volumen - eine Schnittstelle, die von verschiedenen Cloud-Anbietern unterschiedlich implementiert wird.  Es ist in zwei Teile unterteilt: Es gibt einen dauerhaften Volumenanspruch (Anforderung), und dann wird ein EBS erstellt, das sich in den Container zieht.  Sie k√∂nnen mit Stateful Service arbeiten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd6/5c1/2f7/cd65c12f71d417ffd11e3e62c76b484c.png"><br><br>  Aber wie funktioniert es innen?  Das Konzept selbst ist sehr einfach und transparent.  Kubernetes besteht aus zwei Teilen.  Eine ist nur eine Datenbank, in der wir alle diese Ressourcen haben.  Ressourcen k√∂nnen als Tablets betrachtet werden: Insbesondere handelt es sich bei diesen Instanzen lediglich um Aufzeichnungen in Tablets.  Zus√§tzlich zu Kubernetes ist ein API-Server konfiguriert.  Das hei√üt, wenn Sie einen Kubernetes-Cluster haben, kommunizieren Sie normalerweise mit dem API-Server (genauer gesagt, der Client kommuniziert mit ihm). <br><br>  Dementsprechend wird das, was wir erstellt haben (PODs, Dienste usw.), einfach in die Datenbank geschrieben.  Diese Datenbank wird durch ETCD implementiert, d.h.  so dass es auf dem hochverf√ºgbaren Niveau stabil ist. <br><br>  Was kommt als n√§chstes?  Weiter gibt es unter jeder Art von Ressourcen einen bestimmten Controller.  Dies ist nur ein Dienst, der seine Art von Ressource √ºberwacht und etwas in der Au√üenwelt tut.  Wird beispielsweise ein Docker ausgef√ºhrt?  Wenn wir PODs haben, gibt es f√ºr jeden Knoten einen Kubelet-Dienst, der die PODs √ºberwacht, die an diesen Knoten angeschlossen sind.  Und alles, was er tut, ist, dass Docker nach der n√§chsten regelm√§√üigen √úberpr√ºfung ausgef√ºhrt wird, ob dieser POD nicht vorhanden ist. <br><br>  Was sehr wichtig ist - alles geschieht in Echtzeit, sodass die Leistung dieses Controllers h√∂her als das Minimum ist.  Oft nimmt der Controller immer noch die Metriken und schaut sich an, was er gestartet hat.  Das hei√üt,  Entfernt das Feedback aus der realen Welt und schreibt es in die Datenbank, damit Sie oder andere Controller es sehen k√∂nnen.  Beispielsweise wird derselbe POD-Status in ETCD zur√ºckgeschrieben. <br><br>  Somit ist alles in Kubernetes implementiert.  Es ist sehr cool, dass das Informationsmodell vom Operationssaal getrennt ist.  In der Datenbank deklarieren wir √ºber die √ºbliche CRUD-Schnittstelle, was sein soll.  Dann versucht der Satz von Controllern, alles richtig zu machen.  Das passiert zwar nicht immer. <br><br>  Dies ist ein kybernetisches Modell.  Wir haben eine bestimmte Voreinstellung, es gibt eine Art Maschine, die versucht, die reale Welt oder Maschine an den Ort zu lenken, der ben√∂tigt wird.  Es stellt sich nicht immer so heraus: Wir sollten eine R√ºckkopplungsschleife haben.  Manchmal kann eine Maschine dies nicht und muss sich an eine Person wenden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/59e/0a9/1e8/59e0a91e8974351a5f0f49fd94709c9a.png"><br><br>  In realen Systemen denken wir in Abstraktionen der n√§chsten Ebene: Wir haben einige Dienste, Datenbanken und wir verbinden sie alle.  Wir denken nicht an PODs und Ingresss und m√∂chten eine n√§chste Abstraktionsebene aufbauen. <br><img src="https://habrastorage.org/getpro/habr/post_images/77f/5cb/697/77f5cb6974c6ac85e0b5e8b13921d672.png"><br>  Damit der Entwickler so einfach wie m√∂glich war: Er sagte einfach: ‚ÄûIch m√∂chte so und so einen Service starten‚Äú, und alles andere passierte im Inneren. <br><br>  Es gibt so etwas wie HELM.  Dies ist der falsche Weg - ansible Style Templating, bei dem wir nur versuchen, eine Reihe konfigurierter Ressourcen zu erzeugen und sie in einem Kubernetes-Cluster abzulegen. <br><br>  Das Problem ist zum einen, dass dies nur zum Zeitpunkt des Walzens erfolgt.  Das hei√üt, er kann nicht viel Logik implementieren.  Zweitens verschwindet diese Abstraktion zur Laufzeit.  Wenn ich mir meinen Cluster anschaue, sehe ich nur PODs und Dienste.  Ich sehe nicht, dass so und so ein Dienst bereitgestellt wird, dass dort so und so eine Basis mit Replikation eingerichtet wird.  Ich sehe dort nur Dutzende von Herden.  Die Abstraktion verschwindet wie in einer Matrix. <br><img src="https://habrastorage.org/getpro/habr/post_images/696/6e6/9bd/6966e69bd8b289229194911f62a11f84.png"><br><h2>  Internes L√∂sungsmodell </h2><br>  Auf der anderen Seite bietet Kubernetes selbst bereits ein sehr interessantes und einfaches Erweiterungsmodell im Inneren.  Wir k√∂nnen neue Arten von Ressourcen deklarieren, zum Beispiel die Bereitstellung.  Dies ist eine Ressource, die auf PODs oder Replikaten basiert.  Wir k√∂nnen einen Controller in diese Ressource schreiben, diese Ressource in die Datenbank einf√ºgen und unsere kybernetische Schleife ausf√ºhren, damit alles funktioniert.  Das klingt interessant und es scheint mir, dass dies der richtige Weg ist, um Kubernetes zu erweitern. <br><img src="https://habrastorage.org/getpro/habr/post_images/39e/491/c51/39e491c511ea25078eda191097d88b24.png"><br>  Ich m√∂chte in der Lage sein, nur ein Manifest f√ºr meinen Service im Heroku-Stil zu schreiben.  Ein sehr einfaches Beispiel: Ich m√∂chte eine Art Anwendung in meiner realen Umgebung bereitstellen.  Haben bereits Vereinbarungen, SSL, Domains gekauft.  Ich m√∂chte Entwicklern nur die einfachste Oberfl√§che bieten, die m√∂glich ist.  Das Manifest sagt mir, welchen Container ich heben soll, welche Ressourcen dieser Container noch ben√∂tigt.  Er wirft diese Ank√ºndigung in den Cluster und alles beginnt zu funktionieren. <br><img src="https://habrastorage.org/getpro/habr/post_images/a91/24e/8a8/a9124e8a8309c952cc0a65b32f28d76f.png"><br><br>  Wie wird dies in Bezug auf benutzerdefinierte Ressourcen und Controller aussehen?  Hier haben wir eine Ressourcenanwendung in der Datenbank.  Und der Anwendungscontroller erzeugt drei Ressourcen.  Das hei√üt, er schreibt eingehende Regeln f√ºr die Weiterleitung zu diesem Dienst auf, startet den Dienst f√ºr den Lastenausgleich und startet die Bereitstellung mit einer Konfiguration. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/807/938/d22/807938d229cb312ca761214fa30829ed.png"><br><br>  Bevor wir eine benutzerdefinierte Ressource in Kubernetes erstellen, m√ºssen wir sie deklarieren.  Daf√ºr gibt es eine Meta-Ressource namens CustomResourceDefinition. <br><br>  Um eine neue Ressource in Kubernetes zu deklarieren, reicht es aus, eine solche Ank√ºndigung zu ver√∂ffentlichen.  Betrachten Sie diese Erstellungs-Tabelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/253/7d3/09e2537d3520f688c7029a357d9773dd.png"></div><br>  Erstellt eine Tabelle.  Danach k√∂nnen wir durch den Kubectl-Zugriff auf die Ressourcen von Drittanbietern schauen, die wir haben.  Sobald wir es angek√ºndigt hatten, bekamen wir auch ein Banner.  Wir k√∂nnen zum Beispiel kubeclt Apps bekommen.  Aber bisher keine App. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5b/c40/9ad/d5bc409ad70866a12358ccb68ba497f8.png"></div><br>  Lass uns eine App schreiben.  Danach k√∂nnen wir eine benutzerdefinierte Ressourceninstanz erstellen.  Schauen wir es uns in YAML an und erstellen es per Post an eine bestimmte URL. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/044/e55/454/044e554549dc4dc00d262ecf49d8d72d.png"></div><br>  Wenn wir durch kubectl laufen und schauen, erscheint eine App.  Aber w√§hrend nichts passiert, liegt es nur in der Datenbank.  Sie k√∂nnen beispielsweise alle App-Ressourcen √ºbernehmen und anfordern. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/701/234/74d/70123474de1bf62ece27d49587098368.png"></div><br>  Wir k√∂nnen eine zweite solche Ressource aus derselben Vorlage erstellen, indem wir einfach den Namen √§ndern.  Hier ist die zweite Ressource. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/842/a58/4b0/842a584b09631555234babcbd3c7e57c.png"></div><br>  Dar√ºber hinaus sollte unser Controller Vorlagen erstellen, √§hnlich wie HELM.  Das hei√üt, nachdem ich eine Beschreibung unserer App erhalten habe, muss ich eine Ressourcenbereitstellung und einen Ressourcenservice generieren sowie einen Eintrag in Ingress vornehmen.  Dies ist der einfachste Teil: Hier in Clojure ist Erlmacro.  Ich √ºbergebe die Datenstruktur, sie ruft die Bereitstellungsfunktion auf, √ºbergibt sie an das Debugging, das die Pipeline ist.  Und das ist eine reine Funktion: einfaches Templating.  Dementsprechend k√∂nnte ich es in der naivsten Form sofort erstellen, in ein Konsolendienstprogramm verwandeln und mit der Verteilung beginnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b33/bf5/2cb/b33bf52cbd901d2c5e0a0641daed9161.png"></div><br>  Dasselbe tun wir f√ºr den Service: Die Servicefunktion akzeptiert die Deklaration und generiert die Kubernetes-Ressource f√ºr uns. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/daf/e7f/c2edafe7f36d7c0db4573054991c436a.png"></div><br>  Wir machen dasselbe f√ºr die eingehende Linie. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d0/22f/156/5d022f15612aa3dcc19f635b0dd9b403.png"></div><br>  Wie wird das alles funktionieren?  Es wird etwas in der realen Welt geben und es wird geben, was wir wollen.  Was wir wollen - wir nehmen die Anwendungsressource und generieren darauf, was sie sein soll.  Und jetzt m√ºssen wir sehen, was ist.  Was wir √ºber die REST-API anfordern.  Wir k√∂nnen alle Dienste, alle Bereitstellungen erhalten. <br><br>  Wie funktioniert unser benutzerdefinierter Controller?  Er wird erhalten, was wir wollen und was ist, von diesem Div nehmen und sich bei Kubernetes bewerben.  Dies √§hnelt React.  Ich habe mir ein virtuelles DOM ausgedacht, als einige Funktionen einfach einen Baum von JS-Objekten generieren.  Und dann berechnet ein bestimmter Algorithmus den Patch und wendet ihn auf das reale DOM an. <br><br>  Wir werden das gleiche hier tun.  Dies erfolgt in 50 Codezeilen.  Willst du - alles ist auf Github.  Am Ende sollten wir die Funktion zum Abgleichen von Aktionen erhalten. <br><br>  Wir haben eine Funktion zum Vers√∂hnen von Aktionen, die nichts tut und nur diese Div berechnet.  Sie nimmt, was ist und was gebraucht wird.  Und dann gibt es heraus, was getan werden muss, um das erste zum zweiten zu bringen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/460/49b/90d/46049b90d8fa93dfe9279c02828cfa1c.png"></div><br>  Lass uns an ihr ziehen.  Es ist nichts falsch mit ihr, sie kann entkr√§ftet werden.  Sie sagt, dass Sie einen Ingress-Service erstellen, zwei Eintr√§ge darin vornehmen, eine Bereitstellung 1 und 2 erstellen und einen Service 1 und 2 erstellen m√ºssen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c72/c0a/c10/c72c0ac10e4924fde59ed749339345aa.png"></div><br>  In diesem Fall sollte es bereits nur einen Dienst geben.  Wir sehen vom Eingang, dass nur ein Eintrag √ºbrig bleibt. <br><br>  Dann m√ºssen Sie nur noch eine Funktion schreiben, die diesen Patch auf den Kubernetes-Cluster anwendet.  Dazu √ºbergeben wir einfach Abstimmungsaktionen an die Abstimmungsfunktion, und alles wird angewendet.  Und jetzt sehen wir, dass der POD gestiegen ist, die Bereitstellung erfolgt ist und der Dienst gestartet wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/66b/144/1a5/66b1441a56d805344c7e734d3b9b2c80.png"></div><br>  F√ºgen wir einen weiteren Dienst hinzu: F√ºhren Sie die Funktion zum Abgleichen von Aktionen erneut aus.  Mal sehen, was passiert ist.  Alles begann, alles ist in Ordnung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32a/f9f/c1e/32af9fc1e444ed1c135e4bbe828a946f.png"></div><br>  Wie gehe ich damit um?  Wir packen das alles in einen Docker-Container.  Danach schreiben wir eine Funktion, die regelm√§√üig aufwacht, sich vers√∂hnt und einschl√§ft.  Geschwindigkeit ist nicht sehr wichtig, sie kann f√ºnf Sekunden lang schlafen und nicht so oft Vers√∂hnungsaktionen durchf√ºhren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bec/04e/8d1/bec04e8d1791843d80aed4f2b3f2a673.png"></div><br>  Unser benutzerdefinierter Controller ist nur ein Dienst, der den Patch aktiviert und regelm√§√üig berechnet. <br><br>  Jetzt haben wir zwei Dienste zaddeloino, lassen Sie uns eine der Anwendungen l√∂schen.  Mal sehen, wie unser Cluster reagiert hat: Alles ist in Ordnung.  Wir l√∂schen die zweite: Alles ist gel√∂scht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ff/a23/96e/5ffa2396ef22187604393a9ae657edd5.png"></div><br>  Lassen Sie uns durch die Augen des Entwicklers sehen.  Er muss nur sagen, dass Kubernetes sich bewerben und den neuen Dienst benennen.  Wir machen das, unser Controller hat alles aufgenommen und erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd6/ca6/3d7/bd6ca63d77dfbadee1587b6f44a680bd.png"></div><br>  Anschlie√üend sammeln wir all dies in einem Bereitstellungsdienst und werfen diesen benutzerdefinierten Controller mithilfe der Kubernetes-Standardtools in den Cluster.  Wir haben eine Abstraktion f√ºr 200 Codezeilen erstellt. <br><br>  Es sieht alles nach HELM aus, ist aber tats√§chlich m√§chtiger.  Der Controller arbeitet in einem Cluster: Er sieht die Basis, sieht die Au√üenwelt und kann intelligent genug gemacht werden. <br><br><h2>  Eigenes CI </h2><br>  Betrachten Sie die Kubernetes-Erweiterungsbeispiele.  Wir haben beschlossen, dass CI Teil der Infrastruktur sein sollte.  Dies ist gut, es ist aus Sicherheitsgr√ºnden praktisch - ein privates Repository.  Wir haben versucht, Jenkins zu verwenden, aber es ist ein veraltetes Tool.  Ich wollte einen Hacker CI.  Wir brauchen keine Schnittstellen, wir lieben ChatOps: Lassen Sie es einfach im Chat sagen, ob der Build gefallen ist oder nicht.  Au√üerdem wollte ich alles lokal debuggen. <br><img src="https://habrastorage.org/getpro/habr/post_images/9a4/ecf/86e/9a4ecf86e022a465ce11072352456728.png"><br>  Wir setzten uns und schrieben unser CI in einer Woche.  Nur als Erweiterung zu Kubernetes.  Wenn Sie an CI denken, ist dies nur ein Tool, mit dem Jobs ausgef√ºhrt werden.  Im Rahmen dieses Jobs erstellen wir etwas, f√ºhren Tests durch und stellen h√§ufig bereit. <br><br>  Wie funktioniert das alles?  Es basiert auf dem gleichen Konzept von benutzerdefinierten Controllern.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst wird in Kubernetes beschrieben, welchen Repositorys wir folgen. Der Controller geht einfach zu Github und f√ºgt Web-Hook hinzu. Wir haben immer noch Selbstbeobachtung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als n√§chstes kommt der Web-Hook, dessen einzige Aufgabe darin besteht, den eingehenden JSON zu verarbeiten und in einer benutzerdefinierten Build-Ressource abzulegen, die sich auch zur Kubernetes-Datenbank summiert. Die Build-Ressource wird vom Build-Controller √ºberwacht, der das Manifest im Projekt liest und den POD startet. In diesem POD werden alle erforderlichen Dienste gestartet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In POD ein sehr einfacher Agent, der eine Deklaration im Stil von Travis oder Circleci liest, und in YAML eine Reihe von Schritten. Er beginnt sie zu erf√ºllen. Am Ende des Builds wirft er sein Ergebnis in Telegramm.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine weitere Funktion, die wir mit Kubernetes erhalten haben, ist, dass einer der Befehle zum Ausf√ºhren Ihres CI oder der kontinuierlichen Zustellung einfach w√§hrend des True Sleep 10 festgelegt werden kann und Ihr POD bei diesem Schritt einfriert. </font><font style="vertical-align: inherit;">Du machst kubectl exec, findest dich in deinem Build wieder und kannst deb√ºtieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine weitere Funktion - alles basiert auf Dockern und Sie k√∂nnen das Skript lokal debuggen, indem Sie das Docker starten. </font><font style="vertical-align: inherit;">Es dauerte zwei Wochen und 300 Codezeilen.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/72f/334/ec3/72f334ec33db75d3b32e4c464a24dc03.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbeite mit Postgres </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser Produkt basiert auf Postgres, wir verwenden alle m√∂glichen interessanten Funktionen. Wir haben sogar eine Reihe von Erweiterungen geschrieben. Wir k√∂nnen jedoch kein RDS oder etwas anderes verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind gerade dabei, einen Operator f√ºr ein unzerst√∂rbares Postgres zu entwickeln. Ich werde Architektur klingen. Ich m√∂chte sagen: "Cluster, gib mir ein Postgres, das nicht get√∂tet werden kann." Hinzu kommt, dass ich zwei asynchrone Replikate ben√∂tige, eines synchron, t√§gliche Backups und bis zu einem Terabyte. Ich werfe alles, dann beginnt mein Cluster-Controller mit der Orchestrierung und Erweiterung meines Containers. Es werden Pginstance-Ressourcen erstellt, die f√ºr jedes Istance-Postgres verantwortlich sind. Dies werden Cluster-Postgres sein.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer Pginstance-Controller, ganz einfach, versucht nur, POD auszuf√ºhren oder dort mit diesem Postgres bereitzustellen. Das Herz ist anhaltendes Volumen. Diese ganze Maschine √ºbernimmt die volle Kontrolle √ºber Postgres. Sie geben ihr einen Docker-Container, der nur bin√§re Postgres enth√§lt. Alles andere: Der Controller selbst √ºbernimmt die Konfiguration und Erstellung des Postgres-Startclusters. Er tut dies, damit wir sp√§ter neu konfigurieren k√∂nnen und damit er Replikation, Protokollstufen usw. konfigurieren kann. Zu Beginn l√§uft der tempor√§re POD √ºber das persistente Volume und erstellt dort einen Postgres-Cluster f√ºr den Master. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dar√ºber hinaus beginnt die Bereitstellung mit dem Master. Dann wird auf die gleiche Weise ein dauerhaftes Volume erstellt. Ein anderer POD f√§hrt durch, erstellt eine grundlegende Sicherung, zieht sie ab und dar√ºber hinaus beginnt die Bereitstellung mit einem Slave.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als N√§chstes erstellt der Cluster-Controller eine Sicherungsressource (nachdem dies mit Sicherungen beschrieben wurde). Und der Backup-Controller nimmt es bereits und wirft es in einen S3.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/972/b42/457/972b42457c664d988fd8eeee0aaa603c.png"><br><br><h2>  Was weiter? </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns mit Ihnen die nahe Zukunft vorstellen. Es kann vorkommen, dass wir fr√ºher oder sp√§ter √ºber so interessante benutzerdefinierte Ressourcen und benutzerdefinierte Controller verf√ºgen, dass ich sagen werde: "Gib mir Postgres, gib mir Kafka, lass mich CI und starte alles." Alles wird einfach sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir nicht √ºber die nahe Zukunft sprechen, dann denke ich als deklarativer Programmierer, dass nur logische oder relationale Programmierung h√∂her ist als funktionale Programmierung. Dort ist unsere Operationssemantik v√∂llig unabh√§ngig von der Informationssemantik. Wenn wir uns unsere benutzerdefinierten Controller genau ansehen, haben wir beispielsweise eine Ressourcenanwendung in unserer Datenbank. Und wir leiten daraus drei weitere zus√§tzliche Ressourcen ab. Dies ist der Datenbankansicht sehr √§hnlich. Dies ist eine Tatsachenfeststellung. Dies ist eine logische oder Beziehungsansicht.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der n√§chste Schritt f√ºr Kubernetes besteht darin, eine gewisse Illusion einer relationalen oder logischen Basis anstelle einer gehackten REST-API zu vermitteln, in der Sie einfach eine Regel schreiben k√∂nnen. Da fr√ºher oder sp√§ter alles in die Datenbank flie√üt, einschlie√ülich Feedback, k√∂nnen die Regeln folgenderma√üen klingen: "Wenn die Last auf diese Weise gestiegen ist, erh√∂hen Sie die Replikation auf diese Weise." Wir werden eine kleine SQL- oder logische Regel haben. Alles was Sie brauchen ist eine generische Engine, die diesem folgt. Aber das ist eine gl√§nzende Zukunft.</font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/fb4/f1e/930/fb4f1e930029011d081eeb911203d289.png"><br><br><blockquote>    ‚Äî   <b>DevOops 2018</b> !     ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">¬´The DevOps Handbook¬ª</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">¬´Learning Chef: A Guide to Configuration Management and Automation¬ª</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">¬´How to containerize your Go code¬ª</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">¬´Liquid Software: How to Achieve Trusted Continuous Updates in the DevOps World¬ª</a> ‚Äî      .         -    . <br><br>  :       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ! <br><br>    : <b> 1 </b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k√∂nnen ein </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Ticket</font></a><font style="vertical-align: inherit;"> f√ºr DevOops 2018 mit einem Rabatt buchen.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424609/">https://habr.com/ru/post/de424609/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424599/index.html">Sie m√ºssen ausw√§hlen, welche Software Sie ben√∂tigen: p√ºnktlich geschrieben oder von hoher Qualit√§t</a></li>
<li><a href="../de424601/index.html">Informationsarchitektur im Internet Teil 1</a></li>
<li><a href="../de424603/index.html">Das Buch ‚ÄûWarum liegen wir falsch? Denkfallen in Aktion. ‚Äú Ausz√ºge Teil 1</a></li>
<li><a href="../de424605/index.html">Zuckerberg-Fonds: Zusammenarbeit + Technologie + Open Science</a></li>
<li><a href="../de424607/index.html">Helidons Aufstieg</a></li>
<li><a href="../de424611/index.html">So erstellen Sie einen Mitarbeiter aus einem Freiberufler</a></li>
<li><a href="../de424613/index.html">Erfahrung mit Redux ohne Reduzierst√ºcke</a></li>
<li><a href="../de424615/index.html">Kurvenfunktionsausgabe zur reibungslosen Begrenzung von Parametern, Signalen und nicht nur in Wolfram Mathematica</a></li>
<li><a href="../de424621/index.html">Nicht-Film-Superhelden. Wer und wie sch√ºtzt die Baustelle des Lakhta Centers vor Br√§nden?</a></li>
<li><a href="../de424623/index.html">Lassen Sie uns den Sound auf Go verarbeiten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>