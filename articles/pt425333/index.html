<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏪 🌬️ 😬 Inicie você mesmo, a primavera está chegando (Parte 2) 👩🏾‍⚖️ 🧘🏼 🤹🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Evgeny EvgenyBorisov Borisov (NAYA Technologies) e Kirill tolkkv Tolkachev (Cyan.Finance, Twitter ) continuam falando sobre o uso do Spring Boot para ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inicie você mesmo, a primavera está chegando (Parte 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/425333/"><p>  Evgeny <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">EvgenyBorisov</a> Borisov (NAYA Technologies) e Kirill <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">tolkkv</a> Tolkachev (Cyan.Finance, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Twitter</a> ) continuam falando sobre o uso do Spring Boot para resolver os problemas do imaginário Braavos Iron Bank.  Na segunda parte, focaremos nos perfis e sutilezas do lançamento do aplicativo. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c19/236/8c6/c192368c6d6e05d473201da0031d3ccc.png"><br><br></p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7Cq5zEm2wq0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  A primeira parte do artigo pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Até recentemente, o cliente veio e apenas exigiu o envio de um corvo.  Agora a situação mudou.  O inverno chegou, o muro caiu. </p><br><p> Em primeiro lugar, o princípio da emissão de empréstimos está mudando.  Se antes, com uma probabilidade de 50%, davam a todos, exceto Starks, agora agora pagavam apenas àqueles que pagam dívidas.  Portanto, estamos alterando as regras para emissão de empréstimos em nossa lógica de negócios.  Mas apenas para as agências do banco, localizadas onde o inverno já chegou, tudo permanece como antes.  Lembro que este é um serviço que decide se concede ou não um empréstimo.  Faremos apenas outro serviço que funcionará apenas no inverno. </p><br><p>  Vamos à nossa lógica de negócios: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WhiteListBasedProphetService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProphetService</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-meta"><span class="hljs-meta">@Override</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willSurvive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;  } }</code> </pre> <br><p>  Já temos uma lista daqueles que pagam dívidas. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">spring</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">application</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.name</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">money-raven</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jpa</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.hibernate</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ddl-auto</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">validate</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ironbank</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span><span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span><span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>:   <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>  : <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>: ,   : <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span></code> </pre> <br><p>  E há uma classe que já está associada à propriedade - <code></code> . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProphetProperties</span></span></span><span class="hljs-class"> </span></span>{ List&lt;String&gt; ; }</code> </pre> <br><p>  Como nos tempos anteriores, apenas injetamos aqui: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WhiteListBasedProphetService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProphetService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ProphetProperties prophetProperties; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willSurvive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br><p>  Lembre-se da injeção de construtor (sobre anotações mágicas): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WhiteListBasedProphetService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProphetService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ProphetProperties prophetProperties; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willSurvive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br><p>  Quase pronto. </p><br><p>  Agora devemos ceder apenas aos que pagam dívidas: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WhiteListBasedProphetService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProphetService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ProphetProperties prophetProperties; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willSurvive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prophetProperties.get().contains(name); } }</code> </pre> <br><p>  Mas aqui temos um pequeno problema.  Agora, temos duas implementações: os antigos e os novos serviços. </p><br><pre> <code class="java hljs">Description Parameter <span class="hljs-number"><span class="hljs-number">1</span></span> of constructor in com.ironbank.moneyraven.service.TransferMoneyProphecyBackend… - nameBasedProphetService: defined in file [/Users/tolkv/git/conferences/spring-boot-ripper… - WhileListBackendProphetService: defined in file [/Users/tolkv/git/conferences/spring-boot-ripper...</code> </pre> <br><p>  É lógico dividir esses beans em diferentes perfis.  Perfil de <code></code> e perfil de <code></code> .  Deixe nosso novo serviço ser executado apenas no perfil <code></code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-meta"><span class="hljs-meta">@Profile</span></span>(ProfileConstants.) <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WhiteListBasedProphetService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProphetService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ProphetProperties prophetProperties; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willSurvive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prophetProperties.get().contains(name); } }</code> </pre> <br><p>  E o serviço antigo é no <code></code> . </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-meta"><span class="hljs-meta">@Profile</span></span>(ProfileConstants.) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NameBasedProphetService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProphetService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willSurvive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !name.contains(<span class="hljs-string"><span class="hljs-string">"Stark"</span></span>) &amp;&amp; ThreadLocalRandom.current().nextBoolean(); } }</code> </pre> <br><p>  Mas o inverno chega devagar.  Nos reinos próximos ao muro quebrado, já é inverno.  Mas em algum lugar no sul - ainda não.  I.e.  Os aplicativos localizados em diferentes ramificações e fusos horários devem funcionar de maneira diferente.  De acordo com as condições de nossa tarefa, não podemos apagar a antiga implementação onde o inverno chegou e usar a nova classe.  Queremos que os funcionários do banco não façam absolutamente nada: entregaremos a eles um aplicativo que funcionará no modo verão até o inverno chegar.  E quando chega o inverno, eles simplesmente o reiniciam e é isso.  Eles não precisarão alterar o código, apagar nenhuma classe.  Portanto, inicialmente temos dois perfis: parte da lixeira é criada quando o verão e parte da lixeira é criada quando o inverno. </p><br><p>  Mas outro problema aparece: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fbd/7a6/882/fbd7a6882ff3180ccfc693ac3b41a852.png"><br></p><br><p>  Agora, não temos um único bean, porque especificamos dois perfis e o aplicativo inicia no perfil padrão. </p><br><p>  Portanto, temos uma nova exigência do cliente. </p><br><h2>  Lei de Ferro 2. Nenhum perfil é permitido </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/04a/0bb/57a/04a0bb57aa20425f959898ac3eecf8a5.png"><br></p><br><p>  Não queremos elevar o contexto se o perfil não estiver ativado, porque o inverno já chegou, tudo ficou muito ruim.  Há certas coisas que devem acontecer ou não, dependendo se o <code></code> ou se o <code></code> .  Além disso, observe a exceção, cujo texto é fornecido acima.  Ele não explica nada.  Um perfil não está definido, portanto, não há implementação do <code>ProphetService</code> .  Ao mesmo tempo, ninguém disse que é necessário definir um perfil. </p><br><p>  Portanto, agora queremos aparafusar uma peça adicional em nosso iniciador, que, ao criar o contexto, verificará se algum perfil está definido.  Se não estiver definido, não avançaremos e lançaremos apenas uma exceção (e não uma exceção sobre a falta de uma lixeira). </p><br><p>  Podemos fazer isso com nosso ouvinte de aplicativos?  Não.  E há três razões para isso: </p><br><ul><li>  O ouvinte de responsabilidade única é responsável por fazer o corvo voar.  O Ouvinte não deve verificar se um perfil foi ativado, porque a ativação de um perfil afeta não apenas o próprio ouvinte, mas também muito mais. </li><li>  Quando um contexto é construído, coisas diferentes acontecem.  E não queremos que eles comecem a acontecer se um perfil não tiver sido definido. </li><li>  O ouvinte funciona no final quando o contexto é resolvido.  E o fato de não haver perfil, sabemos muito antes.  Por que esperar esses cinco minutos condicionais até o serviço quase aumentar e tudo cair. </li></ul><br><p>  Além disso, ainda não sei quais erros aparecerão devido ao fato de começarmos a crescer sem um perfil (suponha que eu não conheça a lógica de negócios).  Portanto, na ausência de um perfil, você precisa trazer o contexto em um estágio muito inicial.  A propósito, se você usa qualquer Spring Cloud, isso se torna ainda mais relevante para você, porque o aplicativo faz muitas coisas desde o início. </p><br><p>  Para implementar o novo requisito, existe o <code>ApplicationContextInitializer</code> .  Essa é outra interface que nos permite estender algum ponto do Spring especificando-o em spring.factories. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/889/f21/a3b/889f21a3bee67ede3394d3c52b02e96d.png"><br></p><br><p>  Implementamos essa interface e temos um Context Initializer, que possui um <code>ConfigurableApplicationContext</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfileCheckAppInitializer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationContextInitializer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfigurableApplicationContext</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre> <br><p>  Com isso, podemos obter o ambiente - o que a SpringApplication preparou para nós.  Todas as propriedades que passamos para ele chegaram lá.  Entre outras coisas, eles também contêm perfis. </p><br><p>  Se não houver perfis lá, devemos lançar uma exceção dizendo que você não pode trabalhar assim. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfileCheckAppInitializer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationContextInitializer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfigurableApplicationContext</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> applicationContext.getEnvironment().getActiveProfiles().length == <span class="hljs-number"><span class="hljs-number">0</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"  !"</span></span>);   } } }</code> </pre> <br><p>  Agora você precisa registrar essas coisas em spring.factories. </p><br><pre> <code class="java hljs">org.springframework.boot.context.properties.EnableConfigurationProperties=com.ironbank.moneyraven.starter.IronConfiguration org.springframework.context.ApplicationContextInitializer=com.ironbank.moneyraven.starter.ProfileCheckAppInitializer</code> </pre> <br><p>  Pelo exposto, você pode adivinhar que <code>ApplicationContextInitializer</code> é um ponto de extensão.  <code>ApplicationContextInitializer</code> funciona quando o contexto está apenas começando a ser criado, ainda não há caixas. </p><br><p>  Surge a pergunta: se escrevemos <code>ApplicationContextInitializer</code> , por que não deveria, como ouvinte, ser escrito em uma configuração que se estende de qualquer maneira?  A resposta é simples: porque deve funcionar muito mais cedo quando não há contexto nem configurações.  I.e.  ainda não pode ser injetado.  Portanto, prescrevemos como uma peça separada. </p><br><p>  Uma tentativa de iniciar mostrou que tudo havia caído rápido o suficiente e relatou que estávamos começando sem um perfil.  Agora vamos tentar especificar algum perfil, e tudo funciona - o corvo é enviado. </p><br><p>  <code>ApplicationContextInitializer</code> - atende quando o contexto já foi criado, mas não há mais nada além do ambiente. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4ee/fb1/3e5/4eefb13e5b1e2f8f04c19e22f58062a8.png"><br></p><br><p>  Quem cria o ambiente?  Carlson - <code>SpringBootApplication</code> .  Ele a preenche com várias meta-informações, que podem ser retiradas do contexto.  A maioria das coisas pode ser injetada via <code>@value</code> , algo pode ser obtido no ambiente, pois acabamos de obter perfis. </p><br><p>  Por exemplo, propriedades diferentes vêm aqui: </p><br><ul><li>  qual Spring Boot pode construir; </li><li>  que na inicialização são transmitidos através da linha de comando; </li><li>  sistêmico; </li><li>  enunciado como variáveis ​​de ambiente; </li><li>  prescrito nas propriedades do aplicativo; </li><li>  registrado em alguns outros arquivos de propriedades. </li></ul><br><p>  Tudo isso é coletado e definido em um objeto de ambiente.  Ele também contém informações sobre quais perfis estão ativos.  O objeto de ambiente é a única coisa que existe no momento em que o Spring Boot começa a criar o contexto. </p><br><p>  Gostaria de adivinhar automaticamente qual será o perfil se as pessoas se esquecerem de perguntar com as mãos (fazemos tudo para que os funcionários do banco, que estão desamparados o suficiente sem programadores, possam iniciar o aplicativo para que tudo funcione para eles, independentemente do que seja).  Para fazer isso, adicionaremos ao nosso acionador de partida algo que adivinhe o perfil - <code></code> ou não - dependendo da temperatura na rua.  E outra nova interface mágica nos ajudará a tudo isso - <code>EnvironmentPostProcessor</code> , porque precisamos fazer isso antes que o <code>ApplicationContextInitializer</code> funcione.  E antes do <code>ApplicationContextInitializer</code> existe apenas o <code>EnvironmentPostProcessor</code> . </p><br><p>  Estamos novamente implementando uma nova interface.  Existe apenas um método, que da mesma maneira que <code>ConfigurableEnvironment</code> lança no <code>SpringApplication</code> , porque ainda não temos o <code>ConfigurableContext</code> (ele já existe no <code>SpringInitializer</code> não está aqui; existe apenas ambiente). </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResolveProfileEnvironmentPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EnvironmentPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessEnvironment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurableEnvironment environment, SpringApplication application)</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre> <br><p>  Nesse ambiente, podemos definir o perfil.  Mas primeiro você precisa verificar se ninguém o instalou antes.  Portanto, <code>getActiveProfiles</code> precisamos verificar <code>getActiveProfiles</code> .  Se as pessoas souberem o que estão fazendo e estabelecerem um perfil, não tentaremos adivinhar por elas.  Mas se não houver perfil, tentaremos entender pelo clima. </p><br><p>  E a segunda - precisamos entender se temos inverno ou verão agora.  Voltaremos a temperatura de <code>-300</code> . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResolveProfileEnvironmentPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EnvironmentPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessEnvironment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurableEnvironment environment, SpringApplication application)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (environment.getActivePrifiles().length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; getTemperature() &lt; -<span class="hljs-number"><span class="hljs-number">272</span></span>) {   } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTemperature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">300</span></span>; } }</code> </pre> <br><p>  Sob essa condição, temos o inverno e podemos estabelecer um novo perfil.  Lembramos que o perfil é chamado <code></code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResolveProfileEnvironmentPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EnvironmentPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessEnvironment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurableEnvironment environment, SpringApplication application)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (environment.getActivePrifiles().length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; getTemperature() &lt; -<span class="hljs-number"><span class="hljs-number">272</span></span>) { environment.setActiveProfiles(<span class="hljs-string"><span class="hljs-string">""</span></span>);   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { environment.setActiveProfiles(<span class="hljs-string"><span class="hljs-string">""</span></span>);   } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTemperature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">300</span></span>; } }</code> </pre> <br><p>  Agora precisamos especificar o <code>EnvironmentPostProcessor</code> em spring.factories. </p><br><pre> <code class="java hljs">org.springframework.boot.context.properties.EnableConfigurationProperties=com.ironbank.moneyraven.starter.IronConfiguration org.springframework.context.ApplicationContextInitializer=com.ironbank.moneyraven.starter.ProfileCheckAppInitializer org.springframework.boot.env.EnvironmentPostProcessor=com.ironbank.moneyraven.starter.ResolveProfileEnvironmentPostProcessor</code> </pre> <br><p>  Como resultado, o aplicativo inicia sem um perfil, dizemos que é produção e verificamos em qual perfil ele começou conosco.  Magicamente, percebemos que nosso perfil é <code></code> .  E o aplicativo não caiu, porque o <code>ApplicationContextInitializer</code> , que verifica se há um perfil, vem a seguir. <br>  O resultado: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResolveProfileEnvironmentPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EnvironmentPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessEnvironment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConfigurableEnvironment environment, SpringApplication application)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getTemperature() &lt; -<span class="hljs-number"><span class="hljs-number">272</span></span>) {     environment.setActiveProfiles(<span class="hljs-string"><span class="hljs-string">""</span></span>);   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {     environment.setActiveProfiles(<span class="hljs-string"><span class="hljs-string">""</span></span>);   } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTemperature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">300</span></span>; } }</code> </pre> <br><p>  Falamos sobre o <code>EnvironmentPostProcessor</code> , que é executado antes do <code>ApplicationContextInitializer</code> .  Mas quem dirige? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fd0/20e/e9e/fd020ee9edd65a1e41e62e0ebe689658.png"><br></p><br><p>  Essa aberração inicia, que, aparentemente, é o filho ilegítimo de <code>ApplicationListener</code> e <code>EnvironmentPostProcessor</code> , porque é herdado de <code>ApplicationListener</code> e <code>EnvironmentPostProcessor</code> .  É chamado <code>ConfigFileApplicationListener</code> (por que "ConfigFile" - ninguém sabe). </p><br><p>  Ele é o nosso Carlson, ou seja,  O Spring Application fornece um ambiente preparado para ouvir dois eventos: <code>ApplicationPreparedEvent</code> e <code>ApplicationEnvironmentPreparedEvent</code> .  Não analisaremos agora quem lança esses eventos.  Existe outra camada (na minha opinião, já é completamente supérflua, pelo menos nesta fase do desenvolvimento do Spring), que lança um evento que o ambiente está começando a ser construído (Application.yml, propriedades, variáveis ​​de ambiente são analisadas etc.) ) <br>  Após receber <code>ApplicationEnvironmentPreparedEvent</code> , o ouvinte entende que você precisa configurar o ambiente - encontre todo o <code>EnvironmentPostProcessor</code> e deixe-os funcionar. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cd3/8c4/3b8/cd38c43b8a10c9867cc9b3ebcb3ee1e9.png"><br></p><br><p>  Depois disso, ele diz ao <code>SpringFactoriesLoader</code> para entregar tudo o que você pediu, ou seja, todo o <code>EnvironmentPostProcessor</code> , para spring.factories.  Em seguida, coloca todo o <code>EnvironmentPostProcessor</code> em uma lista. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9b0/e39/f0f/9b0e39f0fe2514c22cfdc03af4b3f464.png"><br></p><br><p>  e entende que ele também é um <code>EnvironmentPostProcessor</code> (simultaneamente), portanto, ele se empurra para lá, <br><img src="https://habrastorage.org/getpro/habr/post_images/0f9/bf0/d30/0f9bf0d30e0065e707c813101aa173d9.png"><br>  ao mesmo tempo, classifica-os, acompanha-os e chama o <code>postProcessEnvironment</code> cada método. </p><br><p>  Dessa forma, todos os <code>postProcessEnvironment</code> são iniciados antes do <code>SpringApplicationInitializer</code> .  Nesse caso, um <code>EnvironmentPostProcessor</code> incompreensível chamado <code>ConfigFileApplicationListener</code> também é iniciado. </p><br><p>  Quando o ambiente é configurado, tudo volta para Carlson novamente. </p><br><p>  Se o ambiente estiver pronto, você poderá criar um contexto.  E Carlson começa a criar contexto com o <code>ApplicationInitializer</code> .  Aqui temos a nossa própria peça, que verifica se, no contexto, existe um ambiente em que existem perfis ativos.  Caso contrário, estamos caindo, porque, caso contrário, ainda teremos problemas mais tarde.  Então os iniciantes trabalham, com todas as configurações usuais já. </p><br><p>  A imagem acima reflete que o Spring também não está indo bem.  Esses alienígenas se reúnem periodicamente lá, a responsabilidade única não é respeitada e você precisa escalar com cuidado. </p><br><p>  Agora, queremos falar um pouco sobre o outro lado dessa criatura estranha, que é ouvinte de um lado e <code>EnvironmentPostProcessor</code> do outro. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ffc/200/bf0/ffc200bf085fd822e7fd1fdf6d9e8fec.png"><br></p><br><p>  Como o <code>EnvironmentPostProcessor</code> ele pode carregar application.yml, propriedades do aplicativo, todos os tipos de variáveis ​​de ambiente, argumentos de comando etc.  E como ouvinte, ele pode ouvir dois eventos: </p><br><ul><li> <code>ApplicationPreparedEvent</code> </li> <li> <code>ApplicationEnvironmentPreparedEvent</code> </li> </ul><br><p>  A questão é: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/452/851/6fc/4528516fcdf7fa9038e8ae80d2a8ac9a.png"><br></p><br><p>  Todos esses eventos ocorreram na antiga primavera.  E aqueles sobre os quais falamos acima são eventos do Spring Boot (eventos especiais que ele adicionou para seu ciclo de vida).  E há um monte deles.  Estes são os principais: </p><br><ul><li> <code>ApplicationStartingEvent</code> </li> <li> <code>ApplicationEnvironmentPreparedEvent</code> </li> <li> <code>ApplicationPreparedEvent</code> </li> <li> <code>ContextRefreshedEvent</code> </li> <li> <code>EmbeddedServletContainerInitializedEvent</code> </li> <li> <code>ApplicationReadyEvent</code> </li> <li> <code>ApplicationFailedEvent</code> </li> </ul><br><p>  Esta lista está longe de tudo.  Mas é importante que alguns deles estejam relacionados ao Spring Boot e façam parte do Spring (bom e velho <code>ContextRefreshedEvent</code> , etc.). </p><br><p>  A ressalva é que nem todos esses eventos podem ser recebidos no aplicativo (meros mortais - avós diferentes - não podem apenas ouvir os eventos complexos que o Spring Boot lança).  Mas se você conhece os mecanismos secretos do spring.factories e define o Application Listener no nível do spring.factories, esses eventos, desde o estágio inicial da inicialização do aplicativo, chegam até você. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/54f/14e/bca/54f14ebca5de6e029b3b47dc50f8c7e2.png"><br></p><br><p>  Como resultado, você pode influenciar o início do seu aplicativo em um estágio bastante inicial.  A piada, no entanto, é que parte desse trabalho é realizada em outras entidades - como <code>EnvironmentPostProcessor</code> e <code>ApplicationContextInitializer</code> . </p><br><p>  Você poderia fazer tudo com os ouvintes, mas seria inconveniente e feio.  Se você deseja ouvir todos os eventos que o Spring lança, e não apenas <code>ContextRefreshedEvent</code> e <code>ContextStartedEvent</code> , não é necessário definir o ouvinte, como um bean, da maneira usual (caso contrário, será criado tarde demais).  Ele também deve ser registrado através do spring.factories, e será criado muito antes. </p><br><p>  A propósito, quando analisamos esta lista, não estava claro para nós quando o <code>ContextStartedEvent</code> e o <code>ContextStoppedEvent</code> dispararam? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/796/e78/7ca/796e787ca88d7271898b4072c03d3691.png"><br></p><br><p>  Acontece que esses eventos nunca funcionam.  Ficamos intrigados por um longo tempo sobre quais eventos deveriam ser capturados para entender que o aplicativo realmente foi iniciado.  E aconteceu que os eventos sobre os quais estávamos falando agora aparecem quando você puxa com força os métodos do contexto: </p><br><ul><li> <code>ctx.start();</code>  -&gt; <code>ContextStartedEvent</code> </li><li> <code>ctx.stop();</code>  -&gt; <code>ContextStoppedEvent</code> </li></ul><br><p>  I.e.  <code>SpringApplication.run</code> virão somente se executarmos <code>SpringApplication.run</code> , obtermos o contexto, extrair <code>ctx.start();</code>  ou <code>ctx.stop();</code>  .  Não está muito claro por que isso é necessário.  Mas, novamente, eles deram a você um ponto de extensão. </p><br><p>  Spring tem algo a ver com isso?  Nesse caso, em algum lugar deve haver uma exceção: </p><br><ul><li> <code>ctx.stop();</code>  (1) </li><li> <code>ctx.start();</code>  2) </li><li> <code>ctx.close();</code>  (3) </li><li> <code>ctx.start();</code>  4) </li></ul><br><p>  De fato, estará na última linha, porque depois de <code>ctx.close();</code>  nada pode ser feito com o contexto.  Mas chame <code>ctx.stop();</code>  antes de <code>ctx.start();</code>  - você pode (o Spring simplesmente ignora esses eventos - eles são apenas para você). </p><br><p>  Escreva para seus ouvintes, ouça você mesmo, <code>ctx.stop();</code> suas leis, o que fazer em <code>ctx.stop();</code>  e o que fazer em <code>ctx.start();</code>  . </p><br><p>  No total, o diagrama da interação e do ciclo de vida do aplicativo é mais ou menos assim: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f05/25b/6b5/f0525b6b5742a9a7969a17465b174a4f.png"><br></p><br><p>  As cores aqui mostram diferentes períodos da vida. </p><br><ul><li>  Azul é Spring Boot, o aplicativo já foi iniciado.  Isso significa que as solicitações de serviço do Tomcat enviadas pelos clientes são processadas, todo o contexto é definitivamente gerado, todos os beans estão funcionando, os bancos de dados estão conectados etc. </li><li>  Verde - um evento <code>ContextRefreshedEvent</code> chegou e o contexto foi criado.  A partir deste momento, por exemplo, os ouvintes de aplicativos começam a funcionar, que você implementa definindo a anotação ApplicationListener ou através da interface de mesmo nome com um genérico que escuta determinados eventos.  Se você deseja receber mais eventos, precisa escrever o mesmo ApplicationListener em spring.factories (o Spring usual funciona aqui).  Uma barra indica onde o relatório do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Spring Ripper</a> começa. </li><li>  Numa fase anterior, o SpringApplication funciona, o que prepara o contexto para nós.  Esse é o trabalho de preparar o aplicativo que fizemos quando éramos desenvolvedores regulares do Spring.  Por exemplo, WebXML configurado. </li><li>  Mas existem estágios ainda anteriores.  Mostra quem, onde e para quem trabalha. </li><li>  Ainda existe um estágio cinza no qual é impossível cunhar de alguma maneira.  Este é o estágio em que o SpringApplication fica fora da caixa (apenas entre no código). </li></ul><br><p>  Se você notou, durante o relatório de duas partes, fomos da direita para a esquerda: começamos do final, estragamos a configuração que voava do iniciador e adicionamos o seguinte, etc.  Agora vamos falar rapidamente de toda a cadeia na direção oposta. <br>  Você escreve em seu <code>SpringApplication.run</code> principal.  Ele encontra ouvintes diferentes, lança um evento que ele começou a construir.  Depois disso, os ouvintes encontram o <code>EnvironmentPostProcessor</code> , deixe-os configurar o ambiente.  Depois que o ambiente é configurado, começamos a construir o contexto (Carlson entra).  Carlson cria o contexto e permite que todos os Inicializadores de Aplicativos façam algo com esse contexto.  Temos um ponto de extensão.  Depois disso, o contexto já está configurado e, em seguida, acontece o mesmo que em um aplicativo Spring regular, quando o contexto é criado - <code>BeanFactoryPostProcessor</code> , <code>BeanPostProcessor</code> , os beans são configurados.  É isso que a primavera comum faz. </p><br><h2>  Como executar </h2><br><p>  Terminamos de discutir o processo de criação de um aplicativo. </p><br><p>  Mas tínhamos mais uma coisa que os desenvolvedores não gostam.  Eles não gostam de pensar como, no final, sua aplicação será iniciada.  O administrador o executará no Tomcat, JBoss ou no WebLogic?  Apenas tem que funcionar.  Se não funcionar, na pior das hipóteses, o desenvolvedor precisará configurar algo novamente </p><br><p>  Então, quais são os nossos métodos de lançamento? </p><br><ul><li>  guerra tomcat; </li><li>  ideia; </li><li>  <code>java -jar/war</code> . </li></ul><br><p>  O Tomcat não é uma tendência em massa, não falaremos sobre isso em detalhes. </p><br><p>  A ideia também não é, em princípio, muito interessante.  É apenas um pouco mais complicado do que vou dizer abaixo.  Mas em Idea, em princípio, não deve haver problemas.  Ela vê que tipo de dependências o acionador de partida trará. <br>  Se fizermos <code>java -jar</code> , o principal problema é criar um caminho de classe antes de iniciar o aplicativo. </p><br><p>  O que as pessoas fizeram em 2001?  Eles escreveram em <code>java -jar</code> qual jar deve ser executado, então um espaço, <code>classpath=...</code> e scripts foram indicados lá.  No nosso caso, existem 150 MB de várias dependências que os iniciantes adicionaram.  E tudo isso teria que ser feito manualmente.  Naturalmente, ninguém faz isso.  Nós apenas escrevemos: <code>java -jar</code> , qual jar deve ser executado e é isso.  De alguma forma, o caminho de classe ainda está sendo construído.  Vamos falar sobre isso agora. </p><br><p>  Vamos começar com a preparação do arquivo jar para que ele possa ser iniciado sem o Tomcat.  Antes de criar o <code>java -jar</code> , você precisa construir um jar.  Esse jarro obviamente deve ser incomum, algum tipo de analógico de guerra, onde tudo estará dentro, incluindo o Tomcat incorporado. </p><br><pre> <code class="java hljs">&lt;build&gt; &lt;plugins&gt;    &lt;plugin&gt;       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;       &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;    &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;</code> </pre> <br><p>  Quando baixamos o projeto, alguém já registrou um plug-in em nosso POM.  Aqui, a propósito, você pode lançar configurações, mas mais sobre isso mais tarde.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, além do jar comum que cria o Maven ou Gradle do seu aplicativo, também é criado um jar incomum. </font><font style="vertical-align: inherit;">Por um lado, parece bom:</font></font></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/877/aad/b8e/877aadb8e0edbfbe6df10853b8c3f0c9.png"><br></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mas se você olhar de lado: </font></font></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5ea/499/a35/5ea499a35d217fca525c27d7c8d2cfd3.png"><br></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isso é basicamente um análogo da guerra. </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos ver do que se trata. </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, existem peças padrão, como no jarro comum. </font><font style="vertical-align: inherit;">Quando escrevemos </font></font><code>java -jar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, todas as classes que estão na raiz, por exemplo, são ativadas </font></font><code>org.springframework.boot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas essas não são as nossas aulas. </font><font style="vertical-align: inherit;">Dificilmente escrevemos o pacote org.springframework.boot. </font><font style="vertical-align: inherit;">Portanto, antes de tudo, para nós é familiar</font></font><code>META-INF</code> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5a0/6c7/31e/5a06c731e6b958d02f683de73b2c5a9c.png"><br></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O Spring Boot também MANIFEST (através do mesmo plug-in Maven ou Gradle), personaliza-o e prescreve a classe principal, que inicia no jar. </font></font></p><br><p>  ,  jar-    :     -,    main-.     <code>java -jar</code>   -jar,   ,   main-class-. </p><br><p>  ,   ,        MANIFEST,  main-class   ,    main (    Idea).     ,     .     class path?    <code>java -jar</code>  ,  main,   , —    main,     .    MANIFEST      JarLauncher. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/496/8b5/f76/4968b5f76b6ece2fc7431dbc6195d14e.png"><br></p><br><p>  I.e.     ,     ,    JarLauncher.    ,    main,     class path. <br>    ,    main?   property — <code>Start-class</code> . </p><br><p>  I.e.       .     class path  jar. ,    — <code>org.springframework.boot</code> —   class path.      <code>org.springframework.boot.loader.JarLauncher</code>  main-class.   , main-class  .   class path,    <code>BOOT-INF</code> (   lib     class  ,      ). </p><br><p>    RavenApplication, properties   class  <code>BOOT-INF</code> ,   ,  Tomcat  ,   <code>BOOT-INF/lib/</code> .  JarLauncher  classpath,     —  ,    <code>start-class</code> .     Spring, <code>ContextSpringApplication</code> —   flow,     . </p><br><p>   ,   start-class-?    ,     .      ,  . </p><br><p> ,     .     property,   <code>mainClass</code> ,   MANIFEST   <code>Start-Class</code> ,  <code>mainClass</code> —   JarLauncher. </p><br><p>      ,   mainClass,   ?     . Spring boot plugin   –  mainClass: </p><br><ul><li>     –    .     —     main class; </li><li>    – ,   mainClass   <code>@SpringBootApplication</code>   , , ,  ; </li><li>    —  exception   ,    main class,  ,     jar-  .  I.e.    ,  ,   . ,   ,     main class. </li><li>  @SpringBootApplication  —   . </li></ul><br><p> JarLauncher   .   Tomcat     WarLauncher,      war-  ,  jar-. </p><br><p>    ,     <code>java -jar</code> .   ?  Você pode.   . </p><br><pre> <code class="java hljs">&lt;build&gt; &lt;plugins&gt;    &lt;plugin&gt;       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;       &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;       &lt;configuration&gt;          &lt;executable&gt;<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>&lt;/executable&gt;       &lt;/configuration&gt;    &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;</code> </pre> <br><p>     <code>&lt;configuration&gt;</code>    <code>&lt;executable&gt;true&lt;/executable&gt;</code>    Gradle  ,  : </p><br><pre> <code class="java hljs">springBoot { executable = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> }</code> </pre> <br><p>      jar   executable jar.       . </p><br><p>  ,    .   Windows ,     exe-,   .       Spring Boot, ..   jar,    .      ,    . <br>   ? </p><br><p>      (jar —  zip-,     ): </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/355/f0a/08d/355f0a08d8a971a533cd824c84939827.png"><br></p><br><p> Spring Boot  - . </p><br><p>  -,   jar-.   ,      ,     — <code>#!/bin/bash</code> .     . </p><br><p>       .   <code>exit 0</code>   -  —      zip-. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/365/674/922/365674922651752dc5a5896f48764d8e.png"><br></p><br><p>   ,   zip-    — <code>0xf4ra</code> .     ,  ,    . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/60e/915/263/60e915263d6af6d19a5f0a7df977ee82.png"><br></p><br><p>       (,   ..). </p><br><p>  jar    : </p><br><ul><li>     —     ; </li><li>  ,    "   bash" ( <code>#!/bin/bash</code> ); </li><li> bash   ; </li><li>      <code>exit 0</code> ; </li><li>    <code>java -jar</code>   —     jar-,   ; </li><li>  <code>java -jar</code>  zip-   jar-,  ,    ,       . </li></ul><br><h2>  Conclusões </h2><br><p>         ,  Spring Boot —   ,     ,     . </p><br><p> -,  .  ,    Spring,   Spring —      Spring Boot.    ,         ,        — , ,   ,     . ,  ,     Spring, Spring Boot  . </p><br><p> -,    <code>@SpringBootApplication</code> ,     best practice,     Spring-. </p><br><p>   —   ,     ,   .    property  environment variable,    var arg   ,       ,    JSON.            <code>@value</code>       ,    .  configuration properties ,     ,     ,       .  ,  Spring     .   ,     ,      . </p><br><p>  .      ,    .          Spring,  Spring Boot    .    - ,   ,  ,           . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dc9/832/498/dc983249828e3fd26a257f871e46409e.png"><br></p><br><blockquote>  Minuto de publicidade. 19-20    Joker 2018,            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">«          [Joker Edition]»</a> ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">«Micronaut vs Spring Boot,     ?»</a>  .  ,  Joker       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425333/">https://habr.com/ru/post/pt425333/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425323/index.html">"Toca do coelho". Designer de UX na equipe de produtos</a></li>
<li><a href="../pt425325/index.html">Intérpretes de Bytecode DIY</a></li>
<li><a href="../pt425327/index.html">Programação funcional: meça sete vezes, corte uma vez</a></li>
<li><a href="../pt425329/index.html">Alguns conselhos aos millennials dos "oldies". Como ter sucesso em nosso mundo digital</a></li>
<li><a href="../pt425331/index.html">Alice ajudará os desenvolvedores a encontrar objetos nas solicitações do usuário. NER em caixas de diálogo</a></li>
<li><a href="../pt425335/index.html">Armada invicta Garmin</a></li>
<li><a href="../pt425337/index.html">Como escalar o Scrum - algumas palavras sobre a estrutura de desenvolvimento ágil do Nexus</a></li>
<li><a href="../pt425339/index.html">Arquitetura de informações da Internet - parte 2</a></li>
<li><a href="../pt425341/index.html">Visão geral da “Top 3D Expo. Educação digital 2018 »</a></li>
<li><a href="../pt425343/index.html">25 ferramentas úteis do Kubernetes: implantação e gerenciamento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>