<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÉ üïπÔ∏è ü§© L'√©tude du syst√®me de fichiers HDD du mod√®le DVR QCM-08DL ü§∂üèº üë©üèæ‚Äçüíª üßì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article est consacr√© √† l'√©tude de la structure des fichiers du disque dur d'un enregistreur vid√©o √† huit canaux √† des fins d'extraction de masse d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L'√©tude du syst√®me de fichiers HDD du mod√®le DVR QCM-08DL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421933/"><img src="https://habrastorage.org/webt/jl/fy/ud/jlfyudollyahkfmnnmsy0fa-8xu.jpeg"><br><br>  Cet article est consacr√© √† l'√©tude de la structure des fichiers du disque dur d'un enregistreur vid√©o √† huit canaux √† des fins d'extraction de masse de fichiers vid√©o.  √Ä la fin de l'article se trouve la mise en ≈ìuvre du programme correspondant en C. <br><a name="habracut"></a><br>  Enregistreur vid√©o (DVR abr√©g√©) QCM-08DL est utilis√© dans les syst√®mes de vid√©osurveillance et permet l'enregistrement vid√©o et audio √† huit canaux.  Ce mod√®le, √† mon avis, est l'un des moins chers et en m√™me temps fiable en fonctionnement.  Le format de compression vid√©o est le format H264 populaire.  Pour l'audio, le format de compression est ADPCM.  La vid√©o et l'audio sont enregistr√©s sur un disque dur SATA (HDD) d'ordinateur standard install√© √† l'int√©rieur du DVR.  En utilisant le DVR lui-m√™me, il est possible de visualiser les enregistrements en les recherchant par date et heure.  Il est √©galement possible d'extraire des donn√©es dans un fichier sur un support externe.  Tout d'abord, sur un lecteur USB qui se connecte √† l'interface USB du DVR.  Deuxi√®mement - √† l'ordinateur via l'interface WEB du DVR.  Le nom du fichier r√©sultant est long et comprend la date d'enregistrement, l'heure de d√©but et de fin, le canal d'enregistrement et d'autres informations suppl√©mentaires.  L'extension de fichier est ¬´.264¬ª.  Un examen du contenu d'un tel fichier m'a montr√© clairement que le conteneur multim√©dia dans lequel les flux audio et vid√©o sont emball√©s est loin d'√™tre standard.  Un tel fichier peut √™tre ouvert √† l'aide du lecteur fourni avec le DVR.  Le joueur est tr√®s mal √† l'aise.  Mais vous pouvez √©galement utiliser le programme de reconditionnement pour le conteneur AVI, qui est √©galement inclus.  Ce programme reconditionne le flux vid√©o, le laissant au format H264.  Et le flux sonore est converti d'ADMCM en PCM, ce qui augmente sa taille 4 fois.  Le r√©sultat est un fichier .avi qui peut √™tre lu par n'importe quel lecteur standard.  Je constate tout de suite que ce programme de reconditionnement est tr√®s g√™nant.  Il vous permet d'effectuer des op√©rations sur un seul fichier.  Pour remballer un ensemble de fichiers, vous devez les ouvrir √† leur tour. <br><br>  Les t√¢ches suivantes ont √©t√© d√©finies. <br><br><ol><li>  Acc√©dez √† tous les fichiers .264 du disque dur du DVR en connectant le disque dur √† l'ordinateur. </li><li>  Pour √©tudier l'algorithme par lequel le programme de reconditionnement 264-avi standard fonctionne et cr√©er le m√™me programme qui effectuerait les m√™mes op√©rations, mais pas sur un, mais sur un groupe entier de fichiers, en un seul clic. </li></ol><br>  La premi√®re t√¢che, √† premi√®re vue, peut sembler tr√®s simple: il vous suffit de connecter le disque dur √† l'ordinateur et d'ouvrir les partitions dans l'Explorateur.  Cependant, il y a des pi√®ges.  Cet article est consacr√© √† la premi√®re t√¢che. <br><br>  Je savais d√©j√† √† l'avance que le shell logiciel du microcontr√¥leur DVR est bas√© sur un syst√®me d'exploitation similaire √† Linux.  Par cons√©quent, le partitionnement du disque dur sera probablement similaire √† Linux.  Par cons√©quent, vous avez besoin d'un ordinateur Linux.  Dans mon cas, la capacit√© du disque dur est de 1 To, un ordinateur avec OS Xubuntu.  Apr√®s avoir connect√© le disque dur √† l'ordinateur, je n'ai pu voir qu'une seule partition pour plusieurs gigaoctets.  Ce n'est clairement pas ce dont vous avez besoin.  √Ä l'int√©rieur de la section, il existe de nombreux dossiers au format de nom ¬´AAAA-MM-JJ¬ª correspondant aux dates des enregistrements.  √Ä l'int√©rieur de chaque dossier, il existe de nombreux fichiers correspondant aux entr√©es.  Fichiers du m√™me nom que ceux obtenus lors de l'extraction du DVR.  Cependant, leur taille est plusieurs fois plus petite et l'extension n'est pas .264, mais .nvr.  Il faut supposer que ces m√™mes fichiers nvr sont des cl√©s pour les 264 fichiers correspondants (ou leurs flux multim√©dias), dont le contenu se trouve sur l'espace disque dur principal.  J'ai copi√© les donn√©es du dossier de fichiers sur un support s√©par√© pour de plus amples recherches. <br><br>  J'ai utilis√© beaucoup d'outils logiciels pour la recherche: un √©diteur de disque (c'est aussi un √©diteur de fichiers binaires) DiskExplorer (j'ai utilis√© WinHex plus tard), MS Excel pour les calculs auxiliaires et la fixation des r√©sultats, environnement de programmation Dev-C ++ pour √©crire les programmes de console auxiliaires et finaux, etc.  Dans cet article, je vais essayer de parler de cette proc√©dure. <br><br>  Tout d'abord, regardez le tout premier secteur du disque dur (un secteur (1 LBA) prend 512 octets).  Ce secteur, en r√®gle g√©n√©rale, contient une structure MBR.  Il comprend un chargeur de d√©marrage et une table des mati√®res de base.  La structure de ce secteur, ainsi que la structure de la description de la section, est donn√©e ci-dessous (tir√©e de Wikipedia). <br><br><img src="https://habrastorage.org/webt/yb/x9/iq/ybx9iqnwe7dx7ghojh7xnyfghbm.jpeg"><br><br><img src="https://habrastorage.org/webt/mz/w4/v1/mzw4v1rt6vrfmmrmbbrn2m-ggu0.jpeg"><br><br>  Dans le cas du disque dur √©tudi√©, nous avons ce qui suit.  En regardant la figure ci-dessous et en suivant les tableaux ci-dessus, nous voyons que le chargeur de d√©marrage est manquant.  Mais nous sommes plus int√©ress√©s par la table de partition.  Il est mis en √©vidence dans un cadre rouge.  Les deux derniers octets (remplissage bleu) - signature MBR.  Vous pouvez voir dans la table de partition que le disque est divis√© en deux sections.  Le code pour le type de la premi√®re section (remplissage jaune) est 0x0B.  Il s'agit d'une partition FAT32.  Le code pour le type du second (remplissage orange) est 0x83.  Il s'agit de l'une des partitions Linux (au sens d'EXT).  Les octets de code de type de partition sont entour√©s en bleu. <br><br><img src="https://habrastorage.org/webt/ua/2h/l6/ua2hl6viqijfm3qwziadcpf3myi.jpeg"><br><br>  Un d√©cryptage complet du secteur MBR avec un tableau des sections et leurs param√®tres est donn√© ci-dessous. <br><br><img src="https://habrastorage.org/webt/h2/mc/8j/h2mc8jovgedyxw1lcswaodx-xoa.jpeg"><br><br>  En faisant attention √† la taille des partitions (en comptant le nombre de secteurs en gigaoctets), il est facile de deviner que sur l'ordinateur avec le syst√®me d'exploitation Xubuntu, c'√©tait la premi√®re partition qui occupait une petite partie de l'espace disque.  Soit dit en passant, dans Windows XP, seule la premi√®re partition √©tait √©galement affich√©e, mais elle ne s'est pas ouverte √† partir de l'explorateur.  Et pourquoi, alors, la deuxi√®me partition Linux n'apparaissait pas sur le syst√®me d'exploitation Xubuntu? <br><br>  Ayant pr√©c√©demment √©tudi√© la structure et l'organisation du syst√®me de fichiers Linux en utilisant EXT2 comme exemple, j'ai commenc√© √† √©tudier la deuxi√®me section. <br><br>  Comme vous pouvez le voir dans le tableau des sections, la deuxi√®me section commence par le secteur 16016805. Le manuel du syst√®me de fichiers EXT2 indique la pr√©sence du soi-disant superbloc, qui se trouve √† 1024 octets depuis le d√©but de la section (c'est-√†-dire deux secteurs depuis le d√©but).  Cependant, le secteur 16016805 + 2 = 16016807 √©tait vide.  Mais le premier secteur 16016805 dans sa structure ressemblait √† un superbloc.  Mais son contenu ne correspondait pas enti√®rement √† la description du contenu du superbloc du manuel.  Le superbloc est le bloc principal, qui contient une sorte de tableau de diverses constantes et param√®tres pour le fonctionnement du syst√®me de fichiers: adresses des positions et tailles des autres blocs n√©cessaires, en particulier, en-t√™tes des enregistrements de fichiers et des r√©pertoires.  Des recherches plus pouss√©es dans cette section m'ont conduit √† une seule conclusion: le DVR utilise son propre syst√®me de fichiers unique. <br><br>  √Ä l'avenir, j'ai d√©cid√© de regarder le premier secteur de la premi√®re section (secteur 63) et de faire d√©filer vers le bas.  Il a √©t√© trouv√© sur le contenu du secteur 65 (deux secteurs ci-dessous) qui est compl√®tement similaire au contenu du superbloc FS EXT2, qui est d√©crit dans le manuel.  Des recherches plus pouss√©es ont permis de conclure que la premi√®re partition du HDD DVR est la partition EXT2, qui √©tait affich√©e sur le syst√®me d'exploitation Xubuntu, ind√©pendamment de la marque 0x08 (pas EXT) dans la table des mati√®res!  Ainsi, la premi√®re partition du disque dur du DVR est la partition EXT2, sur laquelle sont enregistr√©s les fichiers nvr, qui sont les cl√©s des enregistrements vid√©o requis. <br><br>  J'√©crirai bri√®vement sur la structure des fichiers .264, que j'ai √©galement examin√©e pr√©c√©demment.  Ces informations seront n√©cessaires √† l'avenir pour √©tudier la deuxi√®me section du disque dur.  Comme dans tout conteneur multim√©dia, dans ¬´264¬ª, il y a un en-t√™te avec des informations de service et des balises multim√©dias, ainsi que des flux audio et vid√©o qui se succ√®dent en petits blocs l'un apr√®s l'autre.  √Ä un d√©calage de 0x84 octets par rapport au d√©but du fichier, le mot cl√© "MDVR96NT_2_R" est enregistr√©.  Avant ce mot se trouvent des octets li√©s √† la date et √† l'heure d'enregistrement.  Mais ces informations sont contenues dans le nom du fichier, par cons√©quent, elles ne m√©ritent pas une attention particuli√®re ici.  Apr√®s cela vient beaucoup d'octets de z√©ros.  Les informations principales concernant les flux audio et vid√©o proviennent d'un d√©calage de 65 536 octets.  Les blocs de flux vid√©o commencent par un en-t√™te de 8 octets ¬´01dcH264¬ª (√©galement trouv√© ¬´00dcH264¬ª).  Les 4 octets suivants d√©crivent la taille du bloc actuel du flux vid√©o en octets.  Apr√®s 4 octets de z√©ros (00 00 00 00), le bloc de flux vid√©o commence lui-m√™me.  Les blocs de flux audio ont le titre "03wb" (bien que, selon mes observations, le premier caract√®re de l'en-t√™te dans certains cas n'√©tait pas n√©cessairement "0").  Apr√®s - 12 octets d'informations que je n'ai pas encore compris.  Et en commen√ßant par le 17e octet - un flux audio d'une longueur fixe de 160 octets.  Il n'y a pas de balises √† la fin du fichier. <br><br>  Nous proc√©dons √† l'√©tude de la structure des fichiers et r√©pertoires situ√©s sur la premi√®re partition du disque dur.  Comme mentionn√© ci-dessus, le contenu de la section a √©t√© copi√© sur un support distinct via un explorateur normal dans le syst√®me d'exploitation Xununtu.  Dans chaque r√©pertoire (r√©pertoire), en plus des fichiers nvr, il y a un fichier binaire nomm√© "file_list".  A en juger par le nom, il contient des informations sur la liste des fichiers dans le r√©pertoire courant.  Ouvrez ce fichier dans l'√©diteur binaire (voir la figure ci-dessous).  J'ai √©tudi√© la structure de ce dossier, et il n'y a fondamentalement rien d'int√©ressant ici.  Le fichier ne contient aucune information concernant l'emplacement des flux multim√©dias souhait√©s.  N√©anmoins, j'√©crirai bri√®vement sur cette structure.  Les 32 premiers octets sont un en-t√™te avec quelques constantes.  Les 16 octets suivants sont li√©s √† la date et l'heure et au nombre de fichiers dans le r√©pertoire en cours.  Ceci est suivi de 48 octets de constantes.  Suivant - 8 octets de constantes, indiquant le d√©but de l'enregistrement de fichier.  Ensuite, 96 octets indiquant le chemin d'acc√®s complet au fichier nvr, y compris son nom.  Suivant - 24 octets li√©s au temps (le nombre de secondes √©coul√©es depuis le d√©but de la journ√©e, le d√©but et la fin de la vid√©o) et d'autres attributs de la vid√©o.  Et ainsi de suite, par analogie, pour tous les fichiers nvr du r√©pertoire courant.  Leur nombre est √©gal au nombre de vid√©os de la journ√©e en cours, indiqu√© par le nom du r√©pertoire en cours.  √Ä quoi sert ce fichier?  Apparemment, pour acc√©l√©rer la recherche de vid√©o dans l'interface DVR. <br><br><img src="https://habrastorage.org/webt/ey/tq/dh/eytqdh-oadafzwauaoh2fbogo9o.jpeg"><br><br>  Passons √† l'√©tude de la structure des fichiers nvr eux-m√™mes.  L'aspect d'un tel fichier dans un √©diteur binaire (plus pr√©cis√©ment dans un √©diteur hexad√©cimal) est illustr√© dans la figure ci-dessous.  Sans entrer dans les d√©tails de la description de la structure du contenu (dont une partie est rest√©e un myst√®re pour moi), j'ai mis en √©vidence les param√®tres les plus √©l√©mentaires, qui sont la cl√© √† trouver.  Il s'agit de valeurs 32 bits (4 octets), situ√©es tous les 32 octets, √† partir de l'octet √† l'offset 40. Sur la figure, elles sont surlign√©es en rouge.  √Ä l'avenir, je suis devenu convaincu que cela suffit pour la cl√© des vid√©os.  Je vous rappelle que 4 octets de la valeur de ce param√®tre cl√© sont situ√©s du plus bas au plus haut, mais pas l'inverse!  Cette notation est due √† l'architecture du processeur PC.  L'exemple de la figure montre le premier fichier nvr du premier r√©pertoire.  Il correspond au premier enregistrement vid√©o r√©alis√© par le DVR.  De toute √©vidence, les valeurs des param√®tres, que j'ai appel√© cl√©, dans l'exemple ci-dessus forment une s√©quence d'entiers, commen√ßant √† z√©ro et allant dans l'ordre croissant.  En examinant d'autres fichiers nvr et en regardant exactement ces octets sp√©cifi√©s, des entiers ont √©galement √©t√© vus, croissant.  Mais cette s√©quence n'a naturellement plus commenc√© √† partir de z√©ro, et dans certains cas, des lacunes dans un ou deux nombres ont √©t√© observ√©es par endroits.  Par exemple (num√©ros du bulldozer): 435, 436, 438, 439, 442, ... (ou en hexad√©cimal: B3010000, B4010000, B6010000, B7010000, BA010000, ...). <br><br><img src="https://habrastorage.org/webt/nl/50/eo/nl50eo8cjnx0mnexkbcf-sqld20.jpeg"><br><br>  Une telle s√©quence avec omissions s'est produite sur des fichiers nvr correspondant aux vid√©os que le DVR a enregistr√©es simultan√©ment √† partir de deux canaux ou plus.  C'est-√†-dire, par exemple, si la s√©quence "435, 436, 438, 439, 442, ..." se r√©f√®re √† la vid√©o d'un canal, alors les valeurs manquantes (437, 440, 441) se rapporteront √† la vid√©o d'un autre canal, qui a √©t√© effectu√©e dans le m√™me point dans le temps.  J'√©tais moi-m√™me convaincu de cela en consultant et en comparant les fichiers NVR correspondants, en fonction de leur nom.  Il ne fait aucun doute que les num√©ros ci-dessus forment les num√©ros de certaines parties li√©es aux vid√©os.  Il ne reste plus qu'√† d√©m√™ler la relation entre ces nombres et les coordonn√©es de l'espace disque sur lequel se trouvent les donn√©es. <br><br>  En outre, c'√©tait pour savoir exactement quelles donn√©es sont divis√©es en segments num√©rot√©s ci-dessus?  Premi√®re hypoth√®se - les donn√©es sont des flux audio et vid√©o qui, dans le conteneur 264, sont repr√©sent√©s par des blocs courts et, comme cela a √©t√© dit, les blocs du flux vid√©o ont des tailles diff√©rentes.  Dans le m√™me temps, le DVR collecte ces flux et les place dans un conteneur 264 au stade de l'extraction des enregistrements vid√©o vers des supports externes. La deuxi√®me hypoth√®se est que le DVR emballe les flux audio et vid√©o dans un conteneur 264 au d√©but et pendant la capture vid√©o.  Et en m√™me temps, des donn√©es de fichier .264 d√©j√† g√©n√©r√©es sont √©crites sur le disque dur, ce qui se serait av√©r√© √† la suite de leur extraction sur un support externe.  En explorant l'espace disque dur quelque part au milieu de la deuxi√®me section, avec les octets de flux audio et vid√©o et leurs en-t√™tes du m√™me type que dans le conteneur 264, je suis √©galement tomb√© sur les en-t√™tes du conteneur lui-m√™me: MDVR96NT_2_R.  Apr√®s cet en-t√™te, il y avait √©galement de nombreux octets de z√©ros.  En g√©n√©ral, l'√©tude a montr√© qu'il existe une deuxi√®me option parmi les deux ci-dessus.  Par cons√©quent, pour obtenir le fichier .264 souhait√©, il vous suffit probablement de connecter tous les segments dont les num√©ros sont contenus dans le fichier nvr correspondant. <br><br>  Commen√ßons la recherche de la relation entre le num√©ro de segment et les coordonn√©es sur le disque dur. <br><br>  Le d√©but des donn√©es du conteneur 264 correspondant au tout premier enregistrement vid√©o (o√π la num√©rotation des segments commence √† z√©ro) avec des outils de recherche que j'ai trouv√©s sur le secteur 16046629 (29824 secteurs depuis le d√©but de la section).  Nous pouvons faire une hypoth√®se sur le soi-disant param√®tre  biais initial, qui participera √† la formule d√©crivant la d√©pendance souhait√©e. <br><br>  Prenons deux fichiers nvr correspondant √† des vid√©os de diff√©rentes cha√Ænes que le DVR a captur√©es en m√™me temps.  Pour ce faire, jetez un ≈ìil aux noms de fichiers.  Par exemple, les vid√©os point√©es par les fichiers ¬´ch00000000000001-150330-160937-161035-02p101000000.nvr¬ª et ¬´ch00000000000004-150330-160000-163000-00p004000000.nvr¬ª ont √©t√© enregistr√©es simultan√©ment.  Le premier enregistrement est l'enregistrement de la 1√®re cha√Æne de 16:09:37 √† 16:10:35.  Le deuxi√®me record est un record de la 4√®me cha√Æne de 16:00:00 √† 16:30:00.  Les deux entr√©es ont √©t√© faites le 30 mars 2015. Sur la chronologie, √©videmment, l'intervalle de temps du premier enregistrement est un sous-ensemble de l'intervalle de temps du deuxi√®me enregistrement.  Je prends √©galement en compte le fait que dans un intervalle de temps plus court (√† l'intersection de deux intervalles) le DVR n'a effectu√© aucune capture vid√©o √† partir des 6 autres canaux.  Parcourez le contenu de ces fichiers nvr.  Nous allons nous assurer que les num√©ros manquants (num√©ros de segment) dans le deuxi√®me fichier long sont n√©cessairement pr√©sents dans le premier fichier court, compl√®tement et compl√®tement.  En utilisant le DVR de la mani√®re habituelle, vous devez extraire au moins un des fichiers .264 r√©f√©renc√©s par les fichiers NVR √©tudi√©s √† l'avance.  Supposons que "ch00000000000001-150330-160937-161035-02p101000000.264" a √©t√© extrait.  Ouvrez-le dans l'√©diteur binaire.  Comme d√©j√† mentionn√©, au d√©but de ce fichier, avant le mot-cl√© "MDVR96NT_2_R", il y a des octets uniques correspondant √† la date et l'heure de l'enregistrement vid√©o contenues dans ce fichier.  Nous annulons tous ces octets, en commen√ßant par une valeur non nulle et en terminant par l'en-t√™te (plus la cha√Æne d'octets est courte pour cet enregistrement vid√©o, mieux c'est).  Notez √©galement le d√©calage de cette cha√Æne d'octets depuis le d√©but du fichier.  Il convient de noter qu'au d√©but du fichier .264 extrait, il y a 4 octets suppl√©mentaires de z√©ros.  Cela est devenu perceptible en comparant les 512 premiers octets du fichier .264 et le secteur de l'espace disque √† partir duquel le contenu de l'un des fichiers .264 commence (un fichier de presque n'importe quel syst√®me de fichiers commence toujours au d√©but du secteur, en outre, un cluster).  Autrement dit, les informations du fichier .264 sont d√©cal√©es √† l'avance de 4 octets vers la droite.  La taille (en octets) de tout fichier .264 est un multiple de 512 uniquement apr√®s avoir soustrait le nombre 4 de la taille.  Commen√ßons la recherche du secteur √† partir duquel le fichier .264 √©tudi√© commence.  Dans l'√©diteur de disque, lancez la fonction de recherche.  Dans le champ de la valeur souhait√©e, entrez une cha√Æne d'octets unique annul√©e √† l'avance.  Pour acc√©l√©rer la recherche, entrez la valeur de d√©calage dans le champ ¬´recherche par d√©calage¬ª, en soustrayant pr√©c√©demment 4. Lancez la recherche.  Quelques heures plus tard, la recherche a r√©ussi.  Nous notons le num√©ro du secteur dans lequel se trouve le titre unique.  Que ce soit la valeur de s.  Nous regardons le contenu du fichier nvr pour cette vid√©o.  Nous radions le num√©ro du premier segment (4 octets √† l'offset 40).  Que ce soit la valeur de b.  Au total, alors que nous connaissons le num√©ro de secteur du disque (16046629) pour le num√©ro de segment z√©ro (dans le tout premier enregistrement vid√©o) et le num√©ro du secteur trouv√© du disque s pour le num√©ro de segment b qui vient d'√™tre supprim√©.  Vous pouvez calculer la taille estim√©e du segment: (s-16046629) / (b-0).  Apr√®s le calcul, j'ai obtenu la valeur 128. Ainsi, la taille du segment est √©gale √† 128 secteurs de disque (LBA), soit 128 * 512 = 65536 octets! <br><br>  J'ai men√© une autre exp√©rience int√©ressante suppl√©mentaire pour enfin dissiper tous les doutes.  Il est d√©crit ci-dessous. <br><br>  D√®s le d√©but des secteurs, nous s√©lectionnons une zone sur le disque avec une taille comparable √† la taille d'un fichier .264 qui commence par ce secteur.  Si mes suppositions sont correctes, alors des segments d'un autre fichier .264, qui a √©t√© captur√© sur le disque dur simultan√©ment avec le premier, tomberont dans la zone s√©lectionn√©e.  Enregistrez cette zone dans un fichier (cr√©ez une image).  Coupez l'image r√©sultante en fichiers de 65 536 octets (taille de segment).  Cela peut √™tre fait en utilisant la fonction ¬´fichier divis√©¬ª dans Total Commander.  Que ce soit des pi√®ces M1, M2, M3, ....  De m√™me, nous avons coup√© le fichier .264 √©tudi√© (qui a √©t√© extrait de mani√®re conviviale du DVR), mais en supprimant d'abord 4 octets de z√©ros en premier.  Que ce soit les pi√®ces K1, K2, K3, ....  En utilisant la fonction ¬´Comparer par contenu¬ª de Total Commander, nous comparons tour √† tour les morceaux de l'image et les morceaux du fichier .264.  (M1 avec K1, M2 avec K2, etc.), guid√© par les num√©ros de segment du fichier nvr correspondant.  Le r√©sultat est le suivant.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supposons (nombres du bulldozer), la cha√Æne de nombres en nvr est la suivante: 435, 436, 438, 439, 442, ... Dans cette situation, M1 = K1, M2 = K2, M4 = K3, M5 = K4, M8 = K5, .... C'est-√†-dire que les morceaux dans lesquels le fichier image et le fichier .264 ont √©t√© divis√©s sont √©gaux, en tenant compte de l'avance correspondante du nombre de morceaux du fichier image, selon les omissions dans la s√©quence. √áa y est! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au total, nous avons obtenu la d√©pendance estim√©e: S = 16046629 + 128 * d, o√π d est le num√©ro de segment dans le fichier nvr, et S est le num√©ro de secteur sur le disque dur, √† partir du tout d√©but du disque √† partir duquel commence le contenu du segment. Taille du segment - 128 secteurs. La formule ci-dessus ne prend pas en compte l'existence de la deuxi√®me section. La d√©pendance se trouve uniquement pour un exemple sp√©cifique du disque dur √† 1 To. Peut-√™tre que si vous mettez une capacit√© diff√©rente dans le disque dur du DVR, les constantes auront un aspect diff√©rent.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour v√©rifier la validit√© de la formule, nous calculons la position du premier segment d'un autre fichier .264 arbitraire, guid√© par le fichier nvr correspondant. En faisant attention √† la date et √† l'heure du nom de fichier, comparez-les avec les premiers octets de l'en-t√™te .264 situ√©s sur le secteur calcul√©. Les octets codant individuellement le nombre, le mois, l'ann√©e, les heures, les minutes, les secondes correspondent √† des donn√©es temporaires dans le nom du fichier. Par cons√©quent, "frappez le clou"! Nous calculons dans le fichier nvr correspondant au fichier .264 extrait √† l'avance, le nombre de segments cs. En g√©n√©ral, leur nombre est cs = sf / 32-1, o√π sf est la taille du fichier nvr. Si le fichier .264 se compose de segments cs, sa taille doit √™tre √©gale √† cs * 65536 + 4 (le nombre de segments multipli√© par la taille du segment en octets, plus 4 des m√™mes octets de z√©ros). Et √ßa l'est vraiment!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essayez tout de m√™me d'explorer la deuxi√®me section. Comme indiqu√© pr√©c√©demment, quelque chose de similaire √† un superbloc est situ√© directement dans le premier secteur de la section (16016805). Et sa copie exacte a √©t√© d√©couverte par sept secteurs ci-dessous (16016812). De toute √©vidence, les informations de base non nulles se trouvent dans le premier secteur du superbloc. Son apparence dans l'√©diteur de disque est illustr√©e dans la figure ci-dessous.</font></font><br><br><img src="https://habrastorage.org/webt/rg/gz/wc/rggzwchl6xsvzhuvbfzslhrhyho.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai r√©ussi √† d√©crypter une partie des param√®tres √† 4 octets. La date et l'heure de montage de la partition sont surlign√©es en bleu. La date et l'heure sont pr√©sent√©es dans une notation sp√©ciale "heure Unix" (le nombre de secondes √©coul√©es depuis minuit le 1er janvier 1970). Dans l'exemple ci-dessus, ¬´03 7E 74 54¬ª (valeur d√©cimale 1416920579) correspond √† ¬´Mar, 25 nov 2014 13:02:59 GMT¬ª. Pour traduire les valeurs, j'ai utilis√© une calculatrice en ligne sp√©ciale. La valeur 65536 est encercl√©e dans le cadre violet. Il est possible que l'interpr√©teur de syst√®me de fichiers √† l'int√©rieur du programme DVR se r√©f√®re √† cette position du superbloc lorsque la taille du bloc est lue (dans le contexte pr√©c√©dent, j'ai appel√© les segments de blocs). Les valeurs 1 sont surlign√©es dans le cadre vert. L'une d'elles indique probablement la position du d√©but de la soi-disant. bitmap (dans le nombre de blocs depuis le d√©but de la section). En effet√† l'avance, le d√©but de l'information a √©t√© trouv√©, quelque chose de similaire √† un bitmap sur le secteur 16016933 (16016805 + 128 * 1). La valeur 233 est mise en √©vidence dans un cadre rouge. C'est pr√©cis√©ment la position du d√©but de ces enregistrements vid√©o .264 depuis le d√©but de la section: 16016805 + 128 * 233 = 16046629.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autrement dit, la deuxi√®me section peut √™tre appel√©e une section tronqu√©e et l√©g√®rement modifi√©e d'EXT2. Il a un superbloc, une copie de celui-ci, un bitmap. Mais il n'y a pas de soi-disant. n≈ìuds d'information correspondant aux enregistrements de fichiers. La section contient des donn√©es de fichiers .264 (flux audio et vid√©o), mais les n≈ìuds d'information (disons-le) pour ces donn√©es sont situ√©s dans des fichiers nvr sur la premi√®re section. Peut-√™tre existe-t-il une formulation plus comp√©tente? Mais ce n'est pas si important pour moi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âcrivons un programme simple pour l'extraction en masse de fichiers .264. Je dois dire tout de suite que je n'ai pas beaucoup d'exp√©rience en programmation sous Windows. Le programme analyse tous les fichiers nvr copi√©s √† l'avance dans la section 1 To du nouveau disque dur. En les analysant, le programme cr√©e un fichier .264 du m√™me nom dans le m√™me r√©pertoire, en utilisant l'acc√®s aux secteurs du disque dur d'origine. Auparavant, un dossier avec le nom ¬´DVR¬ª √©tait cr√©√© dans une section vide du nouveau disque dur, dans lequel les dossiers par date sont plac√©s, qui sont copi√©s de la ¬´mani√®re habituelle¬ª sous Linux. Il a √©t√© possible d'inclure dans ce programme un algorithme pour travailler avec la premi√®re partition Linux pour acc√©der aux fichiers nvr afin de ne pas avoir √† les pr√©-copier. Et vous pouvez ajouter d'autres fonctionnalit√©s pratiques. Oui, c'√©tait possible, mais √† ce moment-l√†, je voulais tout faire le plus rapidement possible.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je n'ai pas utilis√© la r√©cursivit√© pour analyser les r√©pertoires, √©tant donn√© que le format des r√©pertoires est fixe et comporte deux niveaux de pi√®ce jointe. </font><font style="vertical-align: inherit;">En cons√©quence, j'ai appliqu√© deux cycles: parcourir les dossiers jusqu'√† leur fin et parcourir les fichiers de chaque dossier avec la m√™me condition. </font><font style="vertical-align: inherit;">Pour lire des fichiers, j'ai utilis√© la fonction fopen. </font><font style="vertical-align: inherit;">Pour travailler avec les secteurs du disque dur, j'ai utilis√© la fonctionnalit√© WinAPI similaire √† l'utilisation de fichiers. </font><font style="vertical-align: inherit;">Passons au code du programme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les biblioth√®ques en ont besoin.</font></font><br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt;</span></span></span></span></code> </pre> <br>  Et j'ai compl√®tement copi√© ces fonctions √† partir d'un forum. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">HANDLE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> device)</span></span></span><span class="hljs-function"> </span></span>{ HANDLE handle = INVALID_HANDLE_VALUE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (device &lt;<span class="hljs-number"><span class="hljs-number">0</span></span> || device &gt;<span class="hljs-number"><span class="hljs-number">99</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> INVALID_HANDLE_VALUE; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _devicename[<span class="hljs-number"><span class="hljs-number">20</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(_devicename, <span class="hljs-string"><span class="hljs-string">"\\\\.\\PhysicalDrive%d"</span></span>, device); <span class="hljs-comment"><span class="hljs-comment">// Creating a handle to disk drive using CreateFile () function .. handle = CreateFile(_devicename, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL); return handle; } HANDLE openOutputFile(const char * filename) { return CreateFile ( filename, // Open Two.txt. GENERIC_WRITE, // Open for writing 0, // Do not share NULL, // No security OPEN_ALWAYS, // Open or create FILE_ATTRIBUTE_NORMAL, // Normal file NULL); // No template file }</span></span></code> </pre><br>  La fonction de copie contient une formule de d√©pendance lin√©aire, qui est apparue dans la th√©orie ci-dessus. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE device, HANDLE file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s)</span></span></span></span>{ LONG HPos; LONG LPos; __int64 sector; sector = <span class="hljs-number"><span class="hljs-number">16046629</span></span>+<span class="hljs-number"><span class="hljs-number">128</span></span>*s; HPos = (sector*<span class="hljs-number"><span class="hljs-number">512</span></span>)&gt;&gt;<span class="hljs-number"><span class="hljs-number">32</span></span>; LPos = (sector*<span class="hljs-number"><span class="hljs-number">512</span></span>); SetFilePointer (device, LPos, &amp;HPos, FILE_BEGIN); DWORD dwBytesRead; DWORD dwBytesWritten; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">65536</span></span>]; ReadFile(device, buf, <span class="hljs-number"><span class="hljs-number">65536</span></span>, &amp;dwBytesRead, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); WriteFile(file, buf, dwBytesRead, &amp;dwBytesWritten, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); }</code> </pre><br>  La fonction principale est √©galement assez simple. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ HANDLE hdd = openDevice(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    HDD  DVR,    ; SetFilePointer (hdd, 0, NULL, FILE_BEGIN); DWORD dwBytesRead; char name[100]; unsigned int bl; //  ; unsigned int N; // ; unsigned long int pt; //  ; WIN32_FIND_DATA fld,fld1; //   nvr   ; HANDLE hf,hf1; hf=FindFirstFile("E:\\DVR\\*",&amp;fld); FindNextFile(hf,&amp;fld);// "."; FindNextFile(hf,&amp;fld);// ".."; do{ char *str = new char; sprintf(str,"%s%s%s","E:\\DVR\\",fld.cFileName,"\\*.nvr"); printf("\n\nFOLDER: %s\n\n",str); hf1=FindFirstFile(str,&amp;fld1); do{ FILE *nvr; sprintf(name,"%s%s%s%s","E:\\DVR\\",fld.cFileName,"\\",fld1.cFileName); nvr=fopen(name,"rb"); name[strlen(name)-3]='2'; //   ,  name[strlen(name)-2]='6'; // ; name[strlen(name)-1]='4'; HANDLE out = openOutputFile(name); SetFilePointer(out, 4, NULL, FILE_BEGIN); //  "",  4      (  ); bl=0; N=fld1.nFileSizeLow/32-1; //   (); printf("\t%s\n\t%i Blocks\n\n",fld1.cFileName,N); for(bl=0;bl&lt;N;bl++){ //  ; fseek(nvr,40+32*bl,SEEK_SET); //; fread(&amp;pt,1,4,nvr); // ; copy(hdd,out,pt); //  ; } CloseHandle(out); fclose(nvr); }while(FindNextFile(hf1,&amp;fld1)); FindClose(hf1); delete str; }while(FindNextFile(hf,&amp;fld)); FindClose(hf); CloseHandle(hdd); system("PAUSE"); return 0; }</span></span></code> </pre><br>  Sur un vieil ordinateur √©quip√© d'un processeur Pentium 4 et d'un contr√¥leur PCI SATA, le programme a r√©ussi √† transf√©rer √† terme un disque dur complet avec plusieurs milliers de fichiers .264 en 7 heures en moyenne.  Sur un nouvel ordinateur - trois fois plus rapide.  Comme je l'ai d√©j√† not√©, le programme n'est pas universel, toutes les constantes et variables sont ajust√©es √† mon cas sp√©cifique du disque dur √† 1 To.  Cependant, vous pouvez travailler un peu plus et le rendre universel, dessinez une interface graphique. <br><br>  Dans la deuxi√®me partie de l'article, j'√©crirai comment ¬´faire soi-m√™me¬ª pour reconditionner du conteneur ¬´264¬ª vers le conteneur ¬´avi¬ª standard. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr421933/">https://habr.com/ru/post/fr421933/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr421923/index.html">Nous comprenons les m√©tiers du design</a></li>
<li><a href="../fr421925/index.html">Pr√©sentation de l'imprimante 3D Raise 3D Pro 2 Plus</a></li>
<li><a href="../fr421927/index.html">Pr√©sentation du smartphone General Mobile GM8 Go: un employ√© du budget turc avec Android 8.1 Oreo Go Edition</a></li>
<li><a href="../fr421929/index.html">Un an avant le Brexit: la Grande-Bretagne r√©sout le probl√®me des p√©nuries de main-d'≈ìuvre gr√¢ce √† la robotique</a></li>
<li><a href="../fr421931/index.html">Impact de la protection Spectre, Meltdown et Foreshadow sur les performances de Linux 4.19</a></li>
<li><a href="../fr421935/index.html">Premi√®res impressions de la transition d'Ubuntu 16.04 LTS √† Ubuntu 18.04 LTS</a></li>
<li><a href="../fr421937/index.html">Smart city inside - un coup d'≈ìil sur Huawei</a></li>
<li><a href="../fr421939/index.html">Utilisation de SQL dans Rails</a></li>
<li><a href="../fr421945/index.html">Google et Mastercard concluent un accord secret pour suivre les achats dans les magasins</a></li>
<li><a href="../fr421947/index.html">Bienvenue sur Android Devs Meetup le 8 septembre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>