<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👦 🥦 📸 Node.js身份验证指南，不包含password.js和第三方服务 🔨 📴 👱🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这篇文章的作者（我们今天将发表其翻译）说，现在您可以观察到身份验证服务（例如Google Firebase Authentication，AWS Cognito和Auth0）的日益普及。 通用解决方案（例如passport.js）已成为行业标准。 但是，鉴于当前的情况，开发人员从未完全了解身份验证系...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js身份验证指南，不包含password.js和第三方服务</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/457700/"> 这篇文章的作者（我们今天将发表其翻译）说，现在您可以观察到身份验证服务（例如Google Firebase Authentication，AWS Cognito和Auth0）的日益普及。 通用解决方案（例如passport.js）已成为行业标准。 但是，鉴于当前的情况，开发人员从未完全了解身份验证系统的操作涉及哪种机制已变得司空见惯。 <br><br> 本资料专门讨论在Node.js中组织用户身份验证的问题。 在其中的一个实际示例中，考虑了系统中用户注册的组织及其进入系统的组织。 它将引发诸如使用JWT技术和用户模拟的问题。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/8q/s0/uv/8qs0uvft-oqo_nmhu1vwlpf4rjw.jpeg"></a> <br><br> 另外，请注意<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该</a> GitHub存储库，其中包含Node.js项目的代码，本文提供了一些示例。 您可以将此存储库用作自己实验的基础。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">项目要求</font> </h2><br> 以下是我们将在此处处理的项目要求： <br><br><ul><li> 数据库将存在，其中将存储用户的电子邮件地址和密码（clientId和clientSecret或诸如私钥和公钥的组合）。 </li><li> 使用强大高效的加密算法对密码进行加密。 </li></ul><br> 在撰写本文时，我相信现有的加密算法中最好的就是Argon2。 我要求您不要使用简单的加密算法，例如SHA256，SHA512或MD5。 <br><br> 另外，我建议您看一下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这份</a>精彩的材料，在其中可以找到有关选择用于哈希密码的算法的详细信息。 <br><br><h2>  <font color="#3AC1EF">用户在系统中的注册</font> </h2><br> 在系统中创建新用户时，必须将其密码散列并存储在数据库中。 密码与电子邮件地址和有关用户的其他信息一起存储在数据库中（例如，其中可能包括用户配置文件，注册时间等）。 <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> argon2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'argon2'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{   public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> SignUp(email, password, name): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;any&gt; {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> passwordHashed = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> argon2.hash(password);     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.create({       <span class="hljs-attr"><span class="hljs-attr">password</span></span>: passwordHashed,       email,       name,     });     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       <span class="hljs-comment"><span class="hljs-comment">//    - !!!       user: {         email: userRecord.email,         name: userRecord.name,       },       }</span></span></code> </pre> <br> 用户帐户信息应类似于以下内容。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b3/df3/027/2b3df30272e36e256f719b93ddf1197c.jpg"></div><br>  <i><font color="#999999">使用Robo3T从MongoDB中检索的用户数据</font></i> <br><br><h2>  <font color="#3AC1EF">用户登录</font> </h2><br> 这是用户尝试登录时执行的操作的图。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/449/370/7e2/4493707e27d80de68619e12f8e7a8639.png"></div><br>  <i><font color="#999999">用户登录</font></i> <br><br> 用户登录时会发生以下情况： <br><br><ul><li> 客户端向服务器发送公共标识符和用户私钥的组合。 这通常是电子邮件地址和密码。 </li><li> 服务器通过电子邮件地址在数据库中搜索用户。 </li><li> 如果用户存在于数据库中，则服务器会对发送给它的密码进行哈希处理，然后将发生的情况与数据库中存储的密码哈希进行比较。 </li><li> 如果验证成功，则服务器将生成所谓的令牌或身份验证令牌-JSON Web令牌（JWT）。 </li></ul><br>  JWT是一个临时密钥。 客户端必须将此密钥连同对身份验证端点的每个请求一起发送给服务器。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> argon2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'argon2'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{  public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Login(email, password): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;any&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.findOne({ email });    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!userRecord) {      <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'User not found'</span></span>)    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> correctPassword = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> argon2.verify(userRecord.password, password);      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!correctPassword) {        <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Incorrect password'</span></span>)            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {      <span class="hljs-attr"><span class="hljs-attr">user</span></span>: {        <span class="hljs-attr"><span class="hljs-attr">email</span></span>: userRecord.email,        <span class="hljs-attr"><span class="hljs-attr">name</span></span>: userRecord.name,      },      <span class="hljs-attr"><span class="hljs-attr">token</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.generateJWT(userRecord),    }</code> </pre> <br> 使用argon2库执行密码验证。 这是为了防止所谓的“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">时间攻击</a> ”。 进行此类攻击时，攻击者会根据对服务器形成响应所需的时间进行分析，以蛮力破解密码。 <br><br> 现在让我们谈谈如何生成JWT。 <br><br><h2>  <font color="#3AC1EF">什么是JWT？</font> </h2><br>  JSON Web令牌（JWT）是以字符串形式编码的JSON对象。 令牌可以代替cookie，与cookie相比，它具有多个优点。 <br><br> 令牌由三部分组成。 这是报头，有效负载和签名。 下图显示了它的外观。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f16/a11/08d/f16a1108de7e0a5d8e4754725aacc830.jpg"></div><br>  <i><font color="#999999">重量</font></i> <br><br> 令牌数据可以在客户端进行解码，而无需使用密钥或签名。 <br><br> 例如，这对于传输令牌内编码的元数据很有用。 这样的元数据可以描述用户的角色，其个人资料，令牌的持续时间等。 它们可以用于前端应用程序。 <br><br> 这就是解码令牌的样子。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/734/5fa/3e57345fafedf8eaa0d326190aa03b47.jpg"></div><br>  <i><font color="#999999">解码令牌</font></i> <br><br><h2>  <font color="#3AC1EF">在Node.js中生成JWT</font> </h2><br> 让我们创建完成用户身份验证服务工作所需的<code>generateToken</code>函数。 <br><br> 您可以使用jsonwebtoken库创建JWT。 您可以在npm中找到该库。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> jwt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'jsonwebtoken'</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthService</span></span></span><span class="hljs-class"> </span></span>{  private generateToken(user) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = {      <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: user._id,      <span class="hljs-attr"><span class="hljs-attr">name</span></span>: user.name,      <span class="hljs-attr"><span class="hljs-attr">email</span></span>: user.email    };    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> signature = <span class="hljs-string"><span class="hljs-string">'MySuP3R_z3kr3t'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> expiration = <span class="hljs-string"><span class="hljs-string">'6h'</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jwt.sign({ data, }, signature, { <span class="hljs-attr"><span class="hljs-attr">expiresIn</span></span>: expiration }); }</code> </pre> <br> 这里最重要的是编码数据。 不要使用令牌发送秘密用户信息。 <br><br> 签名（这里是<code>signature</code>常量）是用于生成JWT的秘密数据。 确保签名不会落入他人之手非常重要。 如果签名遭到破坏，攻击者将能够代表用户生成令牌并窃取其会话。 <br><br><h2>  <font color="#3AC1EF">端点保护和JWT验证</font> </h2><br> 现在，客户端代码需要在每个请求中将JWT发送到安全端点。 <br><br> 建议您在请求标头中包含JWT。 它们通常包含在Authorization标头中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/4dd/19d/b5c4dd19dfd705c210c9b4f5ce5212cf.jpg"></div><br>  <i><font color="#999999">授权标题</font></i> <br><br> 现在，在服务器上，您需要创建作为快速路由中间件的代码。 将此代码放在<code>isAuth.ts</code>文件中： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> jwt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express-jwt'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      ,  JWT      Authorization,        req.body,    ,      ,     . const getTokenFromHeader = (req) =&gt; {  if (req.headers.authorization &amp;&amp; req.headers.authorization.split(' ')[0] === 'Bearer') {    return req.headers.authorization.split(' ')[1]; } export default jwt({  secret: 'MySuP3R_z3kr3t', //      ,     JWT  userProperty: 'token', //       ,     services/auth:generateToken -&gt; 'req.token'  getToken: getTokenFromHeader, //        })</span></span></code> </pre> <br> 能够从数据库中获取有关用户帐户的完整信息并将它们附加到请求是很有用的。 在我们的案例中，此功能是使用<code>attachCurrentUser.ts</code>文件中的中间件实现的。 这是它的简化代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (req, res, next) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> decodedTokenData = req.tokenData; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.findOne({ <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: decodedTokenData._id })  req.currentUser = userRecord; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!userRecord) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.status(<span class="hljs-number"><span class="hljs-number">401</span></span>).end(<span class="hljs-string"><span class="hljs-string">'User not found'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next(); }</code> </pre> <br> 实施此机制后，路由将能够接收有关正在执行请求的用户的信息： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> isAuth <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/isAuth'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> attachCurrentUser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/attachCurrentUser'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ItemsModel <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../models/items'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (app) =&gt; {    app.get(<span class="hljs-string"><span class="hljs-string">'/inventory/personal-items'</span></span>, isAuth, attachCurrentUser, (req, res) =&gt; {      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = req.currentUser;      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userItems = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ItemsModel.find({ <span class="hljs-attr"><span class="hljs-attr">owner</span></span>: user._id });      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.json(userItems).status(<span class="hljs-number"><span class="hljs-number">200</span></span>);    })</code> </pre> <br>  <code>inventory/personal-items</code>路线现已受到保护。 要访问它，用户必须具有有效的JWT。 此外，路由可以使用用户信息在数据库中搜索所需的信息。 <br><br><h2>  <font color="#3AC1EF">为什么令牌受到入侵者的保护？</font> </h2><br> 阅读有关使用JWT的信息后，您可能会问自己以下问题：“如果可以在客户端解码JWT数据，是否可以通过更改用户ID或其他数据的方式处理令牌？”。 <br><br> 令牌解码-操作非常简单。 但是，如果没有该签名，即在服务器上签名JWT时使用的秘密数据，则无法“重做”此令牌。 <br><br> 这就是为什么保护此敏感数据如此重要的原因。 <br><br> 我们的服务器在isAuth中间件中验证签名。  express-jwt库负责检查。 <br><br> 现在，在弄清楚了JWT技术的工作原理之后，让我们讨论一下它给我们带来的一些有趣的附加功能。 <br><br><h2>  <font color="#3AC1EF">如何假冒用户？</font> </h2><br> 用户模拟是一种用于在不知道其密码的情况下以特定用户身份登录系统的技术。 <br><br> 此功能对超级管理员，开发人员或支持人员非常有用。 模拟使他们能够解决仅在使用系统的用户过程中出现的问题。 <br><br> 您可以代表用户使用该应用程序，而无需知道他的密码。 为此，生成具有正确签名和描述用户的必要元数据的JWT就足够了。 <br><br> 创建一个端点，该端点可以以特定用户的名义生成用于进入系统的令牌。 只有系统的超级管理员可以使用此端点。 <br><br> 首先，我们需要为该用户分配一个比其他用户具有更高特权级别的角色。 这可以通过许多不同的方式来完成。 例如，只需将<code>role</code>字段添加到数据库中存储的用户信息中即可。 <br><br> 看起来可能如下图所示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/c19/30e/f69c1930ec89fdf649d73772cc7754bc.jpg"></div><br>  <i><font color="#999999">用户信息中的新字段</font></i> <br><br>  <code>super-admin</code> <code>role</code>字段的值是<code>super-admin</code> 。 <br><br> 接下来，您需要创建一个新的中间件来检查用户角色： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (requiredRole) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(req.currentUser.role === requiredRole) {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next();    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.status(<span class="hljs-number"><span class="hljs-number">401</span></span>).send(<span class="hljs-string"><span class="hljs-string">'Action not allowed'</span></span>);    }</code> </pre> <br> 它应该放在isAuth和attachCurrentUser之后。 现在创建端点，该端点为超级用户要登录的用户生成JWT： <br><br><pre> <code class="javascript hljs">  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> isAuth <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/isAuth'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> attachCurrentUser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlewares/attachCurrentUser'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> roleRequired <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../middlwares/roleRequired'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UserModel <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../models/user'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> (app) =&gt; {    app.post(<span class="hljs-string"><span class="hljs-string">'/auth/signin-as-user'</span></span>, isAuth, attachCurrentUser, roleRequired(<span class="hljs-string"><span class="hljs-string">'super-admin'</span></span>), (req, res) =&gt; {      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userEmail = req.body.email;      <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRecord = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> UserModel.findOne({ <span class="hljs-attr"><span class="hljs-attr">email</span></span>: userEmail });      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!userRecord) {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.status(<span class="hljs-number"><span class="hljs-number">404</span></span>).send(<span class="hljs-string"><span class="hljs-string">'User not found'</span></span>);           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res.json({        <span class="hljs-attr"><span class="hljs-attr">user</span></span>: {          <span class="hljs-attr"><span class="hljs-attr">email</span></span>: userRecord.email,          <span class="hljs-attr"><span class="hljs-attr">name</span></span>: userRecord.name        },        <span class="hljs-attr"><span class="hljs-attr">jwt</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.generateToken(userRecord)      })      .status(<span class="hljs-number"><span class="hljs-number">200</span></span>);    })</code> </pre> <br> 如您所见，没有什么神秘的东西。 超级管理员知道您要登录的用户的电子邮件地址。 上面代码的逻辑非常让人联想到代码的工作方式，为普通用户的系统提供了输入。 主要区别在于此处未检查密码。 <br> 由于此处根本不需要密码，因此此处未验证密码。 端点安全性由中间件提供。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 依赖第三方身份验证服务和库没有错。 这有助于开发人员节省时间。 但是他们还需要了解身份验证系统操作所基于的原理，以及确保此类系统运行的原理。 <br><br> 在本文中，我们探讨了JWT身份验证的可能性，并讨论了为哈希密码选择良好的加密算法的重要性。 我们研究了用户模拟机制的创建。 <br><br> 用password.js之类的东西做同样的事情远非易事。 身份验证是一个巨大的话题。 也许我们会回到她身边。 <br><br>  <b>亲爱的读者们！</b> 如何为Node.js项目创建身份验证系统？ <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN457700/">https://habr.com/ru/post/zh-CN457700/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN457690/index.html">来自Yandex.Money metap的偏执狂视频</a></li>
<li><a href="../zh-CN457692/index.html">关于国家NB-Fi标准和计费系统的思考</a></li>
<li><a href="../zh-CN457694/index.html">使用多字符常量的危险</a></li>
<li><a href="../zh-CN457696/index.html">使用多字符常量的危险</a></li>
<li><a href="../zh-CN457698/index.html">实验：我们使用代理作为抵御DoS攻击的工具</a></li>
<li><a href="../zh-CN457702/index.html">使用KOMPAS-3D API→第16课→控制字符</a></li>
<li><a href="../zh-CN457704/index.html">GPU如何处理分支</a></li>
<li><a href="../zh-CN457706/index.html">机器人测试SAP ERP</a></li>
<li><a href="../zh-CN457710/index.html">神经网络的惊人功能2019</a></li>
<li><a href="../zh-CN457712/index.html">Verizon和BGP Optimizer如何离线设置</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>