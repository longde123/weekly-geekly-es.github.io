<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§šğŸ¾ â¤µï¸ ğŸ‘©ğŸ»â€ğŸ« 2 life hacks: alternatif pencarian klasik di Microsoft SQL Server ğŸ‘´ğŸ½ ğŸ˜ ğŸ‘¨ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Teman-teman kami dari Softpoint telah menyiapkan artikel menarik tentang Microsoft SQL Server. Ini mem-parsing dua contoh praktis mengguna...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>2 life hacks: alternatif pencarian klasik di Microsoft SQL Server</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/470139/">  Halo, Habr!  Teman-teman kami dari Softpoint telah menyiapkan artikel menarik tentang Microsoft SQL Server.  Ini mem-parsing dua contoh praktis menggunakan pencarian teks lengkap: <br><br><ul><li>  Cari di baris "tak terbatas" (mis. Komentar) sebagai lawan dari pencarian reguler melalui LIKE; </li><li>  Cari berdasarkan nomor dokumen dengan awalan.  Di mana biasanya pencarian teks lengkap tidak dapat digunakan: awalan konstan mengganggu itu.  2 pendekatan dianalisis: preprocessing nomor dokumen dan menambahkan library-word breaker Anda sendiri. </li></ul><br>  Bergabunglah sekarang! <br><br><img src="https://habrastorage.org/webt/cj/iu/to/cjiutotj7eknpw4cyapmoqw3yys.png"><a name="habracut"></a><br><br>  <i>Saya memberikan lantai kepada penulis</i> <br><br>  Pencarian efektif dalam gigabytes data yang terakumulasi adalah semacam "cawan suci" dari sistem akuntansi.  Semua orang ingin menemukannya dan mendapatkan kemuliaan abadi, tetapi dalam proses pencarian berulang kali ternyata tidak ada solusi ajaib yang tunggal. <br><br>  Situasi ini diperumit oleh fakta bahwa pengguna biasanya ingin mencari substring - di suatu tempat ternyata nomor kontrak yang diinginkan "dikubur" di tengah komentar;  di suatu tempat, operator tidak ingat persis nama klien, tetapi dia ingat bahwa namanya adalah "Alexey Evgrafovich";  di suatu tempat, Anda hanya perlu menghilangkan bentuk kepemilikan berulang BYUBL dan segera mencari dengan nama organisasi.  Untuk DBMS relasional klasik, pencarian semacam itu adalah berita yang sangat buruk.  Paling sering, pencarian substring seperti itu dikurangi menjadi pengguliran metodis dari setiap baris tabel.  Bukan strategi yang paling efektif, terutama jika ukuran tabel tumbuh hingga beberapa puluh gigabytes. <br><br>  Dalam mencari alternatif, saya sering mengingat "pencarian teks lengkap".  Kegembiraan menemukan solusi biasanya berlalu dengan cepat setelah tinjauan singkat dari praktik yang ada.  Ternyata dengan cepat, menurut pendapat populer, pencarian teks lengkap: <br><br><ul><li>  Sulit dikonfigurasikan </li><li>  Diperbarui secara perlahan </li><li>  Menggantung sistem saat memperbarui </li><li> Memiliki semacam sintaks yang tidak biasa <s>bodoh</s> </li><li>  Tidak menemukan apa yang mereka minta </li></ul><br>  Seperangkat mitos dapat berlanjut untuk waktu yang lama, tetapi bahkan Plato mengajarkan kita untuk menjadi skeptis dan tidak secara buta menerima pendapat orang lain tentang iman.  Mari kita lihat apakah iblis begitu mengerikan saat ia dilukis? <br><br>  Dan, sementara kita tidak tenggelam dalam penelitian ini, kita akan <b>langsung menyetujui kondisi penting</b> .  Mesin pencarian teks lengkap dapat melakukan lebih dari sekadar pencarian string biasa.  Misalnya, Anda dapat menentukan kamus sinonim dan menggunakan kata "kontak" untuk menemukan "telepon".  Atau cari kata-kata tanpa memperhatikan bentuk dan akhir.  Opsi ini bisa sangat berguna bagi pengguna, tetapi dalam artikel ini kami menganggap pencarian teks lengkap hanya sebagai alternatif dari pencarian baris klasik.  Artinya, <b>kami hanya akan mencari substring yang akan ditentukan di bilah pencarian</b> , tanpa mempertimbangkan sinonim akun, tanpa membawa kata-kata ke bentuk "normal" dan sihir lainnya. <br><br><h2>  Cara Kerja Pencarian Teks Lengkap MS SQL </h2><br>  Fungsionalitas pencarian teks lengkap dalam MS SQL telah dihapus sebagian dari layanan DBMS utama (di dekat akhir artikel kita akan melihat mengapa ini bisa sangat berguna).  Untuk pencarian, indeks khusus dibentuk dengan strukturnya, tidak seperti pohon seimbang biasa. <br><br>  Adalah penting bahwa untuk membuat indeks pencarian teks lengkap, penting bahwa indeks unik ada di tabel kunci, yang terdiri dari hanya satu kolom - itu adalah pencarian teks lengkap yang akan digunakan untuk mengidentifikasi baris tabel.  Seringkali tabel sudah memiliki indeks seperti pada Kunci Utama, tetapi kadang-kadang harus dibuat tambahan. <br><br>  Indeks pencarian teks lengkap diisi secara asinkron dan keluar dari transaksi.  Setelah mengubah satu baris tabel, itu antri untuk diproses.  Proses memperbarui indeks menerima dari baris tabel (baris) semua nilai string, "berlangganan" ke indeks, dan memecahnya menjadi kata-kata terpisah.  Setelah ini, kata-kata dapat direduksi menjadi bentuk "standar" tertentu (misalnya, tanpa akhir), sehingga lebih mudah untuk mencari berdasarkan bentuk kata.  "Stop words" dibuang (kata depan, artikel, dan kata-kata lain yang tidak memiliki makna).  Tautan kata-ke-string yang tersisa cocok dengan indeks pencarian teks lengkap. <br><br>  Ternyata setiap kolom dari tabel yang termasuk dalam indeks melewati pipa seperti itu: <br><br>  Garis panjang -&gt; wordbreaker -&gt; set bagian (kata) -&gt; stemmer -&gt; kata yang dinormalisasi -&gt; [opsional] berhenti pengecualian kata -&gt; tulis untuk mengindeks <br><br>  Seperti disebutkan, proses pembaruan indeks asinkron.  Berikut dari ini: <br><br><ol><li>  Pembaruan tidak memblokir tindakan pengguna </li><li>  Pembaruan menunggu selesainya transaksi perubahan baris dan mulai menerapkan perubahan tidak lebih awal dari komit </li><li>  Perubahan pada indeks teks lengkap diterapkan dengan beberapa penundaan relatif terhadap transaksi utama.  Yaitu, antara menambahkan baris dan saat ketika dapat ditemukan, akan ada penundaan tergantung pada panjang antrian pembaruan indeks </li><li>  Jumlah elemen yang terkandung dalam indeks dapat dipantau oleh kueri: </li></ol><br><pre><code class="cs hljs">SELECT cat.name, FULLTEXTCATALOGPROPERTY(cat.name,<span class="hljs-string"><span class="hljs-string">'ItemCount'</span></span>) AS [ItemCount] FROM sys.fulltext_catalogs AS cat</code> </pre> <br><h2>  Tes praktis.  Cari fisik  orang dengan nama </h2><br><h4>  Mengisi tabel dengan data </h4><br>  Untuk percobaan, kami akan membuat basis kosong baru dengan satu tabel tempat "rekanan" akan disimpan.  Di dalam bidang "deskripsi" akan ada garis dengan nama kontrak, di mana nama rekanan akan disebutkan.  Sesuatu seperti ini: <br><br>  "Kontrak dengan Borovik Demyan Emelyanovich" <br><br>  Atau lebih: <br><br>  "Anjing.  dengan Borovik-Romanov Anatoly Avdeevich " <br><br>  Ya, saya ingin memotret diri sendiri langsung dari "arsitektur" seperti itu, tetapi, sayangnya, aplikasi "komentar" atau "deskripsi" seperti itu sering di antara pengguna bisnis. <br><br>  Selain itu, kami menambahkan beberapa bidang "untuk berat": jika hanya ada 2 kolom dalam tabel, pemindaian sederhana akan membacanya dalam beberapa saat.  Kita perlu "mengembang" tabel agar pemindaian panjang.  Ini membawa kita lebih dekat ke kasus bisnis nyata: kita tidak hanya menyimpan "deskripsi" dalam tabel, tetapi juga banyak informasi berguna [iblis] lainnya. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">create table </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partners</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id bigint identity (</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) not </span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-literal">null</span></span></span><span class="hljs-function">, [description] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nvarchar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">max</span></span></span><span class="hljs-function">), [address] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nvarchar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">256</span></span></span></span></span><span class="hljs-function">) not </span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-literal">null</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> N'107240, ,  ., 168', [phone] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nvarchar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">256</span></span></span></span></span><span class="hljs-function">) not </span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-literal">null</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> N'+7 (</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">495</span></span></span></span></span><span class="hljs-function">) 111-222-33', [contact_name] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nvarchar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">256</span></span></span></span></span><span class="hljs-function">) not </span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-literal">null</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> N'', [bio] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nvarchar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2048</span></span></span></span></span><span class="hljs-function">) not </span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-literal">null</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> N'     . , ,  .  ,    .        ,     .   ,  , ,       ,  .    . ,    ,   .       ,  ,            .       ,    ,     , .          ,   ,   .       .    .') --  ,    ..       </span></span></code> </pre> <br><br>  Pertanyaan selanjutnya adalah di mana bisa mendapatkan begitu banyak nama belakang unik, nama depan, dan patronimik?  Saya, menurut kebiasaan lama, bertindak sebagai siswa Rusia yang normal, yaitu  pergi ke wikipedia: <br><br><ul><li>  Nama diambil dari halaman Kategori: Nama pria Rusia </li><li>  Menulis ulang nama tengah secara manual dari nama, mengubah ujung </li><li>  Dengan nama keluarga itu ternyata sedikit lebih rumit.  Pada akhirnya, kategori "namesakes" ditemukan.  Sedikit perdukunan dengan Python dan di meja terpisah ternyata 46,5 ribu nama.  (skrip untuk mengunduh nama keluarga tersedia di sini) </li></ul><br>  Tentu saja, ada variasi aneh di antara nama keluarga, tetapi untuk tujuan penelitian ini cukup dapat diterima. <br><br><img src="https://habrastorage.org/webt/0z/to/16/0zto16d8rkkkygbiuqvdorvlxdc.png"><br><br>  Saya menulis skrip sql yang melampirkan nomor acak nama dan patronimik untuk setiap nama belakang.  5 menit menunggu dan di meja terpisah sudah ada 4,5 juta kombinasi.  Tidak buruk!  Untuk setiap nama keluarga ada 20 hingga 231 kombinasi nama + nama tengah, rata-rata 97 kombinasi diperoleh.  Distribusi berdasarkan nama dan patronimik ternyata sedikit bias â€œke kiri,â€ tetapi tampaknya berlebihan untuk menghasilkan algoritma yang lebih seimbang. <br><br><img src="https://habrastorage.org/webt/lb/yx/ug/lbyxugz2sjsri9uw7bi7rzornl4.png"><br><br>  Data sudah disiapkan, kita bisa memulai eksperimen kita. <br><br><h4>  Pengaturan Pencarian Teks Lengkap </h4><br>  Buat indeks teks lengkap di tingkat MS SQL.  Pertama, kita perlu membuat repositori untuk indeks ini - katalog teks lengkap. <br><br><pre> <code class="cs hljs">USE [like_vs_fulltext] GO CREATE FULLTEXT CATALOG [basic_ftc] WITH ACCENT_SENSITIVITY = OFF AS DEFAULT AUTHORIZATION [dbo] GO</code> </pre> <br>  Ada katalog, kami mencoba menambahkan indeks teks lengkap untuk tabel kami ... dan tidak ada yang berhasil. <br><br><img src="https://habrastorage.org/webt/-v/rd/ge/-vrdge8hjpp_c8pgt4j3imsmks4.png"><br><br>  Seperti yang saya katakan, untuk indeks teks lengkap Anda memerlukan indeks reguler dengan satu kolom unik.  Kami ingat bahwa kami sudah memiliki bidang yang diperlukan - id pengidentifikasi unik.  Mari kita buat indeks cluster unik di atasnya (meskipun yang tidak tercakup akan cukup): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">create unique clustered index ndx1 </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partners</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  Setelah membuat indeks baru, kami akhirnya dapat menambahkan indeks pencarian teks lengkap.  Mari kita tunggu beberapa menit sampai indeks penuh (ingat bahwa itu diperbarui secara tidak sinkron!).  Anda dapat melanjutkan ke tes. <br><br><h4>  Pengujian </h4><br>  Mari kita mulai dengan skenario paling sederhana, dekat dengan aplikasi sebenarnya dari pencarian.  Kami mensimulasikan "tampilan daftar" - pilihan jendela 45 baris dengan pemilihan berdasarkan topeng pencarian.  Kami mengeksekusi permintaan dengan indeks teks lengkap baru, kami mencatat waktu - 0 detik - luar biasa! <br><br><img src="https://habrastorage.org/webt/m8/ci/bk/m8cibkgbrwb2xkruwbspp3axfgk.png"><br><br>  Sekarang pencarian lama dan terbukti melalui "suka".  Butuh 3 detik untuk membentuk hasilnya.  Tidak terlalu buruk, kekalahan total tidak berhasil.  Mungkin saat itu tidak masuk akal untuk mengatur pencarian teks lengkap - apakah semuanya bekerja dengan baik? <br><br><img src="https://habrastorage.org/webt/bl/gr/hl/blgrhlafampbhbssctycbcweuis.png"><br><br>  Bahkan, kami melewatkan satu detail penting: permintaan dieksekusi tanpa penyortiran.  Pertama, permintaan seperti itu dipasangkan dengan "memilih catatan N pertama" mengembalikan hasil yang tidak beralasan.  Setiap awal dapat mengembalikan catatan N acak dan tidak ada jaminan bahwa dua mulai berturut-turut akan memberikan kumpulan data yang sama.  Kedua, jika kita berbicara tentang "melihat daftar dengan jendela geser" - biasanya "jendela" ini diurutkan berdasarkan kolom mana saja, misalnya, dengan nama.  Lagi pula, operator perlu tahu apa yang akan ia dapatkan ketika ia pindah ke "jendela" berikutnya. <br><br>  Perbaiki eksperimen.  Tambahkan penyortiran, katakanlah, dengan nomor telepon: <br><br><img src="https://habrastorage.org/webt/tc/n-/i9/tcn-i9py1gxkrbrl927ygqqyudq.png"><br><br>  <b>Pencarian teks lengkap menang dengan skor memekakkan: 0 detik versus 172 detik!</b> <br><br>  Jika Anda melihat rencana kueri, menjadi jelas mengapa demikian.  Karena penambahan pemesanan ke teks kueri, operasi pengurutan muncul selama eksekusi.  Ini adalah operasi yang disebut "pemblokiran", yang tidak dapat menyelesaikan permintaan sampai menerima seluruh jumlah data untuk disortir.  Kami tidak dapat mengambil 45 catatan pertama yang kami miliki, kami perlu mengurutkan seluruh kumpulan data. <br><br>  Dan pada tahap memperoleh data untuk disortir, perbedaan dramatis terjadi.  Pencarian dengan "suka" harus menelusuri seluruh tabel yang tersedia.  Ini membutuhkan 172 detik.  Tetapi pencarian teks lengkap memiliki struktur yang dioptimalkan sendiri, yang segera mengembalikan tautan ke semua entri yang diperlukan. <br><br><img src="https://habrastorage.org/webt/gq/nu/fw/gqnufwndwjmo5skv5_uq6ewvdkc.png"><br><br><img src="https://habrastorage.org/webt/uv/ew/c9/uvewc93qvfchgagsclaqi55hvt8.png"><br><br>  Tetapi apakah harus ada lalat di salep?  Ada satu.  Seperti yang dinyatakan di awal, pencarian teks lengkap hanya dapat mencari dari awal kata.  Dan jika kita ingin menemukan "Ivan Poddubny" oleh substring "* oak *", pencarian teks lengkap tidak akan menunjukkan sesuatu yang berguna. <br><br>  Untungnya, untuk mencari berdasarkan nama, ini bukan skenario paling populer. <br><br><h4>  Cari dokumen berdasarkan nomor </h4><br>  Mari kita coba sesuatu yang lebih rumit.  Kasus penggunaan populer kedua untuk mencari adalah menemukan dokumen berdasarkan bagian dari nomornya.  Selain itu, seringkali nomor dokumen terdiri dari dua bagian: awalan huruf dan angka aktual yang mengandung angka nol di depan. <br><br>  Tidak ada spasi atau karakter layanan di antara bagian-bagian ini.  Pada saat yang sama, mencari dengan angka penuh sangat merepotkan - Anda harus ingat berapa banyak angka nol di depan setelah awalan harus sebelum bagian awal yang penting.  Ternyata pencarian teks lengkap "out of the box" sama sekali tidak berguna dalam skenario seperti itu.  Mari kita coba memperbaikinya. <br><br>  Untuk pengujian, saya membuat tabel baru yang disebut dokumen, di mana saya menambahkan 13,5 juta catatan dengan nomor unik dari tipe "ORG".  Penomoran berjalan berurutan, semua angka dimulai dengan "ORG".  Anda bisa mulai. <br><br><h4>  Pra-pemisahan nomor </h4><br>  Pencarian teks lengkap dapat secara efisien mencari kata-kata.  Nah, mari kita bantu dia dan memecah nomor "tidak nyaman" menjadi kata-kata yang nyaman di muka.  Rencana tindakan adalah sebagai berikut: <br><br><ol><li>  Tambahkan kolom tambahan ke tabel sumber tempat nomor yang dikonversi secara khusus akan disimpan </li><li>  Tambahkan pemicu, yang ketika mengubah nomor akan memecahnya menjadi beberapa bagian kecil, dipisahkan oleh spasi </li><li>  Pencarian teks lengkap sudah tahu cara membagi string menjadi bagian-bagian dengan spasi, sehingga akan mengindeks nomor yang dimodifikasi tanpa masalah </li></ol><br>  Mari kita lihat bagaimana ini akan bekerja. <br><br>  Tambahkan kolom tambahan ke tabel. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">alter table document </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">add</span></span></span><span class="hljs-function"> number_parts </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nvarchar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">128</span></span></span></span></span><span class="hljs-function">) not </span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-literal">null</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> ''</span></span></code> </pre> <br>  Pemicu yang mengisi kolom baru dapat ditulis "dahi", mengabaikan kemungkinan duplikat (berapa kali lipat tiga kali lipat dalam angka "0000012"?) Dan Anda dapat menambahkan beberapa sihir XML dan merekam hanya bagian-bagian unik.  Implementasi pertama akan lebih cepat, yang kedua akan memberikan hasil yang lebih kompak.  Bahkan, pilihannya adalah antara kecepatan menulis dan kecepatan membaca, pilih apa yang lebih penting dalam situasi Anda.  Sekarang cukup gunakan <a href="">skrip</a> yang memproses angka yang ada. <br><br><img src="https://habrastorage.org/webt/jh/su/yi/jhsuyix1k3vmyz-m4_2lit8mn0c.png"><br><br>  Tambahkan indeks teks lengkap <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">create fulltext index </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">document</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">number_parts</span></span></span><span class="hljs-function">) key index ndx1 with change_tracking</span></span> = Auto</code> </pre> <br>  Dan periksa hasilnya.  Eksperimennya sama - memodelkan pilihan "jendela" dari daftar dokumen.  Kami tidak mengulangi kesalahan sebelumnya dan segera menjalankan permintaan dengan penyortiran, dalam hal ini berdasarkan tanggal. <br><br><img src="https://habrastorage.org/webt/2a/mc/aq/2amcaqolncb-oewf7l9dfivqstq.png"><br><br>  Itu berhasil!  Sekarang mari kita coba nomor yang lebih otentik: <br><br><img src="https://habrastorage.org/webt/fe/a4/k9/fea4k9kc2isour1u-jkv5fla1pm.png"><br><br>  Dan kemudian misfire terjadi.  Panjang string pencarian lebih panjang dari panjang "kata" yang disimpan.  Faktanya, basis data pencarian tidak memiliki satu baris pun dari 4 karakter, sehingga dengan jujur â€‹â€‹mengembalikan hasil yang kosong.  Kami harus mengalahkan string pencarian menjadi beberapa bagian: <br><br><img src="https://habrastorage.org/webt/0z/tv/sy/0ztvsyfiijs2wuzppnutvugt-dy.png"><br><br>  Hal lain!  Kami lagi memiliki pencarian cepat.  Ya, ia membebankan biaya overhead pada pemeliharaan, tetapi hasilnya ratusan kali lebih cepat daripada pencarian klasik.  Kami mencatat upaya yang dihitung, tetapi cobalah untuk menyederhanakan pemeliharaan entah bagaimana - di bagian selanjutnya. <br><br><h4>  Kami akan memecahnya menjadi kata-kata dengan cara kita sendiri! </h4><br>  Sebenarnya, siapa yang mengatakan bahwa kata-kata harus dipisahkan dengan spasi?  Mungkin saya ingin nol di antara kata-kata!  (dan, jika mungkin, awalan sehingga itu juga entah bagaimana diabaikan dan tidak mengganggu langkah kaki).  Secara umum, tidak ada yang mustahil dalam hal ini.  Mari kita ingat skema operasi pencarian teks lengkap dari awal artikel - komponen terpisah, wordbreaker, bertanggung jawab untuk membobol kata-kata, dan, untungnya, Microsoft memungkinkan Anda untuk menerapkan "pemecah kata" Anda sendiri. <br><br>  Dan di sini yang menarik dimulai.  Wordbreaker adalah dll terpisah yang menghubungkan ke mesin pencarian teks lengkap.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi resmi</a> mengatakan bahwa membuat perpustakaan ini sangat sederhana - cukup terapkan antarmuka IWordBreaker.  Dan berikut adalah beberapa daftar inisialisasi singkat di C ++.  Sangat berhasil, saya baru saja menemukan tutorial yang sesuai! <br><br><img src="https://habrastorage.org/webt/48/vk/hh/48vkhhkmxbga2tnxudfiktk2c4k.png">  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber</a> ) <br><br>  Serius, dokumentasi untuk membuat pemecah masalah Anda sendiri di Internet semakin kecil.  Contoh dan templat yang lebih sedikit.  Tapi saya masih menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek</a> orang baik yang menulis di C ++ implementasi yang memecah kata-kata bukan oleh pemisah, tetapi hanya dengan tiga kali lipat (ya, seperti di bagian sebelumnya!) Selain itu, folder proyek sudah berisi biner yang disusun dengan hati-hati, yang hanya Anda perlukan terhubung ke mesin pencari. <br><br>  Cukup mencolokkan ... Sebenarnya tidak terlalu mudah.  Mari kita ikuti langkah-langkahnya: <br><br>  Anda perlu menyalin pustaka ke folder dengan SQL Server: <br><br><img src="https://habrastorage.org/webt/oy/tj/wk/oytjwkzpv1b8mo6uvysgipl7fq0.png"><br><br>  Daftarkan "bahasa" baru dalam pencarian teks lengkap <br><br><pre> <code class="cs hljs">exec master.dbo.xp_instance_regwrite <span class="hljs-string"><span class="hljs-string">'HKEY_LOCAL_MACHINE'</span></span>, <span class="hljs-string"><span class="hljs-string">'SOFTWARE\Microsoft\MSSQLSERVER\MSSearch\CLSID\{d225281a-7ca9-4a46-ae7d-c63a9d4815d4}'</span></span>, <span class="hljs-string"><span class="hljs-string">'DefaultData'</span></span>, <span class="hljs-string"><span class="hljs-string">'REG_SZ'</span></span>, <span class="hljs-string"><span class="hljs-string">'sqlngram.dll'</span></span> exec master.dbo.xp_instance_regwrite <span class="hljs-string"><span class="hljs-string">'HKEY_LOCAL_MACHINE'</span></span>, <span class="hljs-string"><span class="hljs-string">'SOFTWARE\Microsoft\MSSQLSERVER\MSSearch\CLSID\{0a275611-aa4d-4b39-8290-4baf77703f55}'</span></span>, <span class="hljs-string"><span class="hljs-string">'DefaultData'</span></span>, <span class="hljs-string"><span class="hljs-string">'REG_SZ'</span></span>, <span class="hljs-string"><span class="hljs-string">'sqlngram.dll'</span></span> exec master.dbo.xp_instance_regwrite <span class="hljs-string"><span class="hljs-string">'HKEY_LOCAL_MACHINE'</span></span>, <span class="hljs-string"><span class="hljs-string">'SOFTWARE\Microsoft\MSSQLSERVER\MSSearch\Language\ngram'</span></span>, <span class="hljs-string"><span class="hljs-string">'Locale'</span></span>, <span class="hljs-string"><span class="hljs-string">'REG_DWORD'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> exec master.dbo.xp_instance_regwrite <span class="hljs-string"><span class="hljs-string">'HKEY_LOCAL_MACHINE'</span></span>, <span class="hljs-string"><span class="hljs-string">'SOFTWARE\Microsoft\MSSQLSERVER\MSSearch\Language\ngram'</span></span>, <span class="hljs-string"><span class="hljs-string">'WBreakerClass'</span></span>, <span class="hljs-string"><span class="hljs-string">'REG_SZ'</span></span>, <span class="hljs-string"><span class="hljs-string">'{d225281a-7ca9-4a46-ae7d-c63a9d4815d4}'</span></span> exec master.dbo.xp_instance_regwrite <span class="hljs-string"><span class="hljs-string">'HKEY_LOCAL_MACHINE'</span></span>, <span class="hljs-string"><span class="hljs-string">'SOFTWARE\Microsoft\MSSQLSERVER\MSSearch\Language\ngram'</span></span>, <span class="hljs-string"><span class="hljs-string">'StemmerClass'</span></span>, <span class="hljs-string"><span class="hljs-string">'REG_SZ'</span></span>, <span class="hljs-string"><span class="hljs-string">'{0a275611-aa4d-4b39-8290-4baf77703f55}'</span></span> exec sp_fulltext_service <span class="hljs-string"><span class="hljs-string">'verify_signature'</span></span> , <span class="hljs-number"><span class="hljs-number">0</span></span>; exec sp_fulltext_service <span class="hljs-string"><span class="hljs-string">'update_languages'</span></span>; exec sp_fulltext_service <span class="hljs-string"><span class="hljs-string">'restart_all_fdhosts'</span></span>; exec sp_help_fulltext_system_components <span class="hljs-string"><span class="hljs-string">'wordbreaker'</span></span>;</code> </pre> <br>  Secara manual mengedit beberapa kunci dalam registri (penulis akan mengotomatiskan proses, tetapi tidak ada berita sejak 2016. Namun, ini awalnya merupakan "contoh implementasi", terima kasih untuk itu juga) <br><br><img src="https://habrastorage.org/webt/dx/yd/iq/dxydiqkbefi03iseanfv_tzfcii.png"><br><br>  Langkah-langkahnya dijelaskan secara rinci di halaman proyek. <br><br>  Selesai  Mari kita hapus indeks teks lengkap lama, karena tidak ada dua indeks teks lengkap untuk satu tabel.  Buat yang baru dan indeks nomor dokumen kami.  Sebagai kolom kunci, kami menunjukkan angka-angka itu sendiri, tidak ada lagi kolom pra-patah pengganti yang diperlukan.  Pastikan untuk menentukan "nomor bahasa 1" untuk menggunakan wordbreaker yang baru diinstal. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">drop fulltext index </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">on</span></span></span><span class="hljs-function"> document go create fulltext index </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">on</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">document</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">number Language </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) key index ndx1 with change_tracking</span></span> = Auto</code> </pre> <br>  Periksa? <br><br><img src="https://habrastorage.org/webt/1p/se/zz/1psezzovwm3mnoweyyfkpoo6o34.png"><br><br>  Itu berhasil!  Ini bekerja secepat semua contoh yang dibahas di atas. <br><br>  Mari kita periksa garis panjang di mana opsi sebelumnya tersandung: <br><br><img src="https://habrastorage.org/webt/iq/to/n8/iqton8zugajg5e85tcaieenab7k.png"><br><br>  Pencarian berfungsi secara transparan untuk pengguna dan pemrogram.  Wordbreaker secara terpisah memecah string pencarian menjadi beberapa bagian dan menemukan hasil yang diinginkan. <br><br>  Ternyata sekarang kita tidak perlu kolom dan pemicu tambahan, yaitu solusinya lebih sederhana (baca: lebih dapat diandalkan) daripada upaya kami sebelumnya.  Nah, dalam hal dukungan, implementasi seperti itu lebih sederhana dan lebih transparan, ada sedikit kemungkinan kesalahan. <br><br>  Jadi, hentikan, saya bilang "lebih bisa diandalkan"?  Kami baru saja menghubungkan beberapa perpustakaan pihak ketiga ke DBMS kami!  Dan apa yang akan terjadi jika dia jatuh?  Bahkan secara tidak sengaja menyeret seluruh layanan basis data! <br><br>  Di sini Anda perlu mengingat bagaimana pada awal artikel saya menyebutkan layanan pencarian teks lengkap, terpisah dari proses DBMS utama.  Di sinilah menjadi jelas mengapa ini penting.  Perpustakaan terhubung ke layanan pengindeksan teks lengkap, yang dapat beroperasi dengan hak berkurang.  Dan, yang lebih penting, jika komponen pihak ketiga jatuh, hanya layanan pengindeksan akan jatuh.  Pencarian akan berhenti untuk sementara waktu (tetapi sudah tidak sinkron), dan mesin basis data akan terus bekerja seolah-olah tidak ada yang terjadi. <br><br>  Untuk meringkas.  Menambahkan wordbreaker Anda sendiri bisa menjadi tantangan.  Tetapi ketika bermain "dalam jangka panjang", upaya ini membuahkan hasil dengan fleksibilitas yang lebih besar dan kemudahan perawatan.  Pilihan, seperti biasa, adalah milikmu. <br><br><h2>  Mengapa semua ini perlu? </h2><br>  Seorang pembaca yang ingin tahu mungkin bertanya-tanya lebih dari sekali: "semua ini bagus, tetapi bagaimana saya bisa menggunakan fitur ini jika saya tidak dapat mengubah permintaan pencarian dari aplikasi saya?"  Pertanyaan yang masuk akal  Dimasukkannya teks pencarian MS SQL penuh membutuhkan perubahan sintaks dari query, dan seringkali ini tidak mungkin dalam arsitektur yang ada. <br><br>  Anda dapat mencoba mengelabui aplikasi dengan "menyelipkan" fungsi bernilai-tabel dengan nama yang sama dan bukan tabel biasa, yang sudah akan melakukan pencarian seperti yang kita inginkan.  Anda dapat mencoba mengikat pencarian sebagai semacam sumber data eksternal.  Ada solusi lain - Softpoint Data Cluster - layanan khusus yang menginstal "penerusan" antara aplikasi sumber dan layanan SQL Server, mendengarkan lalu lintas dan dapat mengubah permintaan "dengan cepat" sesuai dengan aturan khusus.  Dengan menggunakan aturan ini, kami dapat menemukan kueri reguler dengan LIKE dan mengonversinya menjadi WADAH dengan pencarian teks lengkap. <br><br>  Mengapa kesulitan seperti itu?  Namun, kecepatan pencariannya sangat menawan.  Dalam sistem yang sarat muatan, di mana operator sering mencari catatan dalam jutaan tabel, kecepatan respons sangat penting.  Menghemat waktu pada operasi yang paling sering menghasilkan puluhan aplikasi tambahan yang diproses, dan ini adalah uang sungguhan, yang membuat bisnis senang.  Pada akhirnya, beberapa hari atau bahkan berminggu-minggu untuk mempelajari dan mengimplementasikan teknologi akan terbayar dengan peningkatan efisiensi operator. <br><br>  Semua skrip yang disebutkan dalam artikel tersedia di repositori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/frrrost/mssql_fulltext</a> <br><br><h2>  Tentang penulis </h2><br><img src="https://habrastorage.org/webt/xh/rm/q5/xhrmq5imxl5i7n9cp6lfjejy9w8.png" align="left" width="120">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alexander Denisov</a> - Analis Kinerja Database MS SQL Server.  Selama 6 tahun terakhir, sebagai bagian dari tim Softpoint, saya telah membantu menemukan kemacetan dalam permintaan orang lain dan memanfaatkan basis data klien sebaik-baiknya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470139/">https://habr.com/ru/post/id470139/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470125/index.html">Jangan menilai kode orang lain dengan ketat</a></li>
<li><a href="../id470127/index.html">Komposer dengan memori jangka pendek yang panjang</a></li>
<li><a href="../id470129/index.html">Manajemen memori deklaratif</a></li>
<li><a href="../id470133/index.html">Cara mengumpulkan metrik yang tidak terdistorsi berdasarkan referensi waktu dengan Prometheus</a></li>
<li><a href="../id470135/index.html">Aplikasi web interaktif tanpa pemrograman? Mudah! Mavo di tangan Anda</a></li>
<li><a href="../id470145/index.html">â€œWaspadalah, FAS!â€: Apa bahaya ID militer dalam periklanan, mengapa penting untuk mengetahui matematika dan apakah kebenaran telanjang selalu dibutuhkan</a></li>
<li><a href="../id470149/index.html">Tidak akan ada koleksi abadi di Jawa - baik sekarang maupun selamanya</a></li>
<li><a href="../id470153/index.html">Kamus Model Data</a></li>
<li><a href="../id470155/index.html">Fitur pengenalan pola nasional</a></li>
<li><a href="../id470159/index.html">Generasi Perdana</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>