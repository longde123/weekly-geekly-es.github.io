<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐤 🐰 ➖ Perkenalkan Analisis Statis dalam Prosesnya, Jangan Hanya Mencari Bug dengannya 🎳 🐜 🤕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini adalah terjemahan resmi dari pos asli . Terjemahan dibuat dengan bantuan orang-orang dari PVS-Studio. Terima kasih kawan! 

 Apa yang mend...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perkenalkan Analisis Statis dalam Prosesnya, Jangan Hanya Mencari Bug dengannya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440610/"> <i>Artikel ini adalah terjemahan resmi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pos asli</a> .</i>  <i>Terjemahan dibuat dengan bantuan orang-orang dari PVS-Studio.</i>  <i>Terima kasih kawan!</i> <br><br>  Apa yang mendorong saya untuk menulis artikel ini adalah sejumlah besar bahan analisis statis, yang akhir-akhir ini semakin banyak muncul.  Pertama, ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog PVS-Studio</a> , yang secara aktif mempromosikan dirinya di Habr memposting ulasan kesalahan, ditemukan oleh alat mereka dalam proyek-proyek open source.  PVS-Studio baru-baru ini mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dukungan Java</a> , dan, tentu saja, pengembang dari IntelliJ IDEA, yang penganalisa bawaannya mungkin yang paling canggih untuk Jawa saat ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak bisa menjauh</a> . <br><br>  Saat membaca ulasan ini, saya merasa bahwa kita sedang berbicara tentang ramuan ajaib: klik tombolnya, dan ini dia - daftar cacat tepat di depan mata Anda.  Tampaknya seiring dengan semakin canggihnya analisis, semakin banyak bug akan ditemukan, dan produk, yang dipindai oleh robot ini, akan menjadi lebih baik dan lebih baik tanpa upaya dari pihak kami. <br><br>  Yah, tapi tidak ada ramuan ajaib.  Saya ingin berbicara tentang apa yang biasanya tidak diucapkan dalam tulisan seperti "di sini adalah hal-hal yang dapat ditemukan robot kami": apa yang tidak dapat dilakukan oleh penganalisa, apa bagian dan tempat mereka yang sebenarnya dalam proses pengiriman perangkat lunak, dan bagaimana menerapkan analisis dengan benar. <br><br><img src="https://habrastorage.org/webt/ey/2o/ta/ey2otantl8aitotp4_lojjuscn4.png" width="500"><br>  <i>Ratchet (sumber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a> ).</i> <br><a name="habracut"></a><br><h2>  Apa Analisis Statis Tidak Akan Pernah Dapat Dilakukan </h2><br>  Apa analisis kode sumber dari sudut pandang praktis?  Kami mengambil file sumber dan mendapatkan beberapa informasi tentang kualitas sistem dalam waktu singkat (jauh lebih pendek daripada tes dijalankan).  Keterbatasan pokok dan matematis yang tidak dapat diatasi adalah bahwa dengan cara ini kita dapat menjawab hanya sebagian kecil pertanyaan tentang sistem yang dianalisis. <br><br>  Contoh tugas yang paling terkenal, tidak dapat dipecahkan dengan menggunakan analisis statis adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah terputus</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">putus</a> : ini adalah teorema, yang membuktikan bahwa seseorang tidak dapat mengerjakan algoritma umum, yang akan menentukan apakah suatu program dengan kode sumber yang diberikan diulang selamanya atau diselesaikan untuk waktu terakhir.  Perpanjangan teorema ini adalah teorema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rice</a> , yang menyatakan bahwa untuk properti non-sepele dari fungsi yang dapat dihitung, pertanyaan penentuan apakah program yang diberikan menghitung fungsi dengan properti ini adalah tugas algoritmik yang tidak dapat dipecahkan.  Misalnya, Anda tidak dapat menulis analisa, yang menentukan berdasarkan kode sumber jika program yang dianalisis adalah implementasi dari algoritma tertentu, katakanlah, yang menghitung kuadrat angka integer. <br><br>  Dengan demikian, fungsi analisis statis memiliki keterbatasan yang tidak dapat diatasi.  Analis statis tidak akan pernah bisa mendeteksi semua kasus, misalnya, bug "null pointer exception" dalam bahasa tanpa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keamanan batal</a> .  Atau mendeteksi semua kemunculan "atribut tidak ditemukan" dalam bahasa yang diketik secara dinamis.  Semua yang dapat dilakukan penganalisa statis paling sempurna adalah menangkap kasus-kasus tertentu.  Jumlah mereka di antara semua kemungkinan masalah dengan kode sumber Anda, tanpa berlebihan, adalah setetes di lautan. <br><br><h2>  Analisis Statis Bukan Pencarian untuk Bug </h2><br>  Berikut ini adalah kesimpulan yang mengikuti dari di atas: analisis statis bukan cara untuk mengurangi jumlah cacat dalam suatu program.  Saya berani mengklaim sebagai berikut: pertama kali diterapkan pada proyek Anda, ia akan menemukan tempat "lucu" dalam kode, tetapi kemungkinan besar tidak akan menemukan cacat yang memengaruhi kualitas program Anda. <br><br>  Contoh cacat yang ditemukan secara otomatis oleh analis sangat mengesankan, tetapi kita tidak boleh lupa bahwa contoh-contoh ini ditemukan dengan memindai sekumpulan basis kode yang besar terhadap sekumpulan aturan yang relatif sederhana.  Dengan cara yang sama peretas, yang memiliki kesempatan untuk mencoba beberapa kata sandi sederhana pada sejumlah besar akun, akhirnya menemukan akun dengan kata sandi sederhana. <br><br>  Apakah ini berarti bahwa analisis statis tidak perlu dilakukan?  Tentu tidak!  Itu harus diterapkan untuk alasan yang sama Anda mungkin ingin memverifikasi setiap kata sandi baru dalam daftar berhenti kata sandi yang tidak aman. <br><br><h2>  Analisis Statis Lebih Daripada Mencari Bug </h2><br>  Bahkan, tugas-tugas yang dapat diselesaikan dengan analisis dalam praktiknya jauh lebih luas.  Karena secara umum, analisis statis mewakili setiap pemeriksaan kode sumber, yang dilakukan sebelum menjalankannya.  Berikut beberapa hal yang dapat Anda lakukan: <br><br><ul><li> Pemeriksaan gaya pengkodean dalam arti luas dari kata ini.  Ini mencakup pemeriksaan pemformatan dan pencarian penggunaan tanda kurung kosong / tidak perlu, pengaturan nilai ambang batas untuk metrik seperti sejumlah baris / kompleksitas siklomatik suatu metode dan sebagainya - semua hal yang menyulitkan keterbacaan dan pemeliharaan kode.  Di Jawa, Checkstyle mewakili alat dengan fungsi seperti itu, dalam Python - <code>flake8</code> .  Program semacam itu biasanya disebut "linter". </li><li>  Tidak hanya kode yang dapat dieksekusi yang dapat dianalisis.  Sumber daya seperti file JSON, YAML, XML, dan <code>.properties</code> dapat (dan harus!) Diperiksa secara otomatis untuk validitasnya.  Alasannya adalah bahwa lebih baik untuk mengetahui fakta bahwa, katakanlah, struktur JSON rusak karena kutipan tidak berpasangan pada tahap awal pemeriksaan otomatis permintaan tarik daripada selama pelaksanaan tes atau dalam waktu berjalan, tidak itu  Ada beberapa alat yang relevan, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YAMLlint</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSONLint</a> dan <code>xmllint</code> . </li><li>  Kompilasi (atau parsing untuk bahasa pemrograman dinamis) juga merupakan semacam analisis statis.  Biasanya, kompiler dapat mengeluarkan peringatan yang memberi sinyal tentang masalah dengan kualitas kode sumber, dan mereka tidak boleh diabaikan. </li><li>  Terkadang kompilasi diterapkan tidak hanya pada kode yang dapat dieksekusi.  Misalnya, jika Anda memiliki dokumentasi dalam format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AsciiDoctor</a> , maka dalam proses kompilasi ke dalam HTML / PDF, AsciiDoctor ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin Maven</a> ) dapat mengeluarkan peringatan, misalnya, pada tautan internal yang terputus.  Ini adalah alasan penting untuk tidak menerima permintaan penarikan dengan perubahan dokumentasi. </li><li>  Pemeriksaan ejaan juga semacam analisis statis.  Utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aspell</a> mampu memeriksa ejaan tidak hanya dalam dokumentasi, tetapi juga dalam kode sumber program (komentar dan literal) dalam berbagai bahasa pemrograman termasuk C / C ++, Java dan Python.  Kesalahan pengejaan di antarmuka pengguna atau dokumentasi juga cacat! </li><li>  Tes konfigurasi sebenarnya mewakili bentuk analisis statis, karena mereka tidak mengeksekusi kode sumber selama proses pelaksanaannya, meskipun tes konfigurasi dijalankan sebagai tes unit <code>pytest</code> . </li></ul><br>  Seperti yang bisa kita lihat, pencarian bug memiliki peran paling tidak penting dalam daftar ini dan semua yang lain tersedia saat menggunakan alat open source gratis. <br><br>  Manakah dari jenis analisis statis ini yang harus digunakan dalam proyek Anda?  Tentu, semakin banyak semakin baik!  Yang penting di sini adalah implementasi yang tepat, yang akan dibahas lebih lanjut. <br><br><h2>  Jalur Pengiriman Sebagai Filter Multistage dan Analisis Statis Sebagai Tahap Pertama </h2><br>  Pipa dengan aliran perubahan (mulai dari perubahan kode sumber hingga pengiriman dalam produksi) adalah metafora klasik integrasi berkelanjutan.  Urutan standar tahapan pipa ini terlihat sebagai berikut: <br><br><ol><li>  analisis statis </li><li>  kompilasi </li><li>  tes unit </li><li>  tes integrasi </li><li>  Tes UI </li><li>  verifikasi manual </li></ol><br>  Perubahan yang ditolak pada tahap ke-N dari pipeline tidak diteruskan pada tahap N +1. <br><br>  Kenapa begitu dan tidak sebaliknya?  Di bagian jalur pipa, yang berkaitan dengan pengujian, penguji mengenali piramida uji yang terkenal: <br><br><img src="https://habrastorage.org/webt/hr/41/ut/hr41utwuuzfwoe_3pkr6xm7rcwo.png" width="400"><br>  <i>Tes piramida.</i>  <i>Sumber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> oleh Martin Fowler.</i> <br><br>  Di bagian bawah piramida ini ada tes yang lebih mudah untuk ditulis, yang dieksekusi lebih cepat dan tidak cenderung menghasilkan positif palsu.  Oleh karena itu, harus ada lebih banyak dari mereka, mereka harus mencakup sebagian besar kode dan harus dieksekusi terlebih dahulu.  Di puncak piramida situasinya sangat berlawanan, sehingga jumlah tes integrasi dan UI harus dikurangi seminimal mungkin.  Orang-orang dalam rantai ini adalah sumber daya yang paling mahal, lambat, dan tidak dapat diandalkan, sehingga mereka berada di bagian paling akhir dan melakukan pekerjaan hanya jika langkah sebelumnya tidak mendeteksi adanya cacat.  Di bagian yang tidak terkait dengan pengujian, pipa dibangun dengan prinsip yang sama! <br><br>  Saya ingin menyarankan analogi dalam bentuk sistem penyaringan air bertingkat.  Air kotor (perubahan dengan cacat) disediakan dalam input, dan sebagai output kita perlu mendapatkan air bersih, yang tidak akan mengandung semua kontaminasi yang tidak diinginkan. <br><br><img src="https://habrastorage.org/webt/nf/2n/gi/nf2ngidmm_2_aaiye4c52ol0fr0.jpeg" width="400"><br>  <i>Filter multi-tahap.</i>  <i>Sumber: <a href="">Wikimedia Commons</a></i> <br><br>  Seperti yang Anda ketahui, filter pemurnian dirancang sedemikian rupa sehingga setiap tahap selanjutnya mampu menghilangkan partikel kontaminan berukuran lebih kecil.  Tahap input pemurnian kasar memiliki throughput lebih besar dan biaya lebih rendah.  Dalam analogi kami, itu berarti bahwa gerbang kualitas input memiliki kinerja yang lebih besar, membutuhkan lebih sedikit upaya untuk meluncurkan dan memiliki lebih sedikit biaya operasi.  Peran analisis statis, yang (seperti yang sekarang kita pahami) mampu menyingkirkan hanya cacat yang paling serius adalah peran sump filter sebagai tahap pertama dari pembersih multi-tahap. <br><br>  Analisis statis tidak meningkatkan kualitas produk akhir dengan sendirinya, sama seperti "bah" tidak membuat air minum.  Namun dalam hubungannya dengan elemen pipa lainnya, kepentingannya jelas.  Meskipun dalam filter multistage, tahap output berpotensi menghapus semua yang dapat input - kami sadar akan konsekuensi yang akan terjadi ketika mencoba bertahan hanya dengan tahap pemurnian halus, tanpa tahap input. <br><br>  Tujuan dari "bah" adalah untuk membongkar tahap selanjutnya dari penangkapan cacat yang sangat kasar.  Misalnya, seseorang yang melakukan tinjauan kode tidak boleh terganggu oleh kode yang salah diformat dan pelanggaran standar kode (seperti tanda kurung yang berlebihan atau bercabang yang bersarang terlalu dalam).  Bug seperti NPE harus ditangkap oleh unit test, tetapi jika sebelum itu penganalisa menunjukkan bahwa bug akan muncul tak terhindarkan - ini akan secara signifikan mempercepat perbaikannya. <br><br>  Saya kira sekarang sudah jelas mengapa analisis statis tidak meningkatkan kualitas produk ketika diterapkan sesekali, dan harus diterapkan terus menerus untuk menyaring perubahan dengan cacat serius.  Pertanyaan apakah aplikasi penganalisis statis meningkatkan kualitas produk Anda kira-kira setara dengan pertanyaan "jika kita mengambil air dari kolam yang kotor, apakah kualitas minumnya akan meningkat ketika kita melewati saringan?" <br><br><h2>  Pengantar dalam Proyek Warisan </h2><br>  Masalah praktis penting: bagaimana menerapkan analisis statis dalam proses integrasi berkelanjutan, sebagai "gerbang kualitas"?  Dalam hal tes otomatis semuanya jelas: ada serangkaian tes, kegagalan salah satunya adalah alasan yang cukup untuk percaya bahwa build belum melewati gerbang kualitas.  Upaya untuk mengatur gerbang dengan cara yang sama dengan hasil analisis statis gagal: ada terlalu banyak peringatan analisis pada kode warisan, Anda tidak ingin mengabaikan semuanya, di sisi lain tidak mungkin untuk menghentikan pengiriman produk hanya karena ada peringatan penganalisa di dalamnya. <br><br>  Untuk setiap proyek, penganalisa mengeluarkan sejumlah besar peringatan yang diterapkan pada saat pertama.  Mayoritas peringatan tidak ada hubungannya dengan berfungsinya produk.  Tidak mungkin untuk memperbaiki mereka semua dan banyak dari mereka tidak harus diperbaiki sama sekali.  Pada akhirnya, kita tahu bahwa produk kita benar-benar berfungsi bahkan sebelum diperkenalkannya analisis statis! <br><br>  Akibatnya, banyak pengembang membatasi diri dengan penggunaan analisis statis sesekali atau menggunakannya hanya dalam mode informatif yang melibatkan mendapatkan laporan analisis ketika membangun proyek.  Ini setara dengan tidak adanya analisis, karena jika kita sudah memiliki banyak peringatan, kemunculan yang lain (betapapun seriusnya) tetap tidak diperhatikan ketika mengubah kode. <br><br>  Berikut adalah cara yang dikenal untuk pengenalan gerbang berkualitas: <br><br><ul><li>  Menetapkan batas jumlah total peringatan atau jumlah peringatan, dibagi dengan jumlah baris kode.  Ini bekerja dengan buruk, karena gerbang seperti itu memungkinkan perubahan dengan cacat baru sampai batas mereka terlampaui. </li><li>  Menandai semua peringatan lama dalam kode sebagai diabaikan pada saat tertentu dan membangun kegagalan saat peringatan baru muncul.  Fungsionalitas tersebut dapat disediakan oleh PVS-Studio dan beberapa alat lain, misalnya, Codacy.  Saya belum pernah bekerja dengan PVS-Studio.  Adapun pengalaman saya dengan Codacy, masalah utama mereka adalah bahwa perbedaan kesalahan lama dan baru adalah algoritma yang rumit dan tidak selalu bekerja, terutama jika file berubah secara signifikan atau diganti namanya.  Sepengetahuan saya, Codacy bisa mengabaikan peringatan baru dalam permintaan tarikan dan pada saat yang sama menghalangi permintaan tarikan karena peringatan, tidak terkait dengan perubahan dalam kode PR ini. </li><li>  Menurut pendapat saya, solusi paling efektif adalah metode "ratcheting" yang dijelaskan dalam buku " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengiriman Berkelanjutan</a> ".  Gagasan dasarnya adalah bahwa jumlah peringatan analisis statis adalah properti dari setiap rilis dan hanya perubahan yang diizinkan, yang tidak menambah jumlah total peringatan. </li></ul><br><h2>  Ratchet </h2><br>  Ini bekerja dengan cara berikut: <br><br><ol><li>  Pada fase awal, entri tentang sejumlah peringatan yang ditemukan oleh penganalisa kode ditambahkan dalam metadata rilis.  Dengan demikian, ketika membangun cabang utama tidak hanya "rilis 7.0.2" ditulis di manajer repositori Anda, tetapi "rilis 7.0.2, yang berisi 100500 Checkstyle-peringatan".  Jika Anda menggunakan manajer repositori tingkat lanjut (seperti Artifactory), mudah menyimpan metadata tersebut tentang rilis Anda. </li><li>  Saat membangun, setiap permintaan tarik membandingkan jumlah peringatan yang dihasilkan dengan jumlah mereka dalam rilis saat ini.  Jika seorang PR mengarah ke pertumbuhan angka ini, kode tidak melewati gerbang kualitas pada analisis statis.  Jika jumlah peringatan dikurangi atau tidak diubah - maka itu berlalu. </li><li>  Selama rilis berikutnya nomor yang dihitung ulang akan ditulis dalam metadata lagi. </li></ol><br>  Jadi perlahan tapi pasti, jumlah peringatan akan menjadi nol.  Tentu saja, sistem bisa dibodohi dengan memperkenalkan peringatan baru dan mengoreksi kesalahan orang lain.  Ini normal, karena dalam jangka panjang memberikan hasil: peringatan diperbaiki, biasanya tidak satu per satu, tetapi oleh kelompok-kelompok dari jenis tertentu, dan semua peringatan yang mudah diselesaikan diselesaikan dengan cukup cepat. <br><br>  Grafik ini menunjukkan jumlah total peringatan Checkstyle selama enam bulan dari "ratchet" pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salah satu proyek OpenSource kami</a> .  Jumlah peringatan telah berkurang secara signifikan, dan itu terjadi secara alami, sejalan dengan pengembangan produk! <br><br><img src="https://habrastorage.org/webt/ye/wa/u5/yewau5w494aa0vpkaevdydizoqm.png" width="500"><br><br>  Saya menerapkan versi modifikasi dari metode ini.  Saya menghitung peringatan secara terpisah untuk berbagai modul proyek dan alat analisis.  File YAML dengan metadata tentang build, yang dibentuk untuk melakukannya, tampak sebagai berikut: <br><br><pre> <code class="plaintext hljs">celesta-sql: checkstyle: 434 spotbugs: 45 celesta-core: checkstyle: 206 spotbugs: 13 celesta-maven-plugin: checkstyle: 19 spotbugs: 0 celesta-unit: checkstyle: 0 spotbugs: 0</code> </pre><br>  Dalam sistem CI canggih "ratchet" dapat diimplementasikan untuk alat analisis statis apa pun, tanpa bergantung pada plugin dan alat pihak ketiga.  Setiap analis mengeluarkan laporannya dalam bentuk teks atau XML sederhana, yang akan dengan mudah dianalisis.  Satu-satunya hal yang harus dilakukan setelahnya, adalah menulis logika yang diperlukan dalam sebuah skrip-CI.  Anda dapat mengintip dan melihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> atau di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> bagaimana penerapannya dalam proyek sumber kami berdasarkan Jenkins dan Artifactory.  Kedua contoh bergantung pada pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ratchetlib</a> : metode <code>countWarnings()</code> dengan cara yang biasa menghitung tag xml dalam file yang dihasilkan oleh Checkstyle dan Spotbugs, dan <code>compareWarningMaps()</code> mengimplementasikan ratchet yang sangat, melempar kesalahan dalam kasus, jika jumlah peringatan di salah satu kategori meningkat. <br><br>  Cara yang menarik untuk penerapan "ratchet" dimungkinkan untuk menganalisis ejaan komentar, literal teks, dan dokumentasi menggunakan aspell.  Seperti yang Anda ketahui, saat memeriksa ejaan, tidak semua kata yang tidak dikenal ke kamus standar salah, mereka dapat ditambahkan ke kamus khusus.  Jika Anda menjadikan kamus khusus sebagai bagian dari proyek kode sumber, maka gerbang kualitas untuk ejaan dapat dirumuskan sebagai berikut: menjalankan aspell dengan kamus standar dan kustom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak akan</a> menemukan kesalahan ejaan apa pun. <br><br><h2>  Pentingnya Memperbaiki Versi Analyzer </h2><br>  Kesimpulannya, perlu untuk mencatat hal berikut: cara apa pun yang Anda pilih untuk memperkenalkan analisis dalam pipa pengiriman Anda, versi penganalisis harus diperbaiki.  Jika Anda membiarkan penganalisis memperbarui dirinya sendiri secara spontan, maka ketika membuat permintaan tarikan lain cacat baru dapat muncul, yang tidak terkait dengan kode yang diubah, tetapi dengan fakta bahwa penganalisa baru hanya mampu mendeteksi lebih banyak cacat.  Ini akan merusak proses verifikasi permintaan tarik Anda.  Pembaruan penganalisis harus merupakan tindakan sadar.  Bagaimanapun, fiksasi versi yang kaku dari setiap komponen build adalah persyaratan umum dan subjek untuk topik lain. <br><br><h2>  Kesimpulan </h2><br><ul><li>  Analisis statis tidak akan menemukan bug dan tidak akan meningkatkan kualitas produk Anda sebagai hasil dari sekali berjalan.  Hanya terus berjalan dalam proses pengiriman akan menghasilkan efek positif. </li><li>  Bug hunt bukan tujuan analisis utama sama sekali.  Sebagian besar fitur yang berguna tersedia di perangkat opensource. </li><li>  Memperkenalkan gerbang kualitas dengan hasil analisis statis pada tahap pertama dari pipa pengiriman, menggunakan "ratchet" untuk kode lawas. </li></ul><br><h2>  Referensi </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengiriman terus menerus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alexey Kudryavtsev: Analisis program: apakah Anda pengembang yang baik?</a>  Laporkan metode analisis kode yang berbeda, bukan hanya statis! </li></ol><br><br><hr><br><h2>  Kutipan dari pembahasan artikel asli </h2><br><br>  <b>Evgeniy Ryzhkov</b> <br><br>  Ivan, terima kasih atas artikelnya dan telah membantu kami melakukan pekerjaan kami, yaitu mempopulerkan teknologi analisis kode statis.  Anda benar bahwa artikel-artikel dari blog PVS-Studio, dalam kasus dengan pikiran yang tidak matang, dapat memengaruhi mereka dan mengarah pada kesimpulan seperti "Saya akan memeriksa kode sekali saja, memperbaiki kesalahan dan itu akan dilakukan."  Ini adalah rasa sakit pribadi saya, yang saya tidak tahu bagaimana mengatasinya selama beberapa tahun.  Faktanya adalah bahwa artikel tentang pemeriksaan proyek: <br><br><ol><li>  Menyebabkan efek wow pada orang.  Orang suka membaca bagaimana pengembang perusahaan seperti Google, Epic Games, Microsoft, dan perusahaan lain terkadang gagal.  Orang suka berpikir bahwa siapa pun bisa salah, bahkan para pemimpin industri melakukan kesalahan.  Orang suka membaca artikel seperti itu. </li><li>  Selain itu, penulis dapat menulis artikel tentang arus, tanpa harus berpikir keras.  Tentu saja, saya tidak ingin menyinggung perasaan orang-orang kami yang menulis artikel ini.  Tetapi datang setiap kali dengan artikel baru jauh lebih sulit daripada menulis artikel tentang cek proyek (selusin bug, beberapa lelucon, campur dengan gambar unicorn). </li></ol><br>  Anda menulis artikel yang sangat bagus.  Saya juga punya beberapa artikel tentang topik ini.  Begitu juga kolega lainnya.  Selain itu, saya mengunjungi berbagai perusahaan dengan laporan tentang tema "Filsafat analisis kode statis", di mana saya berbicara tentang proses itu sendiri, tetapi bukan tentang bug tertentu. <br><br>  Tetapi tidak mungkin menulis 10 artikel tentang prosesnya.  Nah, untuk mempromosikan produk kita, kita perlu banyak menulis secara teratur.  Saya ingin mengomentari beberapa poin lagi dari artikel dengan komentar terpisah untuk membawa diskusi lebih nyaman. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel</a> singkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> adalah tentang "Filsafat analisis kode statis", yang merupakan topik saya ketika mengunjungi berbagai perusahaan. <br><br>  <b>Ivan Ponomarev</b> <br>  Evgeniy, terima kasih banyak atas ulasan informatif pada artikelnya!  Ya, Anda mendapat perhatian saya di posting tentang dampak pada "pikiran yang belum matang" benar-benar benar! <br><br>  Tidak ada yang bisa disalahkan di sini, karena penulis artikel / laporan <i>analisis</i> tidak bertujuan membuat artikel / laporan <i>analisis</i> .  Tetapi setelah beberapa posting terbaru oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Andrey2008</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">lany</a> , saya memutuskan bahwa saya tidak bisa diam lagi. <br><br>  <b>Evgeniy Ryzhkov</b> <br>  Ivan, seperti yang ditulis di atas, saya akan mengomentari tiga poin dari artikel ini.  Itu berarti bahwa saya setuju dengan yang, bahwa saya tidak berkomentar. <br><br>  1. <i>Urutan standar tahapan pipa ini terlihat sebagai berikut ...</i> <br><br>  Saya tidak setuju bahwa langkah pertama adalah analisis statis, dan hanya yang kedua adalah kompilasi.  Saya percaya bahwa, rata-rata, pengecekan kompilasi lebih cepat dan lebih logis daripada langsung menjalankan analisis statis "lebih berat".  Kami dapat mendiskusikan jika Anda berpikir sebaliknya. <br><br>  2. <i>Saya belum pernah bekerja dengan PVS-Studio.</i>  <i>Adapun pengalaman saya dengan Codacy, masalah utama mereka adalah bahwa perbedaan kesalahan lama dan baru adalah algoritma yang rumit dan tidak selalu bekerja, terutama jika file berubah secara signifikan atau diganti namanya.</i> <br><br>  Dalam PVS-Studio hal ini dilakukan dengan sangat baik.  Ini adalah salah satu fitur pembunuh dari produk, yang, sayangnya, sulit untuk dijelaskan dalam artikel, itu sebabnya orang tidak terlalu mengenalnya.  Kami mengumpulkan informasi tentang kesalahan yang ada di basis.  Dan tidak hanya "nama file dan baris", tetapi juga informasi tambahan (tanda hash dari tiga baris - saat ini, sebelumnya, berikutnya), sehingga dalam hal menggeser fragmen kode, kita masih bisa menemukannya.  Karena itu, ketika memiliki modifikasi kecil, kami masih mengerti bahwa ini adalah kesalahan lama.  Dan penganalisa tidak mengeluh tentang hal itu.  Sekarang seseorang mungkin berkata: "Nah, bagaimana jika kodenya telah banyak berubah, maka ini tidak akan berhasil, dan Anda mengeluh tentang hal itu seolah-olah itu adalah yang baru ditulis?"  Ya  Kami mengeluh.  Tetapi sebenarnya ini adalah kode baru.  Jika kode telah banyak berubah, ini sekarang adalah kode baru, bukan yang lama. <br><br>  Berkat fitur ini, kami secara pribadi berpartisipasi dalam implementasi proyek dengan 10 juta baris kode C ++, yang setiap hari "disentuh" ​​oleh sekelompok pengembang.  Semuanya berjalan tanpa masalah.  Jadi kami merekomendasikan penggunaan fitur PVS-Studio ini kepada siapa saja yang memperkenalkan analisis statis dalam prosesnya.  Opsi dengan memperbaiki jumlah peringatan menurut rilis tampaknya kurang disukai bagi saya. <br><br>  3. <i>Cara apa pun yang Anda pilih untuk memperkenalkan analisis pipa pengiriman Anda, versi analisa harus diperbaiki</i> <br><br>  Saya tidak bisa setuju dengan ini.  Musuh yang pasti dari pendekatan semacam itu.  Saya merekomendasikan memperbarui analisa dalam mode otomatis.  Saat kami menambahkan diagnostik baru dan meningkatkan yang lama.  Mengapa  Pertama, Anda akan mendapatkan peringatan untuk kesalahan nyata yang baru.  Kedua, beberapa positif palsu lama mungkin hilang jika kita mengatasinya. <br><br>  Tidak memperbarui penganalisis sama dengan tidak memperbarui basis data anti-virus ("bagaimana jika mereka mulai memberi tahu tentang virus").  Kami tidak akan membahas di sini manfaat sebenarnya dari perangkat lunak antivirus secara keseluruhan. <br><br>  Jika setelah memutakhirkan versi penganalisa Anda memiliki banyak peringatan baru, kemudian tekan mereka, seperti yang saya tulis di atas, melalui fungsi itu.  Tetapi tidak untuk memperbarui versi ... Sebagai aturan, klien seperti itu (tentu ada beberapa) tidak memperbarui versi penganalisa selama bertahun-tahun.  Tidak ada waktu untuk itu.  Mereka MEMBAYAR untuk perpanjangan lisensi, tetapi tidak menggunakan versi baru.  Mengapa  Karena begitu mereka memutuskan untuk memperbaiki suatu versi.  Produk hari ini dan tiga tahun yang lalu adalah siang dan malam.  Ternyata seperti "Saya akan membeli tiket, tetapi tidak akan datang". <br><br>  <b>Ivan Ponomarev</b> <br><br>  1. Di sini Anda benar.  Saya siap untuk setuju dengan kompiler / pengurai di awal dan ini bahkan harus diubah di artikel!  Misalnya, <code>spotbugs</code> terkenal tidak dapat bertindak dengan cara yang berbeda sama sekali, karena menganalisis dikompilasi bytecode.  Ada kasus-kasus eksotis, misalnya, dalam pipa untuk buku pedoman Ansible, analisis statis lebih baik ditetapkan sebelum parsing karena lebih ringan di sana.  Tapi ini eksotis itu sendiri) <br><br>  2. <i>Opsi dengan memperbaiki jumlah peringatan menurut rilis tampaknya kurang disukai bagi saya ...</i> - yah, ya, kurang disukai, kurang teknis tetapi sangat praktis :-) Hal utama adalah bahwa itu adalah metode umum, dimana saya dapat secara efektif menerapkan analisis statis di mana saja, bahkan dalam proyek paling menakutkan, memiliki basis kode dan penganalisa apa pun (tidak harus milik Anda), menggunakan Groovy atau skrip bash pada CI.  Ngomong-ngomong, sekarang kita menghitung peringatan secara terpisah untuk modul dan alat proyek yang berbeda, tetapi jika kita membaginya dengan cara yang lebih terperinci (untuk file), itu akan jauh lebih dekat dengan metode membandingkan yang baru / lama.  Tapi kami merasa seperti itu dan saya suka ratcheting karena itu merangsang pengembang memantau jumlah total peringatan dan perlahan-lahan mengurangi jumlah ini.  Jika kita memiliki metode yang lama / baru, apakah itu akan memotivasi pengembang untuk memantau kurva angka peringatan?  - mungkin, ya, mungkin, tidak. <br><br>  Adapun poin 3, inilah contoh nyata dari pengalaman saya.  Lihatlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komit ini</a> .  Dari mana asalnya?  Kami mengatur linter dalam skrip TravisCI.  Mereka bekerja di sana sebagai gerbang berkualitas.  Tapi tiba-tiba, ketika versi baru dari Ansible-lint yang menemukan lebih banyak peringatan, beberapa build permintaan tarik mulai gagal karena peringatan dalam kode, yang tidak mereka ubah !!!  Pada akhirnya, prosesnya rusak dan permintaan tarikan yang mendesak digabung tanpa melewati gerbang kualitas. <br><br>  Tidak ada yang mengatakan bahwa tidak perlu memperbarui analisis.  Tentu saja!  Seperti semua komponen build lainnya.  Tetapi itu harus merupakan proses yang disadari, tercermin dalam kode sumber.  Dan setiap kali tindakan akan tergantung pada keadaan (apakah kita memperbaiki peringatan yang terdeteksi lagi atau hanya mereset "ratchet") <br><br>  <b>Evgeniy Ryzhkov</b> <br>  Ketika saya ditanya: "Apakah ada kemampuan untuk memeriksa setiap komit di PVS-Studio?", Saya menjawab, bahwa ya, ada.  Dan kemudian menambahkan: "Hanya demi Tuhan jangan gagal membangun jika PVS-Studio menemukan sesuatu!"  Karena kalau tidak, cepat atau lambat, PVS-Studio akan dianggap sebagai hal yang mengganggu.  Dan ada situasi ketika ITU PERLU untuk melakukan dengan cepat, daripada berkelahi dengan alat, yang tidak membiarkan komit berlalu. <br><br>  Pendapat saya buruk untuk gagal membangun dalam kasus ini.  Ada baiknya mengirim pesan ke pembuat kode masalah. <br><br>  <b>Ivan Ponomarev</b> <br>  Pendapat saya adalah bahwa tidak ada yang namanya "kita harus cepat berkomitmen."  Ini semua hanyalah proses yang buruk.  Proses yang baik menghasilkan kecepatan bukan karena kita memecah gerbang proses / kualitas, ketika kita perlu "melakukannya dengan cepat". <br><br>  Ini tidak bertentangan dengan fakta yang dapat kita lakukan tanpa gagal membangun beberapa kelas temuan analisis statis.  Ini hanya berarti bahwa gerbang diatur sedemikian rupa sehingga jenis-jenis temuan tertentu diabaikan dan untuk temuan lain kami memiliki Toleransi Nol. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Commstrip favorit saya pada topik "cepat".</a> <br><br>  <b>Evgeniy Ryzhkov</b> <br>  Saya adalah musuh yang pasti dari pendekatan untuk menggunakan versi analisa lama.  Bagaimana jika pengguna menemukan bug di versi itu?  Dia menulis ke pengembang alat dan pengembang alat bahkan akan memperbaikinya.  Namun dalam versi baru.  Tidak ada yang akan mendukung versi lama untuk beberapa klien.  Jika kita tidak berbicara tentang kontrak bernilai jutaan dolar. <br><br>  <b>Ivan Ponomarev</b> <br>  Evgeniy, kita tidak membicarakan ini sama sekali.  Tidak ada yang mengatakan kita harus menjaga mereka tetap tua.  Ini tentang memperbaiki versi dependensi komponen build untuk pembaruan terkontrol mereka - ini adalah disiplin umum, ini berlaku untuk semuanya, termasuk perpustakaan dan alat. <br><br>  <b>Evgeniy Ryzhkov</b> <br>  Saya mengerti bagaimana "itu harus dilakukan secara teori".  Tetapi saya melihat hanya dua pilihan yang dibuat oleh klien.  Baik tetap pada yang baru atau yang lama.  Jadi kami hampir tidak memiliki situasi seperti itu ketika "kami memiliki disiplin dan kami tertinggal dari versi saat ini pada dua rilis".  Tidak penting bagi saya untuk mengatakan sekarang apakah itu baik atau buruk.  Saya hanya mengatakan apa yang saya lihat. <br><br>  <b>Ivan Ponomarev</b> <br>  Saya mengerti.  Bagaimanapun, itu semua sangat tergantung pada alat / proses apa yang dimiliki klien Anda dan bagaimana mereka menggunakannya.  Sebagai contoh, saya tidak tahu apa-apa tentang cara kerjanya di dunia C ++. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440610/">https://habr.com/ru/post/id440610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440600/index.html">Berapa banyak nama domain .com yang tidak digunakan?</a></li>
<li><a href="../id440602/index.html">Dunning dengan Kruger, Socrates dan kalangan pengetahuan</a></li>
<li><a href="../id440604/index.html">Mesin akuntansi, IBM 1403, dan mengapa 132 kolom adalah standar untuk printer</a></li>
<li><a href="../id440606/index.html">Intisari materi menarik untuk pengembang seluler # 286 (pada 11-17 Februari)</a></li>
<li><a href="../id440608/index.html">Tugas mengklasifikasikan melalui mata anak sekolah: menentukan keberadaan mobil di tempat parkir dengan bingkai dari kamera pengintai</a></li>
<li><a href="../id440612/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 5. Menghubungkan Perangkat CISCO dan Mode iOS</a></li>
<li><a href="../id440614/index.html">Masalah keamanan jalan, disortir berdasarkan titik</a></li>
<li><a href="../id440616/index.html">NASA membeli dua kursi lagi di Soyuz, menguji RS-25 dan tidak meninggalkan stasiun dekat Bumi</a></li>
<li><a href="../id440618/index.html">Julia dan optimasi</a></li>
<li><a href="../id440620/index.html">Kegilaan Dotfile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>