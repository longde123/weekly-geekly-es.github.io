<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗑️ ☢️ 🧗🏾 Die Entwicklung des x86-Kontextwechsels unter Linux 👨🏼‍🔬 🐓 🙌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als ich am vergangenen Wochenende interessante Fakten über den 80386-Hardware-Kontextwechsel studierte, fiel mir plötzlich ein, dass sich die ersten V...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Entwicklung des x86-Kontextwechsels unter Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438042/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df8/ca2/556/df8ca2556ca28afde78fe531a3eb892b.png"></div><br><br>  Als ich am vergangenen Wochenende interessante Fakten über den 80386-Hardware-Kontextwechsel studierte, fiel mir plötzlich ein, dass sich die ersten Versionen des Linux-Kernels darauf stützten.  Und ich tauchte in Code ein, den ich seit vielen Jahren nicht mehr gesehen hatte.  Jetzt habe ich beschlossen, diese wunderbare Reise durch die Geschichte von Linux zu beschreiben.  Ich werde alle Nuggets und lustigen Artefakte zeigen, die ich unterwegs gefunden habe. <br><br>  <b>Ziel:</b> Verfolgen, wie sich die Kontextumschaltung im Linux-Kernel von der ersten (0,01) auf die neueste Version von LTS (4.14.67) geändert hat, wobei der Schwerpunkt auf der ersten und der neuesten Version liegt. <br><a name="habracut"></a><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frühes Linux: Alte Geschichte</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux 1.0: Proof of Concept</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux 2.0: Kandidat</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2 Software Level Switching</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.4: letzter alter Kern</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux 2.6: Popularität</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux 3.0: modernes Betriebssystem</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux 4.14.67: neueste LTS</a> </li></ul><br>  Tatsächlich geht es in der Geschichte nicht darum, den Kontext zu wechseln, sondern um die Entwicklung von Linux von einem kleinen Projekt zu einem modernen Betriebssystem.  Der Kontextwechsel spiegelt einfach diese Geschichte wider. <br><br><h2>  Über welchen Kontextwechsel sprechen wir? </h2><br>  Obwohl es viele Dinge gibt, die als Kontextumschaltung betrachtet werden können (z. B. Umschalten in den Kernelmodus, Umschalten auf einen Interrupt-Handler), meine ich die allgemein akzeptierte Bedeutung: <b>Umschalten zwischen Prozessen</b> .  Unter Linux ist dies das Makro <code>switch_to()</code> und alles darin. <br><br>  Dieses Makro ist eine einfache mechanische Aktion zwischen zwei viel interessanteren Systemen: einem Taskplaner und einer CPU.  Betriebssystementwickler können Aufgabenplanungsstrategien mischen und koordinieren.  CPU-Architekturen sind ebenfalls weit offen: Linux unterstützt Dutzende von Typen.  Aber der Kontextwechsel ist das Zahnrad zwischen ihnen.  Sein „Design“ hängt von seinen Nachbarn ab, daher behauptet der Kontextwechsel, der am <i>wenigsten</i> interessante Teil des Betriebssystems zu sein.  Ich wiederhole: Er tut nur das, was getan werden muss. <br><br>  Eine kurze Liste von Kontextwechselaufgaben: <br><br><ol><li>  Überschreiben des Arbeitsbereichs: Stapelwiederherstellung (SS: SP). <br></li><li>  Suchen Sie nach der folgenden Anweisung: IP-Wiederherstellung (CS: IP). <br></li><li>  Wiederherstellung des Taskstatus: Wiederherstellung von Allzweckregistern. <br></li><li>  Austausch von Speicheradressräumen: Aktualisierung des Seitenverzeichnisses (CR3) <br></li><li>  ... und vieles mehr: FPUs, Betriebssystemdatenstrukturen, Debug-Register, Hardware-Problemumgehungen usw. </li></ol><br>  Es ist nicht immer klar, wann und wo diese Aufgaben ausgeführt werden, wenn ein anderer Prozess die CPU übernimmt.  Beispielsweise verbirgt das Umschalten des Hardwarekontexts vor Linux 2.2 die Aufgaben 2, 3 und 4. Aufgabe 3 ist begrenzt, da zwischen den Kernelmodi umgeschaltet wird.  Das Wiederherstellen eines Benutzer-Threads ist eine <code>iret</code> Aufgabe, nachdem der Scheduler zurückgekehrt ist.  Viele dieser Aufgaben in verschiedenen Kernelversionen schweben zwischen <code>switch_to()</code> und dem Scheduler.  Wir können nur garantieren, dass in jeder Version immer ein Stack-Swap und ein FPU-Switching stattfinden. <br><br><h3>  Für wen ist es? </h3><br>  Nicht für irgendjemanden speziell.  Zum Verständnis müssen Sie nur den x86-Assembler kennen und wahrscheinlich nur über eine minimale Ausbildung in Bezug auf das Betriebssystemdesign verfügen. <br><br>  Ich muss <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">sofort</a> sagen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">,</a> dass ich kein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Betreuer</a> oder Mitwirkender am Linux-Kernel bin.  Alle Informationen von diesen Kameraden oder von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">der Mailingliste der Kernelentwickler</a> , die meinen Informationen widersprechen, sollten ernst genommen werden.  Ich habe ein zufälliges persönliches Projekt, keinen wissenschaftlichen Artikel in einem von Experten begutachteten Journal. <br><br><a name="1"></a><h1>  Frühes Linux vor 1.0: Alte Geschichte (1991) </h1><br>  Der frühe Linux-Kernel ist einfach und funktional und enthält eine kleine Liste der wichtigsten Funktionen: <br><br><ul><li>  Einzelarchitektur (80386 / i386): Nur eine Art von Kontextwechsel.  Viele 80386-Funktionen sind im gesamten Kern fest codiert.  Als Referenz zu diesen Teilen habe ich das Intel 80386 Programmer's Guide (1986) genommen. <br></li><li>  Hardware-Kontextwechsel: Um Aufgaben zu ändern, verwendet der Kernel integrierte Mechanismen 80386. <br></li><li>  Ein Prozess mit präemptivem Multitasking: Es ist jeweils nur eine CPU mit einem Prozess aktiv.  Ein anderer Prozess kann jedoch jederzeit beginnen.  Daher werden die üblichen Synchronisationsregeln angewendet: Blockieren gemeinsam genutzter Ressourcen (ohne Spin-Locks).  Im Extremfall ist es möglich, Interrupts zu deaktivieren, aber zuerst den Mutex zu sperren. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/d58/0f8/1b3/d580f81b36718f5531ea3790fd00c8ab.png"><br><br>  Schauen Sie sich ohne weiteres die beiden frühen Kontextwechsel an.  Der Code ist zur besseren Lesbarkeit formatiert: ein Element pro Zeile ohne Fortsetzungszeichen (\). <br><br>  <b>Linux 0.01</b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/linux/sched.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(n) { struct {long a,b;} __tmp; __asm__(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmpl %%ecx,_current\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"je 1f\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"xchgl %%ecx,_current\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movw %%dx,%1\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ljmp %0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmpl %%ecx,%2\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jne 1f\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"clts\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1:"</span></span></span><span class="hljs-meta"> ::</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (*&amp;__tmp.a), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (*&amp;__tmp.b), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (last_task_used_math), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"d"</span></span></span><span class="hljs-meta"> _TSS(n), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"c"</span></span></span><span class="hljs-meta"> ((long) task[n])); }</span></span></code> </pre> <br>  <b>Linux 0.11</b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/linux/sched.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(n) { struct {long a,b;} __tmp; __asm__(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmpl %%ecx,_current\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"je 1f\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movw %%dx,%1\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"xchgl %%ecx,_current\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ljmp %0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmpl %%ecx,_last_task_used_math\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jne 1f\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"clts\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1:"</span></span></span><span class="hljs-meta"> ::</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (*&amp;__tmp.a), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (*&amp;__tmp.b), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"d"</span></span></span><span class="hljs-meta"> (_TSS(n)), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"c"</span></span></span><span class="hljs-meta"> ((long) task[n])); }</span></span></code> </pre> <br>  Sofort auffällig, wie klein er ist!  Klein genug, um jede Zeile einzeln zu analysieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(n) {</span></span></code> </pre> <br>  <code>switch_to()</code> ist also ein Makro.  Es erscheint an genau einer Stelle: in der allerletzten Zeile des <code>schedule()</code> .  Daher teilt das Makro nach der Vorverarbeitung den Scheduler-Bereich.  Im globalen Bereich werden unbekannte Links überprüft, z. B. <code>current</code> und <code>last_task_used_math</code> .  Das Eingabeargument <code>n</code> ist die Sequenznummer der nächsten Aufgabe (von 0 bis 63). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span><span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a,b;} __tmp;</code> </pre> <br>  Reserviert 8 Bytes (64 Bit) auf dem Stapel, auf die über zwei 4-Byte-Elemente <code>a</code> und <code>b</code> .  Wir werden einige dieser Bytes später für die Weitsprungoperation setzen. <br><br><pre> <code class="cpp hljs">__asm__(<span class="hljs-string"><span class="hljs-string">"cmpl %%ecx,_current\n\t"</span></span></code> </pre> <br>  Der Kontextwechsel ist ein langer Inline-Block im Assembler.  Der erste Befehl bestimmt, ob das Ziel bereits aktuell ist.  Dies ist ein subtraktiver Vergleich des Werts im ECX-Register mit dem Wert des aktuellen <code>current</code> vom Scheduler.  Beide enthalten Zeiger auf <code>task_struct</code> Prozesses.  Unten in ECX befindet sich ein Zeiger auf die Zielaufgabe als gegebene Eingabe: <code>"c" ((long) task[n])</code> .  Das Vergleichsergebnis setzt den Wert des Statusregisters EFLAGS: Zum Beispiel ZF = 1, wenn beide Zeiger übereinstimmen (x - x = 0). <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"je 1f\n\t"</span></span></code> </pre> <br>  Wenn die nächste Aufgabe die aktuelle ist, müssen Sie den Kontext nicht wechseln, daher sollten Sie diese gesamte Prozedur überspringen (überspringen).  Der Befehl <code>je</code> prüft, ob ZF = 1. Wenn ja, wird nach diesem Punkt im Code, der 8 Zeilen voraus ist, zur ersten Bezeichnung '1' verschoben. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"xchgl %%ecx,_current\n\t"</span></span></code> </pre> <br>  Aktualisiert den globalen <code>current</code> , um die neue Aufgabe widerzuspiegeln.  Der Zeiger von ECX (Task [n]) wechselt auf aktuell.  Flags werden nicht aktualisiert. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movw %%dx,%1\n\t"</span></span></code> </pre> <br>  Verschiebt den TSS-Index (Target Selector Descriptor Segment Selector) in einen zuvor reservierten Bereich.  Technisch gesehen wird dadurch der Wert aus dem DX-Register in <code>__tmp.b</code> , <code>__tmp.b</code> in die Bytes 5 bis 8 unserer reservierten 8-Byte-Struktur.  Der DX-Wert ist die angegebene Eingabe: <code>"d" (_TSS(n))</code> .  Das mehrstufige <code>_TSS</code> Makro wird zu einem gültigen TSS-Segment-Selektor erweitert, auf den ich später noch <code>_TSS</code> werde.  Unter dem Strich enthalten die beiden High-Bytes <code>__tmp.b</code> jetzt einen Segmentzeiger auf die nächste Aufgabe. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"ljmp %0\n\t"</span></span></code> </pre> <br>  Ruft einen Hardware-Kontextschalter 80386 auf, der zum TSS-Deskriptor wechselt.  Dieser einfache Sprung kann verwirrend sein, da es drei verschiedene Ideen gibt: Erstens ist <code>ljmp</code> ein indirekter Weitsprung, der einen 6-Byte-Operanden (48 Bit) benötigt.  Zweitens bezieht sich der Operand% 0 auf die nicht initialisierte Variable <code>__tmp.</code> .  Schließlich ist der Wechsel zu einem Segmentselektor in GDT in x86 von besonderer Bedeutung.  Werfen wir einen Blick auf diese Punkte. <br><br><h3>  Indirekter Fernübergang </h3><br>  Der wichtige Punkt ist, dass dieser Übergang einen 6-Byte-Operanden hat.  Das Programmierhandbuch für 80386 beschreibt den Übergang wie folgt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae5/fb3/676/ae5fb367632800feb6f59b53ee8d96c0.png"><br><br><h3>  Gehe zu __tmp.a </h3><br>  Denken Sie daran, dass die <code>__tmp</code> Struktur zwei 4-Byte-Werte enthielt und die Struktur auf <code>a</code> basiert.  Wenn wir dieses Element jedoch als Basisadresse des 6-Byte-Operanden verwenden, erreichen wir zwei Bytes <b>innerhalb der</b> Ganzzahl <code>__tmp.b</code> .  Diese beiden Bytes sind Teil des "Segmentselektors" der Fernadresse.  Wenn der Prozessor erkennt, dass das Segment im GDT TSS ist, wird ein Teil des Offsets vollständig ignoriert.  Die Tatsache, dass <code>__tmp.a</code> nicht initialisiert wird, spielt keine Rolle, da <code>__tmp.b</code> dank der vorherigen <code>movw</code> Anweisung immer noch einen gültigen Wert hat.  Fügen Sie die Übergangsadresse zum Diagramm hinzu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c02/e5a/974/c02e5a974ab3b2c6f907564b1316a0cf.png"><br><br>  Woher wissen wir, dass sich diese Adresse auf GDT bezieht?  Ich werde die Details in anderen Codezeilen offenbaren, aber die kurze Version ist, dass die vier Nullbits im Selektor eine GDT-Suche auslösen.  Das Makro <code>_TSS(n)</code> garantiert das Vorhandensein dieser vier Nullen.  Die unteren zwei Bits sind die Segmentberechtigungsstufe (00 entspricht Supervisor / Kernel), das nächste Nullbit bedeutet die Verwendung der GDT-Tabelle (die beim Booten in der GDTR gespeichert ist).  Die vierte Null ist technisch gesehen Teil des Segmentindex, der alle TSS-Suchen für die geraden Einträge der GDT-Tabelle erzwingt. <br><br><h3>  Hardware-Kontextschalter </h3><br>  Die Sprungadresse in <code>__tmp</code> definiert das TSS-Handle im GDT.  So wird es im Handbuch für 80386 beschrieben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1c/014/050/b1c014050e704604c7064c14e33af920.png"><br><br>  Der Prozessor erledigt für uns automatisch Folgendes: <br><br><ul><li>  Überprüft, ob die aktuelle Berechtigungsstufe zulässig ist (wir befinden uns im Kernel-Modus, sodass alles in Ordnung ist). <br></li><li>  Überprüft, ob das TSS gültig ist (sollte sein). <br></li><li>  Speichert den gesamten aktuellen Status der Aufgabe im alten TSS, der noch im Aufgabenregister (TR) gespeichert ist, sodass Sie EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI, ES, CS, SS, DS, FS, nicht verwenden müssen. GS und EFLAGS.  EIP wird zum nächsten Befehl erhöht und ebenfalls gespeichert. <br></li><li>  Aktualisiert TR für eine neue Aufgabe. <br></li><li>  Stellt alle allgemeinen Register, EIP und PDBR (Swap Address Space) wieder her.  Der Taskwechsel ist beendet, daher wird das TS-Flag im CR0-Register gesetzt. </li></ul><br>  Die einzige Anweisung <code>"ljmp %0\n\t"</code> hat also alle Schritte zum Wechseln des Kontexts ausgeführt.  Es bleibt nur ein bisschen aufzuräumen. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"cmpl %%ecx,%2\n\t"</span></span></code> </pre> <br>  Wir überprüfen, ob die vorherige Aufgabe den mathematischen Coprozessor wiederhergestellt hat.  Das Argument ist der Zeiger <code>last_task_used_math</code> .  Mit dem TS-Flag können Sie überprüfen, ob der Coprozessor einen anderen Kontext hat.  Hardwarekontextschalter steuern den Coprozessor nicht. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"jne 1f\n\t"</span></span></code> </pre> <br>  Wenn die letzte Aufgabe den Coprozessor nicht wiederhergestellt hat, fahren Sie mit dem Ende des Kontextwechsels fort.  Wir möchten das TS-Flag belassen, damit Sie bei der nächsten Verwendung des Coprozessors eine verzögerte Bereinigung durchführen können.  "Faul", weil wir die Aufgabe verschieben, bis sie absolut notwendig wird. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"clts\n"</span></span></code> </pre> <br>  Löschen Sie das TS-Flag, wenn der letzte Prozess den Status des Coprozessors wiederhergestellt hat. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"1:"</span></span></code> </pre> <br>  Endmarkierung des Kontextschalters.  Alle Sprünge zu dieser Bezeichnung überspringen einige oder alle Prozeduren. <br><br><pre> <code class="cpp hljs">::<span class="hljs-string"><span class="hljs-string">"m"</span></span> (*&amp;__tmp.a),</code> </pre> <br>  In diesem Assembler-Block gibt es keine Ausgabe, und die erste Eingabe (% 0) ist die Position im Speicher der ersten vier Bytes des Fernzeigers auf den TSS-Deskriptor in der GDT.  Es wird nur als Referenz auf die Adresse verwendet, der Wert wird nicht initialisiert. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"m"</span></span> (*&amp;__tmp.b),</code> </pre> <br>  Die zweite Eingabe (% 1) ist die Stelle im Speicher der Bytes 5 und 6 des Fernzeigers auf den TSS-Deskriptor.  Technisch gesehen belegt dieser Platz vier Bytes im Speicher, aber nur die ersten beiden werden überprüft und verwendet. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"m"</span></span> (last_task_used_math),</code> </pre> <br>  Die dritte Eingabe (% 2) ist die Position im Speicher des Zeigers auf den letzten <code>task_struct</code> , der den Status des Coprozessors wiederhergestellt hat. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"d"</span></span> (_TSS(n)),</code> </pre> <br>  Die vierte Eingabe (% 3 / %% edx) ist die Adresse des TSS-Deskriptorsegment-Selektors in der GDT.  Schauen wir uns das Makro an: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _TSS(n) ((((unsigned long) n)&lt;&lt;4)+(FIRST_TSS_ENTRY&lt;&lt;3)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FIRST_TSS_ENTRY 4</span></span></code> </pre> <br>  Dies bedeutet, dass der erste TSS-Deskriptor der 4. Datensatz ist (der Index beginnt mit dem 4. Bit des Segmentselektors).  Jedes nachfolgende TSS belegt jeden zweiten GDT-Datensatz: 4, 6, 8 usw. Die ersten acht Aufgaben sehen folgendermaßen aus: <br><br><table border="0"><thead><tr><th>  Aufgabe # </th><th>  16-Bit-Segmentauswahl </th></tr></thead><tbody><tr><td>  0 </td><td>  0000000000100 0 00 </td></tr><tr><td>  1 </td><td>  0000000000110 0 00 </td></tr><tr><td>  2 </td><td>  0000000001000 0 00 </td></tr><tr><td>  3 </td><td>  0000000001010 0 00 </td></tr><tr><td>  4 </td><td>  0000000001100 0 00 </td></tr><tr><td>  5 </td><td>  0000000001110 0 00 </td></tr><tr><td>  6 </td><td>  0000000010000 0 00 </td></tr><tr><td>  7 </td><td>  0000000010010 0 00 </td></tr></tbody></table><br>  Die Adressbits werden durch das Feldformat getrennt, wie es in 80386 sein sollte: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/600/837/d6d/600837d6d6710747e269775a515658b6.png"><br><br>  Die vier niedrigstwertigen Bits sind immer Null, was dem Supervisor-Modus, der GDT-Tabelle, entspricht und sogar Einträge des GDT-Index erzwingt. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"c"</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) task[n]));</code> </pre> <br>  Der letzte Eintrag (% 4 /% ecx) ist ein Zeiger auf das neue task_struct, zu dem wir wechseln.  Beachten Sie, dass sich der %% ecx-Wert unmittelbar vor dem Kontextwechsel zur vorherigen Aufgabe ändert. <br><br><h3>  Unterschiede zwischen 0,01 und 0,11 </h3><br>  Es gibt zwei Unterschiede zwischen Kontextwechseln.  Eine davon ist die einfache Code-Bereinigung und die andere ist die teilweise Fehlerkorrektur. <br><br><ul><li>  <code>_last_task_used_math</code> als Eingabevariable gelöscht, da das Symbol bereits im globalen Bereich verfügbar ist.  Die entsprechende Vergleichsoperation wurde in eine direkte Verknüpfung geändert. <br></li><li>  Der <code>xchgl</code> Befehl wurde mit <code>movw</code> ausgetauscht, um ihn näher an den Hardware-Kontextschalter ( <code>ljmp</code> ) zu bringen.  Das Problem ist, dass diese Operationen nicht atomar sind: Es ist unwahrscheinlich, dass ein Interrupt zwischen <code>xchgl</code> und <code>ljmp</code> , der zu einem weiteren Kontextwechsel mit der falschen <code>current</code> Aufgabe und dem nicht gespeicherten Status der realen Aufgabe führt.  Das Ersetzen dieser Anweisungen macht diese Situation sehr unwahrscheinlich.  In einem lang laufenden System ist dies jedoch "sehr unwahrscheinlich" - ein Synonym für "unvermeidlich". </li></ul><br><a name="2"></a><h1>  Linux 1.x: Proof of Concept </h1><br>  Ungefähr 20 Patches wurden in ungefähr einem Jahr zwischen 0,11 und 1,0 veröffentlicht.  Der größte Teil der Bemühungen konzentrierte sich auf Treiber, Funktionen für Benutzer und Entwickler.  Die maximale Anzahl von Aufgaben wurde auf 128 erhöht, es wurden jedoch nicht viele grundlegende Änderungen am Kontextwechsel vorgenommen. <br><br><h2>  Linux 1.0 </h2><br>  Linux 1.0 läuft immer noch auf derselben CPU mit einem Prozess, wobei die Hardware-Kontextumschaltung verwendet wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/963/c40/196/963c40196485c16d16d5d53c8d15c910.png"><br><br>  <b>Linux 1.0</b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/linux/sched.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(tsk) __asm__(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmpl %%ecx,_current\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"je 1f\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cli\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"xchgl %%ecx,_current\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ljmp %0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sti\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmpl %%ecx,_last_task_used_math\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jne 1f\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"clts\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1:"</span></span></span><span class="hljs-meta"> : </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* no output */</span></span></span><span class="hljs-meta"> :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (*(((char *)&amp;tsk-&gt;tss.tr)-4)), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"c"</span></span></span><span class="hljs-meta"> (tsk) :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cx"</span></span></span><span class="hljs-meta">)</span></span></code> </pre> <br>  Die wichtigste Änderung war, dass das Eingabeargument nicht mehr der Tasknummernindex für das Array von task_struct-Strukturen ist.  Jetzt zeigt <code>switch_to()</code> auf eine neue Aufgabe.  Sie können also die <code>__tmp</code> Struktur entfernen und stattdessen einen direkten Link zu TSS verwenden.  Lassen Sie uns jede Zeile analysieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(tsk)</span></span></code> </pre> <br>  Die Eingabe ist jetzt ein Zeiger auf task_struct der nächsten Aufgabe. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"__asm__("</span></span>cmpl %%ecx,_current\n\t<span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br>  Nicht geändert.  Überprüft, ob die Eingabeaufgabe bereits aktuell ist, sodass kein Schalter erforderlich ist. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"je 1f\n\t"</span></span></code> </pre> <br>  Nicht geändert.  Überspringen Sie die Kontextumschaltung, wenn keine Umschaltung vorhanden ist. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"cli\n\t"</span></span></code> </pre> <br>  Deaktiviert Interrupts, damit der Timer (oder eine andere Person) nicht zwischen dem Aktualisieren einer globalen Aufgabe und dem Umschalten des Hardwarekontexts abstürzt.  Dieser Interrupt-Banhammer löst das Problem früherer Kernel-Versionen, indem die folgenden zwei Anweisungen (Pseudo) atomar gemacht werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"xchgl %%ecx,_current\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"ljmp %0\n\t"</span></span></code> </pre> <br>  Keine Änderung: Tauschen Sie den aktuellen Prozess aus, um die neue Aufgabe widerzuspiegeln, und rufen Sie den Hardwarekontextschalter auf. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"sti\n\t"</span></span></code> </pre> <br>  Schaltet Interrupts wieder ein. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"cmpl %%ecx,_last_task_used_math\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"jne 1f\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"clts\n"</span></span> <span class="hljs-string"><span class="hljs-string">"1:"</span></span></code> </pre> <br>  Im Vergleich zu Linux 0.11 ist alles unverändert.  Verwaltet das TS-Register und überwacht das Löschen des mathematischen Coprozessors von der vorherigen Aufgabe. <br><br><pre> <code class="cpp hljs">: <span class="hljs-comment"><span class="hljs-comment">/* no output */</span></span></code> </pre> <br>  Dieser eingebaute Assembler hat keine Ausgabe - jemand war sichtlich verärgert über das Fehlen von Kommentaren in früheren Versionen des Kernels. <br><br><pre> <code class="cpp hljs">:<span class="hljs-string"><span class="hljs-string">"m"</span></span> (*(((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;tsk-&gt;tss.tr)<span class="hljs-number"><span class="hljs-number">-4</span></span>)),</code> </pre> <br>  Lädt einen Segmentselektor für den TSS-Deskriptor einer neuen Aufgabe, auf den jetzt direkt über den Zeiger task_struct zugegriffen werden kann.  Das Element <code>tss.tr</code> enthält _TSS (task_number) als Referenz auf den GDT / TSS-Speicher, der vor 1.0 im Kernel verwendet wurde.  Wir fallen immer noch um 4 Bytes zurück und laden einen 6-Byte-Segment-Selektor, um die obersten zwei Bytes zu übernehmen.  Viel Spaß! <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"c"</span></span> (tsk)</code> </pre> <br>  Fast unverändert - jetzt laden wir den Zeiger direkt und suchen nicht nach dem Index. <br><br><pre> <code class="cpp hljs">:<span class="hljs-string"><span class="hljs-string">"cx"</span></span>)</code> </pre> <br>  Die Kontextumschaltung blockiert das ECX-Register. <br><br><h2>  Linux 1.3 </h2><br>  Der Kernel unterstützt jetzt mehrere neue Architekturen: Alpha, MIPS und SPARC.  Daher gibt es vier verschiedene Versionen von <code>switch_to()</code> , von denen eine beim Kompilieren des Kernels enthalten ist.  Der architekturspezifische Code wurde vom Kernel getrennt, daher müssen Sie an anderer Stelle nach der x86-Version suchen. <br><br>  <b>Linux 1.3</b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/asm-i386/system.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(tsk) do { __asm__(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cli\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"xchgl %%ecx,_current\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ljmp %0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sti\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmpl %%ecx,_last_task_used_math\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jne 1f\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"clts\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1:"</span></span></span><span class="hljs-meta"> : </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* no output */</span></span></span><span class="hljs-meta"> :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (*(((char *)&amp;tsk-&gt;tss.tr)-4)), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"c"</span></span></span><span class="hljs-meta"> (tsk) :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cx"</span></span></span><span class="hljs-meta">); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Now maybe reload the debug registers */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(current-&gt;debugreg[7]){ loaddebug(0); loaddebug(1); loaddebug(2); loaddebug(3); loaddebug(6); } } while (0)</span></span></code> </pre> <br>  Ein paar kleine Änderungen: Der gesamte Kontextschalter ist in eine gefälschte Do-While-Schleife eingeschlossen.  Feykov, weil er nie wiederholt.  Die Prüfung für den Wechsel zu einer neuen Aufgabe wurde in C von <code>switch_to()</code> zu Sheduler-Code verschoben. Einige Debugging-Aufgaben wurden von C-Code zu <code>switch_to ()</code> , wahrscheinlich um eine Trennung zu vermeiden.  Schauen wir uns die Änderungen an. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(tsk) do {</span></span></code> </pre> <br>  Jetzt wird <code>switch_to()</code> in eine do-while (0) -Schleife eingeschlossen.  Dieses Design verhindert Fehler, wenn das Makro aufgrund der Bedingung (falls vorhanden) auf mehrere Anweisungen erweitert wird.  Derzeit ist dies nicht der Fall, aber angesichts der Änderungen im Scheduler vermute ich, dass dies das Ergebnis der Bearbeitung des Codes ist, nur für den Fall.  Meine Vermutung: <br><br>  <b>Echter Planer in 1.3</b> <br><pre> <code class="cpp hljs">...<span class="hljs-function"><span class="hljs-function">within </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">schedule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(current == next)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span></span>; kstat.context_swtch++; switch_to(next);</code> </pre> <br>  <b>Eine mögliche Option, die switch_to () bricht</b> <br><pre> <code class="cpp hljs">...<span class="hljs-function"><span class="hljs-function">within </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">schedule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(current != next)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">switch_to</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* do-while(0) 'captures' entire * block to ensure proper parse */</span></span></code> </pre> <br><br><pre> <code class="cpp hljs">__asm__(<span class="hljs-string"><span class="hljs-string">"cli\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"xchgl %%ecx,_current\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"ljmp %0\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"sti\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"cmpl %%ecx,_last_task_used_math\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"jne 1f\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"clts\n"</span></span> <span class="hljs-string"><span class="hljs-string">"1:"</span></span> : <span class="hljs-comment"><span class="hljs-comment">/* no output */</span></span> :<span class="hljs-string"><span class="hljs-string">"m"</span></span> (*(((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;tsk-&gt;tss.tr)<span class="hljs-number"><span class="hljs-number">-4</span></span>)), <span class="hljs-string"><span class="hljs-string">"c"</span></span> (tsk) :<span class="hljs-string"><span class="hljs-string">"cx"</span></span>);</code> </pre> <br>  Keine Änderung gegenüber Linux 1.0.  Interrupts werden jedoch deaktiviert, bevor der * task_struct-Wechsel von <code>current</code> , dann die Hardware-Kontextumschaltung funktioniert und die Verwendung des Coprozessors überprüft wird. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Now maybe reload the debug registers */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(current-&gt;debugreg[<span class="hljs-number"><span class="hljs-number">7</span></span>]){</code> </pre> <br>  Überprüft die Debugging-Steuerung auf einen neuen Prozess für aktives ptrace (eine Adresse ungleich Null bedeutet hier aktives ptrace).  Das Debug-Tracking wurde nach <code>switch_to()</code> .  Genau die gleiche Sequenz C wird in 1.0 verwendet.  Ich nehme an, die Entwickler wollten sicherstellen, dass: 1) das Debuggen so nah wie möglich am Kontextschalter ist 2) switch_to das neueste im <code>schedule()</code> . <br><br><pre> <code class="cpp hljs">loaddebug(<span class="hljs-number"><span class="hljs-number">0</span></span>); loaddebug(<span class="hljs-number"><span class="hljs-number">1</span></span>); loaddebug(<span class="hljs-number"><span class="hljs-number">2</span></span>); loaddebug(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Stellt Debug-Haltepunktregister aus einem gespeicherten ptrace-Status wieder her. <br><br><pre> <code class="cpp hljs">loaddebug(<span class="hljs-number"><span class="hljs-number">6</span></span>);</code> </pre> <br>  Stellt das Debug-Steuerregister aus dem gespeicherten ptrace-Status wieder her. <br><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Schließt den Block <code>switch_to()</code> .  Obwohl die Bedingung immer dieselbe ist, stellt dies sicher, dass der Parser die Funktion als Basiseinheit übernimmt, die nicht mit benachbarten Bedingungen in <code>schedule()</code> interagiert.  Beachten Sie das Fehlen eines Kommas am Ende - es steht nach dem Makroaufruf: <code>switch_to(next);</code>  . <br><br><a name="3"></a><h1>  Linux 2.0: Kandidat (1996) </h1><br>  Im Juni 1996 wurde der Kernel auf Version 2.0 aktualisiert und eine 15-jährige Odyssee unter dieser Hauptversion gestartet, die mit einer breiten kommerziellen Unterstützung endete.  In 2.x wurden fast alle grundlegenden Systeme im Kernel radikal verändert.  Berücksichtigen Sie alle Nebenversionen vor 2.6.  Version 2.6 wurde so lange entwickelt, dass es einen separaten Abschnitt verdient. <br><br><h2>  Linux 2.0 </h2><br>  Linux 2.0 begann mit einer grundlegenden Innovation: <b>Multiprocessing</b> !  Zwei oder mehr Prozessoren können gleichzeitig Benutzer- / Kernelcode verarbeiten.  Dies erforderte natürlich einige Verfeinerung.  Beispielsweise verfügt jeder Prozessor jetzt über einen dedizierten Interrupt-Controller (APIC), sodass Interrupts auf jedem Prozessor separat verwaltet werden müssen.  Mechanismen wie Timer-Unterbrechungen müssen überarbeitet werden (das Deaktivieren von Interrupts betrifft nur einen Prozessor).  Die Synchronisierung ist schwierig, insbesondere wenn versucht wird, sie auf eine bereits große und nicht verwandte Codebasis anzuwenden.  Linux 2.0 legt den Grundstein für eine große Kernel-Sperre (BKL) ... Sie müssen irgendwo anfangen. <br><br>  Jetzt haben wir zwei Versionen von <code>switch_to()</code> : die Einzelprozessorversion (UP) von Linux 1.x und die neue verbesserte Version für symmetrisches Multiprocessing (SMP).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betrachten Sie zunächst die Änderungen im alten Code, da einige Änderungen von dort auch in der SMP-Version enthalten sind. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 2.0.1: Uniprozessor-Version (UP) </font></font></h2><br><img src="https://habrastorage.org/getpro/habr/post_images/e0c/ac1/b5c/e0cac1b5c0c3b269808a36f947528f9f.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.0.1 (UP)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/asm-i386/system.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Single process only (not SMP) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev,next) do { __asm__(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl %2,"</span></span></span><span class="hljs-meta">SYMBOL_NAME_STR(current_set)</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ljmp %0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmpl %1,"</span></span></span><span class="hljs-meta">SYMBOL_NAME_STR(last_task_used_math)</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jne 1f\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"clts\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1:"</span></span></span><span class="hljs-meta"> : </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* no outputs */</span></span></span><span class="hljs-meta"> :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (*(((char *)&amp;next-&gt;tss.tr)-4)), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r"</span></span></span><span class="hljs-meta"> (prev), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r"</span></span></span><span class="hljs-meta"> (next)); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Now maybe reload the debug registers */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(prev-&gt;debugreg[7]){ loaddebug(prev,0); loaddebug(prev,1); loaddebug(prev,2); loaddebug(prev,3); loaddebug(prev,6); } } while (0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zwei Änderungen sind sofort ersichtlich: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U </font></font><code>switch_to()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hat ein neues Argument: den Prozess, von dem </font></font><code>*task_struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir wechseln.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Makro für die korrekte Verarbeitung von Zeichen im eingebauten Assembler. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gehen wir wie gewohnt in die richtige Richtung und besprechen die Änderungen. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev,next) do {</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Argument </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definiert die Aufgabe, von der wir wechseln ( </font></font><code>*task_struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Wir wickeln das Makro immer noch in eine do-while (0) -Schleife ein, um einzeilige ifs um das Makro herum zu analysieren.</font></font><br><br><pre> <code class="cpp hljs">__asm__(<span class="hljs-string"><span class="hljs-string">"movl %2,"</span></span>SYMBOL_NAME_STR(current_set)<span class="hljs-string"><span class="hljs-string">"\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert die aktuell aktive Aufgabe auf die neu ausgewählte. </font><font style="vertical-align: inherit;">Dies ist funktional äquivalent </font></font><code>xchgl %%ecx,_current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, außer dass wir jetzt ein Array mit mehreren task_struct und ein macro ( </font></font><code>SYMBOL_NAME_STR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) zum Verarbeiten eingebetteter Assembly-Zeichen haben. </font><font style="vertical-align: inherit;">Warum dafür einen Präprozessor verwenden? </font><font style="vertical-align: inherit;">Tatsache ist, dass einige Assembler (GAS) das Hinzufügen eines Unterstrichs (_) zum Variablennamen C erfordern. Andere Assembler haben diese Anforderung nicht. </font><font style="vertical-align: inherit;">Um eine Konvention nicht auf einer Festplatte zu speichern, können Sie sie zur Kompilierungszeit entsprechend Ihren Tools konfigurieren.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"ljmp %0\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"cmpl %1,"</span></span>SYMBOL_NAME_STR(last_task_used_math)<span class="hljs-string"><span class="hljs-string">"\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"jne 1f\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"clts\n"</span></span> <span class="hljs-string"><span class="hljs-string">"1:"</span></span> : <span class="hljs-comment"><span class="hljs-comment">/* no outputs */</span></span> :<span class="hljs-string"><span class="hljs-string">"m"</span></span> (*(((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;next-&gt;tss.tr)<span class="hljs-number"><span class="hljs-number">-4</span></span>)),</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keine Änderungen, über die wir nicht gesprochen haben. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"r"</span></span> (prev), <span class="hljs-string"><span class="hljs-string">"r"</span></span> (next));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt tragen wir beide Aufgaben als Eingabe in den Inline-Assembler. </font><font style="vertical-align: inherit;">Eine geringfügige Änderung besteht darin, dass die Verwendung des Registers jetzt zulässig ist. </font><font style="vertical-align: inherit;">Es </font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wurde </font><font style="vertical-align: inherit;">zuvor </font><font style="vertical-align: inherit;">in ECX codiert.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Now maybe reload the debug registers */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(prev-&gt;debugreg[<span class="hljs-number"><span class="hljs-number">7</span></span>]){ loaddebug(prev,<span class="hljs-number"><span class="hljs-number">0</span></span>); loaddebug(prev,<span class="hljs-number"><span class="hljs-number">1</span></span>); loaddebug(prev,<span class="hljs-number"><span class="hljs-number">2</span></span>); loaddebug(prev,<span class="hljs-number"><span class="hljs-number">3</span></span>); loaddebug(prev,<span class="hljs-number"><span class="hljs-number">6</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alles ist genau wie in Kernel 1.3. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 2.0.1: Multiprozessor-Version (SMP) </font></font></h2><br><img src="https://habrastorage.org/getpro/habr/post_images/d40/32b/4ce/d4032b4ce288a06a189746c69757fd03.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.0.1 (SMP)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/asm-i386/system.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __SMP__ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Multiprocessing enabled */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev,next) do { cli(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(prev-&gt;flags&amp;PF_USEDFPU) { __asm__ __volatile__(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"fnsave %0"</span></span></span><span class="hljs-meta">:</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=m"</span></span></span><span class="hljs-meta"> (prev-&gt;tss.i387.hard)); __asm__ __volatile__(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"fwait"</span></span></span><span class="hljs-meta">); prev-&gt;flags&amp;=~PF_USEDFPU; } prev-&gt;lock_depth=syscall_count; kernel_counter+=next-&gt;lock_depth-prev-&gt;lock_depth; syscall_count=next-&gt;lock_depth; __asm__(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%edx\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl "</span></span></span><span class="hljs-meta">SYMBOL_NAME_STR(apic_reg)</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">",%%edx\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl 0x20(%%edx), %%edx\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"shrl $22,%%edx\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"and $0x3C,%%edx\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl %%ecx,"</span></span></span><span class="hljs-meta">SYMBOL_NAME_STR(current_set)</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"(,%%edx)\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%edx\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ljmp %0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sti\n\t"</span></span></span><span class="hljs-meta"> : </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* no output */</span></span></span><span class="hljs-meta"> :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (*(((char *)&amp;next-&gt;tss.tr)-4)), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"c"</span></span></span><span class="hljs-meta"> (next)); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Now maybe reload the debug registers */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(prev-&gt;debugreg[7]){ loaddebug(prev,0); loaddebug(prev,1); loaddebug(prev,2); loaddebug(prev,3); loaddebug(prev,6); } } while (0)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was wird schon unverständlich? </font><font style="vertical-align: inherit;">Ich möchte sagen, dass es später besser wird, aber dies wird in der Welt von SMP nicht passieren. </font><font style="vertical-align: inherit;">Aus Platzgründen werde ich keine unveränderten Zeichenfolgen mehr auflisten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drei Ergänzungen für den SMP-Kontextwechsel: 1) Ändern der Funktionsweise eines einzelnen Coprozessors mit mehreren Prozessoren; </font><font style="vertical-align: inherit;">2) Steuern der Sperrtiefe, da die Kernelsperre rekursiv ist; </font><font style="vertical-align: inherit;">3) Verknüpfen Sie mit APIC, um die CPU-ID für das aktuelle * task_struct abzurufen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(prev-&gt;flags&amp;PF_USEDFPU)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überprüft, ob für die Aufgabe, zu der wir wechseln, ein Coprozessor verwendet wurde. </font><font style="vertical-align: inherit;">Wenn ja, müssen Sie den Kontext in der FPU erfassen, bevor Sie wechseln.</font></font><br><br><pre> <code class="cpp hljs">__asm__ __volatile__(<span class="hljs-string"><span class="hljs-string">"fnsave %0"</span></span>:<span class="hljs-string"><span class="hljs-string">"=m"</span></span> (prev-&gt;tss.i387.hard));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichert den FPU-Status in TSS. </font><font style="vertical-align: inherit;">Mit FNSAVE wird die Ausnahmebehandlung übersprungen. </font></font><code>__volatile__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte diese Anweisung vor Änderungen durch den Optimierer schützen.</font></font><br><br><pre> <code class="cpp hljs">__asm__ __volatile__(<span class="hljs-string"><span class="hljs-string">"fwait"</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warten auf die CPU, während die FPU mit dem vorherigen Speichern beschäftigt ist. </font></font><br><br><pre> <code class="cpp hljs">prev-&gt;flags&amp;=~PF_USEDFPU;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deaktiviert das Flag für die Verwendung eines Coprozessors für diese Aufgabe. Es gibt immer Null. </font></font><br><br><pre> <code class="cpp hljs">prev-&gt;lock_depth=syscall_count;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichert die Anzahl der verschachtelten Verwendungen der Kernel-Sperre für eine alte Aufgabe. </font></font><br><br><pre> <code class="cpp hljs">kernel_counter+=next-&gt;lock_depth-prev-&gt;lock_depth;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert den globalen Kernel-Sperrzähler auf die nächste Aufgabe abzüglich der alten Aufgabe. </font><font style="vertical-align: inherit;">Entfernt effektiv die Sperre von der jetzt inaktiven alten Aufgabe, und die neue Aufgabe kann an der Stelle weiterarbeiten, an der sie gestoppt wurde.</font></font><br><br><pre> <code class="cpp hljs">syscall_count=next-&gt;lock_depth;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt den Sperrstatus einer neuen Aufgabe zurück. </font><font style="vertical-align: inherit;">Es sollte dort sein, wo sie in der letzten Zeit aufgehört hat.</font></font><br><br><pre> <code class="cpp hljs">__asm__(<span class="hljs-string"><span class="hljs-string">"pushl %%edx\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden EDX verwenden, damit wir den aktuellen Wert beibehalten. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movl "</span></span>SYMBOL_NAME_STR(apic_reg)<span class="hljs-string"><span class="hljs-string">",%%edx\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschiebt die APIC-E / A-Adresse nach EDX. </font><font style="vertical-align: inherit;">Wir müssen APIC verwenden, um die CPU-ID zu erhalten, da wir nicht wissen, welcher Prozessor funktioniert. </font></font><code>apic_reg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Broadcast während der Betriebssysteminitialisierung.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movl 0x20(%%edx), %%edx\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referenziert den Wert des APIC-Identifikatorregisters im EDX. </font><font style="vertical-align: inherit;">Die tatsächliche ID befindet sich in den Bits 24-27.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b78/a09/fe4/b78a09fe454c84ff075d4a9d5759bbd7.png"><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"shrl $22,%%edx\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschiebt die APIC-ID auf die Bits 2-5. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"and $0x3C,%%edx\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maskiert nur die APIC-ID in den Bits 2-5 und belässt die CPU-Nummer * 4. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movl %%ecx,"</span></span>SYMBOL_NAME_STR(current_set)<span class="hljs-string"><span class="hljs-string">"(,%%edx)\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert den Aufgabenzeiger der aktuellen CPU auf die nächste Aufgabe. </font><font style="vertical-align: inherit;">Die UP-Version hat die spezifische Verwendung von ECX zum Speichern der aktuellen Aufgabe bereits entfernt, wird jedoch weiterhin in der SMP-Version verwendet. </font><font style="vertical-align: inherit;">EDX enthält die CPU-Nummer in den Bits 2-5, multipliziert mit 4, im Maßstab, um die Zeigergröße von _current_set zu versetzen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"popl %%edx\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind mit EDX fertig und werden den Wert wiederherstellen, der vor diesem Verfahren war. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Rest der Zeilen ist der gleiche.</font></font><br><br><a name="4"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 2.2 (1999) </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Warten auf Linux 2.2 hat sich wirklich gelohnt: Hier kam der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Software-Kontextwechsel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">Wir verwenden weiterhin das Taskregister (TR), um auf TSS zu verweisen. </font><font style="vertical-align: inherit;">SMP- und UP-Prozeduren werden mit einer einheitlichen FPU-Statusverarbeitung kombiniert. </font><font style="vertical-align: inherit;">Die meisten Kontextwechsel werden jetzt in C. </font><b><font style="vertical-align: inherit;">Linux 2.2.0-</font></b><font style="vertical-align: inherit;"> Code </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/cfd/c33/992/cfdc33992fee3168758bf99d6abe0698.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(integrierter Assembler) durchgeführt.</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/asm-i386/system.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev,next) do { unsigned long eax, edx, ecx; asm volatile(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%ebx\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%esi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%edi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%ebp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl %%esp,%0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* save ESP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl %5,%%esp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore ESP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl $1f,%1\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* save EIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %6\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore EIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jmp __switch_to\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1:\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%ebp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%edi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%esi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%ebx"</span></span></span><span class="hljs-meta"> :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=m"</span></span></span><span class="hljs-meta"> (prev-&gt;tss.esp),</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=m"</span></span></span><span class="hljs-meta"> (prev-&gt;tss.eip), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=a"</span></span></span><span class="hljs-meta"> (eax), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=d"</span></span></span><span class="hljs-meta"> (edx), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=c"</span></span></span><span class="hljs-meta"> (ecx) :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (next-&gt;tss.esp),</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (next-&gt;tss.eip), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"a"</span></span></span><span class="hljs-meta"> (prev), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"d"</span></span></span><span class="hljs-meta"> (next)); } while (0)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses neue </font></font><code>switch_to()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unterscheidet </font><font style="vertical-align: inherit;">sich </font><font style="vertical-align: inherit;">grundlegend von allen vorherigen Versionen: Es ist einfach! </font><font style="vertical-align: inherit;">Im eingebauten Assembler tauschen wir die Stapel- und Anweisungszeiger aus (Kontextwechselaufgaben 1 und 2). </font><font style="vertical-align: inherit;">Alles andere wird erledigt, nachdem Sie zum C ( </font></font><code>__switch_to()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) - </font><font style="vertical-align: inherit;">Code gegangen sind </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"pushl %%ebx\n\t"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"pushl %%esi\n\t"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"pushl %%edi\n\t"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"pushl %%ebp\n\t"</span></span></span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichert EBX, ESI, EDI und EBP im Stapel des Prozesses, den wir tauschen werden. </font><font style="vertical-align: inherit;">(... warum EBX?)</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movl %%esp,%0\n\t"</span></span> <span class="hljs-comment"><span class="hljs-comment">/* save ESP */</span></span> <span class="hljs-string"><span class="hljs-string">"movl %5,%%esp\n\t"</span></span> <span class="hljs-comment"><span class="hljs-comment">/* restore ESP */</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie den Kommentaren entnehmen können, tauschen wir Stapelzeiger zwischen dem alten und dem neuen Prozess aus. </font><font style="vertical-align: inherit;">Der alte Prozess hat den Operanden% 0 ( </font></font><code>prev-&gt;tss.esp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), während der neue </font><font style="vertical-align: inherit;">Prozess </font><font style="vertical-align: inherit;">% 5 ( </font></font><code>next-&gt;tss.esp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) hat.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movl $1f,%1\n\t"</span></span> <span class="hljs-comment"><span class="hljs-comment">/* save EIP */</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern des Werts des Befehlszeigers für den nächsten Befehl der alten Aufgabe nach dem Zurückschalten des Kontexts. </font><font style="vertical-align: inherit;">Beachten Sie, dass der Wert der folgenden Anweisung eine Bezeichnung verwendet </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"pushl %6\n\t"</span></span> <span class="hljs-comment"><span class="hljs-comment">/* restore EIP */</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bereiten Sie die folgenden Anweisungen für eine neue Aufgabe vor. </font><font style="vertical-align: inherit;">Da wir gerade zu einem neuen Stapel gewechselt haben, wird diese IP aus dem TSS der neuen Aufgabe entnommen und oben im Stapel platziert. </font><font style="vertical-align: inherit;">Die Ausführung beginnt mit der folgenden Anweisung nach 'ret' aus dem C-Code, den wir ausführen möchten.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"jmp __switch_to\n"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir fahren mit unserem neuen und verbesserten Software-Kontextwechsel fort (siehe unten). </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"popl %%ebp\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"popl %%edi\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"popl %%esi\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"popl %%ebx"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir stellen die Register vom Stapel in umgekehrter Reihenfolge wieder her, vermutlich nachdem wir in einem neuen Zeitintervall zur alten Task gewechselt haben. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.2.0 (C)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/i386/kernel/process.c */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __switch_to(struct task_struct *prev, struct task_struct *next) { <span class="hljs-comment"><span class="hljs-comment">/* Do the FPU save and set TS if it wasn't set before.. */</span></span> unlazy_fpu(prev); gdt_table[next-&gt;tss.tr &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>].b &amp;= <span class="hljs-number"><span class="hljs-number">0xfffffdff</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ltr %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">: :</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"g"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;next-&gt;tss.tr))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%fs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;tss.fs))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%gs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;tss.gs))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Re-load LDT if necessary */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;mm-&gt;segments != prev-&gt;mm-&gt;segments) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"lldt %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">: :</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"g"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;next-&gt;tss.ldt))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Re-load page tables */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> new_cr3 = next-&gt;tss.cr3; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cr3 != prev-&gt;tss.cr3) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %0,%%cr3"</span></span></span></span><span class="hljs-function"><span class="hljs-params">: :</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (new_cr3))</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Restore %fs and %gs. */</span></span> loadsegment(fs,next-&gt;tss.fs); loadsegment(gs,next-&gt;tss.gs); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;tss.debugreg[<span class="hljs-number"><span class="hljs-number">7</span></span>]){ loaddebug(next,<span class="hljs-number"><span class="hljs-number">0</span></span>); loaddebug(next,<span class="hljs-number"><span class="hljs-number">1</span></span>); loaddebug(next,<span class="hljs-number"><span class="hljs-number">2</span></span>); loaddebug(next,<span class="hljs-number"><span class="hljs-number">3</span></span>); loaddebug(next,<span class="hljs-number"><span class="hljs-number">6</span></span>); loaddebug(next,<span class="hljs-number"><span class="hljs-number">7</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Software-Kontextwechsel wurde der alte Übergang zum TSS-Deskriptor durch den Übergang zur neuen C: -Funktion ersetzt </font></font><code>__switch_to()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Funktion ist in C geschrieben und enthält mehrere bekannte Komponenten, z. B. Debug-Register. </font><font style="vertical-align: inherit;">Wenn Sie zu C gehen, können Sie sie noch näher an den Kontextwechsel verschieben.</font></font><br><br><pre> <code class="cpp hljs">unlazy_fpu(prev);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir überprüfen die Verwendung der FPU und speichern ihren Status, falls verwendet. </font><font style="vertical-align: inherit;">Dies geschieht nun für jeden Prozess, bei dem die FPU verwendet wurde, sodass die Reinigung nicht mehr verzögert ist. </font><font style="vertical-align: inherit;">Die Vorgehensweise ist dieselbe wie bei der SMP-Routine ab 2.0.1, außer dass wir jetzt ein sauberes Makro haben, das die manuelle TS-Optimierung enthält.</font></font><br><br><pre> <code class="cpp hljs">gdt_table[next-&gt;tss.tr &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>].b &amp;= <span class="hljs-number"><span class="hljs-number">0xfffffdff</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Löscht das BUSY-Bit für einen zukünftigen Task-Deskriptor. </font><font style="vertical-align: inherit;">Verwendet die Aufgabennummer, um die GDT zu indizieren. </font></font><code>tss.tr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält den Wert des Task-Segment-Selektors, wobei die unteren drei Bits für Berechtigungen verwendet werden. </font><font style="vertical-align: inherit;">Wir brauchen nur einen Index, also verschieben wir diese Bits. </font><font style="vertical-align: inherit;">Das zweite TSS-Byte wird geändert, um Bit 10 zu entfernen.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e76/93f/c83/e7693fc83518201122914c5854f59de1.png"><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ltr %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">: :</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"g"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;next-&gt;tss.tr))</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Aufgabenregister wird mit einem Zeiger auf den nächsten Aufgabensegment-Selektor geladen. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%fs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;tss.fs))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%gs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;tss.gs))</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die FS- und GS-Segmentregister für die vorherige Aufgabe werden in TSS gespeichert. </font><font style="vertical-align: inherit;">Beim Hardware-Kontextwechsel wurde dieser Schritt automatisch ausgeführt, jetzt müssen wir dies jedoch manuell tun. </font><font style="vertical-align: inherit;">Aber warum? </font><font style="vertical-align: inherit;">Wie verwendet Linux FS und GS? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter Linux 2.2 (1999) gibt es keine klare Antwort. </font><font style="vertical-align: inherit;">Es wird nur gesagt, dass sie verwendet werden, daher sollten Sie sie speichern, damit sie zugänglich bleiben. </font><font style="vertical-align: inherit;">Der Kernel-Modus-Code "leiht" diese Segmente aus, um Kernel-Segmente oder Benutzerdaten anzuzeigen. </font><font style="vertical-align: inherit;">Sound- und Netzwerktreiber machen dasselbe. </font><font style="vertical-align: inherit;">In letzter Zeit (ab ~ 2,6) unterstützen FS und GS häufig lokale Stream-Speicher- und Datenbereiche pro Prozessor.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;mm-&gt;segments != prev-&gt;mm-&gt;segments) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"lldt %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">: :</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"g"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;next-&gt;tss.ldt))</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellt Segmente der lokalen Deskriptortabelle wieder her, wenn sie nicht bereits dem alten Prozess entsprechen. </font><font style="vertical-align: inherit;">Dies erfolgt durch Laden des LDT-Registers.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cr3 != prev-&gt;tss.cr3) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %0,%%cr3"</span></span></span></span><span class="hljs-function"><span class="hljs-params">: :</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (new_cr3))</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert den Status des virtuellen Speichers für eine neue Aufgabe. </font><font style="vertical-align: inherit;">Insbesondere wird das CR3-Register festgelegt, das ein Seitenverzeichnis für den Zugriff auf den Speicher in einem neuen Kontext enthält.</font></font><br><br><pre> <code class="cpp hljs">loadsegment(fs,next-&gt;tss.fs); loadsegment(gs,next-&gt;tss.gs);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FS und GS werden für eine neue Aufgabe wiederhergestellt. </font><font style="vertical-align: inherit;">Dies stellt die korrekte Ausrichtung sicher und im Falle eines Problems wird das Nullsegment geladen.</font></font><br><br><pre> <code class="cpp hljs">loaddebug(prev,<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schließlich wird das Debug-Steuerregister nun mit TSS gespeichert und umgeschaltet. </font><font style="vertical-align: inherit;">Bisher wurde dieses Register nur überprüft und nicht zur Speicherung verwendet.</font></font><br><br><a name="5"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 2.4 (2001) </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Version 2.4 wurden viele neue Funktionen eingeführt, z. B. Kernel-Threads und Task-Warteschlangen. </font><font style="vertical-align: inherit;">Trotz dieser und einiger Änderungen im Scheduler hat sich der Kontextwechsel im Vergleich zu Version 2.2 nicht wesentlich geändert, obwohl die Aktualisierung von TR zugunsten des Ersetzens aller Registerdaten eingestellt wurde. </font><font style="vertical-align: inherit;">Ich nenne es inoffiziell den "letzten Legacy-Kernel", da alle zukünftigen Versionen die 64-Bit-x86-Architektur verwenden. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9fe/47c/1cb/9fe47c1cbc25d24606a3622694edcafb.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.4.0 (eingebauter Assembler)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/asm-i386/system.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev,next,last) do { asm volatile(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%esi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%edi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%ebp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl %%esp,%0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* save ESP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl %3,%%esp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore ESP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl $1f,%1\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* save EIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %4\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore EIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jmp __switch_to\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1:\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%ebp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%edi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%esi\n\t"</span></span></span><span class="hljs-meta"> :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=m"</span></span></span><span class="hljs-meta"> (prev-&gt;thread.esp),</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=m"</span></span></span><span class="hljs-meta"> (prev-&gt;thread.eip), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=b"</span></span></span><span class="hljs-meta"> (last) :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (next-&gt;thread.esp),</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (next-&gt;thread.eip), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"a"</span></span></span><span class="hljs-meta"> (prev), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"d"</span></span></span><span class="hljs-meta"> (next), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"b"</span></span></span><span class="hljs-meta"> (prev)); } while (0)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Kontextwechsel im 2.4-Kernel nimmt nur wenige geringfügige Änderungen vor: EBX wird nicht mehr gepusht, sondern ist in der Ausgabe des integrierten Assemblers enthalten. </font><font style="vertical-align: inherit;">Es wurde ein neues Eingabeargument angezeigt </font></font><code>last</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das denselben Wert wie enthält </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es wird über EBX übertragen, aber nicht verwendet.</font></font><br><br><pre> <code class="cpp hljs">:<span class="hljs-string"><span class="hljs-string">"=m"</span></span> (prev-&gt;thread.esp),<span class="hljs-string"><span class="hljs-string">"=m"</span></span> (prev-&gt;thread.eip), :<span class="hljs-string"><span class="hljs-string">"m"</span></span> (next-&gt;thread.esp),<span class="hljs-string"><span class="hljs-string">"m"</span></span> (next-&gt;thread.eip),</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E / A-Operanden verweisen jetzt auf Stapel- / Befehlszeiger für Kernel-Threads. </font><font style="vertical-align: inherit;">Kontextschalter, die verwendet werden, um auf Stapelzeiger von TSS zu verweisen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.4.0 (C)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/i386/kernel/process.c */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __switch_to(struct task_struct *prev_p, struct task_struct *next_p) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init_tss</span></span></span><span class="hljs-class"> + </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">smp_processor_id</span></span></span><span class="hljs-class">();</span></span> unlazy_fpu(prev_p); tss-&gt;esp0 = next-&gt;esp0; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%fs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;fs))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%gs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;gs))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Restore %fs and %gs. */</span></span> loadsegment(fs, next-&gt;fs); loadsegment(gs, next-&gt;gs); <span class="hljs-comment"><span class="hljs-comment">/* Now maybe reload the debug registers */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;debugreg[<span class="hljs-number"><span class="hljs-number">7</span></span>]){ loaddebug(next, <span class="hljs-number"><span class="hljs-number">0</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">1</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">2</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* no 4 and 5 */</span></span> loaddebug(next, <span class="hljs-number"><span class="hljs-number">6</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">7</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prev-&gt;ioperm || next-&gt;ioperm) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;ioperm) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(tss-&gt;io_bitmap, next-&gt;io_bitmap, IO_BITMAP_SIZE*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)); tss-&gt;bitmap = IO_BITMAP_OFFSET; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tss-&gt;bitmap = INVALID_IO_BITMAP_OFFSET; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der C-Code-Teil hat einige Dinge geändert. </font><font style="vertical-align: inherit;">Jede Erwähnung des TR-Registers ist verschwunden, stattdessen ändern wir direkt das aktive TSS für den aktuellen Prozessor. </font><font style="vertical-align: inherit;">Wie im Inline-Assembler verweist jede Task auf TSS-Daten in thread_struct innerhalb von task_struct. </font><font style="vertical-align: inherit;">Jede aktive CPU verwendet dediziertes TSS von GDT und aktualisiert diese Felder direkt.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __switch_to(struct task_struct *prev_p, struct task_struct *next_p)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Den Zeigern der vorherigen und nächsten Aufgaben wurde ein Suffix hinzugefügt </font></font><code>_p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist eine kleine , </font><font style="vertical-align: inherit;">aber wichtige Nuance da </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu konvertieren , </font><font style="vertical-align: inherit;">um Kernel - </font><font style="vertical-align: inherit;">Threads gehen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeiger auf TSS-Daten für jede Aufgabe werden bestimmt. </font></font><br><br><pre> <code class="cpp hljs">tss-&gt;esp0 = next-&gt;esp0;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ersetzen des Stapelversatzrings 0 durch den Versatz der neuen Aufgabe. </font><font style="vertical-align: inherit;">Bis ein erneutes Laden der Seitentabelle erzwungen wird ...</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%fs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;fs))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%gs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;gs))</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern von FS und GS für die alte Aufgabe. </font><font style="vertical-align: inherit;">Der Zweck dieser Segmente ist immer noch unverständlich, aber sie werden irgendwie verwendet. </font><font style="vertical-align: inherit;">In Version 2.6 werden sie daher für den lokalen FS: Thread-Speicher und den GS: Pro-Prozessor-Datenbereich verwendet.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prev-&gt;ioperm || next-&gt;ioperm) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;ioperm) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(tss-&gt;io_bitmap, next-&gt;io_bitmap, IO_BITMAP_SIZE*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)); tss-&gt;bitmap = IO_BITMAP_OFFSET;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Legt die Portzuordnungs-E / A-Berechtigungen im aktiven TSS für die bevorstehende Aufgabe fest. </font></font><br><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tss-&gt;bitmap = INVALID_IO_BITMAP_OFFSET;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeigt die E / A-Berechtigungen für das aktive TSS für eine bekannte ungültige Bitmap (0x8000) an. </font></font><br><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 2.6: Popularität (2003) </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Als Kernel 2.5 abreiste, erreichte der Linear-Run-Scheduler die Grenze der praktischen Verwendung, und AMD veröffentlichte eine Erweiterung für x86, die die sofortige Aufmerksamkeit der Kernel-Entwickler erforderte: x86-64. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 2.6.0 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Kernel 2.6.0 wurde ein Kernel-Scheduler mit konstanter Laufzeit angezeigt. </font><font style="vertical-align: inherit;">Dies ist zwar ein Fortschritt gegenüber dem vorherigen linearen Scheduler, aber in 2.6.23 wurde er schließlich durch einen vollständig fairen Scheduler (CFS) ersetzt. </font><font style="vertical-align: inherit;">Andererseits hat die neue 64-Bit-Architektur die bislang bedeutendsten Änderungen vorgenommen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 2.6.0: i386 Version </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist das neueste Erscheinungsbild des 32-Bit-Kontextschalters im Artikel. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f7/832/9c5/8f78329c52340939baba3bedbbcdfa39.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.6.0 (i386 integrierter Assembler)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/asm-i386/system.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev,next,last) do { unsigned long esi,edi; asm volatile(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushfl\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%ebp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl %%esp,%0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* save ESP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl %5,%%esp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore ESP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl $1f,%1\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* save EIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %6\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore EIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jmp __switch_to\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1:\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%ebp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popfl"</span></span></span><span class="hljs-meta"> :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=m"</span></span></span><span class="hljs-meta"> (prev-&gt;thread.esp),</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=m"</span></span></span><span class="hljs-meta"> (prev-&gt;thread.eip), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=a"</span></span></span><span class="hljs-meta"> (last),</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=S"</span></span></span><span class="hljs-meta"> (esi),</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=D"</span></span></span><span class="hljs-meta"> (edi) :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (next-&gt;thread.esp),</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (next-&gt;thread.eip), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"2"</span></span></span><span class="hljs-meta"> (prev), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"d"</span></span></span><span class="hljs-meta"> (next)); } while (0)</span></span></code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vier Zeilen gelöscht. </font><font style="vertical-align: inherit;">ESI und EDI wurden zuvor auf den Stapel verschoben, werden jetzt jedoch über E / A-Operanden übertragen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.6.0 (i386 C)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/i386/kernel/process.c */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> * __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">switch_to</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cpu = smp_processor_id(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init_tss</span></span></span><span class="hljs-class"> + </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cpu</span></span></span><span class="hljs-class">;</span></span> __unlazy_fpu(prev_p); load_esp0(tss, next-&gt;esp0); <span class="hljs-comment"><span class="hljs-comment">/* Load the per-thread Thread-Local Storage descriptor. */</span></span> load_TLS(next, cpu); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%fs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;fs))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%gs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;gs))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Restore %fs and %gs if needed. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(prev-&gt;fs | prev-&gt;gs | next-&gt;fs | next-&gt;gs)) { loadsegment(fs, next-&gt;fs); loadsegment(gs, next-&gt;gs); } <span class="hljs-comment"><span class="hljs-comment">/* Now maybe reload the debug registers */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;debugreg[<span class="hljs-number"><span class="hljs-number">7</span></span>])) { loaddebug(next, <span class="hljs-number"><span class="hljs-number">0</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">1</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">2</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* no 4 and 5 */</span></span> loaddebug(next, <span class="hljs-number"><span class="hljs-number">6</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">7</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(prev-&gt;io_bitmap_ptr || next-&gt;io_bitmap_ptr)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;io_bitmap_ptr) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(tss-&gt;io_bitmap, next-&gt;io_bitmap_ptr, IO_BITMAP_BYTES); tss-&gt;io_bitmap_base = IO_BITMAP_OFFSET; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tss-&gt;io_bitmap_base = INVALID_IO_BITMAP_OFFSET; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev_p; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige interessante Änderungen: der von der Funktion zurückgegebene Wert und das Erscheinungsbild des Makros </font></font><code>unlikely()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich werde keine Änderungen an vorhandenem Code in [un] berücksichtigen, um ihn nicht noch einmal zu erklären. </font><font style="vertical-align: inherit;">Das Makro teilt dem Codegenerator einfach mit, welche Basiseinheit zuerst angezeigt werden soll, um das Pipelining zu unterstützen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">switch_to</span></span></span><span class="hljs-class">(...)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__switch_to gibt jetzt einen Zeiger auf eine alte Aufgabe zurück. </font><font style="vertical-align: inherit;">Dies wird nirgendwo verarbeitet, daher wurde entweder die Änderung gelöscht oder sie wollten der Konvention folgen. </font><font style="vertical-align: inherit;">Zum Beispiel die klassische Konvention, dass wir, wenn eine Funktion den Status ändert, den vorherigen Status zurückgeben, um ihn später zu speichern und wiederherzustellen. </font><font style="vertical-align: inherit;">Dies funktioniert zwar nicht.</font></font><br><br><pre> <code class="cpp hljs">load_TLS(next, cpu);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert die lokalen Thread-Store-Deskriptoren in GDT für eine neue Aufgabe. </font><font style="vertical-align: inherit;">Linux 2.6 führt drei TLS-Einträge in GDT für bestimmte Stream-Segmente ein. </font><font style="vertical-align: inherit;">Glibc verwendet also das erste Segment, Wine - das zweite. </font><font style="vertical-align: inherit;">Jetzt verwenden wir nacheinander das FS-Segmentregister, um nach Bedarf auf den lokalen Thread-Speicher zu verweisen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(prev-&gt;fs | prev-&gt;gs | next-&gt;fs | next-&gt;gs)) {</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt stellen wir nur FS und GS wieder her, wenn sie von der vorherigen oder nächsten Aufgabe verwendet wurden. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 2.6.0: x86_64 Version </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der x86_64-Kontextschalter unterscheidet sich erheblich vom 32-Bit-Kontextschalter. </font><font style="vertical-align: inherit;">Dieses Mal werden wir den Code sorgfältig studieren, da wir uns in Zukunft nur noch auf die 64-Bit-Version konzentrieren werden. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d8/26c/076/7d826c0761304c0e1b5ee41b42420fe3.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.6.0 (eingebauter Assembler x86_64)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/asm-x86_64/system.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SAVE_CONTEXT </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushfq ; pushq %%rbp ; movq %%rsi,%%rbp\n\t"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESTORE_CONTEXT </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %%rbp,%%rsi ; popq %%rbp ; popfq\n\t"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __EXTRA_CLOBBER ,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rcx"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rbx"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rdx"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r8"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r9"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r10"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r11"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r12"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r13"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r14"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r15"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev,next,last) asm volatile(SAVE_CONTEXT </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %%rsp,%P[threadrsp](%[prev])\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* save RSP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %P[threadrsp](%[next]),%%rsp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore RSP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"call __switch_to\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">".globl thread_return\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"thread_return:\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %%gs:%P[pda_pcurrent],%%rsi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %P[thread_info](%%rsi),%%r8\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"btr %[tif_fork],%P[ti_flags](%%r8)\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %%rax,%%rdi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jc ret_from_fork\n\t"</span></span></span><span class="hljs-meta"> RESTORE_CONTEXT : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=a"</span></span></span><span class="hljs-meta"> (last) : [next] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"S"</span></span></span><span class="hljs-meta"> (next), [prev] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"D"</span></span></span><span class="hljs-meta"> (prev), [threadrsp] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (offsetof(struct task_struct, thread.rsp)), [ti_flags] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (offsetof(struct thread_info, flags)), [tif_fork] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (TIF_FORK), [thread_info] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (offsetof(struct task_struct, thread_info)), [pda_pcurrent] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (offsetof(struct x8664_pda, pcurrent)) : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"memory"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cc"</span></span></span><span class="hljs-meta"> __EXTRA_CLOBBER)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Makro wurde in x86_64 aktualisiert </font></font><code>_switch_to()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, daher müssen Sie seine Zeilen erneut durchgehen. </font><font style="vertical-align: inherit;">Viele Änderungen sind einfach Registernamen ( </font></font><code>r..</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stattdessen </font></font><code>e..</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Es gibt einige andere Helfer, die ich oben angegeben habe.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SAVE_CONTEXT</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichert den Kernel-Kontext auf dem Stapel über das oben gezeigte Hilfsmakro. </font><font style="vertical-align: inherit;">Sehr ähnlich der 32-Bit-Version, mit Ausnahme der neuen Registernamen. </font><font style="vertical-align: inherit;">Das Makro wird am Ende des integrierten Assembler-Blocks mit RESTORE_CONTEXT gepaart.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movq %%rsp,%P[threadrsp](%[prev])\n\t"</span></span> <span class="hljs-comment"><span class="hljs-comment">/* save RSP */</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichert den aktuellen Stapelzeiger auf das TSS der alten Task. </font><font style="vertical-align: inherit;">Beachten Sie die neue Notation, die im Abschnitt </font></font><code>[threadrsp]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für Eingabeoperanden </font><font style="vertical-align: inherit;">definiert ist: Dies </font><font style="vertical-align: inherit;">ist der direkte Offset von thread.rsp in task_struct. </font></font><code>%P</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dereferenziert den prev: threadsp-Zeiger, um sicherzustellen, dass der aktualisierte SP ordnungsgemäß gespeichert wird.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movq %P[threadrsp](%[next]),%%rsp\n\t"</span></span> <span class="hljs-comment"><span class="hljs-comment">/* restore RSP */</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stellt den Stapelzeiger einer neuen Aufgabe wieder her. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"call __switch_to\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruft Teil C des Kontextwechsels auf. </font><font style="vertical-align: inherit;">Es wird im nächsten Abschnitt beschrieben.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">".globl thread_return\n"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definiert eine globale Bezeichnung </font></font><code>thread_return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"thread_return:\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übergangspunkt für </font></font><code>thread_return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Rein mechanisch sollte der Befehlszeiger ihm zum nächsten Befehl folgen. </font><font style="vertical-align: inherit;">Wird weder im Kernel noch in der Bibliothek verwendet (z. B. glibc). </font><font style="vertical-align: inherit;">Ich vermute, dass Pthreads es verwenden könnten ... aber es scheint nicht so zu sein.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movq %%gs:%P[pda_pcurrent],%%rsi\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legt den Index für die aktuelle Aufgabe fest, indem auf den Pro-Prozess-Datenbereich (PDA) verwiesen wird. </font><font style="vertical-align: inherit;">Im Kernelmodus sollte GS immer auf Daten für jeden Prozessor zeigen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movq %P[thread_info](%%rsi),%%r8\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschiebt die Struktur </font></font><code>thread_info</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach r8. </font><font style="vertical-align: inherit;">Dies ist neu in Linux 2.6 und im Wesentlichen eine leichte Version </font></font><code>task_struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die leicht auf den Stack passt.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"btr %[tif_fork],%P[ti_flags](%%r8)\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichert den Bitwert TIF_FORK in CF </font></font><code>thread_info-&gt;flags</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und setzt das Bit in der Struktur zurück. </font><font style="vertical-align: inherit;">Nach einigen Zeilen wird dieses Bit nach dem Fork / Cloning gesetzt und zum Ausführen von ret_from_fork verwendet.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movq %%rax,%%rdi\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichert den </font></font><code>task_struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorherigen Stream in der RDI. </font><font style="vertical-align: inherit;">Die letzte Anweisung, die mit EAX funktioniert </font></font><code>__switch_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">besteht darin, die C-Funktion aufzurufen </font><font style="vertical-align: inherit;">, die </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu EAX zurückkehrt.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"jc ret_from_fork\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn dieser Thread eine neue Gabel / ein neuer Klon ist, gehen Sie zu ret_from_fork, um erneut zu starten. </font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-string"><span class="hljs-string">"=a"</span></span> (last)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der vorherige Stream wird an EAX zurückgegeben. </font></font><br><br><pre> <code class="cpp hljs">: [next] <span class="hljs-string"><span class="hljs-string">"S"</span></span> (next), [prev] <span class="hljs-string"><span class="hljs-string">"D"</span></span> (prev), [threadrsp] <span class="hljs-string"><span class="hljs-string">"i"</span></span> (offsetof(struct task_struct, thread.rsp)), [ti_flags] <span class="hljs-string"><span class="hljs-string">"i"</span></span> (offsetof(struct thread_info, flags)), [tif_fork] <span class="hljs-string"><span class="hljs-string">"i"</span></span> (TIF_FORK), [thread_info] <span class="hljs-string"><span class="hljs-string">"i"</span></span> (offsetof(struct task_struct, thread_info)), [pda_pcurrent] <span class="hljs-string"><span class="hljs-string">"i"</span></span> (offsetof(struct x8664_pda, pcurrent))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingabelinks für Inline-Assembler. </font><font style="vertical-align: inherit;">Die meisten von ihnen sind direkte Operanden mit Offsets. </font><font style="vertical-align: inherit;">Oben haben wir sie bereits durchlaufen.</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-string"><span class="hljs-string">"memory"</span></span>, <span class="hljs-string"><span class="hljs-string">"cc"</span></span> __EXTRA_CLOBBER)</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.6.0 (x86_64 C)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/x86_64/kernel/process.c */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">switch_to</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cpu = smp_processor_id(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init_tss</span></span></span><span class="hljs-class"> + </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cpu</span></span></span><span class="hljs-class">;</span></span> unlazy_fpu(prev_p); tss-&gt;rsp0 = next-&gt;rsp0; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%es,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (prev-&gt;es))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;es | prev-&gt;es)) loadsegment(es, next-&gt;es); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%ds,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (prev-&gt;ds))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;ds | prev-&gt;ds)) loadsegment(ds, next-&gt;ds); load_TLS(next, cpu); <span class="hljs-comment"><span class="hljs-comment">/* Switch FS and GS. */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> fsindex; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%fs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=g"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (fsindex))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(fsindex | next-&gt;fsindex | prev-&gt;fs)) { loadsegment(fs, next-&gt;fsindex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fsindex) prev-&gt;fs = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* when next process has a 64bit base use it */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;fs) wrmsrl(MSR_FS_BASE, next-&gt;fs); prev-&gt;fsindex = fsindex; } { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> gsindex; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%gs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=g"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (gsindex))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(gsindex | next-&gt;gsindex | prev-&gt;gs)) { load_gs_index(next-&gt;gsindex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gsindex) prev-&gt;gs = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;gs) wrmsrl(MSR_KERNEL_GS_BASE, next-&gt;gs); prev-&gt;gsindex = gsindex; } <span class="hljs-comment"><span class="hljs-comment">/* Switch the PDA context. */</span></span> prev-&gt;userrsp = read_pda(oldrsp); write_pda(oldrsp, next-&gt;userrsp); write_pda(pcurrent, next_p); write_pda(kernelstack, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)next_p-&gt;thread_info + THREAD_SIZE - PDA_STACKOFFSET); <span class="hljs-comment"><span class="hljs-comment">/* Now maybe reload the debug registers */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;debugreg7)) { loaddebug(next, <span class="hljs-number"><span class="hljs-number">0</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">1</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">2</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* no 4 and 5 */</span></span> loaddebug(next, <span class="hljs-number"><span class="hljs-number">6</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">7</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* Handle the IO bitmap */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(prev-&gt;io_bitmap_ptr || next-&gt;io_bitmap_ptr)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;io_bitmap_ptr) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(tss-&gt;io_bitmap, next-&gt;io_bitmap_ptr, IO_BITMAP_BYTES); tss-&gt;io_bitmap_base = IO_BITMAP_OFFSET; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tss-&gt;io_bitmap_base = INVALID_IO_BITMAP_OFFSET; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev_p; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Version x86_64 wurden dem C-Kontextwechselcode mehrere Änderungen hinzugefügt. </font><font style="vertical-align: inherit;">Ich werde einfache Falländerungen nicht wiederholen (z. B. Umbenennen von EAX in RAX).</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%es,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (prev-&gt;es))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;es | prev-&gt;es)) loadsegment(es, next-&gt;es);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichert das ES-Segment für die alte Aufgabe und lädt dann bei Bedarf das neue. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%ds,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (prev-&gt;ds))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;ds | prev-&gt;ds)) loadsegment(ds, next-&gt;ds);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichert ein Datensegment für eine alte Aufgabe und lädt dann bei Bedarf ein neues. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> fsindex; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%fs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=g"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (fsindex))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(fsindex | next-&gt;fsindex | prev-&gt;fs)) { loadsegment(fs, next-&gt;fsindex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fsindex) prev-&gt;fs = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschiebt das FS-Segment nach </font></font><code>fsindex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und lädt den FS bei Bedarf für eine neue Aufgabe. </font><font style="vertical-align: inherit;">Wenn eine alte oder neue Aufgabe einen gültigen Wert für FS hat, wird im Prinzip etwas an seiner Stelle geladen (möglicherweise NULL). </font><font style="vertical-align: inherit;">FS wird normalerweise für die Speicherung lokaler Streams verwendet, es gibt jedoch auch andere Verwendungszwecke, je nachdem, wann eine Kontextumschaltung erfolgt. </font><font style="vertical-align: inherit;">Für GS wird genau derselbe Code verwendet, sodass keine Wiederholung erforderlich ist. </font><font style="vertical-align: inherit;">GS ist normalerweise ein Segment für </font></font><code>thread_info</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;fs) wrmsrl(MSR_FS_BASE, next-&gt;fs);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das FS-Register in der nächsten Aufgabe verwendet wird, müssen Sie überprüfen, ob der gesamte 64-Bit-Wert geschrieben ist. </font><font style="vertical-align: inherit;">Denken Sie daran, dass Segmentregister ein Artefakt der 16/32-Bit-Ära sind. Eine spezielle Funktion überprüft daher, ob die oberen 32 Bit geschrieben sind.</font></font><br><br><pre> <code class="cpp hljs">prev-&gt;fsindex = fsindex;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichern Sie FS für die alte Aufgabe. </font></font><br><br><pre> <code class="cpp hljs">prev-&gt;userrsp = read_pda(oldrsp); write_pda(oldrsp, next-&gt;userrsp); write_pda(pcurrent, next_p); write_pda(kernelstack, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)next_p-&gt;thread_info + THREAD_SIZE - PDA_STACKOFFSET);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisieren des PDA für eine bevorstehende Aufgabe, einschließlich Speichern des alten RSP (Syscall) der alten Aufgabe. </font><font style="vertical-align: inherit;">Der PDA wird mit Stream- und Stack-Informationen aktualisiert.</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 3.0: modernes Betriebssystem (2011) </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie sich von der Zahl nicht täuschen. </font><font style="vertical-align: inherit;">Tatsächlich wurde Version 3.0 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast 8 Jahre</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nach 2.6.0 veröffentlicht. </font><font style="vertical-align: inherit;">Eine Vielzahl von Änderungen verdient ein ganzes Buch, und ich kann Ihnen nicht alles erzählen. </font><font style="vertical-align: inherit;">Bei der Kontextumschaltung werden i386 und x86_64 in x86 mit separaten Prozessdateien (process_32.c und process_64.s) kombiniert. Dieser Artikel ist bereits zu umfangreich, sodass </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir die x86_64-Version erst später analysieren werden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir werden nur einige Details skizzieren und uns die neueste LTS genauer ansehen. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d0a/a82/1f5/d0aa821f59086dc1f0937e4139353fff.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 3.0.1 (eingebauter Assembler x86_64)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/x86/include/asm/system.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SAVE_CONTEXT </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushf ; pushq %%rbp ; movq %%rsi,%%rbp\n\t"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESTORE_CONTEXT </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %%rbp,%%rsi ; popq %%rbp ; popf\t"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __EXTRA_CLOBBER \ ,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rcx"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rbx"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rdx"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r8"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r9"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r10"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r11"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r12"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r13"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r14"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r15"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev, next, last) asm volatile(SAVE_CONTEXT </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %%rsp,%P[threadrsp](%[prev])\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* save RSP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %P[threadrsp](%[next]),%%rsp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore RSP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"call __switch_to\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq "</span></span></span><span class="hljs-meta">__percpu_arg([current_task])</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">",%%rsi\n\t"</span></span></span><span class="hljs-meta"> __switch_canary </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %P[thread_info](%%rsi),%%r8\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %%rax,%%rdi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"testl %[_tif_fork],%P[ti_flags](%%r8)\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jnz ret_from_fork\n\t"</span></span></span><span class="hljs-meta"> RESTORE_CONTEXT : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=a"</span></span></span><span class="hljs-meta"> (last) __switch_canary_oparam : [next] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"S"</span></span></span><span class="hljs-meta"> (next), [prev] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"D"</span></span></span><span class="hljs-meta"> (prev), [threadrsp] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (offsetof(struct task_struct, thread.sp)), [ti_flags] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (offsetof(struct thread_info, flags)), [_tif_fork] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (_TIF_FORK), [thread_info] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (offsetof(struct task_struct, stack)), [current_task] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (current_task) __switch_canary_iparam : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"memory"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cc"</span></span></span><span class="hljs-meta"> __EXTRA_CLOBBER)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acht Jahre - und </font></font><code>switch_to()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur vier Änderungen </font><font style="vertical-align: inherit;">im Makro </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zwei von ihnen sind miteinander verbunden und nichts radikal Neues.</font></font><br><br><pre> <code class="cpp hljs">movq <span class="hljs-string"><span class="hljs-string">"__percpu_arg([current_task])"</span></span>,%%rsi\n\t</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschiebt neue Naht </font></font><code>task_struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu RSI. </font><font style="vertical-align: inherit;">Dies ist die „neue“ Möglichkeit, auf Aufgabeninformationen zuzugreifen: Jede CPU verfügt über ein statisches Symbol. </font><font style="vertical-align: inherit;">Zuvor waren Informationen über GS verfügbar: [pda offset]. </font><font style="vertical-align: inherit;">Nachfolgende RSI-Vorgänge sind dieselben wie in Version 2.6.</font></font><br><br><pre> <code class="cpp hljs">__switch_canary</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit diesem Makro können Sie zusätzlich prüfen, ob das Makro CONFIG_CC_STACKPROTECTOR während der Kernelassemblierung aktiviert ist. </font><font style="vertical-align: inherit;">Ich werde dieses Thema nicht zu tief vertiefen, außer dass dieser Mechanismus vor der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zerstörung des Stapels durch Hacker</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schützt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tatsächlich speichern wir einen zufälligen Wert und überprüfen ihn später. </font><font style="vertical-align: inherit;">Wenn sich die Bedeutung geändert hat, bedeutet dies Ärger.</font></font><br><br><pre> <code class="cpp hljs">testl %[_tif_fork],%P[ti_flags](%%r8)\n\t jnz ret_from_fork\n\t</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überprüft, ob eine neue Aufgabe einfach mit Klonen / Fork erstellt wurde, und fährt dann mit fort </font></font><code>ret_from_fork()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Früher war dies eine Anweisung </font></font><code>btr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber jetzt verschieben wir das Zurücksetzen des Bits, bis der Aufruf endet. </font><font style="vertical-align: inherit;">Der Name wurde aufgrund einer Teständerung in JNZ geändert: Wenn das Bit gesetzt ist, ist TEST (AND) positiv.</font></font><br><br><pre> <code class="cpp hljs">__switch_canary_oparam</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ausgabe von Stack Canary für </font></font><code>CONFIG_CC_STACKPROTECTOR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs">__switch_canary_iparam</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input Stack Canary für </font></font><code>CONFIG_CC_STACKPROTECTOR</code> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 3.0.1 (x86_64 C)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/x86/kernel/process_64.c */</span></span> __notrace_funcgraph <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> * __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">switch_to</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cpu = smp_processor_id(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">per_cpu</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init_tss</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cpu</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> fsindex, gsindex; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> preload_fpu; preload_fpu = tsk_used_math(next_p) &amp;&amp; next_p-&gt;fpu_counter &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* we're going to use this soon, after a few expensive things */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preload_fpu) prefetch(next-&gt;fpu.state); <span class="hljs-comment"><span class="hljs-comment">/* Reload esp0, LDT and the page table pointer: */</span></span> load_sp0(tss, next); savesegment(es, prev-&gt;es); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;es | prev-&gt;es)) loadsegment(es, next-&gt;es); savesegment(ds, prev-&gt;ds); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;ds | prev-&gt;ds)) loadsegment(ds, next-&gt;ds); savesegment(fs, fsindex); savesegment(gs, gsindex); load_TLS(next, cpu); __unlazy_fpu(prev_p); <span class="hljs-comment"><span class="hljs-comment">/* Make sure cpu is ready for new context */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preload_fpu) clts(); arch_end_context_switch(next_p); <span class="hljs-comment"><span class="hljs-comment">/* Switch FS and GS. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(fsindex | next-&gt;fsindex | prev-&gt;fs)) { loadsegment(fs, next-&gt;fsindex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fsindex) prev-&gt;fs = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* when next process has a 64bit base use it */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;fs) wrmsrl(MSR_FS_BASE, next-&gt;fs); prev-&gt;fsindex = fsindex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(gsindex | next-&gt;gsindex | prev-&gt;gs)) { load_gs_index(next-&gt;gsindex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gsindex) prev-&gt;gs = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;gs) wrmsrl(MSR_KERNEL_GS_BASE, next-&gt;gs); prev-&gt;gsindex = gsindex; <span class="hljs-comment"><span class="hljs-comment">/* Switch the PDA and FPU contexts. */</span></span> prev-&gt;usersp = percpu_read(old_rsp); percpu_write(old_rsp, next-&gt;usersp); percpu_write(current_task, next_p); percpu_write(kernel_stack, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)task_stack_page(next_p) + THREAD_SIZE - KERNEL_STACK_OFFSET); <span class="hljs-comment"><span class="hljs-comment">/* Now maybe reload the debug registers and handle I/O bitmaps */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(task_thread_info(next_p)-&gt;flags &amp; _TIF_WORK_CTXSW_NEXT || task_thread_info(prev_p)-&gt;flags &amp; _TIF_WORK_CTXSW_PREV)) __switch_to_xtra(prev_p, next_p, tss); <span class="hljs-comment"><span class="hljs-comment">/* Preload the FPU context - task is likely to be using it. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preload_fpu) __math_state_restore(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev_p; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt einige Änderungen im C-Code, aber angesichts der acht Jahre zwischen den Veröffentlichungen sind sie relativ wenige. </font><font style="vertical-align: inherit;">Einige von ihnen sind beispielsweise kosmetischer Natur und stehen an der Spitze aller Erklärungen. </font><font style="vertical-align: inherit;">Folgendes hat sich geändert:</font></font><br><br><pre> <code class="cpp hljs">__notrace_funcgraph <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> * __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">switch_to</span></span></span><span class="hljs-class">(...)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine neue Signatur </font></font><code>__notrace_funcgraph</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verhindert, dass aktive ftrace verfolgt werden </font></font><code>switch_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs">preload_fpu = tsk_used_math(next_p) &amp;&amp; next_p-&gt;fpu_counter &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preload_fpu) prefetch(next-&gt;fpu.state);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Überprüft, ob die FPU in der letzten Aufgabe für die letzten 5 Zeitscheiben verwendet wurde, und versucht dann, die Daten für die spätere Verwendung zwischenzuspeichern. </font></font><br><br><pre> <code class="cpp hljs">load_sp0(tss, next);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lädt einen Kernel-Space-Stack-Zeiger, aktualisiert Seitentabellen und benachrichtigt den Hypervisor (falls zutreffend). </font></font><br><br><pre> <code class="cpp hljs">savesegment(es, prev-&gt;es);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichert das ES-Segment. </font><font style="vertical-align: inherit;">Dies ist keine Innovation, sondern nur ein Ersatz für den Inline-Assembler ab 2.6:</font></font><code>asm volatile("movl %%es,%0" : "=m" (prev-&gt;es));</code>  . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preload_fpu) clts();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startet die FPU sofort neu, wenn sie wahrscheinlich verwendet wird. </font><font style="vertical-align: inherit;">Anwendung </font></font><code>clts()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- die gleiche Idee , </font><font style="vertical-align: inherit;">dass wir mit der ersten Version des Linux sehen: </font></font><code>"cmpl %%ecx,%2\n\t jne 1f\n\t clts\n"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs">jne <span class="hljs-number"><span class="hljs-number">1f</span></span>\n\t clts\n<span class="hljs-string"><span class="hljs-string">" arch_end_context_switch(next_p);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur für die </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Virtualisierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> relevant </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Unter normalen Umständen macht eine Funktion </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nichts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Weitere Informationen finden Sie in der endgültigen Kernelversion.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(task_thread_info(next_p)-&gt;flags &amp; _TIF_WORK_CTXSW_NEXT || task_thread_info(prev_p)-&gt;flags &amp; _TIF_WORK_CTXSW_PREV)) __switch_to_xtra(prev_p, next_p, tss);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschäftigt sich mit Verwaltungsarbeiten, die zuvor am Ende beschrieben wurden </font></font><code>switch_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, einschließlich Debug-Registern und E / A-Bitmap-Parametern. </font><font style="vertical-align: inherit;">Wir werden Ihnen mehr darüber in der Codeüberprüfung 4.14.67 erzählen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preload_fpu) __math_state_restore();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellt die FPU wieder her, nachdem ihre Verwendung überprüft wurde. </font><font style="vertical-align: inherit;">Bei einer erfolgreichen Kombination von Umständen sollten sich die Daten dank der zuvor getroffenen Vorauswahl bereits im Cache befinden.</font></font><br><br><a name="8"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 4.14.67: neueste LTS (2018) </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist unser tiefstes Eintauchen in das Innenleben des Kontextwechsels. </font><font style="vertical-align: inherit;">Das Verfahren wurde seit der Veröffentlichung von 3.0 erheblich überarbeitet und der Code organisiert. </font><font style="vertical-align: inherit;">Insgesamt sieht es jetzt sauberer und organisierter aus als je zuvor. </font><font style="vertical-align: inherit;">Für x86_64:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/140/b4b/ca3/140b4bca3a13ffac5abe3a2b3e723dc0.png"><br><br><ul><li>   3.4    <code>switch_to()</code>     <a href="" rel="nofollow">arch/x86/include/asm/switch_to.h</a> .     ,   <code>context_switch()</code>  <a href="" rel="nofollow">kernel/sched/core.</a> . <br></li><li>    4.9 <code>switch_to()</code>    :  <code>prepare_switch_to()</code>          ( <a href="" rel="nofollow">arch/x86/entry/entry_64.S</a> ). <br></li><li>   C            .   2.6.24    <a href="" rel="nofollow">arch/x86/kernel/process_64.c</a> . </li></ul><br> <b>Linux 4.14.67</b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/x86/include/asm/switch_to.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev, next, last) do { prepare_switch_to(prev, next); ((last) = __switch_to_asm((prev), (next))); } while (0)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sieht im Vergleich zu alten Kerneln einfach aus. </font><font style="vertical-align: inherit;">Diese Reorganisation war das Ergebnis einer Lösung des Problems, als Andy Lutomirski </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">praktisch passende Kernel-Stacks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einführte </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs">prepare_switch_to(prev, next);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellt sicher, dass Kernelstapel verfügbar sind, bevor Sie versuchen, den Kontext zu wechseln. </font><font style="vertical-align: inherit;">Dies vermeidet einen möglichen Doppelfehler oder eine Kernel-Panik beim Versuch, den Kontext zu wechseln, wenn virtuell zugeordnete Kernel-Stapel verwendet werden.</font></font><br><br><pre> <code class="cpp hljs">((last) = __switch_to_asm((prev), (next)));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startet den eigentlichen Kontextwechsel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen Sie sich das an </font></font><code>prepare_switch_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das in derselben Quelldatei definiert ist. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 4.14.67</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/x86/include/asm/switch_to.h */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare_switch_to</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct task_struct *prev, struct task_struct *next)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_VMAP_STACK READ_ONCE(*(unsigned char *)next-&gt;thread.sp); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_VMAP_STACK</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bestimmt, wann der Stapel virtuellen Speicher verwendet. </font><font style="vertical-align: inherit;">Wir müssen uns nur dann auf den Kontextwechsel vorbereiten, wenn wir virtuelle Stapel verwenden. </font><font style="vertical-align: inherit;">Dies ist ein Konfigurationsparameter während der Kernel-Erstellung. </font><font style="vertical-align: inherit;">In vielen modernen Distributionen der Standardwert </font></font><code>yes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs">READ_ONCE(*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)next-&gt;thread.sp);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beziehen Sie sich auf den nächsten Stapel, um Seitentabellen (pgd) zu reparieren. </font><font style="vertical-align: inherit;">Das Hauptproblem besteht darin, dass wir versuchen, auf einen Zeiger zuzugreifen, der sich nicht nur außerhalb der Seiten befindet (ausgelagert), sondern aufgrund des verzögerten Ladens des vmalloc-Bereichs auch nicht im Kontext des Speichers dieser Aufgabe. </font><font style="vertical-align: inherit;">Das Fehlen und die Unzugänglichkeit eines Zeigers </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedeutet eine Kernel-Panik,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wenn Sie das Problem nicht im Voraus lösen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 4.16.67</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/x86/entry/entry_64.S */</span></span> ENTRY(__switch_to_asm) UNWIND_HINT_FUNC <span class="hljs-comment"><span class="hljs-comment">/* Save callee-saved registers */</span></span> pushq %rbp pushq %rbx pushq %r12 pushq %r13 pushq %r14 pushq %r15 <span class="hljs-comment"><span class="hljs-comment">/* switch stack */</span></span> movq %rsp, TASK_threadsp(%rdi) <span class="hljs-function"><span class="hljs-function">movq </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TASK_threadsp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function">, %rsp </span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-meta">#</span></span><span class="hljs-meta-keyword"><span class="hljs-function"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span></span><span class="hljs-function"><span class="hljs-meta"> CONFIG_CC_STACKPROTECTOR movq TASK_stack_canary(%rsi), %rbx movq %rbx, PER_CPU_VAR(irq_stack_union)+stack_canary_offset #</span></span><span class="hljs-meta-keyword"><span class="hljs-function"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span><span class="hljs-function"><span class="hljs-meta"> #</span></span><span class="hljs-meta-keyword"><span class="hljs-function"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span></span><span class="hljs-function"><span class="hljs-meta"> CONFIG_RETPOLINE FILL_RETURN_BUFFER %r12, RSB_CLEAR_LOOPS, X86_FEATURE_RSB_CTXSW #</span></span><span class="hljs-meta-keyword"><span class="hljs-function"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span><span class="hljs-function"><span class="hljs-meta"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-meta"><span class="hljs-comment">/* restore callee-saved registers */</span></span></span></span><span class="hljs-function"><span class="hljs-meta"> popq %r15 popq %r14 popq %r13 popq %r12 popq %rbx popq %rbp jmp __switch_to END(__switch_to_asm)</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entry_64.S</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enthält Arbeit , </font><font style="vertical-align: inherit;">dass die vorherigen 25 Jahren in der Linux - </font><font style="vertical-align: inherit;">Inline - </font><font style="vertical-align: inherit;">Assembler ausgeführt.</font></font><br><br><pre> <code class="cpp hljs">UNWIND_HINT_FUNC</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generiert QuickInfos, die vom gerade beendeten objtool-Stack-Trace-Tool verwendet werden. </font><font style="vertical-align: inherit;">Dies ist für spezielle Erstellungsverfahren erforderlich, die nicht den üblichen Konventionen für C-Sprachaufrufe entsprechen. Solche Hinweise sind der Grund für die erfolgreiche Implementierung von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ORC-Code-Unwinder</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Version 4.6.</font></font><br><br><pre> <code class="cpp hljs">pushq %rbp, %rbx, %r12, %r13, %r14, %r15</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir speichern die Register auf dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alten Stapel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , von dem wir wechseln.</font></font><br><br><pre> <code class="cpp hljs">movq %rsp, TASK_threadsp(%rdi) <span class="hljs-function"><span class="hljs-function">movq </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TASK_threadsp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function">, %rsp</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich tausche Stapelzeiger zwischen der alten und der neuen Aufgabe. </font><font style="vertical-align: inherit;">Direkt aus der Umgebungs Montage ist nicht klar, aber enthält RDI und RSI Eingabeargumente </font></font><code>task_struct *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prev</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weiter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Übereinstimmung mit den Konventionen System V ABI. </font><font style="vertical-align: inherit;">Hier ist eine Teilmenge der Register zusammen mit ihrer Verwendung:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9bc/13e/410/9bc13e4108b9c67a1a9d8cd78439b7a5.png"><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_CC_STACKPROTECTOR movq TASK_stack_canary(%rsi), %rbx movq %rbx, PER_CPU_VAR(irq_stack_union)+stack_canary_offset</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Stapelschutz aktiviert ist, wird der Kanarienwert dieser Aufgabe an die entsprechende Stelle im Interrupt-Stapel der aktuellen CPU verschoben. </font><font style="vertical-align: inherit;">Der Stapelschutz ist normalerweise standardmäßig aktiviert, daher geschieht dies normalerweise.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_RETPOLINE FILL_RETURN_BUFFER %r12, RSB_CLEAR_LOOPS, X86_FEATURE_RSB_CTXSW</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schutz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gegen eine mögliche Ausnutzung der Verzweigungsvorhersage (Spectre-Schwachstelle). </font><font style="vertical-align: inherit;">Reines </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voodoo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br><br><pre> <code class="cpp hljs">popq %r15, %r14, %r13, %r12, %rbx, %rbp</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellt alle Register aus dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neuen Stapel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in umgekehrter Reihenfolge wieder her: (r15, r14, r13, r12, rbx, rbp) </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 4.16.67 ( </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit Kommentaren)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/x86/kernel/process_64.c */</span></span> __visible __notrace_funcgraph <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> * __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">switch_to</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpu</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_fpu</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpu</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpu</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_fpu</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpu</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cpu = smp_processor_id(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">per_cpu</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cpu_tss_rw</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cpu</span></span></span><span class="hljs-class">);</span></span> WARN_ON_ONCE(IS_ENABLED(CONFIG_DEBUG_ENTRY) &amp;&amp; this_cpu_read(irq_count) != <span class="hljs-number"><span class="hljs-number">-1</span></span>); switch_fpu_prepare(prev_fpu, cpu); save_fsgs(prev_p); load_TLS(next, cpu); arch_end_context_switch(next_p); savesegment(es, prev-&gt;es); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;es | prev-&gt;es)) loadsegment(es, next-&gt;es); savesegment(ds, prev-&gt;ds); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;ds | prev-&gt;ds)) loadsegment(ds, next-&gt;ds); load_seg_legacy(prev-&gt;fsindex, prev-&gt;fsbase, next-&gt;fsindex, next-&gt;fsbase, FS); load_seg_legacy(prev-&gt;gsindex, prev-&gt;gsbase, next-&gt;gsindex, next-&gt;gsbase, GS); switch_fpu_finish(next_fpu, cpu); <span class="hljs-comment"><span class="hljs-comment">/* Switch the PDA and FPU contexts. */</span></span> this_cpu_write(current_task, next_p); this_cpu_write(cpu_current_top_of_stack, task_top_of_stack(next_p)); <span class="hljs-comment"><span class="hljs-comment">/* Reload sp0. */</span></span> update_sp0(next_p); <span class="hljs-comment"><span class="hljs-comment">/* Now maybe reload the debug registers and handle I/O bitmaps */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(task_thread_info(next_p)-&gt;flags &amp; _TIF_WORK_CTXSW_NEXT || task_thread_info(prev_p)-&gt;flags &amp; _TIF_WORK_CTXSW_PREV)) __switch_to_xtra(prev_p, next_p, tss); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_XEN_PV </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (unlikely(static_cpu_has(X86_FEATURE_XENPV) &amp;&amp; prev-&gt;iopl != next-&gt;iopl)) xen_set_iopl_mask(next-&gt;iopl); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (static_cpu_has_bug(X86_BUG_SYSRET_SS_ATTRS)) { unsigned short ss_sel; savesegment(ss, ss_sel); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ss_sel != __KERNEL_DS) loadsegment(ss, __KERNEL_DS); } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Load the Intel cache allocation PQR MSR. */</span></span></span><span class="hljs-meta"> intel_rdt_sched_in(); return prev_p; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit diesem letzten Codeblock können Sie sich mit den neuesten Änderungen im Kontextwechsel vertraut machen! </font><font style="vertical-align: inherit;">Wenn Sie den Artikel sofort an diesen Ort gescrollt haben, machen Sie sich keine Sorgen - ich werde die meisten Punkte hier (erneut) und detaillierter betrachten. </font><font style="vertical-align: inherit;">Beachten Sie einige Ausnahmen, die in den Kontextwechsel fallen.</font></font><br><br><pre> <code class="cpp hljs">__visible __notrace_funcgraph <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> * __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">switch_to</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Signatur für den Kontextwechsel zu C besteht aus mehreren Teilen: </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__visible</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Dieses Attribut stellt sicher, dass durch die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimierung während des Layoutprozesses</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das Zeichen nicht entfernt wird </font></font><code>__switch_to()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__notrace_funcgraph</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - schützt </font></font><code>__switch_to()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vor dem ftrace-Tracer. </font><font style="vertical-align: inherit;">Die Funktion wurde ungefähr in Version 2.6.29 hinzugefügt und bald aktiviert.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Eingabeargumente sind Zeiger auf die alten und neuen Aufgaben, die an RDI und RSI übergeben werden. </font></font></li></ul><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpu</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_fpu</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpu</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpu</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_fpu</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpu</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sammelt einige Informationen aus Eingabedaten </font></font><code>task_struct *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Thread_struct </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TSS-Daten für die Task (Register usw.). Die Struktur </font></font><code>fpu&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält die FPU-Daten, z. B. die zuletzt verwendete CPU, die Initialisierung und die Registerwerte.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cpu = smp_processor_id();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gibt die Prozessornummer zurück, die wir benötigen, um die GDT für TSS-Daten, die lokale Thread-Speicherung und den Vergleich des Status von Tankstellen zu steuern. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">per_cpu</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cpu_tss_rw</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cpu</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigt die </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aktuelle TSS-CPU an</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs">WARN_ON_ONCE(IS_ENABLED(CONFIG_DEBUG_ENTRY) &amp;&amp; this_cpu_read(irq_count) != <span class="hljs-number"><span class="hljs-number">-1</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legt fest, ob der IRQ-Stapel während der Kontextumschaltung verwendet wird, und meldet dies einmal pro Last. </font><font style="vertical-align: inherit;">Dies wurde zu Beginn der Entwicklung 4.14 hinzugefügt, und tatsächlich wirkt sich dieser Code nicht auf die Kontextumschaltung aus.</font></font><br><br><pre> <code class="cpp hljs">switch_fpu_prepare(prev_fpu, cpu);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichert den aktuellen Status der FPU, während wir uns in der alten Aufgabe befinden. </font></font><br><br><pre> <code class="cpp hljs">save_fsgs(prev_p);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichert FS und GS, bevor wir den lokalen Stream-Speicher ändern. </font></font><br><br><pre> <code class="cpp hljs">load_TLS(next, cpu);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lädt GDT für die lokale Thread-Speicherung neuer Aufgaben neu. </font><font style="vertical-align: inherit;">Kopiert tls_array mechanisch aus einem neuen Stream in die GDT-Datensätze 6, 7 und 8.</font></font><br><br><pre> <code class="cpp hljs">arch_end_context_switch(next_p);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Funktion wird nur bei Paravirtualisierung definiert. </font><font style="vertical-align: inherit;">Ändert den Paravirt-Modus und löscht alle verbleibenden Stapelarbeiten. </font><font style="vertical-align: inherit;">Eingeführt in neueren Versionen 2.6.x. </font><font style="vertical-align: inherit;">Ich bin nicht zu stark in dieser Funktionalität, deshalb überlasse ich sie den </font><font style="vertical-align: inherit;">Lesern </font><font style="vertical-align: inherit;">zur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recherche</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs">savesegment(es, prev-&gt;es); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;es | prev-&gt;es)) loadsegment(es, next-&gt;es);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichert das ES-Segment und lädt bei Bedarf ein neues. </font><font style="vertical-align: inherit;">Ein ähnlicher DS-Aufruf wird weggelassen. </font><font style="vertical-align: inherit;">Auch wenn die neue Aufgabe kein DS / ES verwendet, werden alle alten Werte gelöscht.</font></font><br><br><pre> <code class="cpp hljs">load_seg_legacy(prev-&gt;fsindex, prev-&gt;fsbase, next-&gt;fsindex, next-&gt;fsbase, FS);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lädt neue FS-Segmente (GS weggelassen). </font><font style="vertical-align: inherit;">Dadurch werden Register für 32-Bit- und 64-Bit-Registertypen erkannt und geladen. </font><font style="vertical-align: inherit;">Die neue Aufgabe ist jetzt bereit für TLS.</font></font><br><br><pre> <code class="cpp hljs">switch_fpu_finish(next_fpu, cpu);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Initialisiert den Status der FPU für eine eingehende Aufgabe. </font></font><br><br><pre> <code class="cpp hljs">this_cpu_write(current_task, next_p);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert die aktuelle CPU ( </font></font><code>task_struct *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) - </font><font style="vertical-align: inherit;">Aufgabe </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aktualisiert effektiv den Status der FPU und des PDA (Datenbereich für jeden Prozessor).</font></font><br><br><pre> <code class="cpp hljs">this_cpu_write(cpu_current_top_of_stack, task_top_of_stack(next_p));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU aktualisiert den Stapelzeiger, der </font><font style="vertical-align: inherit;">tatsächlich sp1 als überlastet ist </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erzeugten Code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Eintrag Trampolin) für die </font><font style="vertical-align: inherit;">Sicherheit.</font></font><br><br><pre> <code class="cpp hljs">update_sp0(next_p);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Validierung eines neuen Stapels, um ihn zu überprüfen. </font><font style="vertical-align: inherit;">Es sieht so aus, als ob hier sp0 angegeben werden sollte, nicht sp1? </font><font style="vertical-align: inherit;">Sollte wahrscheinlich umbenannt werden.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(task_thread_info(next_p)-&gt;flags &amp; _TIF_WORK_CTXSW_NEXT || task_thread_info(prev_p)-&gt;flags &amp; _TIF_WORK_CTXSW_PREV)) __switch_to_xtra(prev_p, next_p, tss);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert Debug-Register und E / A-Bitmaps. </font><font style="vertical-align: inherit;">Diese beiden Aufgaben wurden zuvor direkt im Kontextwechsel ausgeführt, werden jetzt jedoch in verschoben </font></font><code>__switch_to_xtra()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_XEN_PV </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (unlikely(static_cpu_has(X86_FEATURE_XENPV) &amp;&amp; prev-&gt;iopl != next-&gt;iopl)) xen_set_iopl_mask(next-&gt;iopl);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tauscht die E / A-Berechtigungsbits manuell gegen Xen-Paravirtualisierung aus. </font><font style="vertical-align: inherit;">Anscheinend </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktioniert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der reguläre Flag-Schalter </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">nicht richtig</font></a><font style="vertical-align: inherit;"> , und deshalb müssen Sie die aktuellen Bits direkt maskieren.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (static_cpu_has_bug(X86_BUG_SYSRET_SS_ATTRS)) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> ss_sel; savesegment(ss, ss_sel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ss_sel != __KERNEL_DS) loadsegment(ss, __KERNEL_DS);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blendet </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unerwartetes Verhalten SYSRET</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in AMD - </font><font style="vertical-align: inherit;">Prozessoren, die nicht richtig Segmentbeschreibern aktualisieren.</font></font><br><br><pre> <code class="cpp hljs">intel_rdt_sched_in();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Intel-Bereinigungsaufgaben. </font><font style="vertical-align: inherit;">Aktualisiert </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RMID und CLOSid</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev_p;</code> </pre> <br>  Fertig! <br><br><h1>  FAQ </h1><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum haben Sie diese Kernel-Versionen ausgewählt? </font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste und letzte Version waren offensichtliche Kandidaten. </font><font style="vertical-align: inherit;">Ursprünglich wollte ich vier weitere Zwischenversionen in Betracht ziehen (2.1, 2.3, 2.5 und 2.6.26), aber die Änderungen reichten nicht aus, um den Artikel zu stark aufzublasen. </font><font style="vertical-align: inherit;">Sie ist schon zu groß. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie lange hat diese Studie gedauert? </font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwei Wochen. </font><font style="vertical-align: inherit;">Eine Woche für Code-Analyse, Notizen und technische Tutorials. </font><font style="vertical-align: inherit;">Dann eine Woche, um Notizen neu zu schreiben, Diagramme zu zeichnen und den Artikel zu formatieren. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.14.67 - nicht die neueste LTS-Version? </font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich begann am 1. September mit dem Studium des Codes und nahm den Quellcode 4.14.67. </font><font style="vertical-align: inherit;">Die Version 4.14.68 wurde vier Tage später fertiggestellt. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich werde weitere Fragen hinzufügen, sobald sie verfügbar sind.</font></font></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438042/">https://habr.com/ru/post/de438042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438024/index.html">Schnelle Zahlungen: Worüber sich Banken Sorgen machen müssen</a></li>
<li><a href="../de438028/index.html">Sie brauchen keine Blockchain: 8 beliebte Benutzerfälle und warum sie nicht funktionieren</a></li>
<li><a href="../de438032/index.html">Beliebte Open Source - Teil zwei: 5 Cloud-Management-Tools</a></li>
<li><a href="../de438036/index.html">3blue1brown und MIT auf Russisch</a></li>
<li><a href="../de438038/index.html">Karriere Steroide. Echte Geschichten</a></li>
<li><a href="../de438046/index.html">Wie kann man schnell eine Million Punkte auf Spark geocodieren?</a></li>
<li><a href="../de438050/index.html">Kalman-Filter zur Minimierung des Entropiewertes eines zufälligen Fehlers mit einer nicht-Gaußschen Verteilung</a></li>
<li><a href="../de438052/index.html">Interaktor, Betriebsmuster</a></li>
<li><a href="../de438058/index.html">"Datenanalyse in Python" in zwei Teilen</a></li>
<li><a href="../de438060/index.html">Einschätzung der räumlichen Ausrichtung oder Wie man keine Angst vor Mahoney- und Majwik-Filtern hat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>