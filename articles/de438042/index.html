<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóëÔ∏è ‚ò¢Ô∏è üßóüèæ Die Entwicklung des x86-Kontextwechsels unter Linux üë®üèº‚Äçüî¨ üêì üôåüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als ich am vergangenen Wochenende interessante Fakten √ºber den 80386-Hardware-Kontextwechsel studierte, fiel mir pl√∂tzlich ein, dass sich die ersten V...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Entwicklung des x86-Kontextwechsels unter Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438042/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df8/ca2/556/df8ca2556ca28afde78fe531a3eb892b.png"></div><br><br>  Als ich am vergangenen Wochenende interessante Fakten √ºber den 80386-Hardware-Kontextwechsel studierte, fiel mir pl√∂tzlich ein, dass sich die ersten Versionen des Linux-Kernels darauf st√ºtzten.  Und ich tauchte in Code ein, den ich seit vielen Jahren nicht mehr gesehen hatte.  Jetzt habe ich beschlossen, diese wunderbare Reise durch die Geschichte von Linux zu beschreiben.  Ich werde alle Nuggets und lustigen Artefakte zeigen, die ich unterwegs gefunden habe. <br><br>  <b>Ziel:</b> Verfolgen, wie sich die Kontextumschaltung im Linux-Kernel von der ersten (0,01) auf die neueste Version von LTS (4.14.67) ge√§ndert hat, wobei der Schwerpunkt auf der ersten und der neuesten Version liegt. <br><a name="habracut"></a><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fr√ºhes Linux: Alte Geschichte</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux 1.0: Proof of Concept</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux 2.0: Kandidat</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2 Software Level Switching</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.4: letzter alter Kern</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux 2.6: Popularit√§t</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux 3.0: modernes Betriebssystem</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux 4.14.67: neueste LTS</a> </li></ul><br>  Tats√§chlich geht es in der Geschichte nicht darum, den Kontext zu wechseln, sondern um die Entwicklung von Linux von einem kleinen Projekt zu einem modernen Betriebssystem.  Der Kontextwechsel spiegelt einfach diese Geschichte wider. <br><br><h2>  √úber welchen Kontextwechsel sprechen wir? </h2><br>  Obwohl es viele Dinge gibt, die als Kontextumschaltung betrachtet werden k√∂nnen (z. B. Umschalten in den Kernelmodus, Umschalten auf einen Interrupt-Handler), meine ich die allgemein akzeptierte Bedeutung: <b>Umschalten zwischen Prozessen</b> .  Unter Linux ist dies das Makro <code>switch_to()</code> und alles darin. <br><br>  Dieses Makro ist eine einfache mechanische Aktion zwischen zwei viel interessanteren Systemen: einem Taskplaner und einer CPU.  Betriebssystementwickler k√∂nnen Aufgabenplanungsstrategien mischen und koordinieren.  CPU-Architekturen sind ebenfalls weit offen: Linux unterst√ºtzt Dutzende von Typen.  Aber der Kontextwechsel ist das Zahnrad zwischen ihnen.  Sein ‚ÄûDesign‚Äú h√§ngt von seinen Nachbarn ab, daher behauptet der Kontextwechsel, der am <i>wenigsten</i> interessante Teil des Betriebssystems zu sein.  Ich wiederhole: Er tut nur das, was getan werden muss. <br><br>  Eine kurze Liste von Kontextwechselaufgaben: <br><br><ol><li>  √úberschreiben des Arbeitsbereichs: Stapelwiederherstellung (SS: SP). <br></li><li>  Suchen Sie nach der folgenden Anweisung: IP-Wiederherstellung (CS: IP). <br></li><li>  Wiederherstellung des Taskstatus: Wiederherstellung von Allzweckregistern. <br></li><li>  Austausch von Speicheradressr√§umen: Aktualisierung des Seitenverzeichnisses (CR3) <br></li><li>  ... und vieles mehr: FPUs, Betriebssystemdatenstrukturen, Debug-Register, Hardware-Problemumgehungen usw. </li></ol><br>  Es ist nicht immer klar, wann und wo diese Aufgaben ausgef√ºhrt werden, wenn ein anderer Prozess die CPU √ºbernimmt.  Beispielsweise verbirgt das Umschalten des Hardwarekontexts vor Linux 2.2 die Aufgaben 2, 3 und 4. Aufgabe 3 ist begrenzt, da zwischen den Kernelmodi umgeschaltet wird.  Das Wiederherstellen eines Benutzer-Threads ist eine <code>iret</code> Aufgabe, nachdem der Scheduler zur√ºckgekehrt ist.  Viele dieser Aufgaben in verschiedenen Kernelversionen schweben zwischen <code>switch_to()</code> und dem Scheduler.  Wir k√∂nnen nur garantieren, dass in jeder Version immer ein Stack-Swap und ein FPU-Switching stattfinden. <br><br><h3>  F√ºr wen ist es? </h3><br>  Nicht f√ºr irgendjemanden speziell.  Zum Verst√§ndnis m√ºssen Sie nur den x86-Assembler kennen und wahrscheinlich nur √ºber eine minimale Ausbildung in Bezug auf das Betriebssystemdesign verf√ºgen. <br><br>  Ich muss <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">sofort</a> sagen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">,</a> dass ich kein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Betreuer</a> oder Mitwirkender am Linux-Kernel bin.  Alle Informationen von diesen Kameraden oder von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">der Mailingliste der Kernelentwickler</a> , die meinen Informationen widersprechen, sollten ernst genommen werden.  Ich habe ein zuf√§lliges pers√∂nliches Projekt, keinen wissenschaftlichen Artikel in einem von Experten begutachteten Journal. <br><br><a name="1"></a><h1>  Fr√ºhes Linux vor 1.0: Alte Geschichte (1991) </h1><br>  Der fr√ºhe Linux-Kernel ist einfach und funktional und enth√§lt eine kleine Liste der wichtigsten Funktionen: <br><br><ul><li>  Einzelarchitektur (80386 / i386): Nur eine Art von Kontextwechsel.  Viele 80386-Funktionen sind im gesamten Kern fest codiert.  Als Referenz zu diesen Teilen habe ich das Intel 80386 Programmer's Guide (1986) genommen. <br></li><li>  Hardware-Kontextwechsel: Um Aufgaben zu √§ndern, verwendet der Kernel integrierte Mechanismen 80386. <br></li><li>  Ein Prozess mit pr√§emptivem Multitasking: Es ist jeweils nur eine CPU mit einem Prozess aktiv.  Ein anderer Prozess kann jedoch jederzeit beginnen.  Daher werden die √ºblichen Synchronisationsregeln angewendet: Blockieren gemeinsam genutzter Ressourcen (ohne Spin-Locks).  Im Extremfall ist es m√∂glich, Interrupts zu deaktivieren, aber zuerst den Mutex zu sperren. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/d58/0f8/1b3/d580f81b36718f5531ea3790fd00c8ab.png"><br><br>  Schauen Sie sich ohne weiteres die beiden fr√ºhen Kontextwechsel an.  Der Code ist zur besseren Lesbarkeit formatiert: ein Element pro Zeile ohne Fortsetzungszeichen (\). <br><br>  <b>Linux 0.01</b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/linux/sched.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(n) { struct {long a,b;} __tmp; __asm__(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmpl %%ecx,_current\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"je 1f\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"xchgl %%ecx,_current\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movw %%dx,%1\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ljmp %0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmpl %%ecx,%2\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jne 1f\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"clts\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1:"</span></span></span><span class="hljs-meta"> ::</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (*&amp;__tmp.a), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (*&amp;__tmp.b), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (last_task_used_math), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"d"</span></span></span><span class="hljs-meta"> _TSS(n), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"c"</span></span></span><span class="hljs-meta"> ((long) task[n])); }</span></span></code> </pre> <br>  <b>Linux 0.11</b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/linux/sched.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(n) { struct {long a,b;} __tmp; __asm__(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmpl %%ecx,_current\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"je 1f\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movw %%dx,%1\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"xchgl %%ecx,_current\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ljmp %0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmpl %%ecx,_last_task_used_math\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jne 1f\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"clts\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1:"</span></span></span><span class="hljs-meta"> ::</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (*&amp;__tmp.a), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (*&amp;__tmp.b), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"d"</span></span></span><span class="hljs-meta"> (_TSS(n)), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"c"</span></span></span><span class="hljs-meta"> ((long) task[n])); }</span></span></code> </pre> <br>  Sofort auff√§llig, wie klein er ist!  Klein genug, um jede Zeile einzeln zu analysieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(n) {</span></span></code> </pre> <br>  <code>switch_to()</code> ist also ein Makro.  Es erscheint an genau einer Stelle: in der allerletzten Zeile des <code>schedule()</code> .  Daher teilt das Makro nach der Vorverarbeitung den Scheduler-Bereich.  Im globalen Bereich werden unbekannte Links √ºberpr√ºft, z. B. <code>current</code> und <code>last_task_used_math</code> .  Das Eingabeargument <code>n</code> ist die Sequenznummer der n√§chsten Aufgabe (von 0 bis 63). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span><span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a,b;} __tmp;</code> </pre> <br>  Reserviert 8 Bytes (64 Bit) auf dem Stapel, auf die √ºber zwei 4-Byte-Elemente <code>a</code> und <code>b</code> .  Wir werden einige dieser Bytes sp√§ter f√ºr die Weitsprungoperation setzen. <br><br><pre> <code class="cpp hljs">__asm__(<span class="hljs-string"><span class="hljs-string">"cmpl %%ecx,_current\n\t"</span></span></code> </pre> <br>  Der Kontextwechsel ist ein langer Inline-Block im Assembler.  Der erste Befehl bestimmt, ob das Ziel bereits aktuell ist.  Dies ist ein subtraktiver Vergleich des Werts im ECX-Register mit dem Wert des aktuellen <code>current</code> vom Scheduler.  Beide enthalten Zeiger auf <code>task_struct</code> Prozesses.  Unten in ECX befindet sich ein Zeiger auf die Zielaufgabe als gegebene Eingabe: <code>"c" ((long) task[n])</code> .  Das Vergleichsergebnis setzt den Wert des Statusregisters EFLAGS: Zum Beispiel ZF = 1, wenn beide Zeiger √ºbereinstimmen (x - x = 0). <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"je 1f\n\t"</span></span></code> </pre> <br>  Wenn die n√§chste Aufgabe die aktuelle ist, m√ºssen Sie den Kontext nicht wechseln, daher sollten Sie diese gesamte Prozedur √ºberspringen (√ºberspringen).  Der Befehl <code>je</code> pr√ºft, ob ZF = 1. Wenn ja, wird nach diesem Punkt im Code, der 8 Zeilen voraus ist, zur ersten Bezeichnung '1' verschoben. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"xchgl %%ecx,_current\n\t"</span></span></code> </pre> <br>  Aktualisiert den globalen <code>current</code> , um die neue Aufgabe widerzuspiegeln.  Der Zeiger von ECX (Task [n]) wechselt auf aktuell.  Flags werden nicht aktualisiert. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movw %%dx,%1\n\t"</span></span></code> </pre> <br>  Verschiebt den TSS-Index (Target Selector Descriptor Segment Selector) in einen zuvor reservierten Bereich.  Technisch gesehen wird dadurch der Wert aus dem DX-Register in <code>__tmp.b</code> , <code>__tmp.b</code> in die Bytes 5 bis 8 unserer reservierten 8-Byte-Struktur.  Der DX-Wert ist die angegebene Eingabe: <code>"d" (_TSS(n))</code> .  Das mehrstufige <code>_TSS</code> Makro wird zu einem g√ºltigen TSS-Segment-Selektor erweitert, auf den ich sp√§ter noch <code>_TSS</code> werde.  Unter dem Strich enthalten die beiden High-Bytes <code>__tmp.b</code> jetzt einen Segmentzeiger auf die n√§chste Aufgabe. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"ljmp %0\n\t"</span></span></code> </pre> <br>  Ruft einen Hardware-Kontextschalter 80386 auf, der zum TSS-Deskriptor wechselt.  Dieser einfache Sprung kann verwirrend sein, da es drei verschiedene Ideen gibt: Erstens ist <code>ljmp</code> ein indirekter Weitsprung, der einen 6-Byte-Operanden (48 Bit) ben√∂tigt.  Zweitens bezieht sich der Operand% 0 auf die nicht initialisierte Variable <code>__tmp.</code> .  Schlie√ülich ist der Wechsel zu einem Segmentselektor in GDT in x86 von besonderer Bedeutung.  Werfen wir einen Blick auf diese Punkte. <br><br><h3>  Indirekter Fern√ºbergang </h3><br>  Der wichtige Punkt ist, dass dieser √úbergang einen 6-Byte-Operanden hat.  Das Programmierhandbuch f√ºr 80386 beschreibt den √úbergang wie folgt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae5/fb3/676/ae5fb367632800feb6f59b53ee8d96c0.png"><br><br><h3>  Gehe zu __tmp.a </h3><br>  Denken Sie daran, dass die <code>__tmp</code> Struktur zwei 4-Byte-Werte enthielt und die Struktur auf <code>a</code> basiert.  Wenn wir dieses Element jedoch als Basisadresse des 6-Byte-Operanden verwenden, erreichen wir zwei Bytes <b>innerhalb der</b> Ganzzahl <code>__tmp.b</code> .  Diese beiden Bytes sind Teil des "Segmentselektors" der Fernadresse.  Wenn der Prozessor erkennt, dass das Segment im GDT TSS ist, wird ein Teil des Offsets vollst√§ndig ignoriert.  Die Tatsache, dass <code>__tmp.a</code> nicht initialisiert wird, spielt keine Rolle, da <code>__tmp.b</code> dank der vorherigen <code>movw</code> Anweisung immer noch einen g√ºltigen Wert hat.  F√ºgen Sie die √úbergangsadresse zum Diagramm hinzu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c02/e5a/974/c02e5a974ab3b2c6f907564b1316a0cf.png"><br><br>  Woher wissen wir, dass sich diese Adresse auf GDT bezieht?  Ich werde die Details in anderen Codezeilen offenbaren, aber die kurze Version ist, dass die vier Nullbits im Selektor eine GDT-Suche ausl√∂sen.  Das Makro <code>_TSS(n)</code> garantiert das Vorhandensein dieser vier Nullen.  Die unteren zwei Bits sind die Segmentberechtigungsstufe (00 entspricht Supervisor / Kernel), das n√§chste Nullbit bedeutet die Verwendung der GDT-Tabelle (die beim Booten in der GDTR gespeichert ist).  Die vierte Null ist technisch gesehen Teil des Segmentindex, der alle TSS-Suchen f√ºr die geraden Eintr√§ge der GDT-Tabelle erzwingt. <br><br><h3>  Hardware-Kontextschalter </h3><br>  Die Sprungadresse in <code>__tmp</code> definiert das TSS-Handle im GDT.  So wird es im Handbuch f√ºr 80386 beschrieben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1c/014/050/b1c014050e704604c7064c14e33af920.png"><br><br>  Der Prozessor erledigt f√ºr uns automatisch Folgendes: <br><br><ul><li>  √úberpr√ºft, ob die aktuelle Berechtigungsstufe zul√§ssig ist (wir befinden uns im Kernel-Modus, sodass alles in Ordnung ist). <br></li><li>  √úberpr√ºft, ob das TSS g√ºltig ist (sollte sein). <br></li><li>  Speichert den gesamten aktuellen Status der Aufgabe im alten TSS, der noch im Aufgabenregister (TR) gespeichert ist, sodass Sie EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI, ES, CS, SS, DS, FS, nicht verwenden m√ºssen. GS und EFLAGS.  EIP wird zum n√§chsten Befehl erh√∂ht und ebenfalls gespeichert. <br></li><li>  Aktualisiert TR f√ºr eine neue Aufgabe. <br></li><li>  Stellt alle allgemeinen Register, EIP und PDBR (Swap Address Space) wieder her.  Der Taskwechsel ist beendet, daher wird das TS-Flag im CR0-Register gesetzt. </li></ul><br>  Die einzige Anweisung <code>"ljmp %0\n\t"</code> hat also alle Schritte zum Wechseln des Kontexts ausgef√ºhrt.  Es bleibt nur ein bisschen aufzur√§umen. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"cmpl %%ecx,%2\n\t"</span></span></code> </pre> <br>  Wir √ºberpr√ºfen, ob die vorherige Aufgabe den mathematischen Coprozessor wiederhergestellt hat.  Das Argument ist der Zeiger <code>last_task_used_math</code> .  Mit dem TS-Flag k√∂nnen Sie √ºberpr√ºfen, ob der Coprozessor einen anderen Kontext hat.  Hardwarekontextschalter steuern den Coprozessor nicht. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"jne 1f\n\t"</span></span></code> </pre> <br>  Wenn die letzte Aufgabe den Coprozessor nicht wiederhergestellt hat, fahren Sie mit dem Ende des Kontextwechsels fort.  Wir m√∂chten das TS-Flag belassen, damit Sie bei der n√§chsten Verwendung des Coprozessors eine verz√∂gerte Bereinigung durchf√ºhren k√∂nnen.  "Faul", weil wir die Aufgabe verschieben, bis sie absolut notwendig wird. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"clts\n"</span></span></code> </pre> <br>  L√∂schen Sie das TS-Flag, wenn der letzte Prozess den Status des Coprozessors wiederhergestellt hat. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"1:"</span></span></code> </pre> <br>  Endmarkierung des Kontextschalters.  Alle Spr√ºnge zu dieser Bezeichnung √ºberspringen einige oder alle Prozeduren. <br><br><pre> <code class="cpp hljs">::<span class="hljs-string"><span class="hljs-string">"m"</span></span> (*&amp;__tmp.a),</code> </pre> <br>  In diesem Assembler-Block gibt es keine Ausgabe, und die erste Eingabe (% 0) ist die Position im Speicher der ersten vier Bytes des Fernzeigers auf den TSS-Deskriptor in der GDT.  Es wird nur als Referenz auf die Adresse verwendet, der Wert wird nicht initialisiert. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"m"</span></span> (*&amp;__tmp.b),</code> </pre> <br>  Die zweite Eingabe (% 1) ist die Stelle im Speicher der Bytes 5 und 6 des Fernzeigers auf den TSS-Deskriptor.  Technisch gesehen belegt dieser Platz vier Bytes im Speicher, aber nur die ersten beiden werden √ºberpr√ºft und verwendet. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"m"</span></span> (last_task_used_math),</code> </pre> <br>  Die dritte Eingabe (% 2) ist die Position im Speicher des Zeigers auf den letzten <code>task_struct</code> , der den Status des Coprozessors wiederhergestellt hat. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"d"</span></span> (_TSS(n)),</code> </pre> <br>  Die vierte Eingabe (% 3 / %% edx) ist die Adresse des TSS-Deskriptorsegment-Selektors in der GDT.  Schauen wir uns das Makro an: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _TSS(n) ((((unsigned long) n)&lt;&lt;4)+(FIRST_TSS_ENTRY&lt;&lt;3)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FIRST_TSS_ENTRY 4</span></span></code> </pre> <br>  Dies bedeutet, dass der erste TSS-Deskriptor der 4. Datensatz ist (der Index beginnt mit dem 4. Bit des Segmentselektors).  Jedes nachfolgende TSS belegt jeden zweiten GDT-Datensatz: 4, 6, 8 usw. Die ersten acht Aufgaben sehen folgenderma√üen aus: <br><br><table border="0"><thead><tr><th>  Aufgabe # </th><th>  16-Bit-Segmentauswahl </th></tr></thead><tbody><tr><td>  0 </td><td>  0000000000100 0 00 </td></tr><tr><td>  1 </td><td>  0000000000110 0 00 </td></tr><tr><td>  2 </td><td>  0000000001000 0 00 </td></tr><tr><td>  3 </td><td>  0000000001010 0 00 </td></tr><tr><td>  4 </td><td>  0000000001100 0 00 </td></tr><tr><td>  5 </td><td>  0000000001110 0 00 </td></tr><tr><td>  6 </td><td>  0000000010000 0 00 </td></tr><tr><td>  7 </td><td>  0000000010010 0 00 </td></tr></tbody></table><br>  Die Adressbits werden durch das Feldformat getrennt, wie es in 80386 sein sollte: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/600/837/d6d/600837d6d6710747e269775a515658b6.png"><br><br>  Die vier niedrigstwertigen Bits sind immer Null, was dem Supervisor-Modus, der GDT-Tabelle, entspricht und sogar Eintr√§ge des GDT-Index erzwingt. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"c"</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) task[n]));</code> </pre> <br>  Der letzte Eintrag (% 4 /% ecx) ist ein Zeiger auf das neue task_struct, zu dem wir wechseln.  Beachten Sie, dass sich der %% ecx-Wert unmittelbar vor dem Kontextwechsel zur vorherigen Aufgabe √§ndert. <br><br><h3>  Unterschiede zwischen 0,01 und 0,11 </h3><br>  Es gibt zwei Unterschiede zwischen Kontextwechseln.  Eine davon ist die einfache Code-Bereinigung und die andere ist die teilweise Fehlerkorrektur. <br><br><ul><li>  <code>_last_task_used_math</code> als Eingabevariable gel√∂scht, da das Symbol bereits im globalen Bereich verf√ºgbar ist.  Die entsprechende Vergleichsoperation wurde in eine direkte Verkn√ºpfung ge√§ndert. <br></li><li>  Der <code>xchgl</code> Befehl wurde mit <code>movw</code> ausgetauscht, um ihn n√§her an den Hardware-Kontextschalter ( <code>ljmp</code> ) zu bringen.  Das Problem ist, dass diese Operationen nicht atomar sind: Es ist unwahrscheinlich, dass ein Interrupt zwischen <code>xchgl</code> und <code>ljmp</code> , der zu einem weiteren Kontextwechsel mit der falschen <code>current</code> Aufgabe und dem nicht gespeicherten Status der realen Aufgabe f√ºhrt.  Das Ersetzen dieser Anweisungen macht diese Situation sehr unwahrscheinlich.  In einem lang laufenden System ist dies jedoch "sehr unwahrscheinlich" - ein Synonym f√ºr "unvermeidlich". </li></ul><br><a name="2"></a><h1>  Linux 1.x: Proof of Concept </h1><br>  Ungef√§hr 20 Patches wurden in ungef√§hr einem Jahr zwischen 0,11 und 1,0 ver√∂ffentlicht.  Der gr√∂√üte Teil der Bem√ºhungen konzentrierte sich auf Treiber, Funktionen f√ºr Benutzer und Entwickler.  Die maximale Anzahl von Aufgaben wurde auf 128 erh√∂ht, es wurden jedoch nicht viele grundlegende √Ñnderungen am Kontextwechsel vorgenommen. <br><br><h2>  Linux 1.0 </h2><br>  Linux 1.0 l√§uft immer noch auf derselben CPU mit einem Prozess, wobei die Hardware-Kontextumschaltung verwendet wird. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/963/c40/196/963c40196485c16d16d5d53c8d15c910.png"><br><br>  <b>Linux 1.0</b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/linux/sched.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(tsk) __asm__(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmpl %%ecx,_current\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"je 1f\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cli\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"xchgl %%ecx,_current\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ljmp %0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sti\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmpl %%ecx,_last_task_used_math\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jne 1f\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"clts\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1:"</span></span></span><span class="hljs-meta"> : </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* no output */</span></span></span><span class="hljs-meta"> :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (*(((char *)&amp;tsk-&gt;tss.tr)-4)), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"c"</span></span></span><span class="hljs-meta"> (tsk) :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cx"</span></span></span><span class="hljs-meta">)</span></span></code> </pre> <br>  Die wichtigste √Ñnderung war, dass das Eingabeargument nicht mehr der Tasknummernindex f√ºr das Array von task_struct-Strukturen ist.  Jetzt zeigt <code>switch_to()</code> auf eine neue Aufgabe.  Sie k√∂nnen also die <code>__tmp</code> Struktur entfernen und stattdessen einen direkten Link zu TSS verwenden.  Lassen Sie uns jede Zeile analysieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(tsk)</span></span></code> </pre> <br>  Die Eingabe ist jetzt ein Zeiger auf task_struct der n√§chsten Aufgabe. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"__asm__("</span></span>cmpl %%ecx,_current\n\t<span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br>  Nicht ge√§ndert.  √úberpr√ºft, ob die Eingabeaufgabe bereits aktuell ist, sodass kein Schalter erforderlich ist. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"je 1f\n\t"</span></span></code> </pre> <br>  Nicht ge√§ndert.  √úberspringen Sie die Kontextumschaltung, wenn keine Umschaltung vorhanden ist. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"cli\n\t"</span></span></code> </pre> <br>  Deaktiviert Interrupts, damit der Timer (oder eine andere Person) nicht zwischen dem Aktualisieren einer globalen Aufgabe und dem Umschalten des Hardwarekontexts abst√ºrzt.  Dieser Interrupt-Banhammer l√∂st das Problem fr√ºherer Kernel-Versionen, indem die folgenden zwei Anweisungen (Pseudo) atomar gemacht werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"xchgl %%ecx,_current\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"ljmp %0\n\t"</span></span></code> </pre> <br>  Keine √Ñnderung: Tauschen Sie den aktuellen Prozess aus, um die neue Aufgabe widerzuspiegeln, und rufen Sie den Hardwarekontextschalter auf. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"sti\n\t"</span></span></code> </pre> <br>  Schaltet Interrupts wieder ein. <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"cmpl %%ecx,_last_task_used_math\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"jne 1f\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"clts\n"</span></span> <span class="hljs-string"><span class="hljs-string">"1:"</span></span></code> </pre> <br>  Im Vergleich zu Linux 0.11 ist alles unver√§ndert.  Verwaltet das TS-Register und √ºberwacht das L√∂schen des mathematischen Coprozessors von der vorherigen Aufgabe. <br><br><pre> <code class="cpp hljs">: <span class="hljs-comment"><span class="hljs-comment">/* no output */</span></span></code> </pre> <br>  Dieser eingebaute Assembler hat keine Ausgabe - jemand war sichtlich ver√§rgert √ºber das Fehlen von Kommentaren in fr√ºheren Versionen des Kernels. <br><br><pre> <code class="cpp hljs">:<span class="hljs-string"><span class="hljs-string">"m"</span></span> (*(((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;tsk-&gt;tss.tr)<span class="hljs-number"><span class="hljs-number">-4</span></span>)),</code> </pre> <br>  L√§dt einen Segmentselektor f√ºr den TSS-Deskriptor einer neuen Aufgabe, auf den jetzt direkt √ºber den Zeiger task_struct zugegriffen werden kann.  Das Element <code>tss.tr</code> enth√§lt _TSS (task_number) als Referenz auf den GDT / TSS-Speicher, der vor 1.0 im Kernel verwendet wurde.  Wir fallen immer noch um 4 Bytes zur√ºck und laden einen 6-Byte-Segment-Selektor, um die obersten zwei Bytes zu √ºbernehmen.  Viel Spa√ü! <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"c"</span></span> (tsk)</code> </pre> <br>  Fast unver√§ndert - jetzt laden wir den Zeiger direkt und suchen nicht nach dem Index. <br><br><pre> <code class="cpp hljs">:<span class="hljs-string"><span class="hljs-string">"cx"</span></span>)</code> </pre> <br>  Die Kontextumschaltung blockiert das ECX-Register. <br><br><h2>  Linux 1.3 </h2><br>  Der Kernel unterst√ºtzt jetzt mehrere neue Architekturen: Alpha, MIPS und SPARC.  Daher gibt es vier verschiedene Versionen von <code>switch_to()</code> , von denen eine beim Kompilieren des Kernels enthalten ist.  Der architekturspezifische Code wurde vom Kernel getrennt, daher m√ºssen Sie an anderer Stelle nach der x86-Version suchen. <br><br>  <b>Linux 1.3</b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/asm-i386/system.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(tsk) do { __asm__(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cli\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"xchgl %%ecx,_current\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ljmp %0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sti\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmpl %%ecx,_last_task_used_math\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jne 1f\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"clts\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1:"</span></span></span><span class="hljs-meta"> : </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* no output */</span></span></span><span class="hljs-meta"> :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (*(((char *)&amp;tsk-&gt;tss.tr)-4)), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"c"</span></span></span><span class="hljs-meta"> (tsk) :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cx"</span></span></span><span class="hljs-meta">); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Now maybe reload the debug registers */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(current-&gt;debugreg[7]){ loaddebug(0); loaddebug(1); loaddebug(2); loaddebug(3); loaddebug(6); } } while (0)</span></span></code> </pre> <br>  Ein paar kleine √Ñnderungen: Der gesamte Kontextschalter ist in eine gef√§lschte Do-While-Schleife eingeschlossen.  Feykov, weil er nie wiederholt.  Die Pr√ºfung f√ºr den Wechsel zu einer neuen Aufgabe wurde in C von <code>switch_to()</code> zu Sheduler-Code verschoben. Einige Debugging-Aufgaben wurden von C-Code zu <code>switch_to ()</code> , wahrscheinlich um eine Trennung zu vermeiden.  Schauen wir uns die √Ñnderungen an. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(tsk) do {</span></span></code> </pre> <br>  Jetzt wird <code>switch_to()</code> in eine do-while (0) -Schleife eingeschlossen.  Dieses Design verhindert Fehler, wenn das Makro aufgrund der Bedingung (falls vorhanden) auf mehrere Anweisungen erweitert wird.  Derzeit ist dies nicht der Fall, aber angesichts der √Ñnderungen im Scheduler vermute ich, dass dies das Ergebnis der Bearbeitung des Codes ist, nur f√ºr den Fall.  Meine Vermutung: <br><br>  <b>Echter Planer in 1.3</b> <br><pre> <code class="cpp hljs">...<span class="hljs-function"><span class="hljs-function">within </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">schedule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(current == next)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span></span>; kstat.context_swtch++; switch_to(next);</code> </pre> <br>  <b>Eine m√∂gliche Option, die switch_to () bricht</b> <br><pre> <code class="cpp hljs">...<span class="hljs-function"><span class="hljs-function">within </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">schedule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">... </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(current != next)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">switch_to</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* do-while(0) 'captures' entire * block to ensure proper parse */</span></span></code> </pre> <br><br><pre> <code class="cpp hljs">__asm__(<span class="hljs-string"><span class="hljs-string">"cli\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"xchgl %%ecx,_current\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"ljmp %0\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"sti\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"cmpl %%ecx,_last_task_used_math\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"jne 1f\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"clts\n"</span></span> <span class="hljs-string"><span class="hljs-string">"1:"</span></span> : <span class="hljs-comment"><span class="hljs-comment">/* no output */</span></span> :<span class="hljs-string"><span class="hljs-string">"m"</span></span> (*(((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;tsk-&gt;tss.tr)<span class="hljs-number"><span class="hljs-number">-4</span></span>)), <span class="hljs-string"><span class="hljs-string">"c"</span></span> (tsk) :<span class="hljs-string"><span class="hljs-string">"cx"</span></span>);</code> </pre> <br>  Keine √Ñnderung gegen√ºber Linux 1.0.  Interrupts werden jedoch deaktiviert, bevor der * task_struct-Wechsel von <code>current</code> , dann die Hardware-Kontextumschaltung funktioniert und die Verwendung des Coprozessors √ºberpr√ºft wird. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Now maybe reload the debug registers */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(current-&gt;debugreg[<span class="hljs-number"><span class="hljs-number">7</span></span>]){</code> </pre> <br>  √úberpr√ºft die Debugging-Steuerung auf einen neuen Prozess f√ºr aktives ptrace (eine Adresse ungleich Null bedeutet hier aktives ptrace).  Das Debug-Tracking wurde nach <code>switch_to()</code> .  Genau die gleiche Sequenz C wird in 1.0 verwendet.  Ich nehme an, die Entwickler wollten sicherstellen, dass: 1) das Debuggen so nah wie m√∂glich am Kontextschalter ist 2) switch_to das neueste im <code>schedule()</code> . <br><br><pre> <code class="cpp hljs">loaddebug(<span class="hljs-number"><span class="hljs-number">0</span></span>); loaddebug(<span class="hljs-number"><span class="hljs-number">1</span></span>); loaddebug(<span class="hljs-number"><span class="hljs-number">2</span></span>); loaddebug(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Stellt Debug-Haltepunktregister aus einem gespeicherten ptrace-Status wieder her. <br><br><pre> <code class="cpp hljs">loaddebug(<span class="hljs-number"><span class="hljs-number">6</span></span>);</code> </pre> <br>  Stellt das Debug-Steuerregister aus dem gespeicherten ptrace-Status wieder her. <br><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Schlie√üt den Block <code>switch_to()</code> .  Obwohl die Bedingung immer dieselbe ist, stellt dies sicher, dass der Parser die Funktion als Basiseinheit √ºbernimmt, die nicht mit benachbarten Bedingungen in <code>schedule()</code> interagiert.  Beachten Sie das Fehlen eines Kommas am Ende - es steht nach dem Makroaufruf: <code>switch_to(next);</code>  . <br><br><a name="3"></a><h1>  Linux 2.0: Kandidat (1996) </h1><br>  Im Juni 1996 wurde der Kernel auf Version 2.0 aktualisiert und eine 15-j√§hrige Odyssee unter dieser Hauptversion gestartet, die mit einer breiten kommerziellen Unterst√ºtzung endete.  In 2.x wurden fast alle grundlegenden Systeme im Kernel radikal ver√§ndert.  Ber√ºcksichtigen Sie alle Nebenversionen vor 2.6.  Version 2.6 wurde so lange entwickelt, dass es einen separaten Abschnitt verdient. <br><br><h2>  Linux 2.0 </h2><br>  Linux 2.0 begann mit einer grundlegenden Innovation: <b>Multiprocessing</b> !  Zwei oder mehr Prozessoren k√∂nnen gleichzeitig Benutzer- / Kernelcode verarbeiten.  Dies erforderte nat√ºrlich einige Verfeinerung.  Beispielsweise verf√ºgt jeder Prozessor jetzt √ºber einen dedizierten Interrupt-Controller (APIC), sodass Interrupts auf jedem Prozessor separat verwaltet werden m√ºssen.  Mechanismen wie Timer-Unterbrechungen m√ºssen √ºberarbeitet werden (das Deaktivieren von Interrupts betrifft nur einen Prozessor).  Die Synchronisierung ist schwierig, insbesondere wenn versucht wird, sie auf eine bereits gro√üe und nicht verwandte Codebasis anzuwenden.  Linux 2.0 legt den Grundstein f√ºr eine gro√üe Kernel-Sperre (BKL) ... Sie m√ºssen irgendwo anfangen. <br><br>  Jetzt haben wir zwei Versionen von <code>switch_to()</code> : die Einzelprozessorversion (UP) von Linux 1.x und die neue verbesserte Version f√ºr symmetrisches Multiprocessing (SMP).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betrachten Sie zun√§chst die √Ñnderungen im alten Code, da einige √Ñnderungen von dort auch in der SMP-Version enthalten sind. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 2.0.1: Uniprozessor-Version (UP) </font></font></h2><br><img src="https://habrastorage.org/getpro/habr/post_images/e0c/ac1/b5c/e0cac1b5c0c3b269808a36f947528f9f.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.0.1 (UP)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/asm-i386/system.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Single process only (not SMP) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev,next) do { __asm__(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl %2,"</span></span></span><span class="hljs-meta">SYMBOL_NAME_STR(current_set)</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ljmp %0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmpl %1,"</span></span></span><span class="hljs-meta">SYMBOL_NAME_STR(last_task_used_math)</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jne 1f\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"clts\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1:"</span></span></span><span class="hljs-meta"> : </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* no outputs */</span></span></span><span class="hljs-meta"> :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (*(((char *)&amp;next-&gt;tss.tr)-4)), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r"</span></span></span><span class="hljs-meta"> (prev), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r"</span></span></span><span class="hljs-meta"> (next)); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Now maybe reload the debug registers */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(prev-&gt;debugreg[7]){ loaddebug(prev,0); loaddebug(prev,1); loaddebug(prev,2); loaddebug(prev,3); loaddebug(prev,6); } } while (0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zwei √Ñnderungen sind sofort ersichtlich: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U </font></font><code>switch_to()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hat ein neues Argument: den Prozess, von dem </font></font><code>*task_struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir wechseln.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Makro f√ºr die korrekte Verarbeitung von Zeichen im eingebauten Assembler. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gehen wir wie gewohnt in die richtige Richtung und besprechen die √Ñnderungen. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev,next) do {</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Argument </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definiert die Aufgabe, von der wir wechseln ( </font></font><code>*task_struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Wir wickeln das Makro immer noch in eine do-while (0) -Schleife ein, um einzeilige ifs um das Makro herum zu analysieren.</font></font><br><br><pre> <code class="cpp hljs">__asm__(<span class="hljs-string"><span class="hljs-string">"movl %2,"</span></span>SYMBOL_NAME_STR(current_set)<span class="hljs-string"><span class="hljs-string">"\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert die aktuell aktive Aufgabe auf die neu ausgew√§hlte. </font><font style="vertical-align: inherit;">Dies ist funktional √§quivalent </font></font><code>xchgl %%ecx,_current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, au√üer dass wir jetzt ein Array mit mehreren task_struct und ein macro ( </font></font><code>SYMBOL_NAME_STR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) zum Verarbeiten eingebetteter Assembly-Zeichen haben. </font><font style="vertical-align: inherit;">Warum daf√ºr einen Pr√§prozessor verwenden? </font><font style="vertical-align: inherit;">Tatsache ist, dass einige Assembler (GAS) das Hinzuf√ºgen eines Unterstrichs (_) zum Variablennamen C erfordern. Andere Assembler haben diese Anforderung nicht. </font><font style="vertical-align: inherit;">Um eine Konvention nicht auf einer Festplatte zu speichern, k√∂nnen Sie sie zur Kompilierungszeit entsprechend Ihren Tools konfigurieren.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"ljmp %0\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"cmpl %1,"</span></span>SYMBOL_NAME_STR(last_task_used_math)<span class="hljs-string"><span class="hljs-string">"\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"jne 1f\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"clts\n"</span></span> <span class="hljs-string"><span class="hljs-string">"1:"</span></span> : <span class="hljs-comment"><span class="hljs-comment">/* no outputs */</span></span> :<span class="hljs-string"><span class="hljs-string">"m"</span></span> (*(((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;next-&gt;tss.tr)<span class="hljs-number"><span class="hljs-number">-4</span></span>)),</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keine √Ñnderungen, √ºber die wir nicht gesprochen haben. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"r"</span></span> (prev), <span class="hljs-string"><span class="hljs-string">"r"</span></span> (next));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt tragen wir beide Aufgaben als Eingabe in den Inline-Assembler. </font><font style="vertical-align: inherit;">Eine geringf√ºgige √Ñnderung besteht darin, dass die Verwendung des Registers jetzt zul√§ssig ist. </font><font style="vertical-align: inherit;">Es </font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wurde </font><font style="vertical-align: inherit;">zuvor </font><font style="vertical-align: inherit;">in ECX codiert.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Now maybe reload the debug registers */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(prev-&gt;debugreg[<span class="hljs-number"><span class="hljs-number">7</span></span>]){ loaddebug(prev,<span class="hljs-number"><span class="hljs-number">0</span></span>); loaddebug(prev,<span class="hljs-number"><span class="hljs-number">1</span></span>); loaddebug(prev,<span class="hljs-number"><span class="hljs-number">2</span></span>); loaddebug(prev,<span class="hljs-number"><span class="hljs-number">3</span></span>); loaddebug(prev,<span class="hljs-number"><span class="hljs-number">6</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alles ist genau wie in Kernel 1.3. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 2.0.1: Multiprozessor-Version (SMP) </font></font></h2><br><img src="https://habrastorage.org/getpro/habr/post_images/d40/32b/4ce/d4032b4ce288a06a189746c69757fd03.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.0.1 (SMP)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/asm-i386/system.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __SMP__ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Multiprocessing enabled */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev,next) do { cli(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(prev-&gt;flags&amp;PF_USEDFPU) { __asm__ __volatile__(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"fnsave %0"</span></span></span><span class="hljs-meta">:</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=m"</span></span></span><span class="hljs-meta"> (prev-&gt;tss.i387.hard)); __asm__ __volatile__(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"fwait"</span></span></span><span class="hljs-meta">); prev-&gt;flags&amp;=~PF_USEDFPU; } prev-&gt;lock_depth=syscall_count; kernel_counter+=next-&gt;lock_depth-prev-&gt;lock_depth; syscall_count=next-&gt;lock_depth; __asm__(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%edx\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl "</span></span></span><span class="hljs-meta">SYMBOL_NAME_STR(apic_reg)</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">",%%edx\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl 0x20(%%edx), %%edx\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"shrl $22,%%edx\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"and $0x3C,%%edx\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl %%ecx,"</span></span></span><span class="hljs-meta">SYMBOL_NAME_STR(current_set)</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"(,%%edx)\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%edx\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ljmp %0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sti\n\t"</span></span></span><span class="hljs-meta"> : </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* no output */</span></span></span><span class="hljs-meta"> :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (*(((char *)&amp;next-&gt;tss.tr)-4)), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"c"</span></span></span><span class="hljs-meta"> (next)); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Now maybe reload the debug registers */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(prev-&gt;debugreg[7]){ loaddebug(prev,0); loaddebug(prev,1); loaddebug(prev,2); loaddebug(prev,3); loaddebug(prev,6); } } while (0)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was wird schon unverst√§ndlich? </font><font style="vertical-align: inherit;">Ich m√∂chte sagen, dass es sp√§ter besser wird, aber dies wird in der Welt von SMP nicht passieren. </font><font style="vertical-align: inherit;">Aus Platzgr√ºnden werde ich keine unver√§nderten Zeichenfolgen mehr auflisten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drei Erg√§nzungen f√ºr den SMP-Kontextwechsel: 1) √Ñndern der Funktionsweise eines einzelnen Coprozessors mit mehreren Prozessoren; </font><font style="vertical-align: inherit;">2) Steuern der Sperrtiefe, da die Kernelsperre rekursiv ist; </font><font style="vertical-align: inherit;">3) Verkn√ºpfen Sie mit APIC, um die CPU-ID f√ºr das aktuelle * task_struct abzurufen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(prev-&gt;flags&amp;PF_USEDFPU)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberpr√ºft, ob f√ºr die Aufgabe, zu der wir wechseln, ein Coprozessor verwendet wurde. </font><font style="vertical-align: inherit;">Wenn ja, m√ºssen Sie den Kontext in der FPU erfassen, bevor Sie wechseln.</font></font><br><br><pre> <code class="cpp hljs">__asm__ __volatile__(<span class="hljs-string"><span class="hljs-string">"fnsave %0"</span></span>:<span class="hljs-string"><span class="hljs-string">"=m"</span></span> (prev-&gt;tss.i387.hard));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichert den FPU-Status in TSS. </font><font style="vertical-align: inherit;">Mit FNSAVE wird die Ausnahmebehandlung √ºbersprungen. </font></font><code>__volatile__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte diese Anweisung vor √Ñnderungen durch den Optimierer sch√ºtzen.</font></font><br><br><pre> <code class="cpp hljs">__asm__ __volatile__(<span class="hljs-string"><span class="hljs-string">"fwait"</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warten auf die CPU, w√§hrend die FPU mit dem vorherigen Speichern besch√§ftigt ist. </font></font><br><br><pre> <code class="cpp hljs">prev-&gt;flags&amp;=~PF_USEDFPU;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deaktiviert das Flag f√ºr die Verwendung eines Coprozessors f√ºr diese Aufgabe. Es gibt immer Null. </font></font><br><br><pre> <code class="cpp hljs">prev-&gt;lock_depth=syscall_count;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichert die Anzahl der verschachtelten Verwendungen der Kernel-Sperre f√ºr eine alte Aufgabe. </font></font><br><br><pre> <code class="cpp hljs">kernel_counter+=next-&gt;lock_depth-prev-&gt;lock_depth;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert den globalen Kernel-Sperrz√§hler auf die n√§chste Aufgabe abz√ºglich der alten Aufgabe. </font><font style="vertical-align: inherit;">Entfernt effektiv die Sperre von der jetzt inaktiven alten Aufgabe, und die neue Aufgabe kann an der Stelle weiterarbeiten, an der sie gestoppt wurde.</font></font><br><br><pre> <code class="cpp hljs">syscall_count=next-&gt;lock_depth;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt den Sperrstatus einer neuen Aufgabe zur√ºck. </font><font style="vertical-align: inherit;">Es sollte dort sein, wo sie in der letzten Zeit aufgeh√∂rt hat.</font></font><br><br><pre> <code class="cpp hljs">__asm__(<span class="hljs-string"><span class="hljs-string">"pushl %%edx\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden EDX verwenden, damit wir den aktuellen Wert beibehalten. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movl "</span></span>SYMBOL_NAME_STR(apic_reg)<span class="hljs-string"><span class="hljs-string">",%%edx\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschiebt die APIC-E / A-Adresse nach EDX. </font><font style="vertical-align: inherit;">Wir m√ºssen APIC verwenden, um die CPU-ID zu erhalten, da wir nicht wissen, welcher Prozessor funktioniert. </font></font><code>apic_reg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Broadcast w√§hrend der Betriebssysteminitialisierung.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movl 0x20(%%edx), %%edx\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referenziert den Wert des APIC-Identifikatorregisters im EDX. </font><font style="vertical-align: inherit;">Die tats√§chliche ID befindet sich in den Bits 24-27.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b78/a09/fe4/b78a09fe454c84ff075d4a9d5759bbd7.png"><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"shrl $22,%%edx\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschiebt die APIC-ID auf die Bits 2-5. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"and $0x3C,%%edx\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maskiert nur die APIC-ID in den Bits 2-5 und bel√§sst die CPU-Nummer * 4. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movl %%ecx,"</span></span>SYMBOL_NAME_STR(current_set)<span class="hljs-string"><span class="hljs-string">"(,%%edx)\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert den Aufgabenzeiger der aktuellen CPU auf die n√§chste Aufgabe. </font><font style="vertical-align: inherit;">Die UP-Version hat die spezifische Verwendung von ECX zum Speichern der aktuellen Aufgabe bereits entfernt, wird jedoch weiterhin in der SMP-Version verwendet. </font><font style="vertical-align: inherit;">EDX enth√§lt die CPU-Nummer in den Bits 2-5, multipliziert mit 4, im Ma√üstab, um die Zeigergr√∂√üe von _current_set zu versetzen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"popl %%edx\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sind mit EDX fertig und werden den Wert wiederherstellen, der vor diesem Verfahren war. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Rest der Zeilen ist der gleiche.</font></font><br><br><a name="4"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 2.2 (1999) </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Warten auf Linux 2.2 hat sich wirklich gelohnt: Hier kam der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Software-Kontextwechsel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">Wir verwenden weiterhin das Taskregister (TR), um auf TSS zu verweisen. </font><font style="vertical-align: inherit;">SMP- und UP-Prozeduren werden mit einer einheitlichen FPU-Statusverarbeitung kombiniert. </font><font style="vertical-align: inherit;">Die meisten Kontextwechsel werden jetzt in C. </font><b><font style="vertical-align: inherit;">Linux 2.2.0-</font></b><font style="vertical-align: inherit;"> Code </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/cfd/c33/992/cfdc33992fee3168758bf99d6abe0698.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(integrierter Assembler) durchgef√ºhrt.</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/asm-i386/system.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev,next) do { unsigned long eax, edx, ecx; asm volatile(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%ebx\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%esi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%edi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%ebp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl %%esp,%0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* save ESP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl %5,%%esp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore ESP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl $1f,%1\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* save EIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %6\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore EIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jmp __switch_to\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1:\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%ebp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%edi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%esi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%ebx"</span></span></span><span class="hljs-meta"> :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=m"</span></span></span><span class="hljs-meta"> (prev-&gt;tss.esp),</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=m"</span></span></span><span class="hljs-meta"> (prev-&gt;tss.eip), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=a"</span></span></span><span class="hljs-meta"> (eax), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=d"</span></span></span><span class="hljs-meta"> (edx), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=c"</span></span></span><span class="hljs-meta"> (ecx) :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (next-&gt;tss.esp),</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (next-&gt;tss.eip), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"a"</span></span></span><span class="hljs-meta"> (prev), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"d"</span></span></span><span class="hljs-meta"> (next)); } while (0)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses neue </font></font><code>switch_to()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unterscheidet </font><font style="vertical-align: inherit;">sich </font><font style="vertical-align: inherit;">grundlegend von allen vorherigen Versionen: Es ist einfach! </font><font style="vertical-align: inherit;">Im eingebauten Assembler tauschen wir die Stapel- und Anweisungszeiger aus (Kontextwechselaufgaben 1 und 2). </font><font style="vertical-align: inherit;">Alles andere wird erledigt, nachdem Sie zum C ( </font></font><code>__switch_to()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) - </font><font style="vertical-align: inherit;">Code gegangen sind </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"pushl %%ebx\n\t"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"pushl %%esi\n\t"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"pushl %%edi\n\t"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"pushl %%ebp\n\t"</span></span></span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichert EBX, ESI, EDI und EBP im Stapel des Prozesses, den wir tauschen werden. </font><font style="vertical-align: inherit;">(... warum EBX?)</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movl %%esp,%0\n\t"</span></span> <span class="hljs-comment"><span class="hljs-comment">/* save ESP */</span></span> <span class="hljs-string"><span class="hljs-string">"movl %5,%%esp\n\t"</span></span> <span class="hljs-comment"><span class="hljs-comment">/* restore ESP */</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie den Kommentaren entnehmen k√∂nnen, tauschen wir Stapelzeiger zwischen dem alten und dem neuen Prozess aus. </font><font style="vertical-align: inherit;">Der alte Prozess hat den Operanden% 0 ( </font></font><code>prev-&gt;tss.esp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), w√§hrend der neue </font><font style="vertical-align: inherit;">Prozess </font><font style="vertical-align: inherit;">% 5 ( </font></font><code>next-&gt;tss.esp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) hat.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movl $1f,%1\n\t"</span></span> <span class="hljs-comment"><span class="hljs-comment">/* save EIP */</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern des Werts des Befehlszeigers f√ºr den n√§chsten Befehl der alten Aufgabe nach dem Zur√ºckschalten des Kontexts. </font><font style="vertical-align: inherit;">Beachten Sie, dass der Wert der folgenden Anweisung eine Bezeichnung verwendet </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"pushl %6\n\t"</span></span> <span class="hljs-comment"><span class="hljs-comment">/* restore EIP */</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bereiten Sie die folgenden Anweisungen f√ºr eine neue Aufgabe vor. </font><font style="vertical-align: inherit;">Da wir gerade zu einem neuen Stapel gewechselt haben, wird diese IP aus dem TSS der neuen Aufgabe entnommen und oben im Stapel platziert. </font><font style="vertical-align: inherit;">Die Ausf√ºhrung beginnt mit der folgenden Anweisung nach 'ret' aus dem C-Code, den wir ausf√ºhren m√∂chten.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"jmp __switch_to\n"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir fahren mit unserem neuen und verbesserten Software-Kontextwechsel fort (siehe unten). </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"popl %%ebp\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"popl %%edi\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"popl %%esi\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"popl %%ebx"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir stellen die Register vom Stapel in umgekehrter Reihenfolge wieder her, vermutlich nachdem wir in einem neuen Zeitintervall zur alten Task gewechselt haben. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.2.0 (C)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/i386/kernel/process.c */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __switch_to(struct task_struct *prev, struct task_struct *next) { <span class="hljs-comment"><span class="hljs-comment">/* Do the FPU save and set TS if it wasn't set before.. */</span></span> unlazy_fpu(prev); gdt_table[next-&gt;tss.tr &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>].b &amp;= <span class="hljs-number"><span class="hljs-number">0xfffffdff</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ltr %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">: :</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"g"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;next-&gt;tss.tr))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%fs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;tss.fs))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%gs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;tss.gs))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Re-load LDT if necessary */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;mm-&gt;segments != prev-&gt;mm-&gt;segments) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"lldt %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">: :</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"g"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;next-&gt;tss.ldt))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Re-load page tables */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> new_cr3 = next-&gt;tss.cr3; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cr3 != prev-&gt;tss.cr3) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %0,%%cr3"</span></span></span></span><span class="hljs-function"><span class="hljs-params">: :</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (new_cr3))</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Restore %fs and %gs. */</span></span> loadsegment(fs,next-&gt;tss.fs); loadsegment(gs,next-&gt;tss.gs); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;tss.debugreg[<span class="hljs-number"><span class="hljs-number">7</span></span>]){ loaddebug(next,<span class="hljs-number"><span class="hljs-number">0</span></span>); loaddebug(next,<span class="hljs-number"><span class="hljs-number">1</span></span>); loaddebug(next,<span class="hljs-number"><span class="hljs-number">2</span></span>); loaddebug(next,<span class="hljs-number"><span class="hljs-number">3</span></span>); loaddebug(next,<span class="hljs-number"><span class="hljs-number">6</span></span>); loaddebug(next,<span class="hljs-number"><span class="hljs-number">7</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Software-Kontextwechsel wurde der alte √úbergang zum TSS-Deskriptor durch den √úbergang zur neuen C: -Funktion ersetzt </font></font><code>__switch_to()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Funktion ist in C geschrieben und enth√§lt mehrere bekannte Komponenten, z. B. Debug-Register. </font><font style="vertical-align: inherit;">Wenn Sie zu C gehen, k√∂nnen Sie sie noch n√§her an den Kontextwechsel verschieben.</font></font><br><br><pre> <code class="cpp hljs">unlazy_fpu(prev);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir √ºberpr√ºfen die Verwendung der FPU und speichern ihren Status, falls verwendet. </font><font style="vertical-align: inherit;">Dies geschieht nun f√ºr jeden Prozess, bei dem die FPU verwendet wurde, sodass die Reinigung nicht mehr verz√∂gert ist. </font><font style="vertical-align: inherit;">Die Vorgehensweise ist dieselbe wie bei der SMP-Routine ab 2.0.1, au√üer dass wir jetzt ein sauberes Makro haben, das die manuelle TS-Optimierung enth√§lt.</font></font><br><br><pre> <code class="cpp hljs">gdt_table[next-&gt;tss.tr &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>].b &amp;= <span class="hljs-number"><span class="hljs-number">0xfffffdff</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√∂scht das BUSY-Bit f√ºr einen zuk√ºnftigen Task-Deskriptor. </font><font style="vertical-align: inherit;">Verwendet die Aufgabennummer, um die GDT zu indizieren. </font></font><code>tss.tr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enth√§lt den Wert des Task-Segment-Selektors, wobei die unteren drei Bits f√ºr Berechtigungen verwendet werden. </font><font style="vertical-align: inherit;">Wir brauchen nur einen Index, also verschieben wir diese Bits. </font><font style="vertical-align: inherit;">Das zweite TSS-Byte wird ge√§ndert, um Bit 10 zu entfernen.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e76/93f/c83/e7693fc83518201122914c5854f59de1.png"><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ltr %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">: :</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"g"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;next-&gt;tss.tr))</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Aufgabenregister wird mit einem Zeiger auf den n√§chsten Aufgabensegment-Selektor geladen. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%fs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;tss.fs))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%gs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;tss.gs))</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die FS- und GS-Segmentregister f√ºr die vorherige Aufgabe werden in TSS gespeichert. </font><font style="vertical-align: inherit;">Beim Hardware-Kontextwechsel wurde dieser Schritt automatisch ausgef√ºhrt, jetzt m√ºssen wir dies jedoch manuell tun. </font><font style="vertical-align: inherit;">Aber warum? </font><font style="vertical-align: inherit;">Wie verwendet Linux FS und GS? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter Linux 2.2 (1999) gibt es keine klare Antwort. </font><font style="vertical-align: inherit;">Es wird nur gesagt, dass sie verwendet werden, daher sollten Sie sie speichern, damit sie zug√§nglich bleiben. </font><font style="vertical-align: inherit;">Der Kernel-Modus-Code "leiht" diese Segmente aus, um Kernel-Segmente oder Benutzerdaten anzuzeigen. </font><font style="vertical-align: inherit;">Sound- und Netzwerktreiber machen dasselbe. </font><font style="vertical-align: inherit;">In letzter Zeit (ab ~ 2,6) unterst√ºtzen FS und GS h√§ufig lokale Stream-Speicher- und Datenbereiche pro Prozessor.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;mm-&gt;segments != prev-&gt;mm-&gt;segments) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"lldt %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">: :</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"g"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;next-&gt;tss.ldt))</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellt Segmente der lokalen Deskriptortabelle wieder her, wenn sie nicht bereits dem alten Prozess entsprechen. </font><font style="vertical-align: inherit;">Dies erfolgt durch Laden des LDT-Registers.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cr3 != prev-&gt;tss.cr3) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %0,%%cr3"</span></span></span></span><span class="hljs-function"><span class="hljs-params">: :</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (new_cr3))</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert den Status des virtuellen Speichers f√ºr eine neue Aufgabe. </font><font style="vertical-align: inherit;">Insbesondere wird das CR3-Register festgelegt, das ein Seitenverzeichnis f√ºr den Zugriff auf den Speicher in einem neuen Kontext enth√§lt.</font></font><br><br><pre> <code class="cpp hljs">loadsegment(fs,next-&gt;tss.fs); loadsegment(gs,next-&gt;tss.gs);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FS und GS werden f√ºr eine neue Aufgabe wiederhergestellt. </font><font style="vertical-align: inherit;">Dies stellt die korrekte Ausrichtung sicher und im Falle eines Problems wird das Nullsegment geladen.</font></font><br><br><pre> <code class="cpp hljs">loaddebug(prev,<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich wird das Debug-Steuerregister nun mit TSS gespeichert und umgeschaltet. </font><font style="vertical-align: inherit;">Bisher wurde dieses Register nur √ºberpr√ºft und nicht zur Speicherung verwendet.</font></font><br><br><a name="5"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 2.4 (2001) </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Version 2.4 wurden viele neue Funktionen eingef√ºhrt, z. B. Kernel-Threads und Task-Warteschlangen. </font><font style="vertical-align: inherit;">Trotz dieser und einiger √Ñnderungen im Scheduler hat sich der Kontextwechsel im Vergleich zu Version 2.2 nicht wesentlich ge√§ndert, obwohl die Aktualisierung von TR zugunsten des Ersetzens aller Registerdaten eingestellt wurde. </font><font style="vertical-align: inherit;">Ich nenne es inoffiziell den "letzten Legacy-Kernel", da alle zuk√ºnftigen Versionen die 64-Bit-x86-Architektur verwenden. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9fe/47c/1cb/9fe47c1cbc25d24606a3622694edcafb.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.4.0 (eingebauter Assembler)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/asm-i386/system.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev,next,last) do { asm volatile(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%esi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%edi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%ebp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl %%esp,%0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* save ESP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl %3,%%esp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore ESP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl $1f,%1\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* save EIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %4\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore EIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jmp __switch_to\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1:\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%ebp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%edi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%esi\n\t"</span></span></span><span class="hljs-meta"> :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=m"</span></span></span><span class="hljs-meta"> (prev-&gt;thread.esp),</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=m"</span></span></span><span class="hljs-meta"> (prev-&gt;thread.eip), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=b"</span></span></span><span class="hljs-meta"> (last) :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (next-&gt;thread.esp),</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (next-&gt;thread.eip), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"a"</span></span></span><span class="hljs-meta"> (prev), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"d"</span></span></span><span class="hljs-meta"> (next), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"b"</span></span></span><span class="hljs-meta"> (prev)); } while (0)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Kontextwechsel im 2.4-Kernel nimmt nur wenige geringf√ºgige √Ñnderungen vor: EBX wird nicht mehr gepusht, sondern ist in der Ausgabe des integrierten Assemblers enthalten. </font><font style="vertical-align: inherit;">Es wurde ein neues Eingabeargument angezeigt </font></font><code>last</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das denselben Wert wie enth√§lt </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es wird √ºber EBX √ºbertragen, aber nicht verwendet.</font></font><br><br><pre> <code class="cpp hljs">:<span class="hljs-string"><span class="hljs-string">"=m"</span></span> (prev-&gt;thread.esp),<span class="hljs-string"><span class="hljs-string">"=m"</span></span> (prev-&gt;thread.eip), :<span class="hljs-string"><span class="hljs-string">"m"</span></span> (next-&gt;thread.esp),<span class="hljs-string"><span class="hljs-string">"m"</span></span> (next-&gt;thread.eip),</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E / A-Operanden verweisen jetzt auf Stapel- / Befehlszeiger f√ºr Kernel-Threads. </font><font style="vertical-align: inherit;">Kontextschalter, die verwendet werden, um auf Stapelzeiger von TSS zu verweisen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.4.0 (C)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/i386/kernel/process.c */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __switch_to(struct task_struct *prev_p, struct task_struct *next_p) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init_tss</span></span></span><span class="hljs-class"> + </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">smp_processor_id</span></span></span><span class="hljs-class">();</span></span> unlazy_fpu(prev_p); tss-&gt;esp0 = next-&gt;esp0; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%fs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;fs))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%gs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;gs))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Restore %fs and %gs. */</span></span> loadsegment(fs, next-&gt;fs); loadsegment(gs, next-&gt;gs); <span class="hljs-comment"><span class="hljs-comment">/* Now maybe reload the debug registers */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;debugreg[<span class="hljs-number"><span class="hljs-number">7</span></span>]){ loaddebug(next, <span class="hljs-number"><span class="hljs-number">0</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">1</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">2</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* no 4 and 5 */</span></span> loaddebug(next, <span class="hljs-number"><span class="hljs-number">6</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">7</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prev-&gt;ioperm || next-&gt;ioperm) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;ioperm) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(tss-&gt;io_bitmap, next-&gt;io_bitmap, IO_BITMAP_SIZE*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)); tss-&gt;bitmap = IO_BITMAP_OFFSET; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tss-&gt;bitmap = INVALID_IO_BITMAP_OFFSET; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der C-Code-Teil hat einige Dinge ge√§ndert. </font><font style="vertical-align: inherit;">Jede Erw√§hnung des TR-Registers ist verschwunden, stattdessen √§ndern wir direkt das aktive TSS f√ºr den aktuellen Prozessor. </font><font style="vertical-align: inherit;">Wie im Inline-Assembler verweist jede Task auf TSS-Daten in thread_struct innerhalb von task_struct. </font><font style="vertical-align: inherit;">Jede aktive CPU verwendet dediziertes TSS von GDT und aktualisiert diese Felder direkt.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __switch_to(struct task_struct *prev_p, struct task_struct *next_p)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Den Zeigern der vorherigen und n√§chsten Aufgaben wurde ein Suffix hinzugef√ºgt </font></font><code>_p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist eine kleine , </font><font style="vertical-align: inherit;">aber wichtige Nuance da </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu konvertieren , </font><font style="vertical-align: inherit;">um Kernel - </font><font style="vertical-align: inherit;">Threads gehen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeiger auf TSS-Daten f√ºr jede Aufgabe werden bestimmt. </font></font><br><br><pre> <code class="cpp hljs">tss-&gt;esp0 = next-&gt;esp0;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ersetzen des Stapelversatzrings 0 durch den Versatz der neuen Aufgabe. </font><font style="vertical-align: inherit;">Bis ein erneutes Laden der Seitentabelle erzwungen wird ...</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%fs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;fs))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%gs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;gs))</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern von FS und GS f√ºr die alte Aufgabe. </font><font style="vertical-align: inherit;">Der Zweck dieser Segmente ist immer noch unverst√§ndlich, aber sie werden irgendwie verwendet. </font><font style="vertical-align: inherit;">In Version 2.6 werden sie daher f√ºr den lokalen FS: Thread-Speicher und den GS: Pro-Prozessor-Datenbereich verwendet.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prev-&gt;ioperm || next-&gt;ioperm) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;ioperm) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(tss-&gt;io_bitmap, next-&gt;io_bitmap, IO_BITMAP_SIZE*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)); tss-&gt;bitmap = IO_BITMAP_OFFSET;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Legt die Portzuordnungs-E / A-Berechtigungen im aktiven TSS f√ºr die bevorstehende Aufgabe fest. </font></font><br><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tss-&gt;bitmap = INVALID_IO_BITMAP_OFFSET;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeigt die E / A-Berechtigungen f√ºr das aktive TSS f√ºr eine bekannte ung√ºltige Bitmap (0x8000) an. </font></font><br><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 2.6: Popularit√§t (2003) </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Als Kernel 2.5 abreiste, erreichte der Linear-Run-Scheduler die Grenze der praktischen Verwendung, und AMD ver√∂ffentlichte eine Erweiterung f√ºr x86, die die sofortige Aufmerksamkeit der Kernel-Entwickler erforderte: x86-64. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 2.6.0 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Kernel 2.6.0 wurde ein Kernel-Scheduler mit konstanter Laufzeit angezeigt. </font><font style="vertical-align: inherit;">Dies ist zwar ein Fortschritt gegen√ºber dem vorherigen linearen Scheduler, aber in 2.6.23 wurde er schlie√ülich durch einen vollst√§ndig fairen Scheduler (CFS) ersetzt. </font><font style="vertical-align: inherit;">Andererseits hat die neue 64-Bit-Architektur die bislang bedeutendsten √Ñnderungen vorgenommen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 2.6.0: i386 Version </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist das neueste Erscheinungsbild des 32-Bit-Kontextschalters im Artikel. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f7/832/9c5/8f78329c52340939baba3bedbbcdfa39.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.6.0 (i386 integrierter Assembler)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/asm-i386/system.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev,next,last) do { unsigned long esi,edi; asm volatile(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushfl\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %%ebp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl %%esp,%0\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* save ESP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl %5,%%esp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore ESP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movl $1f,%1\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* save EIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushl %6\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore EIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jmp __switch_to\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1:\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popl %%ebp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"popfl"</span></span></span><span class="hljs-meta"> :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=m"</span></span></span><span class="hljs-meta"> (prev-&gt;thread.esp),</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=m"</span></span></span><span class="hljs-meta"> (prev-&gt;thread.eip), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=a"</span></span></span><span class="hljs-meta"> (last),</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=S"</span></span></span><span class="hljs-meta"> (esi),</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=D"</span></span></span><span class="hljs-meta"> (edi) :</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (next-&gt;thread.esp),</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (next-&gt;thread.eip), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"2"</span></span></span><span class="hljs-meta"> (prev), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"d"</span></span></span><span class="hljs-meta"> (next)); } while (0)</span></span></code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vier Zeilen gel√∂scht. </font><font style="vertical-align: inherit;">ESI und EDI wurden zuvor auf den Stapel verschoben, werden jetzt jedoch √ºber E / A-Operanden √ºbertragen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.6.0 (i386 C)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/i386/kernel/process.c */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> * __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">switch_to</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cpu = smp_processor_id(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init_tss</span></span></span><span class="hljs-class"> + </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cpu</span></span></span><span class="hljs-class">;</span></span> __unlazy_fpu(prev_p); load_esp0(tss, next-&gt;esp0); <span class="hljs-comment"><span class="hljs-comment">/* Load the per-thread Thread-Local Storage descriptor. */</span></span> load_TLS(next, cpu); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%fs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;fs))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%gs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)&amp;prev-&gt;gs))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Restore %fs and %gs if needed. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(prev-&gt;fs | prev-&gt;gs | next-&gt;fs | next-&gt;gs)) { loadsegment(fs, next-&gt;fs); loadsegment(gs, next-&gt;gs); } <span class="hljs-comment"><span class="hljs-comment">/* Now maybe reload the debug registers */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;debugreg[<span class="hljs-number"><span class="hljs-number">7</span></span>])) { loaddebug(next, <span class="hljs-number"><span class="hljs-number">0</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">1</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">2</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* no 4 and 5 */</span></span> loaddebug(next, <span class="hljs-number"><span class="hljs-number">6</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">7</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(prev-&gt;io_bitmap_ptr || next-&gt;io_bitmap_ptr)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;io_bitmap_ptr) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(tss-&gt;io_bitmap, next-&gt;io_bitmap_ptr, IO_BITMAP_BYTES); tss-&gt;io_bitmap_base = IO_BITMAP_OFFSET; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tss-&gt;io_bitmap_base = INVALID_IO_BITMAP_OFFSET; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev_p; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige interessante √Ñnderungen: der von der Funktion zur√ºckgegebene Wert und das Erscheinungsbild des Makros </font></font><code>unlikely()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ich werde keine √Ñnderungen an vorhandenem Code in [un] ber√ºcksichtigen, um ihn nicht noch einmal zu erkl√§ren. </font><font style="vertical-align: inherit;">Das Makro teilt dem Codegenerator einfach mit, welche Basiseinheit zuerst angezeigt werden soll, um das Pipelining zu unterst√ºtzen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">switch_to</span></span></span><span class="hljs-class">(...)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__switch_to gibt jetzt einen Zeiger auf eine alte Aufgabe zur√ºck. </font><font style="vertical-align: inherit;">Dies wird nirgendwo verarbeitet, daher wurde entweder die √Ñnderung gel√∂scht oder sie wollten der Konvention folgen. </font><font style="vertical-align: inherit;">Zum Beispiel die klassische Konvention, dass wir, wenn eine Funktion den Status √§ndert, den vorherigen Status zur√ºckgeben, um ihn sp√§ter zu speichern und wiederherzustellen. </font><font style="vertical-align: inherit;">Dies funktioniert zwar nicht.</font></font><br><br><pre> <code class="cpp hljs">load_TLS(next, cpu);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert die lokalen Thread-Store-Deskriptoren in GDT f√ºr eine neue Aufgabe. </font><font style="vertical-align: inherit;">Linux 2.6 f√ºhrt drei TLS-Eintr√§ge in GDT f√ºr bestimmte Stream-Segmente ein. </font><font style="vertical-align: inherit;">Glibc verwendet also das erste Segment, Wine - das zweite. </font><font style="vertical-align: inherit;">Jetzt verwenden wir nacheinander das FS-Segmentregister, um nach Bedarf auf den lokalen Thread-Speicher zu verweisen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(prev-&gt;fs | prev-&gt;gs | next-&gt;fs | next-&gt;gs)) {</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt stellen wir nur FS und GS wieder her, wenn sie von der vorherigen oder n√§chsten Aufgabe verwendet wurden. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 2.6.0: x86_64 Version </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der x86_64-Kontextschalter unterscheidet sich erheblich vom 32-Bit-Kontextschalter. </font><font style="vertical-align: inherit;">Dieses Mal werden wir den Code sorgf√§ltig studieren, da wir uns in Zukunft nur noch auf die 64-Bit-Version konzentrieren werden. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d8/26c/076/7d826c0761304c0e1b5ee41b42420fe3.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.6.0 (eingebauter Assembler x86_64)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** include/asm-x86_64/system.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SAVE_CONTEXT </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushfq ; pushq %%rbp ; movq %%rsi,%%rbp\n\t"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESTORE_CONTEXT </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %%rbp,%%rsi ; popq %%rbp ; popfq\n\t"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __EXTRA_CLOBBER ,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rcx"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rbx"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rdx"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r8"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r9"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r10"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r11"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r12"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r13"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r14"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r15"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev,next,last) asm volatile(SAVE_CONTEXT </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %%rsp,%P[threadrsp](%[prev])\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* save RSP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %P[threadrsp](%[next]),%%rsp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore RSP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"call __switch_to\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">".globl thread_return\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"thread_return:\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %%gs:%P[pda_pcurrent],%%rsi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %P[thread_info](%%rsi),%%r8\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"btr %[tif_fork],%P[ti_flags](%%r8)\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %%rax,%%rdi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jc ret_from_fork\n\t"</span></span></span><span class="hljs-meta"> RESTORE_CONTEXT : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=a"</span></span></span><span class="hljs-meta"> (last) : [next] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"S"</span></span></span><span class="hljs-meta"> (next), [prev] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"D"</span></span></span><span class="hljs-meta"> (prev), [threadrsp] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (offsetof(struct task_struct, thread.rsp)), [ti_flags] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (offsetof(struct thread_info, flags)), [tif_fork] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (TIF_FORK), [thread_info] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (offsetof(struct task_struct, thread_info)), [pda_pcurrent] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (offsetof(struct x8664_pda, pcurrent)) : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"memory"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cc"</span></span></span><span class="hljs-meta"> __EXTRA_CLOBBER)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Makro wurde in x86_64 aktualisiert </font></font><code>_switch_to()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, daher m√ºssen Sie seine Zeilen erneut durchgehen. </font><font style="vertical-align: inherit;">Viele √Ñnderungen sind einfach Registernamen ( </font></font><code>r..</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stattdessen </font></font><code>e..</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Es gibt einige andere Helfer, die ich oben angegeben habe.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SAVE_CONTEXT</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichert den Kernel-Kontext auf dem Stapel √ºber das oben gezeigte Hilfsmakro. </font><font style="vertical-align: inherit;">Sehr √§hnlich der 32-Bit-Version, mit Ausnahme der neuen Registernamen. </font><font style="vertical-align: inherit;">Das Makro wird am Ende des integrierten Assembler-Blocks mit RESTORE_CONTEXT gepaart.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movq %%rsp,%P[threadrsp](%[prev])\n\t"</span></span> <span class="hljs-comment"><span class="hljs-comment">/* save RSP */</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichert den aktuellen Stapelzeiger auf das TSS der alten Task. </font><font style="vertical-align: inherit;">Beachten Sie die neue Notation, die im Abschnitt </font></font><code>[threadrsp]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr Eingabeoperanden </font><font style="vertical-align: inherit;">definiert ist: Dies </font><font style="vertical-align: inherit;">ist der direkte Offset von thread.rsp in task_struct. </font></font><code>%P</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dereferenziert den prev: threadsp-Zeiger, um sicherzustellen, dass der aktualisierte SP ordnungsgem√§√ü gespeichert wird.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movq %P[threadrsp](%[next]),%%rsp\n\t"</span></span> <span class="hljs-comment"><span class="hljs-comment">/* restore RSP */</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stellt den Stapelzeiger einer neuen Aufgabe wieder her. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"call __switch_to\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruft Teil C des Kontextwechsels auf. </font><font style="vertical-align: inherit;">Es wird im n√§chsten Abschnitt beschrieben.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">".globl thread_return\n"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definiert eine globale Bezeichnung </font></font><code>thread_return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"thread_return:\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úbergangspunkt f√ºr </font></font><code>thread_return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Rein mechanisch sollte der Befehlszeiger ihm zum n√§chsten Befehl folgen. </font><font style="vertical-align: inherit;">Wird weder im Kernel noch in der Bibliothek verwendet (z. B. glibc). </font><font style="vertical-align: inherit;">Ich vermute, dass Pthreads es verwenden k√∂nnten ... aber es scheint nicht so zu sein.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movq %%gs:%P[pda_pcurrent],%%rsi\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legt den Index f√ºr die aktuelle Aufgabe fest, indem auf den Pro-Prozess-Datenbereich (PDA) verwiesen wird. </font><font style="vertical-align: inherit;">Im Kernelmodus sollte GS immer auf Daten f√ºr jeden Prozessor zeigen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movq %P[thread_info](%%rsi),%%r8\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschiebt die Struktur </font></font><code>thread_info</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach r8. </font><font style="vertical-align: inherit;">Dies ist neu in Linux 2.6 und im Wesentlichen eine leichte Version </font></font><code>task_struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die leicht auf den Stack passt.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"btr %[tif_fork],%P[ti_flags](%%r8)\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichert den Bitwert TIF_FORK in CF </font></font><code>thread_info-&gt;flags</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und setzt das Bit in der Struktur zur√ºck. </font><font style="vertical-align: inherit;">Nach einigen Zeilen wird dieses Bit nach dem Fork / Cloning gesetzt und zum Ausf√ºhren von ret_from_fork verwendet.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"movq %%rax,%%rdi\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichert den </font></font><code>task_struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorherigen Stream in der RDI. </font><font style="vertical-align: inherit;">Die letzte Anweisung, die mit EAX funktioniert </font></font><code>__switch_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">besteht darin, die C-Funktion aufzurufen </font><font style="vertical-align: inherit;">, die </font></font><code>prev</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu EAX zur√ºckkehrt.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"jc ret_from_fork\n\t"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn dieser Thread eine neue Gabel / ein neuer Klon ist, gehen Sie zu ret_from_fork, um erneut zu starten. </font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-string"><span class="hljs-string">"=a"</span></span> (last)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der vorherige Stream wird an EAX zur√ºckgegeben. </font></font><br><br><pre> <code class="cpp hljs">: [next] <span class="hljs-string"><span class="hljs-string">"S"</span></span> (next), [prev] <span class="hljs-string"><span class="hljs-string">"D"</span></span> (prev), [threadrsp] <span class="hljs-string"><span class="hljs-string">"i"</span></span> (offsetof(struct task_struct, thread.rsp)), [ti_flags] <span class="hljs-string"><span class="hljs-string">"i"</span></span> (offsetof(struct thread_info, flags)), [tif_fork] <span class="hljs-string"><span class="hljs-string">"i"</span></span> (TIF_FORK), [thread_info] <span class="hljs-string"><span class="hljs-string">"i"</span></span> (offsetof(struct task_struct, thread_info)), [pda_pcurrent] <span class="hljs-string"><span class="hljs-string">"i"</span></span> (offsetof(struct x8664_pda, pcurrent))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eingabelinks f√ºr Inline-Assembler. </font><font style="vertical-align: inherit;">Die meisten von ihnen sind direkte Operanden mit Offsets. </font><font style="vertical-align: inherit;">Oben haben wir sie bereits durchlaufen.</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-string"><span class="hljs-string">"memory"</span></span>, <span class="hljs-string"><span class="hljs-string">"cc"</span></span> __EXTRA_CLOBBER)</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 2.6.0 (x86_64 C)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/x86_64/kernel/process.c */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">switch_to</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cpu = smp_processor_id(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init_tss</span></span></span><span class="hljs-class"> + </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cpu</span></span></span><span class="hljs-class">;</span></span> unlazy_fpu(prev_p); tss-&gt;rsp0 = next-&gt;rsp0; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%es,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (prev-&gt;es))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;es | prev-&gt;es)) loadsegment(es, next-&gt;es); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%ds,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (prev-&gt;ds))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;ds | prev-&gt;ds)) loadsegment(ds, next-&gt;ds); load_TLS(next, cpu); <span class="hljs-comment"><span class="hljs-comment">/* Switch FS and GS. */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> fsindex; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%fs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=g"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (fsindex))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(fsindex | next-&gt;fsindex | prev-&gt;fs)) { loadsegment(fs, next-&gt;fsindex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fsindex) prev-&gt;fs = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* when next process has a 64bit base use it */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;fs) wrmsrl(MSR_FS_BASE, next-&gt;fs); prev-&gt;fsindex = fsindex; } { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> gsindex; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%gs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=g"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (gsindex))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(gsindex | next-&gt;gsindex | prev-&gt;gs)) { load_gs_index(next-&gt;gsindex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gsindex) prev-&gt;gs = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;gs) wrmsrl(MSR_KERNEL_GS_BASE, next-&gt;gs); prev-&gt;gsindex = gsindex; } <span class="hljs-comment"><span class="hljs-comment">/* Switch the PDA context. */</span></span> prev-&gt;userrsp = read_pda(oldrsp); write_pda(oldrsp, next-&gt;userrsp); write_pda(pcurrent, next_p); write_pda(kernelstack, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)next_p-&gt;thread_info + THREAD_SIZE - PDA_STACKOFFSET); <span class="hljs-comment"><span class="hljs-comment">/* Now maybe reload the debug registers */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;debugreg7)) { loaddebug(next, <span class="hljs-number"><span class="hljs-number">0</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">1</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">2</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* no 4 and 5 */</span></span> loaddebug(next, <span class="hljs-number"><span class="hljs-number">6</span></span>); loaddebug(next, <span class="hljs-number"><span class="hljs-number">7</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* Handle the IO bitmap */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(prev-&gt;io_bitmap_ptr || next-&gt;io_bitmap_ptr)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;io_bitmap_ptr) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(tss-&gt;io_bitmap, next-&gt;io_bitmap_ptr, IO_BITMAP_BYTES); tss-&gt;io_bitmap_base = IO_BITMAP_OFFSET; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tss-&gt;io_bitmap_base = INVALID_IO_BITMAP_OFFSET; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev_p; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Version x86_64 wurden dem C-Kontextwechselcode mehrere √Ñnderungen hinzugef√ºgt. </font><font style="vertical-align: inherit;">Ich werde einfache Fall√§nderungen nicht wiederholen (z. B. Umbenennen von EAX in RAX).</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%es,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (prev-&gt;es))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;es | prev-&gt;es)) loadsegment(es, next-&gt;es);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichert das ES-Segment f√ºr die alte Aufgabe und l√§dt dann bei Bedarf das neue. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%ds,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=m"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (prev-&gt;ds))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;ds | prev-&gt;ds)) loadsegment(ds, next-&gt;ds);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichert ein Datensegment f√ºr eine alte Aufgabe und l√§dt dann bei Bedarf ein neues. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> fsindex; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"movl %%fs,%0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=g"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (fsindex))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(fsindex | next-&gt;fsindex | prev-&gt;fs)) { loadsegment(fs, next-&gt;fsindex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fsindex) prev-&gt;fs = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschiebt das FS-Segment nach </font></font><code>fsindex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und l√§dt den FS bei Bedarf f√ºr eine neue Aufgabe. </font><font style="vertical-align: inherit;">Wenn eine alte oder neue Aufgabe einen g√ºltigen Wert f√ºr FS hat, wird im Prinzip etwas an seiner Stelle geladen (m√∂glicherweise NULL). </font><font style="vertical-align: inherit;">FS wird normalerweise f√ºr die Speicherung lokaler Streams verwendet, es gibt jedoch auch andere Verwendungszwecke, je nachdem, wann eine Kontextumschaltung erfolgt. </font><font style="vertical-align: inherit;">F√ºr GS wird genau derselbe Code verwendet, sodass keine Wiederholung erforderlich ist. </font><font style="vertical-align: inherit;">GS ist normalerweise ein Segment f√ºr </font></font><code>thread_info</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;fs) wrmsrl(MSR_FS_BASE, next-&gt;fs);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das FS-Register in der n√§chsten Aufgabe verwendet wird, m√ºssen Sie √ºberpr√ºfen, ob der gesamte 64-Bit-Wert geschrieben ist. </font><font style="vertical-align: inherit;">Denken Sie daran, dass Segmentregister ein Artefakt der 16/32-Bit-√Ñra sind. Eine spezielle Funktion √ºberpr√ºft daher, ob die oberen 32 Bit geschrieben sind.</font></font><br><br><pre> <code class="cpp hljs">prev-&gt;fsindex = fsindex;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichern Sie FS f√ºr die alte Aufgabe. </font></font><br><br><pre> <code class="cpp hljs">prev-&gt;userrsp = read_pda(oldrsp); write_pda(oldrsp, next-&gt;userrsp); write_pda(pcurrent, next_p); write_pda(kernelstack, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)next_p-&gt;thread_info + THREAD_SIZE - PDA_STACKOFFSET);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisieren des PDA f√ºr eine bevorstehende Aufgabe, einschlie√ülich Speichern des alten RSP (Syscall) der alten Aufgabe. </font><font style="vertical-align: inherit;">Der PDA wird mit Stream- und Stack-Informationen aktualisiert.</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 3.0: modernes Betriebssystem (2011) </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie sich von der Zahl nicht t√§uschen. </font><font style="vertical-align: inherit;">Tats√§chlich wurde Version 3.0 </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast 8 Jahre</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nach 2.6.0 ver√∂ffentlicht. </font><font style="vertical-align: inherit;">Eine Vielzahl von √Ñnderungen verdient ein ganzes Buch, und ich kann Ihnen nicht alles erz√§hlen. </font><font style="vertical-align: inherit;">Bei der Kontextumschaltung werden i386 und x86_64 in x86 mit separaten Prozessdateien (process_32.c und process_64.s) kombiniert. Dieser Artikel ist bereits zu umfangreich, sodass </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir die x86_64-Version erst sp√§ter analysieren werden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir werden nur einige Details skizzieren und uns die neueste LTS genauer ansehen. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d0a/a82/1f5/d0aa821f59086dc1f0937e4139353fff.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 3.0.1 (eingebauter Assembler x86_64)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/x86/include/asm/system.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SAVE_CONTEXT </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pushf ; pushq %%rbp ; movq %%rsi,%%rbp\n\t"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESTORE_CONTEXT </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %%rbp,%%rsi ; popq %%rbp ; popf\t"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __EXTRA_CLOBBER \ ,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rcx"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rbx"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rdx"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r8"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r9"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r10"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r11"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r12"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r13"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r14"</span></span></span><span class="hljs-meta">,</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"r15"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev, next, last) asm volatile(SAVE_CONTEXT </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %%rsp,%P[threadrsp](%[prev])\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* save RSP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %P[threadrsp](%[next]),%%rsp\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore RSP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"call __switch_to\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq "</span></span></span><span class="hljs-meta">__percpu_arg([current_task])</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">",%%rsi\n\t"</span></span></span><span class="hljs-meta"> __switch_canary </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %P[thread_info](%%rsi),%%r8\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movq %%rax,%%rdi\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"testl %[_tif_fork],%P[ti_flags](%%r8)\n\t"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jnz ret_from_fork\n\t"</span></span></span><span class="hljs-meta"> RESTORE_CONTEXT : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"=a"</span></span></span><span class="hljs-meta"> (last) __switch_canary_oparam : [next] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"S"</span></span></span><span class="hljs-meta"> (next), [prev] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"D"</span></span></span><span class="hljs-meta"> (prev), [threadrsp] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (offsetof(struct task_struct, thread.sp)), [ti_flags] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (offsetof(struct thread_info, flags)), [_tif_fork] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (_TIF_FORK), [thread_info] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"i"</span></span></span><span class="hljs-meta"> (offsetof(struct task_struct, stack)), [current_task] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"m"</span></span></span><span class="hljs-meta"> (current_task) __switch_canary_iparam : </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"memory"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cc"</span></span></span><span class="hljs-meta"> __EXTRA_CLOBBER)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acht Jahre - und </font></font><code>switch_to()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur vier √Ñnderungen </font><font style="vertical-align: inherit;">im Makro </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zwei von ihnen sind miteinander verbunden und nichts radikal Neues.</font></font><br><br><pre> <code class="cpp hljs">movq <span class="hljs-string"><span class="hljs-string">"__percpu_arg([current_task])"</span></span>,%%rsi\n\t</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschiebt neue Naht </font></font><code>task_struct</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu RSI. </font><font style="vertical-align: inherit;">Dies ist die ‚Äûneue‚Äú M√∂glichkeit, auf Aufgabeninformationen zuzugreifen: Jede CPU verf√ºgt √ºber ein statisches Symbol. </font><font style="vertical-align: inherit;">Zuvor waren Informationen √ºber GS verf√ºgbar: [pda offset]. </font><font style="vertical-align: inherit;">Nachfolgende RSI-Vorg√§nge sind dieselben wie in Version 2.6.</font></font><br><br><pre> <code class="cpp hljs">__switch_canary</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit diesem Makro k√∂nnen Sie zus√§tzlich pr√ºfen, ob das Makro CONFIG_CC_STACKPROTECTOR w√§hrend der Kernelassemblierung aktiviert ist. </font><font style="vertical-align: inherit;">Ich werde dieses Thema nicht zu tief vertiefen, au√üer dass dieser Mechanismus vor der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zerst√∂rung des Stapels durch Hacker</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sch√ºtzt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tats√§chlich speichern wir einen zuf√§lligen Wert und √ºberpr√ºfen ihn sp√§ter. </font><font style="vertical-align: inherit;">Wenn sich die Bedeutung ge√§ndert hat, bedeutet dies √Ñrger.</font></font><br><br><pre> <code class="cpp hljs">testl %[_tif_fork],%P[ti_flags](%%r8)\n\t jnz ret_from_fork\n\t</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberpr√ºft, ob eine neue Aufgabe einfach mit Klonen / Fork erstellt wurde, und f√§hrt dann mit fort </font></font><code>ret_from_fork()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fr√ºher war dies eine Anweisung </font></font><code>btr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber jetzt verschieben wir das Zur√ºcksetzen des Bits, bis der Aufruf endet. </font><font style="vertical-align: inherit;">Der Name wurde aufgrund einer Test√§nderung in JNZ ge√§ndert: Wenn das Bit gesetzt ist, ist TEST (AND) positiv.</font></font><br><br><pre> <code class="cpp hljs">__switch_canary_oparam</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ausgabe von Stack Canary f√ºr </font></font><code>CONFIG_CC_STACKPROTECTOR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs">__switch_canary_iparam</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input Stack Canary f√ºr </font></font><code>CONFIG_CC_STACKPROTECTOR</code> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 3.0.1 (x86_64 C)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/x86/kernel/process_64.c */</span></span> __notrace_funcgraph <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> * __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">switch_to</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cpu = smp_processor_id(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">per_cpu</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init_tss</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cpu</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> fsindex, gsindex; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> preload_fpu; preload_fpu = tsk_used_math(next_p) &amp;&amp; next_p-&gt;fpu_counter &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* we're going to use this soon, after a few expensive things */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preload_fpu) prefetch(next-&gt;fpu.state); <span class="hljs-comment"><span class="hljs-comment">/* Reload esp0, LDT and the page table pointer: */</span></span> load_sp0(tss, next); savesegment(es, prev-&gt;es); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;es | prev-&gt;es)) loadsegment(es, next-&gt;es); savesegment(ds, prev-&gt;ds); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;ds | prev-&gt;ds)) loadsegment(ds, next-&gt;ds); savesegment(fs, fsindex); savesegment(gs, gsindex); load_TLS(next, cpu); __unlazy_fpu(prev_p); <span class="hljs-comment"><span class="hljs-comment">/* Make sure cpu is ready for new context */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preload_fpu) clts(); arch_end_context_switch(next_p); <span class="hljs-comment"><span class="hljs-comment">/* Switch FS and GS. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(fsindex | next-&gt;fsindex | prev-&gt;fs)) { loadsegment(fs, next-&gt;fsindex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fsindex) prev-&gt;fs = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* when next process has a 64bit base use it */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;fs) wrmsrl(MSR_FS_BASE, next-&gt;fs); prev-&gt;fsindex = fsindex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(gsindex | next-&gt;gsindex | prev-&gt;gs)) { load_gs_index(next-&gt;gsindex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gsindex) prev-&gt;gs = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next-&gt;gs) wrmsrl(MSR_KERNEL_GS_BASE, next-&gt;gs); prev-&gt;gsindex = gsindex; <span class="hljs-comment"><span class="hljs-comment">/* Switch the PDA and FPU contexts. */</span></span> prev-&gt;usersp = percpu_read(old_rsp); percpu_write(old_rsp, next-&gt;usersp); percpu_write(current_task, next_p); percpu_write(kernel_stack, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)task_stack_page(next_p) + THREAD_SIZE - KERNEL_STACK_OFFSET); <span class="hljs-comment"><span class="hljs-comment">/* Now maybe reload the debug registers and handle I/O bitmaps */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(task_thread_info(next_p)-&gt;flags &amp; _TIF_WORK_CTXSW_NEXT || task_thread_info(prev_p)-&gt;flags &amp; _TIF_WORK_CTXSW_PREV)) __switch_to_xtra(prev_p, next_p, tss); <span class="hljs-comment"><span class="hljs-comment">/* Preload the FPU context - task is likely to be using it. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preload_fpu) __math_state_restore(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev_p; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt einige √Ñnderungen im C-Code, aber angesichts der acht Jahre zwischen den Ver√∂ffentlichungen sind sie relativ wenige. </font><font style="vertical-align: inherit;">Einige von ihnen sind beispielsweise kosmetischer Natur und stehen an der Spitze aller Erkl√§rungen. </font><font style="vertical-align: inherit;">Folgendes hat sich ge√§ndert:</font></font><br><br><pre> <code class="cpp hljs">__notrace_funcgraph <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> * __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">switch_to</span></span></span><span class="hljs-class">(...)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine neue Signatur </font></font><code>__notrace_funcgraph</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verhindert, dass aktive ftrace verfolgt werden </font></font><code>switch_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs">preload_fpu = tsk_used_math(next_p) &amp;&amp; next_p-&gt;fpu_counter &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preload_fpu) prefetch(next-&gt;fpu.state);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úberpr√ºft, ob die FPU in der letzten Aufgabe f√ºr die letzten 5 Zeitscheiben verwendet wurde, und versucht dann, die Daten f√ºr die sp√§tere Verwendung zwischenzuspeichern. </font></font><br><br><pre> <code class="cpp hljs">load_sp0(tss, next);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L√§dt einen Kernel-Space-Stack-Zeiger, aktualisiert Seitentabellen und benachrichtigt den Hypervisor (falls zutreffend). </font></font><br><br><pre> <code class="cpp hljs">savesegment(es, prev-&gt;es);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichert das ES-Segment. </font><font style="vertical-align: inherit;">Dies ist keine Innovation, sondern nur ein Ersatz f√ºr den Inline-Assembler ab 2.6:</font></font><code>asm volatile("movl %%es,%0" : "=m" (prev-&gt;es));</code>  . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preload_fpu) clts();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startet die FPU sofort neu, wenn sie wahrscheinlich verwendet wird. </font><font style="vertical-align: inherit;">Anwendung </font></font><code>clts()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- die gleiche Idee , </font><font style="vertical-align: inherit;">dass wir mit der ersten Version des Linux sehen: </font></font><code>"cmpl %%ecx,%2\n\t jne 1f\n\t clts\n"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs">jne <span class="hljs-number"><span class="hljs-number">1f</span></span>\n\t clts\n<span class="hljs-string"><span class="hljs-string">" arch_end_context_switch(next_p);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur f√ºr die </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Virtualisierung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> relevant </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Unter normalen Umst√§nden macht eine Funktion </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nichts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Weitere Informationen finden Sie in der endg√ºltigen Kernelversion.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(task_thread_info(next_p)-&gt;flags &amp; _TIF_WORK_CTXSW_NEXT || task_thread_info(prev_p)-&gt;flags &amp; _TIF_WORK_CTXSW_PREV)) __switch_to_xtra(prev_p, next_p, tss);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besch√§ftigt sich mit Verwaltungsarbeiten, die zuvor am Ende beschrieben wurden </font></font><code>switch_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, einschlie√ülich Debug-Registern und E / A-Bitmap-Parametern. </font><font style="vertical-align: inherit;">Wir werden Ihnen mehr dar√ºber in der Code√ºberpr√ºfung 4.14.67 erz√§hlen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preload_fpu) __math_state_restore();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellt die FPU wieder her, nachdem ihre Verwendung √ºberpr√ºft wurde. </font><font style="vertical-align: inherit;">Bei einer erfolgreichen Kombination von Umst√§nden sollten sich die Daten dank der zuvor getroffenen Vorauswahl bereits im Cache befinden.</font></font><br><br><a name="8"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Linux 4.14.67: neueste LTS (2018) </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist unser tiefstes Eintauchen in das Innenleben des Kontextwechsels. </font><font style="vertical-align: inherit;">Das Verfahren wurde seit der Ver√∂ffentlichung von 3.0 erheblich √ºberarbeitet und der Code organisiert. </font><font style="vertical-align: inherit;">Insgesamt sieht es jetzt sauberer und organisierter aus als je zuvor. </font><font style="vertical-align: inherit;">F√ºr x86_64:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/140/b4b/ca3/140b4bca3a13ffac5abe3a2b3e723dc0.png"><br><br><ul><li>   3.4    <code>switch_to()</code>     <a href="" rel="nofollow">arch/x86/include/asm/switch_to.h</a> .     ,   <code>context_switch()</code>  <a href="" rel="nofollow">kernel/sched/core.</a> . <br></li><li>    4.9 <code>switch_to()</code>    :  <code>prepare_switch_to()</code>          ( <a href="" rel="nofollow">arch/x86/entry/entry_64.S</a> ). <br></li><li>   C            .   2.6.24    <a href="" rel="nofollow">arch/x86/kernel/process_64.c</a> . </li></ul><br> <b>Linux 4.14.67</b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/x86/include/asm/switch_to.h */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> switch_to(prev, next, last) do { prepare_switch_to(prev, next); ((last) = __switch_to_asm((prev), (next))); } while (0)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sieht im Vergleich zu alten Kerneln einfach aus. </font><font style="vertical-align: inherit;">Diese Reorganisation war das Ergebnis einer L√∂sung des Problems, als Andy Lutomirski </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">praktisch passende Kernel-Stacks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einf√ºhrte </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs">prepare_switch_to(prev, next);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellt sicher, dass Kernelstapel verf√ºgbar sind, bevor Sie versuchen, den Kontext zu wechseln. </font><font style="vertical-align: inherit;">Dies vermeidet einen m√∂glichen Doppelfehler oder eine Kernel-Panik beim Versuch, den Kontext zu wechseln, wenn virtuell zugeordnete Kernel-Stapel verwendet werden.</font></font><br><br><pre> <code class="cpp hljs">((last) = __switch_to_asm((prev), (next)));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Startet den eigentlichen Kontextwechsel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen Sie sich das an </font></font><code>prepare_switch_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das in derselben Quelldatei definiert ist. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 4.14.67</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/x86/include/asm/switch_to.h */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare_switch_to</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct task_struct *prev, struct task_struct *next)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_VMAP_STACK READ_ONCE(*(unsigned char *)next-&gt;thread.sp); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_VMAP_STACK</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bestimmt, wann der Stapel virtuellen Speicher verwendet. </font><font style="vertical-align: inherit;">Wir m√ºssen uns nur dann auf den Kontextwechsel vorbereiten, wenn wir virtuelle Stapel verwenden. </font><font style="vertical-align: inherit;">Dies ist ein Konfigurationsparameter w√§hrend der Kernel-Erstellung. </font><font style="vertical-align: inherit;">In vielen modernen Distributionen der Standardwert </font></font><code>yes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs">READ_ONCE(*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)next-&gt;thread.sp);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beziehen Sie sich auf den n√§chsten Stapel, um Seitentabellen (pgd) zu reparieren. </font><font style="vertical-align: inherit;">Das Hauptproblem besteht darin, dass wir versuchen, auf einen Zeiger zuzugreifen, der sich nicht nur au√üerhalb der Seiten befindet (ausgelagert), sondern aufgrund des verz√∂gerten Ladens des vmalloc-Bereichs auch nicht im Kontext des Speichers dieser Aufgabe. </font><font style="vertical-align: inherit;">Das Fehlen und die Unzug√§nglichkeit eines Zeigers </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedeutet eine Kernel-Panik,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wenn Sie das Problem nicht im Voraus l√∂sen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 4.16.67</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/x86/entry/entry_64.S */</span></span> ENTRY(__switch_to_asm) UNWIND_HINT_FUNC <span class="hljs-comment"><span class="hljs-comment">/* Save callee-saved registers */</span></span> pushq %rbp pushq %rbx pushq %r12 pushq %r13 pushq %r14 pushq %r15 <span class="hljs-comment"><span class="hljs-comment">/* switch stack */</span></span> movq %rsp, TASK_threadsp(%rdi) <span class="hljs-function"><span class="hljs-function">movq </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TASK_threadsp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function">, %rsp </span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-meta">#</span></span><span class="hljs-meta-keyword"><span class="hljs-function"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span></span><span class="hljs-function"><span class="hljs-meta"> CONFIG_CC_STACKPROTECTOR movq TASK_stack_canary(%rsi), %rbx movq %rbx, PER_CPU_VAR(irq_stack_union)+stack_canary_offset #</span></span><span class="hljs-meta-keyword"><span class="hljs-function"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span><span class="hljs-function"><span class="hljs-meta"> #</span></span><span class="hljs-meta-keyword"><span class="hljs-function"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span></span><span class="hljs-function"><span class="hljs-meta"> CONFIG_RETPOLINE FILL_RETURN_BUFFER %r12, RSB_CLEAR_LOOPS, X86_FEATURE_RSB_CTXSW #</span></span><span class="hljs-meta-keyword"><span class="hljs-function"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span><span class="hljs-function"><span class="hljs-meta"> </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-meta"><span class="hljs-comment">/* restore callee-saved registers */</span></span></span></span><span class="hljs-function"><span class="hljs-meta"> popq %r15 popq %r14 popq %r13 popq %r12 popq %rbx popq %rbp jmp __switch_to END(__switch_to_asm)</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entry_64.S</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enth√§lt Arbeit , </font><font style="vertical-align: inherit;">dass die vorherigen 25 Jahren in der Linux - </font><font style="vertical-align: inherit;">Inline - </font><font style="vertical-align: inherit;">Assembler ausgef√ºhrt.</font></font><br><br><pre> <code class="cpp hljs">UNWIND_HINT_FUNC</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generiert QuickInfos, die vom gerade beendeten objtool-Stack-Trace-Tool verwendet werden. </font><font style="vertical-align: inherit;">Dies ist f√ºr spezielle Erstellungsverfahren erforderlich, die nicht den √ºblichen Konventionen f√ºr C-Sprachaufrufe entsprechen. Solche Hinweise sind der Grund f√ºr die erfolgreiche Implementierung von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ORC-Code-Unwinder</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Version 4.6.</font></font><br><br><pre> <code class="cpp hljs">pushq %rbp, %rbx, %r12, %r13, %r14, %r15</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir speichern die Register auf dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alten Stapel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , von dem wir wechseln.</font></font><br><br><pre> <code class="cpp hljs">movq %rsp, TASK_threadsp(%rdi) <span class="hljs-function"><span class="hljs-function">movq </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TASK_threadsp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function">, %rsp</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich tausche Stapelzeiger zwischen der alten und der neuen Aufgabe. </font><font style="vertical-align: inherit;">Direkt aus der Umgebungs Montage ist nicht klar, aber enth√§lt RDI und RSI Eingabeargumente </font></font><code>task_struct *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prev</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weiter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in √úbereinstimmung mit den Konventionen System V ABI. </font><font style="vertical-align: inherit;">Hier ist eine Teilmenge der Register zusammen mit ihrer Verwendung:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9bc/13e/410/9bc13e4108b9c67a1a9d8cd78439b7a5.png"><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_CC_STACKPROTECTOR movq TASK_stack_canary(%rsi), %rbx movq %rbx, PER_CPU_VAR(irq_stack_union)+stack_canary_offset</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Stapelschutz aktiviert ist, wird der Kanarienwert dieser Aufgabe an die entsprechende Stelle im Interrupt-Stapel der aktuellen CPU verschoben. </font><font style="vertical-align: inherit;">Der Stapelschutz ist normalerweise standardm√§√üig aktiviert, daher geschieht dies normalerweise.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_RETPOLINE FILL_RETURN_BUFFER %r12, RSB_CLEAR_LOOPS, X86_FEATURE_RSB_CTXSW</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schutz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gegen eine m√∂gliche Ausnutzung der Verzweigungsvorhersage (Spectre-Schwachstelle). </font><font style="vertical-align: inherit;">Reines </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voodoo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br><br><pre> <code class="cpp hljs">popq %r15, %r14, %r13, %r12, %rbx, %rbp</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellt alle Register aus dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neuen Stapel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in umgekehrter Reihenfolge wieder her: (r15, r14, r13, r12, rbx, rbp) </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux 4.16.67 ( </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit Kommentaren)</font></font></b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** arch/x86/kernel/process_64.c */</span></span> __visible __notrace_funcgraph <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> * __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">switch_to</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpu</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_fpu</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpu</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpu</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_fpu</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpu</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cpu = smp_processor_id(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">per_cpu</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cpu_tss_rw</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cpu</span></span></span><span class="hljs-class">);</span></span> WARN_ON_ONCE(IS_ENABLED(CONFIG_DEBUG_ENTRY) &amp;&amp; this_cpu_read(irq_count) != <span class="hljs-number"><span class="hljs-number">-1</span></span>); switch_fpu_prepare(prev_fpu, cpu); save_fsgs(prev_p); load_TLS(next, cpu); arch_end_context_switch(next_p); savesegment(es, prev-&gt;es); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;es | prev-&gt;es)) loadsegment(es, next-&gt;es); savesegment(ds, prev-&gt;ds); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;ds | prev-&gt;ds)) loadsegment(ds, next-&gt;ds); load_seg_legacy(prev-&gt;fsindex, prev-&gt;fsbase, next-&gt;fsindex, next-&gt;fsbase, FS); load_seg_legacy(prev-&gt;gsindex, prev-&gt;gsbase, next-&gt;gsindex, next-&gt;gsbase, GS); switch_fpu_finish(next_fpu, cpu); <span class="hljs-comment"><span class="hljs-comment">/* Switch the PDA and FPU contexts. */</span></span> this_cpu_write(current_task, next_p); this_cpu_write(cpu_current_top_of_stack, task_top_of_stack(next_p)); <span class="hljs-comment"><span class="hljs-comment">/* Reload sp0. */</span></span> update_sp0(next_p); <span class="hljs-comment"><span class="hljs-comment">/* Now maybe reload the debug registers and handle I/O bitmaps */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(task_thread_info(next_p)-&gt;flags &amp; _TIF_WORK_CTXSW_NEXT || task_thread_info(prev_p)-&gt;flags &amp; _TIF_WORK_CTXSW_PREV)) __switch_to_xtra(prev_p, next_p, tss); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_XEN_PV </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (unlikely(static_cpu_has(X86_FEATURE_XENPV) &amp;&amp; prev-&gt;iopl != next-&gt;iopl)) xen_set_iopl_mask(next-&gt;iopl); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (static_cpu_has_bug(X86_BUG_SYSRET_SS_ATTRS)) { unsigned short ss_sel; savesegment(ss, ss_sel); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ss_sel != __KERNEL_DS) loadsegment(ss, __KERNEL_DS); } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Load the Intel cache allocation PQR MSR. */</span></span></span><span class="hljs-meta"> intel_rdt_sched_in(); return prev_p; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit diesem letzten Codeblock k√∂nnen Sie sich mit den neuesten √Ñnderungen im Kontextwechsel vertraut machen! </font><font style="vertical-align: inherit;">Wenn Sie den Artikel sofort an diesen Ort gescrollt haben, machen Sie sich keine Sorgen - ich werde die meisten Punkte hier (erneut) und detaillierter betrachten. </font><font style="vertical-align: inherit;">Beachten Sie einige Ausnahmen, die in den Kontextwechsel fallen.</font></font><br><br><pre> <code class="cpp hljs">__visible __notrace_funcgraph <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> * __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">switch_to</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Signatur f√ºr den Kontextwechsel zu C besteht aus mehreren Teilen: </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__visible</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Dieses Attribut stellt sicher, dass durch die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimierung w√§hrend des Layoutprozesses</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das Zeichen nicht entfernt wird </font></font><code>__switch_to()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__notrace_funcgraph</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - sch√ºtzt </font></font><code>__switch_to()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vor dem ftrace-Tracer. </font><font style="vertical-align: inherit;">Die Funktion wurde ungef√§hr in Version 2.6.29 hinzugef√ºgt und bald aktiviert.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Eingabeargumente sind Zeiger auf die alten und neuen Aufgaben, die an RDI und RSI √ºbergeben werden. </font></font></li></ul><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_p</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpu</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev_fpu</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpu</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpu</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next_fpu</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fpu</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sammelt einige Informationen aus Eingabedaten </font></font><code>task_struct *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Thread_struct </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enth√§lt die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TSS-Daten f√ºr die Task (Register usw.). Die Struktur </font></font><code>fpu&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enth√§lt die FPU-Daten, z. B. die zuletzt verwendete CPU, die Initialisierung und die Registerwerte.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cpu = smp_processor_id();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gibt die Prozessornummer zur√ºck, die wir ben√∂tigen, um die GDT f√ºr TSS-Daten, die lokale Thread-Speicherung und den Vergleich des Status von Tankstellen zu steuern. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tss</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">per_cpu</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cpu_tss_rw</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cpu</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigt die </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aktuelle TSS-CPU an</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs">WARN_ON_ONCE(IS_ENABLED(CONFIG_DEBUG_ENTRY) &amp;&amp; this_cpu_read(irq_count) != <span class="hljs-number"><span class="hljs-number">-1</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legt fest, ob der IRQ-Stapel w√§hrend der Kontextumschaltung verwendet wird, und meldet dies einmal pro Last. </font><font style="vertical-align: inherit;">Dies wurde zu Beginn der Entwicklung 4.14 hinzugef√ºgt, und tats√§chlich wirkt sich dieser Code nicht auf die Kontextumschaltung aus.</font></font><br><br><pre> <code class="cpp hljs">switch_fpu_prepare(prev_fpu, cpu);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichert den aktuellen Status der FPU, w√§hrend wir uns in der alten Aufgabe befinden. </font></font><br><br><pre> <code class="cpp hljs">save_fsgs(prev_p);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichert FS und GS, bevor wir den lokalen Stream-Speicher √§ndern. </font></font><br><br><pre> <code class="cpp hljs">load_TLS(next, cpu);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√§dt GDT f√ºr die lokale Thread-Speicherung neuer Aufgaben neu. </font><font style="vertical-align: inherit;">Kopiert tls_array mechanisch aus einem neuen Stream in die GDT-Datens√§tze 6, 7 und 8.</font></font><br><br><pre> <code class="cpp hljs">arch_end_context_switch(next_p);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Funktion wird nur bei Paravirtualisierung definiert. </font><font style="vertical-align: inherit;">√Ñndert den Paravirt-Modus und l√∂scht alle verbleibenden Stapelarbeiten. </font><font style="vertical-align: inherit;">Eingef√ºhrt in neueren Versionen 2.6.x. </font><font style="vertical-align: inherit;">Ich bin nicht zu stark in dieser Funktionalit√§t, deshalb √ºberlasse ich sie den </font><font style="vertical-align: inherit;">Lesern </font><font style="vertical-align: inherit;">zur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recherche</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs">savesegment(es, prev-&gt;es); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(next-&gt;es | prev-&gt;es)) loadsegment(es, next-&gt;es);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichert das ES-Segment und l√§dt bei Bedarf ein neues. </font><font style="vertical-align: inherit;">Ein √§hnlicher DS-Aufruf wird weggelassen. </font><font style="vertical-align: inherit;">Auch wenn die neue Aufgabe kein DS / ES verwendet, werden alle alten Werte gel√∂scht.</font></font><br><br><pre> <code class="cpp hljs">load_seg_legacy(prev-&gt;fsindex, prev-&gt;fsbase, next-&gt;fsindex, next-&gt;fsbase, FS);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√§dt neue FS-Segmente (GS weggelassen). </font><font style="vertical-align: inherit;">Dadurch werden Register f√ºr 32-Bit- und 64-Bit-Registertypen erkannt und geladen. </font><font style="vertical-align: inherit;">Die neue Aufgabe ist jetzt bereit f√ºr TLS.</font></font><br><br><pre> <code class="cpp hljs">switch_fpu_finish(next_fpu, cpu);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Initialisiert den Status der FPU f√ºr eine eingehende Aufgabe. </font></font><br><br><pre> <code class="cpp hljs">this_cpu_write(current_task, next_p);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert die aktuelle CPU ( </font></font><code>task_struct *</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) - </font><font style="vertical-align: inherit;">Aufgabe </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aktualisiert effektiv den Status der FPU und des PDA (Datenbereich f√ºr jeden Prozessor).</font></font><br><br><pre> <code class="cpp hljs">this_cpu_write(cpu_current_top_of_stack, task_top_of_stack(next_p));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU aktualisiert den Stapelzeiger, der </font><font style="vertical-align: inherit;">tats√§chlich sp1 als √ºberlastet ist </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erzeugten Code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Eintrag Trampolin) f√ºr die </font><font style="vertical-align: inherit;">Sicherheit.</font></font><br><br><pre> <code class="cpp hljs">update_sp0(next_p);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Validierung eines neuen Stapels, um ihn zu √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Es sieht so aus, als ob hier sp0 angegeben werden sollte, nicht sp1? </font><font style="vertical-align: inherit;">Sollte wahrscheinlich umbenannt werden.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(task_thread_info(next_p)-&gt;flags &amp; _TIF_WORK_CTXSW_NEXT || task_thread_info(prev_p)-&gt;flags &amp; _TIF_WORK_CTXSW_PREV)) __switch_to_xtra(prev_p, next_p, tss);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktualisiert Debug-Register und E / A-Bitmaps. </font><font style="vertical-align: inherit;">Diese beiden Aufgaben wurden zuvor direkt im Kontextwechsel ausgef√ºhrt, werden jetzt jedoch in verschoben </font></font><code>__switch_to_xtra()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_XEN_PV </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (unlikely(static_cpu_has(X86_FEATURE_XENPV) &amp;&amp; prev-&gt;iopl != next-&gt;iopl)) xen_set_iopl_mask(next-&gt;iopl);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tauscht die E / A-Berechtigungsbits manuell gegen Xen-Paravirtualisierung aus. </font><font style="vertical-align: inherit;">Anscheinend </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktioniert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der regul√§re Flag-Schalter </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">nicht richtig</font></a><font style="vertical-align: inherit;"> , und deshalb m√ºssen Sie die aktuellen Bits direkt maskieren.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (static_cpu_has_bug(X86_BUG_SYSRET_SS_ATTRS)) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> ss_sel; savesegment(ss, ss_sel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ss_sel != __KERNEL_DS) loadsegment(ss, __KERNEL_DS);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blendet </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unerwartetes Verhalten SYSRET</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in AMD - </font><font style="vertical-align: inherit;">Prozessoren, die nicht richtig Segmentbeschreibern aktualisieren.</font></font><br><br><pre> <code class="cpp hljs">intel_rdt_sched_in();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Intel-Bereinigungsaufgaben. </font><font style="vertical-align: inherit;">Aktualisiert </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RMID und CLOSid</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev_p;</code> </pre> <br>  Fertig! <br><br><h1>  FAQ </h1><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum haben Sie diese Kernel-Versionen ausgew√§hlt? </font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste und letzte Version waren offensichtliche Kandidaten. </font><font style="vertical-align: inherit;">Urspr√ºnglich wollte ich vier weitere Zwischenversionen in Betracht ziehen (2.1, 2.3, 2.5 und 2.6.26), aber die √Ñnderungen reichten nicht aus, um den Artikel zu stark aufzublasen. </font><font style="vertical-align: inherit;">Sie ist schon zu gro√ü. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie lange hat diese Studie gedauert? </font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwei Wochen. </font><font style="vertical-align: inherit;">Eine Woche f√ºr Code-Analyse, Notizen und technische Tutorials. </font><font style="vertical-align: inherit;">Dann eine Woche, um Notizen neu zu schreiben, Diagramme zu zeichnen und den Artikel zu formatieren. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.14.67 - nicht die neueste LTS-Version? </font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich begann am 1. September mit dem Studium des Codes und nahm den Quellcode 4.14.67. </font><font style="vertical-align: inherit;">Die Version 4.14.68 wurde vier Tage sp√§ter fertiggestellt. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich werde weitere Fragen hinzuf√ºgen, sobald sie verf√ºgbar sind.</font></font></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438042/">https://habr.com/ru/post/de438042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438024/index.html">Schnelle Zahlungen: Wor√ºber sich Banken Sorgen machen m√ºssen</a></li>
<li><a href="../de438028/index.html">Sie brauchen keine Blockchain: 8 beliebte Benutzerf√§lle und warum sie nicht funktionieren</a></li>
<li><a href="../de438032/index.html">Beliebte Open Source - Teil zwei: 5 Cloud-Management-Tools</a></li>
<li><a href="../de438036/index.html">3blue1brown und MIT auf Russisch</a></li>
<li><a href="../de438038/index.html">Karriere Steroide. Echte Geschichten</a></li>
<li><a href="../de438046/index.html">Wie kann man schnell eine Million Punkte auf Spark geocodieren?</a></li>
<li><a href="../de438050/index.html">Kalman-Filter zur Minimierung des Entropiewertes eines zuf√§lligen Fehlers mit einer nicht-Gau√üschen Verteilung</a></li>
<li><a href="../de438052/index.html">Interaktor, Betriebsmuster</a></li>
<li><a href="../de438058/index.html">"Datenanalyse in Python" in zwei Teilen</a></li>
<li><a href="../de438060/index.html">Einsch√§tzung der r√§umlichen Ausrichtung oder Wie man keine Angst vor Mahoney- und Majwik-Filtern hat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>