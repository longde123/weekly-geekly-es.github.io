<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏼 😴 👩🏽‍🤝‍👨🏼 Prinsip Desain yang Dimaksudkan untuk Jakarta EE 👨🏿‍🏫 🧙🏾 🎆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Kami baru-baru ini menerbitkan buku " Belajar Java EE. Pemrograman Modern untuk Perusahaan Besar " oleh juara Jawa Jerman Sebastian Dashne...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prinsip Desain yang Dimaksudkan untuk Jakarta EE</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/416429/">  Halo, Habr!  Kami baru-baru ini menerbitkan buku " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Belajar Java EE. Pemrograman Modern untuk Perusahaan Besar</a> " oleh juara Jawa Jerman Sebastian Dashner. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lb/zz/5c/lbzz5cdzefa6q-f5fv5sruxhzck.jpeg"></div><br>  Dashner aktif menulis dan berbicara tentang topik yang berkaitan dengan Java EE modern, sehingga blognya tidak mengabaikan prinsip-prinsip desain umum untuk platform EE Jakarta, yang sekarang dikembangkan oleh Eclipse.  Terjemahan artikel khusus ini (Juni) kami sampaikan kepada Anda hari ini. <br><a name="habracut"></a><br>  Platform Jakarta EE secara bertahap mengambil alih, dan spesifikasi baru untuk pengembangan perusahaan muncul bersamaan dengannya.  Untuk menyetujui berbagai standar dan teknologi yang akan segera muncul, seluruh komunitas Java EE hanya akan mendapat manfaat jika prinsip-prinsip desain umum untuk spesifikasi EE Jakarta dikembangkan. <br><br>  Saya percaya teknologi Java EE telah begitu sukses hanya dengan beberapa prinsip.  Di bawah ini saya akan menyampaikan pandangan saya tentang prinsip-prinsip desain mana yang telah dikembangkan di Jawa EE menurut saya yang paling penting, yang layak untuk dipelajari lebih lanjut dan berpotensi dapat berfungsi sebagai rekomendasi untuk desain di Jakarta EE. <br><br>  Saya memutuskan untuk menulis artikel ini, terinspirasi oleh proposal Dmitry Kornilov mengenai arah pengembangan teknis EE Jakarta. <br><br>  <b>Yang pertama adalah logika bisnis</b> <br><br>  Model pemrograman yang diadopsi dalam Java EE memungkinkan pengembang untuk fokus pada apa yang diperlukan - yaitu, pada logika bisnis.  Anda tidak perlu lagi mewarisi kelas API;  pengembang dapat mengekspresikan logika area subjeknya dalam bahasa Java yang biasa dan sebagian besar secara deklaratif (menggunakan anotasi) mengontrol perilaku server aplikasi.  Dengan demikian, kerangka kerja terintegrasi dengan mulus ke dalam kode Anda dan, pada dasarnya, mudah untuk dihapus dari sana.  Saat mendesain, jangan mengandalkan penggunaan kembali, tetapi pada penghapusan yang mudah. <br><br>  Namun, implementasi harus secara maksimal membebaskan pengembang dari pekerjaan yang paling sulit - yaitu, memungkinkannya untuk melarikan diri dari persyaratan teknis yang tidak terkait dengan logika bisnis.  Contohnya adalah multithreading, transaksi, inversi kontrol, atau pemrosesan permintaan HTTP.  Di sisi aplikasi, membosankan itu bagus :) <br><br>  Tampaknya penting bagi saya bahwa kerangka kerja tidak hanya tidak mengganggu implementasi logika bisnis, tetapi juga mendorong programmer untuk dengan cepat membawa fitur yang dikembangkan ke produksi.  Tidak perlu memoles kerangka untuk bersinar - lebih baik untuk membawa kode logika bisnis ke ideal.  Bandingkan Java EE atau Spring modern dengan versi kuno J2EE - Saya pikir Anda akan segera mengerti apa yang saya maksud. <br><br>  EE Jakarta harus berkembang dalam nada yang sama dan, karenanya, fokus pada spesifikasi yang akan memungkinkan pengembang untuk dengan cepat mengimplementasikan logika bisnis. <br><br>  <b>Konvensi konfigurasi</b> <br><br>  Java EE meminimalkan konfigurasi yang diperlukan untuk mendefinisikan aplikasi perusahaan tipikal.  Dalam sebagian besar situasi praktis, perjanjian berjalan langsung, tidak ada konfigurasi yang diperlukan.  Jadi, Anda tidak lagi memerlukan file XML untuk mengonfigurasi aplikasi Java EE sederhana.  Contoh lain adalah bahwa JAX-RS menyediakan kode respons HTTP default yang sesuai dengan nilai balik metode JAX-RS. <br><br>  Java EE memang memiliki fleksibilitas untuk memodifikasi perilaku dan mengimplementasikan skrip yang lebih kompleks;  Namun, tidak ada kesepakatan tentang ini. <br>  Jakarta EE harus terus mengubah yang sederhana menjadi yang mudah, dan yang kompleks menjadi yang mungkin. <br><br>  <b>Spesifikasi Interoperabilitas</b> <br><br>  EE Jakarta harus melanjutkan dan memperluas interoperabilitas spesifikasi.  Java EE memenuhi spesifikasi yang ada dan fungsionalitas yang ada di dalamnya yang telah menjadi bagian dari standar. <br><br>  Pengembang dapat mengandalkan spesifikasi berbeda untuk berinteraksi dengan baik satu sama lain, tanpa konfigurasi apa pun.  Standar yang diminta: jika lingkungan runtime mendukung spesifikasi A dan spesifikasi B, maka A + B harus saling berinteraksi.  Contoh: validasi komponen, JAXB, atau JSON-B dapat digunakan dalam kelas sumber daya JAX-RS, dan tidak diperlukan konfigurasi lebih lanjut. <br><br>  <b>Ketergantungan Injeksi dan CDI</b> <br><br>  Tentu saja, EE Jakarta tidak diinginkan untuk menemukan kembali hal-hal yang sudah ada - misalnya, injeksi ketergantungan yang terkait dengan CDI.  Diinginkan bahwa spesifikasi menggunakan dan menekankan kekuatan JSR 330 atau, jika perlu, CDI. <br><br>  Contoh <code>UriInfo</code> adalah penggunaan <code>UriInfo</code> dari JAX-RS dalam metode sumber daya.  Annotation <code>@Inject</code> belum mendukung implementasi metode jenis ini.  Lebih mudah bagi programmer untuk bekerja, semakin ia bergantung pada mekanisme universal. <br><br>  Ukuran spesifik lainnya adalah ini: Penyedia CDI harus disediakan dalam spesifikasi, dan, jika perlu, kualifikasi typesafe untuk jenis yang perlu dibuat.  Jadi, saat ini, instance klien JAX-RS hanya dapat diperoleh secara terprogram, melalui API <code>ClientBuilder</code> .  Produsen dan kualifikasi menyederhanakan pekerjaan programmer dengan memberikan definisi deklaratif. <br><br>  <b>Pendekatan deklaratif</b> <br><br>  Untuk semua ini, Java EE API sangat bergantung pada pendekatan deklaratif, saat menggunakan inversi kontrol.  Dengan demikian, pengembang tidak memanggil fungsi secara langsung;  container bertanggung jawab untuk memanggil fungsional, sementara kita bergantung pada definisi kode.  Contoh (dari spesifikasi terkini) adalah JAX-RS, JSON-B, atau CDI. <br><br>  EE Jakarta tidak hanya menyediakan API perangkat lunak yang lebih komprehensif, tetapi juga harus memfasilitasi penggunaan definisi deklaratif dan inversi kontrol. <br><br>  <b>Strategi penyebaran</b> <br><br>  Fitur khusus (dan menurut saya keuntungan besar) Java EE adalah bahwa model penyebaran yang diusulkan di sini, di mana masalah logika bisnis dipisahkan dari implementasi.  Program pengembang khusus untuk API, yang bukan bagian dari artefak penyebaran dan diimplementasikan oleh wadah aplikasi. <br>  Artefak penyebaran yang ringkas ini menyederhanakan dan mempercepat pengiriman program, termasuk perakitan, penerbitan, dan penyebaran seperti itu.  Mereka juga kompatibel dengan tingkat sistem file kontainer yang digunakan, misalnya, di Docker.  Selama proses perakitan, Anda hanya perlu membangun kembali atau mengirim ulang elemen yang diubah. <br><br>  Idealnya, artefak penyebaran harus hanya berisi logika bisnis dan tidak ada yang lain;  implementasi runtime dan pustaka pihak ketiga yang berpotensi ditambahkan dikirimkan pada tingkat yang lebih rendah, misalnya, di pustaka server aplikasi yang ditambahkan pada tahap perakitan wadah sebelumnya. <br><br>  Di Jakarta EE, artefak yang dikerahkan juga harus dianggap entitas kelas satu.  Mungkin akan ada peluang untuk lebih memperketat lingkungan runtime berdasarkan spesifikasi yang diperlukan oleh aplikasi.  Namun, EE Jakarta berharap untuk memberikan perhatian maksimal pada logika bisnis dan produktivitas pengembang, dan penyempurnaan waktu eksekusi sudah sekunder. <br><br>  <b>Testabilitas</b> <br><br>  Menerapkan prinsip-prinsip di atas, terutama memberikan preferensi untuk pemrograman deklaratif dan injeksi ketergantungan, kami meningkatkan testabilitas kode bisnis.  Dengan demikian, pengembang dapat langsung membuat instance objek dalam skrip pengujian, karena sekarang Anda tidak perlu mewarisi kelas API atau memanggil fungsi yang tidak nyaman yang sebelumnya perlu Anda simulasikan. <br><br>  Namun, di Jakarta EE perlu secara serius memperbaiki standardisasi pengujian integrasi pada tingkat kode, sehingga tidak tergantung pada pabrikan.  Sebelumnya, inilah tepatnya yang harus Anda hadapi saat bekerja dengan Arquillian.  Dalam proyek nyata, standar semacam itu akan berguna, yang memungkinkan Anda untuk mendeklarasikan hanya skenario penerapan pengujian dan fungsi panggilan untuk satu atau lebih komponen.  Sebelumnya, saya menulis bahwa saya tidak menganggap pengujian integrasi pada level kode menjadi sangat penting, misalnya, ketika menjalankan aplikasi dalam wadah bawaan.  Namun, jika Anda menstandarkan tes integrasi pada level kode, ini jelas akan memiliki efek positif. <br><br>  <b>Kesimpulan</b> <br><br>  Saya pikir itu bukan kebetulan bahwa Java EE API banyak digunakan dalam proyek nyata: API ini dipikirkan dengan baik dan dirancang sesuai dengan prinsip-prinsip yang jelas, berkat itu dimungkinkan untuk menyatukan tidak hanya satu spesifikasi, tetapi seluruh platform.  Mereka memungkinkan Anda untuk menggunakan beberapa spesifikasi sekaligus, didukung dalam semangat yang sama.  Di sini, kami berhasil menyingkirkan hambatan buatan yang hanya menyulitkan pekerjaan programmer - oleh karena itu, saya percaya, semua pengembangan usaha menjadi jauh lebih menyenangkan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416429/">https://habr.com/ru/post/id416429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416419/index.html">Generator Gua Dua Dimensi Acak</a></li>
<li><a href="../id416421/index.html">Berjalan-jalan di pit lane, atau bagaimana teknologi IaaS membantu tim balap</a></li>
<li><a href="../id416423/index.html">Bagaimana orang Rusia mengingatkan prosesor Amerika, atau ulasan tentang AdvoCam-FD8 Gold-II DVR (GPS + GLONASS)</a></li>
<li><a href="../id416425/index.html">Otorisasi lokal tanpa kata sandi di Ubuntu</a></li>
<li><a href="../id416427/index.html">Apa yang kita baca di bulan Juni: berita tentang Angular, JWT, skandal blockchain dan sedikit zen</a></li>
<li><a href="../id416431/index.html">Proyek blockchain terbaik. ICO Juli 2018 (pemungutan suara)</a></li>
<li><a href="../id416433/index.html">Tanyakan Ethan: Dapatkah kehilangan radiasi bintang menjelaskan energi gelap?</a></li>
<li><a href="../id416435/index.html">Mengapa otak manusia begitu efektif?</a></li>
<li><a href="../id416437/index.html">Apakah ada cukup bahan kimia di dunia es untuk menopang kehidupan di sana?</a></li>
<li><a href="../id416439/index.html">iOS 12: pengelompokan notifikasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>