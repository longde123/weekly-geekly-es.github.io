<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍸 🙈 🏽 كومة الملاحة الخاصة. أفضل من روس؟ ⚱️ 👼🏽 👧🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="هذه هي المقالة الثانية لفريق setUP حول تجربتنا في إنشاء روبوتات مستقلة لمسابقات Eurobot Open واستخدام ROS لهذا الغرض. 

 المقالة الأولى عن الميكانيكا ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>كومة الملاحة الخاصة. أفضل من روس؟</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479636/" style=";text-align:right;direction:rtl"> هذه هي المقالة الثانية لفريق setUP حول تجربتنا في إنشاء روبوتات مستقلة لمسابقات Eurobot Open واستخدام ROS لهذا الغرض. <br><br>  <a href="https://habr.com/ru/post/478836/">المقالة الأولى عن الميكانيكا والهندسة العامة للروبوتات.</a> <br><br>  تنتقل الروبوتات إلى أرض مستوية وتُعرف معظم العقبات مقدمًا ، ومع ذلك ، يمكن للمعارضين الخبيثين محاولة سرقة مواردنا (ونريد أحيانًا تناول بضع عشرات من النقاط الإضافية) ، بينما نريد القيادة إلى النقطة المطلوبة بأسرع ما يمكن وعدم لمس العقبات.  من كاميرا خارجية في الميدان ، نحصل على بيانات حول موقع العدو ونعرف أين هو الآن.  ومع ذلك ، لا يكفي معرفة موقفه - يجب أن تكون قادرًا على استخدام هذه المعلومات. <br><br>  سنحاول اليوم القيادة من النقطة "أ" إلى النقطة "ب" دون السفر على ذيل قطة سقطت نائمة على الحقل.  على وجه الخصوص ، سنشرح كيف نبني طريقًا ونتحكم في سرعة الروبوت ، فضلاً عن كيفية بدء تشغيل كل شيء على جهاز الكمبيوتر الخاص بنا. <br><br><img src="https://habrastorage.org/webt/om/x0/a6/omx0a6wfefbht9c1pialld-9vqy.png"><br><a name="habracut"></a><br><h3 style=";text-align:right;direction:rtl">  محاولة الحصول على القليل من الدماء </h3><br>  عند حل هذه المشكلة ، يمكنك أن تأخذ مواد جاهزة مكتوبة بواسطة محترفين ، فلن يكون هناك عذاب ولا اختراع لـ "الدراجة" التالية.  استخدمنا منصة متعددة الاستخدامات ، لذلك على الرغم من وجود محاولة لاستخدام جهاز إستواء محلي جاهز من شركة ROS ، لعدة أسباب وجدوا أن هذا الأمر غير واعد.  يمكنك أدناه معرفة عدد الأشياء التي يحتاج إليها مصمم طائرة شراعية قياسية: <br><br><pre style=";text-align:right;direction:rtl"><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @class TrajectoryPlanner * @brief Computes control velocities for a robot given a costmap, a plan, and the robot's position in the world. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrajectoryPlanner</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrajectoryPlannerTest</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//Need this for gtest to work public: /** * @brief Constructs a trajectory controller * @param world_model The WorldModel the trajectory controller uses to check for collisions * @param costmap A reference to the Costmap the controller should use * @param footprint_spec A polygon representing the footprint of the robot. (Must be convex) * @param inscribed_radius The radius of the inscribed circle of the robot * @param circumscribed_radius The radius of the circumscribed circle of the robot * @param acc_lim_x The acceleration limit of the robot in the x direction * @param acc_lim_y The acceleration limit of the robot in the y direction * @param acc_lim_theta The acceleration limit of the robot in the theta direction * @param sim_time The number of seconds to "roll-out" each trajectory * @param sim_granularity The distance between simulation points should be small enough that the robot doesn't hit things * @param vx_samples The number of trajectories to sample in the x dimension * @param vtheta_samples The number of trajectories to sample in the theta dimension * @param pdist_scale A scaling factor for how close the robot should stay to the path * @param gdist_scale A scaling factor for how aggresively the robot should pursue a local goal * @param occdist_scale A scaling factor for how much the robot should prefer to stay away from obstacles * @param heading_lookahead How far the robot should look ahead of itself when differentiating between different rotational velocities * @param oscillation_reset_dist The distance the robot must travel before it can explore rotational velocities that were unsuccessful in the past * @param escape_reset_dist The distance the robot must travel before it can exit escape mode * @param escape_reset_theta The distance the robot must rotate before it can exit escape mode * @param holonomic_robot Set this to true if the robot being controlled can take y velocities and false otherwise * @param max_vel_x The maximum x velocity the controller will explore * @param min_vel_x The minimum x velocity the controller will explore * @param max_vel_th The maximum rotational velocity the controller will explore * @param min_vel_th The minimum rotational velocity the controller will explore * @param min_in_place_vel_th The absolute value of the minimum in-place rotational velocity the controller will explore * @param backup_vel The velocity to use while backing up * @param dwa Set this to true to use the Dynamic Window Approach, false to use acceleration limits * @param heading_scoring Set this to true to score trajectories based on the robot's heading after 1 timestep * @param heading_scoring_timestep How far to look ahead in time when we score heading based trajectories * @param meter_scoring adapt parameters to costmap resolution * @param simple_attractor Set this to true to allow simple attraction to a goal point instead of intelligent cost propagation * @param y_vels A vector of the y velocities the controller will explore * @param angular_sim_granularity The distance between simulation points for angular velocity should be small enough that the robot doesn't hit things */ TrajectoryPlanner(WorldModel&amp; world_model, const costmap_2d::Costmap2D&amp; costmap, std::vector&lt;geometry_msgs::Point&gt; footprint_spec, double acc_lim_x = 1.0, double acc_lim_y = 1.0, double acc_lim_theta = 1.0, double sim_time = 1.0, double sim_granularity = 0.025, int vx_samples = 20, int vtheta_samples = 20, double pdist_scale = 0.6, double gdist_scale = 0.8, double occdist_scale = 0.2, double heading_lookahead = 0.325, double oscillation_reset_dist = 0.05, double escape_reset_dist = 0.10, double escape_reset_theta = M_PI_2, bool holonomic_robot = true, double max_vel_x = 0.5, double min_vel_x = 0.1, double max_vel_th = 1.0, double min_vel_th = -1.0, double min_in_place_vel_th = 0.4, double backup_vel = -0.1, bool dwa = false, bool heading_scoring = false, double heading_scoring_timestep = 0.1, bool meter_scoring = true, bool simple_attractor = false, std::vector&lt;double&gt; y_vels = std::vector&lt;double&gt;(0), double stop_time_buffer = 0.2, double sim_period = 0.1, double angular_sim_granularity = 0.025);</span></span></code> </pre> <br>  <i>هذا مثال على تهيئة معلمات تنظيم السرعات والمسار ككل.</i> <br><br>  معلمات مهمة لإجراء عملية حسابية كاملة: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  المعلمة world_model. </li><li style=";text-align:right;direction:rtl">  معلمة خريطة التكلفة: رابط لخريطة تحتوي على عوائق ، بالإضافة إلى "امتدادها الظاهري" ، مع مراعاة التصادم المحتمل. </li></ol><br>  من مزايا المكدس القياسي ، يمكنك تسليط الضوء على توافر الوثائق والقدرة على العثور على المعلومات في المنتديات.  <a href="https://github.com/ros-planning/navigation" rel="nofollow">يمكنك قراءة المزيد على الموقع الرسمي مع الوثائق</a> <br><br>  من المهم أن نذكر أن حزم ROS كانت مكتوبة للمنصات ذات العجلتين ، وفي ظل Omni تم تحسينها من خلال زيادة زاوية الدوران المتاحة عند تحريك ما يصل إلى 360 درجة ، وهو بالتأكيد عكاز. <br><br>  بعد تحليل المشروع ، أدركنا أنه سيكون هناك صعوبة في الدراسة والتكميل ، وكذلك هناك العديد من الرقائق الثقيلة التي لا نحتاج إليها.  قد يبدو ذلك ، فليكن ، لكننا استخدمنا Odroid xu4 (المعالج الذي كان لا يزال على Samsung s5) ، وكانت نتائج الأداء محبطة ، ومساحة لشيء أكثر قوة (وتوت العليق 4 ومعالج jetson nano يدخنان بشكل جانبي بالمقارنة مع معه) لا.  اضطررت إلى التخلي عن المكدس القياسي ومحاولة إنشاء مخطط عالمي ، مخطط محلي ومنظم مسار أنفسنا <br><br><img src="https://habrastorage.org/webt/ij/qe/es/ijqeesrak1vuhjqfr1ij6exr4_a.jpeg"><br><br><h3 style=";text-align:right;direction:rtl">  مسوي عالمي ، مخطط محلي ، منظم مسار وجميع الكل </h3><br>  هناك حاجة إلى الطائرات الشراعية العالمية والمحلية للحصول على الاتجاهات إلى الوجهة.  لماذا الانفصال ضروري؟  لماذا لا يمكنك فقط أخذ <a href="https://ru.wikipedia.org/wiki/A*" rel="nofollow">A *</a> وركوبها؟  كقاعدة عامة ، يمكن للمخطط الشامل ، عند إنشاء مسار ، استخدام الخريطة بأكملها في عمله ، لذلك يجب أن تكون الخوارزمية بأسرع ما يمكن ، حتى مع بعض التبسيط.  لتخفيف هذه التبسيط ، يستخدمون أيضًا المخطط المحلي ، الذي يحاول ، بناءً على نتيجة المخطط العالمي (أو مجرد منطقة محدودة حول الروبوت) ، مراعاة جميع الفروق الدقيقة. <br><br>  بعد أن أنشأنا المسار ، نعرف أين يجب أن يذهب الروبوت ، لكن كيف يمكن إخبارك بهذا؟  للقيام بذلك ، هناك منظم المسار.  يقوم بحساب السرعة والسرعة التي يتحرك فيها الروبوت في الوقت الحالي حتى لا ينحرف عن المسار.  من نواح كثيرة ، هذه الحزمة هي المسؤولة عن مدى سرعة وجميلة سوف يذهب الروبوت. <br><br>  بالإضافة إلى هذه الكيانات الثلاثة ، هناك خادم خرائط - رابع ، يسمح لك بمعالجة حالة العالم بسهولة.  إنه يحدد كيفية وصفنا للخريطة ، وما هي الإمكانيات المتوفرة لدينا عند العمل مع الخريطة ، ومن نواح كثيرة ، تحديد سرعة الطائرات الشراعية. <br><br>  قبل المتابعة مع وصف مكدس التنقل ، سيكون من الجيد تحديد أسباب اختيار cost_map كخادم خرائط.  بشكل عام ، جربنا خيارات مختلفة لمعالج الخرائط: <a href="http://wiki.ros.org/grid_map" rel="nofollow">Occupancy_grid</a> و <a href="https://github.com/stonier/cost_map" rel="nofollow">Grid_map</a> و <a href="https://github.com/stonier/cost_map" rel="nofollow">Cost_map</a> ، لكننا <a href="https://github.com/stonier/cost_map" rel="nofollow">استقرنا</a> على الأخير. <br><br>  الأسباب: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تتفاعل بشكل مريح مع الخريطة. </li><li style=";text-align:right;direction:rtl">  هناك العديد من التكرارات التي نحتاجها في أشكال مختلفة (دائرية ، خطية ، مستطيلة ، إلخ). </li><li style=";text-align:right;direction:rtl">  يمكنك تخزين طبقات خريطة متعددة بمعلمات مختلفة. </li><li style=";text-align:right;direction:rtl">  إدارة ذاكرة جيدة. </li><li style=";text-align:right;direction:rtl">  والأهم من ذلك ، السرعة.  تعمل خريطة الشبكة بنوع مزدوج وبسبب هذا ، فإنها أبطأ عدة مرات من خوادم الخرائط التي تستخدم int8 للعمل. </li></ol><br>  على الرغم من حقيقة أن شبكة الإشغال تعمل أيضًا مع int8 ، إلا أنها لا يمكن أن تفتخر بنفس قابلية الاستخدام ، لذلك اضطررت إلى التخلي عنها. <br><br>  من الخريطة ، نحتاج إلى معرفة أين توجد المناطق الحرة والخطيرة التي لا تقاوم.  لكل كائن موجود في الحقل ، يمكننا ضبط حقل التضخم - وهي القيمة التي تحدد ، حسب المسافة إلى الكائن ، نفاذية الخلية.  التضخم هو ذيل القط ، من السهل عدم ملاحظته ، ولكن بعد ذلك ستندم عليه لفترة طويلة جدًا.  نقوم بتخطيط روبوتات العدو ونضيف منطقة خطر لا يأخذها سوى المخطط المحلي في الاعتبار.  مخطط عالمي يتجاهل جميع النقاط ، إذا لم تكن عقبة. <br><br><h4 style=";text-align:right;direction:rtl">  مخطط عالمي </h4><br>  أول ما كتبوه في الملاحة هو المخطط العالمي.  يعتمد على خوارزمية theta *.  باختصار ، هذا هو <a href="https://ru.wikipedia.org/wiki/A*" rel="nofollow">A *</a> المعدلة ، حيث يتم التركيز على العثور على العقدة الأصل ، والتي يمكن الوصول إليها مباشرة ، أي  لا توجد عقبات أمامها.  هذا يسمح لنا ببناء مسارات مريحة وسلسة تستخدم في المخطط المحلي. <br><br><img src="https://habrastorage.org/webt/it/qs/e4/itqse4uuumbbzu8rxws07gapbn8.png"><br>  <i>مقارنة بين A * و theta *</i> <br><br>  بالنسبة للمخطط العام ، لدينا ملف به معلمات (params / path_planner.yaml) يصف موضوعات الخريطة ومواضيعها مع موقع جميع الروبوتات (لجميع الروبوتات الأربعة في الحقل ، حيث "null" هو الموضوع الذي يحتوي على بيانات حول الروبوت الحالي). <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># small robot debug param list robot_id: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"small"</span></span></span><span class="hljs-meta"> ########################### # cost_map_server params ## ########################### cost_map_server/big_robot_size: 0.45 cost_map_server/little_robot_size: 0.45 cost_map_server/cube_size: 0.11 cost_map_server/inscribed_radius: 0.3 cost_map_server/inflation_radius: 0.3 cost_map_server/inflation_exponential_rate: 0.6 cost_map_server/big_robot1: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/big_robot"</span></span></span><span class="hljs-meta"> cost_map_server/big_robot2: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/enemy_robot1"</span></span></span><span class="hljs-meta"> cost_map_server/small_robot1: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"null"</span></span></span><span class="hljs-meta"> cost_map_server/small_robot2: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/enemy_robot2"</span></span></span><span class="hljs-meta"> cost_map_server/collision: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"collision"</span></span></span><span class="hljs-meta"> cost_map_server/image_resource_name: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"$(find cost_map_server)/param/image_resource.yaml"</span></span></span><span class="hljs-meta"> cost_map_server/min_diff_points: 0.01 ########################### ### path_planner params ### ########################### global_planner/path_layer: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"inflation_layer"</span></span></span><span class="hljs-meta"> global_planner/path_force_layer: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"obstacle_inflation_layer"</span></span></span><span class="hljs-meta"> global_planner/frame_id: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"map"</span></span></span><span class="hljs-meta"> global_planner/current_position: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"real_corr"</span></span></span><span class="hljs-meta"> global_planner/path_filter_epsilon: 0</span></span></code> </pre> <br>  كما يشير إلى: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  واحدة من الخوارزميات التي يمكنك اختيار بناء مسار ، </li><li style=";text-align:right;direction:rtl">  أسماء الطبقات التي سنبني عليها الطريق نفسه ، </li><li style=";text-align:right;direction:rtl">  موضوع حول موقفنا ، حيث يتم إصدار البيانات التي تمت تصفيتها (في حالتنا ، هو مزيج من بيانات الموقع من الكاميرا وقياس المسافات). </li></ol><br>  يتم تمييز خوارزمية البحث عن المسار نفسها - Theta Star - في ملف منفصل (src / global_planner.cpp) لتوفير الراحة لإضافة خوارزميات جديدة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cost_so_far[<span class="hljs-number"><span class="hljs-number">300</span></span>][<span class="hljs-number"><span class="hljs-number">200</span></span>]; PriorityPoint neighbors[<span class="hljs-number"><span class="hljs-number">8</span></span>]; PriorityPoint current; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> come_from[<span class="hljs-number"><span class="hljs-number">300</span></span>][<span class="hljs-number"><span class="hljs-number">200</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePath_ThetaStar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;cost_map::Index&gt; &amp;path, PriorityPoint start, PriorityPoint goal, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> layer, cost_map::CostMap &amp;cost_map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> grid_cost, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> only_cost)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::priority_queue&lt;PriorityPoint, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;PriorityPoint&gt;, myCompare&gt; openSet; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_x = cost_map.getSize()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_y = cost_map.getSize()[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::fill_n(*cost_so_far, max_x * max_y, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max()); cost_so_far[start.x][start.y] = <span class="hljs-number"><span class="hljs-number">0</span></span>; come_from[start.x][start.y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = start.x; come_from[start.x][start.y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = start.y; openSet.push(start); grid_cost=<span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!openSet.empty()) { current = openSet.top(); openSet.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == goal) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } current.GetNeighbors(neighbors); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> current_cost = cost_so_far[current.x][current.y]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parent_carent[<span class="hljs-number"><span class="hljs-number">2</span></span>] ={come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">0</span></span>], come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">1</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbors[i].OnMap(max_x, max_y)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> onLine = lineOfSight(parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>], parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>], neighbors[i].x, neighbors[i].y, cost_map, layer, grid_cost + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (onLine) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> new_cost = cost_so_far[parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>]][parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>]] + HeuristicEvclid(parent_carent, neighbors[i], grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y]) { cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost; neighbors[i].priority = HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>) + new_cost; openSet.push(neighbors[i]); come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>]; come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> neighbor_price = cost_map.at(layer, cost_map::Index({neighbors[i].x, neighbors[i].y})) + neighbors[i].priority; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> new_cost = current_cost + neighbor_price; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y]) { cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost; neighbors[i].priority =HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>) + new_cost; openSet.push(neighbors[i]); come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = current.x; come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = current.y; } } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (only_cost) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cost_so_far[current.x][current.y]; } path.clear(); PriorityPoint temp_point; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != start) { path.push_back({current.x, current.y}); temp_point.x = come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">0</span></span>]; temp_point.y = come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">1</span></span>]; current = temp_point; } path.push_back({current.x, current.y}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  يتم أيضًا تخصيص خوارزمية لإزالة النقاط الإضافية على مسار RamerDouglasPeucker لملف منفصل. <br>  يزيل النقاط من المسار إذا كان خارج مسافة معينة من الخط الذي يصل بين نقطتين متجاورتين. <br><br><img src="https://habrastorage.org/webt/en/_9/dw/en_9dw6khdarxbyf7gvrhpqg7b4.jpeg"><br><br><h4 style=";text-align:right;direction:rtl">  مخطط محلي </h4><br>  انه يعمل بالنسبة لنا على أساس النسب التدرج في مجال محتمل.  كمدخلات ، المسار من المخطط العالمي.  ومع ذلك ، هذا ليس كل ما هو قادر.  في local_planner ، هناك خدمات داخلية لاختيار وضع بناء المسار.  هناك إجمالي وضعين للتشغيل: وضع نقاط التحول على طول التدرج اللوني ، باستخدام تمريرات متعددة على الخريطة ، بالإضافة إلى وضع التحول ، حيث نحسب الزيادة على الفور في إحداثيتين وننقل النقطة إلى حافة المنطقة الآمنة.  إذا سقطت النقطة في عدة مناطق من هذا القبيل ، فإننا ننتقل إلى أماكن تقاطعها ، لأنه هناك الأكثر أمانًا. <br><br>  يكون وضع التشغيل كما يلي: إذا لم تكن هناك عقبة في المسار من التكرار السابق ، فسنقطع المسار كل 2 سم ، ثم نغيره على طول التدرج اللوني ، وإلا فإننا نستخدم وضع المخطط المحلي الثاني للعملية. <br><br>  الخيار الثاني خفيف الوزن تمامًا ، مثل المخطط العام ، لا يقوم بتحميل المعالج كثيرًا.  استخدمنا العديد من إصدارات هذه الخوارزمية ومعالجات مختلفة مع الخريطة.  على سبيل المثال ، حاولنا كتابة رسم بياني توجد فيه القمم كل 10 سم ويتم إزاحتها بحد أقصى 4 سم ، وبعد ذلك تم استخدام خوارزمية ديكسترا على الرسم البياني الذي تم الحصول عليه للعثور على أصغر مسافة.  تستخدم نقطة النهاية في هذه الحالة أقرب نقطة إزاحة.  لكن مثل هذه الخوارزمية كانت أكثر ملاءمة للمخطط العالمي وقررنا التخلي عن هذا التنفيذ. <br><br>  لقد حاولنا أيضًا استخدام بناء المسار من نقطة الصفر باستخدام طريقة النسب التدرج.  كانت هذه الطريقة الأولى التي قررنا الكتابة.  اتضح أن هذا الجهاز غير فعال في الذاكرة (فقد احتل أكثر من 400 ميغابايت من ذاكرة الوصول العشوائي الخالصة ، لأنه استخدم خريطة تكلفة مع كل تمريرة) وبطيئة.  تم إيقاف التحكم في التردد بسبب ضعف التحسين وكانت السرعة أقل من 30 مرة في الثانية ، وهو ما لم يناسبنا. <br><br>  نتيجة لذلك ، قررنا استخدام النسب التدرج في حقل محتمل استنادًا إلى مسار المخطط العالمي.  لقد اتضح أنه خوارزمية خفيفة الوزن وبسيطة نسبيًا ، والتي تناسبنا تمامًا من حيث جودة المسار ووقت العمل وكمية ذاكرة الوصول العشوائي المستخدمة في منطقة 100-150 ميغابايت ، وهي أقل بعدة مرات مما كانت عليه في التكرارات الأولى من التطوير. <br><br><img src="https://habrastorage.org/webt/sg/oq/mo/sgoqmogivjs8elhylt74oqjqrdw.png"><br>  <i>مثال على مسار يقابله المسوي المحلي</i> <br><br>  على عكس global_planner ، فإن المعلمات في local_planner صغيرة للغاية ، ويرجع ذلك إلى بساطتها ، لأن جميع المهام الأكثر أهمية تكمن في global_planner: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">grid_map_server/big_robot1 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/big_robot2 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/small_robot1 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/small_robot2 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> local_planner/radius : <span class="hljs-number"><span class="hljs-number">0.15</span></span> global_planner/frame_id : <span class="hljs-string"><span class="hljs-string">"map"</span></span></code> </pre> <br>  في هذه الحالة ، نقوم بتكوين: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  نصف قطر المناطق الآمنة لكل من الروبوتات. </li><li style=";text-align:right;direction:rtl">  إزاحة المسار الأقصى بواسطة المسوي المحلي. </li><li style=";text-align:right;direction:rtl">  اسم طبقة الخريطة التي نعمل معها. </li></ul><br>  في فصل منفصل تم تخصيص جميع الوظائف الأكثر أهمية.  في هذه الحالة ، إنه انهيار متكرر للمسار ، وإنشاء طائرة شراعية وبناة افتراضية ومدمرات. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Planner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Planner(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> inflation_radius_, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> frame_id_) { inflation_radius = inflation_radius_; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">200</span></span>; j++) our_map[i][j] = <span class="hljs-number"><span class="hljs-number">3000.0</span></span>; } OurPath-&gt;poses.resize(<span class="hljs-number"><span class="hljs-number">50</span></span>); geometry_msgs::Pose pose; pose.position.x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; pose.position.y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>; i++) { OurPath-&gt;poses[i].pose = pose; } frame_id = frame_id_; } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Planner() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdatePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; ros::Publisher move_pub; ros::Publisher BigEnemyPub; ros::Publisher LittleEnemyPub; ros::Publisher local_path_publisher; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-comment"><span class="hljs-comment">// virtual double Calculate_Path_Len(); nav_msgs::Path* recursive_path(nav_msgs::Path *path, std::pair&lt;double, double&gt; start, std::pair&lt;double, double&gt; end, double epsilon, int &amp;index) { if (CalcDistance(start, end) &lt; (epsilon) || path-&gt;poses.size() &gt; 200) return path; double start_x = (start.first + end.first) / 2.0; double start_y = (start.second + end.second) / 2.0; index = find_out(path, start); geometry_msgs::PoseStamped pose; pose.pose.position.x = start_x; pose.pose.position.y = start_y; path-&gt;poses.insert(path-&gt;poses.begin() + index, pose); recursive_path(path, start, std::pair&lt;double, double&gt;{start_x, start_y}, epsilon, index); recursive_path(path, std::pair&lt;double, double&gt;{start_x, start_y}, end, epsilon, index); } int find_out(nav_msgs::Path *path, pair_double point) { int index = 0; for (int i = 0; i &lt; path-&gt;poses.size(); i++) if (path-&gt;poses[i].pose.position.x == point.first &amp;&amp; path-&gt;poses[i].pose.position.y == point.second) return ++i; return index; } void add_in_path(nav_msgs::Path* Path, geometry_msgs::PoseStamped pose, int&amp; Index) { Path-&gt;poses[Index % max_size] = pose; Index++; } double inflation_radius; double our_map[300][200]; int max_size = 49; std::string frame_id; nav_msgs::Path *path = new nav_msgs::Path; nav_msgs::Path *OurPath = new nav_msgs::Path; };</span></span></code> </pre> <br>  تمت توارث فئة LocalPlanning منه ، حيث يوجد قلب الطائرة الشراعية بالكامل ، أي تحويل النقاط إلى حافة المنطقة الآمنة وتحديد ما يجب فعله بالمسار على وجه التحديد. <br><br>  يتم تمييز كل الوظائف الأخرى في ملف منفصل fichi.hpp ، ونسب متدرج في potential_field.hpp.  يوجد أدناه لقطة من هذا الملف ، والتي تُظهر وظائف إنشاء حقل محتمل على خريطة cost_map: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcAttractivePotential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(grid_map::Index index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goalx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goaly)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(index[<span class="hljs-number"><span class="hljs-number">0</span></span>] - goalx, <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(index[<span class="hljs-number"><span class="hljs-number">1</span></span>] - goaly, <span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcPotential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> starty, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goalx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goaly, cost_map::CostMap &amp;cost_map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (&amp;our_map)[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">300</span></span></span></span><span class="hljs-function"><span class="hljs-params">][</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">200</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Use some magic for normalisation of Field double max_distance = (CalcAttractivePotential(grid_map::Index(startx, starty), goalx, goaly) + 15); if (max_distance == 0.0) { max_distance = 0.01; } for (cost_map::CircleIterator iterator(cost_map, grid_map::Position(startx / 100.0, starty / 100.0), max_distance / 100.); !iterator.isPastEnd(); ++iterator) { try { grid_map::Index index(*iterator); double uf; uf = cost_map.at("obstacle_inflation_layer", *iterator); // if we on free podouble - field is more less then if it not free podouble if ( uf &gt;= 10) { uf = 3000.0; // CP - is const variable } else uf += CalcAttractivePotential(index, goalx, goaly)/max_distance * 256; our_map[299-index(0)][199-index(1)] = uf; } catch(std::exception&amp; e) { ROS_INFO("Exception! %s", e.what() ); } } }</span></span></code> </pre> <br><h4 style=";text-align:right;direction:rtl">  منظم المسار </h4><br>  أخيرًا وليس آخرًا ، منظم المسار.  وهو مسؤول عن تحويل مسار المخطط المحلي إلى مسار ويعطي السرعة للخطوة الحالية. <br><br>  الإصدار الأول ، الذي استخدمناه في نهائي Eurobot 2018 ، عبارة عن مزيج من وحدة التحكم في التسارع ومكابح الفرامل ، حيث يتم ضبط ناقل الحركة إلى النقطة التالية على الطريق ، بالنسبة إلى المسافة إلى نقطة النهاية. <br><br>  وحدة التحكم PID ، باختصار ، هي مجموع الحالات الثلاث للنظام التي تساعد في إصلاح الأخطاء والأخطاء التي تحدث في بعض الأحيان. <br><br>  تم تحديد هذه الوظائف بشكل تجريبي وتعتمد على المسافة إلى نقطة النهاية في المسار (يمكن أن تكون من الدرجة الثانية أو المكعبة أو العكسية ، ولكن بعد ذلك استقرنا على الدرجة الثانية).  لقد نجح ذلك ، ولكن الشيء الوحيد الذي لم يناسبنا هو أن الروبوت لم يتمكن من الفرامل في الوقت المناسب بسرعة تفوق 0.7 متر في الثانية.  لذلك ، عندما حان الوقت ، قررنا إعادة بناء الخوارزمية بأكملها. <br><br>  التكرار الأول في الطريق إلى المسار الجديد كان استبدال المتجه الذي كنا بصدده.  الآن كان مجموع ناقلات الثلاثة التالية مع معاملات مختلفة.  التكرار الثاني كان يكتب الحد الأدنى من الهزة.  باختصار ، هذا بناء متعدد الحدود من الدرجة الخامسة ، حيث تعتمد إحداثيات x و y على وقت الوصول إلى كل نقطة. <br><br><img src="https://habrastorage.org/webt/ho/mw/hd/homwhdagbnkgdlrigettcc6yook.png"><br>  <i>يوضح الشكل رسم بياني لأحد الإحداثيات مقابل الوقت ، وكذلك السرعة على طول هذا الإحداثي</i> <br><br>  هذا النوع من منظم المسار يناسبنا أكثر ، لأنه يتطلب معالجة أقل مع اختيار معاملات مختلفة ، لأن جميع المعاملات هي القيم في كثير الحدود ، والتي تم حسابها على أساس وقت الوصول والسرعة الحالية والتسارع وسرعة الإخراج والتسارع. <br><br>  كانت نتيجة إعادة كتابة المسار أننا تمكنا من مضاعفة متوسط ​​سرعة الروبوت. <br><br>  كما في الحالتين السابقتين ، يتم تسليط الضوء على جميع الوظائف الرئيسية في ملف منفصل لسهولة التفاعل.  هذه المرة ، تكون فئة PlannerTrajectory مسؤولة عن إنشاء مسار يعتمد على MinimumJerk <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> velocity; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> acceleration; State(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> v_, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a_) : velocity(v_), acceleration(a_) {} State() { velocity = <span class="hljs-number"><span class="hljs-number">0</span></span>; acceleration = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlannerTrajectory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: nav_msgs::Path global_path; cost_map::CostMap *costmap_ptr; geometry_msgs::PoseStamped Goal_pred; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; trajectory_x; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; trajectory_y; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> average_velocity = <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Defualt or get from param // double max_velocity = 100; double coef_x[6]; double coef_y[6]; int frequency = 30; // Defualt or get from param // int index; public: PlannerTrajectory(cost_map::CostMap *costmap_, const int &amp;frequency_, const double &amp;max_velocity_, const double &amp;average_velocity_) { average_velocity = average_velocity;; max_velocity = max_velocity_; costmap_ptr = costmap_; frequency = frequency_; Goal_pred.pose.position.x = 0.0; Goal_pred.pose.position.y = 0.0; }</span></span></code> </pre> <br>  <i>تظهر الصورة جميع المتغيرات المعلنة التي نستخدمها.</i> <br><br>  يتم تمييز كل شيء آخر في ملف آخر (include / trajectory_regulator.h): تلقي نقاط من الموضوعات ، وتحديد ما إذا كنت تريد الانتقال إلى النقطة التالية (إذا كانت في عقبة ، فلن نذهب) والمزيد. <br><br><h3 style=";text-align:right;direction:rtl">  يهاجر إلى ROS ميلوديك </h3><br>  حتى العام الماضي ، استخدمنا الإصدار lte من ROS - ROS الحركية.  لقد كان مناسبًا لنا عمومًا ، لكن دعمه وصل إلى نهايته في العام المقبل ، والعديد من الحزم التي نحتاجها بدأت في الخروج حصريًا لـ ROS Melodic.  ثم اتضح أن costmap_server استخدمناها ليست تحت Melodic. <br><br>  حدثت مشكلة أثناء معالجة البيانات من البطاقات. <br><br>  لقد اخترنا خريطة الشبكة ، نظرًا لأن المكدس متشابه ، ولكن بداية الخريطة في مكان مختلف ، وقيم الخريطة نفسها تختلف من 0 إلى 1. لقد أصبحت هذه مشكلة كبيرة في مكدس التنقل بأكمله.  إذا تم في وقت سابق تشغيل المخطط العالمي 50 مرة في الثانية (كانت هناك قيود على التردد ، وبالتالي لم يتم استخدام المعالج أكثر من اللازم ، حتى في نصف مؤشر ترابط واحد) ، فقد مهد الآن الطريق كل ثانيتين واعتبره سيئًا: لقد تم تحميل نواة واحدة تمامًا.  في غضون ثانيتين ، كان بإمكان الروبوت عبور الخريطة بالكامل.  هذا لم يناسبنا ، ومحاولات موازاة هذه العملية انتهت بالفشل ، لأنه لم يعد هناك أداء لمشاريع أخرى (مع مراعاة تكاليف الموازاة). <br><br>  قررنا تغيير المكدس مرة أخرى ، والتخلي عن خريطة الشبكة لصالح شبكة الإشغال.  ظهرت مشكلة جديدة - عدم القدرة على تخزين عدة إصدارات من الخرائط في نفس الوقت (على سبيل المثال ، كاملة ، مع كل العقبات ، وخريطة ثابتة ، مع عقبات ديناميكية فقط).  أود أن أقوم بتغيير نصف الكود الذي لم يكن موثوقًا به بشكل خاص.  لذلك ، قررنا البحث عن حلول بديلة لهذه المشكلة. <br><br><h4 style=";text-align:right;direction:rtl">  خادم خريطة التكلفة </h4><br>  بعد بحث طويل ، وجدنا خرائط شوكة costmap_serverr: <a href="" rel="nofollow">https://github.com/lelongg/cost_map.git</a> - مفيدة للغاية لنظام الشوكة لدينا. <br><br><img src="https://habrastorage.org/webt/27/rb/oh/27rbohj3kefxprwtjqrg4mwtqjc.png"><br><br>  والآن ، بدلاً من خدمة خريطة الشبكة فقط ، للتسليم ، نجحنا في حساب الموقع المحتمل للعدو بناءً على التنبؤ بفلتر Kalman. <br><br><img src="https://habrastorage.org/webt/ni/pm/nz/nipmnzvhcrqdje1cu8glf9quude.png"><br><br>  أحد أهم الأشياء لخادم الخرائط هو ملف الخريطة ، والذي يُستخدم لإنشاء أولي لجميع الطبقات ، والتي يتم تحديثها لاحقًا فقط.  إنها صورة ثنائية بابوا نيو غينيا ، حيث يكون الأسود عقبة والأبيض منطقة حرة. <br><br><img src="https://habrastorage.org/webt/2b/l5/rg/2bl5rgpuecb7he51heslqpvcazm.png"><br><br>  يوجد أيضًا ملف إعدادات لتكوين cost_map_server.  أنه يحتوي على مواضيع مع نقاط العدو ، ومنطقة التضخم وحجم المربع ، والتي يمكن أن تستخدم أيضا لوضع منطقة العدو الخطرة على الخريطة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">########################### # cost_map_server params ## ########################### cost_map_server/big_robot_size: <span class="hljs-number"><span class="hljs-number">0.4</span></span> cost_map_server/little_robot_size: <span class="hljs-number"><span class="hljs-number">0.4</span></span> cost_map_server/cube_size: <span class="hljs-number"><span class="hljs-number">0.11</span></span> cost_map_server/inscribed_radius: <span class="hljs-number"><span class="hljs-number">0.25</span></span> cost_map_server/inflation_radius: <span class="hljs-number"><span class="hljs-number">0.25</span></span> cost_map_server/inflation_exponential_rate: <span class="hljs-number"><span class="hljs-number">0.6</span></span> cost_map_server/big_robot1: <span class="hljs-string"><span class="hljs-string">"/aruco/robot1"</span></span> cost_map_server/big_robot2: <span class="hljs-string"><span class="hljs-string">"/aruco/robot2"</span></span> cost_map_server/small_robot1: <span class="hljs-string"><span class="hljs-string">"/aruco/robot3"</span></span> cost_map_server/small_robot2: <span class="hljs-string"><span class="hljs-string">"/aruco/robot4"</span></span> cost_map_server/collision: <span class="hljs-string"><span class="hljs-string">"collision"</span></span> cost_map_server/image_resource_name: <span class="hljs-string"><span class="hljs-string">"$(find cost_map_server)/param/image_resource.yaml"</span></span> cost_map_server/min_diff_points: <span class="hljs-number"><span class="hljs-number">0.01</span></span></code> </pre> <br>  يتم نشر جميع الطبقات فقط إذا اشترك شخص ما فيها: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PublishChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ nav_msgs::OccupancyGrid msg; cost_map_msgs::CostMap cost_map_msg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle_inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toOccupancyGrid(costmap, <span class="hljs-string"><span class="hljs-string">"obstacle_layer"</span></span>, msg); obstacle_inflation_publisher.publish(msg); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toOccupancyGrid(costmap, <span class="hljs-string"><span class="hljs-string">"inflation_layer"</span></span>, msg); inflation_publisher.publish(msg); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cost_map_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toMessage(costmap, cost_map_msg); cost_map_publisher.publish(cost_map_msg); } }</code> </pre> <br><h3 style=";text-align:right;direction:rtl">  تشغيل على جهاز الكمبيوتر الخاص بك </h3><br>  لبدء المكدس بالكامل ، يجب عليك: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  ضع روس </li><li style=";text-align:right;direction:rtl">  cost_map_server cost_map_server_alone.launch - لبدء الخريطة </li><li style=";text-align:right;direction:rtl">  roslaunch global_planner global_planner.launch - إطلاق المسوي العالمي مع المعلمات </li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosparam load $ (find local_planner) /param/param.yaml </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun local_planner local_planning </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun trajectory_regulator </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun global_planner المحرك </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun rviz </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إضافة تضخم </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الآن أرسل رسالة إلى الموضوع / gp / الهدف ، نرسل الروبوت إلى النقطة المطلوبة </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نتيجة لإطلاق جميع العناصر ، سيكون لديك محاكاة جاهزة لإطلاق مجموعتنا على جهاز الكمبيوتر الخاص بك. </font></font><a href="https://github.com/lelongg/cost_map" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">شوكة اللازمة</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iRY5WHgAFns" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في البداية ، احتجنا إلى نظام الملاحة الذي سيساعدنا على قيادة الروبوت بشكل جميل وسريع وبدقة على عجلات متعددة الاستخدامات. </font><font style="vertical-align: inherit;">أثناء الاستعداد للمسابقة ، لم تُجرح قطة واحدة ، والروبوت وسيم. </font><font style="vertical-align: inherit;">نتيجة لذلك ، لدينا مجموعة تنقل خفيفة الوزن للمسابقات المماثلة لـ eurobot ، والتي نحن راضون تمامًا عنها. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بالنسبة لنا ، هذه المكدس أفضل من المعيار ، لكن ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Telegram: t.me/SetUpSber </font><a href="https://github.com/ristle/EUrobotNavigation" rel="nofollow"><font style="vertical-align: inherit;">مستودع كل</font></a><font style="vertical-align: inherit;"> إبداعاتنا</font></font><br> <a href="https://github.com/ristle/EUrobotNavigation" rel="nofollow"><font style="vertical-align: inherit;"></font></a> <br><br><img src="https://habrastorage.org/webt/98/gl/4m/98gl4mdibk20qgavmhzkbdppu4w.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar479636/">https://habr.com/ru/post/ar479636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar479602/index.html">ما هو الجينوم الكامل ولماذا هو مطلوب</a></li>
<li><a href="../ar479618/index.html">Postgres Pro Standard 12.1 Release</a></li>
<li><a href="../ar479620/index.html">عكس المنطق</a></li>
<li><a href="../ar479622/index.html">كيف يعمل النموذج الأولي للمعاملات مجهولة المصدر على blockchain Waves</a></li>
<li><a href="../ar479624/index.html">Postgres Professional gendar Oleg Bartunov يخبر Faride Roslovets عن PostgreSQL والأعمال في روسيا</a></li>
<li><a href="../ar479642/index.html">كيف أدت القرارات الغبية عند تصميم طائرة الحرب العالمية الثانية إلى إنشاء ماكنتوش</a></li>
<li><a href="../ar479644/index.html">كلمات بسيطة عن البرنامج</a></li>
<li><a href="../ar479646/index.html">نصيحة سيئة أو أسباب لمواصلة تعلم اللغة الإنجليزية بعد المرحلة المتوسطة</a></li>
<li><a href="../ar479650/index.html">أعلى 12 الرسوم البيانية ديناميكية تكنولوجيا المعلومات الأكثر إثارة للاهتمام</a></li>
<li><a href="../ar479654/index.html">مولد Django vue</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>