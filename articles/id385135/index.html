<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏽 🎫 🍕 Hidroponik di ambang jendela atau C ++ 11 di mikrokontroler AVR 👩🏻‍🎤 🆙 😣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Proyek ini tidak mengandung Arduino
 
 
 Proyek ini awalnya seharusnya terlihat berbeda - struktur monumental yang terdiri dari alas dengan kaleng dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hidroponik di ambang jendela atau C ++ 11 di mikrokontroler AVR</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/385135/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proyek ini tidak mengandung Arduino</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/911/af2/659/911af265948b47c6933b93c9ff846e34.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proyek ini awalnya seharusnya terlihat berbeda - struktur monumental yang terdiri dari alas dengan kaleng dan pompa, akuarium dipasang di atasnya dan oasis tomat di atasnya. Sebuah air terjun direncanakan di surga oasis tomat, dan bentuk kehidupan ikan di akuarium, persyaratan utama yang adalah kemampuan untuk makan penghuni akuarium yang tidak terencana dan menjaga gelas tetap bersih; kandidat utamanya adalah somiki dan gurami. Seperti yang mungkin sudah Anda duga, moto saya adalah "kemalasan adalah mesin kemajuan" (dan apa yang dapat Anda lakukan agar Anda tidak membersihkan akuarium dan tidak menyirami tomat).</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebuah monumen untuk moto ini mungkin akan didirikan jika belum runtuh pada tahap koordinasi draf garis besar dengan istrinya. Dia tidak terinspirasi oleh ide menjadikan bandura ini dekorasi utama ruang tamu, dan bahkan air terjun tidak meyakinkannya tentang hal ini. Tetapi gagasan tentang sistem otonom, simbiosis biologi dan elektronik, tidak mau terbang keluar dari kepalaku, dan proyek itu menyempit ke ukuran pot bunga - aquaponik berubah menjadi hidroponik, kehidupan ikan diselamatkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gagasan utama hidroponik adalah penggunaan larutan nutrisi berair alih-alih tanah. Ini memungkinkan urutan besarnya untuk mempercepat pertumbuhan tanaman. Namun, seseorang tidak bisa hanya menurunkan akar ke dalam air - mereka membutuhkan oksigen, yang tanpanya mereka akan mulai mati. Dalam hal ini, ada pilihan - terus-menerus meniup air dengan kompresor, seperti di akuarium, atau secara berkala membasahi akar dengan larutan nutrisi, dan tiriskan setelah beberapa waktu. Opsi pertama memiliki kelemahan - senandung kompresor yang konstan. Pilihan kedua memiliki keunggulan - sebagian besar akar berada di udara, pernapasan aktif, dan efek mempercepat pertumbuhan harus lebih besar. Selain itu, mereka direndam dalam substrat butiran berpori khusus yang mempertahankan kelembaban. Pilihannya jelas, saya mengambil opsi kedua sebagai dasar.Dalam kasus ikan, sistem bisa berubah menjadi hampir sepenuhnya tertutup - sekresi ikan diproses oleh bakteri khusus dalam biofilter, produk olahan diumpankan ke tanaman, lapisan pasir menyaring air, air bersih dikembalikan ke akuarium. Dalam kasus yang ideal, pakan kadang-kadang ditaburkan ke pengumpan otomatis, dan tomat berkumpul dari semak-semak. Tapi itu tidak tumbuh bersama, mungkin itu menjadi lebih baik - siapa yang tahu bagaimana urutan melalui surat dari bakteri yang diperlukan akan berakhir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akibatnya, perangkat tanaman tomat mengambil kontur. </font><font style="vertical-align: inherit;">Dua kapal - yang bawah dengan air, yang atas dengan substrat dan tanaman. </font><font style="vertical-align: inherit;">Untuk banjir kita akan menggunakan pompa Cina kecil dengan motor DC, untuk drainase kita akan menggunakan siphon otomatis. </font><font style="vertical-align: inherit;">Prinsip pengoperasian siphon dalam video:</font></font><br>
<iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.youtube.com/embed/5wZ9PQepQYI%3Ffeature%3Doembed&amp;usg=ALkJrhjYLSheb5BlsjpWLe3o7xa0HIwsbw" frameborder="0" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hidroponik dengan siphon yang serupa:</font></font><br>
<iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.youtube.com/embed/ZHaiVhVZ3kM%3Ffeature%3Doembed&amp;usg=ALkJrhhQcxLXS6D3qqYj3R24gsn6EaIImQ" frameborder="0" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otak perangkat adalah mikrokontroler ATMEGA328P (hanya karena placer sudah dekat). Tugasnya termasuk mengelola banjir dan pembuangan sesuai dengan jadwal, memantau ketinggian air di dalam tangki dan menandakan kekurangannya, mengendalikan iluminasi tanaman (kami ingin memiliki panjang siang minimum minimum tertentu; ketika cahaya alami berakhir, cahaya buatan secara bertahap menyala), antarmuka pengguna untuk melihat status, manajemen, dan konfigurasi seluruh ekonomi ini. Jelas, ini membutuhkan semacam solusi untuk sensor ketinggian air, sensor cahaya, jam waktu nyata, dan semacam terminal pengguna. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum menjelaskan detailnya, daftar sumber daya proyek: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda dapat melihat foto hasil dan proses pembuatannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Video pendek:</font></font><br>
<br>
<iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.youtube.com/embed/C_qit2_2rrY%3Ffeature%3Doembed&amp;usg=ALkJrhjG29EsVtEeMS3xjTKSi4IasdnfGw" frameborder="0" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proyek ini tersedia di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Di sana, dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rilis,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file dengan proyek bagian elektronik di KiCAD dan proyek desain dan peluit di SolidWorks ditata (file STL untuk pencetakan dilampirkan).</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fitur-fitur perakitan firmware</font></font></b><div class="spoiler_text">      — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>    « ».    ,   , ,        USB    AVR (,   ,    ,     ,      ),               .  -    ,     ,    'ADK_ROOT'     ,        'scons'.<br>
</div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skema bagian elektronik: </font></font><br>
<br>
<img src="https://habrastorage.org/files/cfc/96b/dad/cfc96bdad51648caa640d661ac6ffc40.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rincian lebih lanjut, deskripsi tentang jebakan dan sedikit kode. </font><font style="vertical-align: inherit;">Deskripsi masalah perangkat lunak </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di bagian paling akhir</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mungkin seseorang akan tertarik untuk melihat contoh baru bekerja dengan I2C, valcoder, modul RTC, dan tampilan grafik. </font><font style="vertical-align: inherit;">Semua kode dalam proyek ditulis "dari awal" tanpa menggunakan solusi pihak ketiga (karena saya bisa).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sensor level air</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah paling sensitif diputuskan terlebih dahulu. Tentu saja ada varian dari beberapa jenis pelampung sehingga, misalnya, akan memindahkan rel tempat kode Gray diterapkan, dan sensor optik akan dibaca. Tapi itu benar-benar terlihat tidak dapat diandalkan. Pencarian di eBay tidak membuahkan hasil - ada saklar apung (level yang diinginkan tercapai atau tidak), atau elektroda terbenam dan bacaan berdasarkan konduktivitas medium, tetapi ini segera dicatat, karena komposisi air akan terus berubah seiring dengan konduktivitas dari penambahan pupuk dan pembubaran kotoran dari substrat. Akibatnya, muncul ide untuk menggunakan pengintai ultrasonik, salah satu yang biasanya ditempatkan pada robot yang berbeda. Seperti yang direncanakan, sensor ditempatkan di tutup tangki dan sinyal dipantulkan langsung dari permukaan air. Telah dibeli HC-SR04 (pilihan nilai terkecil dari jarak kerja minimum - ia memiliki 2cm),dan konsepnya diperiksa pada seember air. Ternyata itu bekerja untuk dirinya sendiri (ada kekhawatiran bahwa tidak akan ada pantulan normal dari permukaan air, atau bahwa tidak akan ada cukup directivity balok dan akan ada pantulan yang tidak diinginkan dari dinding tangki). By the way, pengintai juga merupakan opsi cadangan, tetapi inframerah. Di permukaan air seharusnya melempar pelampung dengan reflektor. Satu-satunya masalah adalah jarak kerja minimum mereka 10cm (dari yang saya temukan), yang sudah sedikit banyak untuk dimensi yang diberikan.Di permukaan air seharusnya melempar pelampung dengan reflektor. Satu-satunya masalah adalah jarak kerja minimum mereka 10cm (dari yang saya temukan), yang sudah sedikit banyak untuk dimensi yang diberikan.Di permukaan air seharusnya melempar pelampung dengan reflektor. Satu-satunya masalah adalah jarak kerja minimum mereka 10cm (dari yang saya temukan), yang sudah sedikit banyak untuk dimensi yang diberikan.</font></font><br>
<br>
<img src="https://habrastorage.org/files/ee1/7ac/b85/ee17acb8500c4a94b65014c08d3df694.jpg"><br>
<img src="https://habrastorage.org/files/cd2/558/d46/cd2558d46164418f95b883a60c20c213.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menurut hasil proyek, pendekatan ini bekerja, dan dapat digunakan dalam praktik, tidak ada masalah yang diperhatikan. Sebaiknya mengambil tindakan untuk mengisolasi papan dari kelembaban (penyegelan dalam case). Itu hanya sensornya sendiri yang tetap terbuka, mungkin masih ada.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antarmuka sensornya sederhana - pulsa dikirim ke input pemicu, yang memicu sinyal gema. Sebuah pulsa dihasilkan pada output gema, yang panjangnya sama dengan waktu dari awal radiasi hingga penerimaan sinyal gema yang dipantulkan. Dengan mengukur panjang pulsa, mengetahui kecepatan suara dan fakta bahwa sinyal menuju ke objek dan kembali, Anda dapat menghitung jarak. Dalam proyek ini, ini diterapkan di kelas LevelGauge. Untuk mengukur panjang pulsa, kemampuan perangkat keras “input input” MK AVR digunakan. Dalam hal ini, pengatur waktu perangkat keras diatur ulang pada tepi naik dari pulsa, dan pada nilai pengukur waktu ke bawah, perangkat keras disimpan dalam register ICR1, dan interupsi dihasilkan. Dengan demikian, dimungkinkan untuk mengukur durasi pulsa dengan akurasi yang cukup dan konsumsi waktu prosesor minimum.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan dengan model sensor ini, sebuah kesalahan diperhatikan - ketika daya diterapkan, garis gema tetap terus aktif. </font><font style="vertical-align: inherit;">Dia memintas dengan menerapkan denyut nadi ke pelatuk dan menunggu sampai siklus gema-lokasi pertama berlalu.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lampu latar</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lampu latar dibuat oleh tiga pegangan LED. </font><font style="vertical-align: inherit;">Saya menekuk bingkai segitiga dari profil aluminium, menempelkan LED di atasnya dengan epoksi. </font><font style="vertical-align: inherit;">Saya memesan stabilizer China saat ini dengan daya 700mA. </font><font style="vertical-align: inherit;">Sekitar tiga volt jatuh pada setiap dioda, stabilizer memerlukan perbedaan antara voltase input dan output setidaknya dua volt, dan saya akan memberi daya seluruh wunderwafer dari catu daya 12 volt. </font><font style="vertical-align: inherit;">Dari sini mudah untuk menghitung mengapa tepatnya tiga LED.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dioda berwarna putih hangat. Bagiku itu alami, spektrum matahari dan semua itu. Tetapi seperti yang saya ketahui kemudian, setelah saya memesannya, tanaman biasanya menggunakan kombinasi merah dan biru. Seperti yang saya pahami, seluruh pertanyaan hanya dalam efisiensi. Jika Anda memiliki pertanian besar dengan pencahayaan sepanjang waktu, maka Anda tertarik bahwa semua energi yang dihabiskan dihabiskan untuk selamanya. Di bawah pencahayaan putih, daun hijau akan mencerminkan komponen hijau, sebagian besar energi yang dihabiskan untuk pencahayaan akan terbuang sia-sia.</font></font><br>
<br>
<img src="https://habrastorage.org/files/b75/39b/561/b7539b5610cf43039f95a393567ce5ce.jpg"><br>
<img src="https://habrastorage.org/files/6e3/a21/084/6e3a2108427a44518658b276d5affe3c.JPG"><br>
<img src="https://habrastorage.org/files/1af/253/8d1/1af2538d188c4dfe962d915a09bb2fba.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fitur penting dari stabilizer adalah adanya input untuk pengaturan PWM, yang saya gunakan untuk menyesuaikan kecerahan. Ini adalah penggaruk Cina lainnya. Pertama, ternyata hanya fungsional saat ini on / off. Artinya, saya berharap bahwa arus keluaran tidak akan dimodulasi, dan nilainya akan tergantung pada siklus tugas sinyal PWM, tetapi arus hanya mengulangi pulsa pada input kontrol. Tapi ini tidak terlalu buruk, penyergapan lain adalah bahwa regulator bereaksi tidak memadai terhadap PWM dengan frekuensi yang cukup tinggi. Saya harus menurunkannya ke 300Hz, di mana ia bekerja lebih atau kurang normal. Sinyal PWM dihasilkan oleh mikrokontroler dalam perangkat keras menggunakan salah satu timer.</font></font><br>
<br>
<img src="https://habrastorage.org/files/fde/4a1/3d6/fde4a13d69f04e909fe2fafbcb526ed4.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagian penting lain dari perakitan lampu latar adalah sensor cahaya. Fototransistor dipilih dalam peran ini. Dan ya, ada dua di antaranya - satu di atas LED untuk mengukur cahaya alami, yang kedua di bawah LED untuk memberikan umpan balik. Benar, fungsi ekstensi siang hari otomatis belum diterapkan, seperti di musim panas, dan itu tidak perlu (dan motivasi adalah masalah serius). Diasumsikan bahwa segera setelah sensor pertama mendeteksi penurunan tingkat pencahayaan (dan waktu yang dialokasikan untuk siang hari belum kedaluwarsa), lampu diatur sehingga sensor kedua menghasilkan tingkat yang sesuai dengan iluminasi yang diinginkan. Untuk melakukan ini, Anda perlu menerapkan kontroler PID sederhana dalam kode. Tetapi sementara di antarmuka Anda hanya dapat melihat pembacaan sensor saat ini, dan secara manual memutar kecerahan cahaya latar yang diinginkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan koneksi sensor. </font><font style="vertical-align: inherit;">Masing-masing dari mereka memiliki dua rentang tetap, yang dipilih dengan menghubungkan ke nol resistor yang sesuai. </font><font style="vertical-align: inherit;">Kaki mikrokontroler, terhubung ke resistor kedua, pada saat ini ditransfer ke keadaan resistansi tinggi. </font><font style="vertical-align: inherit;">Anda dapat menyalakan kedua resistor secara bersamaan, maka akan ada tiga rentang pengukuran tetap. </font><font style="vertical-align: inherit;">Sinyal dari resistor emitor dilewatkan melalui sirkuit RC untuk menyaring pulsa modulasi - cahaya dari LED berdenyut bersama dengan sinyal PWM pada regulator saat ini.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pompa</font></font></h4><br>
<img src="https://habrastorage.org/files/a13/933/895/a13933895d9f4546a4ab7e54e87c056b.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cina paling murah, persneling, dengan motor DC. </font><font style="vertical-align: inherit;">Penyergapan, tentu saja, tersedia. </font><font style="vertical-align: inherit;">Terlepas dari kenyataan bahwa ia mengatakan 12V, itu tidak berfungsi untuk waktu yang lama pada tegangan ini. </font><font style="vertical-align: inherit;">Satu terbakar sebelum perakitan struktur. </font><font style="vertical-align: inherit;">Skema menyediakan PWM untuk itu, daya maksimum dikonfigurasi di antarmuka, dalam praktiknya tidak ditetapkan di atas 70%. </font><font style="vertical-align: inherit;">Sudah pada level ini, dia melolong liar di tempat kerja, tetapi sebagian besar waktu dia bekerja pada daya yang jauh lebih rendah - sekitar 30% dan bergemuruh dengan tenang. </font><font style="vertical-align: inherit;">Tentang mode operasinya di bawah ini, dalam deskripsi logika flooding. </font><font style="vertical-align: inherit;">Kapasitor yang lebih besar (C8 dalam diagram) harus diposisikan lebih dekat ke sirkuit daya pompa, jika tidak akan ada gangguan besar ke seluruh rangkaian (dalam praktiknya, ternyata regulator saat ini untuk LED paling sensitif terhadap mereka, musik ringan dimulai).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jam waktu nyata</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada ide gila untuk menggunakan sumber daya mikrokontroler untuk tujuan ini. Generator jam kuarsa memiliki akurasi yang cukup baik, di proyek lain pendekatan ini bekerja dengan baik. Tetapi masalahnya adalah benar-benar semua timer perangkat keras sudah diambil untuk keperluan lain. Tidak ada pilihan selain menemukan modul RTC eksternal. Puji orang Cina, mereka ada di sana dan murah. </font></font><br>
<br>
<img src="https://habrastorage.org/files/16f/8e2/404/16f8e24047b9445f969a1d1e9333b4bc.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modul berdasarkan DS3231 memiliki antarmuka I2C, catu daya redundannya sendiri - waktu tidak akan salah dengan pemadaman. Ada keluaran berliku-liku pada beberapa frekuensi tetap - 1 kHz, 4 kHz dan 8 kHz. Ini sangat berguna untuk sinyal audio - sekali lagi, Anda tidak perlu memuat MCU, dan tidak ada timer gratis untuk ini. EEPROM 32Kbit adalah bonus, tetapi tidak digunakan dalam proyek ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anehnya, ini sangat akurat - dalam beberapa bulan waktu kehilangan kekuatannya selama beberapa detik. </font><font style="vertical-align: inherit;">Dia menyatakan bahwa dia memperhitungkan pengaruh suhu pada frekuensi generator, dan tampaknya ini berfungsi. </font><font style="vertical-align: inherit;">Namun, jika waktu berlalu, ada kemungkinan koreksi frekuensi perangkat lunak. </font><font style="vertical-align: inherit;">Pembacaan sensor suhu tersedia, dan dalam proyek ini ditampilkan di antarmuka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas Rtc bertanggung jawab untuk bekerja dengan modul ini dalam kode.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampilan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya sudah lama ingin melakukan sesuatu dengan tampilan grafis. </font><font style="vertical-align: inherit;">Mencari yang termurah dengan antarmuka I2C memberi opsi ini.</font></font><br>
<br>
<img src="https://habrastorage.org/files/629/1fb/ecc/6291fbeccac04dfe854f3a3e45b2a2a3.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Monochrome OLED menampilkan 128x64 piksel berdasarkan pada pengontrol SSD1306 yang agak populer. Saat memilih, Anda harus hati-hati melihat deskripsi - chip yang sama mendukung antarmuka lain, kecuali I2C, dan ada opsi tanpa itu. Atau mereka menulis bahwa ini universal, mendukung I2C juga, tetapi dalam kenyataannya akan perlu untuk sedikit memodifikasi papan dengan mengatur ulang nol ke situs lain. Oleh karena itu, jika Anda berencana untuk menggunakan I2C, lebih baik untuk memilih satu di mana hanya I2C ditampilkan di papan tulis, akan ada lebih sedikit keributan dengan papan yang tidak memiliki hampir semua dokumentasi (dokumentasi hanya untuk chip). Versi ini bekerja dari 5V, board memiliki regulator 3.3V yang diperlukan untuk controller. Saya bertemu ulasan yang dalam beberapa versi mungkin tidak.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Layar umumnya puas. Saya perhatikan hanya satu fitur yang tidak menyenangkan - kecerahan baris piksel tergantung pada berapa banyak piksel yang menyala di dalamnya. Semakin terang, semakin rendah kecerahan. Kontras antara garis mungkin mencolok jika area yang terisi penuh dengan beberapa elemen sempit bergantian di layar. Namun dalam praktiknya, ini tidak terlihat dalam gambar saya dan tidak mencolok. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengontrol dapat dikonfigurasikan untuk beroperasi dalam berbagai mode untuk menampilkan isi memori layar pada matriks piksel. Itu lebih nyaman bagi saya ketika setiap byte dipetakan ke kolom vertikal delapan piksel tinggi, dan kolom pergi secara horizontal dari kiri ke kanan, mengisi layar dengan garis delapan piksel tinggi. Dalam mode ini, lebih mudah untuk menggambar teks.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seringkali, suatu pendekatan dipraktikkan di mana memori tampilan diduplikasi dalam RAM MCU - pertama, semua tindakan dengan gambar dilakukan dalam RAM, dan kemudian semua piksel yang diubah disalin ke memori tampilan. Dalam proyek ini, pendekatan ini tidak digunakan untuk menghemat sumber daya. Semua tempat yang diubah digambar ulang langsung dalam memori tampilan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang disarankan dalam komentar, tampilan OLED memudar seiring waktu. Saya juga menduga ini (mengingat apa itu screen saver), dan menyediakan tampilan untuk dimatikan setelah beberapa menit setelah aktivitas terakhir pada kontrol. Menyala saat menyalakan atau menekan encoder. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kode, bekerja dengan layar diimplementasikan di kelas Tampilan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Valkoder:</font></font><br>
<br>
<img src="https://habrastorage.org/files/ee6/a1e/6b5/ee6a1e6b5921493bb395675e2805f2c6.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menurut pendapat saya, valcoder adalah opsi kontrol terbaik untuk perangkat seperti itu yang memiliki setidaknya beberapa antarmuka pengguna. Ini kompak dan sangat nyaman. Lebih mudah bagi mereka untuk membuka dan memilih item menu, mengubah nilai parameter apa pun, beralih mode, dll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menghubungkan, diperlukan tiga kaki input mikrokontroler. Satu untuk tombol (Anda dapat menekan pegangan), dua untuk valcoder itu sendiri. Ada sinyal </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode Gray</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari encoder </font><font style="vertical-align: inherit;">. Pada setiap langkah belokan, satu bit berubah pada dua baris. Urutan menentukan arah rotasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya tampak sederhana, tetapi, tampaknya, pengembang tidak selalu dapat membuat dukungan berkualitas tinggi untuk perangkat semacam itu. Sebagai contoh, pada printer 3D saya ada papan RAMPS dan papan dengan layar dan encoder yang sama persis terhubung. Firmware Marlin bekerja dengannya, tetapi pengalaman menggunakannya sangat buruk - tidak ada perasaan dapat diandalkan - ketika Anda mengklik kenop saat memutar kenop, antarmuka sering berhenti pada item menu yang salah atau nilai parameter yang diharapkan. Dengan rotasi cepat, rasanya klik dilewati. Pada titik tertentu, beralih tidak dimulai saat klik, tetapi di suatu tempat di antaranya, sangat tidak menyenangkan. Ya, apa itu Marlin, saya terkadang memiliki perasaan yang sama pada sistem multimedia bawaan di mobil. Dalam hal ini, beberapa tips (dan, tentu saja, lihat kode di sekitar kelas RotEnc).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, poin yang cukup jelas bagi siapa saja yang menghubungkan tombol apa saja ke mikrokontroler - Anda harus berurusan dengan bouncing. Encoder mekanis ini dan jalur sinyalnya, pada kenyataannya, adalah tombol yang sama, dan mereka juga memiliki obrolan. Pertama, kami memfilter obrolan, lalu kami memproses urutan status garis sinyal. Mungkin ada valcoder dengan sensor optik, itu sudah tergantung pada skema pemrosesan sinyal dari mereka. Jika kaki-kaki sebuah fototransistor dibawa keluar secara langsung, maka ia dapat berputar di sana dengan rotasi lambat, tetapi jika ada skema pemrosesan yang memperkenalkan histeresis, maka penindasan perangkat lunak tidak diperlukan. Tetapi perangkat seperti itu lebih mahal dan jarang digunakan dalam perangkat amatir, yang paling umum adalah mekanik, beberapa dolar banyak.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kedua, poin yang sedikit kurang jelas, mungkin salah satu dari yang Marlin terbakar - pegangan memiliki posisi stabil selama rotasi - klik (klik). Model ini memiliki empat langkah dari urutan kode untuk setiap klik. Jadi, Anda perlu merespons klik, dan bukan pada langkah-langkah urutannya. Dan yang paling penting adalah melakukan sinkronisasi dengan posisi stabil. Banyak yang cukup memasukkan STEPS_PER_CLICK konstan, dan, misalnya, merespons setiap langkah keempat. Tetapi masalahnya adalah bahwa sinyalnya tidak sempurna, urutannya mungkin tidak sepenuhnya benar. Dengan ejaan tertentu, kode dapat “tersesat”, sebagai akibatnya, setiap langkah keempat akan diperoleh di suatu tempat di tengah klik, yang akan membuat pengguna tidak nyaman. Pada saat yang sama, posisi tetap dari pegangan untuk model tertentu sesuai dengan nilai kode tetap,itu harus dilampirkan padanya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketiga, sekali lagi, titik yang cukup jelas bagi pengembang sistem mikrokontroler yang kurang lebih berpengalaman - gunakan interupsi perangkat keras untuk mengubah keadaan jalur input. </font><font style="vertical-align: inherit;">Minimal, akan ada sedikit risiko "kehilangan" langkah-langkah urutan. </font><font style="vertical-align: inherit;">Tetapi secara umum, seperti yang Anda tahu, gangguan adalah segalanya bagi kami. </font><font style="vertical-align: inherit;">MCU harus tidur bila memungkinkan, bangun hanya dengan gangguan - baik dari luar, atau dari timer untuk melakukan tugas yang tertunda. </font><font style="vertical-align: inherit;">Ini adalah prinsip-prinsip desain arsitektur sistem yang baik.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desain secara keseluruhan</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu terbuat dari bahan improvisasi dan berbagai bagian yang dicetak pada printer 3D dari ABS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prinsip pengoperasian siphon diilustrasikan dalam video di atas. Bagi saya, ini adalah tabung PVC eksternal, dan tabung internal dengan corong di ujungnya. Untuk sifon klasik, diperlukan lutut lain, tetapi sudah sulit untuk membuatnya secara konstruktif. Ketika masalah dengan saluran pembuangan ditemukan, bak mandi kecil tersangkut di dinding tangki bagian bawah, di mana ujung pipa bagian dalam direndam, dan menciptakan ketahanan terhadap saluran pembuangan, sehingga sifon dapat bekerja.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ternyata ABS adalah bahan yang sangat hidrofobik. Air benar-benar tidak meluap melalui itu, saya bahkan harus mengulang corong siphon. Layak mempertimbangkan properti ini, tidak mungkin membuat sistem hidrolik miniatur (misalnya, saya ingin membuat permukaan panduan pada corong sifon, untuk memutar air, untuk meningkatkan respons sifon. Tetapi dengan dimensi dan hidrofobisitas ABS seperti ini tidak masuk akal) . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya juga mencoba untuk merekatkan semuanya bersama-sama dengan pistol lem panas. Itu tidak berhasil - pada awalnya semuanya tampak kuat, tetapi setelah beberapa hari jatuh sendiri. Pilihan terbaik adalah Asia Tengah. Detail, bahkan di bawah air, pegang erat-erat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kesalahan perhitungan terbesar dalam desain adalah wadah transparan. Saya benar-benar lupa tentang fakta bahwa air mekar dalam cahaya. Saya harus membungkusnya dengan bahan buram. Nah, Anda dapat secara berkala menambahkan kalium permanganat untuk disinfeksi, ini tampaknya tidak membahayakan tanaman.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algoritma flooding adalah sebagai berikut - pertama pompa dihidupkan dengan daya rendah dan mengisi seluruh tangki bagian atas dengan diam-diam. Proses ini dimonitor oleh sensor level. Ketika air mulai meluap melalui corong siphon, level penurunan di tangki bawah berhenti, yang terdeteksi oleh sensor. Aliran kecil yang dibuat dengan daya rendah tidak cukup untuk memicu siphon. Pompa berhenti, volume yang dipompa ke tangki atas diingat. Akar disimpan dalam larutan selama beberapa menit, setelah itu pompa hidup kembali. Pertama, pada daya rendah, sampai air mencapai corong lagi (selama downtime, ia turun lebih rendah karena efek siphon), dan ketika tingkat corong tercapai, pompa beralih ke daya yang meningkat, menyediakan aliran yang cukup untuk menyedot siphon untuk beroperasi. Aliran melalui siphon dijamin lebih tinggi dari aliran pompa,akibatnya, level di tangki bawah mulai naik, ini terdeteksi oleh sensor dan pompa berhenti.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Siklus banjir mulai secara berkala, pada interval waktu tetap dan dapat dikonfigurasi, dari subuh hingga senja. </font><font style="vertical-align: inherit;">Menurut rencana, fajar seharusnya diperbaiki oleh sensor cahaya, dan panjang siang hari, jika perlu, diperluas ke nilai yang ditetapkan, tetapi sampai saat itu tangan belum mencapainya. </font><font style="vertical-align: inherit;">Waktu subuh hanya diatur dalam pengaturan.</font></font><br>
<br>
<a name="cpp11"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan di mana C ++ 11?</font></font></h4><br>
<a name="cpp11"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin seseorang akan meragukan bahwa C ++ 11 dapat berguna dalam pemrograman mikrokontroler (di antara mereka yang umumnya sadar bahwa mikrokontroler dapat diprogram dalam C ++). </font><font style="vertical-align: inherit;">Saya akan mencoba memberikan contoh spesifik tentang manfaat C ++ 11 di area ini (selain hal-hal kecil yang jelas menyenangkan seperti constexpr, override, default, dll.).</font></font><br>
<br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penempatan sumber daya string</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banyak orang tahu bahwa RAM dalam mikrokontroler adalah sumber daya yang sangat terbatas. Ini bisa menjadi masalah jika aplikasi Anda, misalnya, memiliki antarmuka pengguna, dan program Anda menggunakan sejumlah baris yang cukup besar. Jika dalam kode untuk menulis sesuatu seperti</font></font><br>
<pre><code class="cpp hljs">PromptUser(<span class="hljs-string">"Are you sure you want to format SD-card?"</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
maka garis yang dilewati dalam argumen akan ditempatkan di bagian data yang diinisialisasi (selanjutnya, perilaku kompiler GCC untuk platform AVR) - yaitu, di area RAM, yang saat startup (sebelum fungsi utama dipanggil) diinisialisasi dari memori flash program. Fungsi PromptUser () akan memberikan pointer ke lokasi yang diinginkan dalam RAM. Jika Anda menggunakan pendekatan serupa di seluruh program, maka RAM akan berakhir dengan cepat (di ATMEGA328P yang digunakan dalam proyek ini hanya 2 kilobyte, dan ini juga untuk BSS, heap dan stack). Untuk mengatasi batasan ini, fungsi-fungsi seperti PromptUser () belajar untuk bekerja bukan dengan pointer ke RAM, tetapi dengan pointer ke suatu wilayah dalam memori flash program. Anda dapat membaca dari sana hanya dengan bantuan instruksi khusus, yang, misalnya, dalam avr-libc dibungkus dengan fungsi keluarga </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eeprom_read_ [byte | word | dword | ...]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, string pertama-tama harus ditempatkan dalam variabel yang dilengkapi dengan atribut PROGMEM, yang memberitahu kompiler bahwa ia harus ditempatkan dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memori program</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">char</span> prompt[] PROGMEM = <span class="hljs-string">"Are you sure you want to format SD-card?"</span>;<font></font>
PromptUser(prompt);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini merepotkan jika Anda ingin mendeklarasikan semua lini secara terpusat. </font><font style="vertical-align: inherit;">Maka Anda harus terlebih dahulu mendeklarasikan deklarasi mereka di file header:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> prompt[] PROGMEM;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan dalam file .cpp terpisah, tentukan:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">char</span> prompt[] PROGMEM = <span class="hljs-string">"Are you sure you want to format SD-card?"</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Duplikasi kode, yang tidak baik, dan sangat merepotkan ketika ada banyak baris seperti itu. </font><font style="vertical-align: inherit;">Ya, ini dapat dielakkan dengan membuat makro yang rumit, dan termasuk file header dalam file .cpp yang terpisah, di mana makro akan diperluas ke dalam definisi, sementara dalam konteks lain akan diperluas ke dalam deklarasi. </font><font style="vertical-align: inherit;">Tetapi dengan C ++ 11 ada opsi yang lebih bersih jika Anda menggunakan inisialisasi anggota kelas ketika mendeklarasikan. </font><font style="vertical-align: inherit;">Di file header, deklarasikan kelas dengan baris:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEF_STR(__name, __text) \
    const char __name[sizeof(__text)] = __text;</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strings</span> {</span>
<span class="hljs-keyword">public</span>:<font></font>
    DEF_STR(Prompt, <span class="hljs-string">"Are you sure you want to format SD-card?"</span>)<font></font>
    DEF_STR(OtherString, <span class="hljs-string">"..."</span>)<font></font>
    …<font></font>
} __attribute__((packed));<font></font>
<font></font>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> Strings strings PROGMEM;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam file .cpp:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> Strings strings PROGMEM;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang semua baris dideklarasikan di satu tempat, ditempatkan dalam memori program, dan Anda dapat mengaksesnya seperti ini:</font></font><br>
<pre><code class="cpp hljs">PromptUser(strings.prompt);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam proyek ini, pendekatan berdasarkan prinsip yang sama digunakan untuk menentukan bitmap - berbagai gambar yang ditampilkan pada tampilan grafis.</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">/** Bitmap descriptor. */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Bitmap</span> {</span>
    <span class="hljs-comment">/** Pointer to data array if in data memory. Offset of data array relatively
     * to Bitmaps class instance start address if in program memory.
     */</span>
    <span class="hljs-keyword">const</span> u8 *data;
    <span class="hljs-comment">/** Number of pages in the bitmap. */</span><font></font>
    u8 numPages,<font></font>
    <span class="hljs-comment">/** Number of columns in the bitmap. */</span><font></font>
       numColumns;<font></font>
} __PACKED;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;u8... data&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">static</span> u8
<span class="hljs-title">Bitmap_NumDataBytes</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">sizeof</span>...(data);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/** Define bitmap.
 * @param __name Name for accessing.
 * @param __numPages Number of pages in the bitmap. Number of columns defined as
 *      total number of data bytes divided by number of pages.
 * @param __VA_ARGS__ Data bytes.
 */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEF_BITMAP(__name, __numPages, ...) \
    const u8 __CONCAT(__name, __data__) \
        [Bitmap_NumDataBytes<span class="hljs-meta-string">&lt;__VA_ARGS__&gt;()] = { __VA_ARGS__ }; \</span></span>
    <span class="hljs-keyword">const</span> Bitmap __name { \
        <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> u8 *&gt;(OFFSETOF(Bitmaps, __CONCAT(__name, __data__))), \<font></font>
        __numPages, \<font></font>
        <span class="hljs-keyword">sizeof</span>(__CONCAT(__name, __data__)) / __numPages};<font></font>
<font></font>
<span class="hljs-comment">/** Global bitmaps repository. Stored in program memory. */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bitmaps</span> {</span>
<span class="hljs-keyword">public</span>:<font></font>
<font></font>
    <span class="hljs-comment">/** Thermometer icon. */</span>
    DEF_BITMAP(Thermometer, <span class="hljs-number">1</span>,
        <span class="hljs-number">0b01101010</span>,
        <span class="hljs-number">0b10011110</span>,
        <span class="hljs-number">0b10000001</span>,
        <span class="hljs-number">0b10011110</span>,
        <span class="hljs-number">0b01101010</span><font></font>
    )<font></font>
<font></font>
    <span class="hljs-comment">/** Sun icon. */</span>
    DEF_BITMAP(Sun, <span class="hljs-number">1</span>,
        <span class="hljs-number">0b00100100</span>,
        <span class="hljs-number">0b00011000</span>,
        <span class="hljs-number">0b10100101</span>,
        <span class="hljs-number">0b01000010</span>,
        <span class="hljs-number">0b01000010</span>,
        <span class="hljs-number">0b10100101</span>,
        <span class="hljs-number">0b00011000</span>,
        <span class="hljs-number">0b00100100</span><font></font>
    )<font></font>
    ...<font></font>
};<font></font>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">const</span> Bitmaps bitmaps PROGMEM;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perbedaannya adalah bahwa selain data gambar itu sendiri, perlu juga untuk menempatkan atribut (ukuran gambar). </font><font style="vertical-align: inherit;">Setiap byte mendefinisikan kolom delapan piksel. </font><font style="vertical-align: inherit;">Kolom dapat mengisi satu atau lebih baris, jumlahnya ditunjukkan oleh parameter kedua setelah nama. </font><font style="vertical-align: inherit;">Ternyata ketinggian bitmap harus kelipatan delapan untuk lebar sewenang-wenang, yang cukup dapat diterima untuk proyek ini.</font></font><br>
<br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literal biner</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda mungkin sudah memperhatikan bahwa bitmap pada contoh sebelumnya menggunakan literal biner untuk menentukan. </font><font style="vertical-align: inherit;">Ini benar-benar sangat nyaman - Anda dapat mengedit bitmap sederhana langsung dalam kode, terutama jika editor memungkinkan penyorotan. </font><font style="vertical-align: inherit;">Misalnya, definisi karakter font dalam file font.h:</font></font><br>
<br>
<img src="https://habrastorage.org/files/8f4/a54/0c9/8f4a540c9a8a42ff9315c8d4cd307d93.png"><br>
<br>
<h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Templat variadik</font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di mana kemudian tanpa mereka itu. </font><font style="vertical-align: inherit;">Nah, misalnya, perintah untuk pengontrol tampilan dapat memiliki panjang satu hingga beberapa byte. </font><font style="vertical-align: inherit;">Dikirim dengan kode berikut:</font></font><br>
<br>
<pre><code class="cpp hljs">SendCommand(Command::DISPLAY_ON);<font></font>
SendCommand(Command::SET_COM_PINS, COM_PINS | COM_PINS_ALTERNATIVE);<font></font>
SendCommand(Command::SET_COLUMN_ADDRESS, curVp.minCol, curVp.maxCol);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nyaman bukan?</font></font><br>
<pre><code class="cpp hljs">    <span class="hljs-comment">/** Queue command sending.
     * @param bytes Up to MAX_CMD_SIZE bytes of command data.
     */</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... TByte&gt;
    <span class="hljs-function"><span class="hljs-keyword">void</span>
    <span class="hljs-title">SendCommand</span><span class="hljs-params">(TByte... bytes)</span>
    </span>{<font></font>
        cmdSize = <span class="hljs-keyword">sizeof</span>...(bytes);<font></font>
        controlSent = <span class="hljs-literal">false</span>;<font></font>
        cmdInProgress = <span class="hljs-literal">true</span>;<font></font>
        SetCmdByte(<span class="hljs-keyword">sizeof</span>...(bytes) - <span class="hljs-number">1</span>, bytes...);<font></font>
        i2cBus.RequestTransfer(DISPLAY_ADDRESS, <span class="hljs-literal">true</span>,<font></font>
                               CommandTransferHandler);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... TByte&gt;
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>
    <span class="hljs-title">SetCmdByte</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx, u8 byte, TByte... bytes)</span>
    </span>{<font></font>
        cmdBuf[idx] = byte;<font></font>
        SetCmdByte(idx - <span class="hljs-number">1</span>, bytes...);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span>
    <span class="hljs-title">SetCmdByte</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, u8 byte)</span>
    </span>{<font></font>
        cmdBuf[<span class="hljs-number">0</span>] = byte;<font></font>
    }<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File variant.h menjelaskan kelas yang secara samar-samar menyerupai boost :: varian menggunakan templat variadic. Ini digunakan untuk mengatur halaman antarmuka pengguna. Intinya adalah lagi dalam menghemat memori - di mana manajemen memori dinamis adalah kemewahan yang tidak dapat diterima, Anda harus mengelak (walaupun 2K masih banyak, Anda tidak bisa mengelak, tetapi dalam garis ATMEGA yang sama ukurannya mencapai 512 byte, dan setiap byte per Akun). Di antarmuka saya, satu halaman ditampilkan di layar pada waktu tertentu. Dengan demikian, untuk semua halaman Anda dapat menggunakan memori yang sama, yang disebut penyatuan dalam C. Untuk kelas dalam C ++, ini biasanya disebut varian. Tidak seperti penyatuan, kita harus ingat untuk memanggil destruktor dari konten sebelumnya sebelum memanggil konstruktor yang baru.</font></font><br>
<br>
<pre><code class="cpp hljs">    Variant&lt;MainPage,<font></font>
            Menu,<font></font>
            LinearValueSelector,<font></font>
            TimeSelector&gt; curPage;<font></font>
    ...<font></font>
    <span class="hljs-comment">/** Get type code for the specified page class. */</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TPage</span>&gt;
    <span class="hljs-title">static</span> <span class="hljs-title">constexpr</span> <span class="hljs-title">u8</span>
    <span class="hljs-title">GetPageTypeCode</span>()
    {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">decltype</span>(curPage)::GetTypeCode&lt;TPage&gt;();<font></font>
    }<font></font>
...<font></font>
curPage.Engage(nextPageTypeCode, page);<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk kompilasi, binutils GCC dan GNU digunakan untuk platform AVR (di Ubuntu ada paket gcc-avr yang sudah jadi). </font><font style="vertical-align: inherit;">Rincian proses perakitan diberikan di atas. </font><font style="vertical-align: inherit;">Parameter untuk kompilator terlihat seperti ini (defund dan inklusi spesifik proyek dihilangkan): </font><font style="vertical-align: inherit;">
Tautan: </font><font style="vertical-align: inherit;">
Konversi bagian kode ke format hex: </font><font style="vertical-align: inherit;">
Buat gambar EEPROM: </font><font style="vertical-align: inherit;">
Firmware untuk mikrokontroler: </font><font style="vertical-align: inherit;">
PS Tomat pertama sudah matang, dan rasanya tidak enak. </font><font style="vertical-align: inherit;">Ternyata, mereka tidak menyukai sesuatu dalam makanan. </font><font style="vertical-align: inherit;">Mungkin harus mengubah budaya.</font></font><br>
<code>avr-g++ -o build/native-debug/src/firmware/cpu/lighting.cpp.o -c -fno-exceptions -fno-rtti -std=c++1y -Wall -Werror -Wextra -ggdb3 -Os -mcall-prologues -mmcu=atmega328p -fshort-wchar -fshort-enums src/firmware/cpu/lighting.cpp<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<code>avr-g++ -o build/native-debug/src/firmware/cpu/cpu -mmcu=atmega328p build/native-debug/src/firmware/cpu/adc.cpp.o build/native-debug/src/firmware/cpu/application.cpp.o …<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<code>avr-objcopy -j .text -j .data -O ihex build/native-debug/src/firmware/cpu/cpu build/native-debug/src/firmware/cpu/cpu_rom.hex<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<code>avr-objcopy -j .eeprom --change-section-lma .eeprom=0 -O ihex build/native-debug/src/firmware/cpu/cpu build/native-debug/src/firmware/cpu/cpu_eeprom.hex<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<code>avrdude -p atmega328p -c avrisp2 -P /dev/avrisp -U flash:w:build/native-debug/src/firmware/cpu/cpu_rom.hex:i<br>
</code><br>
<br><font style="vertical-align: inherit;"></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id385135/">https://habr.com/ru/post/id385135/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id385121/index.html">Surealisme Algoritma: Panduan Perdagangan Frekuensi Tinggi untuk 900 Juta Mikrodetik. Bagian 1</a></li>
<li><a href="../id385123/index.html">Station New Horizons mengirim gambar satelit kecil Pluto Styx</a></li>
<li><a href="../id385125/index.html">Reddit выбрал, какая картинка отправится на Луну в 2017 году</a></li>
<li><a href="../id385129/index.html">Sensor Penerangan Nirkabel CR2450</a></li>
<li><a href="../id385131/index.html">Tenang di malam hari, hanya jangan tidur PC: pergi diam-diam</a></li>
<li><a href="../id385137/index.html">Gerakan Membongkar Billboard Perkotaan Global</a></li>
<li><a href="../id385139/index.html">Robot Tesla Motors</a></li>
<li><a href="../id385141/index.html">Cannybots: robot untuk mengajar anak-anak cara memprogram</a></li>
<li><a href="../id385143/index.html">Bedak untuk otak atau cara membuat bedak untuk mesin pencuci piring 9,7 kali lebih murah</a></li>
<li><a href="../id385145/index.html">Pilihan pelacak tempat Anda dapat mengubah tali pengikat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>