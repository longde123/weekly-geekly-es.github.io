<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❕ 👸🏼 🧖 Inovasi JavaScript: hasil Google I / O 2019. Bagian 2 📇 ⏯️ ⛹🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kami menerbitkan bagian kedua dari terjemahan inovasi JavaScript. Di sini kita berbicara tentang pemisah angka angka, tentang angka besar, te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inovasi JavaScript: hasil Google I / O 2019. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/464131/"> Hari ini kami menerbitkan bagian kedua dari terjemahan inovasi JavaScript.  Di sini kita berbicara tentang pemisah angka angka, tentang angka besar, tentang bekerja dengan array dan objek, tentang <code>globalThis</code> , tentang penyortiran, tentang API internasionalisasi dan tentang janji. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/rm/vp/au/rmvpaup4ihud1vahnljqqw_8moo.jpeg"></a> <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian pertama</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pemisah Angka</font> </h2><br>  Nomor panjang yang ditemukan dalam program sulit dibaca.  Misalnya, <code>1000000000</code> adalah satu miliar dalam desimal.  Tetapi sekilas sulit untuk dipahami.  Oleh karena itu, jika pembaca program menemukan sesuatu yang serupa, ia harus hati-hati mempertimbangkan nol agar dapat melihatnya dengan benar. <br><br>  Dalam JavaScript modern, Anda dapat menggunakan pemisah digit angka - garis bawah ( <code>_</code> ), yang penggunaannya meningkatkan keterbacaan angka panjang.  Inilah cara angka yang ditulis menggunakan pembatas terlihat dalam kode: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> billion = <span class="hljs-number"><span class="hljs-number">1</span></span>_000_000_000; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( billion ); <span class="hljs-comment"><span class="hljs-comment">// 1000000000</span></span></code> </pre> <br>  Pemisah dapat digunakan untuk secara acak membagi angka menjadi beberapa bagian.  JavaScript, ketika berhadapan dengan angka, mengabaikan pemisah.  Mereka dapat digunakan saat menulis angka apa saja: bilangan bulat, titik apung, biner, heksadesimal, oktal. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-number"><span class="hljs-number">1</span></span>_000_000_000<span class="hljs-number"><span class="hljs-number">.11</span></span> ); <span class="hljs-comment"><span class="hljs-comment">// 1000000000.11 console.log( 1_000_000_000.1_012 ); // 1000000000.1012 console.log( 0xFF_00_FF ); // 16711935 console.log( 0b1001_0011 ); // 147 console.log( 0o11_17 ); // 591</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">→ Dukungan</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tahap 3</a> </li><li>  Chrome: 75+ </li><li>  Node: 12.5+ </li></ul><br><h2>  <font color="#3AC1EF">Tipe data Bigint</font> </h2><br>  Angka dalam JavaScript dibuat menggunakan fungsi konstruktor <code>Number</code> . <br><br>  Nilai maksimum yang dapat direpresentasikan dengan aman menggunakan tipe data <code>Number</code> adalah (2⁵³ - 1), yaitu, 9007199254740991. Anda dapat melihat nomor ini menggunakan konstruksi <code>Number.MAX_SAFE_INTEGER</code> . <br><br>  Harap perhatikan bahwa ketika literal numerik digunakan dalam kode JS, JavaScript memprosesnya, membuat objek berdasarkannya menggunakan konstruktor <code>Number</code> .  Prototipe objek ini berisi metode untuk bekerja dengan angka.  Ini terjadi dengan semua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tipe data primitif</a> . <br><br>  Apa yang akan terjadi jika kita mencoba menambahkan sesuatu ke nomor 9007199254740991? <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>.MAX_SAFE_INTEGER ); <span class="hljs-comment"><span class="hljs-comment">// 9007199254740991 console.log( Number.MAX_SAFE_INTEGER + 10 ); // 9007199254741000</span></span></code> </pre> <br>  Hasil dari penambahan <code>Number.MAX_SAFE_INTEGER</code> dan 10, output kedua <code>console.log()</code> , salah.  Hal ini disebabkan oleh fakta bahwa JS tidak dapat melakukan perhitungan dengan benar dengan angka lebih besar dari nilai <code>Number.MAX_SAFE_INTEGER</code> .  Anda dapat mengatasi masalah ini dengan menggunakan <code>bigint</code> data <code>bigint</code> . <br><br>  Jenis <code>bigint</code> memungkinkan <code>bigint</code> untuk mewakili bilangan bulat yang lebih besar dari <code>Number.MAX_SAFE_INTEGER</code> .  Bekerja dengan nilai BigInt mirip dengan bekerja dengan nilai-nilai tipe <code>Number</code> .  Secara khusus, bahasa tersebut memiliki fungsi <code>BigInt()</code> , yang dengannya Anda dapat membuat nilai yang sesuai, dan tipe data <code>bigint</code> primitif <code>bigint</code> digunakan untuk mewakili bilangan bulat besar. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> large = BigInt( <span class="hljs-number"><span class="hljs-number">9007199254740991</span></span> ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( large ); <span class="hljs-comment"><span class="hljs-comment">// 9007199254740991n console.log( typeof large ); // bigint</span></span></code> </pre> <br>  JavaScript menambahkan <code>n</code> ke akhir BigInt literals.  Bagi kami, ini berarti bahwa literal seperti itu dapat ditulis dengan menambahkan <code>n</code> pada akhir bilangan bulat. <br><br>  Sekarang kita memiliki angka BigInt yang dapat kita gunakan, kita dapat melakukan operasi matematika dengan aman pada sejumlah besar tipe <code>bigint</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> large = <span class="hljs-number"><span class="hljs-number">9007199254740991</span></span>n; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( large + <span class="hljs-number"><span class="hljs-number">10</span></span>n ); <span class="hljs-comment"><span class="hljs-comment">// 9007199254741001n</span></span></code> </pre> <br>  Sejumlah nomor jenis tidak sama dengan jumlah jenis <code>bigint</code> .  Secara khusus, kita berbicara tentang fakta bahwa angka BigInt hanya bisa bilangan bulat.  Akibatnya, ternyata Anda tidak dapat melakukan operasi aritmatika yang menggunakan jenis <code>bigint</code> dan <code>number</code> . <br><br>  Perlu dicatat bahwa fungsi <code>BigInt()</code> dapat mengambil berbagai angka: desimal, biner, heksadesimal, oktal.  Di dalam fungsi ini, mereka akan dikonversi menjadi angka, untuk representasi yang menggunakan sistem angka desimal. <br><br>  Jenis <code>bigint</code> juga mendukung pemisah bit: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> large = <span class="hljs-number"><span class="hljs-number">9</span></span>_007_199_254_741_001n; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( large ); <span class="hljs-comment"><span class="hljs-comment">// 9007199254741001n</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">→ Dukungan</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tahap 3</a> </li><li>  Chrome: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">67+</a> </li><li>  Node: 10.4+ </li><li>  Firefox: 68+ </li></ul><br><h2>  <font color="#3AC1EF">Metode Array Baru: .flat () dan .flatMap ()</font> </h2><br>  Di sini kita akan berbicara tentang metode prototipe baru untuk objek <code>Array</code> - metode <code>.flat()</code> dan <code>.flatMap()</code> . <br><br><h3>  <font color="#3AC1EF">▍ metode .at ()</font> </h3><br>  Sekarang objek tipe <code>Array</code> memiliki metode baru - <code>.flat(n)</code> .  Ini mengembalikan array baru, memungkinkan secara rekursif untuk menaikkan elemen array ke level yang ditentukan <code>n</code> .  Secara default, <code>n</code> adalah 1. Metode ini dapat memberikan <code>n</code> sama dengan <code>Infinity</code> , yang memungkinkan Anda untuk mengubah array dengan array bersarang menjadi array satu dimensi. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, [<span class="hljs-number"><span class="hljs-number">2</span></span>, [<span class="hljs-number"><span class="hljs-number">3</span></span>, [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]]]]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( nums.flat() ); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, [3, [4,5]]] console.log( nums.flat(2) ); // [1, 2, 3, [4,5]] console.log( nums.flat(Infinity) ); // [1, 2, 3, 4, 5]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">→ Dukungan</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tahap 4</a> </li><li>  Chrome: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">69+</a> </li><li>  Node: 11+ </li><li>  Firefox: 62+ </li></ul><br><h3>  <font color="#3AC1EF">▍ .flatMap () metode</font> </h3><br>  Ketika menyelesaikan tugas sehari-hari, programmer kadang-kadang mungkin perlu memproses array menggunakan metode <code>.map()</code> dengan transformasi selanjutnya menjadi struktur datar.  Misalnya, buat array yang berisi angka dan kuadrat dari angka-angka ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> squares = nums.map( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> [ n, n*n ] ) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( squares ); <span class="hljs-comment"><span class="hljs-comment">// [[1,1],[2,4],[3,9]] console.log( squares.flat() ); // [1, 1, 2, 4, 3, 9]</span></span></code> </pre> <br>  Solusi untuk masalah ini dapat disederhanakan dengan menggunakan metode <code>.flatMap()</code> .  Ia mengubah array yang dikembalikan oleh fungsi callback yang diteruskan ke sana, sama seperti mereka akan mengonversi metode <code>.flat()</code> dengan parameter <code>n</code> sama dengan 1. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> makeSquare = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> [ n, n*n ]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( nums.flatMap( makeSquare ) ); <span class="hljs-comment"><span class="hljs-comment">// [1, 1, 2, 4, 3, 9]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">→ Dukungan</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tahap 4</a> </li><li>  Chrome: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">69+</a> </li><li>  Node: 11+ </li><li>  Firefox: 62+ </li></ul><br><h3>  <font color="#3AC1EF">▍ Metode Object.fromEntries ()</font> </h3><br>  Dimungkinkan untuk mengekstraksi pasangan tipe- <code>:</code> dari suatu objek <code>:</code> dapat digunakan dengan menggunakan <code>Object</code> Method statis, yang mengembalikan sebuah array, setiap elemen di antaranya adalah array yang mengandung, sebagai elemen pertama, kunci, dan sebagai yang kedua - sebuah nilai. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">z</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> objEntries = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries( obj ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( objEntries ); <span class="hljs-comment"><span class="hljs-comment">// [["x", 1],["y", 2],["z", 3]]</span></span></code> </pre> <br>  Sekarang kita sudah punya metode statis <code>Object.fromEntries()</code> , yang memungkinkan kita untuk mengubah struktur yang sama kembali menjadi objek. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entries = [[<span class="hljs-string"><span class="hljs-string">"x"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>],[<span class="hljs-string"><span class="hljs-string">"y"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>],[<span class="hljs-string"><span class="hljs-string">"z"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.fromEntries( entries ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( obj ); <span class="hljs-comment"><span class="hljs-comment">// {x: 1, y: 2, z: 3}</span></span></code> </pre> <br>  Metode <code>entries()</code> digunakan untuk memfasilitasi penyaringan dan pemetaan data yang disimpan dalam objek.  Hasilnya adalah sebuah array.  Namun sejauh ini, tugas mengubah array menjadi objek belum memiliki solusi yang indah.  Untuk mengatasi masalah ini Anda dapat menggunakan metode <code>Object.fromEntries()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">z</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// [["x", 1],["y", 2],["z", 3]] var objEntries = Object.entries( obj ); // [["x", 1],["z", 3]] var filtered = objEntries.filter( ( [key, value] ) =&gt; value % 2 !== 0 //  ,     ); console.log( Object.fromEntries( filtered ) ); // {x: 1, z: 3}</span></span></code> </pre> <br>  Jika <code>Map</code> <code>:</code> struktur data digunakan untuk menyimpan pasangan <code>:</code> , maka data di dalamnya disimpan dalam urutan yang ditambahkan ke dalamnya.  Pada saat yang sama, bagaimana data disimpan menyerupai larik yang dikembalikan oleh metode <code>Object.entries()</code> .  Metode <code>Object.fromEntries()</code> mudah digunakan untuk mengubah struktur data <code>Map</code> menjadi objek. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>([[<span class="hljs-string"><span class="hljs-string">"x"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>],[<span class="hljs-string"><span class="hljs-string">"y"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>],[<span class="hljs-string"><span class="hljs-string">"z"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]]); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( m ); <span class="hljs-comment"><span class="hljs-comment">// {"x" =&gt; 1, "y" =&gt; 2, "z" =&gt; 3} console.log( Object.fromEntries( m ) ); // {x: 1, y: 2, z: 3}</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">→ Dukungan</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tahap 4</a> </li><li>  Chrome: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">73+</a> </li><li>  Node: 12+ </li><li>  Firefox: 63+ </li></ul><br><h3>  <font color="#3AC1EF">▍ Properti global global</font> </h3><br>  Kami terbiasa dengan <code>this</code> digunakan dalam JavaScript.  Itu tidak memiliki nilai tetap.  Sebaliknya, makna <code>this</code> tergantung pada konteks di mana ia diakses.  Di lingkungan apa pun, <code>this</code> menunjuk ke objek global saat diakses dari konteks level tertinggi.  Inilah makna global dari <code>this</code> . <br><br>  Dalam JavaScript berbasis browser, misalnya, nilai global untuk <code>this</code> adalah objek <code>window</code> .  Anda dapat memverifikasi ini dengan menggunakan <code>console.log(this)</code> di tingkat atas file JavaScript (dalam konteks paling eksternal) atau di konsol JS browser. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46b/8a9/28d/46b8a928d5d89a7777f2ab38cdd9b3d3.png"></div><br>  <i><font color="#999999">Mengakses ini di konsol browser</font></i> <br><br>  Nilai global <code>this</code> di Node.js menunjuk ke objek <code>global</code> .  Di dalam pekerja web, itu menunjuk pada pekerja itu sendiri.  Namun, mendapatkan nilai global <code>this</code> bukanlah tugas yang mudah.  Faktanya adalah bahwa Anda tidak dapat merujuk <code>this</code> mana pun.  Misalnya, jika Anda mencoba melakukan ini di konstruktor kelas, ternyata <code>this</code> menunjuk ke turunan dari kelas yang sesuai. <br><br>  Di beberapa lingkungan, <code>this</code> <code>self</code> dapat digunakan untuk mengakses nilai global <code>this</code> .  Kata kunci ini memainkan peran yang sama dengan mekanisme untuk mengakses nilai ini di browser, di Node.js, dan di pekerja web.  Menggunakan pengetahuan tentang bagaimana nilai global <code>this</code> disebut di lingkungan yang berbeda, Anda dapat membuat fungsi yang mengembalikan nilai ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getGlobalThis = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> self !== <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">window</span></span> !== <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> global !== <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> global; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> !== <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Unable to locate global `this`'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> globalThis = getGlobalThis();</code> </pre> <br>  Sebelum kita adalah polyfill primitif untuk mendapatkan objek global <code>this</code> .  Baca lebih lanjut tentang ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  JavaScript sekarang memiliki kata kunci <code>globalThis</code> .  Ini memberikan cara universal untuk mengakses nilai global <code>this</code> untuk lingkungan yang berbeda dan tidak bergantung pada lokasi program dari mana ia diakses. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">fn</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">'this'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> === obj ); <span class="hljs-comment"><span class="hljs-comment">// true  console.log( 'globalThis', globalThis === window ); // true } }; obj.fn();</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">→ Dukungan</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tahap 3</a> </li><li>  Chrome: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">71+</a> </li><li>  Node: 12+ </li><li>  Firefox: 65+ </li></ul><br><h2>  <font color="#3AC1EF">Penyortiran stabil</font> </h2><br>  Standar ECMAScript tidak menawarkan algoritma penyortiran array spesifik yang harus diimplementasikan mesin JavaScript.  Itu hanya menjelaskan API yang digunakan untuk menyortir.  Akibatnya, dengan menggunakan mesin JS yang berbeda, orang dapat menemukan perbedaan dalam kinerja operasi penyortiran dan dalam stabilitas (stabilitas) dari algoritma penyortiran. <br><br>  Sekarang standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengharuskan</a> array penyortiran menjadi stabil.  Detail tentang stabilitas penyortiran dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Inti dari karakteristik algoritma pengurutan ini adalah sebagai berikut.  Algoritma stabil jika hasil pengurutan, yang merupakan array yang dimodifikasi, berisi elemen dengan nilai yang sama yang tidak terpengaruh oleh pengurutan dalam urutan yang sama di mana mereka ditempatkan dalam array asli.  Pertimbangkan sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = [  { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Anna'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">21</span></span> },  { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Barbra'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">25</span></span> },  { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Zoe'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">18</span></span> },  { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Natasha'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">25</span></span> } ]; <span class="hljs-comment"><span class="hljs-comment">//      age [  { name: 'Natasha', age: 25 }  { name: 'Barbra', age: 25 },  { name: 'Anna', age: 21 },  { name: 'Zoe', age: 18 }, ]</span></span></code> </pre> <br>  Di sini, array <code>list</code> berisi objek diurutkan berdasarkan bidang <code>age</code> objek-objek ini.  Dalam array <code>list</code> , objek dengan properti <code>name</code> sama dengan <code>Barbra</code> terletak di depan objek dengan properti <code>name</code> sama dengan <code>Natasha</code> .  Karena nilai <code>age</code> dari objek-objek ini sama, kita dapat berharap bahwa dalam array yang diurutkan elemen-elemen ini akan mempertahankan urutan pengaturan sebelumnya relatif satu sama lain.  Namun, dalam praktiknya hal ini tidak dapat diharapkan.  Bagaimana tepatnya susunan yang disortir akan dibentuk bergantung sepenuhnya pada mesin JS yang digunakan. <br><br>  Sekarang semua browser modern dan Node.js menggunakan algoritma penyortiran yang stabil, dipanggil saat mengakses metode array <code>.sort()</code> .  Ini memungkinkan Anda untuk selalu, untuk data yang sama, mendapatkan hasil yang sama: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    [  { name: 'Barbra', age: 25 },  { name: 'Natasha', age: 25 }  { name: 'Anna', age: 21 },  { name: 'Zoe', age: 18 }, ]</span></span></code> </pre> <br>  Di masa lalu, beberapa mesin JS mendukung penyortiran stabil, tetapi hanya untuk array kecil.  Untuk meningkatkan kinerja saat memproses array besar, mereka dapat menggunakan algoritma lebih cepat dan mengorbankan stabilitas semacam. <br><br><h3>  <font color="#3AC1EF">→ Dukungan</font> </h3><br><ul><li>  Chrome: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">70+</a> </li><li>  Node: 12+ </li><li>  Firefox: 62+ </li></ul><br><h2>  <font color="#3AC1EF">API Internasionalisasi</font> </h2><br>  API internasionalisasi dimaksudkan untuk mengatur perbandingan string, untuk memformat angka, tanggal dan waktu, seperti biasa dalam berbagai standar regional (lokal).  Akses ke API ini diatur melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">objek</a> <code>Intl</code> .  Objek ini menyediakan konstruktor untuk membuat objek penyortir dan objek yang memformat data.  Daftar lokal yang didukung oleh objek <code>Intl</code> dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h3>  <font color="#3AC1EF">▍Intl.RelativeTimeFormat ()</font> </h3><br>  Dalam banyak aplikasi, seringkali perlu untuk menghasilkan waktu dalam format relatif.  Mungkin terlihat seperti "5 menit yang lalu," "kemarin," "1 menit yang lalu," dan seterusnya.  Jika materi situs web diterjemahkan ke dalam bahasa yang berbeda, Anda harus menyertakan semua kemungkinan kombinasi konstruksi relatif yang menggambarkan waktu dalam perakitan situs. <br><br>  JS sekarang memiliki <code>Intl.RelativeTimeFormat(locale, config)</code> , yang memungkinkan Anda membuat sistem pemformatan tanggal dan waktu untuk lokal yang berbeda.  Secara khusus, kita berbicara tentang objek yang memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode</a> <code>.format(value, unit)</code> , yang memungkinkan Anda untuk menghasilkan berbagai cap waktu relatif.  Ini terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// español ( ) var rtfEspanol= new Intl.RelativeTimeFormat('es', {  numeric: 'auto' }); console.log( rtfEspanol.format( 5, 'day' ) ); // dentro de 5 días console.log( rtfEspanol.format( -5, 'day' ) ); // hace 5 días console.log( rtfEspanol.format( 15, 'minute' ) ); // dentro de 15 minutos</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">→ Dukungan</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tahap 3</a> </li><li>  Chrome: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">71+</a> </li><li>  Node: 12+ </li><li>  Firefox: 65+ </li></ul><br><h3>  <font color="#3AC1EF">▍Intl.ListFormat ()</font> </h3><br>  Konstruktor <code>Intl.ListFormat</code> memungkinkan <code>Intl.ListFormat</code> untuk menggabungkan item daftar menggunakan kata-kata <code>and</code> ( <code></code> ) dan <code>or</code> ( <code></code> ).  Saat membuat objek yang sesuai, konstruktor dilewatkan lokal dan objek dengan parameter.  Parameter <code>type</code> dapat berupa <code>conjunction</code> , <code>disjunction</code> dan <code>unit</code> .  Sebagai contoh, jika kita ingin menggabungkan elemen <code> [apples, mangoes, bananas]</code> menggunakan objek konjungsi, kita mendapatkan string dari bentuk <code>apples, mangoes and bananas</code> .  Jika kita menggunakan objek disjungsi, kita mendapatkan string berupa <code>apples, mangoes or bananas</code> . <br><br>  Objek yang dibuat oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konstruktor</a> <code>Intl.ListFormat</code> memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode</a> <code>.format(list)</code> yang menggabungkan daftar.  Pertimbangkan sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// español ( ) var lfEspanol = new Intl.ListFormat('es', {  type: 'disjunction' }); var list = [ 'manzanas', 'mangos', 'plátanos' ]; console.log( lfEspanol.format( list ) ); // manzanas, mangos o plátanos</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">→ Dukungan</font> </h3><br><ul><li>  TC39 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">: Tahap 3</a> </li><li>  Chrome: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">72+</a> </li><li>  Node: 12+ </li></ul><br><h3>  <font color="#3AC1EF">▍Intl.Locale ()</font> </h3><br>  Konsep "standar regional" biasanya lebih dari sekadar nama bahasa.  Ini mungkin termasuk jenis kalender, informasi tentang siklus waktu yang digunakan, dan nama-nama bahasa.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konstruktor</a> <code>Intl.Locale(localeId, config)</code> digunakan untuk membuat string <code>Intl.Locale(localeId, config)</code> diformat berdasarkan objek <code>config</code> diteruskan ke sana. <br><br>  Objek yang dibuat menggunakan <code>Intl.Locale</code> berisi semua pengaturan regional yang ditentukan.  Metode <code>.toString()</code> menghasilkan string standar regional yang diformat. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> krLocale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Intl</span></span>.Locale( <span class="hljs-string"><span class="hljs-string">'ko'</span></span>, {  <span class="hljs-attr"><span class="hljs-attr">script</span></span>: <span class="hljs-string"><span class="hljs-string">'Kore'</span></span>, <span class="hljs-attr"><span class="hljs-attr">region</span></span>: <span class="hljs-string"><span class="hljs-string">'KR'</span></span>,  <span class="hljs-attr"><span class="hljs-attr">hourCycle</span></span>: <span class="hljs-string"><span class="hljs-string">'h12'</span></span>, <span class="hljs-attr"><span class="hljs-attr">calendar</span></span>: <span class="hljs-string"><span class="hljs-string">'gregory'</span></span> } ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( krLocale.baseName ); <span class="hljs-comment"><span class="hljs-comment">// ko-Kore-KR console.log( krLocale.toString() ); // ko-Kore-KR-u-ca-gregory-hc-h12</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat membaca tentang pengidentifikasi dan tag lokal di Unicode. <br><br><h3>  <font color="#3AC1EF">→ Dukungan</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tahap 3</a> </li><li>  Chrome: 74+ </li><li>  Node: 12+ </li></ul><br><h2>  <font color="#3AC1EF">Janji</font> </h2><br>  Sampai sekarang, JS memiliki metode statis <code>Promise.all()</code> dan <code>Promise.race()</code> .  Metode <code>Promise.all([...promises])</code> mengembalikan janji yang berhasil diselesaikan setelah semua janji yang diteruskan ke metode sebagai argumen diselesaikan.  Janji ini ditolak dalam hal bahwa setidaknya satu dari janji yang ditransfer ke dalamnya ditolak.  Metode <code>Promise.race([...promises])</code> mengembalikan janji, yang diselesaikan setelah salah satu janji yang ditransfer ke itu diselesaikan, dan ditolak jika setidaknya salah satu dari janji tersebut ditolak. <br><br>  Komunitas pengembang JS sangat membutuhkan metode statis, janji yang dikembalikan yang akan diselesaikan setelah semua janji yang diberikan kepadanya akan lengkap (diizinkan atau ditolak).  Selain itu, kami membutuhkan metode yang mirip dengan <code>race()</code> , yang akan mengembalikan janji yang menunggu resolusi dari salah satu janji yang diberikan kepadanya. <br><br><h3>  <font color="#3AC1EF">▍ Metode Promise.allSettled ()</font> </h3><br>  Metode <code>Promise.allSettled()</code> menerima berbagai janji.  Janji yang dikembalikan olehnya diizinkan setelah semua janji ditolak atau diizinkan.  Hasilnya adalah bahwa janji yang dikembalikan dengan metode ini tidak memerlukan <code>catch</code> . <br><br>  Faktanya adalah bahwa janji ini selalu berhasil diselesaikan.  Blok <code>then</code> menerima <code>status</code> dan <code>value</code> dari setiap janji dalam urutan yang muncul. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p1 = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(  <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> setTimeout( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve( <span class="hljs-string"><span class="hljs-string">'val1'</span></span> ), <span class="hljs-number"><span class="hljs-number">2000</span></span> ) ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p2 = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(  <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> setTimeout( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve( <span class="hljs-string"><span class="hljs-string">'val2'</span></span> ), <span class="hljs-number"><span class="hljs-number">2000</span></span> ) ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p3 = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(  <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> setTimeout( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> reject( <span class="hljs-string"><span class="hljs-string">'err3'</span></span> ), <span class="hljs-number"><span class="hljs-number">2000</span></span> ) ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.allSettled( [p1(), p2(), p3()] ).then(  <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> values </span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( values ) ); <span class="hljs-comment"><span class="hljs-comment">//  [ {status: "fulfilled", value: "val1"}  {status: "fulfilled", value: "val2"}  {status: "rejected", value: "err3"} ]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">→ Dukungan</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tahap 3</a> </li><li>  Chrome: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">76+</a> </li></ul><br><h3>  <font color="#3AC1EF">▍ Method Promise.any ()</font> </h3><br>  Metode <code>Promise.any()</code> mirip dengan <code>Promise.race()</code> , tetapi janji yang dikembalikan olehnya tidak mengeksekusi <code>catch</code> ketika salah satu janji yang diteruskan ke metode ini ditolak. <br><br>  Sebaliknya, ia menunggu resolusi dari semua janji.  Jika tidak ada janji yang diizinkan, maka <code>catch</code> block akan dieksekusi.  Jika salah satu janji berhasil diselesaikan, <code>then</code> akan dieksekusi. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Pada artikel ini, kami melihat beberapa inovasi JavaScript yang dibahas pada konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google I / O 2019</a> .  Kami harap Anda menemukan sesuatu di antara mereka yang berguna bagi Anda. <br><br>  <b>Pembaca yang budiman!</b>  Apa yang terutama Anda lewatkan dalam JavaScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464131/">https://habr.com/ru/post/id464131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464119/index.html">Frontend Weekly Digest (12 - 18 Agustus 2019)</a></li>
<li><a href="../id464121/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 376 (12 - 18 Agustus 2019)</a></li>
<li><a href="../id464125/index.html">Kisah internet rahasia dalam kebijakan privasi Google 4.000 kata</a></li>
<li><a href="../id464127/index.html">Pengembangan favicon animasi</a></li>
<li><a href="../id464129/index.html">Inovasi JavaScript: hasil Google I / O 2019. Bagian 1</a></li>
<li><a href="../id464133/index.html">Performa bukan hanya tentang CPU: membuat profiler Anda sendiri untuk Python</a></li>
<li><a href="../id464137/index.html">Dukungan teknis Miran: cara kerjanya</a></li>
<li><a href="../id464141/index.html">Fantasi tentang masalah metaclasses di C #</a></li>
<li><a href="../id464143/index.html">Obat kanker pribadi. Bagaimana Gen Pasien Mempengaruhi Keberhasilan Perawatan</a></li>
<li><a href="../id464145/index.html">CMake: Kasus ketika Kualitas Proyek tidak dapat dimaafkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>