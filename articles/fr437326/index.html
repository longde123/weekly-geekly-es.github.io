<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüî¨ üì¨ ‚õìÔ∏è Sur la question de la multiplication, de l'extraction des racines carr√©es, de la substitution des importations et de l'entreprise Milander ‚ñ∂Ô∏è üñ•Ô∏è ü§ñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬´L'entropie, une source ergodique, un espace de message multidimensionnel, des bits, la polys√©mie, le processus de Markov - tous ces mots semblent tr√®...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sur la question de la multiplication, de l'extraction des racines carr√©es, de la substitution des importations et de l'entreprise Milander</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437326/"><h4>  ¬´L'entropie, une source ergodique, un espace de message multidimensionnel, des bits, la polys√©mie, le processus de Markov - tous ces mots semblent tr√®s impressionnants, quel que soit l'ordre dans lequel ils sont plac√©s.  Si vous les arrangez dans le bon ordre, ils acqui√®rent un certain contenu th√©orique.  Et un vrai sp√©cialiste peut parfois trouver une solution aux probl√®mes pratiques quotidiens avec son aide. ¬ª <br><br>  John PIRS "Je ne vois aucun mal" <br></h4><br>  Ce poste est plein de discussions sur l'optimisation subtile des op√©rations math√©matiques sur MK avec des ressources limit√©es, ainsi que des √©valuations subjectives de divers aspects du d√©veloppement de logiciels embarqu√©s. <br><br>  Ceux que cet avertissement n'a pas effray√©s, je demande sous cat. <br><a name="habracut"></a><br>  Avant de d√©crire la proc√©dure d'extraction d'une racine carr√©e d'un entier, l'op√©ration inverse de la mise au carr√© et, en cons√©quence, la multiplication, parlons de cette derni√®re. <br><br>  Supposons que nous ayons la possibilit√© de multiplier un nombre 8 bits par un nombre 8 bits, obtenant un r√©sultat 16 bits (8 * 8 = 16), comment pouvons-nous obtenir la mise en ≈ìuvre de l'op√©ration 16 * 16 = 32 bas√©e sur cette op√©ration.  La fa√ßon √©vidente est de repr√©senter 16 comme la somme de deux 8, alors nous obtenons <br><br> <code>(16)*(16)=(1(8)*256+2(8))*1(8)*256+2(8)) =1*1*256*256+1*2*256+2*1*256+2*2</code> <br> <br>  Si dans l'expression r√©sultante nous rempla√ßons la multiplication par 256 par un d√©calage √† gauche de 8 chiffres, alors nous obtenons un algorithme compl√®tement fonctionnel.  Estimons le temps pass√© sur la mise en ≈ìuvre - nous avons besoin de 4 multiplications de 8 * 8 = 16 et de 4 additions de nombres √† 4 octets 32 + 32 = 32.  Pour l'AVR de type MK, nous obtenons 4 * 2 + 4 * 4 = 24 cycles, mais c'est pour une solution ¬´frontale¬ª.  Essayons d'am√©liorer le r√©sultat.  Le fait que nous ayons besoin non pas de 4, mais de 3 ajouts et d'une affectation simplifie quelque peu la situation, car la remise √† z√©ro initiale du r√©sultat n'est pas requise, mais nous n'en avons toujours pas tenu compte, bien que cela ait √©t√© n√©cessaire et que le temps total devrait √™tre de 24 + 4 = 28 cycles.  Mais, si nous prenons en compte la pr√©sence d'un d√©calage dans les trois premiers termes (respectivement, nous avons que le bas (deux octets bas) est nul et il est inutile de l'ajouter au r√©sultat), alors nous devrons ajouter non pas 4 octets, mais trois et deux, ce qui r√©duira temps d'ex√©cution pour 1 * 2 + 2 = 4 mesures et obtenez 20 mesures.  De plus, nous pouvons faire attention au fait que les premier et dernier termes ne se croisent pas du tout, ce qui nous permet de remplacer la mise √† z√©ro de la moiti√© sup√©rieure du r√©sultat par l'attribution du premier terme et de r√©duire le temps d'ex√©cution de 2 cycles d'horloge √† 18. De plus, en utilisant les fonctionnalit√©s d'architecture, √† savoir la pr√©sence du transfert de registre paires, enregistrez deux mesures suppl√©mentaires et le r√©sultat final - 16 mesures au lieu des 28 originales - une bagatelle, mais agr√©able. <br><br>  Des m√©thodes d'optimisation similaires fonctionnent pour l'op√©ration 32 * 32 = 32, pour laquelle vous pouvez r√©duire le temps d'ex√©cution des 4 * 4 * (2 + 4) + 4 = 100 cycles d'horloge attendus √† (3 + 5 + 4 + 3) + (5 + 3 +3) + (4 + 3) + 3 = 36 mesures, ce qui n'est pas mal du tout.  Eh bien, √† la fin de l'examen de diverses options de multiplication, nous notons que 16 * 16 = 16 peuvent √™tre obtenus en 3 + 3 + 3 = 9 cycles.  Notez que toutes ces consid√©rations ne sont valables que sous l'hypoth√®se qu'il existe une op√©ration 8 * 8 = 16 pour 2 mesures, et si elle n'est pas sur le MK cible, le temps d'ex√©cution de toutes les autres versions de l'op√©ration ne deviendra certainement pas plus rapide. <br><br>  R√©sumons le temps n√©cessaire pour effectuer la multiplication (8 * 8 = 8 2, 8 * 8 = 16 9, 16 * 16 = 16 16, 16 * 16 = 32 36) et consid√©rons maintenant le probl√®me d'origine. <br><br>  Nous devons extraire la racine enti√®re carr√©e du nombre 32 bits H, c'est-√†-dire trouver le plus grand nombre 16 bits n tel que n * n &lt;= H.  Nous tous du lyc√©e connaissons la m√©thode d'approximation successive de la racine carr√©e (n = (N / n '+ n) / 2), mais lors de son utilisation, nous devrons diviser les nombres entiers, ce qui prend beaucoup de temps. <br><br>  Par cons√©quent, d'autres sch√©mas de calcul ont √©t√© d√©velopp√©s, dont l'un est la m√©thode d'approximation au niveau du bit, qui dans le pseudo-code ressemble √† ceci: <br><br><ul><li>  valeurs initiales -&gt; n = 0;  b = 0x8000; </li><li>  effectuer 16 fois -&gt; si ((n + b) * (n + b)&gt; = H) n = n + b;  b = b &gt;&gt; 1; </li></ul><br>  Vous pouvez imm√©diatement estimer le temps pass√© sur cette option 16 (le nombre de bits du r√©sultat) * (2 (organisation du cycle) +2 (addition) + X (multiplication) +5 (comparaison et solution) +2 (modification du r√©sultat) / 2 (moyenne mi-temps) +2 (d√©calage de bits)) = 16 * (12 + X).  Vous demandez pourquoi dans la formule X au lieu du nombre 16, et il s'av√®re qu'une embuscade nous attendait, puisque nous √©crivons en C, et non en assembleur.  Le fait est que dans la biblioth√®que standard, il n'y a pas d'op√©ration de multiplication avec un changement de profondeur de bits et nous ne pouvons pas appliquer 16 * 16 = 32, mais nous sommes oblig√©s d'utiliser 32 * 32 = 32, ce qui conduit √† X = 36 au lieu de X = 16 et le chiffre final est 16 * 48 = 768 cycles d'horloge pour extraire la valeur enti√®re de la racine carr√©e d'un nombre 32 bits. <br><br>  Bien s√ªr, c'est beaucoup mieux que la m√©thode Newton, mais un peu beaucoup, voyons ce qui peut √™tre fait. <br>  Il est donc √©vident que la plupart du temps est consacr√© au calcul du r√©sultat de multiplication suivant.  Bien s√ªr, vous pouvez le r√©√©crire dans l'assembleur et utiliser la version moins ch√®re de la multiplication, obtenant 16 * (12 + 16) = 448 ticks, mais nous laisserons cette m√©thode en dernier recours.  Consid√©rez le processus plus attentivement et voyez que nous ne calculons pas la multiplication d'un nombre al√©atoire par lui-m√™me, mais plut√¥t la multiplication de la valeur pr√©c√©dente avec une certaine augmentation, et le carr√© de la valeur pr√©c√©dente est connu.  Par cons√©quent, nous pouvons recourir √† un sch√©ma de diff√©rence bas√© sur la formule (n + b) * (n + b) = n * n + 2 * n * b + b * b.  √Ä premi√®re vue, cela ressemble √† une moquerie - au lieu d'une multiplication, nous devons faire quatre pi√®ces et m√™me deux ajouts de nombres longs (32 bits).  Mais commen√ßons √† comprendre: nous avons d√©j√† n * n, b * b en tenant compte du fait que b = b '/ 2 est facile √† obtenir, comme b' * b '/ 4, et de m√™me 2 * n * b = 2 * n * b '/ 2. <br><br>  Le sch√©ma de calcul suivant √©merge: <br><br><ol><li>  valeurs initiales -&gt; nn = 0;  n = 0;  b = 0x8000;  bb = b * b; </li><li>  r√©p√©ter 16 fois -&gt; if (nn + n + bb&gt; = H) {n = n + b;  nn = nn + bb + n};  bb &gt;&gt; 2;  b&gt; 1; </li></ol><br>  Nous estimons les co√ªts de mise en ≈ìuvre 16 * (2 (organisation du cycle) +12 (affectation et deux ajouts) +5 (comparaison et solution) + (2 (ajout) +8 (deux ajouts)) / 2 (moyenne mi-temps) +8 (d√©calage √† droite de 2) +2 (d√©calage √† droite) = 16 * 34 = 544 cycles d'horloge. Mieux qu'avec une multiplication incorrecte de 32 * 32, mais nous avons encore des r√©serves. <br><br>  Quels sont-ils - pr√™tons attention √† l'op√©ration la plus co√ªteuse - ajoutant et comparant un total de 17 cycles d'horloge et refait la boucle principale de l'algorithme: <br>  2. r√©p√©ter 16 fois -&gt; T = H-bb-n;  si (T&gt; = 0) {H = T;  n = n + b);};  bb &gt;&gt; 2;  b&gt; 1; <br>  Le temps d'ex√©cution du cycle sera alors de 16 * (2 (organisation du cycle) +12 (calcul de la nouvelle diff√©rence) +1 (comparaison et solution) + ((4 (affectation) +2 (ajout)) / 2 (demi-temps moyen) +8 +2) = 16 * 28 = 448 cycles, si vous prenez en compte les particularit√©s de l'architecture, vous pouvez enregistrer encore 2 + 2 = 4 * 16 = 64 cycles et rester dans moins de 400 cycles. <br><br>  Nous obtenons m√™me un r√©sultat l√©g√®rement meilleur, comme lors de l'utilisation de la multiplication correcte 16 * 16 = 32, mais sans assembleur, "en C pur".  Cependant, il y a un inconv√©nient important - si tout est intuitif dans la version avec multiplication, alors la variante avec un sch√©ma de diff√©rence sans commentaires donne l'impression d'une session de magie noire, vous devriez choisir.  Notez √©galement que nous avons √©chang√© le nombre de mesures contre de la m√©moire suppl√©mentaire pour des variables interm√©diaires, ce qui se produit g√©n√©ralement. <br><br>  Remarque n√©cessaire - nous n'avons pas obtenu un gain significatif (parfois) par rapport aux multiplications, car nous avons une impl√©mentation rapide de 8 * 8 = 16.  S'il est absent dans le MK (et cela se produit) ou pas si rapide (et cela se produit √©galement), le sch√©ma de diff√©rence devient plusieurs fois plus rapide, car il n'utilise que des op√©rations d'ajout et de d√©calage standard, qui sont garanties d'√™tre dans n'importe quel MK. <br><br>  Il semblait que cela ne fonctionnerait pas mieux, mais il s'av√®re qu'il existe encore des r√©serves pour augmenter les performances de l'algorithme.  Essayons d'utiliser une autre m√©thode classique d'acc√©l√©ration - diviser pour mieux r√©gner.  Et si vous extrayez d'abord la racine carr√©e de la moiti√© la plus ancienne de l'argument, puis l'affinez?  Tout d'abord, nous montrons que cela est fondamentalement possible.  En effet, nous pr√©sentons l'argument sous la forme H = H '&lt;&lt; 16 + H' 'et le r√©sultat sous la forme n = n' &lt;&lt; 8 + n ''.  Puisque n '' &lt;256, alors son carr√© sera √©videmment inf√©rieur au carr√© du nombre n = n '&lt;&lt; 8 + 256 = (n' + 1) &lt;&lt; 8.  Il s'ensuit que la partie la plus √©lev√©e du r√©sultat ne d√©passe pas la racine carr√©e de la partie la plus √©lev√©e de l'argument. <br><br>  La mise en ≈ìuvre de cette approche est laiss√©e au lecteur curieux. <br>  Que nous apportera cette approche, car le nombre total d'it√©rations restera inchang√© - nous pouvons effectuer la premi√®re moiti√© d'it√©rations avec des nombres de longueur plus courte, ce qui entra√Æne une diminution des co√ªts de temps.  Cette approche peut √™tre appliqu√©e √† la variante avec multiplication et √† la variante de diff√©rence, le gain total sera jusqu'√† un quart du temps d'ex√©cution total. <br><br>  Remarque n√©cessaire - l'applicabilit√© de cette approche n'est pas du tout √©vidente, lors de la mise en ≈ìuvre pour MK tels que AVR, l'acc√©l√©ration de l'ex√©cution a lieu, mais pour certaines architectures, par exemple pour x86, le ralentissement des op√©rations est apparu de mani√®re inattendue.  Apparemment, travailler avec des donn√©es non natives (16 bits) dans cette architecture co√ªte beaucoup plus cher en temps qu'avec les natives (32 bits).  Je n'ai pas men√© une √©tude approfondie, mais le fait s'est produit et je devrais le signaler afin d'√©viter tout malentendu. <br><br>  Mais ce n'est pas tout.  Puisque nous nous sommes d√©j√† engag√©s sur la voie de la s√©paration et de la domination, alors pourquoi ne pas aller plus loin - extraire la racine des bits pas √† pas, en commen√ßant par les plus anciens (commencer par les plus jeunes est contre-productif dans notre cas).  Le sch√©ma d'algorithme est le m√™me - nous ajoutons la portion suivante de bits dans le r√©sultat actuel et essayons d'ajouter le bit suivant au r√©sultat, en v√©rifiant si nous avons d√©pass√© la valeur racine.  La particularit√© est que nous ne pouvons v√©rifier que les bits hauts de l'argument, jusqu'√† ce que nous arrivions aux bits bas. <br><br>  Lors de l'impl√©mentation, nous utilisons une astuce de plus - au lieu de d√©placer nos nombres soustraits vers la droite, nous d√©placerons notre argument d√©cr√©ment√© vers la gauche, la signification ne change pas et la vitesse augmente.  Il augmente en raison de deux facteurs - 1) il nous suffit de soustraire uniquement des nombres √† 16 bits (il y a une particularit√©, et il faut en tenir compte, mais nous envisageons une √©tude de cas, vout) et 2) nous n'avons pas besoin de d√©placer le carr√© du bit suivant, car il sera toujours √©gal √† un.  Mais vous devez payer pour tout dans ce monde et nous aurons un d√©calage de la diff√©rence √©tendue (6 octets) vers la gauche, et de 2 bits par horloge.  Voir pseudo code <br><br><ol><li>  valeurs initiales -&gt; n = 0;  H1 = 0; </li><li>  r√©p√©ter 16 fois -&gt; (H1, H) &lt;&lt; 2;  T = H1-n-1;  si (T&gt; 0) {H1 = T;  n = n + 2};  n &lt;&lt; 1; </li></ol><br>  et √©valuer le temps d'ex√©cution, obtenant 16 * (12 (d√©calage √©tendu) +4 (calcul de la diff√©rence) +1 (solution) +2 (affectation) +1 (augmentation) +2 (d√©calage)) = 16 * 22 = 352 mesures, peut-√™tre , le r√©sultat est presque parfait.  Lors de la mise en ≈ìuvre de cette option, il y a de petits pi√®ges, je laisse √† nouveau le lecteur curieux (enfin, il obtient le travail). <br><br>  Eh bien, en conclusion de la section qui m'a incit√© √† √©crire ce post.  Il y a une biblioth√®que McuCpp absolument magnifique, r√©dig√©e par Anton Chizhov, dans laquelle, bas√© sur la classe d'auteur Loki, Andriescu est inhabituellement √©l√©gant (enfin, dans la mesure o√π l'√©l√©gance peut √™tre appliqu√©e aux mod√®les C ++), travaillez avec des √©pingles &lt;a ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/KonstantinChizhov/ Mcucpp</a> ¬ªJ'ai beaucoup de respect pour l'auteur mentionn√© (tous les deux) et r√©cemment, en relation avec les circonstances, dont je parlerai plus tard, j'ai regard√© les sources de cette biblioth√®que et j'ai encore une fois admir√©. <br><br>  Cependant, parmi d'autres fichiers, j'ai vu template_utils.h, dans lequel certaines routines auxiliaires ont √©t√© impl√©ment√©es, et parmi elles une racine enti√®re d'un nombre 32 bits.  Le fait qu'il utilise l'algorithme d'approximation s√©quentielle le plus simple avec multiplication n'est pas effrayant, car cet algorithme ne perd pas beaucoup de vitesse, mais en termes de compr√©hensibilit√©, il donne beaucoup de points devant et gagne toujours.  Mais je n'aimais pas vraiment le fait qu'il ait √©t√© mis en ≈ìuvre de mani√®re quelque peu inexacte (en termes de performances), car "les enfants peuvent le voir".  L'inexactitude consiste √† repr√©senter le nombre s√©lectionn√© avec 32 bits, car nous savons fermement que la racine du nombre 32 bits ne d√©passera pas 16 bits, alors pourquoi devons-nous d√©caler z√©ro octet.  Et c'est exactement le cas lorsque le compilateur lui-m√™me ne devinera jamais d'effectuer une optimisation et devrait l'aider. <br><br>  Conversion de fonction √©vidente <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> add = <span class="hljs-number"><span class="hljs-number">0x8000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> i = <span class="hljs-number"><span class="hljs-number">16</span></span>; i !=<span class="hljs-number"><span class="hljs-number">0</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> rootGuess = result | add; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> guess = rootGuess * rootGuess; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= guess) { result = rootGuess; } add &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  nous permet d'√©conomiser 2 cycles sur un d√©calage de bit et 2 cycles sur la cr√©ation du facteur suivant √† chaque cycle, et l'organisation du cycle sous la forme indiqu√©e est encore 4 cycles (je sais que le compilateur peut faire une telle optimisation pour nous, mais pourquoi ne pas l'aider explicitement ), ce qui est assez bon pour les modifications de code purement cosm√©tiques qui n'affectent en rien sa compr√©hensibilit√©. <br><br>  Note ult√©rieure - un commentaire m'a fait penser que ce serait plus correct <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint_fast8_t</span></span> i= ...)</code> </pre> <br>  Merci Oleg pour l'aide. <br><br>  La cerise sur le g√¢teau est la fonction d'extraction de la racine carr√©e enti√®re du num√©ro de signe situ√© juste en dessous, qui pr√©tend que ‚àö-1 = 65635 = -1. D'un autre c√¥t√©, pourquoi pas, ce qui est pire que tout autre r√©sultat, nous n'avons pas d'exception cause dans MK, et la racine carr√©e enti√®re d'un nombre n√©gatif n'existe pas. <br><br>  Eh bien, la conclusion sur la raison pour laquelle je me suis tourn√© vers la biblioth√®que d'Anton Chizhov.  J'ai √©t√© invit√© par un post r√©cent concernant le RTOS domestique pour MK sous le nom MAX (MultiAgent Coherent System) - voir l'√©pigraphe du post annonc√© par ses cr√©ateurs et port√© sur le MK fabriqu√© par Milander.  Remarque - ce message n'est en aucun cas du mat√©riel promotionnel et il deviendra bient√¥t clair pour les lecteurs.  Des auteurs mcucpp susmentionn√©s de l'OS ont utilis√© la mise en ≈ìuvre d'un tampon en anneau (sans diminuer du tout les avantages de la biblioth√®que Anton, je dois dire que cette partie n'est pas une r√©f√©rence, et c'est toujours une formulation douce, dont j'ai √©crit dans un autre post que je ne publierai pas du tout).  Comme je travaille en √©troite collaboration avec les installations de production de Milander, le mat√©riel m'a int√©ress√© et j'ai suivi le lien vers le site Web des d√©veloppeurs. <br><br>  Ici commence le prochain cri de Yaroslavna. <br><br>  L'ann√©e derni√®re, lorsque la cr√©ation du RTOS national a √©t√© annonc√©e pour la premi√®re fois, j'ai t√©l√©charg√© une description du produit logiciel √† partir de ce site, mais d'une mani√®re ou d'une autre mes mains n'ont pas atteint l'√©tude.  De par la nature de mon activit√©, je dois g√©rer des composants domestiques (je comprends assez ...), donc ce serait bien d'avoir le logiciel appropri√©.  Rappelant comment, dans la version de l'ann√©e derni√®re, le directeur de la soci√©t√© a parl√© des millions de roubles d√©pens√©s pour le d√©veloppement et de la grande √©quipe travaillant √† la cr√©ation de ce logiciel, j'ai d√©cid√© de voir la version d'essai disponible en t√©l√©chargement gratuit, et ici je partage les r√©sultats. <br><br>  Pour commencer, le descriptif semestriel a presque diminu√© de moiti√© en volume (de 115 √† 55 pages), et si la disparition des applications avec des captures d'√©cran d√©crivant le processus de lancement de troisi√®mes produits de la ¬´Description du programme¬ª est la bienvenue, alors pas l'apparence de ces mat√©riaux (pour la cr√©ation desquels J'ai pass√©, bien que pas tr√®s important, mais encore du temps et de l'argent) dans un document tel que ¬´Guide de l'op√©rateur¬ª, je suis personnellement perplexe.  De plus, dans la toute premi√®re phrase du document, nous voyons une nette d√©viation de la v√©rit√©, puisque RTOS lui-m√™me n'est pas destin√© √† "cr√©er des programmes" de quelque mani√®re que ce soit, pour une raison quelconque, les auteurs ne se sont pas permis de telles d√©clarations dans la version pr√©c√©dente du document, l'influence du service de marketing se fait sentir.  Il fournit √©galement que si la description √©tait dans le dossier / docs du r√©pertoire racine, et c'√©tait logique, maintenant elle est cach√©e dans / toolchain / macs / docs, eh bien, comme ils l'ont dit dans ma jeunesse, "tout le monde est fou √† sa mani√®re", nous allons de l'avant. <br><br>  Je commence √† regarder la description, en regardant le code source (il est aimablement inclus dans la version d'essai) et, perplexe, je trouve l'absence de tout pilote de p√©riph√©rique adapt√© pour fonctionner avec cet OS.  J'ai d'abord sugg√©r√© qu'il s'agissait d'une fonctionnalit√© de l'essai, puis sur le forum dans les informations des d√©veloppeurs, je trouve qu'il n'y a vraiment pas de pilotes, mais ils y travaillent.  Plus de six mois (six mois, Carl, en fait pr√®s d'un an) √† partir du moment o√π l'OS a √©t√© publi√© pour MK, et ils travaillent sur des pilotes.  Naturellement, ou comme on dit, il va sans dire qu'on ne peut pas parler de produits tiers (syst√®me de fichiers, pile r√©seau, pile USB).  Une id√©e amusante des auteurs sur les exigences de d√©veloppement de logiciels pour MK, d'accord, a encore conduit. <br><br>  Autrement dit, le syst√®me d'exploitation d√©clar√©, dont la caract√©ristique mise en √©vidence est l'organisation de l'interaction au sein d'un syst√®me √† plusieurs contr√¥leurs, ne dispose pas de moyens natifs pour organiser cette interaction.  Ce que nous avons en fin de compte - et nous avons la gestion des t√¢ches, en fait un sheduler, un service de temps minimal et des moyens de synchroniser les t√¢ches, et c'est tout - dr√¥le, pour dire le moins.  D'accord, nous allons voir plus loin, m√™me dans un tel ensemble de composants, des solutions int√©ressantes sont possibles, surtout si l'on consid√®re que sur un site (pas l'entreprise du fabricant) j'ai vu un "examen" du code source de cet OS par r√©f√©rence.  Ce document indique que le produit logiciel n'utilise pas de composants tiers (importation) et est original, il serait n√©cessaire de s'assurer. <br><br>  La premi√®re observation est que si vous utilisez des fichiers ARM originaux inclus dans le package de code source pour porter sur une architecture Cortex-M0 sp√©cifique (1986 BE1T), cela est tr√®s similaire √† l'utilisation de fragments de texte tiers (import√©s) - je pense personnellement que c'est l'usage, mais Je ne sais probablement pas tout.  Eh bien, et deuxi√®mement, le code source du sheduler et des composants de gestion des t√¢ches connexes est vraiment original et n'a pas d'analogues (du moins je n'en connais pas), mais c'est le genre d'originalit√© quand je me souviens de la phrase du vieux chaman du film "The Evil Spirit of Yambuya" √† propos de le grand chasseur: "Coupez les oreilles, faites cuire et mangez - auriez-vous devin√©?" <br><br>  Je vais essayer d'expliquer - dans la conception du syst√®me d'exploitation en g√©n√©ral et dans le RTOS en particulier, l'un des probl√®mes complexes est celui de garantir l'acc√®s de tous les processus du syst√®me √† une ressource partag√©e - le temps d'ex√©cution du processeur.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le fait est qu'un syst√®me mal con√ßu (et une t√¢che mal √©crite) peut bloquer l'ex√©cution de toutes les t√¢ches avec une priorit√© inf√©rieure, ce qui surprendra certainement le programmeur. Il ne s'agit pas d'effectuer des op√©rations interdites telles que le contr√¥le d'interruption (c'est un sujet pour une discussion s√©par√©e et n'a tout simplement pas de solution dans le cadre de MK simples, bien que les auteurs du syst√®me d'exploitation en question pr√©tendent avoir r√©solu ce probl√®me en utilisant le MPU), mais sur une ex√©cution continue sans attendre.</font></font><br><br>    ,     ,      ,  ,          .           (1) , ,  FREE-RTOS     20        ,       ( ,       ,        ). <br><br>     , ,         60 (  ).  ,    .            (      )    ,     (,     )   ,  <br><br><ol><li>       (n)  </li><li>       ‚Äî  ,   20*(3*4)=240   .   , ,    ,    . </li></ol><br>  ,     ,       (     ,   ,   )             .  ,         ( , ).                 mcucpp (      ‚Äî   ),        . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La conclusion de cette section est que si d'autres d√©cisions sur la substitution des importations dans le domaine des logiciels sont mises en ≈ìuvre de mani√®re similaire avec des r√©sultats de qualit√© similaire, les perspectives de construction de syst√®mes embarqu√©s nationaux me semblent tr√®s mal d√©finies. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conclusion, je voudrais me tourner vers le manuel (non, pas un d√©veloppeur de syst√®me d'exploitation, je ne veux m√™me pas le mentionner √† c√¥t√© de bons d√©veloppeurs) de l'entreprise-d√©veloppeur et fabricant du MK-Milander mentionn√©. Vous faites de bons microcontr√¥leurs (je ne vais pas mentir, ils sont inf√©rieurs en param√®tres aux analogues √©trangers, mais pas fatalement), par exemple, √† un moment donn√© (en 2013) BE1T √©tait presque le meilleur parmi les camarades de classe, mais dans la cour en 2019 et pendant ce temps, beaucoup l'ont rattrap√© et d√©pass√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais, si le bon MK produit par l'entreprise n'a pas:</font></font><br><br><ol><li>  (  ,   )  ( ,   ,    ,  ,  ), </li><li>      (   ), </li><li>      ()      2, </li><li>       HAL, CMSIS (- ), </li><li>       , </li><li>        , </li><li>      (3rd part),  , </li><li>       , </li><li>       , </li><li>    ,     (,   ,     ..)     ¬´ ¬ª, </li><li>  ,   ,         (    , , MIT   ,  ¬´      ¬ª),        ,    (?). </li></ol><br> ,         ,   ,           5          (  , ,  10,            IDE).    ,        ,    . <br><br>    ,              , ,    . <br><br>    ,      ,   ()    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437326/">https://habr.com/ru/post/fr437326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437316/index.html">L'Internet Development Institute a nomm√© des sites qui pourraient √™tre d√©connect√©s sur RuNet depuis le 1er f√©vrier</a></li>
<li><a href="../fr437318/index.html">Migration transparente (ou presque) entre les principales versions de PostgreSQL √† l'aide de la r√©plication logique</a></li>
<li><a href="../fr437320/index.html">Indice de d√©veloppement de la sph√®re des m√©dias 2018: stagnation de la t√©l√©vision, confiance accrue dans les m√©dias informels</a></li>
<li><a href="../fr437322/index.html">L'√âtat est engag√© dans BigDate</a></li>
<li><a href="../fr437324/index.html">Baiser sanglant: propri√©t√©s de vasorelaxation de la salive des chauves-souris vampires</a></li>
<li><a href="../fr437330/index.html">devleads - parle de burnout</a></li>
<li><a href="../fr437332/index.html">Deux pour cent du ¬´chat¬ª ou qui a photographi√© Ma√Ætre Yoda?</a></li>
<li><a href="../fr437334/index.html">Que se passera-t-il le 1er f√©vrier?</a></li>
<li><a href="../fr437336/index.html">De Penza √† Berlin: histoire du d√©m√©nagement de l'automate de test</a></li>
<li><a href="../fr437342/index.html">Comment choisir une plateforme de vid√©osurveillance: Cloud vs DVR / NVR / VMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>