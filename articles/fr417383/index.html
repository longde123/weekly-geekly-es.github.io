<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎳 👩🏼‍🏭 🤟🏽 JavaScript ES6: faiblesses 👫 🤰 👨🏼‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En juin 2018, la norme ECMAScript 2015 ( ES6 ) a célébré son troisième anniversaire. Dans ES6, d'une part, de nombreuses nouvelles fonctionnalités Jav...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript ES6: faiblesses</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/417383/">  En juin 2018, la norme ECMAScript 2015 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ES6</a> ) a célébré son troisième anniversaire.  Dans ES6, d'une part, de nombreuses nouvelles fonctionnalités JavaScript sont apparues, et d'autre part, une nouvelle ère de développement de langage commence avec cette norme.  De plus, il s'agissait de la dernière version à grande échelle de JS, car le TC39 applique désormais le schéma de publication de petits numéros annuels de la norme et ne le réédite plus toutes les quelques années. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ts/9f/9h/ts9f9hvjwknbldjzd40effqpdbs.jpeg"></a> <br><br>  Les 4 dernières années, ES6, à juste titre, a attiré l'attention universelle.  L'auteur du matériel, dont nous publions la traduction aujourd'hui, dit que pendant tout ce temps, grâce à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Babel</a> , il a écrit tout le code en utilisant la version moderne des spécifications JS.  Il estime que suffisamment de temps s'est écoulé pour analyser de manière critique les nouvelles fonctionnalités d'ES6.  En particulier, il s'intéresse à ce qu'il a utilisé pendant un certain temps, puis a cessé de l'utiliser car cela a aggravé son code. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">À propos des faiblesses de JS</font> </h2><br>  Douglas Crockford, dans son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livre</a> JavaScript: Strengths, a également écrit sur ce qui peut être considéré comme des faiblesses du langage.  C'est quelque chose qui, à son avis, ne vaut pas la peine d'être utilisé.  Heureusement, parmi les innovations d'ES6, rien n'est aussi disgracieux que certaines des anciennes fonctionnalités problématiques de JS, telles que l'opérateur d'égalité laxiste qui effectue une conversion de type implicite, la fonction <code>eval()</code> et l'instruction <code>with</code> .  Les nouvelles fonctionnalités d'ES6 sont bien mieux conçues.  Cependant, il y a des choses en lui que j'évite.  Les fonctionnalités qui figurent sur ma liste de «faiblesses» JS figurent sur cette liste pour les raisons suivantes: <br><br><ul><li>  Ce sont essentiellement des «pièges».  Autrement dit, il semble qu'ils soient conçus pour effectuer certaines actions et, dans la plupart des cas, ils fonctionnent comme prévu.  Cependant, ils se comportent parfois de manière inattendue, ce qui peut facilement entraîner des erreurs. </li><li>  Ils augmentent le volume de la langue en échange de petits avantages.  De telles opportunités donnent au développeur quelques petits avantages, mais nécessitent que quelqu'un qui essaie de comprendre son code ait une connaissance de certains mécanismes, généralement cachés quelque part.  Cela est doublement vrai pour les capacités de l'API, lorsque l'utilisation de cette fonctionnalité signifie que tout autre code qui interagit avec le code écrit par un certain développeur doit être conscient de l'application de cette fonctionnalité de l'API. </li></ul><br>  Maintenant, guidés par ces considérations, parlons des faiblesses d'ES6. <br><br><h2>  <font color="#3AC1EF">Mot-clé const</font> </h2><br>  Avant ES6, les variables en JavaScript pouvaient être déclarées à l'aide du mot clé <code>var</code> .  De plus, les variables n'ont pas pu être déclarées du tout, alors elles, même si elles sont utilisées dans des fonctions, tombent dans la portée globale.  Les propriétés des objets peuvent jouer le rôle de variables et les fonctions sont déclarées à l'aide du mot clé <code>function</code> .  Le mot-clé <code>var</code> a certaines fonctionnalités. <br><br>  Ainsi, il vous permet de créer des variables qui sont ajoutées à l'objet global, ou celles dont la portée est limitée par des fonctions.  Cependant, le mot clé <code>var</code> ne fait pas attention aux blocs de code.  De plus, vous pouvez faire référence à une variable déclarée à l'aide du mot-clé <code>var</code> dans le code situé avant la commande pour sa déclaration.  Ce phénomène est appelé augmentation des variables.  Ces fonctionnalités, si elles ne sont pas prises en compte, peuvent entraîner des erreurs.  Afin de rectifier la situation, ES6 a introduit deux nouveaux mots clés pour déclarer des variables: <code>let</code> et <code>const</code> .  Ils ont résolu les principaux problèmes <code>var</code> .  À savoir, nous parlons du fait que les variables déclarées à l'aide de ces mots clés ont une portée de bloc, par conséquent, par exemple, une variable déclarée dans une boucle n'est pas visible à l'extérieur.  De plus, l'utilisation de <code>let</code> et <code>const</code> ne permet pas d'accéder aux variables avant qu'elles ne soient déclarées.  Cela entraînera une erreur <code>ReferenceError</code> .  Ce fut un grand pas en avant.  Cependant, l'émergence de deux nouveaux mots clés, ainsi que leurs fonctionnalités, a conduit à une confusion supplémentaire. <br><br>  La valeur d'une variable (constante) déclarée à l'aide du mot clé <code>const</code> ne peut pas être remplacée après la déclaration.  C'est la seule différence entre <code>const</code> et <code>let</code> .  Cette nouvelle opportunité semble utile, et elle peut vraiment apporter des avantages.  Le problème est le mot clé <code>const</code> lui-même.  Le comportement des constantes déclarées qui l'utilisent ne correspond pas à ce que la plupart des développeurs associent au concept de «constante». <br><br><pre> <code class="hljs pgsql">const <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> = <span class="hljs-number"><span class="hljs-number">123</span></span>; //      "TypeError: invalid assignment to const `CONSTANT`" <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> = <span class="hljs-number"><span class="hljs-number">345</span></span>; const CONSTANT_ARR = [] CONSTANT_ARR.push(<span class="hljs-number"><span class="hljs-number">1</span></span>) //     [<span class="hljs-number"><span class="hljs-number">1</span></span>]  -    console.log(CONSTANT_ARR)</code> </pre> <br>  L'utilisation du mot clé <code>const</code> empêche l'écriture d'une nouvelle valeur dans une constante, mais ne rend pas immuable les objets référencés par de telles constantes.  Cette fonctionnalité offre une faible protection contre les modifications de valeurs lors de l'utilisation de la plupart des types de données.  Par conséquent, étant donné que l'utilisation de <code>const</code> peut entraîner de la confusion et du fait que si le mot clé <code>let</code> est présent, la présence de <code>const</code> semble redondante, j'ai décidé de toujours utiliser <code>let</code> . <br><br><h2>  <font color="#3AC1EF">Chaînes de modèle marquées</font> </h2><br>  Le mot clé <code>const</code> est un exemple de la façon dont une spécification crée trop de façons de résoudre trop peu de problèmes.  Dans le cas de chaînes de modèle balisées, nous avons la situation inverse.  La syntaxe de ces chaînes a été considérée par le comité TC39 comme un moyen de résoudre l'interpolation de chaînes et les chaînes multilignes.  Ils ont ensuite décidé d'étendre cette opportunité grâce à l'utilisation de macros. <br><br>  Si vous n'avez jamais vu de chaînes de motifs marquées auparavant, gardez à l'esprit qu'elles sont un peu comme des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">décorateurs de</a> chaînes.  Voici un exemple de collaboration avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MDN</a> : <br><br><pre> <code class="hljs powershell">var person = <span class="hljs-string"><span class="hljs-string">'Mike'</span></span>; var age = <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myTag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(strings, personExp, ageExp)</span></span></span></span> { var str0 = strings[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // <span class="hljs-string"><span class="hljs-string">"that "</span></span> var str1 = strings[<span class="hljs-number"><span class="hljs-number">1</span></span>]; // <span class="hljs-string"><span class="hljs-string">" is a "</span></span> //  (  ) //     , //  ,      . // var str2 = strings[<span class="hljs-number"><span class="hljs-number">2</span></span>]; var ageStr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ageExp &gt; <span class="hljs-number"><span class="hljs-number">99</span></span>){   ageStr = <span class="hljs-string"><span class="hljs-string">'centenarian'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   ageStr = <span class="hljs-string"><span class="hljs-string">'youngster'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str0 + personExp + str1 + ageStr; } var output = myTag`that <span class="hljs-variable"><span class="hljs-variable">$</span></span>{ person } is a <span class="hljs-variable"><span class="hljs-variable">$</span></span>{ age }`; console.log(output); // that Mike is a youngster</code> </pre> <br>  Les chaînes de modèle marquées ne peuvent pas être appelées complètement inutiles.  Voici un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">aperçu de</a> certaines de leurs utilisations.  Par exemple, ils sont utiles pour effacer le code HTML.  Et, pour le moment, leur application démontre l'approche la plus précise dans les situations où vous devez effectuer la même opération sur toutes les données d'entrée d'un modèle de chaîne arbitraire.  Cependant, ceci est relativement rare, vous pouvez faire de même en utilisant l'API appropriée (bien qu'une telle solution soit plus longue).  Et, pour résoudre la plupart des problèmes, l'utilisation de l'API ne sera pas pire que l'utilisation de chaînes de modèle balisées.  Cette fonctionnalité n'ajoute pas de nouvelles fonctionnalités à la langue.  Elle ajoute de nouvelles approches pour travailler avec des données qui devraient être familières à ceux qui doivent lire du code écrit à l'aide de chaînes de modèle balisées.  Et je m'efforce de faire en sorte que mon code reste aussi propre et compréhensible que possible. <br><br><h2>  <font color="#3AC1EF">Expressions d'attribution destructives repensées</font> </h2><br>  Certaines fonctionnalités du langage ont fière allure lorsqu'elles sont utilisées pour résoudre des tâches simples, cependant, lorsque les tâches deviennent plus complexes, ces fonctionnalités peuvent devenir incontrôlables.  Par exemple, j'aime l'opérateur conditionnel ternaire: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> conferenceCost = isStudent ? <span class="hljs-number"><span class="hljs-number">50</span></span> : <span class="hljs-number"><span class="hljs-number">200</span></span></code> </pre> <br>  Cependant, le code écrit avec son aide, il devient difficile de comprendre si, en utilisant cet opérateur, vous commencez à utiliser des constructions imbriquées: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> conferenceCost = isStudent ? hasDiscountCode ? <span class="hljs-number"><span class="hljs-number">25</span></span> : <span class="hljs-number"><span class="hljs-number">50</span></span> : hasDiscountCode ? <span class="hljs-number"><span class="hljs-number">100</span></span> : <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre> <br>  On peut en dire autant de l'affectation destructrice.  Ce mécanisme vous permet d'extraire les valeurs des variables des objets ou des tableaux: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {a} = {<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [b] = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a, b) <span class="hljs-comment"><span class="hljs-comment">// 2, 4</span></span></code> </pre> <br>  De plus, lorsque vous l'utilisez, vous pouvez renommer des variables, obtenir des valeurs imbriquées, définir des valeurs par défaut: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {a: val1} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, b: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [{b}] = [{a:<span class="hljs-number"><span class="hljs-number">3</span></span>, b:<span class="hljs-number"><span class="hljs-number">4</span></span>} , {<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, d: <span class="hljs-number"><span class="hljs-number">6</span></span>}]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>=<span class="hljs-number"><span class="hljs-number">6</span></span>} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {d=<span class="hljs-number"><span class="hljs-number">6</span></span>} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>}; console.log(val1, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, d) <span class="hljs-comment"><span class="hljs-comment">// 2, 4, 5, 6</span></span></code> </pre> <br>  Tout cela est merveilleux - jusqu'à ce qu'il s'agisse de créer des expressions complexes en utilisant toutes ces fonctionnalités.  Par exemple, dans l'expression ci-dessous, 4 variables sont déclarées: <code>userName</code> , <code>eventType</code> , <code>eventDate</code> et <code>eventId</code> .  Leurs valeurs sont prises à différents endroits de la structure de l'objet <code>eventRecord</code> . <br><br><pre> <code class="hljs pgsql">let eventRecord = { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: { <span class="hljs-type"><span class="hljs-type">name</span></span>: "Ben M", email: "ben@m.com" }, event: "logged in", metadata: { <span class="hljs-type"><span class="hljs-type">date</span></span>: "10-10-2017" }, id: "123" }; let { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: { <span class="hljs-type"><span class="hljs-type">name</span></span>: userName = "Unknown" }, event: eventType = "Unknown Event", metadata: [<span class="hljs-type"><span class="hljs-type">date</span></span>: eventDate], id: eventId } = obj;</code> </pre> <br>  Comprendre un tel code est presque impossible.  Ce problème peut être résolu en utilisant du code beaucoup plus lisible, si vous utilisez plusieurs opérations de déstructuration ou si vous les abandonnez complètement. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eventRecord = { user: { name: <span class="hljs-string"><span class="hljs-string">"Ben M"</span></span>, email: <span class="hljs-string"><span class="hljs-string">"ben@m.com"</span></span> }, <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>: <span class="hljs-string"><span class="hljs-string">"logged in"</span></span>, metadata: { date: <span class="hljs-string"><span class="hljs-string">"10-10-2017"</span></span> }, id: <span class="hljs-string"><span class="hljs-string">"123"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userName = eventRecord.user.userName || <span class="hljs-string"><span class="hljs-string">'Unknown'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eventDate = eventRecord.metadata.date; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>:eventType=<span class="hljs-string"><span class="hljs-string">'UnknownEvent'</span></span>, id:eventId} = eventRecord;</code> </pre> <br>  Je n'ai pas de ligne directrice claire indiquant que l'expression de la mission destructrice doit être retravaillée.  Cependant, chaque fois que je regarde une expression similaire et que je ne peux pas comprendre instantanément quel problème elle résout, quelles variables y sont utilisées, je comprends qu'il est temps de simplifier le code afin d'améliorer sa lisibilité. <br><br><h2>  <font color="#3AC1EF">Exportation par défaut</font> </h2><br>  ES6 a une fonctionnalité intéressante.  Elle consiste dans la façon dont ses développeurs ont abordé la standardisation de ce qui était fait auparavant avec l'aide de diverses bibliothèques, souvent en concurrence les unes avec les autres.  Ainsi, dans la spécification sont apparues des classes, des promesses, des modules.  C'est tout ce que la communauté des développeurs JS utilisait avant ES6, le trouvant dans des bibliothèques tierces.  Par exemple, les modules ES6 sont un excellent substitut à ce qui s'est répandu dans la guerre des formats AMD / CommonJS et fournissent une syntaxe pratique pour organiser les importations. <br><br>  Les modules ES6 prennent en charge deux manières principales d'exporter des valeurs: l'exportation nommée et l'exportation par défaut, ou l'exportation par défaut: <br><br><pre> <code class="hljs vhdl">const mainValue = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> export export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> mainValue export const secondaryValue = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a secondary value; export const secondaryValue2 = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> another secondary value;</code> </pre> <br>  Un module peut utiliser plusieurs commandes d'exportation nommées, mais une seule commande d'exportation par défaut.  Lors de l'importation de ce qui a été exporté à l'aide de la commande d'exportation par défaut, dans le fichier d'importation, vous pouvez donner à tout ce qui est exporté par défaut n'importe quel nom, car aucun nom n'est recherché pendant cette opération.  Lorsque vous utilisez l'exportation nommée, vous devez utiliser les noms de variable des fichiers d'exportation, bien que le changement de nom soit également possible. <br><br><pre> <code class="hljs pgsql">//   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> renamedMainValue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>; //   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {secondaryValue} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>; //     <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {secondaryValue <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> otherValue} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>;</code> </pre> <br>  L'exportation par défaut a bénéficié d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une attention particulière des développeurs de</a> la norme ES6, et ils ont intentionnellement créé une syntaxe plus simple pour cela.  Cependant, dans la pratique, j'ai pu découvrir que l'utilisation de la technologie d'exportation nommée est préférable pour les raisons suivantes. <br><br><ol><li>  Lorsque vous utilisez l'exportation nommée, les noms des variables exportées correspondent, par défaut, aux noms des variables importées, ce qui simplifie leur recherche pour ceux qui n'utilisent pas d'outils de développement intelligents. </li><li>  Lors de l'utilisation d'exportations nommées, les programmeurs utilisant des outils de développement intelligents bénéficient de fonctionnalités pratiques telles que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'importation automatique</a> . </li><li>  Les exportations nommées vous permettent d'exporter uniformément à partir des modules tout ce que vous voulez, dans les bonnes quantités.  L'exportation par défaut limite le développeur à l'exportation d'une seule valeur.  Pour contourner ce problème, vous pouvez appliquer l'exportation d'un objet avec plusieurs propriétés.  Cependant, cette approche perd la valeur de l'algorithme de tremblement d'arbre utilisé pour réduire la taille des applications JS construites par quelque chose comme webpack.  L'utilisation de modules nommés exclusivement nommés simplifie le travail. </li></ol><br>  En général, on peut noter que la dénomination des entités est une bonne pratique, car elle vous permet de les identifier de manière unique à la fois dans le code et dans les conversations sur ce code.  C'est pourquoi j'utilise l'export nommé. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Vous venez d'apprendre les fonctionnalités d'ES6 qui, selon l'auteur de ce document, n'ont pas réussi.  Peut-être que vous rejoignez cette opinion, peut-être pas.  Tout langage de programmation est un système complexe, dont les capacités peuvent être vues de différents points de vue.  Cependant, nous espérons que cet article sera utile à tous ceux qui cherchent à écrire du code clair et de haute qualité. <br><br>  <b>Chers lecteurs!</b>  Y a-t-il quelque chose dans le JavaScript moderne que vous essayez d'éviter? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ri/aw/tq/riawtqey48mow3zanijqzhgifjg.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417383/">https://habr.com/ru/post/fr417383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417369/index.html">15 outils pour l'arsenal de travail du chef de produit</a></li>
<li><a href="../fr417373/index.html">Environnements de stockage, de veille et de test ZFS</a></li>
<li><a href="../fr417375/index.html">15 méthodes d'élément HTML dont vous n'avez probablement jamais entendu parler</a></li>
<li><a href="../fr417377/index.html">Pourquoi vous ne devriez pas utiliser Google Cloud</a></li>
<li><a href="../fr417379/index.html">Nouveau moteur-fusée à propergol solide pour Vega-C et Ariane 6</a></li>
<li><a href="../fr417385/index.html">Comment j'ai déménagé ... chez moi, ou ma réponse à l'auteur de l'article sur "la farine impitoyable"</a></li>
<li><a href="../fr417389/index.html">Effet d'objectif à décalage d'inclinaison</a></li>
<li><a href="../fr417391/index.html">Extension Web multi-navigateur pour les scripts personnalisés Partie 4</a></li>
<li><a href="../fr417393/index.html">Comment nous avons créé un système qui attribue des remises aux clients en fonction des caractéristiques individuelles</a></li>
<li><a href="../fr417395/index.html">Tests de bout en bout: quoi, pourquoi, pourquoi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>