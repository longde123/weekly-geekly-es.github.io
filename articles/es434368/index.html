<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçê üöÆ üë©‚Äç‚úàÔ∏è Aprendizaje autom√°tico para encontrar errores en el c√≥digo: c√≥mo hice pr√°cticas en JetBrains Research üö∂üèæ üë®üèæ‚Äçüéì üöÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, hablamos sobre c√≥mo obtener una pasant√≠a en Google. Adem√°s de Google, nuestros estudiantes prueban suerte en JetBrains, Yandex, Acronis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprendizaje autom√°tico para encontrar errores en el c√≥digo: c√≥mo hice pr√°cticas en JetBrains Research</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/434368/">  Recientemente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hablamos</a> sobre c√≥mo obtener una pasant√≠a en Google.  Adem√°s de Google, nuestros estudiantes prueban suerte en JetBrains, Yandex, Acronis y otras compa√±√≠as. <br><br>  En este art√≠culo compartir√© mi experiencia de pasant√≠as en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JetBrains Research</a> , hablar√© sobre las tareas que resuelven all√≠ y me detendr√© en c√≥mo el aprendizaje autom√°tico puede buscar errores en el c√≥digo del programa. <br><br><img src="https://habrastorage.org/webt/gf/xa/bh/gfxabh9xemshdpmkrr48vind45a.jpeg"><br><a name="habracut"></a><br><h2>  Sobre mi </h2><br>  Mi nombre es Egor Bogomolov, soy un estudiante de cuarto a√±o de la licenciatura de San Petersburgo HSE en Matem√°tica Aplicada y Ciencias de la Computaci√≥n.  Durante los primeros 3 a√±os, yo, como mis compa√±eros de clase, estudi√© en la Universidad Acad√©mica, y desde septiembre nos hemos mudado a la Escuela Superior de Econom√≠a con todo el departamento. <br><br>  Despu√©s del segundo a√±o, realic√© una pasant√≠a de verano en Google Zurich.  All√≠ pas√© tres meses trabajando en el equipo de Android Calendar, la mayor√≠a del tiempo haciendo frontend'om y un poco de investigaci√≥n UX.  La parte m√°s interesante de mi trabajo fue investigar c√≥mo se ver√≠an las interfaces de calendario en el futuro.  Result√≥ ser agradable que casi todo el trabajo que hice al final de la pasant√≠a termin√≥ en la versi√≥n principal de la aplicaci√≥n.  Pero el tema de las pasant√≠as en Google est√° muy bien cubierto en una publicaci√≥n anterior, as√≠ que hablar√© sobre lo que hice este verano. <br><br><h2>  ¬øQu√© es JB Research? </h2><br>  JetBrains Research es un conjunto de laboratorios que trabajan en varios campos: lenguajes de programaci√≥n, matem√°tica aplicada, aprendizaje autom√°tico, rob√≥tica y otros.  Dentro de cada √°rea hay varios grupos cient√≠ficos.  Debido a mi direcci√≥n, conozco mejor las actividades de los grupos en el campo del aprendizaje autom√°tico.  Cada uno de ellos organiza seminarios semanales en los que los miembros del grupo o invitados invitan a hablar sobre su trabajo o art√≠culos interesantes en su campo.  Muchos estudiantes del HSE vienen a estos seminarios, ya que cruzan la calle desde el edificio principal del Campus HSE en San Petersburgo. <br><br>  En nuestro programa de licenciatura, estamos necesariamente involucrados en trabajos de investigaci√≥n (I + D) y presentamos los resultados de la investigaci√≥n dos veces al a√±o.  A menudo, este trabajo se convierte gradualmente en pasant√≠as de verano.  Esto tambi√©n sucedi√≥ con mi trabajo de investigaci√≥n: este verano hice una pasant√≠a en el laboratorio "M√©todos de aprendizaje autom√°tico en ingenier√≠a de software" con mi supervisor de investigaci√≥n Timofey Bryksin.  Las tareas que se est√°n trabajando en este laboratorio incluyen sugerencias de refactorizaci√≥n autom√°tica, an√°lisis del estilo de c√≥digo para programadores, finalizaci√≥n de c√≥digo y b√∫squeda de errores en el c√≥digo del programa. <br><br>  Mi pasant√≠a dur√≥ dos meses (julio y agosto), y en el oto√±o segu√≠ participando en tareas asignadas en el marco de la investigaci√≥n.  Trabaj√© en varias √°reas, la m√°s interesante de ellas, en mi opini√≥n, fue la b√∫squeda autom√°tica de errores en el c√≥digo, y quiero hablar sobre ello.  El punto de partida fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un art√≠culo de Michael Pradel</a> . <br><br><h2>  B√∫squeda autom√°tica de errores </h2><br><h3>  ¬øC√≥mo se buscan los errores ahora? </h3><br>  Por qu√© buscar errores es m√°s o menos claro.  Veamos c√≥mo les va ahora.  Los detectores de errores modernos se basan principalmente en el an√°lisis de c√≥digo est√°tico.  Para cada tipo de error, busque patrones notados previamente por los cuales pueda determinarse.  Luego, para reducir el n√∫mero de falsos positivos, se inventan heur√≠sticas, inventadas para cada caso individual.  Se pueden buscar patrones tanto en un √°rbol de sintaxis abstracta (AST) construido por c√≥digo como en gr√°ficos de un flujo de control o datos. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) || x &gt; MAX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = bar(x); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><img src="https://habrastorage.org/webt/76/8t/wn/768twn22o7j83mwak6x-n9kw5d4.png"><br><br>  El c√≥digo y el √°rbol que se construy√≥ sobre √©l. <br><br>  Para entender c√≥mo funciona esto, considere un ejemplo.  El tipo de errores puede ser el uso de = en lugar de == en C ++.  Veamos el siguiente fragmento de c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">0</span></span>; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value = <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ‚Ä¶ }</code> </pre><br>  Hubo un error en la expresi√≥n condicional, mientras que el primer = en la asignaci√≥n del valor a la variable es correcto.  El patr√≥n viene de aqu√≠: si la asignaci√≥n se usa dentro de la condici√≥n en if, esto es un error potencial.  Buscando dicho patr√≥n en AST, podemos detectar el error y corregirlo. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = <span class="hljs-number"><span class="hljs-number">0</span></span>; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ‚Ä¶ }</code> </pre><br>  En un caso m√°s general, no podremos encontrar tan f√°cilmente una manera de describir el error.  Supongamos que queremos determinar el orden correcto de los operandos.  De nuevo, mira los fragmentos de c√≥digo: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; n; i++) { a[i] = a[<span class="hljs-number"><span class="hljs-number">1</span></span> - i] + a[i - <span class="hljs-number"><span class="hljs-number">2</span></span>]; }</code> </pre><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitReverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> - i; }</code> </pre><br>  En el primer caso, el uso de 1-i fue err√≥neo, y en el segundo fue completamente correcto, lo cual es claro por el contexto.  Pero, ¬øc√≥mo describirlo en forma de patr√≥n?  Con la complicaci√≥n del tipo de errores, tenemos que considerar una secci√≥n m√°s grande de c√≥digo y analizar m√°s y m√°s casos individuales. <br><br>  El √∫ltimo ejemplo motivador: la informaci√≥n √∫til tambi√©n est√° contenida en los nombres de m√©todos y variables.  Es a√∫n m√°s dif√≠cil de expresar por algunas condiciones especificadas manualmente. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSquare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDim, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> yDim)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span>, y = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = getSquare(y, x);</code> </pre><br>  Una persona entiende que, muy probablemente, los argumentos en la llamada a la funci√≥n est√°n mezclados, porque tenemos un entendimiento de que x es m√°s como xDim que yDim.  Pero, ¬øc√≥mo informar esto al detector?  Puede agregar algunas heur√≠sticas de la forma "el nombre de la variable es el prefijo del nombre del argumento", pero suponga que x es m√°s a menudo un ancho que una altura, por lo que ya no se expresa. <br><br>  En pocas palabras: el problema del enfoque moderno para encontrar errores es que se debe hacer mucho trabajo con las manos: para determinar patrones, agregar heur√≠sticas, por eso, agregar soporte para un nuevo tipo de error en el detector se vuelve lento.  Adem√°s, es dif√≠cil usar una parte importante de la informaci√≥n que el desarrollador dej√≥ en el c√≥digo: los nombres de las variables y los m√©todos. <br><br><h3>  ¬øC√≥mo puede ayudar el aprendizaje autom√°tico? </h3><br>  Como habr√°s notado, en muchos ejemplos los errores son visibles para los humanos, pero son dif√≠ciles de describir formalmente.  En tales situaciones, los m√©todos de aprendizaje autom√°tico a menudo pueden ayudar.  Dejemos de buscar argumentos reorganizados en una llamada de funci√≥n y comprendamos qu√© necesitamos buscarlos mediante el aprendizaje autom√°tico: <br><br><ol><li>  Una gran cantidad de c√≥digo de muestra sin errores </li><li>  Una gran cantidad de c√≥digo con errores de un tipo dado </li><li>  M√©todo para vectorizar fragmentos de c√≥digo </li><li>  El modelo que ense√±aremos para distinguir entre c√≥digo con y sin errores </li></ol><br>  Podemos esperar que en la mayor√≠a de los c√≥digos establecidos en el dominio p√∫blico, los argumentos en las llamadas a funciones est√©n en el orden correcto.  Por lo tanto, para el c√≥digo de muestra sin errores, puede tomar un gran conjunto de datos.  En el caso del autor del art√≠culo original, era JS 150K (150 mil archivos en Javascript), en nuestro caso, un conjunto de datos similar para Python. <br><br>  Encontrar c√≥digo con errores es mucho m√°s dif√≠cil.  Pero no podemos buscar los errores de otra persona, ¬°pero hazlos t√∫ mismo!  Para el tipo de errores, debe especificar una funci√≥n que, de acuerdo con el c√≥digo correcto, la corromper√°.  En nuestro caso, reorganice los argumentos en la llamada a la funci√≥n. <br><br><h3>  ¬øC√≥mo vectorizar el c√≥digo? </h3><br>  Armados con muchos c√≥digos buenos y malos, estamos casi listos para ense√±ar algo.  Antes de eso, todav√≠a tenemos que responder la pregunta: ¬øc√≥mo presentar fragmentos de c√≥digo? <br><br>  Una llamada de funci√≥n se puede representar como una tupla del nombre de un m√©todo, el nombre de qui√©n es el m√©todo, los nombres y los tipos de argumentos pasados ‚Äã‚Äãa las variables.  Si aprendemos c√≥mo vectorizar tokens individuales (nombres de variables y m√©todos, todas las "palabras" encontradas en el c√≥digo), podemos tomar la concatenaci√≥n de vectores de tokens de inter√©s para nosotros y obtener el vector deseado para el fragmento. <br><br>  Para vectorizar tokens, echemos un vistazo a c√≥mo se vectorizan las palabras en los textos ordinarios.  Una de las formas m√°s exitosas y populares es la word2vec propuesta en 2013. <br><br><img src="https://habrastorage.org/webt/kj/0o/pp/kj0opp-scftpuqr16t5c9fj1uv0.png"><br><br>  Funciona de la siguiente manera: ense√±amos a la red a predecir por palabras otras palabras que aparecen junto a ella en los textos.  Al mismo tiempo, la red parece una capa de entrada del tama√±o de un diccionario, una capa oculta del tama√±o de la vectorizaci√≥n que queremos obtener y una capa de salida, tambi√©n del tama√±o de un diccionario.  Durante el entrenamiento, las redes se alimentan con un vector de unidad de entrada con una unidad en lugar de la palabra en cuesti√≥n (zorro), y en la salida queremos obtener las palabras que aparecen dentro de la ventana alrededor de esta palabra (r√°pido, marr√≥n, saltos, sobre).  En este caso, la red primero traduce todas las palabras en un vector en una capa oculta, y luego hace una predicci√≥n. <br><br>  Los vectores resultantes para palabras individuales tienen buenas propiedades.  Por ejemplo, los vectores de palabras con un significado similar est√°n cerca uno del otro, y la suma y la diferencia de los vectores son la suma y la diferencia de los "significados" de las palabras. <br><br>  Para hacer una vectorizaci√≥n similar de tokens en el c√≥digo, debe configurar de alguna manera el entorno que se predecir√°.  Pueden ser informaci√≥n de AST: tipos de v√©rtices alrededor, tokens encontrados, posici√≥n en un √°rbol. <br><br>  Despu√©s de recibir una vectorizaci√≥n, puede ver qu√© fichas son similares entre s√≠.  Para hacer esto, calcule la distancia del coseno entre ellos.  Como resultado, se obtienen los siguientes vectores vecinos para Javascript (el n√∫mero es la distancia del coseno): <br><br><img src="https://habrastorage.org/webt/lf/q0/4q/lfq04qjp4fcygqjikgy0zq9av8y.png"><br><br>  El ID y LIT agregados al principio indican si el token es un identificador (nombre de una variable, m√©todo) o un literal (constante).  Se puede ver que la proximidad es significativa. <br><br><h3>  Clasificador de entrenamiento </h3><br>  Habiendo recibido una vectorizaci√≥n para tokens individuales, obtener una vista de un fragmento de c√≥digo con un posible error es bastante simple: es una concatenaci√≥n de vectores importantes para la clasificaci√≥n de tokens.  Un perceptr√≥n de dos capas est√° entrenado en piezas de c√≥digo con ReLU como funci√≥n de activaci√≥n y ca√≠da para reducir el sobreajuste.  El aprendizaje converge r√°pidamente, el modelo resultante es peque√±o y puede hacer predicciones para cientos de ejemplos por segundo.  Esto le permite usarlo en tiempo real, lo cual se discutir√° m√°s adelante. <br><br><h3>  Resultados </h3><br>  La evaluaci√≥n de calidad del clasificador resultante se dividi√≥ en dos partes: una evaluaci√≥n en un gran n√∫mero de ejemplos generados artificialmente y verificaci√≥n manual en un peque√±o n√∫mero (50 para cada detector) de ejemplos con la mayor probabilidad pronosticada.  Los resultados para los tres detectores (argumentos reorganizados, la correcci√≥n del operador binario y el operando binario) fueron los siguientes: <br><br><img src="https://habrastorage.org/webt/n9/f5/sm/n9f5smfdvj55bw3qeb-l_y9jub0.png"><br><br>  Algunos de los errores predichos ser√≠an dif√≠ciles de encontrar con los m√©todos de b√∫squeda cl√°sicos.  Un ejemplo con res reorganizado y err en una llamada a p.done: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> (); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( promises === <span class="hljs-literal"><span class="hljs-literal">null</span></span> || promises . length === <span class="hljs-number"><span class="hljs-number">0</span></span>) { p. done (error , result ) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { promises [<span class="hljs-number"><span class="hljs-number">0</span></span>](error, result).then( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, err</span></span></span><span class="hljs-function">) </span></span>{ p.done(res, err); }); }</code> </pre><br>  Tambi√©n hubo ejemplos en los que no hubo error, pero las variables se deben cambiar de nombre para no confundir a la persona que intenta descifrar el c√≥digo.  Por ejemplo, agregar ancho y cada uno no parece ser una buena idea, aunque result√≥ no ser un error: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cw = cs[i].width + each;</code> </pre><br><h3>  Python porting </h3><br>  Particip√© en la transferencia del trabajo de Michael Pradel de js a python, y luego cre√© un complemento para PyCharm que implementa inspecciones basadas en el m√©todo anterior.  Utilizamos el conjunto de datos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Python 150K</a> (150 mil archivos Python disponibles en GitHub). <br><br>  Primero, result√≥ que en Python hay m√°s tokens diferentes que en javascript.  Para js, los 10,000 tokens m√°s populares representaron m√°s del 90% de todos los encontrados, mientras que para Python fue necesario usar alrededor de 40,000, lo que condujo a un aumento en el tama√±o de los tokens en los vectores, lo que dificult√≥ la transferencia al complemento. <br><br>  En segundo lugar, habiendo implementado para Python una b√∫squeda de argumentos incorrectos en las llamadas de funci√≥n y mirando los resultados manualmente, obtuve una tasa de error de m√°s del 90%, que estaba en desacuerdo con los resultados para js.  Habiendo entendido las razones, result√≥ que en javascript se declararon m√°s funciones en el mismo archivo que sus llamadas.  Yo, siguiendo el ejemplo del autor del art√≠culo, al principio no permit√≠ la declaraci√≥n de funciones de otros archivos, lo que condujo a malos resultados. <br><br>  Hacia finales de agosto, complet√© la implementaci√≥n de Python y escrib√≠ la base del complemento.  El complemento contin√∫a desarroll√°ndose, ahora la estudiante Anastasia Tuchina de nuestro laboratorio se dedica a esto. <br><br>  Puede encontrar los pasos para probar c√≥mo funciona el complemento en el wiki del repositorio. <br><br>  Enlaces en github: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Repositorio con implementaci√≥n de python</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Repositorio con plugin</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es434368/">https://habr.com/ru/post/es434368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es434356/index.html">Python Stiller con correo electr√≥nico</a></li>
<li><a href="../es434358/index.html">Sustituci√≥n de importaciones de sistemas operativos. ¬øC√≥mo veo el sistema operativo dom√©stico?</a></li>
<li><a href="../es434360/index.html">Charla explicada sobre programaci√≥n asincr√≥nica en Javascript</a></li>
<li><a href="../es434362/index.html">NO pronosticado para 2019</a></li>
<li><a href="../es434364/index.html">Hangfire Queue Support</a></li>
<li><a href="../es434370/index.html">Otro conquistador de la sombra en Phaser, o el uso de bicicletas.</a></li>
<li><a href="../es434374/index.html">Comprobaci√≥n de RBAC en Kubernetes</a></li>
<li><a href="../es434380/index.html">Conceptos b√°sicos de inyecci√≥n de dependencia</a></li>
<li><a href="../es434382/index.html">Portar Alpine Linux a RISC-V</a></li>
<li><a href="../es434384/index.html">Sobre la responsabilidad de los artistas int√©rpretes o ejecutantes.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>