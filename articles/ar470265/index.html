<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐐 🍌 🤷🏼 C ++ اختصار ورقة الغش وأكثر من ذلك. الجزء 1: C ++ 🖖🏻 👹 🕊️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="بمجرد أن تمت مقابلتي لشغل منصب C ++ Developer في مكتب واحد لائق وحتى معروف. سبق لي أن اكتسبت بعض الخبرة ، حتى أني كنت أعتبر مطورًا رائدًا في صاحب العم...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ اختصار ورقة الغش وأكثر من ذلك. الجزء 1: C ++</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470265/" style=";text-align:right;direction:rtl">  بمجرد أن تمت مقابلتي لشغل منصب C ++ Developer في مكتب واحد لائق وحتى معروف.  سبق لي أن اكتسبت بعض الخبرة ، حتى أني كنت أعتبر مطورًا رائدًا في صاحب العمل في ذلك الوقت.  لكن عندما سئل عما إذا كنت أعرف أشياء مثل DRY ، KISS ، YAGNI ، NIH ، كان علي الإجابة "لا" مرارًا وتكرارًا. <br><br>  لقد فشلت فشلا ذريعا ، بالطبع.  ولكن بعد ذلك تم اختصار الاختصارات أعلاه وتذكرها.  عندما قرأت مقالات وكتبًا مواضيعية ، وأعدت للمقابلات ، وتحدثت للتو مع زملائي ، تعلمت المزيد من الأشياء الجديدة ، ونسيتها ، وغوغل مرة أخرى وفهمتها.  قبل شهرين ، ذكر أحد زملائي عرضًا في دردشة العمل التي أجراها معهد IIFE في سياق C ++.  مثل هذا الجد في مزحة ، كدت أنزل عن الموقد ودخلت Google مرة أخرى. <br><br><img src="https://habrastorage.org/webt/i7/7u/fc/i77ufc8-ui3-rtrvpu-421lmpfq.png"><br><a name="habracut"></a><br>  بعد ذلك قررت أن أؤلف (بشكل أساسي لنفسي) ورقة غش للاختصارات المفيدة لمطور C ++ لمعرفتها.  هذا لا يعني أنها تنطبق فقط على C ++ ، أو أنها كلها مفاهيم من C ++ (يمكنك كتابة مجلدات حول التعابير اللغوية).  لا ، هذه فقط مفاهيم واجهتها بالفعل في العمل والمقابلات ، وعادة ما يتم التعبير عنها في شكل اختصارات.  حسنًا ، فاتني أشياء تافهة تمامًا مثل LIFO و FIFO و CRUD و OOP و GCC و MSVC. <br><br>  ومع ذلك ، ظهرت الاختصارات بشكل لائق ، لذلك قمت بتقسيم ورقة الغش إلى جزأين: تتميز بقوة C ++ وأكثر شيوعًا.  عندما كان ذلك مناسبًا ، قمت بتجميع المفاهيم معًا ، وإلا فسردتها أبجديًا.  بشكل عام ، ليس هناك معنى كبير في ترتيبها. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الأشياء الأساسية:</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ODR</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">POD</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">POF</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">PIMPL</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">RAII</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">RTTI</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المحكمة الخاصة بلبنان</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">UB</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">التفاصيل الدقيقة للغة:</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ADL</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">CRTP</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">CTAD</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">EBO</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">IIFE</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">NVI</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">RVO و NRVO</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">SFINAE</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">SBO ، SOO ، SSO</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><b>UPDATE:</b></a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">السيرة الذاتية</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">LTO</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">PCH</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">PGO</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">SEH / VEH</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">TMP</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">VLA</a> <br><br><h2 style=";text-align:right;direction:rtl">  الأشياء الأساسية <a name="Basics"></a></h2><br><h3 style=";text-align:right;direction:rtl">  ODR <a name="ODR"></a></h3><br>  <i>قاعدة تعريف واحدة.</i>  <i>حكم تعريف واحد.</i>  المبسطة تعني ما يلي: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  ضمن وحدة ترجمة واحدة ، لا يمكن أن يكون لكل متغير أو وظيفة أو فصل دراسي ، وما إلى ذلك ، أكثر من تعريف واحد.  هناك أكبر عدد ممكن من الإعلانات (باستثناء عمليات النقل بدون نوع أساسي معين ، والتي لا يمكن التصريح عنها دون تعريف) ، ولكن ليس أكثر من تعريف واحد.  أقل ممكن إذا لم يتم استخدام الكيان. </li><li style=";text-align:right;direction:rtl">  خلال البرنامج بالكامل ، يجب أن يكون لكل وظيفة غير مضمنة ومتغير مستخدم تعريف واحد تمامًا.  يجب أن يكون لكل وظيفة مضمّنة ومتغير مستخدم تعريف واحد في كل وحدة ترجمة. </li><li style=";text-align:right;direction:rtl">  يمكن أن تحتوي بعض الكيانات - على سبيل المثال ، الفئات والوظائف المضمّنة والمتغير والقوالب والأعداد وما إلى ذلك - على العديد من التعريفات في البرنامج (ولكن ليس أكثر من تعريف في وحدة الترجمة).  في الواقع ، يحدث هذا عندما يكون الرأس نفسه الذي يحتوي على فئة مطبقة بالكامل ، على سبيل المثال ، متصلاً بعدة ملفات .cpp.  لكن يجب أن تتزامن هذه التعريفات (أنا أبسطها كثيرًا ، لكن الجوهر هو هذا).  وإلا سيكون <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">UB</a> . </li></ul><br>  سيقوم المترجم <i>بقبض</i> انتهاك <i>ODR</i> بسهولة داخل وحدة الترجمة.  لكنه لن يكون قادرًا على فعل أي شيء في حالة انتهاك القاعدة على نطاق البرنامج - فقط لأن المترجم يعالج وحدة ترجمة واحدة في كل مرة. <br><br>  يمكن للرابط أن يجد المزيد من الانتهاكات ، ولكن ، بصرامة ، ليس مضطرًا للقيام بذلك (لأنه ، وفقًا للمعيار ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">UB موجود</a> هنا) ويمكنه تفويت شيء ما.  بالإضافة إلى ذلك ، فإن عملية البحث عن انتهاكات <i>ODR</i> في مرحلة الربط لها تعقيد من الدرجة الثانية ، وتجميع C ++ code ليس بهذه السرعة. <br><br>  نتيجة لذلك ، فإن المسؤولية الرئيسية عن الامتثال لهذه القاعدة (خاصة على مستوى البرنامج) هي المطور نفسه.  ونعم - يمكن فقط للكيانات التي لها رابط خارجي أن تنتهك <i>ODR</i> على نطاق البرنامج ؛  لا يشارك الأشخاص من الداخل (أي المعرّفين في مساحات أسماء مجهولة) في هذا الكرنفال. <br><br>  اقرأ المزيد: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مرة</a> واحدة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">(الإنجليزية)</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اثنان (الإنجليزية)</a> <br><br><h3 style=";text-align:right;direction:rtl">  POD <a name="POD"></a></h3><br>  <i>سهل البيانات القديمة.</i>  <i>بنية بيانات بسيطة.</i>  أبسط تعريف: هذا هو الهيكل الذي يمكنك ، كما هو ، في شكل ثنائي إرسال / استقبال من مكتبة C.  أو ، وهو نفسه ، نسخ صحيح مع <code>memcpy</code> بسيطة. <br><br>  من قياسي إلى قياسي ، تغير التعريف الكامل بالتفصيل.  آخر C ++ 17 <i>POD</i> يحدد حاليا كيف <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  نوع العددية </li><li style=";text-align:right;direction:rtl">  أو فئة / هيكل / اتحاد: <br>  - هناك فئة تافهة <br>  - هناك فئة مع جهاز قياسي <br>  - لا يحتوي على حقول غير ثابتة <i>POD</i> <br></li><li style=";text-align:right;direction:rtl">  أو مجموعة من هذه الأنواع </li></ul><br>  فئة تافهة: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لم يحذف واحد على الأقل: <br>  - المنشئ الافتراضي <br>  - نسخة منشئ <br>  - منشئ متحرك <br>  - نسخة مشغل الاحالة <br>  - نقل مشغل الاحالة <br></li><li style=";text-align:right;direction:rtl">  جميع المنشئات الافتراضية التي تقوم بنسخ ونقل المنشئات ومشغلي المهام تافهة (مبسطة - تم إنشاؤها بواسطة المترجم) أو عن بعد </li><li style=";text-align:right;direction:rtl">  لديه التدمير تافهة غير عن بعد </li><li style=";text-align:right;direction:rtl">  جميع الأنواع الأساسية وجميع حقول أنواع الطبقات لها مدمرات تافهة </li><li style=";text-align:right;direction:rtl">  لا توجد طرق افتراضية (بما في ذلك المدمر) </li><li style=";text-align:right;direction:rtl">  لا توجد أنواع قاعدة افتراضية </li></ul><br>  فئة مع جهاز قياسي (فئة تخطيط قياسي): <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لا توجد طرق افتراضية </li><li style=";text-align:right;direction:rtl">  لا توجد أنواع قاعدة افتراضية </li><li style=";text-align:right;direction:rtl">  لا توجد حقول ارتباط غير ثابتة </li><li style=";text-align:right;direction:rtl">  جميع الحقول غير الثابتة لها نفس معدل الوصول (عام / محمي / خاص) </li><li style=";text-align:right;direction:rtl">  جميع الحقول غير الساكنة والفئات الأساسية هي أيضًا أنواع بجهاز قياسي </li><li style=";text-align:right;direction:rtl">  يتم الإعلان عن جميع الحقول غير الثابتة للفئة نفسها وجميع أسلافها في فصل واحد (أي في الفصل نفسه أو في أحد الأسلاف) </li><li style=";text-align:right;direction:rtl">  لا يرث نفس النوع مرتين ، أي أنه من المستحيل القيام بذلك: <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> :</span></span> A{}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> B, C {};</code> </pre> </li><li style=";text-align:right;direction:rtl">  نوع الحقل غير الثابت الأول ، أو إذا كان صفيفًا ، يجب ألا يتطابق نوع العنصر الخاص به مع أي من الأنواع الأساسية (بسبب <i>EBO</i> الإلزامي في هذه الحالة) </li></ul><br>  ومع ذلك ، في C ++ 20 لن يكون هناك مفهوم لنوع <i>POD</i> ، فقط النوع التافه والنوع مع الجهاز القياسي سيبقيان. <br><br>  اقرأ المزيد: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">واحد (الروسية)</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">واثنان (الإنجليزية)</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وثلاثة (الإنجليزية)</a> <br><br><h3 style=";text-align:right;direction:rtl">  ميناء الفجيرة <a name="POF"></a></h3><br>  <i>وظيفة القديمة عادي.</i>  <i>وظيفة بسيطة على غرار C.</i> مذكورة في المعيار قبل C ++ 14 شاملة فقط في سياق معالجات الإشارات.  متطلبات ذلك هي: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يستخدم فقط الأشياء الشائعة بين C و C ++ (على سبيل المثال لا استثناءات <code>try-catch</code> ، على سبيل المثال) </li><li style=";text-align:right;direction:rtl">  لا يتسبب بشكل مباشر أو غير مباشر في وظائف غير <i>POF</i> ، باستثناء العمليات الخالية من الكتلة الذرية ( <code>std::atomic_init</code> ، <code>std::atomic_fetch_add</code> ، إلخ) </li></ul><br>  فقط هذه الوظائف ، التي لها أيضًا ارتباط C ( <code>extern "C"</code> ) ، مسموح بها بواسطة المعيار لاستخدامها كمعالجات إشارات.  يعتمد دعم الوظائف الأخرى على المترجم. <br><br>  في C ++ 17 ، يختفي مفهوم <i>POF</i> ، بدلاً من ذلك يظهر تقييمًا آمنًا للإشارات.  في مثل هذه الحسابات محظورة: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يدعو إلى جميع وظائف المكتبة القياسية ، باستثناء ذرية ، وخالية من قفل </li><li style=";text-align:right;direction:rtl">  <code>new</code> <code>delete</code> المكالمات </li><li style=";text-align:right;direction:rtl">  باستخدام <code>dynamic_cast</code> </li><li style=";text-align:right;direction:rtl">  استدعاء إلى <code>thread_local</code> الكيان </li><li style=";text-align:right;direction:rtl">  أي عمل مع استثناءات </li><li style=";text-align:right;direction:rtl">  تهيئة متغير ثابت محلي </li><li style=";text-align:right;direction:rtl">  انتظار تهيئة متغير ثابت لإكمال </li></ul><br>  في حالة قيام معالج الإشارة بأي مما سبق ، يعد المعيار <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">UB</a> . <br><br>  اقرأ المزيد: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الوقت (الإنجليزية)</a> <br><br><h3 style=";text-align:right;direction:rtl">  PIMPL <a name="PIMPL"></a></h3><br>  <i>المؤشر إلى التنفيذ.</i>  <i>مؤشر التنفيذ.</i>  المصطلح الكلاسيكي في لغة C ++ ، والمعروف أيضًا باسم d-pointer ، المؤشر غير شفاف ، جدار الحماية المترجم.  يتكون في حقيقة أن كل الطرق الخاصة والحقول وتفاصيل التنفيذ الأخرى لفئة معينة يتم تخصيصها في فصل منفصل ، والطرق العامة فقط (على سبيل المثال ، واجهة) ومؤشر لمثيل هذه الفئة المنفصلة الجديدة تبقى في الفصل الأصلي.  على سبيل المثال: <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">foo.hpp</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Foo(); ~Foo(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doThis</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doThat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Impl&gt; pImpl_; };</code> </pre> <br></div></div><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">foo.cpp</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"foo.hpp"</span></span></span><span class="hljs-meta"> class Foo::Impl { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// implementation }; Foo::Foo() : pImpl_(std::make_unique&lt;Impl&gt;()) {} Foo::~Foo() = default; void Foo::doThis() { pImpl_-&gt;doThis(); } int Foo::doThat() { return pImpl_-&gt;doThat(); }</span></span></span></span></code> </pre> <br></div></div><br>  لماذا هذا ضروري ، أي المزايا: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  التغليف: يحصل مستخدمو الفصل من خلال اتصال الرأس على ما يحتاجون إليه فقط - واجهة عامة.  إذا تغيرت تفاصيل التنفيذ ، فلن يلزم إعادة ترجمة رمز العميل (انظر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ABI</a> ). </li><li style=";text-align:right;direction:rtl">  وقت التجميع: بما أن الرأس العام لا يعرف شيئًا عن التنفيذ ، فإنه لا يشمل الرؤوس الكثيرة التي يحتاجها.  وفقًا لذلك ، يتم تقليل عدد الرؤوس المتصلة ضمنيًا في رمز العميل.  يتم أيضًا تبسيط عملية البحث عن أسماء وتحميل الأحمال الزائدة ، لأن العنوان العام لا يحتوي على أعضاء خاصين (رغم أنهم خاصون ، إلا أنهم يشاركون في هذه العمليات). </li></ul><br>  السعر ، أي عيوبه: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  بالإضافة إلى إلغاء مؤشر واحد على الأقل بالإضافة إلى استدعاء دالة واحدة عند الوصول إلى الأساليب العامة. </li><li style=";text-align:right;direction:rtl">  يتم زيادة حجم فئة الذاكرة المطلوبة حسب حجم المؤشر. </li><li style=";text-align:right;direction:rtl">  يتم تخصيص جزء من هذه الذاكرة (على الأرجح أكبر) على الكومة ، مما يؤثر سلبًا أيضًا على الأداء. </li><li style=";text-align:right;direction:rtl">  الثبات المنطقي يمكن انتهاكه بسهولة.  على سبيل المثال ، يتم تجميع هذه التعليمات البرمجية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Foo::doThis() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { pImpl_-&gt;doThis(); <span class="hljs-comment"><span class="hljs-comment">// cosnt method pImpl_-&gt;doSmthElse(); // non-const method }</span></span></code> </pre> </li></ul><br>  بعض أوجه القصور هذه قابلة للإزالة ، لكن السعر يزيد من تعقيد الكود ويقدم مستويات إضافية من التجريد (انظر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">FTSE</a> ). <br><br>  اقرأ المزيد: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">واحد (روسي)</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">واثنان (روسي)</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وثلاثة (انجليزي)</a> <br><br><h3 style=";text-align:right;direction:rtl">  RAII <a name="RAII"></a></h3><br>  <i>اكتساب الموارد هو التهيئة.</i>  <i>التقاط مورد هو التهيئة.</i>  معنى هذا المصطلح هو أن الاحتفاظ بمورد معين يستمر طوال حياة الكائن المقابل.  يحدث التقاط المورد في وقت إنشاء / تهيئة الكائن ، والإطلاق - في وقت تدمير / الانتهاء من الكائن نفسه. <br><br>  من الغريب (في المقام الأول لمبرمجي C ++) ، يتم استخدام هذا المصطلح أيضًا بلغات أخرى ، حتى تلك التي تستخدم أداة تجميع مجمعي البيانات المهملة.  في Java ، يكون هناك <code>try--</code> ، في Python the statement ، في C # التوجيه <code>using</code> ، في Go the <code>defer</code> .  ولكن في C ++ مع العمر المتوقع للغاية للأجسام ، فإن <i>RAII</i> يناسب الكائنات <i>العضوية</i> بشكل خاص. <br><br>  في C ++ ، يتم عادةً التقاط مورد في المنشئ ويتم تحريره في المدمر.  على سبيل المثال ، تتحكم المؤشرات الذكية في الذاكرة بهذه الطريقة ، حيث تقوم تدفقات الملفات بإدارة الملفات ، وتؤدي مزامنة المزامنة إلى مزامنة المزامنة.  الجمال هو أنه بغض النظر عن كيفية خروج الكتلة (النطاق) - هل هو طبيعي من خلال أي من نقاط الخروج ، أو تم طرح استثناء - سيتم تدمير كائن التحكم في الموارد الذي تم إنشاؤه في هذه الكتلة ، وسيتم تحرير المورد.  أي  بالإضافة إلى تغليف <i>RAII</i> في C ++ ، فإنه يساعد أيضًا في ضمان الأمان بمعنى الاستثناءات. <br><br>  القيود ، حيث بدونها.  Destructors في C ++ لا تُرجع القيم بشكل قاطع ولا يجب رمي استثناءات.  وفقًا لذلك ، إذا كان إصدار المورد مصحوبًا بواحد أو آخر ، فسيكون من الضروري تطبيق منطق إضافي في المدمر الخاص بكائن التحكم. <br><br>  اقرأ المزيد: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مرة واحدة (الروسية)</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اثنان (الإنجليزية)</a> <br><br><h3 style=";text-align:right;direction:rtl">  RTTI <a name="RTTI"></a></h3><br>  <i>معلومات نوع وقت التشغيل.</i>  <i>تحديد الهوية في وقت التشغيل.</i>  هذه آلية للحصول على معلومات حول نوع الكائن أو التعبير في وقت التشغيل.  إنه موجود بلغات أخرى ، لكن في لغة C ++ يتم استخدامه من أجل: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <code>dynamic_cast</code> </li> <li style=";text-align:right;direction:rtl">  <code>typeid</code> و <code>type_info</code> </li><li style=";text-align:right;direction:rtl">  استثناء الصيد </li></ul><br>  أحد القيود المهمة: يستخدم <i>RTTI</i> جدول الوظائف الافتراضية ، وبالتالي لا يعمل إلا مع أنواع متعددة الأشكال (المدمر الظاهري كافٍ).  أحد التفسيرات المهمة: <code>dynamic_cast</code> و <code>typeid</code> لا تستخدمان <i>RTTI</i> دائمًا ، وبالتالي تعمل مع الأنواع غير متعددة الأشكال.  على سبيل المثال ، لإلقاء ارتباط ديناميكي على سليل إلى رابط أحد الأسلاف ، فإن <i>RTTI</i> ليست ضرورية ؛ كل المعلومات متوفرة في وقت الترجمة. <br><br>  <i>RTTI</i> ليس مجانيًا ، وإن كان قليلاً ، ولكنه يؤثر سلبًا على أداء وحجم الذاكرة المستهلكة (ومن هنا تأتي النصيحة المتكررة بعدم استخدام <code>dynamic_cast</code> بسبب بطئه).  لذلك ، يسمح لك برنامج التحويل البرمجي ، كقاعدة عامة ، بتعطيل <i>RTTI</i> .  يعد مجلس التعاون الخليجي و MSVC بأن هذا لن يؤثر على صحة الاستثناءات. <br><br>  اقرأ المزيد: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مرة واحدة (الروسية)</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اثنان (الإنجليزية)</a> <br><br><h3 style=";text-align:right;direction:rtl">  STL <a name="STL"></a></h3><br>  <i>مكتبة القوالب القياسية.</i>  <i>مكتبة القوالب القياسية.</i>  جزء من مكتبة C ++ القياسية التي توفر الحاويات العامة والتكرارات والخوارزميات ووظائف المساعد. <br><br>  على الرغم من اسمها المعروف ، فإن <i>STL</i> لم يطلق عليها في المعيار.  من أقسام المعيار ، يمكن أن تعزى <i>STL</i> بوضوح إلى مكتبة الحاويات ، ومكتبة التكرار ، ومكتبة الخوارزمية ، ومكتبة المرافق العامة جزئيًا. <br><br>  في التوصيف الوظيفي ، يمكنك غالبًا العثور على متطلبين منفصلين - معرفة لغة C ++ والألفة مع <i>STL</i> .  لم أفهم هذا أبدًا ، لأن <i>STL</i> جزء لا يتجزأ من اللغة منذ معيار 1998 الأول. <br><br>  اقرأ المزيد: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مرة واحدة (الروسية)</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اثنان (الإنجليزية)</a> <br><br><h3 style=";text-align:right;direction:rtl">  UB <a name="UB"></a></h3><br>  <i>سلوك غير محدد.</i>  <i>سلوك غير محدد.</i>  هذا السلوك في حالات الخطأ التي لا يوجد فيها متطلبات القياسية.  يتم سرد العديد من هذه صراحة في المعيار باعتبارها تؤدي إلى <i>UB</i> .  وتشمل هذه ، على سبيل المثال: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  انتهاك حدود مجموعة أو حاوية <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">STL</a> </li><li style=";text-align:right;direction:rtl">  استخدام متغير غير مهيأ </li><li style=";text-align:right;direction:rtl">  dereferencing مؤشر فارغة </li><li style=";text-align:right;direction:rtl">  وقعت عدد صحيح تجاوز </li></ul><br>  تعتمد نتيجة <i>UB</i> على كل شيء على التوالي - سواء على إصدار المترجم أو على الطقس على المريخ.  علاوة على ذلك ، يمكن أن تكون هذه النتيجة أي شيء: خطأ في الترجمة ، والتنفيذ الصحيح ، والتعطل.  السلوك غير المحدد هو الشر ، فمن الضروري التخلص منه. <br><br>  السلوك غير <i>المحدد</i> ، من ناحية أخرى ، لا ينبغي الخلط بينه وبين <i>السلوك غير المحدد</i> .  السلوك غير المحدد هو السلوك الصحيح للبرنامج الصحيح ، لكن الذي ، بإذن من المعيار ، يعتمد على المترجم.  والمترجم غير مطلوب لتوثيق ذلك.  على سبيل المثال ، هذا هو الترتيب الذي يتم به تقييم وسيطات دالة أو تفاصيل تطبيق <code>std::map</code> . <br><br>  حسنًا ، هنا يمكنك استدعاء السلوك المحدد بالتنفيذ.  من غير محدد يختلف في توافر الوثائق.  مثال: المحول البرمجي مجاني لجعل النوع <code>std::size_t</code> أي حجم ، ولكن يجب أن يشير إلى أي واحد. <br><br>  اقرأ المزيد: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">واحد (روسي)</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">واثنان (روسي)</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وثلاثة (انجليزي)</a> <br><br><h2 style=";text-align:right;direction:rtl">  الدقيقة من اللسان <a name="Cobwebs"></a></h2><br><h3 style=";text-align:right;direction:rtl">  ADL <a name="ADL"></a></h3><br>  <i>بحث يعتمد على الوسيطة.</i>  <i>بحث يعتمد على الوسيطة.</i>  إنه البحث عن كوينيج - على شرف أندرو كوينيج.  هذه مجموعة من القواعد لحل أسماء الوظائف غير المؤهلة (أي ، الأسماء بدون المشغل <code>::</code> :) ، بالإضافة إلى تحليل الاسم المعتاد.  ببساطة: يتم البحث عن اسم الوظيفة في مساحات الأسماء المتعلقة بوسائطها (هذه هي المساحة التي تحتوي على نوع الوسيطة ، والنوع نفسه ، إذا كان فئة ، وجميع أسلافها ، إلخ). <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">مثال أبسط</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; namespace N { struct S {}; void f(S) { std::cout &lt;&lt; "f(S)" &lt;&lt; std::endl; }; } int main() { N::S s; f(s); }</span></span></span></span></code> </pre> <br>  <code>f</code> العثور على الدالة <code>f</code> في مساحة الاسم <code>N</code> فقط لأن الوسيطة الخاصة بها تنتمي إلى هذه المساحة. <br></div></div><br>  حتى <code>std::cout &lt;&lt; "Hello World!\n"</code> التافهة <code>std::cout &lt;&lt; "Hello World!\n"</code> يستخدم <i>ADL</i> ، <code>std::basic_stream::operator&lt;&lt;</code> لا <code>std::basic_stream::operator&lt;&lt;</code> زائد على <code>const char*</code> .  لكن الوسيطة الأولى لهذا البيان هي <code>std::basic_stream</code> ، ويبحث المترجم ويجد حمل زائد مناسب في <code>std</code> . <br><br>  بعض التفاصيل: لا ينطبق <i>ADL</i> إذا وجد بحث منتظم إعلانًا لأحد أعضاء الفصل ، أو عن إعلان دالة في الكتلة الحالية دون استخدام أو إعلان لا دالة ولا قالب دالة.  أو إذا كان اسم الوظيفة موضحًا بين قوسين (المثال أعلاه لا يتم ترجمة مع <code>(f)(s)</code> ؛ سيتعين عليك كتابة <code>(N::f)(s);</code> ). <br><br>  في بعض الأحيان ، يفرض عليك <i>ADL</i> استخدام أسماء الوظائف المؤهلة بالكامل حيث يبدو الأمر غير ضروري. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">على سبيل المثال ، لا يتم ترجمة هذا الرمز</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> N1 { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S)</span></span></span><span class="hljs-function"> </span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> N2 { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(N1::S)</span></span></span><span class="hljs-function"> </span></span>{}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(N1::S s)</span></span></span><span class="hljs-function"> </span></span>{ foo(s); } }</code> </pre> <br></div></div><br>  اقرأ المزيد: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">واحد (الإنجليزية)</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اثنان (الإنجليزية)</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ثلاثة (الإنجليزية)</a> <br><br><h3 style=";text-align:right;direction:rtl">  CRTP <a name="CRTP"></a></h3><br>  <i>الغريب نموذج قالب المتكررة.</i>  <i>نمط العودية غريب.</i>  جوهر القالب كما يلي: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يرث بعض الفئة من فئة القالب </li><li style=";text-align:right;direction:rtl">  يتم استخدام الفئة المنحدرة كمعلمة قالب للفئة الأساسية الخاصة بها </li></ul><br>  من الأسهل إعطاء مثال: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived&gt; {};</code> </pre> <br>  <i>CRTP</i> هو مثال رئيسي على تعدد الأشكال الساكن.  توفر الفئة الأساسية واجهة ؛ وتوفر الفئات المشتقة تطبيقًا.  ولكن على عكس تعدد الأشكال العادي ، لا يوجد أي تكاليف لإنشاء واستخدام جدول من الوظائف الافتراضية. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">مثال</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;actionImpl(); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">staticPolymorphicHandler</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arg</span></span></span><span class="hljs-class">) {</span></span> arg.action(); }</code> </pre> <br>  عند استخدامها بشكل صحيح ، تكون <code>T</code> دائمًا من سليل <code>Base</code> ، لذلك يكفي <code>static_cast</code> .  نعم ، في هذه الحالة ، تعرف الفئة الأساسية الواجهة المنحدرة. <br></div></div><br>  مجال شائع آخر لاستخدام <i>CRTP</i> هو امتداد (أو تضييق) وظائف الفئات الموروثة (شيء يسمى mixin في بعض اللغات).  ولعل الأمثلة الأكثر شهرة: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> <code>struct Derived : singleton&lt;Derived&gt; { … }</code> </li> <li style=";text-align:right;direction:rtl"> <code>struct Derived : private boost::noncopyable&lt;Derived&gt; { … }</code> </li> <li style=";text-align:right;direction:rtl"> <code>struct Derived : std::enable_shared_from_this&lt;Derived&gt; { … }</code> </li> <li style=";text-align:right;direction:rtl">  <code>struct Derived : counter&lt;Derived&gt; { … }</code> - حساب عدد الكائنات التي تم إنشاؤها و / أو الموجودة </li></ul><br>  العيوب ، أو بالأحرى ، اللحظات التي تتطلب الانتباه: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لا توجد فئة أساسية شائعة ، لا يمكنك إنشاء مجموعة من أحفاد مختلفة والوصول إليها من خلال مؤشر إلى نوع الأساس.  ولكن إذا كنت تريد ، يمكنك أن ترث Base من النوع متعدد الأشكال المعتاد. </li><li style=";text-align:right;direction:rtl">  هناك فرصة إضافية لإخراج قدمك من الإهمال: <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">مثال</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived1</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived1&gt; {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived2</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived1&gt; {};</code> </pre> <br>  ولكن يمكنك إضافة الحماية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Base() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> T;</code> </pre> </div></div></li><li style=";text-align:right;direction:rtl">  لأن  نظرًا لأن جميع الأساليب غير افتراضية ، فإن أساليب السليل تخفي أساليب الفئة الأساسية التي تحمل نفس الأسماء.  لذلك ، من الأفضل أن ندعو لهم بشكل مختلف. </li><li style=";text-align:right;direction:rtl">  بشكل عام ، لدى الأحفاد طرق عامة لا ينبغي استخدامها في أي مكان باستثناء الفئة الأساسية.  هذا ليس جيدًا ، لكن يتم تصحيحه من خلال مستوى إضافي من التجريد (انظر <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">FTSE</a> ). </li></ul><br><br>  اقرأ المزيد: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مرة واحدة (الروسية)</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اثنان (الإنجليزية)</a> <br><br><h3 style=";text-align:right;direction:rtl">  CTAD <a name="CTAD"></a></h3><br>  <i>قالب حجة فئة الفصل.</i>  <i>استنتاج نوع المعلمة قالب الفئة تلقائياً.</i>  هذه ميزة جديدة من C ++ 17.  في السابق ، لم يتم عرض أنواع المتغيرات ( <code>auto</code> ) وقالب الدالة تلقائيًا تلقائيًا ، وهذا هو السبب في ظهور الوظائف المساعدة مثل <code>std::make_pair</code> ، <code>std::make_tuple</code> ، وما إلى ذلك. الآن ، في معظم الأحيان ، ليست هناك حاجة إليها ، لأن المترجم قادر على عرض معلمات قوالب الفصل تلقائيًا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// -&gt; std::pair&lt;int, double&gt; auto lck = std::lock_guard{mtx}; // -&gt; std::lock_guard&lt;std::mutex&gt;</span></span></code> </pre> <br>  <i>CTAD</i> هي فرصة جديدة ، لا تزال <i>بحاجة</i> إلى التطور والتطور (تعد C ++ 20 بالفعل بتحسينات).  القيود حتى الآن على النحو التالي: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">الاستدلال الجزئي لأنواع المعلمات غير مدعوم</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  std::tuple&lt;&gt; t{1, 2, 3}; // </span></span></code> </pre></div></div></li><li style=";text-align:right;direction:rtl"><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">الأسماء المستعارة للنموذج غير مدعومة</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPair</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:pair&lt;T, U&gt;; MyPair p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> </div></div></li><li style=";text-align:right;direction:rtl"><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">لا يتم دعم المنشئات المتوفرة فقط في تخصصات القوالب.</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span><span class="hljs-class">&lt;int&gt; {</span></span> Wrapper(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) {}; }; Wrapper w{<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> </div></div></li><li style=";text-align:right;direction:rtl"><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">القوالب المتداخلة غير مدعومة</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> {</span></span> Bar(T, U) {}; }; }; Foo::Bar x{ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Foo&lt;int&gt;::Bar x{1, 2.0}; // OK</span></span></code> </pre> </div></div></li><li style=";text-align:right;direction:rtl"><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">من الواضح ، لن يعمل CTAD إذا لم يكن نوع معلمة القالب مرتبطًا بوسائط المُنشئ.</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> {</span></span> Collection(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) {}; }; Collection c{<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> </div></div></li></ul><br>  في بعض الحالات ، سوف تساعد قواعد الاستدلال الصريح التي يجب الإعلان عنها في نفس الكتلة مثل قالب الفئة. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">مثال</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">It</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">It</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">from</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">It</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to</span></span></span><span class="hljs-class">) {</span></span>}; }; Collection c{v.begin(), v.end()}; <span class="hljs-comment"><span class="hljs-comment">//  template &lt;class It&gt; Collection(It, It)-&gt;Collection&lt;typename std::iterator_traits&lt;It&gt;::value_type&gt;; Collection c{v.begin(), v.end()}; //  OK</span></span></code> </pre> </div></div><br><br>  اقرأ المزيد: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مرة واحدة (الروسية)</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اثنان (الإنجليزية)</a> <br><br><h3 style=";text-align:right;direction:rtl">  EBO <a name="EBO"></a></h3><br>  <i>قاعدة فارغة الأمثل.</i>  <i>تعظيم الاستفادة من فئة أساسية فارغة.</i>  يُطلق عليها أيضًا تحسين فئة القاعدة الفارغة (EBCO). <br><br>  كما تعلم ، في C ++ ، لا يمكن أن يكون حجم كائن من أي فئة صفراً.  خلاف ذلك ، سيتم كسر كل حساب من المؤشرات ، لأنه في عنوان واحد سيكون من الممكن وضع علامة على العديد من الكائنات المختلفة كما تريد.  لذلك ، حتى كائنات الفئات الفارغة (أي الفئات التي لا تحتوي على حقل غير ثابت) لها حجم غير صفري ، والذي يعتمد على برنامج التحويل البرمجي ونظام التشغيل ويكون عادةً مساويًا لـ 1. <br><br>  وبالتالي ، تضيع الذاكرة عبثا على جميع الكائنات من الطبقات الفارغة.  ولكن ليس الكائنات من نسلهم ، لأنه في هذه الحالة المعيار يجعل صراحة استثناء.  لا يُسمح للمترجم بتخصيص ذاكرة لفئة أساسية فارغة ، وبالتالي لا يحفظ فقط بايت واحد من الفئة الفارغة ، ولكن أيضًا الكل 4 (حسب النظام الأساسي) ، نظرًا لوجود محاذاة أيضًا. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">مثال</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> :</span></span> Empty { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Empty) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; sizeof(Foo) &lt;&lt; std::endl; // 4 std::cout &lt;&lt; sizeof(int) &lt;&lt; std::endl; // 4</span></span></code> </pre> </div></div><br>  ولكن <i>نظرًا لأنه</i> لا يمكن وضع كائنات مختلفة من نفس النوع على نفس العنوان ، فلن يعمل <i>EBO</i> إذا: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">تم العثور على فئة فارغة مرتين بين الأجداد</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty2</span></span></span><span class="hljs-class"> :</span></span> Empty {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> :</span></span> Empty, Empty2 { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Empty) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; sizeof(Empty2) &lt;&lt; std::endl; // 1 std::cout &lt;&lt; sizeof(Foo) &lt;&lt; std::endl; // 8</span></span></code> </pre> </div></div></li><li style=";text-align:right;direction:rtl"><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">أول حقل غير ثابت هو كائن من نفس الفئة الفارغة أو سليلها</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> :</span></span> Empty { Empty e; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Empty) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; sizeof(Foo) &lt;&lt; std::endl; // 8</span></span></code> </pre> </div></div></li></ul><br>  في الحالات التي تكون فيها كائنات الفئات الفارغة عبارة عن حقول غير ثابتة ، لا يتم توفير تحسينات (في الوقت الحالي ، <code>[[no_unique_address]]</code> السمة <code>[[no_unique_address]]</code> في C ++ 20).  لكن إنفاق 4 بايت (أو ما يحتاج إليه المترجم) لكل حقل من هذا القبيل هو عار ، لذلك يمكنك "طي" كائنات الفئات الفارغة مع أول حقل غير ثابت فارغ في منطقتك. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">مثال</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty1</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty2</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Member</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyOptimization</span></span></span><span class="hljs-class"> :</span></span> Empty ... { Member member; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> EmptyOptimization&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, Empty1, Empty2&gt; data; };</code> </pre> <br>  غريب ، ولكن في هذه الحالة ، يختلف حجم Foo عن المترجمين المختلفين ، أما MSVC 2019 فهو 8 ، وبالنسبة لخليج GCC 8.3.0 هو 4. لكن على أي حال ، فإن زيادة عدد الفئات الفارغة لا يؤثر على حجم <code>Foo</code> . </div></div><br>  اقرأ المزيد: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مرة</a> واحدة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">(الإنجليزية)</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اثنان (الإنجليزية)</a> <br><br><h3 style=";text-align:right;direction:rtl">  IIFE <a name="IIFE"></a></h3><br>  <i>استدعاء دالة فورًا.</i>  <i>التعبير الوظيفي يسمى على الفور.</i>  بشكل عام ، هذا هو المصطلح في JavaScript ، حيث استعاره Jason Turner من الاسم.  في الواقع ، إنه مجرد إنشاء lambda واستدعائه على الفور: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> myVar = [&amp;] { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition1()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> computeSomeComplexStuff(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> condition2() ? computeSonethingElse() : DEFAULT_VALUE; } ();</code> </pre> <br>  لماذا هذا ضروري؟  حسنًا ، على سبيل المثال ، كما في التعليمة البرمجية أعلاه من أجل تهيئة ثابت من خلال حساب غير تافهي وليس تسد النطاق مع المتغيرات والوظائف غير الضرورية. <br><br>  اقرأ المزيد: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مرة</a> واحدة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">(الإنجليزية)</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اثنان (الإنجليزية)</a> <br><br><h3 style=";text-align:right;direction:rtl">  NVI <a name="NVI"></a></h3><br>  <i>واجهة غير افتراضية.</i>  <i>واجهة غير افتراضية.</i>  وفقًا لهذا المصطلح ، يجب ألا تحتوي واجهة الطبقة المفتوحة على وظائف افتراضية.  جميع الوظائف الافتراضية تكون خاصة (محميّة إلى أقصى حد) وتُسمى بالداخل غير الظاهري. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">مثال</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Base() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// check precondition fooImpl(); // check postconditions } private: virtual void fooImpl() = 0; }; class Derived : public Base { private: void fooImpl() override { } };</span></span></code> </pre> </div></div><br>  لماذا هذا ضروري: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تقوم كل وظيفة افتراضية مفتوحة بعمل شيئين: فهي تحدد الواجهة العامة للفصل وتشارك في السلوك الغالب في الفصول التناسلية.  استخدام <i>NVI</i> يلغي مثل هذه الوظائف مع تحميل مزدوج: يتم تعريف الواجهة من قبل بعض الوظائف ، وتغيير السلوك من قبل الآخرين.  يمكنك تغيير كل منهما بشكل مستقل عن بعضها البعض. </li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذا كانت هناك بعض المتطلبات العامة لجميع الخيارات لتنفيذ وظيفة افتراضية (قبل الشيكات السابقة واللاحقة ، والتقاط المزج ، وما إلى ذلك) ، فمن الملائم للغاية تجميعها في مكان واحد (انظر </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DRY</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - في الفئة الأساسية - ومنع الورثة من تجاوز هذا السلوك.</font></font> أي<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> اتضح حالة خاصة لطريقة قالب النمط. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إن رسوم استخدام </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هي بعض التورمات في الكود ، وانخفاض محتمل في الأداء (بسبب استدعاء طريقة إضافية واحدة) وزيادة التعرض لمشكلة فئة أساسية هشة (انظر </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اقرأ المزيد: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مرة</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> واحدة </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;">(الإنجليزية)</font></a><font style="vertical-align: inherit;"> ، </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اثنان (الإنجليزية)</font></font></a> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RVO و NRVO </font></font><a name="RVO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(الاسم) عائد القيمة الأمثل. </font><font style="vertical-align: inherit;">تحسين قيمة الإرجاع (المسماة). </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هذه حالة خاصة لاستخراج النسخ يسمح بها المعيار - يمكن للمترجم أن يتجاهل نسخًا غير ضرورية من الكائنات المؤقتة ، حتى إذا كان لمنشئيها ومدمراتها تأثيرات جانبية واضحة. </font><font style="vertical-align: inherit;">يكون هذا التحسين مسموحًا به عندما تقوم الدالة بإرجاع كائن حسب القيمة (الحالات الأخرى المسموح بها في نسخ النسخة هي رمي الاستثناءات والتقاطها).</font></font><br><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مثال</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Foo(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f = bar(); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بدون </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، سيتم إنشاء كائن مؤقت </font></font><code>Foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في الوظيفة </font><font style="vertical-align: inherit;">هنا </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، ثم من خلال مُنشئ النسخ ، سيتم إنشاء كائن مؤقت آخر في الوظيفة منه </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(للحصول على النتيجة </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) ، وعندئذٍ فقط سيتم إنشاء الكائن وسيتم </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تعيين قيمة الكائن المؤقت الثاني إليها. </font><font style="vertical-align: inherit;">تتخلص </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> من كل هذه النسخ والواجبات ، </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وتخلق </font><font style="vertical-align: inherit;">الوظيفة </font><font style="vertical-align: inherit;">مباشرة </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يحدث مثل هذا: وظيفة </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يخصص مساحة لكائن في إطار المكدس الخاص به </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. تمكن الوظيفة </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(التي تعمل بالفعل في إطارها) من الوصول إلى هذه الذاكرة المخصصة في الإطار السابق وإنشاء الكائن المطلوب هناك. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يختلف عن</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يقوم </font><i><font style="vertical-align: inherit;">RVO</font></i><font style="vertical-align: inherit;"> بنفس التحسين ، لكن ليس عند إنشاء الكائن في التعبير </font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، ولكن عندما يتم إرجاع الكائن الذي تم إنشاؤه مسبقًا في الوظيفة.</font></font><br><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مثال</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على الرغم من الفارق الصغير الظاهر ، إلا أن </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يصعب تنفيذه ، وبالتالي فهو لا يعمل في كثير من الحالات. </font><font style="vertical-align: inherit;">على سبيل المثال ، إذا قامت دالة بإرجاع كائن </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عمومي</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> أو </font><i><font style="vertical-align: inherit;">إحدى وسائطه</font></i><font style="vertical-align: inherit;"> ، أو إذا كان للدالة عدة نقاط خروج وتم إرجاع كائنات مختلفة من خلالها ، </font><font style="vertical-align: inherit;">فلن يتم تطبيق </font><i><font style="vertical-align: inherit;">NRVO</font></i><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO لا يعمل هنا</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> condition)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) { Foo f1; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f1; } Foo f2; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f2; }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تقريبا جميع المجمعين قد دعمت طويلة </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">يمكن أن تختلف </font><font style="vertical-align: inherit;">درجة دعم </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> من مترجم إلى مترجم ومن إصدار إلى آخر. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> و </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هي مجرد تحسينات. وعلى الرغم من عدم نسخ نسخ المُنشئ ومشغل المهمة ، إلا أنهما يجب أن يكونا في فئة الكائن. لقد تغيرت القواعد قليلاً في C ++ 17: الآن </font><font style="vertical-align: inherit;">لا يعتبر </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> نسخة elision ، فقد أصبح إلزاميًا ، وليست هناك حاجة إلى المُنشئ المقابل ومشغل التعيين. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ملاحظة: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(N) RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بعبارات ثابتة هو موضوع زلق. حتى C ++ 14 ضمنيًا ، لم يُقال شيئًا عن ذلك ، تتطلب C ++ 17 </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> في مثل هذه التعبيرات ، ويحظر C ++ 20 القادم.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بضع كلمات حول العلاقة مع دلالات النزوح. </font><font style="vertical-align: inherit;">أولا ، </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(N) RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لا يزال أكثر فعالية ، ل </font><font style="vertical-align: inherit;">لا حاجة لاستدعاء الخطوة منشئ والمدمرة. </font><font style="vertical-align: inherit;">ثانياً ، إذا بدلاً </font></font><code>result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من العودة من نفس الوظيفة </font></font><code>std::move(result)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، فإن </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يضمن عدم العمل. </font><font style="vertical-align: inherit;">لإعادة صياغة المعيار: </font><font style="vertical-align: inherit;">ينطبق </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> على القيمة ، </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ينطبق NRVO على القيمة</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، وهي </font></font><code>std::move(result)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عبارة عن قيمة xvalue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اقرأ المزيد: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">واحد (الإنجليزية)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اثنان (الإنجليزية)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ثلاثة (الإنجليزية)</font></font></a> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SFINAE </font></font><a name="SFINAE"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">فشل الإحلال ليس خطأ. </font><font style="vertical-align: inherit;">الاستبدال الفاشل ليس خطأ. </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هي ميزة لعملية إنشاء مثيل للقوالب - وظائف وفئات - في C ++. </font><font style="vertical-align: inherit;">خلاصة القول هي أنه إذا تعذّر إنشاء قالب معين ، فلن يعتبر ذلك خطأً إذا كانت هناك خيارات أخرى. </font><font style="vertical-align: inherit;">على سبيل المثال ، تعمل خوارزمية مبسطة لاختيار التحميل الزائد للوظائف الأكثر ملائمة مثل:</font></font><br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تم حل اسم الوظيفة - يبحث المترجم عن جميع الوظائف بالاسم المحدد في جميع مساحات الأسماء المحددة (انظر </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يتم تجاهل الوظائف غير الملائمة - وليس عدد الوسائط ، ولا يوجد تحويل ضروري لأنواع الوسائط ، ولم يكن من الممكن اشتقاق أنواع لقالب الوظيفة ، إلخ. </font></font></li><li style=";text-align:right;direction:rtl">          (viable functions),          .           —     . </li></ol><br>   <i>SFINAE</i>    :      ,        ,      ,    (  ).    . <br><br> <i>SFINAE</i>     , ,           .       -  , . . ,        . <br><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; template &lt;class, class = void&gt; struct HasToString : std::false_type {}; //    ,      //   -    ,  //     —  ,    ,   template &lt;class T&gt; struct HasToString&lt;T, std::void_t&lt;decltype(&amp;T::toString)&gt;&gt; : std::is_same&lt;std::string, decltype(std::declval&lt;T&gt;().toString())&gt; {}; struct Foo { std::string toString() { return {}; } }; int main() { std::cout &lt;&lt; HasToString&lt;Foo&gt;::value &lt;&lt; std::endl; // 1 std::cout &lt;&lt; HasToString&lt;int&gt;::value &lt;&lt; std::endl; // 0 }</span></span></span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إن ما ظهر في C ++ 17 </font></font><code>static if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قد يحل في بعض الحالات محل </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، والمفاهيم المتوقعة في C ++ 20 ستجعلها غير ضرورية. </font><font style="vertical-align: inherit;">لنرى. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اقرأ المزيد: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(. روس) وقت</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اثنان (المهندس)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ثلاثة (المهندس)</font></font></a> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SBO ، SOO ، SSO </font></font><a name="SBO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عازلة صغيرة / كائن / سلسلة الأمثل. </font><font style="vertical-align: inherit;">تعظيم الاستفادة من المخازن المؤقتة الصغيرة / الكائنات / الخطوط. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أحيانًا </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم استخدام SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بمعنى تحسين الحجم الصغير ، ولكن نادرًا ما نفترض ، لذلك نفترض أن </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO تدور</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> حول سلاسل. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> و </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هي مرادفات ببساطة ، و </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هي الحالة الخاصة الأكثر شهرة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">جميع هياكل البيانات التي تستخدم الذاكرة الديناميكية تشغل بالتأكيد مكانًا في المجموعة. </font><font style="vertical-align: inherit;">على الأقل من أجل تخزين مؤشر لمجموعة. </font><font style="vertical-align: inherit;">وجوهر هذه التحسينات ليس طلب ذاكرة من الكومة للأجسام الصغيرة نسبيا (وهي مكلفة نسبيا) ، ولكن لوضعها في مساحة مكدس مخصصة بالفعل. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على سبيل المثال ، يمكن تنفيذ std :: string مثل هذا:</font></font><br><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مثال</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* begin_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> capacity_; };</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> حجم هذه الفئة ، أحصل على 24 بايت (يعتمد على المترجم والنظام الأساسي). </font></font> أي<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سلاسل لا تزيد عن 24 حرفا يمكن وضعها على المكدس. </font><font style="vertical-align: inherit;">في الواقع ، ليس حتى 24 ، بالطبع ، لأنه من الضروري التمييز بطريقة ما بين الموضع على المكدس وعلى الكومة. </font><font style="vertical-align: inherit;">ولكن هنا هي أبسط طريقة لخطوط قصيرة تصل إلى 8 أحرف (بنفس الحجم - 24 بايت):</font></font><br><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مثال</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> Buffer { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* begin_; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> local_[<span class="hljs-number"><span class="hljs-number">8</span></span>]; }; Buffer buffer_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> _size; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> _capacity; };</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بالإضافة إلى عدم وجود مخصصات على الكومة ، هناك ميزة أخرى - وهي درجة عالية من محلية البيانات. </font><font style="vertical-align: inherit;">سيشغل صفيف أو متجه لهذه الكائنات المحسنة بالفعل قطعة متواصلة من الذاكرة فقط. </font><font style="vertical-align: inherit;">تستخدم </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">جميع التطبيقات تقريبًا </font><i><font style="vertical-align: inherit;">SSO</font></i><font style="vertical-align: inherit;"> وبعض التطبيقات على الأقل </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">ولكن </font><font style="vertical-align: inherit;">لم </font><font style="vertical-align: inherit;">يتم </font><font style="vertical-align: inherit;">تحسينها على الإطلاق بهذه الطريقة ، حيث أن المعيار يتطلب أنه </font><font style="vertical-align: inherit;">بالنسبة لاثنين من المتجهات لا يسبب نسخ أو تعيين عناصرها ، وأن تظل جميع التكرارات الصالحة صالحة. </font><font style="vertical-align: inherit;">سوف </font><i><font style="vertical-align: inherit;">SBO</font></i><font style="vertical-align: inherit;"> لا تسمح للوفاء بهذه المتطلبات ( </font><font style="vertical-align: inherit;">لأنها ليست). </font><font style="vertical-align: inherit;">ولكن </font><font style="vertical-align: inherit;">، كما قد تتخيل ، يستخدم </font><i><font style="vertical-align: inherit;">SBO</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">قراءة المزيد: </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;">الوقت (الإنجليزية)</font></a><font style="vertical-align: inherit;"> ،</font></font><code>std::string</code><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><code>std::function</code><font style="vertical-align: inherit;"></font><code>std::vector</code><font style="vertical-align: inherit;"></font><code>std::swap</code><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><code>std::string</code><font style="vertical-align: inherit;"></font><code>boost::container::small_vector</code><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اثنين (المهندس)</font></font></a> <br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UDPATE </font></font><a name="Update"></a></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بفضل </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PyerK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> على هذه القائمة الإضافية من الاختصارات.</font></font><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CV </font></font><a name="CV"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تصفيات مثل const ومتقلبة. </font></font></i> <code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يعني أنه لا يمكن تعديل الكائن / المتغير ، وستؤدي محاولة القيام بذلك إلى حدوث خطأ في وقت الترجمة أو في </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> في وقت التشغيل. </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يعني أن الكائن / المتغير يمكن أن يتغير بغض النظر عن تصرفات البرنامج (على سبيل المثال ، يملأ بعض المتحكم الدقيق شيئًا ما على الذاكرة) ، ويجب ألا يقوم المحول البرمجي بتحسين الوصول إليه. </font><font style="vertical-align: inherit;">الوصول إلى </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كائن ليس من خلال </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ارتباط أو مؤشر يؤدي أيضًا إلى </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اقرأ المزيد: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(. روس) وقت</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اثنان (المهندس)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ثلاثة (. روس)</font></font></a> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> عفرتو </font></font><a name="LTO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وصلة الوقت الأمثل. </font><font style="vertical-align: inherit;">رابط التحسين. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كما يوحي الاسم ، يحدث هذا التحسين أثناء الارتباط ، أي بعد التجميع. </font><font style="vertical-align: inherit;">يمكن للرابط أن يفعل شيئًا لم يجرؤ المترجم على القيام به: جعل بعض الوظائف مضمنة ، وطرح الكود والبيانات غير المستخدمة. </font><font style="vertical-align: inherit;">يزيد وقت الارتباط ، بالطبع. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اقرأ المزيد: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الوقت (الإنجليزية)</font></font></a> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PCH </font></font><a name="PCH"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">رؤوس المترجمة مسبقا. </font><font style="vertical-align: inherit;">رؤوس المترجمة مسبقا. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">غالبًا ما يتم تجميعها ، لكن نادراً ما يتم تجميع ملفات الرأس المعدلة مرة واحدة وحفظها في تنسيق برنامج التحويل البرمجي الداخلي. </font><font style="vertical-align: inherit;">وبالتالي ، سيستغرق إعادة تجميع المشروع وقتًا أقل ، وأحيانًا أقل. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اقرأ المزيد: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الوقت (روس).</font></font></a> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PGO </font></font><a name="PGO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ملف التعريف الموجه. </font><font style="vertical-align: inherit;">التحسين على أساس نتائج التنميط. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هذه طريقة لتحسين البرنامج ، ولكن ليس من خلال تحليل الشفرة الثابتة ، ولكن من خلال إطلاق برنامج الاختبار وجمع إحصائيات حقيقية. </font><font style="vertical-align: inherit;">على سبيل المثال ، يمكن تحسين الوظائف المتفرعة واستدعاء الوظائف بهذه الطريقة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اقرأ المزيد: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الوقت (روس).</font></font></a> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> سي / ه </font></font><a name="SEH"></a></h3><br> <i>Structured/Vectored Exception Handling.</i>   MSVC     .     <code>try-catch</code> <i>SEH</i>     : <code>__try</code> , <code>__except</code> , <code>__finally</code> ,       ,   ,     ,   -  ,      . . <i>VEH</i>     ,      . <br><br>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="> (.)</a> <br><br><h3 style=";text-align:right;direction:rtl"> TMP <a name="TMP"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قالب ميتا البرمجة. </font><font style="vertical-align: inherit;">metaprogramming قالب. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metaprogramming هو عندما يقوم أحد البرامج بإنشاء برنامج آخر نتيجة لعمله. </font><font style="vertical-align: inherit;">تطبيق القوالب في C ++ مثل metaprogramming. </font><font style="vertical-align: inherit;">يقوم مترجم القوالب بإنشاء العدد المطلوب للفئات أو الوظائف. </font><font style="vertical-align: inherit;">من المعروف أن </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TMP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> في C ++ مكتملة Turing ، أي أنه يمكن تنفيذ أي وظيفة عليها. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اقرأ المزيد: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الوقت (روس).</font></font></a> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VLA </font></font><a name="VLA"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">صفيف متغير الطول. </font><font style="vertical-align: inherit;">صفائف متغيرة الطول.</font></font></i>  أي<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> صفائف طولها غير معروف في وقت الترجمة: </font></font><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[n]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لا يسمح المعيار C ++ بهذا. </font><font style="vertical-align: inherit;">وهو أمر غريب إلى حد ما ، لأنها موجودة في C النقي منذ معيار C99. </font><font style="vertical-align: inherit;">ويدعمها بعض المترجمين C ++ امتداد. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اقرأ المزيد: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الوقت (روس).</font></font></a> <br><br><h2 style=";text-align:right;direction:rtl">  PS </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذا فاتني شيء ما أو كنت مخطئًا في مكان ما - اكتب التعليقات. </font><font style="vertical-align: inherit;">فقط تذكر ، من فضلك ، فقط الاختصارات المرتبطة مباشرة بـ C ++ مدرجة هنا. </font><font style="vertical-align: inherit;">للآخرين ، ولكن ليس أقل فائدة ، سيكون هناك وظيفة منفصلة. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الجزء الثاني</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar470265/">https://habr.com/ru/post/ar470265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar470247/index.html">RESHI.RU - روبوت يحل ويشرح مشاكل النص المدرسي في الرياضيات</a></li>
<li><a href="../ar470251/index.html">كيف فعلت تطبيق سطح المكتب على الرفرفة (+ المكافأة)</a></li>
<li><a href="../ar470255/index.html">تحسين محفظة السندات باستخدام ALGLIB</a></li>
<li><a href="../ar470257/index.html">عباءة حول ImmutableList في جاوة</a></li>
<li><a href="../ar470259/index.html">Aimybox في البحث: يحتاج إطار إنشاء المساعدين الصوتيين إلى معالج iOS</a></li>
<li><a href="../ar470267/index.html">رصد درجة الحرارة المعتمدة</a></li>
<li><a href="../ar470269/index.html">ReactOS 0.4.12: 华为 ， 你 认为 这个 怎么 样？</a></li>
<li><a href="../ar470271/index.html">F # 6: Tuples</a></li>
<li><a href="../ar470273/index.html">F # 7: السجلات</a></li>
<li><a href="../ar470275/index.html">F # 8: الاتحادات التمييزية</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>