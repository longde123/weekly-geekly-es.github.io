<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏽 👩🏾‍⚖️ ❗️ Test des projets Node.js. Partie 2. Évaluation des performances des tests, intégration continue et analyse de la qualité du code ☸️ 🚟 🧜🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="→ Test des projets Node.js. Partie 1. Anatomie d'essai et types d'essai 

 Aujourd'hui, dans la deuxième partie de la traduction du matériel consacré ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Test des projets Node.js. Partie 2. Évaluation des performances des tests, intégration continue et analyse de la qualité du code</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/435464/">  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test des projets Node.js.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1. Anatomie d'essai et types d'essai</a> <br><br>  Aujourd'hui, dans la deuxième partie de la traduction du matériel consacré aux tests des projets Node.js, nous parlerons de l'évaluation de l'efficacité des tests et de l'analyse de la qualité du code. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/f16/1a0/3e2/f161a03e2b08ae35b31f718a083a39a0.jpg" alt="image"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Section 3. Évaluation de l'efficacité des tests</font> </h2><br><h3>  <font color="#3AC1EF">▍19.</font>  <font color="#3AC1EF">Atteindre un niveau de couverture de code suffisamment élevé avec des tests afin de gagner en confiance dans son bon fonctionnement.</font>  <font color="#3AC1EF">Habituellement, une couverture d'environ 80% donne de bons résultats.</font> </h3><br><h4>  Recommandations </h4><br>  Le but des tests est de s'assurer que le programmeur peut continuer à travailler de manière productive sur le projet, en s'assurant que ce qui a déjà été fait est correct.  Évidemment, plus le volume du code testé est grand, plus la confiance que tout fonctionne comme il se doit est forte.  L'indicateur de couverture du code par les tests indique le nombre de lignes (branches, commandes) vérifiées par les tests.  Quel devrait être cet indicateur?  Il est clair que 10 à 30% est trop peu pour donner l'assurance que le projet fonctionnera sans erreur.  D'autre part, le désir de couvrir à 100% le code avec des tests peut être un plaisir trop cher et peut distraire le développeur des fragments de programme les plus importants, le forçant à rechercher dans le code les endroits où les tests existants n'atteignent pas.  Si vous donnez une réponse plus complète à la question de savoir quelle devrait être la couverture du code avec des tests, alors nous pouvons dire que l'indicateur auquel nous devons nous efforcer dépend de l'application en cours de développement.  Par exemple, si vous écrivez un logiciel pour la prochaine génération d'Airbus A380, alors 100% est un indicateur qui n'est même pas discuté.  Mais si vous créez un site Web sur lequel des galeries de caricature seront affichées, alors probablement 50%, c'est déjà beaucoup.  Bien que les experts en tests disent que le niveau de couverture du code avec des tests que vous devez rechercher dépend du projet, beaucoup d'entre eux mentionnent le chiffre de 80%, qui convient probablement à la plupart des applications.  Par exemple, nous parlons ici de quelque chose de l'ordre de 80 à 90%, et, selon l'auteur de ce document, une couverture à 100% du code avec des tests le rend suspect, car cela peut indiquer que le programmeur écrit des tests uniquement pour obtenir beau numéro dans le rapport. <br><br>  Afin d'utiliser les indicateurs des tests de couverture de code, vous devrez configurer correctement votre système pour une intégration continue (CI, intégration continue).  Cela permettra, si l'indicateur correspondant n'atteint pas un certain seuil, d'arrêter le montage du projet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici comment</a> configurer Jest pour collecter les informations de couverture de test.  De plus, vous pouvez configurer des seuils de couverture non pas pour tout le code, mais en vous concentrant sur les composants individuels.  En plus de cela, envisagez de détecter une diminution de la couverture des tests.  Cela se produit, par exemple, lors de l'ajout de nouveau code à un projet.  Le contrôle de cet indicateur encouragera les développeurs à augmenter le volume du code testé, ou au moins à maintenir ce volume au niveau existant.  Compte tenu de ce qui précède, la couverture du code par des tests n'est qu'un indicateur, quantifié, qui ne suffit pas pour évaluer pleinement la fiabilité des tests.  De plus, comme cela sera montré ci-dessous, ses niveaux élevés ne signifient pas encore que le code «couvert de tests» est vraiment vérifié. <br><br><h4>  Conséquences de la dérogation aux recommandations </h4><br>  La confiance du programmeur dans la haute qualité du code et des indicateurs associés liés aux tests va de pair.  Un programmeur ne peut s'empêcher d'avoir peur des erreurs s'il ne sait pas que la majeure partie du code de son projet est couverte par des tests.  Ces préoccupations peuvent ralentir votre projet. <br><br><h4>  Exemple </h4><br>  Voici à quoi ressemble un rapport de couverture de test typique. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96b/951/4fc/96b9514fc0e5d96553a4fc8551793d27.png"></div><br>  <i><font color="#999999">Rapport de couverture des tests généré par Istanbul</font></i> <br><br><h4>  Bonne approche </h4><br>  Voici un exemple de définition du niveau souhaité de couverture de test du code composant et du niveau général de cet indicateur dans Jest. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e23/feb/473/e23feb47399296324bb96b2109d4b360.jpg"></div><br>  <i><font color="#999999">Définition du niveau de couverture de code souhaité avec des tests pour l'ensemble du projet et pour un composant spécifique</font></i> <br><br><h3>  <font color="#3AC1EF">▍20.</font>  <font color="#3AC1EF">Examiner les rapports sur la couverture du code avec des tests pour identifier les parties non protégées du code et d'autres anomalies</font> </h3><br><h4>  Recommandations </h4><br>  Certains problèmes ont tendance à passer à travers une variété de systèmes de détection d'erreurs.  De telles choses peuvent être difficiles à détecter à l'aide d'outils traditionnels.  Cela ne s'applique peut-être pas aux vraies erreurs.  Nous parlons plutôt d'un comportement d'application inattendu, qui peut avoir des conséquences dévastatrices.  Par exemple, il arrive souvent que certains fragments de code ne soient jamais utilisés ou soient rarement appelés.  Par exemple, vous pensez que les mécanismes de la classe <code>PricingCalculator</code> toujours utilisés pour fixer le prix d'un produit, mais en fait il s'avère que cette classe n'est pas utilisée du tout, et il y a des enregistrements de 10000 produits dans la base de données et dans la boutique en ligne où le système est utilisé, beaucoup de ventes ... Les rapports sur la couverture du code avec des tests aident le développeur à comprendre si l'application fonctionne comme elle devrait fonctionner.  De plus, à partir des rapports, vous pouvez savoir quel code de projet n'est pas testé.  Si vous vous concentrez sur un indicateur général qui indique que les tests couvrent 80% du code, vous ne pouvez pas savoir si des parties critiques de l'application sont testées.  Pour générer un tel rapport, il suffit de configurer correctement l'outil que vous utilisez pour exécuter les tests.  De tels rapports sont généralement assez jolis, et leur analyse, qui ne prend pas beaucoup de temps, vous permet de détecter toutes sortes de surprises. <br><br><h4>  Conséquences de la dérogation aux recommandations </h4><br>  Si vous ne savez pas quelles parties de votre code restent non testées, vous ne savez pas où vous pouvez vous attendre à des problèmes. <br><br><h4>  Mauvaise approche </h4><br>  Examinez le prochain rapport et réfléchissez à ce qui semble inhabituel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ce/883/889/1ce88388923499c997c6fdc4606d3c10.png"></div><br>  <i><font color="#999999">Rapport indiquant un comportement inhabituel du système</font></i> <br><br>  Le rapport est basé sur un scénario réel d'utilisation de l'application et vous permet de voir le comportement inhabituel du programme associé aux utilisateurs se connectant au système.  À savoir, un nombre étonnamment élevé de tentatives infructueuses pour entrer dans le système attire votre attention par rapport à celles qui ont réussi.  Après analyse du projet, il s'est avéré que la raison en était une erreur dans le frontend, en raison de laquelle la partie interface du projet envoyait constamment des demandes correspondantes à l'API du serveur pour entrer dans le système. <br><br><h3>  <font color="#3AC1EF">▍21.</font>  <font color="#3AC1EF">Mesurer la couverture du code logique avec des tests à l'aide de tests de mutation</font> </h3><br><h4>  Recommandations </h4><br>  Les paramètres d'analyse comparative traditionnels peuvent ne pas être fiables.  Ainsi, dans le rapport, il peut y avoir un chiffre de 100%, mais en même temps, absolument toutes les fonctions du projet renverront des valeurs incorrectes.  Comment expliquer ça?  Le fait est que l'indicateur de couverture du code par les tests n'indique que les lignes de code qui ont été exécutées sous le contrôle du système de test, mais cela ne dépend pas de savoir si quelque chose a été vraiment vérifié, c'est-à-dire si les déclarations du test ont été visant à vérifier l'exactitude des résultats du code.  Cela ressemble à une personne qui, de retour d'un voyage d'affaires à l'étranger, montre des tampons dans son passeport.  Les timbres prouvent qu'il est allé quelque part, mais ils ne disent pas s'il a fait ce qu'il est allé en voyage d'affaires. <br><br>  Ici, les tests de mutation peuvent nous être utiles, ce qui nous permet de savoir combien de code a été réellement testé, et pas seulement visité par le système de test.  Pour les tests mutationnels, vous pouvez utiliser la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stryker</a> JS.  Voici les principes selon lesquels cela fonctionne: <br><br><ol><li>  Elle modifie intentionnellement le code, créant des erreurs.  Par exemple, le code <code>newOrder.price===0</code> devient <code>newOrder.price!=0</code> .  Ces «erreurs» sont appelées mutations. </li><li>  Elle exécute des tests.  S'ils s'avèrent être réussis, alors nous avons des problèmes, car les tests ne remplissent pas leur tâche de détection des erreurs, et les «mutants», comme on dit, «survivent».  Si les tests indiquent des erreurs dans le code, alors tout est en ordre - les "mutants" "meurent". </li></ol><br>  S'il s'avère que tous les "mutants" ont été "tués" (ou, du moins, la plupart d'entre eux n'ont pas survécu), cela donne un niveau de confiance plus élevé dans la haute qualité du code et les tests qui le testent que les mesures traditionnelles pour couvrir le code avec des tests.  Dans le même temps, le temps requis pour configurer et effectuer des tests mutationnels est comparable à celui nécessaire lors de l'utilisation de tests conventionnels. <br><br><h4>  Conséquences de la dérogation aux recommandations </h4><br>  Si l'indicateur traditionnel de couverture du code par des tests indique que 85% du code est couvert par des tests, cela ne signifie pas que les tests sont capables de détecter des erreurs dans ce code. <br><br><h4>  Mauvaise approche </h4><br>  Voici un exemple de couverture à 100% du code avec des tests, dans lequel le code n'est pas complètement testé. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addNewOrder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newOrder</span></span></span><span class="hljs-function">) </span></span>{   logger.log(<span class="hljs-string"><span class="hljs-string">`Adding new order </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${newOrder}</span></span></span><span class="hljs-string">`</span></span>);   DB.save(newOrder);   Mailer.sendMail(newOrder.assignee, <span class="hljs-string"><span class="hljs-string">`A new order was places </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${newOrder}</span></span></span><span class="hljs-string">`</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">approved</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}; } it(<span class="hljs-string"><span class="hljs-string">"Test addNewOrder, don't use such test names"</span></span>, () =&gt; {   addNewOrder({<span class="hljs-attr"><span class="hljs-attr">asignee</span></span>: <span class="hljs-string"><span class="hljs-string">"John@mailer.com"</span></span>,<span class="hljs-attr"><span class="hljs-attr">price</span></span>: <span class="hljs-number"><span class="hljs-number">120</span></span>}); });<span class="hljs-comment"><span class="hljs-comment">//    100%, ,   ,    </span></span></code> </pre> <br><h4>  Bonne approche </h4><br>  Voici le rapport de test de mutation généré par la bibliothèque Stryker.  Il vous permet de savoir combien de code n'est pas testé (cela est indiqué par le nombre de "mutants" "survivants"). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/037/f6c/9c0/037f6c9c038e09d219c1d06a1b255e4c.jpg"></div><br>  <i><font color="#999999">Rapport Stryker</font></i> <br><br>  Les résultats de ce rapport permettent avec plus de confiance que les indicateurs habituels de couverture du code avec des tests de dire que les tests fonctionnent comme prévu. <br><br><ul><li>  Une mutation est un code qui a été délibérément modifié par la bibliothèque Stryker pour tester l'efficacité d'un test. </li><li>  Le nombre de «mutants» (tués) «tués» indique le nombre de défauts de code («mutants») créés intentionnellement qui ont été identifiés au cours des tests. </li><li>  Le nombre de «mutants» «survécus» (survécu) vous permet de savoir combien de tests de défauts de code n'ont pas trouvés. </li></ul><br><h2>  <font color="#3AC1EF">Section 4. Intégration continue, autres indicateurs de qualité du code</font> </h2><br><h3>  <font color="#3AC1EF">▍ 22.</font>  <font color="#3AC1EF">Profitez des capacités de linter et interrompez le processus de construction du projet lorsqu'il détecte les problèmes signalés</font> </h3><br><h4>  Recommandations </h4><br>  Aujourd'hui, les linters sont des outils puissants qui peuvent identifier de graves problèmes de code.  Il est recommandé, en plus de quelques règles de base de linting (telles que celles implémentées par les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugins eslint-plugin-standard</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">eslint-config-airbnb</a> ), d'utiliser des règles spécialisées.  Par exemple, ce sont les règles implémentées au moyen du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugin eslint-plugin-chai-expect</a> pour vérifier l'exactitude du code de test, ce sont les règles du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugin eslint-plugin-promise</a> qui contrôlent le travail avec les promesses, ce sont les règles de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">eslint-plugin-security</a> qui vérifient la présence du code il contient des expressions régulières dangereuses.  Ici, vous pouvez également mentionner le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plug-in eslint-plugin-you-dont-need-lodash-underscore</a> , qui vous permet de trouver dans le code l'utilisation de méthodes provenant de bibliothèques externes qui ont des analogues en JavaScript pur. <br><br><h4>  Conséquences de la dérogation aux recommandations </h4><br>  Un jour de pluie est arrivé, le projet donne des échecs continus de production et il n'y a aucune information sur les piles d'erreurs dans les journaux.  Qu'est-il arrivé?  Il s'est avéré que ce que le code lève comme exception n'est pas vraiment un objet d'erreur.  Par conséquent, les informations sur la pile n'entrent pas dans les journaux.  En fait, dans une telle situation, le programmeur peut tuer contre le mur ou, ce qui est beaucoup mieux, passer 5 minutes à configurer le linter, ce qui détectera facilement le problème et assurera le projet contre des problèmes similaires qui pourraient survenir à l'avenir. <br><br><h4>  Mauvaise approche </h4><br>  Voici le code qui, par inadvertance, lève un objet ordinaire comme exception, alors qu'ici vous avez besoin d'un objet de type <code>Error</code> .  Sinon, les données sur la pile ne seront pas enregistrées dans le journal.  ESLint trouve ce qui pourrait causer des problèmes de production, aidant à éviter ces problèmes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6a/d40/bc0/d6ad40bc0f5e0c09840e3b52e2b878a6.jpg"></div><br>  <i><font color="#999999">ESLint vous aide à trouver un bogue dans votre code</font></i> <br><br><h3>  <font color="#3AC1EF">▍23.</font>  <font color="#3AC1EF">Retour d'information plus rapide avec les développeurs utilisant l'intégration continue locale</font> </h3><br><h4>  Recommandations </h4><br>  Vous utilisez un système centralisé d'intégration continue, qui aide à contrôler la qualité du code, à le tester, à l'aide du linter, à le rechercher des vulnérabilités?  Si tel est le cas, assurez-vous que les développeurs peuvent exécuter ce système localement.  Cela leur permettra de vérifier instantanément leur code, ce qui accélère les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commentaires</a> et réduit le temps de développement du projet.  Pourquoi en est-il ainsi?  Un processus de développement et de test efficace implique de nombreuses opérations répétées cycliquement.  Le code est testé, puis le développeur reçoit un rapport, puis, si nécessaire, le code est refactorisé, après quoi tout est répété.  Plus la boucle de rétroaction fonctionne rapidement, plus les développeurs reçoivent rapidement des rapports sur les tests de code, plus ils peuvent effectuer d'itérations d'amélioration de ce code.  S'il faut beaucoup de temps pour obtenir un rapport de test, cela peut entraîner une mauvaise qualité du code.  Supposons que quelqu'un travaille sur un module, puis commence à travailler sur autre chose, puis reçoive un rapport sur le module, ce qui indique que le module doit être amélioré.  Cependant, déjà occupé par des sujets complètement différents, le développeur ne fera pas assez attention au module problème. <br><br>  Certains fournisseurs de solutions CI (disons que cela s'applique à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CircleCI</a> ) vous permettent d'exécuter le pipeline CI localement.  Certains outils payants, comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wallaby.js</a> (l'auteur note qu'il n'est pas connecté à ce projet), peuvent rapidement obtenir des informations précieuses sur la qualité du code.  De plus, le développeur peut simplement ajouter le script npm approprié à <code>package.json</code> , qui effectue des vérifications de la qualité du code (tests, analyses avec un linter, recherche des vulnérabilités), et utilise même le package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">simultanément</a> pour accélérer les vérifications.  Maintenant, afin de vérifier complètement le code, il suffira d'exécuter une seule commande, comme la <code>npm run quality</code> , et d'obtenir immédiatement un rapport.  De plus, si les tests de code indiquent qu'il a des problèmes, vous pouvez annuler les validations à l'aide de git hooks (la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">husky</a> peut être utile pour résoudre ce problème). <br><br><h4>  Conséquences de la dérogation aux recommandations </h4><br>  Si un développeur reçoit un rapport sur la qualité du code un jour après avoir écrit ce code, un tel rapport est susceptible de se transformer en quelque chose comme un document formel, et les tests de code seront dissociés du travail, ne devenant pas sa partie naturelle. <br><br><h4>  Bonne approche </h4><br>  Voici un script npm qui vérifie la qualité du code.  La réalisation des vérifications est parallélisée.  Le script est exécuté lors de la tentative d'envoi de nouveau code au référentiel.  De plus, le développeur peut le lancer de sa propre initiative. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"inspect:sanity-testing"</span></span>: <span class="hljs-string"><span class="hljs-string">"mocha **/**--test.js --grep \"sanity\""</span></span>,   <span class="hljs-string"><span class="hljs-string">"inspect:lint"</span></span>: <span class="hljs-string"><span class="hljs-string">"eslint ."</span></span>,   <span class="hljs-string"><span class="hljs-string">"inspect:vulnerabilities"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm audit"</span></span>,   <span class="hljs-string"><span class="hljs-string">"inspect:license"</span></span>: <span class="hljs-string"><span class="hljs-string">"license-checker --failOn GPLv2"</span></span>,   <span class="hljs-string"><span class="hljs-string">"inspect:complexity"</span></span>: <span class="hljs-string"><span class="hljs-string">"plato ."</span></span>,     <span class="hljs-string"><span class="hljs-string">"inspect:all"</span></span>: <span class="hljs-string"><span class="hljs-string">"concurrently -c \"bgBlue.bold,bgMagenta.bold,yellow\" \"npm:inspect:quick-testing\" \"npm:inspect:lint\" \"npm:inspect:vulnerabilities\" \"npm:inspect:license\""</span></span> }, <span class="hljs-string"><span class="hljs-string">"husky"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"hooks"</span></span>: {     <span class="hljs-string"><span class="hljs-string">"precommit"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run inspect:all"</span></span>,     <span class="hljs-string"><span class="hljs-string">"prepush"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run inspect:all"</span></span>   } }</code> </pre> <br><h3>  <font color="#3AC1EF">▍24.</font>  <font color="#3AC1EF">Effectuer des tests de bout en bout sur un miroir d'environnement de production réaliste</font> </h3><br><h4>  Recommandations </h4><br>  Dans le vaste écosystème de Kubernetes, il existe toujours un consensus pour utiliser des outils adaptés au déploiement des environnements locaux, bien que de tels outils apparaissent assez souvent.  Une approche possible ici consiste à exécuter un Kubernetes «minimisé» à l'aide d'outils tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Minikube</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MicroK8</a> , qui vous permettent de créer des environnements légers qui ressemblent à de vrais.  Une autre approche consiste à tester des projets dans un environnement Kubernetes «réel» distant.  Certains fournisseurs de CI (tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Codefresh</a> ) permettent d'interagir avec les environnements intégrés de Kubernetes, ce qui simplifie le travail des pipelines de CI lors du test de projets réels.  D'autres vous permettent de travailler avec des environnements Kubernetes distants. <br><br><h4>  Conséquences de la dérogation aux recommandations </h4><br>  L'utilisation de différentes technologies dans la production et les tests nécessite le support de deux modèles de développement et conduit à la séparation des équipes de programmeurs et de spécialistes DevOps. <br><br><h4>  Bonne approche </h4><br>  Voici un exemple de chaîne CI, qui, comme on dit, crée à la volée un cluster Kubernetes (c'est tiré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'ici</a> ). <br><br><pre> <code class="javascript hljs">deploy: stage: deploy image: registry.gitlab.com/gitlab-examples/kubernetes-deploy script: - ./configureCluster.sh $KUBE_CA_PEM_FILE $KUBE_URL $KUBE_TOKEN - kubectl create ns $NAMESPACE - kubectl create secret -n $NAMESPACE docker-registry gitlab-registry --docker-server=<span class="hljs-string"><span class="hljs-string">"$CI_REGISTRY"</span></span> --docker-username=<span class="hljs-string"><span class="hljs-string">"$CI_REGISTRY_USER"</span></span> --docker-password=<span class="hljs-string"><span class="hljs-string">"$CI_REGISTRY_PASSWORD"</span></span> --docker-email=<span class="hljs-string"><span class="hljs-string">"$GITLAB_USER_EMAIL"</span></span> - mkdir .generated - echo <span class="hljs-string"><span class="hljs-string">"$CI_BUILD_REF_NAME-$CI_BUILD_REF"</span></span> - sed -e <span class="hljs-string"><span class="hljs-string">"s/TAG/$CI_BUILD_REF_NAME-$CI_BUILD_REF/g"</span></span> templates/deals.yaml | tee <span class="hljs-string"><span class="hljs-string">".generated/deals.yaml"</span></span> - kubectl apply --namespace $NAMESPACE -f .generated/deals.yaml - kubectl apply --namespace $NAMESPACE -f templates/my-sock-shop.yaml environment: name: test-<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>-ci</code> </pre> <br><h3>  <font color="#3AC1EF">▍25.</font>  <font color="#3AC1EF">S'efforcer de paralléliser l'exécution des tests</font> </h3><br><h4>  Recommandations </h4><br>  Si le système de test est bien organisé, il deviendra votre ami fidèle, 24 heures sur 24, prêt à signaler les problèmes avec le code.  Pour ce faire, les tests doivent être effectués très rapidement.  En pratique, il s'avère que l'exécution en mode unitaire 500 tests unitaires qui utilisent intensivement le processeur prend trop de temps.  Et ces tests doivent être effectués assez souvent.  Heureusement, les outils modernes pour exécuter des tests ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jest</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AVA</a> , une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">extension pour Mocha</a> ) et les plates-formes CI peuvent exécuter des tests en parallèle en utilisant plusieurs processus, ce qui peut considérablement améliorer la vitesse de réception des rapports de test.  Certaines plateformes CI savent même comment paralléliser les tests entre les conteneurs, ce qui améliore encore la boucle de rétroaction.  Pour réussir à paralléliser l'exécution des tests, locaux ou distants, les tests ne doivent pas dépendre les uns des autres.  Les tests autonomes peuvent être exécutés sans problème dans différents processus. <br><br><h4>  Conséquences de la dérogation aux recommandations </h4><br>  Obtenir des résultats de test une heure après l'envoi du code au référentiel tout en travaillant sur de nouvelles fonctionnalités de projet est un excellent moyen de réduire l'utilité des résultats de test. <br><br><h4>  Bonne approche </h4><br>  Grâce à l'exécution parallèle de tests, la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mocha-parallel-test</a> et le framework <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jest</a> contournent facilement Mocha ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">c'est la</a> source de cette information). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5f/aa2/e8e/c5faa2e8ee900ae5d3447d510bc1bf8f.png"></div><br>  <i><font color="#999999">Tester les outils de test de performance</font></i> <br><br><h3>  <font color="#3AC1EF">▍26.</font>  <font color="#3AC1EF">Protégez-vous contre les problèmes juridiques en utilisant la vérification de licence et la vérification du code de plagiat</font> </h3><br><h4>  Recommandations </h4><br>  Peut-être que maintenant vous n'êtes pas particulièrement préoccupé par les problèmes avec la loi et le plagiat.  Cependant, pourquoi ne pas rechercher des problèmes similaires dans votre projet?  Il existe de nombreux outils pour organiser de telles inspections.  Par exemple, ce sont le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vérificateur de licence et le vérificateur de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plagiat</a> (il s'agit d'un package commercial, mais il est possible de l'utiliser gratuitement).  Il est facile d'intégrer de telles vérifications dans le pipeline CI et de vérifier le projet, par exemple, pour la présence de dépendances avec des licences limitées, ou pour la présence de code copié à partir de StackOverflow et portant probablement atteinte aux droits d'auteur de quelqu'un d'autre. <br><br><h4>  Conséquences de la dérogation aux recommandations </h4><br>  Le développeur peut, par inadvertance, utiliser le package avec une licence qui ne convient pas à son projet, ou copier le code commercial, ce qui peut entraîner des problèmes juridiques. <br><br><h4>  Bonne approche </h4><br>  Installez le package de vérificateur de licence localement ou dans un environnement CI: <br><br><pre> <code class="javascript hljs">npm install -g license-checker</code> </pre> <br>  Nous vérifierons les licences avec lui et s'il trouve quelque chose qui ne nous convient pas, nous reconnaîtrons que le chèque a échoué.  Le système CI, après avoir détecté un problème lors de la vérification des licences, arrêtera l'assemblage du projet. <br><br><pre> <code class="javascript hljs">license-checker --summary --failOn BSD</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/791/cde/326/791cde326f7185df4c78479ef4ab5757.png"></div><br>  <i><font color="#999999">Vérification de licence</font></i> <br><br><h3>  <font color="#3AC1EF">▍27.</font>  <font color="#3AC1EF">Vérifier constamment le projet pour les dépendances vulnérables</font> </h3><br><h4>  Recommandations </h4><br>  Même les packages hautement respectés et fiables, tels qu'Express, présentent des vulnérabilités.  Afin d'identifier ces vulnérabilités, vous pouvez utiliser des outils spéciaux - comme l'outil standard pour l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">audit des packages npm</a> ou le projet commercial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">snyk</a> , qui a une version gratuite.  Ces vérifications, ainsi que d'autres, peuvent faire partie du pipeline CI. <br><br><h4>  Conséquences de la dérogation aux recommandations </h4><br>  Afin de protéger votre projet contre les vulnérabilités de ses dépendances sans utiliser d'outils spéciaux, vous devrez surveiller en permanence les publications sur ces vulnérabilités.  C'est une tâche qui prend beaucoup de temps. <br><br><h4>  Bonne approche </h4><br>  Voici les résultats de la vérification du projet à l'aide de NPM Audit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d5/da1/3a9/9d5da13a900a066fbc6c15aba2cc0a0d.png"></div><br>  <i><font color="#999999">Rapport du package de vérification de la vulnérabilité</font></i> <br><br><h3>  <font color="#3AC1EF">▍28.</font>  <font color="#3AC1EF">Automatiser les mises à jour des dépendances</font> </h3><br><h4>  Recommandations </h4><br>  La route de l'enfer est pavée de bonnes intentions.  Cette idée est pleinement applicable au <code>package-lock.json</code> , dont l'utilisation, par défaut, bloque les mises à jour des packages.  Cela se produit même dans les cas où les projets sont amenés à un état sain par les commandes <code>npm install</code> et <code>npm update</code> .  Cela conduit, au mieux, à l'utilisation de packages obsolètes, ou, au pire, à l'apparition de code vulnérable dans le projet.  En conséquence, les équipes de développement s'appuient soit sur une mise à jour manuelle des informations sur les versions appropriées des packages, soit sur des utilitaires comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ncu</a> , qui, là encore, sont lancés manuellement.  Le processus de mise à jour des dépendances est mieux automatisé, en se concentrant sur l'utilisation des versions les plus fiables des packages utilisés dans le projet.  Ce n'est pas la seule bonne solution, cependant, dans l'automatisation des mises à jour de packages, il existe quelques approches notables.  La première consiste à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">injecter</a> quelque chose comme la vérification des packages en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">npm-obsolète</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">npm-check-updates</a> (ncu) dans le pipeline CI.  Cela aidera à identifier les packages obsolètes et encouragera les développeurs à les mettre à niveau.  La deuxième approche consiste à utiliser des outils commerciaux qui vérifient le code et effectuent automatiquement des requêtes d'extraction visant à mettre à jour les dépendances.  Dans le domaine de la mise à jour automatique des dépendances, nous sommes confrontés à une autre question intéressante concernant la politique de mise à jour.  Si elle est mise à jour avec chaque nouveau patch, la mise à jour peut mettre trop de pression sur le système.  Si vous mettez à jour immédiatement après la publication de la prochaine version majeure du package, cela peut conduire à l'utilisation de solutions instables dans le projet (les vulnérabilités de nombreux packages se trouvent exactement dans les tout premiers jours après la publication, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lisez</a> l'incident avec eslint-scope).         « »,             ,    . ,      1.3.1,             1.3.2,      1.3.8. <br><br><h4>     </h4><br>       ,    ,        ,     . <br><br><h4>   </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ncu</a>     ,   ,   ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6e/b2a/dcf/e6eb2adcf8720657a4e5c09c34691704.png"></div><br> <i><font color="#999999">   ncu</font></i> <br><br><h3> <font color="#3AC1EF">▍29.        ,     Node.js</font> </h3><br><h4>  </h4><br>       ,     Node.js-,     ,   Node.js  . <br><br><ol><li>   .     —   , , ,    Jenkins      . </li><li>  ,  Docker. </li><li>       . ,    ,      .    (,    ),       , ,  ,     . </li><li>   ,    ,      ,    .  —   ,    ,   ,      . </li><li>     ,     . ,          feature,    —   master, ,                 (   ). </li><li>        .        ,    . </li><li>     . </li><li>         (,     Docker)  . </li><li>     , ,  ,  . ,        <code>node_modules</code> . </li></ol><br><h4>     </h4><br>      ,     ,     . <br><br><h3> <font color="#3AC1EF">▍30.    </font> </h3><br><h4>  </h4><br>      ,      .     ,      , ,    Node.js    ,            .  CI-,    ,    « ». ,      ,    ,   . , ,      mySQL,   — Postgres.   ,        Node.js,  — 8, 9  10.          ,     .     CI-. <br><br><h4>     </h4><br>         ,     ,    ,      . ,  ,     . <br><br><h4>   </h4><br>    CI- Travis        Node.js. <br><br><pre> <code class="javascript hljs">language: node_js node_js: - <span class="hljs-string"><span class="hljs-string">"7"</span></span> - <span class="hljs-string"><span class="hljs-string">"6"</span></span> - <span class="hljs-string"><span class="hljs-string">"5"</span></span> - <span class="hljs-string"><span class="hljs-string">"4"</span></span> install: - npm install script: - npm run test</code> </pre> <br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>      ,    ,       . ,   ,     . <br><br>  <b>Chers lecteurs!</b>      ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435464/">https://habr.com/ru/post/fr435464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435452/index.html">Test de bout en bout des microservices avec Catcher</a></li>
<li><a href="../fr435454/index.html">AOP vs fonctionnalités</a></li>
<li><a href="../fr435456/index.html">Est-il dangereux de laisser un smartphone à côté de vous la nuit?</a></li>
<li><a href="../fr435460/index.html">Coworkidea Coworking Photo Tour (Barcelone)</a></li>
<li><a href="../fr435462/index.html">Test des projets Node.js. Partie 1. Anatomie d'essai et types d'essai</a></li>
<li><a href="../fr435466/index.html">Tutoriel React Partie 6: Quelques fonctionnalités du cours, JSX et JavaScript</a></li>
<li><a href="../fr435468/index.html">Tutoriel React, partie 7: styles en ligne</a></li>
<li><a href="../fr435470/index.html">Tutoriel React, Partie 8: Poursuite des travaux sur une application TODO, présentation des propriétés des composants</a></li>
<li><a href="../fr435476/index.html">Mkcert: certificats HTTPS valides pour localhost</a></li>
<li><a href="../fr435480/index.html">Microsoft et Kroger vont combattre Amazon dans le domaine ... le commerce des aliments</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>