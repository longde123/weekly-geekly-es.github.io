<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🏫 👶🏾 🎮 Interrupciones de dispositivos externos en un sistema x86. Parte 1. La evolución de los controladores de interrupción 🤦🏻 👩🏾‍🤝‍👩🏽 🌲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este artículo, me gustaría considerar los mecanismos para entregar interrupciones desde dispositivos externos en el sistema x86 e intentar responde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interrupciones de dispositivos externos en un sistema x86. Parte 1. La evolución de los controladores de interrupción</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430548/">  En este artículo, me gustaría considerar los mecanismos para entregar interrupciones desde dispositivos externos en el sistema x86 e intentar responder las preguntas: <br><br><ul><li>  ¿Qué es PIC y para qué sirve? </li><li>  ¿Qué es APIC y para qué sirve?  ¿Para qué sirven LAPIC y I / O APIC? </li><li>  ¿Cuáles son las diferencias entre APIC, xAPIC y x2APIC? </li><li>  ¿Qué es el MSI?  ¿Cuáles son las diferencias entre MSI y MSI-X? </li><li>  ¿Cómo se relacionan las tablas $ PIR, MPtable, ACPI con esto? </li></ul><br>  Si está interesado en recibir una respuesta a cualquiera de estas preguntas o si solo desea familiarizarse con la evolución de los controladores de interrupción en el sistema x86, bienvenido a cat. <br><a name="habracut"></a><br><h3>  Introduccion </h3><br>  Todos sabemos lo que es la interrupción.  Para aquellos que no lo son, cita de wikipedia: <br><br><blockquote> Interrupción (interrupción en inglés): una señal del software o hardware que informa al procesador sobre la ocurrencia de cualquier evento que requiera atención inmediata.  La interrupción notifica al procesador la ocurrencia de un evento de alta prioridad que requiere la interrupción del código actual ejecutado por el procesador.  El procesador responde suspendiendo su actividad actual, manteniendo su estado y ejecutando una función llamada controlador de interrupción (o controlador de interrupción) que responde al evento y lo sirve, después de lo cual devuelve el control al código interrumpido. <br><br>  Dependiendo de la fuente de la señal de interrupción, se dividen en: <br><br><ul><li>  Eventos asíncronos o externos (hardware) que se originan en dispositivos de hardware externos (como dispositivos periféricos) y pueden ocurrir en cualquier momento arbitrario: una señal de un temporizador, una tarjeta de red o unidad de disco, pulsaciones de teclas, movimientos del mouse.  El hecho de que tal interrupción ocurra en el sistema se interpreta como una solicitud de interrupción (IRQ): los dispositivos informan que requieren atención del sistema operativo; </li><li>  eventos síncronos o internos en el propio procesador como resultado de la violación de ciertas condiciones al ejecutar código de máquina: división por cero o desbordamiento de pila, acceso a direcciones de memoria no válidas o código de operación no válido; </li></ul></blockquote>  En este artículo, me gustaría hablar sobre las interrupciones IRQ externas. <br><br>  ¿Por qué son necesarios?  Supongamos que queremos realizar alguna acción con un paquete de entrada para una tarjeta de red cuando llegue.  Para no preguntar a la tarjeta de red constantemente "¿tiene un nuevo paquete?"  y no desperdicie recursos del procesador en esto; puede usar la interrupción IRQ.  La línea de interrupción del dispositivo está conectada a la línea INTR del procesador, y cuando se recibe un paquete, la tarjeta de red "tira" de esta línea.  El procesador comprende que hay información y lee el paquete. <br><br>  Pero, ¿qué pasa si hay muchos dispositivos?  No puede tener suficiente de todos los dispositivos externos de las patas del procesador. <br><br><img src="https://habrastorage.org/webt/vg/3q/3v/vg3q3v7kx8vjttp43xo99o8pccs.png"><br><br>  Para resolver este problema, se les ocurrió un chip, un controlador de interrupción. <br><br><h3>  Pic </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wiki</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">osdev</a> ) <br><br>  El primero fue un chip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PIC Intel 8259</a> .  8 líneas de entrada (IRQ0-7) y una salida que conecta el controlador con la línea INTR del procesador.  Cuando ocurre una interrupción de un dispositivo, 8259 tira de la línea INTR, el procesador comprende que algún dispositivo está señalando una interrupción y sondea el PIC para comprender qué rama IRQx causó la interrupción.  Hay un retraso adicional para esta encuesta, pero el número de líneas de interrupción aumenta a 8. <br><br><img src="https://habrastorage.org/webt/le/yf/6e/leyf6enogyzp6flpijo2d0x1w9g.png"><br><br>  Sin embargo, 8 líneas rápidamente resultaron ser pequeñas, y para aumentar su número, se comenzaron a utilizar 2 8259 controladores (maestro y esclavo) conectados en cascada (Dual PIC). <br><br>  Las IRQ 0 a 7 son procesadas por el primer Intel 8259 PIC (maestro), y las IRQ 8 a 15 son procesadas por el segundo 8259 PIC (esclavo).  Solo un maestro señala la ocurrencia de una interrupción.  Si se produce una interrupción en las líneas 8-15, el segundo PIC (esclavo) señala una interrupción al maestro a través de IRQ 2, y el maestro a su vez señala a la CPU.  Esta interrupción en cascada toma una de las 16 líneas, pero al final ofrece 15 interrupciones disponibles para los dispositivos. <br><br><img src="https://habrastorage.org/webt/xj/yn/dh/xjyndhabujjwz0alrbx831zfzt8.png"><br><br>  El circuito se ha establecido, y esto es lo que quieren decir cuando hablan sobre PIC (Programm Interrupt Controller) ahora.  Posteriormente, los controladores 8259 recibieron algunas mejoras y se conocieron como 8259A, y este circuito se incluyó en el conjunto de chips.  En un momento en que el bus principal para conectar dispositivos externos era el bus ISA, dicho sistema en su conjunto era suficiente.  Solo era necesario asegurarse de que diferentes dispositivos no se conectaran a la misma línea IRQ para evitar conflictos, ya que las interrupciones ISA no se comparten. <br><br>  Por lo general, el diseño de las interrupciones para dispositivos era más o menos estándar <br><br>  Ejemplo (tomado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de aquí</a> ): <br>  IRQ 0 - temporizador del sistema <br>  IRQ 1 - controlador de teclado <br>  IRQ 2 - cascada (interrupción desde el controlador esclavo) <br>  IRQ 3 - puerto serie COM2 <br>  IRQ 4 - puerto serie COM1 <br>  IRQ 5 - puerto paralelo 2 y 3 o tarjeta de sonido <br>  IRQ 6 - controlador de disquete <br>  IRQ 7 - puerto paralelo 1 <br>  IRQ 8 - Temporizador RTC <br>  IRQ 9 - ACPI <br>  IRQ 10 - abierto / SCSI / NIC <br>  IRQ 11 - abierto / SCSI / NIC <br>  IRQ 12 - controlador de mouse <br>  IRQ 13 - coprocesador matemático <br>  IRQ 14 - ATA canal 1 <br>  IRQ 15 - ATA canal 2 <br><br>  La configuración y el trabajo con 8259 microcircuitos se realiza a través de puertos de E / S: <br><div class="scrollable-table"><table><tbody><tr><th>  Chip </th><th>  Registrarse </th><th>  Puerto de E / S </th></tr><tr><td>  Foto maestra </td><td>  Comando </td><td>  0x0020 </td></tr><tr><td>  Foto maestra </td><td>  Datos </td><td>  0x0021 </td></tr><tr><td>  Foto esclavo </td><td>  Comando </td><td>  0x00A0 </td></tr><tr><td>  Foto esclavo </td><td>  Datos </td><td>  0x00A1 </td></tr></tbody></table></div><br>  → La documentación para el 8259A se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí.</a> <br><br>  El bus ISA fue reemplazado por el bus PCI.  Y el número de dispositivos claramente comenzó a exceder el número 15, además, a diferencia del bus ISA estático, en este caso, los dispositivos se pueden agregar al sistema dinámicamente.  Pero afortunadamente en este bus se pueden compartir interrupciones (es decir, se pueden conectar varios dispositivos a la misma línea IRQ).  Como resultado, para resolver el problema de la falta de líneas IRQ, decidieron agrupar las interrupciones de todos los dispositivos PCI en líneas PIRQ (solicitud de interrupción programable). <br><br>  Digamos que tenemos 4 líneas de interrupción libremente en el controlador PIC y 20 dispositivos PCI.  Combinamos las interrupciones de 5 dispositivos por línea PIRQx y conectamos las líneas PIRQx al controlador.  Si se produce una interrupción en la línea PIRQx, el procesador tendrá que interrogar a todos los dispositivos conectados a esta línea para comprender de quién proviene la interrupción, pero en general esto resuelve el problema.  Un dispositivo que une líneas de interrupción PCI en una línea PIRQ a menudo se denomina enrutador PIR. <br><br>  En este método, debe asegurarse de que las líneas PIRQx no estén conectadas a las líneas IRQx en las que ya se han iniciado las interrupciones ISA (ya que esto provocará conflictos), y que las líneas PIRQx estén equilibradas (porque cuantos más dispositivos conectamos a la misma línea PIRQ, más dispositivos necesitará interrogará al procesador para comprender cuál de estos dispositivos causó la interrupción). <br><br><img src="https://habrastorage.org/webt/u_/jr/u9/u_jru9pemdeda2xvvbqihvgtp3y.png"><br><br>  <b>Nota</b> : el dispositivo PCI -&gt; el mapeo PIR se muestra de forma abstracta en la imagen, porque de hecho es algo más complicado.  En realidad, cada dispositivo PCI tiene 4 líneas de interrupción (INTA, INTB, INTC, INTD).  Cada dispositivo PCI puede tener hasta 8 funciones, y ahora cada función tiene una interrupción INTx.  La configuración del chipset determina qué INTx obtendrá cada función del dispositivo. <br><br>  En esencia, las funciones son bloques lógicos separados.  Por ejemplo, en un dispositivo PCI puede haber una función de controlador Smbus, una función de controlador SATA, una función de puente LPC.  En el lado del sistema operativo, cada función es un dispositivo separado con su propio espacio de configuración PCI Config. <br><br>  El BIOS pasó la información sobre el enrutamiento de interrupción en el PIC al BIOS usando la tabla $ PIR y completando los registros 3Ch (INT_LN Interrupt Line (R / W)) y 3Dh (INT_PN Interrupt Pin (RO)) del espacio de configuración PCI para cada función.  La especificación para la tabla $ PIR estaba anteriormente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el sitio web de Microsoft</a> , pero ahora ya no está allí.  El contenido de las filas de la tabla $ PIR puede entenderse a partir de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificación PCI BIOS</a> [4.2.2.  Obtenga opciones de enrutamiento de interrupción PCI] o lea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> <br><br><h3>  Apic </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wiki</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">osdev</a> ) <br><br>  El método anterior funcionó hasta que aparecieron los sistemas multiprocesador.  El hecho es que en su dispositivo PIC puede transmitir interrupciones a un solo procesador principal.  Pero me gustaría que la carga en los procesadores del manejo de interrupciones sea equilibrada.  La solución a este problema fue la nueva interfaz APIC (Advanced PIC). <br><br>  Para cada procesador, se agrega un controlador LAPIC especial (APIC local) y un controlador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">APIC de E / S</a> para enrutar las interrupciones de los dispositivos.  Todos estos controladores se combinan en un bus común llamado APIC (los nuevos sistemas ahora están conectados a través de un bus de sistema estándar). <br><br>  Cuando una interrupción de un dispositivo llega al pin I / O APIC, el controlador dirige la interrupción al LAPIC de uno de los procesadores.  La presencia de I / O APIC le permite equilibrar la distribución de interrupciones de dispositivos externos entre procesadores. <br><br>  El primer chip APIC fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">82489DX</a> , era un chip separado que combina LAPIC y I / O APIC.  Para crear un sistema de 2 procesadores, se necesitaban 3 microcircuitos de este tipo.  2 funcionaría como LAPIC y uno como I / O APIC.  Más tarde, la funcionalidad LAPIC se incluyó directamente en los procesadores, y la funcionalidad I / O APIC se enmarcó en el chip 82093AA. <br><br>  El I / O APIC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">82093AA</a> contenía 24 pines de entrada, y la arquitectura APIC podía soportar hasta 16 CPU.  Para mantener la compatibilidad con sistemas más antiguos, se asignaron 0 ~ 15 interrupciones a las interrupciones ISA anteriores.  Y las interrupciones de los dispositivos PCI comenzaron a mostrarse en la línea IRQ 16-23.  Ahora era posible no pensar en conflictos de interrupción de dispositivos ISA y PCI.  Además, gracias al mayor número de líneas de interrupción libre, también ha sido posible aumentar el número de líneas PIRQx. <br><br><img src="https://habrastorage.org/webt/mc/ra/hj/mcrahjn-owk9qrcmyiixcmhomcq.png"><br><br>  La programación I / O APIC y LAPIC se realiza a través de MMIO.  Los registros LAPIC generalmente se encuentran en 0xFEE00000, los registros I / O APIC en 0xFE00000.  Aunque, en principio, todas estas direcciones pueden reconfigurarse. <br><br>  Como en el caso de PIC, inicialmente, los chips individuales luego se convirtieron en parte del conjunto de chips. <br><br>  Posteriormente, la arquitectura APIC recibió modernización y la nueva versión se llamó xAPIC (x - extendida).  Compatibilidad retenida con la versión anterior.  El número de CPU posibles en el sistema aumentó a 256. <br><br>  La siguiente ronda de desarrollo de arquitectura se llamó <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">x2APIC</a> .  El número de CPU posibles en el sistema aumentó a 2 ^ 32.  Los controladores pueden funcionar en modo de compatibilidad xAPIC, o en el nuevo modo x2APIC, donde la programación LAPIC se lleva a cabo no a través de MMIO, sino a través de registros MSR (que es mucho más rápido).  A juzgar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">por este enlace, se</a> requiere soporte de IOMMU para que este modo funcione. <br><br>  Cabe señalar que el sistema puede tener varios controladores I / O APIC.  Por ejemplo, uno por 24 interrupciones en el puente sur, el otro por 32 en el norte.  En el contexto de las E / S, las interrupciones APIC a menudo se denominan GSI (Interrupción del sistema global).  Entonces, en dicho sistema será GSI 0-55. <br><br>  ¿Existe un LAPIC incorporado en la CPU y qué arquitectura puede ser entendida por los indicadores de bit en la CPUID? <br>  Para que el sistema detecte LAPIC y I / O APIC, el BIOS debe proporcionar información sobre ellos al sistema a través de MPtable (el método anterior) o de la tabla ACPI (MADT en este caso).  Además de la información general, tanto MPtable como ACPI (esta vez en la tabla DSDT) deben contener información sobre las interrupciones de enrutamiento, es decir, información sobre qué dispositivo está en qué línea de interrupciones (análogo de la tabla $ PIR). <br><br>  La tabla MPTable se puede encontrar en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20121002210153/">especificación</a> oficial.  Anteriormente, la especificación estaba en el sitio web de Intel, pero ahora solo se puede encontrar en el archivo.  La especificación ACPI ahora se encuentra en el sitio web de UEFI (versión actual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.2</a> ).  Cabe señalar que con ACPI puede especificar el enrutamiento de interrupción para sistemas sin APIC (en lugar de usar la tabla $ PIR). <br><br><h3>  Msi </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wiki</a> ) <br><br>  La versión anterior con APIC es buena, pero no sin fallas.  Todas estas líneas de interrupción del dispositivo complican los circuitos y aumentan la probabilidad de errores.  El bus PCI fue reemplazado por PCI express, en el que simplemente se decidió eliminar las líneas de interrupción.  Para mantener la compatibilidad, ciertos tipos de mensajes emulan las señales de interrupción (INTx #).  En este esquema, la adición lógica de líneas de interrupción, que solía hacerse mediante la conexión física de los cables, recaía sobre los hombros de los puentes PCI.  Sin embargo, el soporte de interrupción INTx heredado es solo soporte para la compatibilidad con el bus PCI.  De hecho, PCI express ha propuesto un nuevo método para entregar mensajes de interrupción: MSI (interrupciones señalizadas por mensaje).  En este método, para señalar una interrupción, el dispositivo simplemente escribe en el área MMIO asignada para el procesador LAPIC. <br><br><img src="https://habrastorage.org/webt/8z/qw/7h/8zqw7him-vupzm_wi5glkqtr1ja.png"><br><br>  Anteriormente, solo se asignaban 4 interrupciones a un dispositivo PCI (es decir, a todas sus funciones), pero ahora es posible abordar hasta 32 interrupciones. <br><br>  En el caso de MSI, no se comparten las líneas, cada interrupción corresponde a su dispositivo. <br><br>  Las interrupciones de MSI también resuelven otro problema.  Supongamos que un dispositivo realiza una transacción de escritura de memoria y desea informar su finalización a través de una interrupción.  Pero una transacción de escritura puede retrasarse en el bus durante el proceso de transferencia (que el dispositivo desconoce en absoluto), y la señal de interrupción llegará antes que el procesador.  Por lo tanto, la CPU seguirá leyendo datos no válidos.  Si se usa MSI, se transmite información sobre MSI, así como datos, y simplemente no podrá llegar antes. <br><br>  Cabe señalar que las interrupciones de MSI no pueden funcionar sin LAPIC, pero el uso de MSI puede reemplazarnos con I / O APIC (simplificación de diseño). <br><br>  Posteriormente, este método recibió la extensión MSI-X.  Ahora cada dispositivo puede tener hasta 2048 interrupciones.  Y se hizo posible indicar individualmente a cada interrupción en qué procesador debería ejecutarse.  Esto puede ser muy útil para dispositivos con mucha carga, como tarjetas de red. <br><br>  No se requieren tablas de BIOS adicionales para el soporte de MSI.  Pero el dispositivo debe informar el soporte de MSI en una de las capacidades en su configuración PCI, y el controlador del dispositivo debe admitir trabajar con MSI. <br><br><h3>  Conclusión </h3><br>  En este artículo, examinamos la evolución de los controladores de interrupción y recibimos información teórica general sobre la entrega de interrupciones desde dispositivos externos en un sistema x86. <br><br>  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">siguiente parte,</a> veremos cómo usar en Linux cada uno de los controladores descritos en la práctica. <br><br><h4>  Referencias </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Controladores de interrupción (cosas en el medio)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Qué hacen las diferentes interrupciones en PCIe?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reducción de la latencia de interrupción mediante el uso de interrupciones señalizadas por mensaje</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Arquitectura de procesamiento de interrupciones para sistemas compatibles con Intel</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430548/">https://habr.com/ru/post/es430548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430534/index.html">Crear una plantilla para Zabbix usando el SDK Trassir de DVR como ejemplo</a></li>
<li><a href="../es430536/index.html">Diseño de funciones de ventana sumadas en una unidad con un nivel dado de superposición</a></li>
<li><a href="../es430538/index.html">¿Lees Scaladoc para métodos de recolección "obvios"? O por qué la pereza no siempre es buena</a></li>
<li><a href="../es430542/index.html">Seminario web abierto "Infraestructura como código"</a></li>
<li><a href="../es430546/index.html">"Se creía que el código sería reemplazado por diagramas UML, y no habría necesidad de probarlo": una entrevista con Alexei Barantsev</a></li>
<li><a href="../es430550/index.html">Construyendo un sistema de componentes reactivos con Kotlin</a></li>
<li><a href="../es430552/index.html">Inicio del día (septiembre-octubre de 2018)</a></li>
<li><a href="../es430554/index.html">Zapatillas de realidad virtual patentadas por Google que puedes caminar para siempre</a></li>
<li><a href="../es430556/index.html">GeekBrains lanza curso de capacitación de gerente de producto</a></li>
<li><a href="../es430558/index.html">Cómo funciona la puntuación en la industria del automóvil compartido. Parte 1. Descripción general de herramientas populares sobre datos reales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>