<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📣 😴 👨‍🚀 Wie Namecoin Blockchain Research RTM-Cyber-Angriffe vorhersagte 👨🏿‍🔬 🕚 👈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Namecoin-Blockchain wurde als Alternative zu herkömmlichen DNS-Registraren erstellt und vor Zensur und erzwungener Domainbeschlagnahme geschützt. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Namecoin Blockchain Research RTM-Cyber-Angriffe vorhersagte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/460857/"><img src="https://habrastorage.org/webt/yc/l5/bz/ycl5bz9rlakm74fw8zztbhesnbm.png"><br><br>  Die Namecoin-Blockchain wurde als Alternative zu herkömmlichen DNS-Registraren erstellt und vor Zensur und erzwungener Domainbeschlagnahme geschützt.  In den letzten Jahren haben Botnetzbetreiber wie Dimnie, Shifu, RTM und Gandcrab damit begonnen, die Adressen von C &amp; C-Servern zu verwalten. <br><br>  Einerseits erlauben die Dezentralisierung und Stabilität der Blockchain Forschern und Anbietern nicht, solche Domänen zu entfernen oder die Kontrolle über sie zu übernehmen.  Andererseits verfügt die auf der Blockchain basierende Infrastruktur über ein Architekturmerkmal: Alle Änderungen im Netzwerk sind öffentlich verfügbar und können zum Studieren und Verfolgen der Aktionen von Angreifern verwendet werden. <br><br>  In diesem Artikel wird der Ansatz vorgestellt, mit dem Botnets in Namecoin zugeordnet und weiter verfolgt werden, um neue IOCs zu extrahieren.  Unter Verwendung des beschriebenen Ansatzes wurden Listen von Assets (siehe Anhang) erstellt, die von den oben genannten Botnetzen verwendet wurden. <br><a name="habracut"></a><br><h2>  Lyrischer Exkurs </h2><br>  Erfindungen, die das Internet verändern, lösen oft nicht nur ein technisches, sondern ein soziales Problem.  Es sind genau solche Technologien und Dienste, die es der Community ermöglichen, einige Axiome von der Seite zu betrachten, die unerschütterlich erschienen, sie zu überdenken, von Grund auf neu zu erstellen, nur eine Idee zu hinterlassen und die Last der im Laufe der Jahre angesammelten Konventionen und Einschränkungen fallen zu lassen.  Blockchain und Bitcoin, Tor, Wikipedia - hinter dem Erfolg eines jeden von ihnen steht eine kleine Gruppe von Enthusiasten mit brennenden Augen, die aufrichtig glauben, dass sie eine bessere Gesellschaft schaffen. <br><br>  Leider folgen ihnen oft andere - den seltsamen Idealen der Pioniere des Internets fremd, aber viel praktischer.  Sie finden <i>eine alternative</i> Anwendung für Technologie, über die die Entwickler nicht nachgedacht haben (oder nicht nachdenken wollten).  Da diese alternative Anwendung an der Grenze (und häufiger, um sich offen im Ausland zu verstecken) des Zulässigen liegt, wird sie für die Mehrheit, oft nicht ohne die Hilfe der Medien, zu einem <i>impliziten</i> oder sogar zum <i>einzigen</i> <i>Standard</i> . <br><br>  Die Gleichwertigkeit der Technologie als Idee und die am meisten diskutierte Methode ihrer Verwendung kann dazu führen, dass die Gesellschaft die Technologie selbst ablehnt.  Infolge der Kriminalisierung seiner Nutzung kann ein unreifer Dienst auf das Niveau einer Grenzkultur reduziert oder vollständig zerstört werden.  So ist es vor langer Zeit mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Napster</a> passiert, nicht so lange her - mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BitTorrent</a> und Tor passiert dies gerade mit Bitcoin. <br><br>  Dies ist nicht vorbei an dem Helden dieser Arbeit - Namecoin.  Namecoin ist eine Blockchain zum Speichern beliebiger Schlüssel-Wert-Paare. Das bekannteste davon ist ein dezentrales, zensurresistentes DNS-Namensregistrierungssystem - Dot-Bit. <br><br>  Unser Interesse an Namecoin wuchs, nachdem die RTM-Botnet-Verwaltungsgruppe Dot-Bit zur Verwaltung ihrer C &amp; C-Server einsetzte.  Irgendwann haben wir uns gefragt: Ist es möglich, neue C &amp; C-Server sofort nach ihrer Registrierung in Dot-Bit zu erkennen?  Und wenn es keine Probleme mit der Aktualisierung bekannter Domänen gab, erwies sich die Entwicklung eines Ansatzes, der es ermöglicht, starke Beweise für die Verbindung neuer Domänen mit einer interessierenden Person zu finden, plötzlich als spannende Forschungsaufgabe, deren Ergebnis diese Arbeit war. <br><br>  Im Allgemeinen wurden die Namecoin-Forschung und die Sammlung von Kompromissindikatoren in Dot-Bit früher durchgeführt.  Die detaillierteste Arbeit kann als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel von Kevin Perlow angesehen werden</a> .  Er war der erste, der auf die grundlegende Möglichkeit des Extrahierens von Daten aus Namecoin aufmerksam machte, und beschrieb mehrere heuristische Techniken, mit denen ein Experte Domänen finden kann, deren Eigenschaften den bekannten C &amp; C-Servern einer bestimmten Gruppe ähneln. <br><br>  Der in dieser Studie vorgestellte Ansatz unterscheidet sich erheblich von der von Kevin beschriebenen Indexierungs- und Schwenktechnik für Experten.  Die heuristischen Regeln, die wir zur Bestimmung von Domaininhabern entwickelt haben, leiten sich aus den Prinzipien der Blockchain und der Bildung von Transaktionen darin ab und werden zusätzlich zur allgemeinen Beschreibung in Form strenger logischer Formulierungen dargestellt.  Zusammen mit einer formalen Beschreibung des Bypass-Algorithmus können Sie so die Suche nach IOC automatisieren, was die Effektivität der Untersuchung erheblich erhöht.  Darüber hinaus hilft der entwickelte Algorithmus nicht nur, andere Namen zu finden, die einmal von der Studiengruppe verwendet wurden, sondern ermöglicht es Ihnen auch, die Erstellung neuer Domänen zu verfolgen, die von derselben Person gesteuert werden. <br><br>  Alle Arbeiten sind in drei Kapitel unterteilt.  Das erste Kapitel beschreibt die Grundlagen von Bitcoin, dessen Code als Plattform für die Erstellung von Namecoin verwendet wurde.  Viele in Bitcoin definierte Entitäten, Beziehungen und deren Implementierungen wurden von Namecoin geerbt.  Ihr Verständnis ist entscheidend für die weitere Diskussion. <br><br>  Das zweite Kapitel ist direkt Namecoin und seiner Hauptanwendung - Dot-Bit - gewidmet. <br><br>  Das dritte Kapitel beschreibt den vorgeschlagenen Ansatz zum Extrahieren von Daten aus Namecoin und enthält eine formale Beschreibung des Blockchain-Bypass-Algorithmus und der heuristischen Regeln, die zum Herstellen von Beziehungen zwischen Domänen verwendet werden. <br><br>  Die Anhänge enthalten IOCs, die mit der beschriebenen Methode für einige Botnets gesammelt wurden, sowie eine Liste von Referenzen und Repositories, die Forschern helfen, die weiter an diesem Thema arbeiten möchten. <br><br><h2>  Bitcoin 201 </h2><br>  Die meisten Informationen in diesem Abschnitt stammen aus den Materialien der Artikelserie von Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Pavlov_dog</a> Potekhin „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bitcoin auf den Punkt gebracht</a> “.  Für russischsprachige Leser ist diese Quelle unserer Meinung nach die umfassendste und am tiefsten öffentlich zugängliche, aber überraschend leicht zu lesen.  Forscher, die sich für das interne Gerät von Bitcoin interessieren, möchten sich nicht auf die in diesem Abschnitt angegebenen Auszüge beschränken, sondern sich mit dem vollständigen Text der Artikel vertraut machen, die über den Link in der Anwendung verfügbar sind.  Der Rest der unten aufgeführten Informationen reicht aus, um die Beschreibung des Algorithmus und die heuristischen Regeln zum Ermitteln der Beziehung zwischen den Adressen in Namecoin zu verstehen, die im letzten Kapitel angegeben wurden. <br><br>  Obwohl es üblich ist, die Geschichte über die Blockchain mit Blöcken und der Kryptographie, die sie verbindet, zu beginnen, werden wir mit Transaktionen beginnen. <br><br><h3>  Transaktion </h3><br>  Wie Sie wissen, ist das nächste Analogon zu Bitcoin ein Kontobuch, in dem alle Transaktionen mit Münzen aufgezeichnet werden.  Aber seltsamerweise gibt es in Bitcoin keine allgemeine Tabelle der Form <code>&lt;, &gt;</code> , genauso wie es keinen Hauptbuchhalter gibt, der diese Tabelle bearbeiten würde. <br><br>  Stattdessen wird die sehr berüchtigte Blockchain verwendet, dh alle Transaktionen werden im Allgemeinen gespeichert.  Der Einfachheit halber können wir annehmen, dass dies Nachrichten der Form sind: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">address</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span><span class="hljs-tag">&gt;</span></span> sent <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">amount</span></span></span><span class="hljs-tag">&gt;</span></span> BTC to <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">address</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Wenn Sie also die gesamte Blockchain durchlaufen, können Sie berechnen, wie viele Münzen zu einer bestimmten Adresse gehören. <br><br><h4>  Ein- und Ausgänge </h4><br>  Eine echte Transaktion in einem Bitcoin-Netzwerk ist etwas komplizierter als die oben beschriebene.  Dies ist eine Struktur, deren Hauptkomponenten Ein- und Ausgänge sind. <br><br>  Eingaben sind Transaktionen, auf die Sie "verweisen".  Stellen Sie sich vor, drei Transaktionen wurden einmal an Ihre Adresse X gesendet: <br><br><pre> <code class="json hljs">TXN_ID: <span class="hljs-number"><span class="hljs-number">123456</span></span>, VALUE: <span class="hljs-number"><span class="hljs-number">40</span></span> BTC TXN_ID: <span class="hljs-number"><span class="hljs-number">645379</span></span>, VALUE: <span class="hljs-number"><span class="hljs-number">10</span></span> BTC TXN_ID: <span class="hljs-number"><span class="hljs-number">888888</span></span>, VALUE: <span class="hljs-number"><span class="hljs-number">100</span></span> BTC</code> </pre> <br>  Wenn Sie beispielsweise <code>45 BTC</code> ausgeben müssen, können Sie auf die Transaktion <code>888888</code> oder zwei Transaktionen gleichzeitig verweisen: <code>123456</code> und <code>645379</code> . <br><br>  Ausgänge - wörtlich "Ausgänge".  Wir können davon ausgehen, dass dies „Adressen“ sind, an die als Ergebnis der Transaktion Münzen „gesendet“ werden.  Es kann auch mehrere Ausgänge geben, von denen jeder seinen eigenen Betrag hat. <br><br>  In der Abbildung unten wird eine neue Transaktion <code>C</code> , die sich auf zwei Ausgänge bezieht - <code>A</code> und <code>B</code>  Infolgedessen hat die Transaktion am Eingang <code>0.008 BTC</code> , die dann in zwei Ausgänge unterteilt werden - <code>0.001 BTC</code> an die erste Adresse und <code>0.006 BTC</code> an die zweite Adresse gesendet. <br><br><img src="https://habrastorage.org/webt/hc/jj/-v/hcjj-vgrvls-t0qv4alrdutq1mm.png" alt="Bild"><br><br>  Die Möglichkeit, mehrere Ausgaben gleichzeitig anzugeben, ist ein sehr wichtiges Merkmal, da <b>die Transaktionsausgabe nur einmal und nur vollständig als Eingabe verwendet werden kann</b> .  Wenn Sie eine eingehende Transaktion bei <code>10 BTC</code> haben und 8 davon ausgeben müssen, erstellen Sie einfach eine Transaktion mit einer Eingabe und zwei Ausgaben: <code>8 BTC</code> an den Verkäufer und <code>2 BTC</code> zurück an Ihre Adresse.  Wenn Sie eine Transaktion erstellen, bei der die Summe der Ausgaben kleiner ist als die Summe der Eingaben (wie im Bild), wird die Differenz an die Adresse des Miners gesendet, der Ihre Transaktion in den Block geschrieben hat. <br><br><h2>  Gebühr </h2><br>  Es ist diese Differenz zwischen der Summe der Eingaben und der Summe der Ausgaben, die als " <code>transaction fee</code> ", <code>transaction fee</code> .  Es ist die zweitwichtigste Einnahmequelle für Bergleute, und die Zeit, die benötigt wird, um die Transaktion in die Blockchain aufzunehmen, hängt davon ab.  Dies liegt an der Tatsache, dass jeder Bergmann über einen bestimmten Pool nicht verifizierter Transaktionen verfügt, die behaupten, im Block zu sein, und der Bergmann sortiert sie in der Regel einfach in absteigender Reihenfolge, um so seinen Gewinn zu maximieren.  Je höher die Provision, desto höher stehen Sie in der Warteschlange und desto schneller wird Ihre Zahlung ausgeführt. <br><br>  Die allgemeine Ansicht der Transaktion ist in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Spezifikation des Protokolls beschrieben</a> , hier wird einer der häufigsten Sonderfälle angegeben. <br><br><img src="https://habrastorage.org/webt/sy/s-/g1/sys-g1dafvutkmxwetsud1urhng.png"><br><br>  <code>previous output hash</code> - Kennung (Hash) der Transaktion, auf die wir uns beziehen.  <code>previous output index</code> - Da wir uns nicht auf die Transaktion selbst, sondern auf eine ihrer Ausgaben beziehen müssen, geben wir in diesem Parameter an, an welcher bestimmten Ausgabe wir interessiert sind.  Die Nummerierung beginnt bei Null.  <code>value</code> - Die Menge an Satoshi ( <code>1/100000000</code> BTC), die an den Ausgang gesendet wurde.  Es wird in einer Little-Endian-Form aufgezeichnet, d. H. <code>62 64 01 00 00 00 00 00</code> - es ist <code>0x016462</code> oder <code>0.00091234 BTC</code> . <br><br>  Die <code>block lock time</code> und <code>sequence</code> werden in der Praxis selten verwendet.  Wir sind nicht an ihnen interessiert, daher werden wir die Beschreibung ihres Zwecks weglassen. <br><br>  Aber auf die Parameter mit dem Wort <code>script</code> im Titel werden wir näher eingehen. <br><br><h4>  Skript </h4><br>  Das Bitcoin-Netzwerk verfügt über einen Mechanismus, der auf kryptografischen Algorithmen mit einem öffentlichen Schlüssel basiert und es Ihnen ermöglicht, ein System zu erstellen, in dem nur der Besitzer des Schlüssels die Münzen verwenden kann, die der von diesem Schlüssel erhaltenen Adresse zugeordnet sind.  Wir werden herausfinden, wie dies unter der Haube umgesetzt wird. <br><br>  Zunächst gibt es in Bitcoin eine einfache gestapelte Programmiersprache namens <code>Script</code> .  Hier ist das einfachste Skriptprogramm: <br><br><pre> <code class="xml hljs">2 3 OP_ADD 5 OP_EQUAL</code> </pre> <br>  Jeder Befehl heißt <code>opcode</code> , es gibt insgesamt etwa 80 davon. Das folgende Bild zeigt den Ausführungsprozess des obigen Programms. <br><br><img src="https://habrastorage.org/webt/du/p0/a9/dup0a971icbk3mhhz1k7vfsipg0.png"><br><br><img src="https://habrastorage.org/webt/pe/xz/6k/pexz6k4icaot60gal2hc7y_iijk.png"><br><br><img src="https://habrastorage.org/webt/ie/nr/sg/ienrsgzd8tb5ncdwaxvvpzzdfku.png"><br><br><img src="https://habrastorage.org/webt/n8/zy/ve/n8zyvevbelp1wm7za8aksy-kcpi.png"><br><br><img src="https://habrastorage.org/webt/gx/aw/v_/gxawv_arrvb86zydou0zm22qhi0.png"><br><br>  In Bitcoin <code>Script</code> verwendet, um eine Bedingung <code>Script</code> unter der die Ausgabe ausgegeben werden kann, und um zu bestätigen, dass die Bedingung erfüllt ist.  Die Bedingung ( <code>scriptPubKey</code> ) wird in der Transaktion für jeden Exit im Feld <code>scriptPubKey</code> gespeichert.  Die Bestätigung, dass die Bedingung erfüllt ist ( <code>unlocking script</code> ), wird für jede Eingabe in das Feld <code>scriptSig</code> geschrieben. <br><br>  Um das Recht zur Verwendung der Ausgabe zu überprüfen, müssen Sie das <code>unlocking script</code> + das <code>unlocking script</code> verbinden und das resultierende Programm als Ganzes ausführen.  Wenn nach der Ausführung <code>TRUE</code> oben auf dem Stapel bleibt, ist die Transaktion gültig. <br><br><a name="P2PKH"></a><br><h4>  Pay to Public Key Hash (P2PKH) </h4><br>  Das <code>P2PKH</code> Skript <code>P2PKH</code> in den meisten Transaktionen verwendet, daher sollten Sie verstehen, wie es funktioniert.  Hier ist seine allgemeine Ansicht: <br><br><img src="https://habrastorage.org/webt/yc/l5/bz/ycl5bz9rlakm74fw8zztbhesnbm.png"><br><br>  Dieses Skript ist seit dem Aufkommen von Bitcoin bekannt und führt die am Anfang des Kapitels erwähnte Aufgabe aus - um sicherzustellen, dass nur der Besitzer des Schlüssels die Münzen verwenden kann, die der von diesem Schlüssel erhaltenen Adresse zugeordnet sind. <br><br>  Die Idee ist folgende: Lassen Sie Ihren Freund <code>B</code> ein Schlüsselpaar besitzen - <code>P</code> (privat) und <code>K</code> (öffentlich).  Mit der Hash-Funktion erhält er die Adresse <code>A</code> vom öffentlichen Schlüssel und teilt Ihnen die Adresse mit.  Als Nächstes senden Sie beispielsweise <code>1 BTC</code> an Adresse <code>A</code> und schreiben Folgendes in das Feld für das <code>locking script</code> : <br><br><blockquote>  Nur jemand, der den privaten Schlüssel für Adresse <code>A</code> kann diese Transaktion ausgeben.  Schreiben Sie als Beweis in das <code>unlocking script</code> erstens den öffentlichen Schlüssel <code>K</code> und zweitens die Signatur der Transaktion mit dem privaten Schlüssel <code>P</code> <br></blockquote><br>  Wenn <code>B</code> beschließt, Ihre Transaktion als Eingabe zu verwenden, erstellt er beispielsweise <code>0.5 BTC</code> und trägt im Feld zum <code>unlocking script</code> die Signatur seiner Transaktion mit dem privaten Schlüssel <code>P</code> <code>sig</code> und dem öffentlichen Schlüssel K- <code>PubK</code> . <br><br>  Hier ist der Ausführungsprozess des kombinierten Programms: <br><br><img src="https://habrastorage.org/webt/et/zx/tw/etzxtwxr3qihzwza6e43rrymdcs.png"><br><br><img src="https://habrastorage.org/webt/yj/bs/1n/yjbs1nuol2e6ut1rp_p9iifi9z4.png"><br><br><img src="https://habrastorage.org/webt/ia/eo/kb/iaeokbdrdznakoutfhiuu2m53xu.png"><br><br><img src="https://habrastorage.org/webt/ix/zh/v2/ixzhv2l0_qhjxgn55tjung8tyng.png"><br><br><img src="https://habrastorage.org/webt/3f/ah/zf/3fahzfikukod-rbz-29tufqlry8.png"><br><br><img src="https://habrastorage.org/webt/71/gf/2h/71gf2hcsfwo7eqtvmmmmdebz0pw.png"><br><br><img src="https://habrastorage.org/webt/yk/f_/b7/ykf_b7fyo6hplbhax7wolaukqrk.png"><br><br><h2>  Blöcke und Blockchain </h2><br>  Wenn die gesamte Blockchain ein Buch ist, können einzelne Blöcke als Seiten dargestellt werden, auf denen Transaktionen aufgezeichnet werden.  Jeder Block "bezieht" sich auf den vorherigen und so weiter bis zum allerersten Block ( <code>genesis block</code> ).  Dies schafft ein Merkmal der Blockchain wie Unveränderlichkeit.  Sie können Block <code>#123</code> nicht übernehmen und ändern, damit niemand es bemerkt: Die Blockchain ist so konzipiert, dass Block <code>#124</code> , dann <code>#125</code> usw. ganz oben geändert werden. <br><br>  Die Blockstruktur sieht folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/bs/kp/3d/bskp3dzxovwwy4zx-s-pxzromgu.png"><br><br>  Die ersten sechs Parameter (alle außer <code>txn_count</code> und <code>txns</code> ) bilden den Header des Blocks.  Der Header-Hash wird als Block-Hash bezeichnet.  Transaktionen selbst nehmen nicht direkt am Hashing teil.  <code>merkle_root</code> ist für ihre Unveränderlichkeit verantwortlich - wenn vereinfacht, dann ist dies ein Hash aller Transaktionen im Block.  Weitere Informationen zum Algorithmus zum Erstellen des Merkle-Baums finden Sie hier unter diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> . <br><br>  Nonce und Bits stehen in direktem Zusammenhang mit dem Prozess des Auftretens von Blöcken - Mining. <br><br><h3>  Bergbau </h3><br>  Bergbau ist ein kritischer Prozess für Bitcoin, der darin besteht, neue Blöcke zu erstellen und zwei Ziele gleichzeitig zu verfolgen.  Das erste ist die Geldmengenproduktion.  Jedes Mal, wenn ein Bergmann einen neuen Block erstellt, wird er dafür mit der N-ten Anzahl von Münzen belohnt, die er dann irgendwo ausgibt, wodurch neue Mittel in das Netzwerk eingeführt werden. <br><br>  Das zweite und viel wichtigere Ziel ist die Kontrolle der Einhaltung der Regeln im Netzwerk.  Es sind die Miner, die die Skripte und Transaktionseingaben überprüfen, bevor sie in den Block aufgenommen werden. <br><br>  Wer mehr über die finanziellen Grundlagen von Bitcoin erfahren möchte, kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Artikel</a> empfehlen.  Ich werde dem ersten Aspekt des Bergbaus nicht viel Aufmerksamkeit schenken und mich auf den zweiten konzentrieren - Transaktionen überprüfen und im Netzwerk starten. <br><br><h3>  Arbeitsnachweis </h3><br>  Lass dich ein Bergmann sein.  Sie haben 10 Transaktionen, die Sie in den Block aufnehmen möchten.  Sie überprüfen diese Transaktionen auf Gültigkeit, bilden einen Block daraus, geben im Feld <code>nonce</code> 0 an und berücksichtigen den Block-Hash.  Ändern Sie dann <code>nonce</code> auf 1 und zählen Sie den Hash erneut. <br><br>  Ihre Aufgabe ist es, eine <code>nonce</code> so zu finden, dass der Block-Hash (256-Bit-Nummer) kleiner als eine vorgegebene Nummer <code>N</code>  Die Suche nach einem solchen Hash ist nur durch Brute Force <code>nonce</code> .  Je schneller Sie Nonce finden möchten, desto mehr Leistung benötigen Sie. <br><br>  Die Zahl <code>N</code> ist genau der Parameter (sie wird auch als <code>target</code> ), den das Netzwerk abhängig von der Gesamtleistung der Bergleute anpasst.  Wenn die Blöcke von morgen relativ gesehen alle drei Minuten herauskommen, wird <code>N</code> reduziert, es wird mehr Zeit für die Suche nach Nonce benötigt und die <code>block time</code> wird erneut auf 10 Minuten erhöht.  Umgekehrt. <br><br>  So sieht der Proof-of-Work-Algorithmus aus, der Bitcoin und vielen anderen Blockchains zugrunde liegt.  Mit scheinbarer Einfachheit weist es eine Reihe wichtiger Merkmale auf: <br><br><ul><li>  Das Erstellen eines neuen Blocks ist eine rechenintensive Aufgabe.  Gleichzeitig ist die Überprüfung des Blocks auf Richtigkeit eine einfache und fast sofortige Operation. </li><li>  Das gesamte Netzwerk benötigt 10 Minuten, um einen neuen Block zu berechnen (im Durchschnitt).  Die spezifische Zeit ist für jede Blockchain unterschiedlich, aber unter dem Strich ist die durchschnittliche Zeit voreingestellt.  Darüber hinaus hängt diese Zeit nicht von der Anzahl der Netzwerkteilnehmer ab.  Selbst wenn es eines Tages hundertmal mehr Bergleute geben wird, ändert der Algorithmus seine Parameter, so dass es schwieriger wird, den <code>block time</code> zu finden <code>block time</code> und die <code>block time</code> fällt in die Nähe der angegebenen Zeit zurück. <br><br>  Wie oben beschrieben, läuft der Mining-Prozess darauf hinaus, einen Block-Hash zu finden, der kleiner als eine Zahl ist, die als <code>target</code> .  In der Blockstruktur wird diese Nummer in das Bitfeld geschrieben.  Für Block <code>#277316 target</code> <code>1903a30c</code> . </li></ul><br>  Wie oben beschrieben, läuft der Mining-Prozess darauf hinaus, einen Block-Hash zu finden, der kleiner als eine Zahl ist, die als <code>target</code> .  In der Blockstruktur wird diese Nummer in das <code>bits</code> .  Für Block <code>#277316</code> <code>target</code> <code>1903a30c</code> . <br><br><pre> <code class="json hljs">$ bitcoin-cli getblock <span class="hljs-number"><span class="hljs-number">0000000000000001</span></span>b<span class="hljs-number"><span class="hljs-number">6</span></span>b<span class="hljs-number"><span class="hljs-number">9</span></span>a<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">3</span></span>b<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">5</span></span>e<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">6</span></span>db<span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-number"><span class="hljs-number">1</span></span>c<span class="hljs-number"><span class="hljs-number">4</span></span>a<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">8</span></span>b<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">7</span></span>ef<span class="hljs-number"><span class="hljs-number">2</span></span>d<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-number"><span class="hljs-number">4</span></span>a<span class="hljs-number"><span class="hljs-number">9</span></span>b<span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-number"><span class="hljs-number">1</span></span>b<span class="hljs-number"><span class="hljs-number">2</span></span>cc<span class="hljs-number"><span class="hljs-number">7</span></span>bdc<span class="hljs-number"><span class="hljs-number">4</span></span> { <span class="hljs-attr"><span class="hljs-attr">"hash"</span></span> : <span class="hljs-string"><span class="hljs-string">"0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"confirmations"</span></span> : <span class="hljs-number"><span class="hljs-number">35561</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span> : <span class="hljs-number"><span class="hljs-number">218629</span></span>, <span class="hljs-attr"><span class="hljs-attr">"height"</span></span> : <span class="hljs-number"><span class="hljs-number">277316</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"merkleroot"</span></span> : <span class="hljs-string"><span class="hljs-string">"c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tx"</span></span> : [<span class="hljs-string"><span class="hljs-string">"d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f"</span></span>, ...], <span class="hljs-attr"><span class="hljs-attr">"time"</span></span> : <span class="hljs-number"><span class="hljs-number">1388185914</span></span>, <span class="hljs-attr"><span class="hljs-attr">"nonce"</span></span> : <span class="hljs-number"><span class="hljs-number">924591752</span></span>, <span class="hljs-attr"><span class="hljs-attr">"bits"</span></span> : <span class="hljs-string"><span class="hljs-string">"1903a30c"</span></span>, // &lt;--   <span class="hljs-attr"><span class="hljs-attr">"difficulty"</span></span> : <span class="hljs-number"><span class="hljs-number">1180923195.25802612</span></span>, <span class="hljs-attr"><span class="hljs-attr">"chainwork"</span></span> : <span class="hljs-string"><span class="hljs-string">"000000000000000000000000000000000000000000000934695e92aaf53afa1a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"previousblockhash"</span></span> : <span class="hljs-string"><span class="hljs-string">"0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"nextblockhash"</span></span> : <span class="hljs-string"><span class="hljs-string">"000000000000000010236c269dd6ed714dd5db39d36b33959079d78dfd431ba7"</span></span> }</code> </pre> <br>  In <code>bits</code> tatsächlich zwei Zahlen gleichzeitig geschrieben: Das erste Byte <code>0x19</code> ist der Exponent, die verbleibenden drei Bytes <code>0x03a30c</code> sind die Mantisse.  Um das <code>target</code> aus <code>bits</code> , müssen Sie die folgende Formel verwenden: <br><br><pre> <code class="python hljs">target = mantissa * <span class="hljs-number"><span class="hljs-number">2</span></span>^(<span class="hljs-number"><span class="hljs-number">8</span></span> * (exponent - <span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre> <br>  In der Regel werden jedoch <code>bits</code> in allen Online-Blockregistern angezeigt, z. B. in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://namecha.in/</a> - Namecoin-Blockregister. <br><br>  Und ja, genug Theorie.  Alles, worüber wir oben bei der Anwendung auf Bitcoin gesprochen haben, gilt auch für Namecoin - mit Ausnahme der kleinen Unterschiede, über die wir im nächsten Abschnitt sprechen werden. <br><br><h2>  Namecoin </h2><br>  <i>Namecoin</i> ist eine Blockchain, die auf den Algorithmen und dem Quellcode von Bitcoin basiert. Die Hauptidee besteht darin, ein Registrierungsschema für verteilte Transaktionen zu verwenden, um ein Domain Name System zu verwalten, ein Analogon zu herkömmlichem DNS. <br><br>  Namecoin kopiert die wichtigsten Bitcoin-Ansätze (Proof-of-Work, 10-minütiges Blockgenerierungsintervall) und Datenformate, mit Ausnahme kleiner Ergänzungen, über die wir später sprechen werden. <br><br>  Namecoin-Domains haben das Suffix .bit.  Diese Zone wurde von IANA nicht zugewiesen und nicht der Liste der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezialdomänen</a> zugewiesen.  Normale DNS-Server antworten normalerweise auf solche NXDOMAIN-Anforderungen.  Es gibt jedoch Gateways von DNS zu Namecoin (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenNIC</a> ), öffentliche Proxys mit Namecoin-Unterstützung, Browser- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugins</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Open Source-Projekt</a> , mit dem Sie Ihren eigenen DNS-Server mit Namecoin-Unterstützung starten können. <br><br>  Um eine Domain mit dem Namen <code>facebook.bit</code> , reicht es aus, den Schlüssel <code>d/facebook</code> Präfix <code>d/facebook</code> wird in Namecoin für Domains verwendet) zu registrieren und seinen Wert zu bestimmen.  Das JSON-Format wird zum Festlegen der Werte verwendet.  Ein Eintrag, der die Domänenauflösung auf die IP-Adresse <code>1.2.3.4</code> sieht <code>1.2.3.4</code> aus: <br><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"ip"</span></span>: [<span class="hljs-string"><span class="hljs-string">"1.2.3.4"</span></span>]}</code> </pre> <br>  Namecoin weist Namen nach Verfügbarkeit zu.  Selbst für Mark Zuckerberg selbst wird es kryptografisch unmöglich sein, die Domain <code>facebook.bit</code> vom Eigentümer zu übernehmen. <br><br>  Tatsächlich beschränkt nichts die Verwendung von Namecoin auf die Verwaltung der DNS-Namenspakete - IP-Adresse.  Namecoin kann als verteilte Tabelle verwendet (und verwendet) werden, um beliebige Schlüssel Werten zuzuordnen.  Wir werden uns jedoch genau auf das Szenario seiner Verwendung konzentrieren, in dem es ein alternatives DNS über Blockchain darstellt. <br><br><h2>  Domänenverwaltung </h2><br>  Namecoin verwendet eine Transaktion zum Speichern eines Domäneneintrags.  Das <code>scriptPubKey</code> Feld, das das Programm enthält, ist nämlich die Bedingung für die Verwendung des Transaktions- <code>scriptPubKey</code> , dem wir im vorherigen Kapitel so viel Zeit gewidmet haben.  Um Datensätze zu verwalten, führte Namecoin drei neue Operatoren ein (genauer gesagt, neu definierte bestehende): <br><br><ul><li>  NAME_NEU </li><li>  NAME_FIRSTUPDATE </li><li>  NAME_UPDATE </li></ul><br>  Ihre Bedeutung ergibt sich aus den Namen, aber wir werden dennoch den Zweck und das Format der Verwendung jedes einzelnen von ihnen analysieren. <br><br>  Möglicherweise stellen Sie fest, dass der Operator zum Löschen oder Ungültigmachen von Domains fehlt.  Um die Registrierung von nicht verwendeten Namen zu bereinigen, ist im Netzwerk ein Mechanismus integriert, der automatisch einen Namen freigibt, der seit 36.000 Blöcken (~ 250 Tage) nicht aktualisiert wurde. <br><br><h3>  NAME_NEU </h3><br>  Der erste Schritt besteht darin, die Absicht anzukündigen, einen neuen Namen im Netzwerk zu registrieren.  Erstellen Sie dazu einfach eine spezielle Münze (Ausgabe) mit einem Gewicht von mindestens <code>0.01 NMC</code> , deren <code>output script</code> ungefähr so ​​aussieht: <br><br><pre> <code class="xml hljs">OP_NAMENEW <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">20</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">byte</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">hash</span></span></span><span class="hljs-tag">&gt;</span></span> OP_2DROP <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Zur Demonstration werde ich die Transaktionen, die Stephen Morse durchgeführt hat, verwenden, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um seinen Artikel</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">veranschaulichen</a> . <br><br>  Wenn wir also die Registrierung des Namens <code>d/stephenmorse</code> , müssen wir Folgendes tun: <br><br><img src="https://habrastorage.org/webt/q9/br/b8/q9brb8jrft9fyzc1vc2ph0ssade.png"><br><br>  Wenn Sie sich die resultierende Transaktion ansehen, können Sie zwei interessante Fakten feststellen.  Erstens ist das <code>output script</code> trotz der Tatsache, dass es in Namecoin-Notation geschrieben ist, aus Sicht des ursprünglichen Bitcoin weiterhin gültig.  Die Ersteller von Namecoin haben Codes für ihre Operationen so erfolgreich ausgewählt, dass sie in Bitcoin Operationen entsprechen, die im Wesentlichen dem Schreiben in den konstanten Stapel entsprechen.  <code>NAME_NEW (0x51)</code> -Code von <code>NAME_NEW (0x51)</code> entspricht <code>OP_1</code> , der <code>OP_1</code> Stapel 1 <code>OP_1</code> wird. Eine ähnliche Geschichte mit <code>NAME_FIRSTUPDATE</code> ( <code>0x52</code> oder <code>OP_2</code> , Puts 2) und mit <code>NAME_UPDATE</code> ( <code>0x53</code> oder <code>OP_3</code> , Puts 3).  Die ersten beiden Schritte des Skripts setzen also nur zwei Werte auf den Stapel.  Und die nächste Operation <code>OP_2DROP</code> entfernt sie vom Stapel, so dass weiteres <code>P2PKH</code> „von Grund auf neu“ funktioniert.  Daher gelten alle Skript-Tricks, die wir im Kapitel über Bitcoin behandelt haben, trotz der Neudefinition einiger Operationen auch für Namecoin. <br><br>  Zweitens sind die Schlüssel, die eine spezielle Münze öffnen und wechseln, unterschiedlich.  Obwohl technisch nichts Sie daran hindert, denselben Schlüssel wiederholt zu verwenden, ist es üblich, für jede Quittung einen neuen Schlüssel zu generieren.  Dies geschieht, um es schwierig zu machen, Korrelationen zwischen Transaktionen zu identifizieren und die Anonymität im Netzwerk zu erhöhen. <br><br>  Auf den ersten Blick erscheint es seltsam, dass es entgegen dem gesunden Menschenverstand unmöglich ist, einen Namen und eine IP-Adresse sofort zu übernehmen und zu registrieren.  Dies geschieht, damit niemand den Namen abfangen kann, sobald er sieht, dass Sie ihn registrieren möchten (und ihn dann an Sie weiterverkaufen). <br><br>  Zum Beispiel könnten Bergleute, die unbestätigte (noch nicht in einem der Blöcke enthaltene) Transaktionen im Netzwerk analysieren, ihre eigene Transaktion für die Registrierung derselben Domain erstellen und diese (und nicht Ihre) in ihren Block aufnehmen.  Um diesen Angriff zu implementieren, ist es nicht einmal notwendig, Ihren Block abzubauen.  Es reicht aus, Ihre Transaktion mit einer hohen Gebühr ins Netzwerk zu stellen.  Daher wurden zwei separate Operationen <code>NAME_NEW</code> und <code>NAME_FIRSTUPDATE</code> , und die zweite kann nur von demjenigen ausgeführt werden, der die erste ausgeführt hat, und erst, nachdem <code>NAME_NEW</code> in einen Block <code>NAME_NEW</code> . <br><br>  Tatsächlich ist diese Einschränkung noch etwas strenger: <code>NAME_FIRSTUPDATE</code> ist <code>NAME_FIRSTUPDATE</code> 12 Blöcke nach <code>NAME_NEW</code> (ca. 2 Stunden) möglich.  Um zu verstehen, warum die Blöcke in dieser Einschränkung nicht 1, nicht 2, nicht 3, sondern speziell 12 sind, müssen wir ein wenig von der Hauptgeschichte zurücktreten und herausfinden, was <code>fork</code> und <code>51% attack</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Gabel</b> <div class="spoiler_text">  Stellen Sie sich vor, Bergleute suchen nach Block <code>#123456</code> .  Ungefähr zur gleichen Zeit wurde er unabhängig von zwei Bergleuten gefunden, von denen einer in Australien und der andere in den Vereinigten Staaten lebt.  Jeder von ihnen beginnt, seine Version des Blocks über das Netzwerk zu verteilen, und als Ergebnis stellt sich heraus, dass eine Hälfte der Welt eine Blockchain und die andere eine andere hat. <br><br><img src="https://habrastorage.org/webt/ov/a1/yq/ova1yqiulayufd1o7z6vbmwpb0e.png"><br><br>  Ist das möglich  Ja, vielleicht.  Darüber hinaus passiert dies ziemlich oft.  In diesem Fall bleibt jeder Knoten bei seiner eigenen Version der Blockchain, bis jemand den nächsten Block findet.  Angenommen, der neue Block setzt den grünen Zweig wie in der Abbildung unten fort.  In diesem Fall synchronisieren die Knoten, die der roten Version entsprechen, automatisch die grüne, da die Regel in Bitcoin (und entsprechend in Namecoin) funktioniert: Die längste Version der Blockchain ist wahr.  Die rote Version der Blockchain wird einfach vergessen, zusammen mit Belohnungen für diejenigen, die sie finden. <br><br><img src="https://habrastorage.org/webt/br/le/xq/brlexqeynpgyq5qjq6u0knjla5q.png"><br><br>  Theoretisch kann sich die Situation im zweiten Schritt natürlich wiederholen, und gleichzeitig finden sie mit lila eine andere, die die rote Version der Blockchain fortsetzt.  Und am dritten und so weiter.  Aber die Wahrscheinlichkeit selbst der ersten Gabel ist eher gering, die zweite ist noch geringer und so weiter.  Die längste Gabelung in der Geschichte von Bitcoin war nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vier Blocks</a> .  Irgendwann wird jedoch eine der Niederlassungen ausbrechen und das gesamte Netzwerk wird dorthin gehen. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">51% Angriff</b> <div class="spoiler_text">  Die Tatsache, dass die längste Kette in der Blockchain dominiert, basiert auf einem Angriff mit dem Namen 51%. <br><br>  Stellen Sie sich vor, Sie sind ein Betrüger und kaufen Waren bei <code>1000 BTC</code> in einem Geschäft.  Sie stimmen dem Verkäufer zu und senden ihm das Geld.  Der Verkäufer überprüft die Blockchain, stellt fest, dass eine solche Transaktion tatsächlich durchgeführt wurde, hat alle Überprüfungen bestanden und ist sogar in einen Block geraten, zum Beispiel <code>#123</code> .  Danach geht der Verkäufer zur Post und schickt Ihnen die Ware. <br><br>  Zu diesem Zeitpunkt schalten Sie Ihre Mining-Farm ein und beginnen mit dem Mining ab Block <code>#122</code> .  Wenn Sie über genügend Strom verfügen, können Sie den Rest des Netzwerks überholen und am schnellsten bis Block <code>#124</code> zählen. Danach wechselt die ganze Welt zu Ihrer Version der Blockchain.  Gleichzeitig werden Sie Ihre Transaktion für <code>1000 BTC</code> in keinen der Blöcke aufnehmen, was bedeutet, dass sie für immer vergessen wird, als wäre es nie gewesen.          . <br><br>         ,          .      .   11   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  , ,     6  ,      0,1%    ,    10% .        ,         . ,  Namecoin      ,     20%  . <br><br>       . ,        .    ,  <code>NAME_NEW</code> ,  12 ,       <code>NAME_FIRSTUPDATE</code> . <br></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NAME_FIRSTUPDATE </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Zweck der Operation </font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besteht darin, den Namen, in dem ich angekündigt habe </font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, zu veröffentlichen und einen Wert dafür anzugeben. </font><font style="vertical-align: inherit;">Dazu muss ich eine Transaktion im Netzwerk starten, deren Eingabe die ganz besondere Münze ist, die ich am Ausgang generiert habe </font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um das Nutzungsrecht zu bestätigen, präsentiere ich im Eingabeskript meinen öffentlichen Schlüssel und die Signatur der Transaktion, </font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die vom privaten Paarschlüssel ausgeführt wird, genau nach dem Schema, das wir im Kapitel über untersucht haben </font></font><code>P2PKH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eines der Ergebnisse der Transaktion wird eine neue Spezialmünze sein, die wie die vorherige nicht weniger wiegt </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ihr Ausgabeskript sollte folgendermaßen aussehen:</font></font><br><br><pre> <code class="xml hljs">OP_NAME_FIRSTUPDATE <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Salt</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Value</span></span></span><span class="hljs-tag">&gt;</span></span> OP_2DROP OP_2DROP <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> <code>Salt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist die sehr zufällige Zahl </font></font><code>0xd5eeb22ee8117f57</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die wir in der ersten Phase der Vorbereitung des Skripts erstellt haben </font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- es ist </font></font><code>d/stephenmorse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in hexadezimal </font></font><code>0x642f7374657068656e6d6f727365</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Feld </font></font><code>Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte ein assoziatives Array enthalten, das die Regeln darstellt, nach denen der Name aufgelöst wird. Eine vollständige Liste möglicher Schlüssel und Regeln zum Ausfüllen finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In erster Näherung ist dies ein Analogon der Zonendatei; Der obige Link zeigt die Zuordnung von Namecoin-Entitäten zu bekannten DNS-Entitäten. Die beliebtesten von ihnen sind ip, ein Beispiel, bei dem es höher war, und ns, das wir jetzt verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um anzugeben, was der NS-Server für die Domäne sein wird, setzen wir </font></font><code>1.2.3.4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Wert in Value </font></font><code>{“ns”:[“1.2.3.4”]}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber natürlich in hexadezimal - </font></font><code>0x7b226e73223a5b22312e322e332e34225d7d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schließen Sie wie beim letzten Mal die Münze mit </font></font><code>P2PKH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In seinem Beispiel hat Stephen in Schritt NAME_NEW absichtlich eine Münze mit einem Gewicht von nicht genau </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber mit einem Rand erstellt, so dass dieser Rand im nächsten Schritt für die Provision an den Bergmann ausreichen würde. </font><font style="vertical-align: inherit;">Im allgemeinen Fall hat die Transaktion einen weiteren Eingang, um die Provision sicherzustellen - und einen weiteren Ausgang für die Lieferung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sammeln alles in einer Transaktion und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werfen es in das Netzwerk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/webt/nn/rt/cd/nnrtcdedqwwblvhs_wsdawyivpg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Transaktion in den Block fällt, aktualisieren die Hosts in ihren Tabellen den Wert für den Schlüssel </font></font><code>d/stephenmorse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an </font></font><code>{“ns”:[“1.2.3.4”]}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Alle Browser mit Namecoin-Unterstützung lösen die Domain </font></font><code>stephenmorse.bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ihre Subdomains </font><font style="vertical-align: inherit;">jetzt </font><font style="vertical-align: inherit;">über den DNS-Server unter in IP-Adressen auf </font></font><code>1.2.3.4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NAME_UPDATE </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die "Tabelle" mit Schlüsseln und ihren Bedeutungen, die ich am Ende des letzten Abschnitts erwähnt habe, heißt eigentlich </font></font><code>UTXO set (unspent transaction output)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Da es für das Netzwerk wichtig ist, wiederholte Ausgaben von Geldern zu verhindern, prüft der Miner vor dem Hinzufügen einer Transaktion zum Block, ob die zuvor in der Transaktion angegebenen Eingaben verwendet wurden. Um diesen Vorgang zu beschleunigen, werden alle nicht verwendeten Ausgaben in einer separaten Datenstruktur gespeichert. Diese Struktur existiert nicht auf Netzwerkebene, sondern wird von jedem Knoten lokal berechnet und gespeichert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem ich die Transaktion abgeschlossen habe </font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird die Ausgabe meiner Münze mit einem Gewicht </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, an das der Wert für den Schlüssel angehängt ist </font></font><code>d/stephenmorse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, auf den Tisch gelegt</font></font><code>UTXO</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn diese Ausgabe nicht für 36.000 Blöcke ausgegeben wird (das sind mehr als 8 Monate mit durchschnittlich 10 Minuten pro Block), wird sie als ungültig und der entsprechende Name als frei betrachtet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Zeitraum von 36.000 Blöcken (sowie der Mindestwert einer Spezialmünze </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) ist zu Beginn des Netzwerks klar definiert und unverändert. Um die Registrierung des Namens zu erweitern sowie Änderungen am Datensatz vorzunehmen oder ihn an einen anderen Eigentümer zu übertragen, wird eine Transaktion verwendet </font></font><code>NAME_UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Regeln für den Abschluss einer solchen Transaktion unterscheiden sich praktisch nicht von den oben beschriebenen. Die Eingabe für die Transaktion sollte die Ausgabe der in der Transaktion erhaltenen Münze sein</font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ein zusätzlicher Input ist erforderlich, um die Provision sicherzustellen. </font><font style="vertical-align: inherit;">Von den beiden Ausgaben der Transaktion ist eine eine neue Münze mit einem aktualisierten Wert für den Namen, und die zweite dient dazu, Änderungen von der Provision zu übertragen. </font><font style="vertical-align: inherit;">Das Ausgabeskriptformat für die Münze lautet:</font></font><br><br><pre> <code class="xml hljs">OP_NAME_UPDATE <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Value</span></span></span><span class="hljs-tag">&gt;</span></span> OP_2DROP OP_DROP <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie im vorherigen Fall ist </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dies </font></font><code>d/stephenmorse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- JSON mit einem Wert, beide hexadezimal. </font><font style="vertical-align: inherit;">Schließen Sie den Exit mit P2PKH und werfen Sie die Transaktion </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in das Netzwerk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/webt/ny/2t/vq/ny2tvqbgf2fhkaiebkx2b9_fdkc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen ist dies fast alles, was ich über die Namensverwaltung in Namecoin erzählen wollte. </font><font style="vertical-align: inherit;">Alles, was bleibt, ist ein paar Worte über die Kosten für den Besitz einer Domain zu sagen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kosten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berechnen wir, wie viel der Inhalt des Namens in </font></font><code>Dot-Bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(der Name der DNS-Zone .bit, die auf der Basis von Namecoin arbeitet) in Kryptowährung kostet und die Zahlen in Fiat-Währung umgerechnet mit den Kosten einer „normalen“ DNS-Domain vergleichbar sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie aus dem vorherigen Abschnitt hervorgeht, werden für eine Transaktion die </font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kosten des Domaininhabers </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">darin bestehen, eine Münze zu erstellen, an die die Zone angehängt wird, zuzüglich der Provision des Bergmanns. Bei einer Transaktion </font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird auf Kosten der alten </font><font style="vertical-align: inherit;">eine </font><font style="vertical-align: inherit;">neue Münze erstellt, und der Eigentümer zahlt zusätzlich nur die Provision. Nach ca. 8 Monaten muss der Eigentümer die Transaktion abschließen </font></font><code>NAME_UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um den registrierten Namen beizubehalten. Und hier enden die erforderlichen Kosten für das erste Jahr. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die meisten Artikel über Namecoin (einschließlich des zuvor zitierten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikels von Stephen Morse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) basieren auf Daten aus den ersten Jahren des Bestehens des Netzwerks und behaupten, dass die Bergbaukommission 0,005 NMC beträgt. Seitdem ist der Medianwert der Provision jedoch allmählich gesunken und liegt zu Beginn des Jahres 2019 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bei</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> etwa 0,0003 NMC. Der NMC-Wechselkurs gegenüber dem US-Dollar hingegen kehrte nach mehreren Aufschwüngen auf das Niveau von 2015 zurück und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beträgt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für 1 NMC etwa 0,7 USD. Es ist leicht zu berechnen, dass die Domain in der .bit-Zone im ersten Jahr den Eigentümer ab 0,0109 NMC oder 0,00763 USD kostet. Vielleicht fällt es jemandem leichter, sich an ein ungefähres Analogon dieses Betrags in russischer Währung zu erinnern - 50 Kopeken.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun, dies ist die Untergrenze, die dem Szenario für den Kauf eines Namens für die zukünftige Verwendung oder das Cybersquatting entspricht. Was ist mit der Obergrenze? Da die Eingabe von jeder Transaktion, die die Zone aktualisiert, eine Münze aus einem der vorherigen Blöcke sein sollte, ist das theoretische Maximum der Häufigkeit der Namensaktualisierung gleich der Häufigkeit des Auftretens neuer Blöcke. Unter Hinweis darauf, dass der Durchschnittswert dieses Werts zu Beginn des Netzwerks festgelegt wurde und etwa 10 Minuten beträgt, kann geschätzt werden, dass die Obergrenze der Kosten für die Wartung einer Domain 15,7744 NMC oder etwas mehr als 11 USD beträgt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen können, entspricht selbst ein solch fantastisches Szenario, bei dem ein Name in Namecoin kostenpflichtig verwendet wird, ungefähr dem ersten Jahr, in dem Sie eine reguläre Domain in der beliebtesten .com-Zone besitzen. Wenn wir ein realistischeres Szenario mit einem Update durchschnittlich einmal am Tag vergleichen, kostet der Name in der Bit-Zone etwa 8 Cent pro Jahr, was viel billiger ist als die vorteilhaftesten Angebote im traditionellen DNS, die nicht unter 1 US-Dollar fallen. Im Szenario der kurzfristigen Nutzung der Domain (von mehreren Stunden bis zu einem Monat) beträgt der Unterschied zugunsten von Namecoin bereits zwei Größenordnungen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unter Berücksichtigung der finanziellen Attraktivität des Dienstes sowie der Anonymität des Domaininhabers, einschließlich des Fehlens einer traditionellen „Geldspur“ für gewöhnliches DNS, wird deutlich, warum Namecoin zu einem beliebten Netzwerk für Dienstbesitzer mit einem erhöhten Risiko der Trennung oder Blockierung, insbesondere von Botnetzen, geworden ist. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Botnets in Namecoin </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Tat ist die Tatsache, dass Botnetzbetreiber anfingen, Anonymität </font></font><code>Dot-Bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Schutz ihrer C &amp; C-Server zu verwenden, nicht überraschend. Eine andere Sache ist interessanter - wie lange Botnets in .bit aktiv bleiben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C &amp; C-Domänen, die in „normalen“ DNS-Zonen registriert sind, werden früher oder später vom Eigentümer zurückgezogen, wodurch der Betreiber gezwungen ist, für die Registrierung eines neuen Namens zu zahlen und eine neue Bot-Assembly im Netzwerk mit einem neuen Verwaltungsserver zu starten. Die grundsätzliche Unmöglichkeit, eine Domäne in der .bit-Zone zu entfernen, erhöhte die Botnet-Lebensdauer um Größenordnungen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nehmen wir zum Beispiel die </font></font><code>pationare.bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Dezember 2016 registrierte Domain. Es wurde verwendet, um ein Botnetz zu steuern </font></font><code>Chthronic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Verteilung eines Bankentrojaners, der auf der Basis des berühmten ZeuS gebaut wurde). Vertriebskampagne</font></font><code>Chthronic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">war mit der Verwendung des Exploit Packs RIG verbunden und wurde von verschiedenen Forschern (z. B. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malware-traffic-analysis.net</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) Ende 2016 - dem ersten Halbjahr 2017 - </font><font style="vertical-align: inherit;">ausführlich beschrieben </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist davon auszugehen, dass dieses Botnetz längst zerstört wurde. Aber nein - mehr als zwei Jahre nach dem Start sind die C &amp; C-Domain und das Netzwerk des Botnetzes noch aktiv. Wie aus dem folgenden Screenshot ersichtlich, wurde das letzte Update im Dezember 2018 durchgeführt.</font></font><br><br><img src="https://habrastorage.org/webt/9k/o9/5w/9ko95wbszt4g7fqntkxm0cnh34u.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sieht verlockend aus, oder? Da der DNS-Name des Verwaltungsservers intakt bleibt, muss der Bot-Code nicht häufig aktualisiert und die Verteilungskampagne neu gestartet werden. Es bleiben nur die Kosten für das Ändern des Hostings nach dem Blockieren der IP-Adresse, aber diese Kosten können auch reduziert werden, indem gehackte Webserver als Proxys verwendet werden, deren Shells weniger als einen Dollar kosten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andererseits sind alle Transaktionen in der Blockchain für jeden Teilnehmer öffentlich zugänglich. </font><font style="vertical-align: inherit;">Wie wir in den vorherigen Kapiteln ausführlich besprochen haben, verschwinden Münzen in Namecoin nicht spurlos, was bedeutet, dass wir ihre Umverteilung zwischen Adressen verfolgen können. </font><font style="vertical-align: inherit;">Wenn wir die Regeln und Einschränkungen kennen und berücksichtigen, welche Transaktionen in Namecoin gebildet werden, können wir aussagekräftige Muster finden, in denen die einheitliche Verwaltung einiger an der Transaktion beteiligter Adressen offensichtlich ist. </font><font style="vertical-align: inherit;">In diesem Fall haben die mit Münzen von diesen Adressen bezahlten Domains einen gemeinsamen Eigentümer - die von uns verwaltete Gruppe, die das Botnetz steuert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden diese Idee weiterentwickeln.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Allgemeines IOC-Sammlungsschema </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beschreiben wir das allgemeine Suchschema am Beispiel eines echten Botnetzes der RTM-Gruppe. Wir werden auf diesem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufbauen </font><font style="vertical-align: inherit;">, das als identifiziert wurde </font></font><code>Win32/Spy.RTM.N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/webt/9r/rx/tq/9rrxtqepv4ods_wcbibv-2hk9uk.png"><br><br><img src="https://habrastorage.org/webt/ps/by/dk/psbydk2cmnsifuf5cf8njpmnnvm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie dem obigen Screenshot entnehmen können, wird nach dem Start versucht, die IP-Adresse für den Namen abzurufen </font></font><code>stat-counter-4.bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informationen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zum Transaktionsverlauf für diesen Namen erhalten </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">in Namecoin. </font></font><br><br><img src="https://habrastorage.org/webt/ok/jj/aj/okjjajszmlcuj_8enwzkosbze6k.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Kennung der Transaktion, die diese Domain erstellt hat, erhalten wir durch Klicken auf den Link zur Operation NAME_NEW. Die Eingabeadresse dieser Transaktion, mit deren Hilfe die Domain erstellt wurde, wird offensichtlich von der für uns interessanten Gruppe verwaltet. Er wird die erste Reihe von Daten sein: </font></font><code>N3KPt8py24EAsAiKquyFgoKGyTYeR5Tmry</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><img src="https://habrastorage.org/webt/-k/si/6n/-ksi6n9mz69t-tscu-cpyilewpa.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basierend auf dem anfänglichen Datensatz gehen wir iterativ um die Blockchain herum und bewegen uns in Richtung ihres Wachstums (Aufwärtsbewegung oder Aufwärtsbewegung). Zu Beginn jedes Schritts erhalten wir eine Transaktion, deren bestimmte Münze der Person gehört, an der wir interessiert sind. Im ersten Schritt überprüfen wir die Transaktion anhand des ursprünglichen Datensatzes, dessen Eigentümer wir a priori kennen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Transaktion wird auf Übereinstimmung mit heuristischen Regeln überprüft (wir werden sie unten formulieren), die garantieren, dass eine bestimmte Münze (oder Münzen) am Ende der Transaktion derselben Person gehört wie die bekannte Eingabemünze. Wenn die betreffende Transaktion eine oder mehrere Heuristiken erfüllt, geben solche Leitmünzen die Richtung der weiteren Bewegung an. Die Transaktion, die die Leitmünze ausgibt, ist der nächste Schritt in der Iteration. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei jedem Schritt der Iteration füllen wir die Liste der Domänen, die an den Transaktionen teilgenommen haben, und die Liste der IP-Adressen, in die diese Domänen aufgelöst wurden, auf. Dies sind historische Identifikatoren des Kompromisses (IOC), die für Forensiker sowie zur Identifizierung von Taktiken und Gruppierungsmethoden verwendet werden können.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bewegung stoppt, wenn die betreffende Transaktion keine der Heuristiken erfüllt. Dies bedeutet, dass wir nicht mit Sicherheit sagen können, dass die Ergebnisse der betreffenden Transaktion von der Person kontrolliert werden, an der wir interessiert sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere Situation, die die Bewegung stoppt, ist das Fehlen von Transaktionen von der Ausgabeadresse. Wir werden solche Adressen in einer separaten Liste nicht ausgegebener Münzen (UTXO) speichern. Sie stellen den größten Wert in der gesamten Studie dar. Da wir sicher sind, dass diese Adressen von der Person verwaltet werden, an der wir interessiert sind, generiert jede zukünftige Transaktion, die diese Adressen verwendet, ein neues, zuvor unbekanntes IOC - den Domänennamen oder die IP-Adresse -, das von der Gruppierung noch nicht verwendet wurde. Aber mit hoher Wahrscheinlichkeit wird es bald sein.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Blockchain zu umgehen, ist es bequem, sie in die Datenbank zu exportieren. Hierfür können Sie beispielsweise das modifizierte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dienstprogramm rusty-blockparser verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mit dem wir die Unterstützung für Namecoin verbessert haben, indem wir die Erkennung von Vorgängen </font></font><code>NAME_*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Datenstrukturen </font></font><code>Auxiliary Proof-of-Work</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und das Exportformat erweitert haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Python-Pseudocode für die Aufwärtsbewegung ist unten dargestellt. Im Folgenden wird angenommen, dass die Blockchain-Transaktionsdaten in MongoDB gespeichert sind.</font></font><br><br><pre> <code class="python hljs">start = <span class="hljs-string"><span class="hljs-string">"37d40bc2f3ca7415908dc9e276593b50d3120158cd540cb088246f2e2cf88b16"</span></span> tx = namecoin.transactions.find_one({<span class="hljs-string"><span class="hljs-string">"id"</span></span>: start}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upstream_movement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> names <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> IPs <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> utxo <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> known_addresses heuristic_result = upstream_heuristic_test(tx) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> heuristic_result <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> heuristic_result.guiding_outs: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx.has_name_op(): names.add(tx.name_op.name) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ip_address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.name_op.get_ip(): IPs.add(ip_address) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> guiding_out <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> heuristic_result.guiding_outs: known_addresses.add(guiding_out.address) tx = namecoin.transactions.find_one({<span class="hljs-string"><span class="hljs-string">"in.id"</span></span>: guiding_out.id}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx: upstream_movement(tx) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: utxo.add(guiding_out)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der zweite Teil des Blockchain-Bypasses ist die Bewegung gegen das Wachstum der Blockchain (Abwärtsbewegung oder Abwärtsbewegung). Im Allgemeinen unterscheidet sich der Abwärtsbewegungsalgorithmus nicht vom Aufwärtsalgorithmus. Eine Bewegung beginnt mit einer Transaktion aus dem Originaldatensatz. Bei jedem Schritt wird die Transaktion auf Übereinstimmung mit heuristischen Regeln überprüft (im Allgemeinen anders als bei den Regeln für die Aufwärtsbewegung). Der einzige Unterschied besteht darin, dass sich die Münze, deren Mitgliedschaft a priori bekannt ist, am Ende der Transaktion befindet und die Heuristik garantiert, dass dieselbe Person eine oder mehrere Münzen am Eingang hat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Abwärtsbewegung stoppt auch, wenn die aktuelle Transaktion keine der Heuristiken erfüllt. </font><font style="vertical-align: inherit;">Im Gegensatz zur Aufwärtsbewegung können wir nicht ausgegebene Münzen unter den Führungen nicht treffen, und diese Option zum Beenden der Rekursion in der Abwärtsbewegung funktioniert nicht. </font><font style="vertical-align: inherit;">Aber wie bei der Aufwärtsbewegung füllen wir sowohl die Liste der Namen als auch die Liste der IP-Adressen auf. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python-Pseudocode für die Abwärtsbewegung würde folgendermaßen aussehen:</font></font><br><br><pre> <code class="python hljs">start = <span class="hljs-string"><span class="hljs-string">"37d40bc2f3ca7415908dc9e276593b50d3120158cd540cb088246f2e2cf88b16"</span></span> tx = namecoin.transactions.find_one({<span class="hljs-string"><span class="hljs-string">"id"</span></span>: start}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downstream_movement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> names <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> IPs <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> utxo <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> known_addresses heristic_result = downstream_heuristic_test(tx) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> heuristic_result <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> heuristic_result.guiding_ins: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx.has_name_op(): names.add(tx.name_op.name) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ip_address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.name_op.get_ip(): IPs.add(ip_address) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> guiding_in <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> heuristic_result.guiding_ins: known_addresses.add(guiding_in.address) tx = namecoin.transactions.find_one({<span class="hljs-string"><span class="hljs-string">"out.id"</span></span>: guiding_in.id}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx: downstream_movement(tx)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betrachten Sie nun die heuristischen Regeln, die wir beim Bewegen entlang der Blockchain verwenden werden. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Heuristische Regeln </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gemeinsame Veränderung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns noch einmal die Transaktion an, von der oben ein Screenshot gezeigt wurde. Eine Adresse, </font></font><code>N3KPt8py24EAsAiKquyFgoKGyTYeR5Tmry</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Geld zum Erstellen eines neuen Namens enthält, </font><font style="vertical-align: inherit;">wird an die Transaktionseingabe gesendet </font><font style="vertical-align: inherit;">. Es </font><font style="vertical-align: inherit;">gibt zwei Adressen </font><font style="vertical-align: inherit;">für Transaktionen </font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>NAME_UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Eingang - eine spezielle Münze mit einer Zone aus der vorherigen Transaktion nach Domain und zusätzlichen Mitteln zur Deckung der Provision. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich werde sofort feststellen, dass wir im Zusammenhang mit Transaktionen sowohl über Münzen als auch über Adressen sprechen werden. Trotz der Tatsache, dass diese Konzepte in einigen Werken als nahezu gleichwertig angesehen werden, ist es wichtig, dass wir den Unterschied zwischen diesen Begriffen klar angeben, da wir im Verlauf der Studie Schlussfolgerungen sowohl zu Münzen als auch zu Adressen ziehen werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit "Münze" meinen wir einen positiven Saldo, der als Ergebnis einer Transaktion gebildet wird. Diese Münze wird durch die Transaktionsnummer, die sie generiert hat, und den Exit-Index identifiziert. Beispielsweise hat eine Münze am Eingang der oben betrachteten Transaktion eine Kennung </font></font><code>5778be8e1901e9931e9b41a128a0b7f963e6e1ae72e461df2cba26e6279d433a:1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da sie als Ausgabe (mit Index 1) der Transaktion gebildet wurde </font></font><code>5778be8e1901e9931e9b41a128a0b7f963e6e1ae72e461df2cba26e6279d433a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine spezielle Münze nennen wir nach wie vor eine Münze mit dem Nennwert b </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>locking script</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die die Operation mit einem Domainnamen enthält. Wir haben den Mechanismus für die Bildung solcher Münzen im Abschnitt Domain Management eingehend untersucht. Eine gewöhnliche Münze nennen wir eine Münze willkürlichen Nennwerts, an die die Operation mit der Domäne nicht gebunden ist.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Haupteigenschaft von Münzen ist ihre Unveränderlichkeit. Jede Münze kann nur einmal und nur in ihrer Gesamtheit ausgegeben werden. Daher wird jede im Namecoin-Netzwerk maximal zweimal erwähnt: einmal bei der Erstellung und ein zweites Mal bei Ausgaben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit "Adresse" meinen wir eine Kennung, die ein Schlüsselpaar eindeutig identifiziert, das ein Sperrskript in einem Format öffnen kann </font></font><code>P2PKH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das eine Münze schließt, die sich am Eingang oder Ausgang einer Transaktion befindet. Da nur der der Adresse entsprechende Schlüssel eine Münze ausgeben kann, ist die nächste Analogie der physischen Welt zur Adresse die Brieftasche, in der die Münzen aufbewahrt werden (und von der sie ausgegeben werden).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotz der Tatsache, dass in Namecoin eine Adresse oft nur zweimal verwendet wird, ist es nicht erforderlich, eine einzelne Münze zu empfangen und zu konsumieren. Die Fakten der Wiederverwendung von Adressen werden uns in Zukunft ein wenig helfen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben im Kapitel von Bitcoin 201 ausführlicher über Eingaben, Ausgaben und Adressen gesprochen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Ende der Transaktion werden also zwei Münzen gebildet. </font></font><code>N2hgZoWaTKoJ7FPmLuytTow3XrCCfEj2ca</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieselbe Spezialmünze mit einem Gewicht von 0,01 NMC, an die die Domain gebunden ist, ging an die </font><font style="vertical-align: inherit;">Adresse </font><font style="vertical-align: inherit;">. Eine </font></font><code>NKMMLwyMw4nwGuke6vd3AuDBMP18FWRaF1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gewöhnliche Münze mit Wechselgeld wurde an die </font><font style="vertical-align: inherit;">zweite Adresse geschickt </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist das häufigste Transaktionsschema. Es gibt immer noch Optionen, wenn sich mehr als eine Münze am Eingang befindet, aber ihre gemeinsame Eigenschaft ist, dass die Münze mit Wechselgeld immer genau gleich ist.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können davon ausgehen, dass eine solche Transaktion einer einfachen Aktualisierung der Domäneninformationen entspricht. Die Zahlung für die Aktualisierung erfolgt mit einer (seltener mehreren) Münzen einer Person. Da eine Transaktion immer nur einen Autor hat, muss sie alle Eingabeadressen verwalten. Ohne dies kann er kein Entsperrskript erstellen, das für die Verwendung der Münzen aus dieser Brieftasche erforderlich ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun, da alle Änderungen aus dieser Operation in einer Münze gesammelt sind, ist es klar, dass diese Münze derselben Person gehört wie die Münzen am Eingang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein ähnliches Schema für Bitcoin wird in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieser Arbeit beschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wo es aufgerufen wird </font></font><code>one-time change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es spiegelt die Methode wider, mit der native Bitcoin-Anwendungen Transaktionen ausführen - </font></font><code>bitcoind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und</font></font><code>bitcoin-qt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Einmalig (einmalig) wird es aufgrund einer anderen Funktion dieser Anwendungen aufgerufen. Standardmäßig generieren sie am Ausgang der erstellten Transaktion neue Adressen für Münzen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namecoin hat zusammen mit der Bitcoin-Codebasis den Großteil des Codes für diese Anwendungen geerbt, die als </font></font><code>namecoind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und bezeichnet werden </font></font><code>namecoin-qt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Bei normalen Münzen können wir diese Heuristik ohne Änderungen verwenden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Statistik der Wiederverwendung von Adressen zur Aufbewahrung von Spezialmünzen zeigt, dass diese Regel in den meisten Fällen auch für sie eingehalten wird. Die Wiederverwendung solcher Adressen ist ziemlich selten. Mehrfach verwendete Adressen, etwa 6% der Gesamtzahl; mehr als zweimal - ungefähr 1%. Basierend auf dem Zweck von Namecoin kann davon ausgegangen werden, dass die meisten Transaktionen mit speziellen Münzen im Netzwerk einfache Erstellungs- und Aktualisierungsvorgänge sind, bei denen sich der Domaininhaber nicht ändert. Daher können wir argumentieren, dass eine solche Operation dem Abheben einer speziellen Münze an eine neue, zuvor nicht verwendete Adresse entspricht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns nun ein Beispiel für eine Transaktion mit einer wiederverwendeten Adresse für eine spezielle Ausgabemünze an. Nehmen Sie dazu eine andere Transaktion der RTM-Gruppe vor -</font></font><code>b3c7ce9ca3a689c6236b9d6df3c257c5fab6c3985187669ccf731ac42a127a11</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/webt/em/d6/hx/emd6hxidz3xhgqny_f5e7ho5-04.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Adresse, </font></font><code>NDpWDEx1mBkUYywqxDTAZZeGCfUV4GkVE8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an die die Spezialmünze ging, wurde bereits in früheren Transaktionen verwendet. </font></font><br><br><img src="https://habrastorage.org/webt/ws/32/00/ws3200wv6hvjc1z63vt4p1hdivs.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bereits erwähnt, führen die Standardskripte in nativen Clientanwendungen für Namecoin nicht zur Wiederverwendung von Adressen. Um eine spezielle Münze an eine vorhandene Adresse zu senden, muss der Eigentümer separate, optionale Anstrengungen unternehmen, um die Ausgangsadresse in der Phase der Transaktionsbildung explizit herauszufinden und anzugeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum könnte dies erforderlich sein? Die einzige Erwähnung der Situation, in der die Exit-Adresse manuell angegeben wird, traf ich nur in den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anweisungen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zum Übertragen der Domain auf einen anderen Eigentümer.</font></font><br><br><img src="https://habrastorage.org/webt/zv/8q/pe/zv8qpeblzvm4jogj-axkgmcgili.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Vermutung wird bestätigt, wenn wir das weitere Schicksal der Adressen am Ende der betreffenden Transaktion berücksichtigen. In der folgenden Abbildung ist diese Transaktion durch einen hellgrünen Meilenstein gekennzeichnet. Es ist ersichtlich, dass die nächste Transaktion </font></font><code>9e16f6be</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der stat-counter-4-Domäne unter Verwendung einer Geldadresse stattfand </font></font><code>NJ8xUePv</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die keine explizite Verbindung mit der in der "übergeordneten" Transaktion verwendeten Adresse hat. Offensichtlich wurde die Domain an die Verwaltung einer anderen Person übertragen.</font></font><br><br><img src="https://habrastorage.org/webt/ue/ho/ea/uehoea2yau72ydjns-ujsixawkw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im allgemeinen Fall kann dies entweder der Verkauf einer Domain an einen anderen Eigentümer sein, der nicht mit den Aktivitäten der betreffenden Person zusammenhängt, oder die Übertragung einer Domain zwischen den Konten einer Person. </font><font style="vertical-align: inherit;">Die zweite Option ist die Einfachheit und die geringen Kosten für die Registrierung einer neuen Domain sowie das fehlende sichtbare Interesse von Organisationen und Markeninhabern an der Registrierung von Domains in der .bit-Zone. </font><font style="vertical-align: inherit;">Wir konnten nicht wenigstens eine berechtigte Motivation für den Kauf einer Domain finden, die bei böswilligen Aktivitäten festgestellt wurde. </font><font style="vertical-align: inherit;">Wir glauben daher, dass trotz der Möglichkeit, die Domain auf eine andere Person zu übertragen, Transaktionen mit wiederverwendbaren Adressen für den Abzug einer speziellen Münze eine Neuordnung von Vermögenswerten zwischen mehreren Konten darstellen, die von einer Gruppe kontrolliert werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir formulieren die obigen Argumente in Form einer heuristischen Regel, die wir als allgemeine Änderung bezeichnen werden: </font></font><br><br><blockquote>         ,   ,       ,     . <br><br>          ,     ,    . <br><br>  ,    ,     . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Schema zur Verwendung dieser Regel ist in der Abbildung dargestellt. Graue Bäche - gewöhnliche Münzen, grün - eine besondere Münze. Die Hilfslinien sind alle Münzen vom Ende der Transaktion gegenüber der Münze, durch die wir zu dieser Transaktion gekommen sind: Alle Ausgaben sind für die Aufwärtsbewegung und alle Eingaben für die Abwärtsbewegung. </font></font><br><br><img src="https://habrastorage.org/webt/1a/bh/fo/1abhfo8tmu_v8xwuw_uk7j0mla4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir stellen einige Merkmale dieser Heuristik fest. Erstens bidirektional: Es funktioniert sowohl für die Aufwärtsbewegung, wenn wir den Besitzer des Eingangs kennen, als auch für die Abwärtsbewegung, wenn wir den Besitzer einer der Münzen am Ausgang kennen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens die optionale Verfügbarkeit einer speziellen Münze: Trotz der Tatsache, dass die Transaktion in Abwesenheit nicht mit der Aktualisierung der Domain zusammenhängt, bleibt die oben angegebene logische Begründung bezüglich des Besitzers einer regulären Münze gültig.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Pseudocode zum Testen einer Transaktion auf Übereinstimmung mit der allgemeinen Änderungsregel würde folgendermaßen aussehen: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">common_change</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> result = {<span class="hljs-string"><span class="hljs-string">"guiding_outs"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>: []} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(tx.outs.money) != <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {} addr = tx.outs.money[<span class="hljs-number"><span class="hljs-number">0</span></span>].address first_tx = namecoin.tx.find_one({<span class="hljs-string"><span class="hljs-string">"out.id"</span></span>: addr}, sort=[(<span class="hljs-string"><span class="hljs-string">"block"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first_tx.id != tx.id: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: result[<span class="hljs-string"><span class="hljs-string">"guiding_outs"</span></span>] = tx.outs.all result[<span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>] = tx.ins.all <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gemeinsame Ausgaben </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die oben betrachtete Heuristik hat neben der Bidirektionalität eine weitere wichtige Eigenschaft. Gemeinsame Veränderung - Heuristik "ohne Gedächtnis"; Das Überprüfungsergebnis wird nur durch die Merkmale der betreffenden Transaktion bestimmt und hängt nicht von den Ergebnissen anderer Heuristiken und akkumulierter Daten ab. Eine solche Heuristik ist in den ersten Iterationen einer Durchquerung für das anfängliche Füllen eines Datensatzes unverzichtbar. Andererseits ist es leicht, die Einschränkungen seiner Anwendung zu bemerken. Zum Beispiel wird sie sich auf eine Transaktion konzentrieren, die zwei oder mehr Geldausgaben enthält. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten Sie als Beispiel für eine solche Transaktion </font></font><code>db4ff4082f39d0a501508706e627f26aa92712d27b4f633ded59917d201cfae5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Diese Transaktion bezieht sich auf die Aktivitäten der Gruppe, die das Dimnie-Botnetz verwaltet. </font></font><br><br><img src="https://habrastorage.org/webt/td/61/-c/td61-cbmmd7enx-0olfyjxrpcva.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben diese Transaktion über die Adresse abgewickelt</font></font><code>My7Ap3nH5f4X6Us2KiUWisd77wRpMG1MDY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies wurde in der vorherigen CC-Transaktion als Anmeldeadresse verwendet. Trotz der Tatsache, dass seine Haltung gegenüber der untersuchten Person zweifelsfrei ist, können wir über keinen der anderen Ausgänge und Eingänge dasselbe (wie auch das Gegenteil) sagen. Dies kann eine Umverteilung von Münzen zwischen Gruppenadressen sein. In diesem Fall werden alle Adressen von der Person kontrolliert, an der wir interessiert sind. Oder handelt es sich möglicherweise um eine Aufladung von den Adressen einer der Börsen, an denen Namecoin-Token verkauft werden? Oder eine Übertragung von einem anderen Netzwerkmitglied, das nicht mit den Aktivitäten der untersuchten Person zusammenhängt. Es ist unmöglich, allein aus den Attributen dieser Transaktion einen endgültigen Schluss zu ziehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten Sie die Adresse</font></font><code>N4XtLb7xpC4Zk72T8QcshKhTW17ZCyQ1j1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Eingang dieser Transaktion. </font><font style="vertical-align: inherit;">Diese Adresse wurde bereits zuvor ("früher" für eine Abwärtsbewegung bedeutet "in der Zukunft", "in Richtung Blockchain-Wachstum") bei der Eingabe einer CC-Transaktion verwendet </font></font><code>6bffc741eb66de074c09a380fb5e6bd13d4bd5205c36a76e3682674dba08461e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sodass wir davon ausgehen können, dass diese Adresse von der für uns interessierenden Person verwaltet wird. </font><font style="vertical-align: inherit;">Und da, wie bereits gezeigt wurde, die Schlüssel für alle Münzen am Eingang der Transaktion von einer Person gesteuert werden (was nicht über die Ausgaben gesagt werden kann), haben wir Grund zu der Annahme, dass alle anderen Eingaben ebenfalls zu der für uns interessanten Gruppe gehören. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die strenge Bedingung der heuristischen gemeinsamen Ausgaben sieht sehr einfach aus:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn bekannt ist, dass mindestens eine der Adressen am Eingang der Transaktion von einer bestimmten Person gesteuert wird, werden alle anderen Adressen an den Eingängen dieser Transaktion von derselben Person gesteuert. </font><font style="vertical-align: inherit;">Münzen an diesen Eingängen gehören derselben Person.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen, ist diese Heuristik nur für die Abwärtsbewegung sinnvoll. Wenn wir uns in Richtung Blockchain-Wachstum bewegen, kommen wir über einen der Inputs zu der untersuchten Transaktion. In diesem Fall wird die Regelbedingung automatisch erfüllt, sagt jedoch nichts über die Ausgaben der Transaktion aus und ermöglicht es Ihnen nicht, sich weiter in die Upstream-Richtung zu bewegen. Mit anderen Worten, dies ist eine unidirektionale Heuristik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das zweite erwähnenswerte Merkmal dieser Heuristik ist, dass wir hier zuerst die Daten verwendet haben, die bei der Überprüfung früherer Transaktionen gesammelt wurden - eine Liste von Adressen, die von der untersuchten Person verwaltet werden. Aus diesem Grund kann diese sekundäre Heuristik nicht für unabhängige Bewegungen verwendet werden, ohne eine primäre Heuristik, die nicht von den akkumulierten Ergebnissen abhängt (z. B. gemeinsame Änderung).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Pseudocode zum Testen einer Transaktion auf Übereinstimmung mit der allgemeinen Ausgabenregel würde folgendermaßen aussehen: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">common_spending</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> result = { <span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>: [] } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> input <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.get_ins(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input.address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> known_addresses: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>: tx.ins.all} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {}</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bekannte Adresse </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die letzte Heuristik, die wir im Rahmen dieses Abschnitts betrachten werden, ist die einfachste von allen. </font><font style="vertical-align: inherit;">Dies ist eine sekundäre bidirektionale Heuristik, die (da sie bidirektional ist) sowohl für Aufwärts- als auch für Abwärtsbewegungen verwendet werden kann. </font><font style="vertical-align: inherit;">Die strikte Formulierung der heuristischen bekannten Adresse für die Aufwärtsbewegung sieht folgendermaßen aus:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn bekannt ist, dass die Adresse am Eingang (Ausgang) der Transaktion von einer bestimmten Person gesteuert wird, gehören die an dieser Adresse empfangenen Münzen (die von dieser Adresse ausgegeben werden) derselben Person. </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl die Heuristik wie eine offene Binsenweisheit aussieht, hilft diese Regel dabei, Zweige und Schnittpunkte in Münzflüssen zu finden, und fügt dem Transaktionsbaum Konnektivität hinzu. Darüber hinaus können Sie die Bewegung von Transaktionen, die nicht unter andere Heuristiken fallen, nicht stoppen. Ein Beispiel ist die Transaktion des </font></font><code>7a35b9cb0a16b3eba92781be014555eaa4255bd17655bb00f2b3f42c3950ac69</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bereits erwähnten Dimnie-Botnetzes. </font></font><br><br><img src="https://habrastorage.org/webt/06/eg/as/06egasevdvty7quvjjvr0jrp6gy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir es in einer Aufwärtsbewegung erreicht haben, werden wir nicht in der Lage sein, mit Hilfe gemeinsamer Veränderungen voranzukommen, da die Ausgabe mehr als eine gewöhnliche Münze ist. Bei einer Transaktion können wir nicht sagen, wie viele Münzen in der Ausgabe derselben Person gehören wie die Münze in der Ausgabe - beide, eine oder gar keine. Die Verwendung der bekannten Adressheuristik ermöglicht es Ihnen, aufgrund der Tatsache, dass die Adresse</font></font><code>MwMdTb8WQvoRW9jEW5dHn9SkkCJTRn31wQ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">war an der CC-Transaktion beteiligt </font></font><code>cf7ac8986f9855246c6cf26df9a24aa5645cb9258bf787e034a33e75101ae1fc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit der die Domain erstellt </font><font style="vertical-align: inherit;">wurde, die zuvor in der Upstream-Bewegung erfüllt wurde </font></font><code>d/sectools</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Vollständigkeit halber geben wir den Pseudocode der heuristischen bekannten Adresse an:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">known_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> result = { <span class="hljs-string"><span class="hljs-string">"guiding_outs"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>: [] } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> output <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.get_outs(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> known_addresses: result[<span class="hljs-string"><span class="hljs-string">"guiding_outs"</span></span>].append(output) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> input <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.get_ins(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input.address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> known_addresses: result[<span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>].append(input) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt haben wir also sowohl den allgemeinen Bypass-Algorithmus als auch die Heuristiken, die für die Bewegung entlang der Blockchain erforderlich sind, damit wir sie zusammenstellen können, um ein IOC von Namecoin zu erhalten. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lass uns gehen! </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden die RTM-Transaktionen mit der Aufwärts- und Abwärtsbewegung beginnen, beginnend mit </font></font><code>37d40bc2f3ca7415908dc9e276593b50d3120158cd540cb088246f2e2cf88b16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Im Zuge der Weiterentwicklung der Blockchain werden wir nicht nur das IOC sammeln, sondern auch die Transaktionen selbst, die die Heuristiken erfüllen. Münzen fließen zwischen Transaktionen, die wir anhand des Sankey-Diagramms visualisieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das vollständige Diagramm ist zu groß, um im Format dieses Dokuments angezeigt zu werden. Daher werde ich hier nur einen Teil davon angeben, der für die weitere Geschichte erforderlich ist. </font></font><br><br><img src="https://habrastorage.org/webt/zj/jh/un/zjjhundsmnmtabrgw81hkty76nk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Strom gewöhnlicher Münzen ist grau hervorgehoben. Die restlichen Farben entsprechen den Flüssen von Spezialmünzen. Für jeden Namen wird eine eigene Farbe ausgewählt. Weiße Meilensteine ​​entsprechen Transaktionen, die die heuristischen Bedingungen erfüllen. Die leuchtend roten Meilensteine ​​rechts sind UTXO.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Diagrammelement, auf das ich aufmerksam machen möchte, ist mit einem blauen Meilenstein hervorgehoben. Dies ist ein baumelnder Eintrag - eine Münze, die bei der Eingabe einer Transaktion entstanden ist, die der Algorithmus an die Aufwärtsbewegung weitergegeben hat, aber die Transaktion, die diese Münze erstellt hat, hat ihn nicht getroffen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baumelnde Eingaben sind Anzeichen dafür, dass die untersuchte Struktur Seitenzweige aufweist, die nicht mit dem Hauptstamm verbunden sind, entlang dem sich der Algorithmus bewegt. Im gezeigten Fall ist dies ein weiteres unabhängiges Konto. Wie im Diagramm zu sehen ist, werden damit Änderungen für die bereits bekannten Domänen bezahlt. Daraus können wir schließen, dass dieses Konto auch von der untersuchten Person kontrolliert wird. Um das IOC zu erhalten, das mit Vorgängen auf diesem Konto verknüpft ist, bis es im Diagramm angezeigt wird, starten wir eine separate Abwärtsbewegung, beginnend mit einer Transaktion mit einem baumelnden Eintrag. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In ähnlicher Weise können bei einer Abwärtsbewegung baumelnde Ausgänge auftreten. Für jeden von ihnen starten wir ab der entsprechenden Transaktion eine separate Aufwärtsbewegung.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusätzlich zu den Transaktionen der Gruppe, die das RTM-Botnetz steuert, haben wir auch die Transaktionen der Gruppen untersucht, die die Shifu-, Dimnie- und GandCrab-Botnetze steuern. Als Ergebnis wurden 164 im Interesse dieser Gruppen registrierte Domains und 277 mit diesen Namen verknüpfte IP-Adressen gefunden. Zum Zeitpunkt dieses Schreibens blieben von den gesammelten UTXO, die zu diesen Gruppen gehören, 39 Münzen in Kraft. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die IOC-Listen sowie die Namecoin-Adressen, auf denen die nicht verwendeten Münzen der Gruppen verblieben sind, sind in Anhang A aufgeführt.</font></font><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Testen im realen Leben ist eine Herausforderung für fast jede Technologie. Mitte der 2000er Jahre war Wikipedia zu einer so beliebten vertrauenswürdigen Informationsquelle geworden, dass es durch die Änderung der Artikeltexte möglich wurde, die öffentliche Meinung zu kontrollieren, loszulegen und Geld zu verdienen. Diese Periode in der Geschichte des Dienstes ist berühmt für seine enormen Revisionskriege - den aggressiven Einsatz des Mechanismus zur Korrektur von Artikeln und die Rücknahme von Änderungen durch mehrere Kriegsparteien, um den Streit um den Inhalt des Artikels zu gewinnen. Wikipedia-Seiten wurden zu einer internationalen Eitelkeitsmesse, auf der jeder buchstäblich das letzte Wort sagen wollte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einerseits begannen sie mit den Änderungen zu kämpfen und stellten spezielle Regeln auf, die es im Streitfall erlauben, die Möglichkeit der Bearbeitung des Artikels vorübergehend auszuschließen - bis die Debattierer im Abschnitt "Diskussion" einen Kompromisswortlaut finden. Andererseits zwang der Revisionskrieg Wikipedia, einen dynamischen Mechanismus für die Verwaltung der Ressourcen von Administratoren einzuführen, der es ihnen ermöglichte, schnell an der Lösung von Konflikten in den heißesten Bereichen beteiligt zu sein. Darüber hinaus nutzte die Enzyklopädie die öffentliche Aufmerksamkeit, die durch Zusammenstöße um einzelne Artikel auf sich gezogen wurde, um mehr Teilnehmer für die Bearbeitung dieser Artikel zu gewinnen und die korrekteste und vollständigste Berichterstattung über ein bestimmtes Thema zu erreichen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kann Namecoin wie Wikipedia erwachsen werden und seine Herausforderung bewältigen? </font><font style="vertical-align: inherit;">Kommt Zeit, kommt Rat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS-Tabellen mit Kompromissindikatoren </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sind auf GitHub verfügbar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gepostet von</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alexey Goncharov, PT Expert Security Center</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460857/">https://habr.com/ru/post/de460857/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460845/index.html">Fernando Corbato, der Vater Ihres Computers (und Passworts), starb im Alter von 93 Jahren</a></li>
<li><a href="../de460847/index.html">12,3 Millionen gleichzeitige WebSockets</a></li>
<li><a href="../de460849/index.html">Teil 4. Ein Diagrammmodell zur Berechnung logischer Funktionen für asynchrone parallele Prozesse</a></li>
<li><a href="../de460851/index.html">SamsPcbGuide, Teil 10: Technologie - Löten bleifreier Komponenten</a></li>
<li><a href="../de460855/index.html">Wie verwende ich PHP zur Implementierung von Microservices?</a></li>
<li><a href="../de460859/index.html">IThink # 3 Konferenz in Kharkov - basierend auf WWDC 2019</a></li>
<li><a href="../de460861/index.html">JavaScript lexikalischer Umfang und Abschluss</a></li>
<li><a href="../de460863/index.html">Details zum Cloudflare-Absturz 2. Juli 2019</a></li>
<li><a href="../de460865/index.html">Menschen auf dem Mond. Quellen</a></li>
<li><a href="../de460867/index.html">Sourcery zur automatischen Konvertierung in Realm-Objektstrukturen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>