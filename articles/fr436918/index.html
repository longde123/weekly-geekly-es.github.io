<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé´ üòØ ü§µüèº Cr√©ation d'un jeu pour Game Boy, partie 2 ‚ôãÔ∏è ü§¶üèª ü§ú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques semaines, j'ai d√©cid√© de travailler sur un jeu pour Game Boy, dont la cr√©ation m'a fait grand plaisir. Son nom de travail est Aqua and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ation d'un jeu pour Game Boy, partie 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436918/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/849/ccb/9b1/849ccb9b1062f45b917d8771b08bf2c0.png" alt="image"></div><br>  Il y a quelques semaines, j'ai d√©cid√© de travailler sur un jeu pour Game Boy, dont la cr√©ation m'a fait grand plaisir.  Son nom de travail est Aqua and Ashes.  Le jeu est open source et est publi√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> .  La partie pr√©c√©dente de l'article est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  Sprites fantastiques et o√π ils vivent </h2><br>  Dans la derni√®re partie, j'ai termin√© le rendu de plusieurs sprites √† l'√©cran.  Cela a √©t√© fait de mani√®re tr√®s arbitraire et chaotique.  En fait, je devais indiquer dans le code quoi et o√π je veux afficher.  Cela a rendu la cr√©ation d'animation presque impossible, a pass√© beaucoup de temps CPU et un support de code compliqu√©.  J'avais besoin d'un meilleur moyen. <br><br>  Plus pr√©cis√©ment, j'avais besoin d'un syst√®me dans lequel je pouvais simplement r√©p√©ter le num√©ro d'animation, le num√©ro d'image et le minuteur pour chaque animation individuelle.  Si je devais changer l'animation, je changerais simplement l'animation et r√©initialiserais le compteur d'images.  La proc√©dure d'animation effectu√©e dans chaque image doit simplement choisir les sprites appropri√©s √† afficher et les lancer sur l'√©cran sans aucun effort de ma part. <br><a name="habracut"></a><br>  Et il s'est av√©r√© que cette t√¢che est pratiquement r√©solue.  Ce que je cherchais s'appelle des <em>mappages de sprites</em> .  Les cartes de sprites sont des structures de donn√©es qui (grosso modo) contiennent une liste de sprites.  Chaque carte de sprite contient tous les sprites pour le rendu d'un seul objet.  Des <em>cartes d'animation (mappages d'animation)</em> , qui sont des listes de cartes de sprites avec des informations sur la boucle, leur sont √©galement associ√©es. <br><br>  C'est assez dr√¥le qu'en mai, j'ai ajout√© un √©diteur de carte d'animation √† l'√©diteur de carte de sprite pr√™t √† l'emploi pour les jeux Sonic 16 bits sur Sonic.  (Il est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , vous pouvez √©tudier) Il n'est pas encore termin√©, car il est plut√¥t rugueux, douloureusement lent et peu pratique √† utiliser.  Mais d'un point de vue technique, cela fonctionne.  Et <em>il me</em> semble que c'est plut√¥t cool ... (L'une des raisons de la rugosit√© √©tait que j'ai d'abord litt√©ralement travaill√© avec le framework JavaScript.) Sonic est un ancien jeu, il est donc id√©al comme fondement de mon nouveau jeu ancien. <br><br><h2>  Format de carte Sonic 2 </h2><br>  J'avais l'intention d'utiliser l'√©diteur dans Sonic 2 parce que je voulais cr√©er un hack pour Genesis.  Sonic 1 et 3K sont fondamentalement presque les m√™mes, mais pour ne pas compliquer, je me limiterai √† l'histoire de la deuxi√®me partie. <br><br>  Tout d'abord, regardons les cartes de sprites.  Voici un sprite Tails assez typique, qui fait partie de l'animation de clignotement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a1/5c7/1a0/6a15c71a0607d906333fe5e189c3b223.png"></div><br>  La console Genesis cr√©e des sprites un peu diff√©remment.  La tuile Genesis (la plupart des programmeurs l'appellent un ¬´motif¬ª) est 8x8, tout comme sur le Game Boy.  Le sprite se compose d'un rectangle jusqu'√† 4x4 tuiles, un peu comme le mode sprite 8x16 sur Game Boy, mais plus flexible.  L'astuce ici est qu'en m√©moire ces tuiles doivent √™tre c√¥te √† c√¥te.  Les d√©veloppeurs de Sonic 2 voulaient r√©utiliser autant de tuiles que possible pour un cadre Tails clignotant √† partir d'un cadre Tails debout.  Par cons√©quent, Tails est divis√© en 2 sprites mat√©riels, constitu√©s de tuiles 3x2 - une pour la t√™te, l'autre pour le corps.  Ils sont illustr√©s dans la figure ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3c/f35/4fd/b3cf354fd7f9f482b3e04ca5ab6b7ad3.png"></div><br>  Le haut de cette bo√Æte de dialogue contient les attributs du sprite mat√©riel.  Il contient leur position par rapport au point de d√©part (les nombres n√©gatifs sont coup√©s; en fait, ce sont -16 et -12 pour le premier sprite et -12 pour le second), la tuile initiale utilis√©e dans VRAM, la largeur et la hauteur du sprite, ainsi que divers bits d'√©tat pour image miroir du sprite et de la palette. <br><br>  Les vignettes sont affich√©es en bas lors de leur chargement de la ROM dans la VRAM.  Il n'y a pas assez d'espace pour stocker tous les sprites Tails dans VRAM, donc les tuiles n√©cessaires doivent √™tre copi√©es en m√©moire dans chaque image.  Ils sont appel√©s <em>Dynamic Pattern Load Cues</em> .  Cependant, bien que nous puissions les ignorer, car ils sont presque ind√©pendants des cartes de sprites, et donc ils peuvent facilement √™tre ajout√©s plus tard. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e7/fc5/33b/8e7fc533b1b25a0ea1edcc785163f1ba.png"></div><br>  Quant √† l'animation, tout ici est un peu plus simple.  Une carte d'animation dans Sonic est une liste de cartes de sprites avec deux morceaux de m√©tadonn√©es - la valeur de vitesse et l'action √† entreprendre apr√®s la fin de l'animation.  Les trois actions les plus couramment utilis√©es sont: une boucle sur toutes les images, une boucle sur les N derni√®res images, ou une transition vers une animation compl√®tement diff√©rente (par exemple, lors du passage d'une animation d'un Sonic debout √† une animation de son empressement avec son pied).  Il existe quelques commandes qui sp√©cifient des indicateurs internes dans la m√©moire des objets, mais peu d'objets les utilisent.  (Maintenant, il m'est venu √† l'esprit que vous pouvez d√©finir le bit dans la RAM de l'objet √† une valeur lors de la boucle de l'animation. Cela sera utile pour les effets sonores et d'autres choses.) <br><br>  Si vous regardez le code <a href="">Sonic 1 d√©mont√©</a> (le code Sonic 2 est trop volumineux pour √™tre li√©), vous remarquerez que le lien vers les animations n'est cr√©√© par aucun ID.  Chaque objet re√ßoit une liste d'animations et l'index d'animation est stock√© en m√©moire.  Pour rendre une animation sp√©cifique, le jeu prend un index, le recherche dans la liste des animations, puis le rend.  Cela rend le travail un peu plus facile, car vous n'avez pas besoin de scanner les animations pour trouver celle dont vous avez besoin. <br><br><h2>  Nous nettoyons la soupe des structures </h2><br>  Regardons les types de cartes: <br><br><ol><li>  Cartes de sprites: une liste de sprites comprenant une tuile initiale, le nombre de tuiles, la position, l'√©tat de r√©flexion (le sprite est en miroir ou non) et une palette. </li><li>  DPLC: une liste de tuiles ROM qui doivent √™tre charg√©es dans VRAM.  Chaque √©l√©ment d'un DPLC se compose d'une tuile initiale et d'une longueur;  chaque √©l√©ment est plac√© dans VRAM apr√®s le dernier. </li><li>  Cartes d'animation: liste d'animations consistant en une liste de cartes de sprites, de valeurs de vitesse et d'actions de cycle. </li><li>  Liste d'animation: une liste de pointeurs sur l'action de chaque animation. </li></ol><br>  √âtant donn√© que nous travaillons avec Game Boy, certaines simplifications peuvent √™tre apport√©es.  Nous savons que dans les cartes de sprites dans un sprite 8x16, il y aura toujours deux tuiles.  Cependant, tout le reste doit √™tre pr√©serv√©.  Pour l'instant, nous pouvons compl√®tement abandonner DPLC et simplement tout stocker dans VRAM.  Il s'agit d'une solution temporaire, mais, comme je l'ai dit, ce probl√®me sera facile √† r√©soudre.  Enfin, nous pouvons ignorer la valeur de vitesse si nous supposons que chaque animation fonctionne √† la m√™me vitesse. <br><br>  Commen√ßons √† comprendre comment impl√©menter un syst√®me similaire dans mon jeu. <br><br>  V√©rifiez avec commit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2e5e5b7</a> ! <br><br>  Commen√ßons par les cartes de sprites.  Chaque √©l√©ment de la carte doit refl√©ter OAM (Object Attribute Memory - sprite VRAM) et ainsi une simple boucle et memcpy suffiront pour afficher l'objet.  Permettez-moi de vous rappeler qu'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©l√©ment dans OAM se compose de Y, X, d'une tuile initiale et d'un octet d'attribut</a> .  J'ai juste besoin d'en cr√©er une liste.  En utilisant le pseudo-op√©rateur EQU assembl√©, j'ai pr√©par√© √† l'avance l'octet d'attribut afin d'avoir un nom lisible pour chaque combinaison possible d'attributs.  (Vous pouvez voir que dans le commit pr√©c√©dent, j'ai remplac√© la tuile Y / X dans les cartes. Cela s'est produit parce que j'ai lu les sp√©cifications OAM par inadvertance. J'ai √©galement ajout√© un compteur de sprites pour savoir combien de temps la boucle devrait prendre.) <br><br>  Vous remarquerez que le corps et la queue du renard polaire sont stock√©s s√©par√©ment.  S'ils √©taient stock√©s ensemble, il y aurait alors <em>beaucoup de</em> redondance, car chaque animation devrait √™tre dupliqu√©e pour chaque √©tat de queue.  Et l'ampleur de la redondance augmenterait rapidement.  Dans Sonic 2, le m√™me probl√®me s'est pos√© avec Tails.  Ils l'ont r√©solu l√†-bas, faisant de Tails tails un objet s√©par√© avec son propre √©tat d'animation et son propre temporisateur.  Je ne veux pas faire cela parce que je n'essaie pas de r√©soudre le probl√®me du maintien de la position correcte de la queue par rapport au renard. <br><br>  J'ai r√©solu le probl√®me gr√¢ce √† des cartes d'animation.  Si vous regardez ma carte d'animation (unique), il y a trois m√©tadonn√©es dedans.  Il montre le nombre de cartes d'animation, donc je sais quand elles se termineront.  (Dans Sonic, il est v√©rifi√© que l'animation suivante n'est pas valide, similaire au concept de z√©ro octet dans les lignes C. Une solution de Sonic lib√®re le cas, mais ajoute une comparaison qui fonctionnerait contre moi.) Bien s√ªr, il y a toujours une action en boucle.  (J'ai transform√© les circuits Sonic √† 2 octets en un nombre √† 1 octet dans lequel le bit 7 est le bit de mode.) Mais j'ai aussi le nombre <em>de cartes sprite</em> , mais ce n'√©tait pas dans Sonic.  Avoir plusieurs cartes de sprites par image d'animation me permet de r√©utiliser des animations dans plusieurs animations, ce qui, √† mon avis, √©conomisera beaucoup d'espace pr√©cieux.  Vous pouvez √©galement remarquer que les animations sont dupliqu√©es pour chaque direction.  En effet, les cartes pour chaque direction sont diff√©rentes et vous devez les ajouter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e9/e7d/240/8e9e7d2401e1a07d0c77e2f0c6c99e3d.png" alt="image"></div><br><h2>  Danser avec des registres </h2><br>  Reportez-vous √† <a href="">ce fichier</a> au 1713848. <br><br>  Commen√ßons par dessiner un seul sprite sur l'√©cran.  Alors, je l'avoue, j'ai menti.  Permettez-moi de vous rappeler que nous ne pouvons pas enregistrer sur l'√©cran en dehors de VBlank.  Et tout ce processus est trop long pour l'adapter √† VBlank.  Par cons√©quent, nous devons enregistrer la zone de m√©moire que nous allouerons pour DMA.  Au final, cela ne change rien, il est important d'enregistrer au bon endroit. <br><br>  Commen√ßons √† compter les registres.  Le processeur GBZ80 a 6 registres, de A √† E, H et L. H et L sont des registres sp√©ciaux, ils sont donc bien adapt√©s pour effectuer des it√©rations √† partir de la m√©moire.  (Puisqu'ils sont utilis√©s ensemble, ils sont appel√©s HL.) Dans un opcode, je peux √©crire √† l'adresse m√©moire contenue dans HL et en ajouter une.  C'est difficile √† g√©rer.  Vous pouvez l'utiliser soit comme source soit comme destination.  Je l'ai utilis√© comme adresses et la combinaison de registres BC comme source, car c'√©tait plus pratique.  Nous n'avons que A, D et E. J'ai besoin du registre A pour les op√©rations math√©matiques et similaires.  √Ä quoi peut servir DE?  J'utilise D comme compteur de boucles et E comme espace de travail.  Et c'est l√† que les registres ont pris fin. <br><br>  Disons que nous avons 4 sprites.  Nous mettons le registre D (compteur de cycles) √† 4, le registre HL (destination) l'adresse de tampon OAM et BC (la source) l'emplacement dans la ROM o√π nos cartes sont stock√©es.  J'aimerais maintenant appeler memcpy.  Cependant, un petit probl√®me se pose.  Rappelez-vous les coordonn√©es X et Y?  Ils sont indiqu√©s par rapport au point de d√©part, le centre de l'objet est utilis√© pour les collisions et similaires.  Si nous les enregistrions tels quels, chaque objet serait affich√© dans le coin sup√©rieur gauche de l'√©cran.  Cela ne nous convient pas.  Pour r√©soudre ce probl√®me, nous devons ajouter les coordonn√©es X et Y de l'objet √† X et Y du sprite. <br><br>  Petite note: je parle des ¬´objets¬ª, mais je ne vous ai pas expliqu√© ce concept.  Un objet est simplement un ensemble d'attributs associ√©s √† un objet dans un jeu.  Les attributs sont une position, une vitesse, une direction.  description de l'article, etc.  J'en parle parce que j'ai besoin d'extraire des donn√©es X et Y de ces objets. Pour ce faire, nous avons besoin d'un troisi√®me ensemble de registres pointant vers la place en RAM des objets o√π se trouvent les coordonn√©es.  Et puis nous devons stocker X et Y quelque part. La m√™me chose s'applique √† la direction, car elle nous aide √† d√©terminer dans quelle direction les sprites regardent.  De plus, nous devons rendre <em>tous les</em> objets, ils ont donc √©galement besoin d'un compteur de boucles.  Et nous ne sommes pas encore arriv√©s aux animations!  Tout devient rapidement incontr√¥lable ... <br><br><h2>  R√©vision de d√©cision </h2><br>  Donc, je cours trop loin.  Revenons en arri√®re et r√©fl√©chissons √† chaque √©l√©ment de donn√©es que je dois suivre, et o√π l'√©crire. <br><br>  Pour commencer, divisons cela en ¬´√©tapes¬ª.  Chaque √©tape ne doit recevoir des donn√©es que pour la suivante, √† l'exception de la derni√®re qui effectue la copie. <br><br><ol><li>  Object (boucle) - d√©couvre si l'objet doit √™tre rendu et le restitue. </li><li>  Liste d'animation - d√©termine quelle animation afficher.  Obtient √©galement les attributs d'un objet. </li><li>  Animation (boucle) - d√©termine la liste des cartes √† utiliser et en rend chaque carte. </li><li>  Carte (cycle) - parcourt it√©rativement chaque sprite dans la liste des sprites </li><li>  Sprite - copie les attributs de sprite dans le tampon OAM </li></ol><br>  Pour chacune des √©tapes, j'ai √©num√©r√© les variables dont ils ont besoin, les r√¥les qu'ils jouent et les endroits pour les stocker.  Ce tableau ressemble √† ceci. <br><br><table><tbody><tr><th>  La description </th><th>  La taille </th><th>  Stage </th><th>  Utiliser </th><th>  D'o√π </th><th>  Lieu </th><th>  Vers o√π </th></tr><tr><td>  Tampon OAM </td><td>  2 </td><td>  Sprite </td><td>  Pointeur </td><td>  Hl </td><td>  Hl </td><td></td></tr><tr><td>  Source de la carte </td><td>  2 </td><td>  Sprite </td><td>  Pointeur </td><td>  BC </td><td>  BC </td><td></td></tr><tr><td>  Octet actuel </td><td>  1 </td><td>  Sprite </td><td>  Espace de travail </td><td>  Source de la carte </td><td>  E </td><td></td></tr><tr><td>  X </td><td>  1 </td><td>  Sprite </td><td>  Variable </td><td>  Hiram </td><td>  Un </td><td></td></tr><tr><td>  Oui </td><td>  1 </td><td>  Sprite </td><td>  Variable </td><td>  Hiram </td><td>  Un </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  D√©but de la carte d'animation </td><td>  2 </td><td>  Carte de Sprite </td><td>  Pointeur </td><td>  Stack3 </td><td>  DE </td><td></td></tr><tr><td>  Source de la carte </td><td>  2 </td><td>  Carte de Sprite </td><td>  Pointeur </td><td>  [DE] </td><td>  BC </td><td></td></tr><tr><td>  Sprites restants </td><td>  1 </td><td>  Carte de Sprite </td><td>  Gratter </td><td>  Source de la carte </td><td>  D </td><td></td></tr><tr><td>  Tampon OAM </td><td>  1 </td><td>  Carte de Sprite </td><td>  Pointeur </td><td>  Hl </td><td>  Hl </td><td>  Stack1 </td></tr><tr><td colspan="7"></td></tr><tr><td>  D√©but de la carte d'animation </td><td>  2 </td><td>  L'animation </td><td>  Espace de travail </td><td>  BC / Stack3 </td><td>  BC </td><td>  Stack3 </td></tr><tr><td>  Cartes restantes </td><td>  1 </td><td>  L'animation </td><td>  Espace de travail </td><td>  D√©but de l'animation </td><td>  Hiram </td><td></td></tr><tr><td>  Nombre total de cartes </td><td>  1 </td><td>  Des animations </td><td>  Variable </td><td>  D√©but de l'animation </td><td>  Hiram </td><td></td></tr><tr><td>  Direction de l'objet </td><td>  1 </td><td>  L'animation </td><td>  Variable </td><td>  Hiram </td><td>  Hiram </td><td></td></tr><tr><td>  Cartes par image </td><td>  1 </td><td>  L'animation </td><td>  Variable </td><td>  D√©but de l'animation </td><td>  NON UTILIS√â !!! </td><td></td></tr><tr><td>  Num√©ro de trame </td><td>  1 </td><td>  L'animation </td><td>  Variable </td><td>  Hiram </td><td>  Un </td><td></td></tr><tr><td>  Pointeur de carte </td><td>  2 </td><td>  L'animation </td><td>  Pointeur </td><td>  AnimStart + Dir * TMC + MpF * F # </td><td>  BC </td><td>  DE </td></tr><tr><td>  Tampon OAM </td><td>  2 </td><td>  L'animation </td><td>  Pointeur </td><td>  Stack1 </td><td>  Hl </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  D√©but de la table d'animation </td><td>  2 </td><td>  Liste d'animation </td><td>  Espace de travail </td><td>  Ensemble dur </td><td>  DE </td><td></td></tr><tr><td>  Source d'objet </td><td>  2 </td><td>  Liste d'animation </td><td>  Pointeur </td><td>  Hl </td><td>  Hl </td><td>  Stack2 </td></tr><tr><td>  Num√©ro de trame </td><td>  1 </td><td>  Liste d'animation </td><td>  Variable </td><td>  Source d'objet </td><td>  Hiram </td><td></td></tr><tr><td>  Num√©ro d'animation </td><td>  1 </td><td>  Liste d'animation </td><td>  Espace de travail </td><td>  Source d'objet </td><td>  Un </td><td></td></tr><tr><td>  Objet X </td><td>  1 </td><td>  Liste d'objets </td><td>  Variable </td><td>  Source d'objet </td><td>  Hiram </td><td></td></tr><tr><td>  Objet Y </td><td>  1 </td><td>  Liste d'animation </td><td>  Variable </td><td>  Source d'objet </td><td>  Hiram </td><td></td></tr><tr><td>  Direction de l'objet </td><td>  1 </td><td>  Liste d'animation </td><td>  Variable </td><td>  Obj src </td><td>  Hiram </td><td></td></tr><tr><td>  D√©but de la carte d'animation </td><td>  2 </td><td>  Liste d'animation </td><td>  Pointeur </td><td>  [Tableau Anim + Anim #] </td><td>  BC </td><td></td></tr><tr><td>  Tampon OAM </td><td>  2 </td><td>  Liste d'animation </td><td>  Pointeur </td><td>  DE </td><td>  Stack1 </td><td></td></tr><tr><td colspan="7"></td></tr><tr><td>  Source d'objet </td><td>  2 </td><td>  Cycle d'objet </td><td>  Panneau </td><td>  Hard Set / Stack2 </td><td>  Hl </td><td></td></tr><tr><td>  Objets restants </td><td>  1 </td><td>  Cycle d'objet </td><td>  Variable </td><td>  Calcul√© </td><td>  B </td><td></td></tr><tr><td>  Champ de bits actif d'un objet </td><td>  1 </td><td>  Cycle d'objet </td><td>  Variable </td><td>  Calcul√© </td><td>  C </td><td></td></tr><tr><td>  Tampon OAM </td><td>  2 </td><td>  Cycle d'objet </td><td>  Pointeur </td><td>  Ensemble dur </td><td>  DE </td><td></td></tr></tbody></table><br>  Oui, tr√®s d√©routant.  Pour √™tre tout √† fait honn√™te, j'ai fait ce tableau pour le poste uniquement, pour expliquer plus clairement, mais il a d√©j√† commenc√© √† √™tre utile.  Je vais essayer de l'expliquer. Commen√ßons par la fin et arrivons au tout d√©but.  Vous verrez chaque √©l√©ment de donn√©es par lequel je commence: la source de l'objet, le tampon OAM et les variables de boucle pr√©calcul√©es.  Dans chaque cycle, nous commen√ßons par ceci et seulement cela, sauf que la source de l'objet est mise √† jour dans chaque cycle. <br><br>  Pour chaque objet que nous rendons, il est n√©cessaire de d√©finir l'animation affich√©e.  Pendant que nous faisons cela, nous pouvons √©galement enregistrer les attributs X, Y, Frame # et Direction avant d'incr√©menter le pointeur d'objet sur l'objet suivant et de les enregistrer sur la pile pour les reprendre √† la sortie.  Nous utilisons le num√©ro d'animation en combinaison avec la table d'animation cod√©e en dur dans le code pour d√©terminer o√π commence la carte d'animation.  (Ici, je simplifie, en supposant que chaque objet a la m√™me table d'animation. Cela me limite √† 256 animations par jeu, mais il est peu probable que je d√©passe cette valeur.) Nous pouvons √©galement √©crire un tampon OAM pour enregistrer plusieurs registres. <br><br>  Apr√®s avoir extrait la carte d'animation, nous devons trouver o√π se trouve la liste des cartes de sprites pour l'image et la direction donn√©es, ainsi que le nombre de cartes √† rendre.  Vous pouvez remarquer que la variable de carte par image n'est pas utilis√©e.  C'est arriv√© parce que je n'ai pas r√©fl√©chi et r√©gl√© la valeur constante 2. Je dois le r√©parer.  Nous devons √©galement extraire le tampon OAM de la pile.  Vous pouvez √©galement remarquer un manque total de contr√¥le du cycle.  Il est effectu√© dans une sous-proc√©dure distincte, beaucoup plus simple, qui vous permet de vous d√©barrasser du jonglage avec les registres. <br><br>  Apr√®s cela, tout devient assez simple.  Une carte est un groupe de sprites, nous les parcourons donc en boucle et dessinons en fonction des coordonn√©es X et Y enregistr√©es. Cependant, nous enregistrons √† nouveau le pointeur OAM √† la fin de la liste des sprites afin que la prochaine carte commence l√† o√π nous avons termin√©. <br><br>  Quel a √©t√© le r√©sultat final de tout cela?  Exactement comme avant: un renard polaire agitant sa queue dans le noir.  Mais ajouter de nouvelles animations ou sprites est maintenant beaucoup plus facile.  Dans la partie suivante, je parlerai des arri√®re-plans complexes et du d√©filement de parallaxe. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19f/cc5/431/19fcc54315854aa3dd7eafcad60c7c38.png" alt="image"></div><br><h2>  Partie 4. Contexte de parallaxe </h2><br>  Permettez-moi de vous rappeler qu'au stade actuel, nous avons des sprites anim√©s sur un fond noir uni.  Si je ne pr√©vois pas de faire un jeu d'arcade des ann√©es 70, alors ce ne sera clairement pas suffisant.  J'ai besoin d'une sorte d'image d'arri√®re-plan. <br><br>  Dans la premi√®re partie, lorsque je dessinais des graphiques, j'ai √©galement cr√©√© plusieurs tuiles d'arri√®re-plan.  Il est temps de les utiliser.  Nous aurons trois types de tuiles ¬´de base¬ª (ciel, herbe et terre) et deux tuiles transitionnelles.  Tous sont charg√©s dans VRAM et pr√™ts √† l'emploi.  Il ne nous reste plus qu'√† les √©crire en arri√®re-plan. <br><br><h2>  Contexte </h2><br>  Les arri√®re-plans du Game Boy sont stock√©s en m√©moire dans un tableau 32x32 de tuiles 8x8.  Tous les 32 octets correspondent √† une ligne de tuiles. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d4/f70/972/3d4f70972bfc10421deaf1d18809e4f6.png"></div><br>  Jusqu'√† pr√©sent, je pr√©vois de r√©p√©ter la m√™me <em>colonne de</em> tuiles dans tout l'espace 32x32.  C'est tr√®s bien, mais cela cr√©e un petit probl√®me: je devrai placer <em>chaque</em> tuile 32 fois de suite.  Ce sera long √† √©crire. <br><br>  Instinctivement, j'ai d√©cid√© d'utiliser la commande REPT pour ajouter 32 octets / ligne, puis utiliser memcpy pour copier l'arri√®re-plan dans VRAM. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">REPT</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> db BG_SKY ENDR REPT <span class="hljs-number"><span class="hljs-number">32</span></span> db BG_GRASS ENDR ...</code> </pre> <br>  Cependant, cela signifie que vous devez allouer 256 octets pour un seul arri√®re-plan, ce qui est beaucoup.  Ce probl√®me est exacerb√© si vous vous souvenez que la copie d'une carte d'arri√®re-plan pr√©c√©demment cr√©√©e avec memcpy ne vous permettra pas d'ajouter d'autres types de colonnes (par exemple, des portes, des obstacles) sans une complexit√© significative et des tas de ROM de cartouche gaspill√©e. <br><br>  Au lieu de cela, j'ai d√©cid√© de configurer une seule colonne comme suit: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">db</span></span> BG_SKY, BG_SKY, BG_SKY, ..., BG_GRASS</code> </pre> <br>  puis utilisez une boucle simple pour copier 32 fois chaque √©l√©ment de cette liste.  (voir <a href=""><code> LoadGFX</code> fichier <code> LoadGFX</code> du commit 739986a</a> .) <br><br>  La commodit√© de cette approche est que plus tard, je peux ajouter une file d'attente pour √©crire quelque chose comme ceci: <br><br><pre> <code class="hljs perl">BGCOL_Field: db BG_SKY, ... BGCOL_LeftGoal: db BG_SKY, ... BGCOL_RightGoal: db BG_SKY, ... ... BGMAP_overview: db <span class="hljs-number"><span class="hljs-number">1</span></span> dw BGCOL_LeftGoal db <span class="hljs-number"><span class="hljs-number">30</span></span> dw BGCOL_Field db <span class="hljs-number"><span class="hljs-number">1</span></span> dw BGCOL_RightGoal db $FF</code> </pre> <br>  Si je d√©cide de rendre BGMAP_overview, il dessinera 1 colonne de LeftGoal, apr√®s quoi il y aura 30 colonnes de Field et 1 colonne de RightGoal.  Si <code>BGMAP_overview</code> est en RAM, je peux le changer √† la vol√©e en fonction de la position de la cam√©ra dans X. <br><br><h2>  Cam√©ra et position </h2><br>  Oh oui, la cam√©ra.  C'est un concept important dont je n'ai pas encore parl√©.  Ici, nous avons affaire √† une multitude de coordonn√©es, donc avant de parler de la cam√©ra, nous allons d'abord analyser tout cela. <br><br>  Nous devons travailler avec deux syst√®mes de coordonn√©es.  Le premier est les <em>coordonn√©es de</em> l' <em>√©cran</em> .  Il s'agit d'une zone de 256x256 qui peut √™tre contenue dans la VRAM de la console Game Boy.  On peut faire d√©filer la partie visible de l'√©cran √† l'int√©rieur de ces 256x256, mais quand on d√©passe les fronti√®res, on s'effondre. <br><br>  En largeur, j'ai besoin de plus de 256 pixels, donc j'ajoute <em>des coordonn√©es mondiales</em> , qui dans ce jeu auront des dimensions de 65536x256.  (Je n'ai pas besoin de hauteur suppl√©mentaire en Y, car le jeu se d√©roule sur un terrain plat.) Ce syst√®me est compl√®tement distinct du syst√®me de coordonn√©es d'√©cran.  Toute la physique et les collisions doivent √™tre effectu√©es en coordonn√©es mondiales, sinon les objets entreront en collision avec des objets sur d'autres √©crans. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56c/557/fd6/56c557fd66ec77707c4083b6f38565f4.png"></div><br>  <i>Comparaison des coordonn√©es √©cran et monde</i> <br><br>  √âtant donn√© que les positions de tous les objets sont repr√©sent√©es en coordonn√©es universelles, elles doivent √™tre converties en coordonn√©es d'√©cran avant le rendu.  √Ä l'extr√™me gauche du monde, les coordonn√©es du monde co√Øncident avec les coordonn√©es de l'√©cran.  Si nous devons afficher les choses √† droite sur l'√©cran, alors nous devons tout prendre en coordonn√©es universelles et le d√©placer vers la gauche pour qu'elles soient en coordonn√©es d'√©cran. <br><br>  Pour ce faire, nous allons d√©finir la variable ¬´camera X¬ª, qui est d√©finie comme la bordure gauche de l'√©cran dans le monde.  Par exemple, si la <code>camera X</code> vaut 1000, alors nous pouvons voir les coordonn√©es mondiales 1000-1192, car l'√©cran visible a une largeur de 192 pixels. <br><br>  Pour traiter les objets, nous prenons simplement leur position dans X (par exemple, 1002), soustrayons la position de la cam√©ra √©gale √† 1000 et dessinons l'objet √† la position donn√©e par la diff√©rence (dans notre cas, 2).  Pour un arri√®re-plan qui n'est <em>pas</em> en coordonn√©es universelles, mais d√©j√† d√©crit en coordonn√©es d'√©cran, nous d√©finissons la position √©gale √† l'octet inf√©rieur de la variable <code>camera X</code> de la <code>camera X</code> .  Gr√¢ce √† cela, l'arri√®re-plan d√©file vers la gauche et la droite avec l'appareil photo. <br><br><h2>  Parallax </h2><br>  Le syst√®me que nous avons cr√©√© semble plut√¥t plat.  Chaque calque d'arri√®re-plan se d√©place √† la m√™me vitesse.  Il ne se sent pas en trois dimensions et nous devons le r√©parer. <br><br>  Un moyen simple d'ajouter une simulation 3D est appel√© d√©filement parallaxe.  Imaginez que vous conduisez sur une route et que vous √™tes tr√®s fatigu√©.  Le Game Boy est √† court de piles et vous devez regarder par la fen√™tre de la voiture.  Si vous regardez le sol √† c√¥t√© de vous, vous verrez.  qu'elle se d√©place √† une vitesse de 70 miles par heure.  Cependant, si vous regardez les champs au loin, il semblerait qu'ils se d√©placent beaucoup plus lentement.  Et si vous regardez les montagnes tr√®s lointaines, elles semblent √† peine bouger. <br><br>  Nous pouvons simuler cet effet avec trois feuilles de papier.  Si vous dessinez une cha√Æne de montagnes sur une feuille, le champ sur la seconde et la route sur la troisi√®me, et les posez les unes sur les autres comme ceci.  de sorte que chaque couche soit visible, ce sera une imitation de ce que nous voyons depuis la fen√™tre de la voiture.  Si nous voulons d√©placer la ¬´voiture¬ª vers la gauche, nous d√©pla√ßons la feuille sup√©rieure (avec la route) loin vers la droite, la suivante est un peu √† droite et la derni√®re est un peu √† droite. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4d/b52/691/d4db5269121565e6eda63ce5e240d96e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce4/c39/8db/ce4c398dbae155b1da618016c83d440f.png"></div><br>  Cependant, lors de la mise en ≈ìuvre d'un tel syst√®me sur Game Boy, un petit probl√®me se pose.  La console n'a qu'une seule couche d'arri√®re-plan.  Cela est similaire au fait que nous n'avons qu'une seule feuille de papier.  Vous ne pouvez pas cr√©er un effet de parallaxe avec une seule feuille de papier.  Ou est-ce possible? <br><br><h2>  H-blanc </h2><br>  L'√©cran de Game Boy est rendu ligne par ligne.  En raison de l'√©mulation du comportement des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">anciens t√©l√©viseurs √† tube cathodique,</a> il existe un l√©ger d√©lai entre chaque ligne.  Et si nous pouvions l'utiliser d'une mani√®re ou d'une autre?  Il s'av√®re que Game Boy a une interruption mat√©rielle sp√©ciale sp√©cialement con√ßue √† cet effet. <br><br>  Semblable √† l'interruption VBlank, que nous attendions constamment jusqu'√† la fin de la trame pour l'enregistrement en VRAM, il y a une interruption HBlank.  En d√©finissant le bit 6 du registre √† <code>$FF41</code> , en <code>$FF41</code> l'interruption <code>LCD STAT</code> et en √©crivant le num√©ro de ligne √† <code>$FF45</code> , nous pouvons dire √† Game Boy de d√©marrer l'interruption <code>LCD STAT</code> quand il est sur le point de tracer la ligne sp√©cifi√©e (et quand elle est dans son HBlank). <br><br>  Pendant ce temps, nous pouvons modifier toutes les variables VRAM.  Ce n'est pas <em>beaucoup de</em> temps, donc nous ne pouvons pas changer plus que quelques registres, mais nous avons encore quelques possibilit√©s.  Nous voulons changer le registre de d√©filement horizontal √† <code>$FF43</code> .  Dans ce cas, tout ce qui se trouve √† l'√©cran sous la ligne sp√©cifi√©e se d√©placera d'un certain d√©calage, cr√©ant un effet de parallaxe. <br><br>  Si vous revenez √† l'exemple de la montagne, vous pouvez remarquer un probl√®me potentiel.  Les montagnes, les nuages ‚Äã‚Äãet les fleurs ne sont pas des lignes plates!  Nous ne pouvons pas d√©placer la ligne s√©lectionn√©e de haut en bas pendant le processus de rendu;  si nous le choisissons, alors il reste le m√™me au moins jusqu'au prochain HBlank.  Autrement dit, nous ne pouvons couper qu'en lignes droites. <br><br>  Pour r√©soudre ce probl√®me, nous devons faire un peu plus intelligemment.  Nous pouvons d√©clarer une ligne en arri√®re-plan comme une ligne que rien ne peut traverser, ce qui signifie changer les modes des objets au-dessus et en dessous, et le joueur ne pourra rien remarquer.  Par exemple, c'est l√† que ces lignes sont en sc√®ne avec la montagne. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f3/371/46a/7f337146a97de76d1c7647ec0d0d78db.png"></div><br>  Ici, j'ai fait des tranches juste au-dessus et en dessous de la montagne.  Tout du haut √† la premi√®re ligne se d√©place lentement, tout √† la deuxi√®me ligne se d√©place √† une vitesse moyenne et tout en dessous de cette ligne se d√©place rapidement.  C'est une astuce simple mais intelligente.  Et en l'apprenant, vous pouvez le remarquer dans de nombreux jeux r√©tro, principalement pour Genesis / Mega Drive, mais aussi sur d'autres consoles.  L'un des exemples les plus √©vidents est la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie de la grotte</a> de Mickey Mania.  Vous pouvez remarquer que les stalagmites et les stalactites en arri√®re-plan sont s√©par√©es <em>exactement le</em> long d'une ligne horizontale avec une bordure noire √©vidente entre les couches. <br><br>  J'ai r√©alis√© la m√™me chose dans mon pass√©.  Cependant, il y a une astuce.  Supposons que le premier plan se d√©place √† une vitesse un sur un co√Øncidant avec le mouvement de la cam√©ra et que la vitesse d'arri√®re-plan soit un tiers du mouvement des pixels de la cam√©ra, c'est-√†-dire que l'arri√®re-plan se d√©place comme un tiers du premier plan.  Mais, bien s√ªr, un tiers du pixel n'existe pas.  Par cons√©quent, je dois d√©placer l'arri√®re-plan d'un pixel pour trois pixels de mouvement. <br><br>  Si vous travaillez avec des ordinateurs capables de calculs math√©matiques, vous devez prendre la position de la cam√©ra, la diviser par 3 et faire de cette valeur un d√©calage d'arri√®re-plan.  Malheureusement, le Game Boy n'est pas capable de faire la division, sans parler du fait que la division des programmes est un processus tr√®s lent et douloureux.  Ajouter un appareil pour diviser (ou multiplier) √† un CPU faible pour une console de divertissement portable dans les ann√©es 80 ne semblait pas √™tre une √©tape rentable, nous devons donc inventer une autre fa√ßon. <br><br>  Dans le code, j'ai fait ce qui suit: au lieu de lire la position de la cam√©ra √† partir d'une variable, j'ai exig√© qu'elle augmente ou diminue.  Gr√¢ce √† cela, avec chaque troisi√®me incr√©ment, je peux effectuer un incr√©ment de la position d'arri√®re-plan, et avec chaque premier incr√©ment - un incr√©ment de la position de premier plan.  Cela complique un peu le d√©filement vers une position de l'autre bord du champ (le moyen le plus simple est de simplement r√©initialiser les positions des couches apr√®s une certaine transition), mais cela nous √©vite d'avoir √† diviser. <br><br><h2>  R√©sultat </h2><br>  Apr√®s <em>tout cela,</em> j'ai obtenu ce qui suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47d/f64/3a2/47df643a2bd620cf8899b3601162748b.gif"></div><br>  Pour un jeu sur Game Boy, c'est plut√¥t cool.  Pour autant que je sache, tous n'ont pas le d√©filement de parallaxe impl√©ment√© comme ceci. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436918/">https://habr.com/ru/post/fr436918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436908/index.html">6 fa√ßons de masquer des donn√©es dans une application Android</a></li>
<li><a href="../fr436910/index.html">Conseils pour cr√©er des workflows personnalis√©s dans GitLab CI</a></li>
<li><a href="../fr436912/index.html">Tendances CRM 2019: amusant √† lire, dangereux √† croire</a></li>
<li><a href="../fr436914/index.html">Probl√®mes de croissance de d√©marrage - Surveillance</a></li>
<li><a href="../fr436916/index.html">VShard - mise √† l'√©chelle horizontale dans Tarantool</a></li>
<li><a href="../fr436920/index.html">Transpilateur PAS2JS de Pascal √† JavaScript: incompatible avec Delphi et solutions</a></li>
<li><a href="../fr436922/index.html">Optimisation du temps de d√©marrage de Prometheus 2.6.0 avec pprof</a></li>
<li><a href="../fr436924/index.html">Quelques mots sur l'organisation des concours de robotique</a></li>
<li><a href="../fr436926/index.html">H√©ros de l'authentification √† deux facteurs, ou comment "marcher dans la peau des autres"</a></li>
<li><a href="../fr436928/index.html">WebRTC - encore plus facile (EasyRTC)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>