<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíß ‚úåüèª ü§ô Blitz Engine e Battle Prime: ECS e c√≥digo de rede üíÖ üë®üèº‚Äçüè´ üéüÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Battle Prime √© o primeiro projeto do nosso est√∫dio. Apesar do fato de muitos membros da equipe terem uma experi√™ncia decente no desenvolvimento de jog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blitz Engine e Battle Prime: ECS e c√≥digo de rede</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469709/"><img src="https://habrastorage.org/webt/xi/ez/ao/xiezaordrjuxu_maz07nn1wdtqe.jpeg"><br><br>  <b>Battle Prime</b> √© o primeiro projeto do nosso est√∫dio.  Apesar do fato de muitos membros da equipe terem uma experi√™ncia decente no desenvolvimento de jogos, naturalmente enfrentamos v√°rias dificuldades ao trabalhar nele.  Eles surgiram tanto no processo de trabalhar no mecanismo quanto no desenvolvimento do pr√≥prio jogo. <br><br>  No setor de gamedev, um grande n√∫mero de desenvolvedores que compartilham de bom grado suas hist√≥rias, melhores pr√°ticas, decis√µes de arquitetura - de uma forma ou de outra.  Essa experi√™ncia, apresentada no espa√ßo p√∫blico na forma de artigos, apresenta√ß√µes e relat√≥rios, √© uma excelente fonte de id√©ias e inspira√ß√£o.  Por exemplo, os relat√≥rios da equipe de desenvolvimento de Overwatch foram muito √∫teis para n√≥s quando trabalhamos no mecanismo.  Como o jogo em si, eles s√£o feitos com muito talento, e eu aconselho todos os interessados ‚Äã‚Äãem v√™-los.  Dispon√≠vel no cofre da GDC e no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">YouTube</a> . <br><br>  Essa √© uma das raz√µes pelas quais tamb√©m queremos contribuir para a causa comum - e este artigo √© um dos primeiros dedicados aos detalhes t√©cnicos do desenvolvimento e da execu√ß√£o do Blitz Engine - Battle Prime. <br><br>  O artigo ser√° dividido em duas partes: <br><br><ul><li>  ECS: implementa√ß√£o do padr√£o Entity-Component-System dentro do Blitz Engine.  Esta se√ß√£o √© importante para entender os exemplos de c√≥digo no artigo e, por si s√≥, √© um t√≥pico interessante separado. </li><li>  C√≥digo de rede e jogabilidade: tudo sobre a parte de alto n√≠vel da rede e seu uso dentro do jogo - arquitetura cliente-servidor, previs√µes de clientes, replica√ß√£o.  Uma das coisas mais importantes em um jogo de tiro √© atirar, para que mais tempo seja dedicado a ele. </li></ul><br>  <i>Sob o corte de muitos megabytes de gifs!</i> <br><a name="habracut"></a><br>  Dentro de cada se√ß√£o, al√©m da hist√≥ria sobre a funcionalidade e seu uso, tentarei descrever as defici√™ncias que ela traz consigo - sejam suas limita√ß√µes, inconveni√™ncia no trabalho ou apenas pensamentos sobre suas melhorias no futuro. <br><br>  Tamb√©m tentarei dar exemplos de c√≥digo e algumas estat√≠sticas.  Em primeiro lugar, √© apenas interessante e, em segundo lugar, fornece um pouco de contexto na escala do uso dessa ou daquela funcionalidade e projeto. <br><br><h1>  ECS </h1><br>  Dentro do mecanismo, usamos o termo "mundo" para descrever uma cena que cont√©m uma hierarquia de objetos. <br><br>  Os mundos funcionam de acordo com o modelo do sistema de componentes de entidade ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descri√ß√£o na Wikipedia</a> ): <br><br><ul><li>  Entidade - um objeto dentro da cena.  √â um reposit√≥rio para um conjunto de componentes.  Objetos podem ser aninhados, formando uma hierarquia no mundo; </li><li>  Componente - s√£o os dados necess√°rios para a opera√ß√£o de qualquer mec√¢nica e que determina o comportamento do objeto.  Por exemplo, `TransformComponent` cont√©m a transforma√ß√£o do objeto e` DynamicBodyComponent` cont√©m dados para simula√ß√£o f√≠sica.  Alguns componentes podem n√£o ter dados adicionais, sua simples presen√ßa no objeto descreve o estado desse objeto.  Por exemplo, no Battle Prime, s√£o usados ‚Äã‚Äã`AliveComponent` e` DeadComponent`, que marcam caracteres ativos e inativos, respectivamente; </li><li>  Sistema - um conjunto de fun√ß√µes chamado periodicamente que suporta a solu√ß√£o de sua tarefa.  Com cada chamada, o sistema processa objetos que satisfazem alguma condi√ß√£o (geralmente com um determinado conjunto de componentes) e, se necess√°rio, os modifica.  Toda a l√≥gica do jogo e a maior parte do mecanismo s√£o implementadas no n√≠vel do sistema.  Por exemplo, dentro do mecanismo, existe um `LodSystem`, que se dedica ao c√°lculo dos √≠ndices LOD (n√≠vel de detalhe) de um objeto com base em sua transforma√ß√£o no mundo e em outros dados.  Este √≠ndice contido no `LodComponent` √© ent√£o usado por outros sistemas para suas tarefas. </li></ul><br>  Essa abordagem facilita a combina√ß√£o de diferentes mec√¢nicas no mesmo objeto.  Assim que a entidade recebe dados suficientes para o trabalho de algumas mec√¢nicas, os sistemas respons√°veis ‚Äã‚Äãpor essa mec√¢nica come√ßam a processar esse objeto. <br><br>  Na pr√°tica, adicionar um novo funcional reduz-se a um novo componente (ou conjunto de componentes) e a um novo sistema (ou conjunto de sistemas) que implementa esse funcional.  Na grande maioria dos casos, √© conveniente trabalhar nesse padr√£o. <br><br><h2>  Reflex√£o </h2><br>  Antes de prosseguir com a descri√ß√£o dos componentes e sistemas, vou me debru√ßar um pouco sobre o mecanismo de reflex√£o, pois ele geralmente ser√° usado em exemplos de c√≥digo. <br><br>  O Reflection permite receber e usar informa√ß√µes sobre tipos enquanto o aplicativo est√° em execu√ß√£o.  Em particular, os seguintes recursos est√£o dispon√≠veis: <br><br><ul><li>  Obtenha uma lista de tipos de acordo com um crit√©rio espec√≠fico (por exemplo, os herdeiros de uma classe ou com uma tag especial), </li><li>  Obtenha uma lista de campos de classe, </li><li>  Obtenha uma lista de m√©todos dentro da classe, </li><li>  Obtenha uma lista de valores de enumera√ß√£o, </li><li>  Chame algum m√©todo ou altere o valor de um campo, </li><li>  Obtenha os metadados de um campo ou m√©todo que podem ser usados ‚Äã‚Äãpara uma funcionalidade espec√≠fica. </li></ul><br>  Muitos m√≥dulos dentro do mecanismo usam a reflex√£o para seus pr√≥prios prop√≥sitos.  Alguns exemplos: <br><br><ul><li>  As integra√ß√µes de linguagens de script usam reflex√£o para trabalhar com tipos declarados no c√≥digo C ++; </li><li>  O editor usa reflex√£o para obter uma lista de componentes que podem ser adicionados ao objeto, al√©m de exibir e editar seus campos; </li><li>  O m√≥dulo de rede usa os metadados do campo dentro dos componentes para v√°rias fun√ß√µes: eles indicam os par√¢metros para replicar campos do servidor para os clientes, quantizar dados durante a replica√ß√£o e assim por diante; </li><li>  V√°rias configura√ß√µes s√£o desserializadas em objetos dos tipos correspondentes usando reflex√£o. </li></ul><br>  Usamos nossa pr√≥pria implementa√ß√£o, cuja interface n√£o √© muito diferente de outras solu√ß√µes existentes (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/rttrorg/rttr</a> ).  Usando o exemplo de CapturePointComponent (que descreve o ponto de captura para o modo de jogo), adicionar reflex√£o ao tipo fica assim: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     class CapturePointComponent final : public Component { //            BZ_VIRTUAL_REFLECTION(Component); public: float points_to_own = 10.0f; String visible_name; // ‚Ä¶   }; //   .cpp  BZ_VIRTUAL_REFLECTION_IMPL(CapturePointComponent) { //       ReflectionRegistrar::begin_class&lt;CapturePointComponent&gt;() [M&lt;Serializable&gt;(), M&lt;Scriptable&gt;(), M&lt;DisplayName&gt;("Capture point")] //      .field("points_to_own", &amp;CapturePointComponent::points_to_own) [M&lt;Serializable&gt;(), M&lt;DisplayName&gt;("Points to own")] .field("visible_name", &amp;CapturePointComponent::visible_name) [M&lt;Serializable&gt;(), M&lt;DisplayName&gt;("Name")] // ‚Ä¶     }</span></span></code> </pre> <br>  Gostaria de prestar aten√ß√£o especial aos metadados de tipos, campos e m√©todos declarados usando a express√£o <br><br><pre> <code class="cpp hljs">M&lt;T&gt;()</code> </pre> <br>  onde `T` √© o tipo de metadados (dentro do comando, apenas usamos o termo" meta ", no futuro eu o usarei).  Eles s√£o usados ‚Äã‚Äãpor diferentes m√≥dulos para seus pr√≥prios prop√≥sitos.  Por exemplo, o editor usa `DisplayName` para exibir os nomes e os campos do tipo dentro do editor, e o m√≥dulo de rede recebe uma lista de todos os componentes e, entre eles, procura por campos marcados como 'Replic√°vel' - eles ser√£o enviados do servidor para os clientes. <br><br><h2>  Descri√ß√£o dos componentes e sua adi√ß√£o ao objeto </h2><br>  Cada componente √© um herdeiro da classe base `Component 'e pode descrever com a ajuda da reflex√£o os campos que usa (se necess√°rio). <br><br>  √â assim que o `AvatarHitComponent` √© declarado e descrito dentro do jogo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** Component that indicates avatar hit event. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AvatarHitComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Component { BZ_VIRTUAL_REFLECTION(Component); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PlayerId source_id = NetConstants::INVALID_PLAYER_ID; PlayerId target_id = NetConstants::INVALID_PLAYER_ID; HitboxType hitbox_type = HitboxType::UNKNOWN; }; BZ_VIRTUAL_REFLECTION_IMPL(AvatarHitComponent) { ReflectionRegistrar::begin_class&lt;AvatarHitComponent&gt;() .ctor_by_pointer() .copy_ctor_by_pointer() .field(<span class="hljs-string"><span class="hljs-string">"source_id"</span></span>, &amp;AvatarHitComponent::source_id)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"target_id"</span></span>, &amp;AvatarHitComponent::target_id)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"hitbox_type"</span></span>, &amp;AvatarHitComponent::hitbox_type)[M&lt;Replicable&gt;()]; }</code> </pre> <br>  Este componente marca um objeto que √© criado como resultado de um jogador atingir outro jogador.  Ele cont√©m informa√ß√µes sobre este evento, como os identificadores do jogador atacante e seu objetivo, bem como o tipo de caixa de acerto na qual o acerto ocorreu. <br>  Simplificando, esse objeto √© criado dentro do sistema do servidor de maneira semelhante: <br><br><pre> <code class="cpp hljs">Entity hit_entity = world-&gt;create_entity(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> avatar_hit_component = hit_entity.add&lt;AvatarHitComponent&gt;(); avatar_hit_component-&gt;source_id = source_player_id; avatar_hit_component-&gt;target_id = target_player_id; avatar_hit_component-&gt;hitbox_type = hitbox_type; <span class="hljs-comment"><span class="hljs-comment">//      //      // ...</span></span></code> </pre> <br>  O objeto com o `AvatarHitComponent` √© ent√£o usado por diferentes sistemas: para tocar sons de jogadores, coletando estat√≠sticas, rastreando as realiza√ß√µes dos jogadores e assim por diante. <br><br><h2>  Descri√ß√£o dos sistemas e seu trabalho </h2><br>  Um sistema √© um objeto com um tipo herdado do `System`, que cont√©m m√©todos que implementam uma tarefa espec√≠fica.  Como regra, um m√©todo √© suficiente.  V√°rios m√©todos s√£o necess√°rios se eles devem ser executados em diferentes momentos no mesmo quadro. <br><br>  Semelhante aos componentes que descrevem seus campos, cada sistema descreve os m√©todos que devem ser executados pelo mundo. <br><br>  Por exemplo, o Sistema Explosivo respons√°vel pelas explos√µes √© declarado e descrito da seguinte forma: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// System responsible for handling explosive components: // - tracking when they need to be exploded: by timer, trigger zone etc. // - destroying them on explosion and creating separate explosion entity class ExplosiveSystem final : public System { BZ_VIRTUAL_REFLECTION(System); public: ExplosiveSystem(World* world); private: void update(float dt); //    ,     // ... }; BZ_VIRTUAL_REFLECTION_IMPL(ExplosiveSystem) { ReflectionRegistrar::begin_class&lt;ExplosiveSystem&gt;()[M&lt;SystemTags&gt;("battle")] .ctor_by_pointer&lt;World*&gt;() .method("ExplosiveSystem::update", &amp;ExplosiveSystem::update)[M&lt;SystemTask&gt;( TaskGroups::GAMEPLAY_END, ReadAccess::set&lt; TimeSingleComponent, WeaponDescriptorComponent, BallisticComponent, ProjectileComponent, GrenadeComponent&gt;(), WriteAccess::set&lt;ExplosiveComponent&gt;(), InitAccess::set&lt;ExplosiveStatsComponent, LocalExplosionComponent, ServerExplosionComponent, EntityWasteComponent, ReplicationComponent, AbilityIdComponent, WeaponBaseStatsComponent, HitDamageStatsComponent, ClusterGrenadeStatsComponent&gt;(), UpdateType::FIXED, Vector&lt;TaskOrder&gt;{ TaskOrder::before(FastName{ "ballistic_update" }) })]; }</span></span></code> </pre> <br>  Os seguintes dados s√£o indicados na descri√ß√£o do sistema: <br><br><ul><li>  A tag √† qual o sistema pertence.  Cada mundo cont√©m um conjunto de tags, e neles est√£o os sistemas que devem funcionar neste mundo.  Nesse caso, a tag `battle` significa o mundo em que a batalha entre os jogadores ocorre.  Outros exemplos de tags s√£o `server` e` client` (o sistema roda apenas no servidor ou cliente, respectivamente) e` render` (o sistema roda apenas no modo GUI); </li><li>  O grupo no qual este sistema √© executado e a lista de componentes que esse sistema utiliza - para escrever, ler e criar; </li><li>  Tipo de atualiza√ß√£o - se este sistema deve funcionar em atualiza√ß√£o normal, atualiza√ß√£o fixa ou outros; </li><li>  Depend√™ncias de permiss√£o expl√≠citas entre sistemas. </li></ul><br>  Mais informa√ß√µes sobre grupos de sistemas, depend√™ncias e tipos de atualiza√ß√£o ser√£o descritas abaixo. <br><br>  Os m√©todos declarados s√£o chamados pelo mundo no momento certo para manter a funcionalidade deste sistema.  O conte√∫do do m√©todo depende do sistema, mas, como regra, √© um passeio por todos os objetos que atendem aos crit√©rios desse sistema e sua atualiza√ß√£o subsequente.  Por exemplo, a atualiza√ß√£o do `ExplosiveSystem` dentro do jogo √© a seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ExplosiveSystem::update(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dt) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* time_single_component = world-&gt;get&lt;TimeSingleComponent&gt;(); <span class="hljs-comment"><span class="hljs-comment">// Init new explosives for (Component* component : new_explosives_group-&gt;components) { auto* explosive_component = static_cast&lt;ExplosiveComponent*&gt;(component); init_explosive(explosive_component, time_single_component); } new_explosives_group-&gt;components.clear(); // Update all explosives for (ExplosiveComponent* explosive_component : explosives_group) { update_explosive(explosive_component, time_single_component, dt); } }</span></span></code> </pre> <br>  Os grupos no exemplo acima (`new_explosives_group` e` explosives_group`) s√£o cont√™ineres auxiliares que simplificam a implementa√ß√£o do sistema.  new_explosives_group √© um cont√™iner com novos objetos necess√°rios para este sistema e que nunca foram processados, e explosives_group √© um cont√™iner com todos os objetos que precisam ser processados ‚Äã‚Äãem todos os quadros.  O mundo √© diretamente respons√°vel por encher esses recipientes.  Seu recebimento pelo sistema ocorre em seu construtor: <br><br><pre> <code class="cpp hljs">ExplosiveSystem::ExplosiveSystem(World* world) : System(world) { <span class="hljs-comment"><span class="hljs-comment">// `explosives_group`        `ExplosiveComponent` explosives_group = world-&gt;acquire_component_group&lt;ExplosiveComponent&gt;(); // `new_explosives_group`        //  `ExplosiveComponent` -       new_explosives_group = explosive_group-&gt;acquire_component_group_on_add(); }</span></span></code> </pre> <br><h2>  Atualiza√ß√£o mundial </h2><br>  O mundo, um objeto do tipo `Mundo ', cada quadro chama os m√©todos necess√°rios em v√°rios sistemas.  Quais sistemas ser√£o chamados depende do seu tipo. <br><br>  Parte dos sistemas em que todos os quadros s√£o necessariamente atualizados (o termo ‚Äúatualiza√ß√£o normal‚Äù √© usado dentro do mecanismo) - esse tipo inclui todos os sistemas que afetam a renderiza√ß√£o do quadro e dos sons: anima√ß√µes esquel√©ticas, part√≠culas, interface do usu√°rio e assim por diante.  A outra parte √© executada em uma frequ√™ncia fixa e predeterminada (usamos o termo "atualiza√ß√£o fixa" e para o n√∫mero de atualiza√ß√µes fixas por segundo - FFPS) - elas processam a maior parte da l√≥gica de jogo e tudo o que precisa ser sincronizado entre o cliente e o servidor - por exemplo, parte da entrada do jogador, movimento do personagem, tiro, parte da simula√ß√£o f√≠sica. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j7/uo/wo/j7uowoyprp2hgp3lqgdy9rsotpm.png" height="1024" width="768"></div><br><br>  A frequ√™ncia de execu√ß√£o de uma atualiza√ß√£o fixa deve ser equilibrada - um valor muito pequeno leva a uma jogabilidade sem resposta (por exemplo, a entrada do jogador √© processada com menos frequ√™ncia e, portanto, com um atraso maior) e muito alta - a requisitos de desempenho elevados do dispositivo no qual o aplicativo est√° sendo executado.  Isso tamb√©m significa que quanto maior a frequ√™ncia, maior o custo da capacidade do servidor (menos batalhas podem funcionar simultaneamente na mesma m√°quina). <br><br>  No gif abaixo, o mundo trabalha com uma frequ√™ncia de 5 atualiza√ß√µes fixas por segundo.  Voc√™ pode notar o atraso entre pressionar o bot√£o W e o in√≠cio do movimento, bem como o atraso entre soltar o bot√£o e interromper o movimento do personagem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0dd/cbe/d6a/0ddcbed6a0354d56cc93efe6c2901b17.gif" alt="imagem" height="1024" width="768"></div><br>  No pr√≥ximo gif, o mundo trabalha com uma frequ√™ncia de 30 atualiza√ß√µes fixas por segundo, o que fornece um controle significativamente mais responsivo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe9/330/c42/fe9330c427acbd0bf5c807edcd9463ff.gif" alt="imagem" height="1024" width="768"></div><br>  No momento, na atualiza√ß√£o fixa do Battle Prime, o mundo corre 31 vezes por segundo.  Esse valor "feio" foi escolhido especialmente - ele pode causar erros que n√£o existiriam em outras situa√ß√µes quando o n√∫mero de atualiza√ß√µes por segundo for, por exemplo, um n√∫mero redondo ou um m√∫ltiplo da taxa de atualiza√ß√£o da tela. <br><br><h2>  Ordem de execu√ß√£o do sistema </h2><br>  Uma das coisas que complica o trabalho com o ECS √© a tarefa de executar sistemas.  Por contexto, no momento da reda√ß√£o deste artigo, no cliente Battle Prime durante a batalha entre os jogadores, existe um sistema 251 e seu n√∫mero s√≥ est√° aumentando. <br><br>  Um sistema que √© executado por engano no momento errado pode levar a erros sutis ou a um atraso na opera√ß√£o de algumas mec√¢nicas por quadro (por exemplo, se o sistema de danos funcionar no in√≠cio do quadro e o sistema de v√¥o do proj√©til no final, o dano ser√° causado. com um atraso de um quadro). <br><br>  A ordem de execu√ß√£o dos sistemas pode ser definida de v√°rias maneiras, por exemplo: <br><br><ul><li>  Pedido expl√≠cito </li><li>  Indica√ß√£o da ‚Äúprioridade‚Äù num√©rica do sistema e posterior classifica√ß√£o por prioridade; </li><li>  Crie automaticamente um gr√°fico de depend√™ncias entre sistemas e instale-os nos lugares certos na ordem de execu√ß√£o. </li></ul><br>  No momento, estamos usando a terceira op√ß√£o.  Cada sistema indica quais componentes ele usa para leitura, quais para grava√ß√£o e quais componentes ele cria.  Em seguida, os sistemas s√£o organizados automaticamente entre si na ordem necess√°ria: <br><ul><li>  O componente de leitura do sistema A vem depois que o sistema grava no componente A; </li><li>  O sistema que grava ou l√™ o componente B vem depois do sistema que cria o componente B; </li><li>  Se os dois sistemas gravarem no componente C, o pedido poder√° ser qualquer (mas pode ser especificado manualmente, se necess√°rio). </li></ul><br>  Em teoria, essa solu√ß√£o minimiza o controle sobre a ordem de execu√ß√£o; tudo o que √© necess√°rio √© definir m√°scaras de componentes para o sistema.  Na pr√°tica, com o crescimento do projeto, isso leva a mais e mais ciclos entre os sistemas.  Se o sistema 1 grava no componente A e l√™ o componente B, e o sistema 2 l√™ o componente A e grava no componente B, esse √© um ciclo e deve ser resolvido manualmente.  Muitas vezes, existem mais de dois sistemas em um ciclo.  Sua resolu√ß√£o requer tempo e indica√ß√µes expl√≠citas da rela√ß√£o entre eles. <br><br>  Portanto, o Blitz Engine possui "grupos" de sistemas.  Dentro dos grupos, os sistemas s√£o alinhados automaticamente na ordem desejada (e os ciclos ainda s√£o resolvidos manualmente) e a ordem dos grupos √© definida explicitamente.  Essa decis√£o √© um cruzamento entre uma ordem totalmente manual e uma totalmente automatizada, e o tamanho dos grupos afeta seriamente sua efic√°cia.  Assim que o grupo fica grande demais, os programadores novamente se deparam com os problemas de loops dentro deles. <br><br>  Atualmente existem 10 grupos no Battle Prime.  Isso ainda n√£o √© suficiente, e planejamos aumentar seu n√∫mero criando uma sequ√™ncia l√≥gica estrita entre eles e usando a constru√ß√£o autom√°tica de um gr√°fico dentro de cada um deles. <br><br>  A indica√ß√£o de quais componentes s√£o usados ‚Äã‚Äãpelos sistemas para escrita ou leitura tamb√©m permitir√° no futuro agrupar automaticamente os sistemas em "blocos" que ser√£o executados em paralelo entre si. <br><br>  Abaixo est√° um utilit√°rio auxiliar que exibe uma lista de sistemas e as depend√™ncias entre eles dentro de cada um dos grupos (gr√°ficos completos dentro dos grupos parecem intimidadores).  A cor laranja mostra depend√™ncias definidas explicitamente entre os sistemas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/592/2a4/fae/5922a4fae880eb7c80252628a827d2a0.gif" alt="imagem" height="1024" width="768"></div><br><h2>  Comunica√ß√£o entre sistemas e sua configura√ß√£o </h2><br>  As tarefas que os sistemas executam dentro de si podem, em um grau ou outro, depender dos resultados de outros sistemas.  Por exemplo, um sistema que processa colis√µes de dois objetos depende de uma simula√ß√£o da f√≠sica que registra essas colis√µes.  E o sistema de danos depende dos resultados do sistema bal√≠stico, respons√°vel pelo movimento das conchas. <br><br>  A maneira mais simples e √≥bvia de se comunicar entre sistemas √© usar componentes.  Um sistema adiciona os resultados de seu trabalho a um componente, e o segundo sistema l√™ esses resultados do componente e resolve seu problema com base. <br><br>  Uma abordagem baseada em componentes pode ser inconveniente em alguns casos: <br><br><ul><li>  E se o resultado do sistema n√£o estiver diretamente vinculado a algum objeto?  Por exemplo, um sistema que coleta estat√≠sticas de batalha (o n√∫mero de tiros, acertos, mortes etc.) - coleta globalmente, com base em toda a batalha; </li><li>  E se o sistema precisar ser configurado de alguma forma?  Por exemplo, um sistema de simula√ß√£o f√≠sica precisa saber quais tipos de objetos devem registrar colis√µes entre si e quais n√£o s√£o. </li></ul><br>  Para resolver esses problemas, usamos a abordagem emprestada da equipe de desenvolvimento de Overwatch - Single Components. <br><br>  Componente √∫nico √© um componente que existe no mundo em uma √∫nica c√≥pia e √© obtido diretamente do mundo.  Os sistemas podem us√°-lo para adicionar os resultados de seu trabalho, que s√£o usados ‚Äã‚Äãpor outros sistemas ou para configurar seu trabalho. <br><br>  No momento, o projeto (m√≥dulos de mecanismo + jogo) possui cerca de 120 componentes √∫nicos que s√£o usados ‚Äã‚Äãpara diferentes fins - desde o armazenamento de dados globais do mundo at√© a configura√ß√£o de sistemas individuais. <br><br><h2>  Abordagem "limpa" </h2><br>  Na sua forma mais pura, essa abordagem de sistemas e componentes requer a disponibilidade de dados somente dentro dos componentes e a presen√ßa de l√≥gica somente dentro dos sistemas.  Na minha opini√£o, na pr√°tica, essa restri√ß√£o raramente faz sentido observar rigorosamente (embora os debates sobre esse assunto ainda sejam periodicamente levantados). <br><br>  Os seguintes argumentos a favor de uma abordagem menos "rigorosa" podem ser destacados: <br><br><ul><li>  Parte do c√≥digo deve ser compartilhada - e executada de forma s√≠ncrona a partir de sistemas diferentes ou ao definir algumas propriedades dos componentes.  L√≥gica semelhante √© descrita separadamente.  Como parte do mecanismo, usamos o termo Utils.  Por exemplo, dentro do jogo `DamageUtils` cont√©m a l√≥gica associada √† aplica√ß√£o do dano - que pode ser aplicada a partir de diferentes sistemas; </li><li>  N√£o faz sentido manter os dados privados do sistema em algum lugar que n√£o seja o pr√≥prio sistema - ningu√©m precisar√° deles, exceto os mesmos, e mov√™-los para outro local n√£o √© particularmente √∫til.  H√° uma exce√ß√£o a essa regra, que est√° associada √† funcionalidade das previs√µes do cliente - ela ser√° descrita na se√ß√£o abaixo; </li><li>  √â √∫til que os componentes tenham uma pequena quantidade de l√≥gica - na maioria dos casos, s√£o getters e setters inteligentes que simplificam o trabalho com o componente. </li></ul><br><h1>  Netcode </h1><br>  O Battle Prime usa uma arquitetura com um servidor autorit√°rio e previs√µes de clientes.  Isso permite que o jogador receba feedback instant√¢neo de suas a√ß√µes, mesmo com altos pings e perdas de pacotes e o projeto como um todo - para minimizar a trapa√ßa dos jogadores, porque  o servidor determina todos os resultados da simula√ß√£o dentro da batalha. <br><br>  Todo o c√≥digo dentro do projeto do jogo √© dividido em tr√™s partes: <br><br><ul><li>  Cliente - sistemas e componentes que funcionam apenas no cliente.  Isso inclui coisas como interface do usu√°rio, captura autom√°tica e interpola√ß√£o; </li><li>  Servidor - sistemas e componentes que funcionam apenas no servidor.  Por exemplo, tudo relacionado a personagens de dano e desova; </li><li>  Geral - √© tudo o que funciona no servidor e no cliente.  Em particular, todos os sistemas que calculam o movimento do personagem, o estado da arma (o n√∫mero de rodadas, recargas) e tudo o mais que precisa ser previsto no cliente.  A maioria dos sistemas respons√°veis ‚Äã‚Äãpelos efeitos visuais tamb√©m √© comum - o servidor pode ser iniciado opcionalmente no modo GUI (na maioria das vezes apenas para depura√ß√£o). </li></ul><br><h2>  Entrada do usu√°rio (entrada) </h2><br>  Antes de passar para os detalhes de replica√ß√£o e previs√µes no cliente, voc√™ deve continuar trabalhando com entrada dentro do mecanismo - os detalhes ser√£o importantes nas se√ß√µes abaixo. <br><br>  Toda a entrada do player √© dividida em dois tipos: baixo e alto n√≠vel: <br><br><ul><li>  Entrada de baixo n√≠vel - s√£o eventos de dispositivos de entrada, como pressionamentos de teclas, toque na tela e assim por diante.  Essa entrada raramente √© processada pelos sistemas de jogo; </li><li>  Entrada de alto n√≠vel - s√£o as a√ß√µes do usu√°rio cometidas por ele no contexto do jogo: tiro, mudan√ßa de arma, movimento do personagem e assim por diante.  Para a√ß√µes de alto n√≠vel, usamos o termo "A√ß√£o".  Al√©m disso, dados adicionais podem ser associados √† a√ß√£o - como a dire√ß√£o do movimento ou o √≠ndice da arma selecionada.  A grande maioria dos sistemas trabalha com a√ß√µes. </li></ul><br>  Uma entrada de alto n√≠vel √© gerada com base em ligantes a partir de uma entrada de baixo n√≠vel ou programaticamente.  Por exemplo, uma a√ß√£o de disparo pode ser ligada a um clique do mouse ou pode ser gerada pelo sistema respons√°vel pelo disparo autom√°tico - assim que o jogador apontar para o inimigo, esse sistema gera um tiro de a√ß√£o se o usu√°rio tiver a configura√ß√£o correspondente ativada.  As a√ß√µes tamb√©m podem ser enviadas pelo sistema da interface do usu√°rio: por exemplo, pressionando o bot√£o correspondente ou ao mover o joystick na tela.  Um sistema acionado n√£o importa como essa a√ß√£o foi criada. <br><br>  A√ß√µes logicamente relacionadas s√£o agrupadas (objetos do tipo `ActionSet`).  Os grupos podem ser desconectados se n√£o forem necess√°rios no contexto atual - por exemplo, no Battle Prime, existem v√°rios grupos, entre os quais: <br><br><ul><li>  A√ß√µes para controlar o movimento do personagem, </li><li>  A√ß√µes para disparar armas autom√°ticas, </li><li>  A√ß√µes para disparar armas semi-autom√°ticas. </li></ul><br>  Dos dois √∫ltimos grupos, apenas um est√° ativo por vez, dependendo do tipo de arma selecionada - eles diferem na maneira como a a√ß√£o FIRE √© gerada: enquanto o bot√£o √© pressionado (para armas autom√°ticas) ou apenas uma vez quando o bot√£o √© pressionado (para armas semiautom√°ticas ) <br><br>  Da mesma forma, grupos de a√ß√µes s√£o criados e configurados dentro do jogo em um dos sistemas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Map&lt;FastName, ActionSet&gt; action_sets = { { <span class="hljs-comment"><span class="hljs-comment">//     ControlModes::CHARACTER_MOVEMENT, ActionSet { { DigitalBinding{ ActionNames::JUMP, { { InputCode::KB_SPACE, DigitalState::just_pressed() } }, nullopt }, DigitalBinding{ ActionNames::MOVE, { { InputCode::KB_W, DigitalState::pressed() } }, ActionValue{ AnalogState{0.0f, 1.0f, 0.0f} } }, //    ... }, { AnalogBinding{ ActionNames::LOOK, InputCode::MOUSE_RELATIVE_POSITION, AnalogStateType::ABSOLUTE, AnalogStateBasis::LOGICAL, {} } //    ... } } }, { //       ControlModes::AUTOMATIC_FIRE, ActionSet { { // FIRE    ,      DigitalBinding{ ActionNames::FIRE, { { InputCode::MOUSE_LBUTTON, DigitalState::pressed() } }, nullopt }, //       ... } } }, { //       ControlModes::SEMI_AUTOMATIC_FIRE, ActionSet { { // FIRE          DigitalBinding{ ActionNames::FIRE, { { InputCode::MOUSE_LBUTTON, DigitalState::just_pressed() } }, nullopt }, //       ... } } } //   ... };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Battle Prime descreve cerca de 40 a√ß√µes. </font><font style="vertical-align: inherit;">Alguns deles s√£o usados ‚Äã‚Äãapenas para depura√ß√£o ou grava√ß√£o de clipes.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Replica√ß√£o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Replica√ß√£o √© o processo de transfer√™ncia de dados de um servidor para clientes. </font><font style="vertical-align: inherit;">Todos os dados s√£o transmitidos atrav√©s de objetos no mundo:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sua cria√ß√£o e exclus√£o, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Criando e excluindo componentes em objetos, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alterar propriedades do componente. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A replica√ß√£o √© configurada usando o componente apropriado. </font><font style="vertical-align: inherit;">Por exemplo, de maneira semelhante, o jogo configura a replica√ß√£o das armas do jogador:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* replication_component = weapon_entity.add&lt;ReplicationComponent&gt;(); replication_component-&gt;enable_replication&lt;WeaponDescriptorComponent&gt;(Privacy::PUBLIC); replication_component-&gt;enable_replication&lt;WeaponBaseStatsComponent&gt;(Privacy::PUBLIC); replication_component-&gt;enable_replication&lt;WeaponComponent&gt;(Privacy::PRIVATE); replication_component-&gt;enable_replication&lt;BallisticsStatsComponent&gt;(Privacy::PRIVATE); <span class="hljs-comment"><span class="hljs-comment">// ...   </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para cada componente, a privacidade usada durante a replica√ß√£o √© indicada. Os componentes privados ser√£o enviados do servidor apenas para o jogador que possui esta arma. Os componentes p√∫blicos ser√£o enviados a todos. Neste exemplo, o `WeaponDescriptorComponent` e o` WeaponBaseStatsComponent` s√£o p√∫blicos - eles cont√™m os dados necess√°rios para a exibi√ß√£o correta de outros jogadores. Por exemplo, o √≠ndice do slot no qual a arma est√° e seu tipo s√£o necess√°rios para as anima√ß√µes. Os componentes restantes s√£o enviados em particular ao jogador que possui esta arma - os par√¢metros da bal√≠stica das cartuchas, informa√ß√µes sobre o n√∫mero total de rodadas, os modos de tiro dispon√≠veis e assim por diante. Existem modos de privacidade mais especializados: por exemplo, voc√™ pode enviar um componente apenas para aliados ou apenas para inimigos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada componente em sua descri√ß√£o deve indicar quais campos devem ser replicados dentro desse componente. </font><font style="vertical-align: inherit;">Por exemplo, todos os campos dentro do `WeaponComponent` s√£o marcados como` Replicable`:</font></font><br><br><pre> <code class="cpp hljs">BZ_VIRTUAL_REFLECTION_IMPL(WeaponComponent) { ReflectionRegistrar::begin_class&lt;WeaponComponent&gt;() .ctor_by_pointer() .copy_ctor_by_pointer() .field(<span class="hljs-string"><span class="hljs-string">"owner"</span></span>, &amp;WeaponComponent::owner)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"fire_mode"</span></span>, &amp;WeaponComponent::fire_mode)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"loaded_ammo"</span></span>, &amp;WeaponComponent::loaded_ammo)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"ammo"</span></span>, &amp;WeaponComponent::ammo)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"shooting_cooldown_end_ms"</span></span>, &amp;WeaponComponent::shooting_cooldown_end_ms)[M&lt;Replicable&gt;()]; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este mecanismo √© muito conveniente de usar. </font><font style="vertical-align: inherit;">Por exemplo, dentro do sistema do servidor, respons√°vel por ‚Äúejetar‚Äù os tokens dos oponentes mortos (em um modo de jogo especial), basta adicionar e configurar o 'ReplicationComponent` nesse token. </font><font style="vertical-align: inherit;">√â assim:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component* component : added_dead_avatars-&gt;components) { Entity kill_token_entity = world-&gt;create_entity(); <span class="hljs-comment"><span class="hljs-comment">//           // ... //   auto* replication_component = kill_token_entity.add&lt;ReplicationComponent&gt;(); replication_component-&gt;enable_replication&lt;TransformComponent&gt;(Privacy::PUBLIC); replication_component-&gt;enable_replication&lt;KillTokenComponent&gt;(Privacy::PUBLIC); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste exemplo, a simula√ß√£o f√≠sica do token durante a perda ocorrer√° no servidor e a transforma√ß√£o final do token ser√° enviada e aplicada no cliente. Um sistema de interpola√ß√£o tamb√©m funcionar√° no cliente, o que facilitar√° o movimento desse token, levando em considera√ß√£o a frequ√™ncia das atualiza√ß√µes, a qualidade da conex√£o com o servidor e assim por diante. Outros sistemas associados a este modo de jogo adicionam uma parte visual aos objetos com `KillTokenComponent` e monitoram sua sele√ß√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O √∫nico inconveniente da abordagem atual que voc√™ deseja prestar aten√ß√£o e da qual deseja se livrar no futuro √© a incapacidade de definir privacidade para cada campo de componente. Isso n√£o √© muito cr√≠tico, pois um problema semelhante pode ser facilmente resolvido dividindo-se o componente em v√°rios: por exemplo, o jogo cont√©m `ShooterPublicComponent` e` ShooterPrivateComponent` com a privacidade correspondente. Apesar de vinculados a um mec√¢nico (tiro), √© necess√°rio ter dois componentes para economizar tr√°fego - alguns dos campos simplesmente n√£o s√£o necess√°rios para clientes que n√£o possuem esses componentes. No entanto, isso adiciona trabalho ao programador.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, os objetos replicados para um cliente podem ter estados para diferentes quadros. </font><font style="vertical-align: inherit;">Portanto, a capacidade de agrupar objetos formando grupos de replica√ß√£o foi adicionada. </font><font style="vertical-align: inherit;">Todos os componentes em objetos dentro do mesmo grupo sempre t√™m um estado para o mesmo quadro no cliente - isso √© necess√°rio para que as previs√µes funcionem corretamente (mais sobre eles abaixo). </font><font style="vertical-align: inherit;">Por exemplo, uma arma e um personagem que a possui est√£o no mesmo grupo. </font><font style="vertical-align: inherit;">Se os objetos estiverem em grupos diferentes, seu estado no mundo poder√° ser para quadros diferentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O sistema de replica√ß√£o tenta minimizar a quantidade de tr√°fego, em particular compactando os dados transmitidos (cada campo dentro do componente pode ser opcionalmente marcado de acordo para a compacta√ß√£o) e transmitindo apenas a diferen√ßa de valores entre os dois quadros.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Previs√µes de clientes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As previs√µes do cliente (o termo previs√£o do lado do cliente √© usado em ingl√™s) permitem que o jogador receba feedback instant√¢neo sobre a maioria de suas a√ß√µes no jogo. </font><font style="vertical-align: inherit;">Ao mesmo tempo, como a √∫ltima palavra est√° sempre atr√°s do servidor, no caso de um erro na simula√ß√£o (o termo erro de previs√£o √© usado em ingl√™s, no futuro os chamarei simplesmente de "previs√µes err√¥neas"), o cliente deve corrigi-lo. </font><font style="vertical-align: inherit;">Mais detalhes sobre erros de previs√£o e como eles s√£o corrigidos ser√£o descritos abaixo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As previs√µes do cliente funcionam de acordo com as seguintes regras:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O cliente simula-se adiante por N frames; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Toda entrada gerada pelo cliente √© enviada ao servidor (na forma de a√ß√µes executadas pelo jogador); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N depende da qualidade da conex√£o com o servidor. </font><font style="vertical-align: inherit;">Quanto menor esse valor, mais "atualizada" a imagem do mundo √© para o cliente (ou seja, o intervalo de tempo entre o jogador local e outros jogadores √© menor).</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, o servidor e o cliente executam a simula√ß√£o com base na entrada do cliente. </font><font style="vertical-align: inherit;">O servidor envia os resultados dessa simula√ß√£o para o cliente. </font><font style="vertical-align: inherit;">Se o cliente determinar que seus resultados n√£o coincidem com os do servidor, ele tenta corrigir o erro - retorna ao √∫ltimo estado conhecido do servidor e simula novamente N quadros √† frente. </font><font style="vertical-align: inherit;">Ent√£o, tudo continua de acordo com um esquema semelhante - o cliente continua a simular-se no futuro em rela√ß√£o ao servidor, e o servidor envia os resultados de sua simula√ß√£o. </font><font style="vertical-align: inherit;">Daqui resulta que todo o c√≥digo que afeta as previs√µes do cliente deve ser compartilhado entre o cliente e o servidor.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, para economizar tr√°fego, toda a entrada √© compactada com base em um esquema predefinido. Em seguida, ele √© enviado ao servidor e imediatamente descompactado de volta ao cliente. O empacotamento e a descompacta√ß√£o subsequente no cliente s√£o necess√°rios para eliminar a diferen√ßa nos valores associados √† entrada entre o cliente e o servidor. Ao criar um esquema, o intervalo de valores para esta a√ß√£o √© indicado e o n√∫mero de bits nos quais ela deve ser compactada. Da mesma forma, o an√∫ncio do esquema de empacotamento no Battle Prime parece dentro de um sistema comum entre o cliente e o servidor:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* input_packing_sc = world-&gt;get_for_write&lt;InputPackingSingleComponent&gt;(); input_packing_sc-&gt;packing_schema = { { ActionNames::MOVE, AnalogStatePrecision{ <span class="hljs-number"><span class="hljs-number">8</span></span>, { <span class="hljs-number"><span class="hljs-number">-1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span> }, <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }, { ActionNames::LOOK, AnalogStatePrecision{ <span class="hljs-number"><span class="hljs-number">16</span></span>, { -PI, PI }, <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }, { ActionNames::JUMP, nullopt }, <span class="hljs-comment"><span class="hljs-comment">// ..    action' };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma condi√ß√£o cr√≠tica para que o desempenho das previs√µes do cliente funcione √© a necessidade de que a entrada tenha tempo para chegar ao servidor no momento em que a simula√ß√£o de quadro √† qual essa entrada est√° relacionada. Se a entrada n√£o conseguiu chegar ao servidor no quadro desejado (isso pode acontecer, por exemplo, com um salto acentuado de ping), o servidor tentar√° usar a entrada desse cliente do quadro anterior. Este √© um mecanismo de backup que pode ajudar a se livrar das previs√µes err√¥neas no cliente em algumas situa√ß√µes. Por exemplo, se um cliente simplesmente executar em uma dire√ß√£o e sua entrada n√£o for alterada por um tempo relativamente longo, o uso de entrada para o √∫ltimo quadro ser√° bem-sucedido - o servidor ir√° ‚Äúadivinhar‚Äù e n√£o haver√° discrep√¢ncia entre o cliente e o servidor. Um esquema semelhante √© usado em Overwatch (foi mencionado em uma palestra no GDC:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.youtube.com/watch?v=W3aieHjyNvw</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atualmente, o cliente Battle Prime prev√™ o status dos seguintes objetos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avatar do jogador (posi√ß√£o no mundo e tudo o que pode afet√°-lo, estado das habilidades, etc.); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Todas as armas do jogador (n√∫mero de rodadas na loja, recargas entre tiros, etc.). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O uso de previs√µes do cliente se resume a adicionar e configurar o `PredictionComponent` no cliente aos objetos desejados. </font><font style="vertical-align: inherit;">Por exemplo, a previs√£o do avatar de um jogador em um dos sistemas √© ativada de maneira semelhante:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// `new_local_avatars`       , //      for (Entity avatar : new_local_avatars) { auto* avatar_prediction_component = avatar.add&lt;PredictionComponent&gt;(); avatar_prediction_component-&gt;enable_prediction&lt;TransformComponent&gt;(); avatar_prediction_component-&gt;enable_prediction&lt;CharacterControllerComponent&gt;(); avatar_prediction_component-&gt;enable_prediction&lt;ShooterPrivateComponent&gt;(); avatar_prediction_component-&gt;enable_prediction&lt;ShooterPublicComponent&gt;(); // ...      }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse c√≥digo significa que os campos dentro dos componentes acima ser√£o comparados constantemente com os mesmos campos dos componentes do servidor - se for observada uma discrep√¢ncia nos valores em um √∫nico quadro, ser√° feito um ajuste no cliente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O crit√©rio de discrep√¢ncia depende do tipo de dados. Na maioria dos casos, isso √© apenas uma chamada para `operator ==`, a exce√ß√£o s√£o os dados baseados em float - para eles, o erro m√°ximo permitido atualmente √© corrigido e √© igual a 0,005. No futuro, h√° um desejo de adicionar a capacidade de definir a precis√£o de cada campo de componente separadamente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O fluxo de trabalho de replica√ß√£o e previs√£o do cliente √© baseado no fato de que todos os dados necess√°rios para a simula√ß√£o est√£o contidos nos componentes. Acima, na se√ß√£o ECS, escrevi que os sistemas podem armazenar parte dos dados - isso pode ser conveniente em alguns casos. Isso n√£o se aplica a nenhum dado que afeta a simula√ß√£o - ele deve sempre estar dentro dos componentes, pois os sistemas de captura instant√¢nea do cliente e do servidor funcionam apenas com os componentes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m de prever valores de campo dentro de componentes, √© poss√≠vel prever a cria√ß√£o e remo√ß√£o de componentes. Por exemplo, se, como resultado do uso da habilidade, um `SpeedModifierComponent` for sobreposto ao personagem (que modifica a velocidade do movimento, por exemplo, acelera o jogador), ele deve ser adicionado ao personagem no servidor e no cliente no mesmo quadro; caso contr√°rio, ele levar√° a uma previs√£o incorreta da posi√ß√£o do personagem no cliente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A previs√£o de cria√ß√£o e exclus√£o de objetos n√£o √© suportada no momento. Isso pode ser conveniente em algumas situa√ß√µes, mas tamb√©m complicar√° os m√≥dulos de rede. Talvez voltemos a isso no futuro.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abaixo est√° um gif no qual o controle de caracteres ocorre com a RTT por cerca de 1,5 segundos. </font><font style="vertical-align: inherit;">Como voc√™ pode ver, o personagem √© controlado instantaneamente, apesar do alto atraso: movimento, tiro, recarga, lan√ßamento de granada - tudo acontece sem esperar pelas informa√ß√µes do servidor. </font><font style="vertical-align: inherit;">Voc√™ tamb√©m pode notar que a captura de um ponto (uma zona limitada por tri√¢ngulos) come√ßa com um atraso - essa mec√¢nica funciona apenas no servidor e n√£o √© prevista pelo cliente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6b/224/09f/a6b22409f317a314819b0163f14f2b6e.gif" alt="imagem" height="1024" width="768"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Previs√µes err√¥neas e simula√ß√µes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erro de impress√£o - discrep√¢ncia entre os resultados das simula√ß√µes do servidor e do cliente. Ressimula√ß√£o √© o processo de corre√ß√£o dessa discrep√¢ncia pelo cliente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primeira raz√£o para a apar√™ncia de erros de previs√£o s√£o os saltos acentuados de ping, pelos quais o cliente n√£o teve tempo de se ajustar. Em tal situa√ß√£o, a entrada do player pode n√£o ter tempo para chegar ao servidor, e o servidor usar√° o mecanismo de backup descrito acima com duplica√ß√£o da √∫ltima entrada por algum tempo e, ap√≥s algum tempo, parar√° de us√°-lo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O segundo motivo √© a intera√ß√£o do personagem com objetos que s√£o totalmente controlados pelo servidor e n√£o s√£o previstos localmente pelo cliente. Por exemplo, uma colis√£o com outro jogador causar√° uma imprevisibilidade - uma vez que eles, de fato, vivem em dois per√≠odos de tempo diferentes (um personagem local √© no futuro relativo a outro jogador - cuja posi√ß√£o vem do servidor e √© interpolada). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O terceiro e mais desagrad√°vel motivo s√£o os erros no c√≥digo. Por exemplo, um sistema pode usar dados n√£o replicados por engano para controlar a simula√ß√£o, ou os sistemas funcionam na ordem errada ou mesmo em ordens diferentes no servidor e no cliente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encontrar esses bugs √†s vezes leva uma quantidade decente de tempo. Para simplificar sua pesquisa, criamos v√°rias ferramentas auxiliares - enquanto o aplicativo est√° em execu√ß√£o, voc√™ pode ver:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Componentes replicados </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O n√∫mero de previs√µes err√¥neas </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em quais quadros eles aconteceram, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quais dados estavam no servidor e no cliente nos componentes divergentes, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Que entrada foi aplicada no servidor e no cliente para esse quadro. </font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9d/ym/7x/9dym7xq_wej-rqkes4zumdvkrxa.png" height="1024" width="768"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4t/4i/ar/4t4iarkyqjkmgdlbabbfordysgi.png" height="1024" width="768"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gp/zt/cy/gpztcyp0k9yobauozchbixe4suy.png" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, mesmo com eles, a busca pelas causas dos reavivamentos ainda leva um tempo decente. </font><font style="vertical-align: inherit;">Sem d√∫vida, ferramentas e valida√ß√µes precisam ser desenvolvidas para reduzir a probabilidade de erros e simplificar sua pesquisa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para apoiar a opera√ß√£o de re-simula√ß√µes, o sistema deve herdar de uma classe espec√≠fica `ResimulatableSystem`. </font><font style="vertical-align: inherit;">Em uma situa√ß√£o em que uma imprevisibilidade ocorre, o mundo ‚Äúreverte‚Äù todos os objetos para o √∫ltimo estado conhecido do servidor e, em seguida, faz o n√∫mero necess√°rio de simula√ß√µes para corrigir esse erro - somente sistemas ressimul√°veis ‚Äã‚Äãparticipar√£o disso.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, as simula√ß√µes de clientes n√£o devem ser percebidas pelos jogadores. </font><font style="vertical-align: inherit;">Quando eles ocorrem, todos os campos de componentes s√£o interpolados suavemente em novos valores para suavizar visualmente poss√≠veis "contra√ß√µes". </font><font style="vertical-align: inherit;">No entanto, √© essencial manter o n√∫mero o mais baixo poss√≠vel.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tiro </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os danos aos jogadores s√£o completamente ditados pelo servidor - os clientes n√£o podem confiar em uma mec√¢nica t√£o importante para reduzir a chance de trapa√ßa. Mas, como o movimento, atirar no cliente deve ser o mais responsivo poss√≠vel e sem atrasos - o jogador precisa receber feedback instant√¢neo na forma de efeitos e sons - focinho, tra√ßo do voo do proj√©til, bem como os efeitos do proj√©til atingindo o entorno e outros jogadores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, todo o estado do personagem associado ao disparo √© previsto pelo cliente - quantas rodadas h√° na loja, a dispers√£o durante o disparo, o atraso entre os disparos, a hora do √∫ltimo disparo e assim por diante. Tamb√©m no cliente existem os mesmos sistemas respons√°veis ‚Äã‚Äãpela movimenta√ß√£o de shells que no servidor - isso permite simular disparos no cliente sem aguardar os resultados de sua simula√ß√£o no servidor.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As bal√≠sticas das pr√≥prias conchas n√£o s√£o previstas - uma vez que voam a uma velocidade muito alta e, por via de regra, terminam seu movimento em alguns quadros, o shell j√° ter√° tempo para chegar a algum ponto do mundo e perder o efeito antes de obtermos os resultados da simula√ß√£o este √© um proj√©til do servidor (ou a falta de resultados se, devido a uma imprevisibilidade, o cliente disparou o proj√©til por engano).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O esquema de trabalho de proj√©teis voando lentamente √© um pouco diferente. </font><font style="vertical-align: inherit;">Se um jogador lan√ßa uma granada, mas como resultado da imprevisibilidade, a granada n√£o foi lan√ßada, ela ser√° destru√≠da no cliente. </font><font style="vertical-align: inherit;">Da mesma forma, se um cliente previu incorretamente a destrui√ß√£o de uma granada (ela j√° explodiu no servidor, mas ainda n√£o no cliente), a granada do cliente tamb√©m ser√° destru√≠da. </font><font style="vertical-align: inherit;">Todas as informa√ß√µes sobre as explos√µes exibidas no cliente v√™m do servidor para evitar situa√ß√µes em que, como resultado de um erro do cliente, a explos√£o do servidor ocorreu em um local e no cliente em outro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealmente, eu gostaria de prever completamente conchas que voam lentamente no futuro - n√£o apenas o tempo da vida, mas tamb√©m a posi√ß√£o delas.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compensa√ß√£o de atraso </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A compensa√ß√£o de retardo √© uma t√©cnica que permite nivelar o efeito do atraso entre o servidor e o cliente na precis√£o do disparo. </font><font style="vertical-align: inherit;">Nesta se√ß√£o, assumirei que o tiro sempre vem de armas "hitscan" - ou seja, </font><font style="vertical-align: inherit;">um proj√©til disparado por uma arma viaja em velocidade infinita. </font><font style="vertical-align: inherit;">Mas tudo o que √© descrito aqui tamb√©m importa com outros tipos de armas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os seguintes pontos tornam necess√°rio compensar o atraso ao fotografar:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O personagem sob o controle do jogador √©, no futuro, relativo ao servidor (prevendo seu estado para um certo n√∫mero de quadros √† frente); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Consequentemente, o restante dos jogadores est√° relativamente no passado; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quando acionada, a a√ß√£o correspondente √© enviada pelo cliente ao servidor e aplicada no mesmo quadro em que foi aplicada no cliente (se poss√≠vel). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se assumirmos que o jogador est√° mirando em um inimigo correndo em dire√ß√£o √† cabe√ßa e pressionar o bot√£o de tiro, a seguinte imagem √© obtida: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No cliente: o atirador no quadro N1 dispara um tiro na cabe√ßa de um inimigo localizado no quadro N0 (N0 &lt;N1); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No servidor: o atirador no quadro N1 dispara um tiro na cabe√ßa do inimigo, tamb√©m localizado no quadro N1 (no servidor, todos s√£o ao mesmo tempo). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O resultado disso, com uma alta probabilidade, √© um erro durante um tiro. </font><font style="vertical-align: inherit;">Como o cliente mira com base em sua imagem do mundo, que n√£o coincide com a imagem do mundo do servidor, para entrar no inimigo, ele precisa apontar para ele mesmo ao usar armas hitscan, e a dist√¢ncia na qual ele deve disparar depende da qualidade da conex√£o com o servidor. </font><font style="vertical-align: inherit;">Isto, para dizer o m√≠nimo, n√£o √© uma boa experi√™ncia para um atirador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para se livrar desse problema, a compensa√ß√£o de atraso √© usada. </font><font style="vertical-align: inherit;">O esquema de seu trabalho √© o seguinte:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O servidor possui um hist√≥rico de tamanho limitado de instant√¢neos do mundo; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quando disparados, os inimigos (ou parte dos inimigos) "retrocedem" de forma que o mundo no servidor corresponda ao mundo que o cliente viu em si - o cliente est√° no "presente" (o momento do disparo) e os inimigos est√£o no passado; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mec√¢nica de detec√ß√£o de acerto funciona, acertos s√£o registrados; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O mundo est√° retornando ao seu estado original. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como a imagem do mundo no cliente tamb√©m depende da opera√ß√£o do sistema de interpola√ß√£o, para "reverter" o mundo para o estado mais preciso do cliente no servidor, o cliente fornece dados adicionais - a diferen√ßa entre o quadro atual do cliente e o quadro para o qual ele v√™ todos os outros jogadores (no momento, s√£o dois bytes por quadro), bem como o tempo de gera√ß√£o da entrada da tomada em rela√ß√£o ao in√≠cio do quadro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A compensa√ß√£o de atraso existe no n√≠vel de um m√≥dulo separado dentro do mecanismo e n√£o est√° vinculada a um projeto espec√≠fico. </font><font style="vertical-align: inherit;">Do ponto de vista do desenvolvedor da mec√¢nica de jogo, seu uso √© o seguinte:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LagCompensationComponent √© adicionado ao player e a lista de hitboxes a serem armazenadas no hist√≥rico √© preenchida; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao fotografar (ou outras mec√¢nicas que exigem compensa√ß√£o - por exemplo, em ataques corpo a corpo), `LagCompensation :: invoke` √© chamado, onde o functor √© passado, que ser√° executado no" compensado ", do ponto de vista de um jogador em particular, mundo. </font><font style="vertical-align: inherit;">Ele deve ter toda a detec√ß√£o de ocorr√™ncias necess√°ria.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Codifique com um exemplo do uso de compensa√ß√£o de atraso do Batle Prime ao mover proj√©teis bal√≠sticos: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// `targets_data`    , //   ‚Äú‚Äù    , //    const auto compensated_action = [this](const Vector&lt;LagCompensation::LagCompensationData&gt;&amp; targets_data) { process_projectile(projectile, elapsed_time); }; LagCompensation::invoke( observer, // ,       projectile_component-&gt;input_time_ms, // ,      compensated_entities, // ,    compensated_action // ,       );</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m gostaria de observar que a compensa√ß√£o de atraso √© um esquema que coloca a experi√™ncia do atirador acima da experi√™ncia do alvo em que ele est√° atirando. </font><font style="vertical-align: inherit;">Do ponto de vista do alvo, o inimigo pode entrar nele quando j√° est√° atr√°s de um obst√°culo (uma reclama√ß√£o frequente nos f√≥runs de jogos). </font><font style="vertical-align: inherit;">Para fazer isso, a compensa√ß√£o de atraso possui um n√∫mero limitado de quadros para os quais os objetivos podem ser "bombeados". </font><font style="vertical-align: inherit;">No momento, no Battle Prime, um atirador com um RTT de cerca de 400 milissegundos pode acertar confortavelmente inimigos. </font><font style="vertical-align: inherit;">Se o RTT for maior, voc√™ ter√° que ir adiante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um exemplo de tiro sem compensa√ß√£o - voc√™ precisa disparar √† frente para atingir constantemente o inimigo:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f49/510/94b/f4951094b844f899b7bafc0fd2783534.gif" alt="imagem" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E com compensa√ß√£o - voc√™ pode apontar confortavelmente diretamente para o inimigo: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/2fe/126/ffe2fe12616364feb0251847e02b3807.gif" alt="imagem" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nossos agentes de constru√ß√£o tamb√©m executam periodicamente testes autom√°ticos que verificam o trabalho de diferentes mec√¢nicos. Entre eles, h√° tamb√©m um autoteste para precis√£o de disparo com a compensa√ß√£o de atraso ativada. No gif abaixo, este teste √© mostrado - o personagem simplesmente atira na cabe√ßa de um inimigo que passa correndo e conta o n√∫mero de acertos nele. Para depura√ß√£o, as caixas de acerto do inimigo que estavam no servidor no momento do disparo (em branco) e as caixas de acerto usadas para a detec√ß√£o de acertos dentro do mundo compensado (em azul) tamb√©m s√£o exibidas:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f99/8cf/e30/f998cfe305878180085bb44352b36a85.gif" alt="imagem" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um fator adicional que afeta a precis√£o do disparo √© a posi√ß√£o das caixas de acerto no personagem. As caixas de ocorr√™ncias dependem de anima√ß√µes esquel√©ticas e, atualmente, suas fases n√£o s√£o sincronizadas de forma alguma, portanto √© poss√≠vel que as caixas de ocorr√™ncias sejam diferentes entre o cliente e o servidor. As conseq√º√™ncias disso dependem das pr√≥prias anima√ß√µes - quanto maior a amplitude de movimento dentro da anima√ß√£o, maior a diferen√ßa potencial na posi√ß√£o das caixas de acerto entre o servidor e o cliente. Na pr√°tica, essa diferen√ßa n√£o √© percept√≠vel para o jogador e afeta mais a parte inferior do corpo, o que √© menos cr√≠tico em compara√ß√£o com a parte superior (cabe√ßa, tronco, bra√ßos). No entanto, no futuro, gostaria de abordar com mais detalhes a quest√£o da sincroniza√ß√£o de anima√ß√µes entre o servidor e o cliente.</font></font><br><br><h1>  Conclus√£o </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste artigo, tentei descrever a base sobre a qual o Battle Prime se baseia - esta √© a implementa√ß√£o do padr√£o ECS dentro do Blitz Engine, bem como o m√≥dulo de rede respons√°vel pela replica√ß√£o, pelas previs√µes dos clientes e pela mec√¢nica relacionada. </font><font style="vertical-align: inherit;">Apesar de algumas falhas (que continuamos trabalhando na corre√ß√£o), o uso dessa funcionalidade agora √© simples e conveniente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mostrar a imagem geral do Battle Prime, tive que abordar um grande n√∫mero de t√≥picos. </font><font style="vertical-align: inherit;">Muitos deles podem ser dedicados a separar artigos no futuro, nos quais ser√£o descritos com mais detalhes! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O jogo j√° est√° sendo testado na Turquia e nas Filipinas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nossos artigos anteriores podem ser encontrados nos seguintes links:</font></font><br><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/en/post/461623</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/en/post/465343</font></font></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt469709/">https://habr.com/ru/post/pt469709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt469689/index.html">Economize tempo ao trabalhar com a linha de comando</a></li>
<li><a href="../pt469693/index.html">Como alimentar milh√µes de chineses em meia hora</a></li>
<li><a href="../pt469697/index.html">O nascimento de novas tecnologias em processos de neg√≥cios fabricados tradicionalmente</a></li>
<li><a href="../pt469703/index.html">Avalonia regular</a></li>
<li><a href="../pt469707/index.html">Configurando o VSCode para Trabalhar com o Scala</a></li>
<li><a href="../pt469717/index.html">Deixe a luz brilhar</a></li>
<li><a href="../pt469721/index.html">Dell OptiPlex 7070 Ultra: um computador modular que transforma qualquer monitor em um monobloco</a></li>
<li><a href="../pt469723/index.html">Criando uma habilidade stateful para Alice nas fun√ß√µes sem servidor do Yandex.Cloud e Python</a></li>
<li><a href="../pt469725/index.html">Guia do sistema solar para caronas</a></li>
<li><a href="../pt469731/index.html">Manipulando exce√ß√µes do ASP.NET usando IRO.Mvc.MvcExceptionHandler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>