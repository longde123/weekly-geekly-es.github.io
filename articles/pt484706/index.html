<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>„ÄΩÔ∏è üêç ‚è™ Pr√°tica no trabalho com pneus personalizados do complexo Redd üè† üë®‚Äçüë®‚Äçüë¶ üìâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No √∫ltimo artigo, examinamos a teoria de gerenciar mil pequenas coisas no complexo Redd, mas, para n√£o aumentar o volume, adiamos a pr√°tica da pr√≥xima...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pr√°tica no trabalho com pneus personalizados do complexo Redd</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484706/"> No <a href="https://habr.com/ru/post/483724/">√∫ltimo artigo,</a> examinamos a teoria de gerenciar mil pequenas coisas no complexo Redd, mas, para n√£o aumentar o volume, adiamos a pr√°tica da pr√≥xima vez.  Chegou a hora de realizar experimentos pr√°ticos.  Aqueles que n√£o usam o complexo Redd tamb√©m poder√£o encontrar conhecimento √∫til neste artigo, a saber, a metodologia para enviar comandos do Fornecedor para drives USB a partir do Linux, porque, como j√° mencionado, o controlador STM32 no complexo desempenha a fun√ß√£o de um leitor SD, ou seja, dirigir. <br><br><img src="https://habrastorage.org/webt/_e/hh/5n/_ehh5nw2j8tiw7myjovthvvc_va.png"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Artigos anteriores do ciclo</b> <div class="spoiler_text"><ol><li>  <a href="https://habr.com/ru/post/452656/">Desenvolvimento do ‚Äúfirmware‚Äù mais simples para FPGAs instalados no Redd e depura√ß√£o usando o teste de mem√≥ria como exemplo.</a> </li><li>  <a href="https://habr.com/ru/post/453682/">Desenvolvimento do ‚Äúfirmware‚Äù mais simples para FPGAs instalados em Redd.</a>  <a href="https://habr.com/ru/post/453682/">Parte 2. C√≥digo do programa.</a> </li><li>  <a href="https://habr.com/ru/post/454938/">Desenvolvimento de n√∫cleo pr√≥prio para incorpora√ß√£o em um sistema de processador baseado em FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/456008/">Desenvolvimento de programas para o processador central Redd no exemplo de acesso ao FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/462253/">Os primeiros experimentos usando o protocolo de streaming no exemplo da conex√£o da CPU e do processador no FPGA do complexo Redd.</a> </li><li>  <a href="https://habr.com/ru/post/464795/">Merry Quartusel, ou como o processador ganhou vida.</a> </li><li>  <a href="https://habr.com/ru/post/467353/">M√©todos de otimiza√ß√£o de c√≥digo para Redd.</a>  <a href="https://habr.com/ru/post/467353/">Parte 1: efeito de cache.</a> </li><li>  <a href="https://habr.com/ru/post/468027/">M√©todos de otimiza√ß√£o de c√≥digo para Redd.</a>  <a href="https://habr.com/ru/post/468027/">Parte 2: mem√≥ria n√£o armazenada em cache e opera√ß√£o de barramento paralelo.</a> </li><li>  <a href="https://habr.com/ru/post/469985/">Otimiza√ß√£o abrangente de c√≥digo: substituindo um gerador de rel√≥gio para melhorar o desempenho do sistema.</a> </li><li>  <a href="https://habr.com/ru/post/477662/">Acesso a barramentos redd implementados em controladores FTDI</a> </li><li>  <a href="https://habr.com/ru/post/483724/">Trabalhar com o complexo de pneus personalizados Redd</a> </li></ol><br></div></div><br><h2>  Classifica√ß√£o da unidade por sistemas de comando </h2><br>  Ao trabalhar com unidades, voc√™ deve distinguir entre uma interface f√≠sica e um sistema de comando.  Em particular, unidades de CD / DVD / BD e outras √≥pticas.  Tradicionalmente, eles se conectam a um cabo SATA (anteriormente IDE).  Por√©m, especificamente nesse fio, apenas os comandos PACKET s√£o executados durante a opera√ß√£o, no bloco de dados em que os comandos codificados de acordo com um princ√≠pio completamente diferente s√£o colocados (em breve descobriremos qual).  Portanto, agora falaremos n√£o tanto sobre fios, mas sobre as equipes que os rodeiam.  Conhe√ßo tr√™s sistemas de comando comuns para trabalhar com unidades. <br><br><ul><li>  MMC  √â entendido por cart√µes SD.  Honestamente, para mim este √© o sistema de comando mais misterioso.  Como envi√°-los, ao que parece, √© claro, mas como gerenciar a unidade sem ler atentamente o documento que cont√©m muitos gr√°ficos de transi√ß√£o - estou sempre confuso.  Felizmente, isso n√£o nos incomoda atualmente, pois, embora trabalhemos com um cart√£o SD, o controlador STM32 no modo "caixa preta" trabalha com ele. </li><li>  ATA  Inicialmente, esses comandos eram executados no barramento IDE e depois no SATA.  Um sistema de comando maravilhoso, mas hoje tamb√©m mencionamos que ele existe. </li><li>  SCSI  Este sistema de comando √© usado em uma ampla variedade de dispositivos.  Considere seu uso em unidades.  Hoje, as equipes de SCSI executam, antes de tudo, os fios do barramento SAS (a prop√≥sito, at√© SSDs com interface SAS est√£o na moda).  Curiosamente, as unidades √≥pticas conectadas fisicamente ao barramento SATA tamb√©m funcionam atrav√©s de comandos SCSI.  No barramento USB ao trabalhar de acordo com o padr√£o do dispositivo de armazenamento em massa, os comandos tamb√©m v√£o no formato SCSI.  O microcontrolador STM32 √© conectado ao complexo Redd atrav√©s do barramento USB, ou seja, no nosso caso, os comandos seguem o seguinte caminho: <br><br><img src="https://habrastorage.org/webt/hy/iy/f4/hyiyf4m9sjgr8etz8ily8joxsrc.png"><br></li></ul><br>  Do PC ao controlador, via USB, os comandos est√£o no formato SCSI.  O controlador transcodifica os comandos de acordo com a regra do MMC e os envia pelo barramento SDIO.  Mas temos que escrever um programa para o PC, para que as equipes nos deixem no formato SCSI.  Eles s√£o preparados pelo driver de dispositivo do dispositivo de armazenamento em massa, com o qual nos comunicamos atrav√©s do driver do sistema de arquivos.  √â poss√≠vel misturar solicita√ß√µes com outros dispositivos para essas solicita√ß√µes?  Vamos acertar. <br><br><h2>  Detalhes do sistema de comando SCSI </h2><br>  Se voc√™ abordar o assunto formalmente, a descri√ß√£o do padr√£o SCSI estar√° dispon√≠vel no t10.org, mas seremos realistas.  Ningu√©m o ler√° voluntariamente.  Mais precisamente, n√£o o dele, mas o deles: existe uma pilha inteira de documentos abertos e uma montanha de documentos fechados. Somente uma necessidade extrema far√° com que voc√™ mergulhe na linguagem complexa em que o padr√£o est√° escrito (isso, a prop√≥sito, se aplica ao padr√£o ATA em t13.org).  √â muito mais f√°cil ler a documenta√ß√£o para unidades reais.  Est√° escrito em uma linguagem mais animada, e partes hipot√©ticas, mas n√£o realmente usadas, s√£o cortadas.  Ao preparar o artigo, me deparei com um documento bastante novo (2016) do <b>Manual de refer√™ncia de comandos SCSI</b> da Seagate (link direto <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">www.seagate.com/files/staticfiles/support/docs/manual/Interface%20manuals/100293068j.pdf</a> , mas, como sempre, N√£o sei quanto tempo ela vai viver).  Eu acho que se algu√©m quiser dominar esse sistema de comandos, ele deve come√ßar com este documento.  Lembramos apenas que os leitores SD implementam um subconjunto ainda menor dos comandos dessa descri√ß√£o. <br><br>  Falando muito brevemente, uma unidade de comando com um comprimento de 6 a 16 bytes √© enviada para a unidade.  Um bloco de dados pode ser anexado ao bloco de comando do PC para a unidade ou da unidade para o PC (o padr√£o SCSI tamb√©m permite trocas bidirecionais, mas para o Dispositivo de armazenamento em massa via USB apenas um bloco √© permitido, o que significa que a dire√ß√£o √© apenas uma).  No bloco de instru√ß√µes, o primeiro byte √© sempre o c√≥digo de comando.  Os bytes restantes s√£o seus argumentos.  As regras para preenchimento dos argumentos s√£o descritas exclusivamente pelos detalhes da implementa√ß√£o do comando. <br><br><img src="https://habrastorage.org/webt/xt/1l/eb/xt1lebwoznye5dag98pwbtiuxfm.png"><br><br>  No come√ßo, inseri muitos exemplos no artigo, mas depois percebi que eles dificultam a leitura.  Portanto, sugiro que todos comparem os campos do comando READ CAPACITY (10) da tabela 119 do documento Seigate e os campos do comando READ (10) da tabela 97 do mesmo documento (consulte o link acima).  Quem n√£o encontrou nenhuma conex√£o - n√£o se assuste.  Era isso que eu queria mostrar.  Al√©m do campo "comando" no byte zero, o objetivo de todos os campos depende exclusivamente das especificidades de um comando espec√≠fico.  Voc√™ sempre precisa abrir o documento e estudar a finalidade dos campos restantes nele. <br><br>  Ent√£o: <br><br><ul><li>  Para se comunicar com a unidade, voc√™ deve formar um bloco de comando com um comprimento de 6 a 16 bytes (dependendo do formato do comando, o n√∫mero exato √© indicado na documenta√ß√£o para ele). </li><li>  O mais importante √© o byte zero do bloco: √© ele quem define o c√≥digo de comando. </li><li>  Os bytes restantes do bloco n√£o t√™m um objetivo claro.  Para entender como preench√™-los, voc√™ deve abrir a documenta√ß√£o para uma equipe espec√≠fica. </li><li>  Um bloco de dados que pode ser transferido para ou de uma unidade pode ser anexado a um comando. </li></ul><br>  Na verdade, √© tudo.  Aprendemos as regras para emitir comandos SCSI.  Agora podemos envi√°-los, haveria documenta√ß√£o sobre eles.  Mas como fazer isso no n√≠vel do sistema operacional? <br><br><h2>  Comandos Linux SCSI </h2><br><h3>  Pesquisar dispositivo de destino </h3><br>  Para emitir comandos, abra o dispositivo de disco.  Vamos encontrar o nome dele.  Para fazer isso, seguiremos exatamente da mesma maneira que no <a href="https://habr.com/ru/post/477662/">artigo sobre portas seriais</a> .  Vamos ver a lista de ‚Äúarquivos‚Äù no <b>diret√≥rio / dev</b> (lembre-se de que nos dispositivos Linux tamb√©m s√£o mostrados como arquivos e sua lista √© exibida com o mesmo <b>comando ls</b> ). <br><br>  Hoje prestamos aten√ß√£o ao <b>disco do</b> diret√≥rio virtual: <br><br><img src="https://habrastorage.org/webt/t_/py/kj/t_pykjsq2_2gdno-u0oc9wdpltm.png"><br><br>  Analisamos seu conte√∫do: <br><br><img src="https://habrastorage.org/webt/cp/yp/n_/cpypn_cslhfibis7ixhbez64q4y.png"><br><br>  Um conjunto familiar de diret√≥rios aninhados!  Estamos tentando considerar o diret√≥rio <b>by-id</b> , usando a op√ß√£o <b>‚Äìl</b> do <b>comando ls, que</b> j√° sab√≠amos no artigo sobre portas seriais: <br><br><img src="https://habrastorage.org/webt/jq/8s/zn/jq8sznkl6pimg5oxevbdp8m7l4w.png"><br><br>  Palavras destacadas falam por si.  Esta √© uma unidade que cont√©m o cart√£o SD interno do complexo Redd.  √ìtimo!  Agora sabemos que o dispositivo <b>MIR_Redd_Internal_SD</b> corresponde ao dispositivo <b>/ dev / sdb e / dev / sdb1</b> .  Aquele que sem o n√∫mero √© a pr√≥pria unidade, trabalharemos com ela e, com o n√∫mero, √© o sistema de arquivos localizado na m√≠dia inserida nela.  Em termos de trabalho com um cart√£o SD, <b>/ dev / sdb</b> √© o leitor e <b>/ dev / sdb1</b> √© o sistema de arquivos no cart√£o inserido nele. <br><br><h3>  Fun√ß√£o do sistema operacional para emitir comandos </h3><br>  Normalmente, em qualquer sistema operacional, todas as coisas n√£o padronizadas dos dispositivos s√£o feitas atrav√©s de solicita√ß√µes diretas ao driver.  No Linux, a fun√ß√£o <b>ioctl ()</b> est√° dispon√≠vel para enviar esses pedidos.  Nosso caso n√£o √© exce√ß√£o.  Como argumento, passamos a solicita√ß√£o SG_IO descrita no arquivo de cabe√ßalho <b>sg.h.</b>  A estrutura <b>sg_io_hdr_t</b> que cont√©m os par√¢metros de solicita√ß√£o tamb√©m √© descrita l√°.  N√£o darei a estrutura completa, pois nem todos os seus campos devem ser preenchidos.  Vou dar apenas o mais importante deles: <br><br><pre><code class="plaintext hljs">typedef struct sg_io_hdr { int interface_id; /* [i] 'S' for SCSI generic (required) */ int dxfer_direction; /* [i] data transfer direction */ unsigned char cmd_len; /* [i] SCSI command length ( &lt;= 16 bytes) */ unsigned char mx_sb_len; /* [i] max length to write to sbp */ unsigned short int iovec_count; /* [i] 0 implies no scatter gather */ unsigned int dxfer_len; /* [i] byte count of data transfer */ void * dxferp; /* [i], [*io] points to data transfer memory or scatter gather list */ unsigned char * cmdp; /* [i], [*i] points to command to perform */ unsigned char * sbp; /* [i], [*o] points to sense_buffer memory */ unsigned int timeout; /* [i] MAX_UINT-&gt;no timeout (unit: millisec) */</code> </pre> <br>  N√£o faz sentido descrever os campos que est√£o bem documentados nos coment√°rios ( <b>interface_id, dxfer_direction, timeout</b> ).  O artigo j√° est√° crescendo. <br><br>  O campo <b>cmd_len</b> cont√©m o n√∫mero de bytes no bloco de comando e o <b>cmdp cont√©m</b> um ponteiro para esse bloco.  Voc√™ n√£o pode ficar sem um comando, portanto, o n√∫mero de bytes deve ser diferente de zero (de 6 a 16). <br><br>  Os dados s√£o opcionais.  Se estiverem, o comprimento do buffer selecionado √© especificado no campo <b>dxfer_len</b> e um ponteiro para ele √© especificado no campo <b>dxferp</b> .  Uma unidade pode transferir fisicamente menos dados que o tamanho do buffer especificado.  A dire√ß√£o da transmiss√£o √© especificada no campo <b>dxfer_direction</b> .  Os valores v√°lidos do dispositivo de armazenamento em massa USB s√£o: <b>SG_DXFER_NONE, SG_DXFER_TO_DEV, SG_DXFER_FROM_DEV</b> .  H√° mais uma coisa no arquivo de cabe√ßalho, mas o padr√£o do dispositivo de armazenamento em massa n√£o permite implement√°-lo fisicamente. <br><br>  Voc√™ tamb√©m pode solicitar o retorno de um c√≥digo de erro estendido ( <b>SENSE</b> ).  O que √© encontrado pode ser encontrado no documento Segate, se√ß√£o 2.4.  O comprimento do buffer alocado √© indicado no campo <b>mx_sb_len</b> , e o ponteiro para o buffer em si √© indicado no campo <b>sbp</b> . <br><br>  Como voc√™ pode ver, tudo o que eu falei acima est√° preenchido nesta estrutura (al√©m disso, voc√™ pode obter informa√ß√µes estendidas sobre o erro).  Leia mais sobre como trabalhar com a solicita√ß√£o <b>SG_IO</b> aqui: <a href="http://sg.danny.cz/sg/sg_io.html">sg.danny.cz/sg/sg_io.html</a> <br><br><h3>  Enviamos um comando padr√£o para a unidade </h3><br>  Bem, descobrimos o formato do comando, descobrimos para qual dispositivo envi√°-lo, descobrimos qual fun√ß√£o chamar.  Vamos tentar enviar algum comando padr√£o para o nosso dispositivo.  Seja este o comando para obter o nome da unidade.  √â assim que √© descrito no documento Sigeyt: <br><br><img src="https://habrastorage.org/webt/nj/qk/ca/njqkcamj1tnhjznoczjnrdfni60.png"><br><br>  Observe que, de acordo com a ideologia SCSI, todos os campos nos comandos padr√£o s√£o preenchidos na nota√ß√£o Big Endian, ou seja, o maior byte a frente.  Portanto, preenchemos o campo com o tamanho do buffer n√£o no formato "0x80, 0x00", mas, pelo contr√°rio - "0x00, 0x80".  Mas isso est√° em comandos padr√£o.  No n√£o padr√£o, tudo √© poss√≠vel, voc√™ deve sempre consultar a descri√ß√£o.  Na verdade, apenas o c√≥digo de comando ( <b>12h</b> ) e o comprimento que precisamos preencher.  Solicitaremos uma p√°gina zero e os campos restantes ser√£o reservados ou desatualizados ou o padr√£o ser√° zero.  Ent√£o, preencha todos com zeros. <br><br><div class="spoiler">  <b class="spoiler_title">N√≥s criamos um programa que fornece este comando:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; // open #include &lt;unistd.h&gt; // close #include &lt;sys/ioctl.h&gt; #include &lt;scsi/scsi.h&gt; #include &lt;scsi/sg.h&gt; int main() { printf("hello from SdAccessTest!\n"); int s_fd = open("/dev/sdb", O_NONBLOCK | O_RDWR); if (s_fd &lt; 0) { printf("Cannot open file\n"); return -1; } sg_io_hdr_t header; memset(&amp;header;, 0, sizeof(header)); uint8_t cmd12h[] = { 0x12,0x00,0x00,0x00,0x80,0x00}; uint8_t data[0x80]; uint8_t sense[0x80]; header.interface_id = 'S'; //  'S' //  header.cmd_len = sizeof(cmd12h); header.cmdp = cmd12h; //  header.dxfer_len = sizeof(data); header.dxferp = data; header.dxfer_direction = SG_DXFER_TO_FROM_DEV; //     header.mx_sb_len = sizeof(sense); header.sbp = sense; // header.timeout = 100; // 100  int res = ioctl(s_fd, SG_IO, &amp;header;); close(s_fd); return 0; }</code> </pre><br></div></div><br><br>  Como executar esses programas em um dispositivo Redd remoto, j√° discutimos em um dos <a href="https://habr.com/ru/post/456008/">artigos anteriores</a> .  √â verdade que, iniciando-o pela primeira vez, recebi imediatamente um erro ao chamar a fun√ß√£o <b>open ()</b> .  Descobriu-se que o usu√°rio por padr√£o n√£o tem direitos suficientes para abrir dispositivos de disco.  Qual de mim √© especialista em Linux, escrevi v√°rias vezes, mas na rede consegui descobrir que, para resolver esse problema, voc√™ pode alterar os direitos de acesso ao dispositivo emitindo o comando: <br><br>  <b>sudo chmod 666 / dev / sdb</b> <br><br>  No entanto, meu chefe (e ele √© um grande especialista neste sistema operacional) mais tarde observou que a solu√ß√£o √© v√°lida at√© que o sistema operacional seja reiniciado.  Para obter os direitos com certeza, voc√™ precisa adicionar o usu√°rio ao grupo de <b>discos</b> . <br><br>  Qualquer que seja o caminho, mas depois que tudo tiver funcionado, coloque um ponto de interrup√ß√£o na linha <b>close (s_fd);</b>  e inspecione os resultados at√© o momento em que √© alcan√ßado no ambiente de desenvolvimento (j√° que o programa nem sequer √© de um dia, o que significa que n√£o temos tempo para gastar tempo e esfor√ßo na inser√ß√£o de mapeadores, se o ambiente de desenvolvimento puder nos mostrar tudo).  O valor de <b>res</b> √© zero.  Ent√£o a equipe trabalhou sem erros. <br><br><img src="https://habrastorage.org/webt/ih/2o/40/ih2o40ujbpv2p0qk9m_qiwdw9do.png"><br><br>  O que veio para o buffer?  Quando inseri a palavra <b>dados</b> no endere√ßo do despejo, eles me disseram que n√£o podiam calcular o valor, tive que inserir o <b>&amp; data;</b>  .  √â estranho, porque os <b>dados</b> s√£o um ponteiro, ao depurar no Windows tudo funciona, mas apenas observe esse fato, funciona assim: veja o resultado obtido assim: <br><br><img src="https://habrastorage.org/webt/bj/tk/ae/bjtkaehd8ucyzdufbdsn1392tgm.png"><br><br>  √â isso mesmo, eles retornaram o nome e a revis√£o da unidade para n√≥s.  Mais informa√ß√µes sobre o formato da estrutura resultante podem ser encontradas no documento Segate (se√ß√£o 3.6.2, tabela 59).  O buffer de <b>detec√ß√£o</b> n√£o foi preenchido, mas a descri√ß√£o IOCTL da solicita√ß√£o diz que √© preenchida apenas quando ocorre um erro que retorna algo nesse buffer.  Literalmente: <b>dados de detec√ß√£o (usados ‚Äã‚Äãapenas quando 'status' √© CHECK CONDITION ou (driver_status &amp; DRIVER_SENSE) s√£o verdadeiros)</b> . <br><br><h2>  Formato de comando personalizado para a unidade SD interna Redd </h2><br>  Agora que n√£o apenas estudamos a descri√ß√£o seca do padr√£o, mas tamb√©m tentamos tudo na pr√°tica, tendo experimentado o que √© um bloco de comando, j√° podemos mostrar o formato de comando com o qual voc√™ pode chamar fun√ß√µes fora do padr√£o que s√£o "piscadas" para o controlador STM32 na placa complexa.  O c√≥digo de comando que selecionei desde o in√≠cio do intervalo de comandos <b>espec√≠ficos</b> do <b>fornecedor</b>  √â igual a 0xC0.  Tradicionalmente, nas descri√ß√µes dos comandos SCSI, escreva <b>C0h</b> .  O comprimento do comando √© sempre 10 bytes.  O formato da equipe √© unificado e apresentado na tabela abaixo. <br><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Byte</b> </td><td>  <b>Nomea√ß√£o</b> </td></tr><tr><td>  0 0 </td><td>  C√≥digo de comando C0h </td></tr><tr><td>  1 </td><td>  C√≥digo de subcomando </td></tr><tr><td>  2 </td><td rowspan="4">  Argumento arg1.  Situado na nota√ß√£o Little Endian (avan√ßo de bytes baixos) </td></tr><tr><td>  3 </td></tr><tr><td>  4 </td></tr><tr><td>  5 </td></tr><tr><td>  6 </td><td rowspan="4">  Argumento arg2.  Situado na nota√ß√£o Little Endian (avan√ßo de bytes baixos) </td></tr><tr><td>  7 </td></tr><tr><td>  8 </td></tr><tr><td>  9 </td></tr></tbody></table></div><br>  Como voc√™ pode ver, os argumentos s√£o dados na nota√ß√£o Little Endian.  Isso permitir√° que voc√™ descreva o comando na forma de uma estrutura e acesse seus campos diretamente, sem recorrer √† fun√ß√£o de permuta√ß√£o de bytes.  Problemas de alinhamento (palavras duplas na estrutura t√™m compensa√ß√µes que n√£o s√£o m√∫ltiplas de quatro) nas arquiteturas x86 e x64 n√£o valem a pena. <br><br>  Os c√≥digos de subcomando s√£o descritos pela seguinte enumera√ß√£o: <br><pre> <code class="plaintext hljs">enum vendorSubCommands { subCmdSdEnable = 0, // 00 Switch SD card to PC or Outside subCmdSdPower, // 01 Switch Power of SD card On/Off subCmdSdReinit, // 02 Reinitialize SD card (for example, after Power Cycle) subCmdSpiFlashEnable, // 03 Switch SPI Flash to PC or Outside subCmdSpiFlashWritePage, // 04 Write Page to SPI Flash subCmdSpiFlashReadPage, // 05 Read Page from SPI Flash subCmdSpiFlashErasePage,// 06 Erase Pages on SPI Flash (4K block) subCmdRelaysOn, // 07 Switch relays On by mask subCmdRelaysOff, // 08 Switch relays off by mask subCmdRelaysSet, // 09 Set state of all relays by data subCmdFT4222_1_Reset, // 0A Activate Reset State or switch chip to normal mode subCmdFT4222_2_Reset, // 0B Activate Reset State or switch chip to normal mode subCmdFT4222_3_Reset, // 0C Activate Reset State or switch chip to normal mode subCmdFT4232_Reset, // 0D Activate Reset State or switch chip to normal mode subCmdFT2232_Reset, // 0E Activate Reset State or switch chip to normal mode subCmdMAX3421_Reset, // 0F Activate Reset State or switch chip to normal mode subCmdFT4222_1_Cfg, // 10 Write to CFG pins of FT4222_1 subCmdFT4222_2_Cfg, // 11 Write to CFG pins of FT4222_2 subCmdFT4222_3_Cfg, // 12 Write to CFG pins of FT4222_3 };</code> </pre><br>  Eles podem ser divididos em grupos. <br><br><h3>  Alternando dispositivos para modos interno e externo </h3><br>  Os <b>comandos subCmdSdEnable</b> e <b>subCmdSpiFlashEnable</b> alternam o cart√£o SD e o SPI, respectivamente.  O par√¢metro <b>arg1</b> passa um dos seguintes valores: <br><br><pre> <code class="plaintext hljs">enum enableMode { enableModeToPC = 0, enableModeOutside };</code> </pre> <br>  Por padr√£o, os dois dispositivos est√£o conectados a um PC. <br><br><h3>  Comuta√ß√£o de energia </h3><br>  O protocolo SDIO requer muita manipula√ß√£o durante a inicializa√ß√£o.  √Äs vezes, √© √∫til redefinir o cart√£o SD para seu estado inicial (por exemplo, ao mudar suas linhas para um conector externo).  Para fazer isso, desligue e ligue a energia.  Isso pode ser feito usando o <b>comando subCmdSdPower</b> .  No argumento <b>arg1,</b> um dos seguintes valores √© passado: 0 - desligado, 1 - ligado.  Lembre-se de reservar um tempo para descarregar os capacitores na linha de energia. <br><br>  Depois de ligar a alimenta√ß√£o, o cart√£o, se estiver conectado ao PC, deve ser reinicializado.  Para fazer isso, use o comando <b>subCmdSdReinit</b> (ele n√£o possui argumentos). <br><br><h3>  Trabalhar com a unidade flash SPI </h3><br>  Se o cart√£o SD estiver conectado ao sistema como uma unidade completa, o chip de acesso na vers√£o atual √© bastante limitado.  Voc√™ pode acessar apenas suas p√°ginas individuais (256 bytes) e apenas uma de cada vez.  A quantidade de mem√≥ria no microcircuito √© tal que, mesmo quando se trabalha na p√°gina, o processo n√£o leva muito tempo, mas essa abordagem simplifica bastante o "firmware" do microcontrolador. <br><br>  O comando <b>subCmdSpiFlashReadPage</b> l√™ a p√°gina.  O endere√ßo √© especificado no par√¢metro arg1, o n√∫mero de p√°ginas a serem transmitidas no par√¢metro arg2.  Mas na vers√£o atual, o n√∫mero de p√°ginas deve ser igual a uma.  O comando retornar√° 256 bytes de dados. <br><br>  Espelhado para ela est√° o comando <b>subCmdSpiFlashWritePage</b> .  Os argumentos para ela s√£o preenchidos pelo mesmo princ√≠pio.  A dire√ß√£o da transfer√™ncia de dados √© para o dispositivo. <br><br>  A peculiaridade da mem√≥ria flash √© que apenas bits √∫nicos podem ser substitu√≠dos por zero durante a grava√ß√£o.  Para devolv√™-los a um √∫nico valor, as p√°ginas devem ser apagadas.  Existe um comando <b>subCmdSpiFlashErasePage</b> para <b>isso</b> .  √â verdade que, devido aos recursos do microcircuito usado, n√£o √© uma √∫nica p√°gina configurada no par√¢metro <b>arg1</b> que √© apagada, mas um bloco de 4 kilobytes que o cont√©m. <br><br><h3>  Gerenciamento de rel√©s de estado s√≥lido </h3><br>  O complexo possui seis rel√©s de estado s√≥lido.  Existem tr√™s equipes para gerenci√°-los. <br><br>  <b>subCmdRelaysSet</b> - define o valor de todos os seis rel√©s simultaneamente.  No par√¢metro <b>arg1, um</b> valor √© passado, cada bit correspondendo ao seu pr√≥prio rel√© (zero bit - rel√© com √≠ndice 0, primeiro bit com √≠ndice 1, etc.).  Um valor de bit √∫nico fecha o rel√©, um valor zero faz com que ele seja aberto. <br><br>  Este m√©todo de opera√ß√£o √© bom quando todos os rel√©s funcionam como um √∫nico grupo.  Se eles funcionarem independentemente um do outro, com essa abordagem, voc√™ precisar√° iniciar uma vari√°vel de buffer que armazene o valor do estado de todos os rel√©s.  Se diferentes rel√©s s√£o controlados por diferentes programas, o problema de armazenar o valor agregado se torna extremamente agudo.  Nesse caso, voc√™ pode usar outros dois comandos: <br><br>  <b>subCmdRelaysOn</b> - ativa rel√©s selecionados por m√°scara.  Os rel√©s que correspondem aos bits da unidade no argumento <b>arg1</b> ser√£o ativados.  Os rel√©s que correspondem a zeros na m√°scara manter√£o seu estado atual. <br><br>  O comando <b>subCmdRelaysOff, espelhando-o</b> , desativar√° os rel√©s selecionados por m√°scara.  Os rel√©s que correspondem aos bits √∫nicos no argumento <b>arg1</b> ser√£o desativados.  Os rel√©s que correspondem a zeros na m√°scara manter√£o seu estado atual. <br><br><h3>  Redefinir controladores FTDI e Maxim </h3><br>  Para enviar sinais de redefini√ß√£o para os microcircuitos FTDI e Maxim, o grupo de comandos <b>subCmdFT4222_1_Reset</b> , <b>subCmdFT4222_2_Reset</b> , <b>subCmdFT4222_3_Reset</b> , <b>subCmdFT4232_Reset</b> , <b>subCmdFT2232_Reset</b> e <b>subCmdMAX3421_ √© usado</b> .  A partir de seus nomes, voc√™ pode ver quais chips eles controlam atrav√©s de sinais de reset.  As pontes FT4222, como consideramos anteriormente, s√£o duas no circuito (seus √≠ndices s√£o 1 e 2), outra ponte FT4222 transfere dados para o chip MAX3421, que consideraremos no pr√≥ximo artigo. <br><br>  O par√¢metro <b>arg1</b> passa um dos seguintes valores: <br><br><pre> <code class="plaintext hljs">enum ResetState { resetStateActive =0, resetStateNormalOperation };</code> </pre> <br>  Por padr√£o, todas as pontes est√£o em condi√ß√µes normais de trabalho.  Como j√° observado em um <a href="https://habr.com/ru/post/483724/">artigo anterior</a> , n√≥s mesmos n√£o temos certeza se essa funcionalidade √© necess√°ria, mas quando n√£o h√° acesso direto ao dispositivo, √© melhor poder redefinir remotamente tudo e tudo. <br><br><h3>  Alternando linhas de configura√ß√£o de chips FT4222 </h3><br>  Os chips FT4222 t√™m quatro modos.  √â improv√°vel que algu√©m precise de um modo diferente de "00", mas se voc√™ precisar de repente, poder√° usar os <b>comandos subCmdFT4222_1_Cfg</b> , <b>subCmdFT4222_2_Cfg</b> e <b>subCmdFT4222_3_Cfg</b> para <b>alternar</b> para o primeiro, segundo e terceiro chips.  O valor das linhas CFG0 e CFG1 √© definido nos dois bits inferiores do par√¢metro <b>arg1</b> . <br><br><h2>  Experi√™ncia pr√°tica na emiss√£o de comandos para o controlador STM32 </h2><br>  Para testar o material te√≥rico obtido na pr√°tica, tentaremos trocar o cart√£o SD.  Para fazer isso, emita o comando <b>subCmdSdEnable</b> com o c√≥digo 0x00 com o argumento <b>enableModeOutside</b> com o c√≥digo 0x01.  √ìtimo.  Reescrevemos o programa a partir de experi√™ncias passadas da seguinte forma. <br><br><div class="spoiler">  <b class="spoiler_title">Programa reescrito:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; // open #include &lt;unistd.h&gt; // close #include &lt;sys/ioctl.h&gt; #include &lt;scsi/scsi.h&gt; #include &lt;scsi/sg.h&gt; int main() { printf("hello from SdAccessTest!\n"); int s_fd = open("/dev/sdb", O_NONBLOCK | O_RDWR); if (s_fd &lt; 0) { printf("Cannot open file\n"); return -1; } sg_io_hdr_t header; memset(&amp;header;, 0, sizeof(header)); uint8_t cmdSdToOutside[] = { 0xC0,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }; uint8_t cmdSdToPC[] = { 0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }; uint8_t sense[32]; memset(sense, 0, sizeof(sense)); header.interface_id = 'S'; //  'S' //  header.cmd_len = sizeof(cmdSdToOutside); header.cmdp = cmdSdToOutside; //  ( ) header.dxfer_len = 0; header.dxferp = 0; header.dxfer_direction = SG_DXFER_NONE; //     header.mx_sb_len = sizeof(sense); header.sbp = sense; // header.timeout = 100; // 100  int res = ioctl(s_fd, SG_IO, &amp;header;); //   header.cmdp = cmdSdToPC; res = ioctl(s_fd, SG_IO, &amp;header;); close(s_fd); return 0; }</code> </pre><br></div></div><br>  Alteramos o comprimento do comando para dez bytes e removemos o bloco de dados.  Bem, eles escreveram o c√≥digo de comando com argumentos, conforme necess√°rio.  Caso contr√°rio, tudo permanece o mesmo.  Come√ßamos ... E ... Nada funciona.  A fun√ß√£o <b>ioctl ()</b> retorna um erro.  O motivo est√° descrito no <b>documento de</b> comando <b>SG_IO</b> .  O fato √© que damos o comando espec√≠fico do fornecedor <b>C0h</b> , e o seguinte √© dito sobre eles literalmente: <br><blockquote>  Qualquer outro comando SCSI (opcode) n√£o mencionado para o driver sg precisa de O_RDWR.  Qualquer outro comando SCSI (opcode) n√£o mencionado para a camada de bloco SG_IO ioctl precisa de um usu√°rio com o recurso CAP_SYS_RAWIO. </blockquote><br>  Como o chefe me explicou (estou apenas recontando suas palavras), os valores das <b>capacidades</b> s√£o atribu√≠dos a um arquivo execut√°vel.  Por esse motivo, tive que rastrear a partir do ambiente de desenvolvimento efetuando login como <b>raiz</b> .  N√£o √© a melhor solu√ß√£o, mas pelo menos alguma coisa.  De fato, no Windows, a solicita√ß√£o <b>IOCTL_SCSI_PASS_THROUGH_DIRECT</b> tamb√©m requer direitos de administrador.  Talvez nos coment√°rios algu√©m d√™ conselhos sobre como resolver o problema de rastreamento sem essas etapas dr√°sticas, mas voc√™ pode executar o programa j√° escrito sem <b>raiz</b> , se registrar os <b>recursos</b> corretos <b>para ele</b> .  Enquanto isso, altere o nome de usu√°rio no ambiente de desenvolvimento e defina um ponto de interrup√ß√£o na linha: <br><br><pre> <code class="plaintext hljs">int res = ioctl(s_fd, SG_IO, &amp;header;);</code> </pre> <br>  e antes de chamar a fun√ß√£o <b>ioctl ()</b> , examinamos a lista de dispositivos de armazenamento: <br><br><img src="https://habrastorage.org/webt/ys/ef/ls/yseflsambpnn83pbywoqfuazoqi.png"><br><br>  Ligue para <b>ioctl ()</b> e veja a lista novamente: <br><br><img src="https://habrastorage.org/webt/ro/2g/33/ro2g331krziu9uslxuzo28hylxa.png"><br><br>  O dispositivo <b>/ dev / sdb</b> permaneceu (grosso modo, este √© o pr√≥prio leitor de cart√£o SD) e <b>/ dev / sdb1</b> desapareceu.  Este dispositivo corresponde ao sistema de arquivos na m√≠dia.  A operadora desconectou do computador - n√£o estava mais vis√≠vel.  Continuamos rastreando.  Depois de chamar a segunda fun√ß√£o <b>ioctl ()</b> , examinamos novamente a lista de dispositivos: <br><br><img src="https://habrastorage.org/webt/rd/wi/zx/rdwizxqu4amrqeuhzghnrptvkly.png"><br><br>  O cart√£o SD √© reconectado ao sistema, ent√£o <b>/ dev / sdb1 est√° de</b> volta no lugar.  Na verdade, aprendemos como emitir comandos espec√≠ficos do fornecedor e gerenciar um dispositivo baseado no microcontrolador STM32 no complexo Redd.  Outros comandos ser√£o deixados para os leitores para estudo independente.  Voc√™ pode controlar a opera√ß√£o de alguns deles de maneira semelhante.  Se algum chip <b>ftdi entrar</b> em um estado de redefini√ß√£o, o dispositivo correspondente desaparecer√° do sistema.  A opera√ß√£o do rel√© e o controle das pernas da configura√ß√£o ter√£o que ser controlados por instrumentos de medi√ß√£o.  Bem, voc√™ pode verificar o trabalho com uma unidade flash escrevendo p√°ginas com o controle de leitura subsequente. <br><br><h2>  Conclus√£o </h2><br>  Examinamos dois grandes t√≥picos que n√£o est√£o relacionados aos FPGAs no complexo Redd.  O terceiro permaneceu - trabalhando com o chip MAX3421, que permite a implementa√ß√£o de dispositivos USB 2.0 FS.  De fato, tamb√©m existem hosts, mas existem muitos hosts e a placa-m√£e.  A funcionalidade do dispositivo permitir√° ao complexo fingir ser uma unidade flash USB (para enviar atualiza√ß√µes de "firmware"), um teclado USB (para controlar unidades externas) etc.  Vamos considerar este t√≥pico no pr√≥ximo artigo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt484706/">https://habr.com/ru/post/pt484706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt484688/index.html">Estamos nos aproximando do limite de poder computacional - precisamos de novos programadores</a></li>
<li><a href="../pt484690/index.html">Semin√°rio, confer√™ncia, mitap: estudando as estat√≠sticas de 18.000 eventos</a></li>
<li><a href="../pt484692/index.html">Vitamina C - Preciso tomar suplementos ou √© uma medida comercial?</a></li>
<li><a href="../pt484700/index.html">Java 14: visualiza√ß√£o de registros</a></li>
<li><a href="../pt484702/index.html">Alternativas do Prestashop em 2020: as principais plataformas de com√©rcio eletr√¥nico</a></li>
<li><a href="../pt484708/index.html">Richard Hamming ‚ÄúCap√≠tulo inexistente‚Äù: como sabemos o que sabemos (vers√£o completa)</a></li>
<li><a href="../pt484710/index.html">Quebrando as Regras da Coleta de Lixo da Unidade</a></li>
<li><a href="../pt484712/index.html">Compatibilidade bin√°ria Reaktive: como a fornecemos</a></li>
<li><a href="../pt484716/index.html">Pare de chamar tudo de AI</a></li>
<li><a href="../pt484718/index.html">As modernas impressoras HP se recusam a trabalhar sem assinatura de tinta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>