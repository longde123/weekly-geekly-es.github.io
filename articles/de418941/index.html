<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😂 🤘🏿 🧖🏿 Keine Angst vor Microservice: Alexey Baitov über den Einsatz von Microservice-Architektur in der Praxis 🧓🏾 👩🏼‍🤝‍👨🏻 🕑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Für einige ist Microservices die Fähigkeit, eine Anwendung in einem relativ modernen Stil zu wiederholen und umzugestalten. Diese architektonische Lös...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Keine Angst vor Microservice: Alexey Baitov über den Einsatz von Microservice-Architektur in der Praxis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/418941/"> Für einige ist Microservices die Fähigkeit, eine Anwendung in einem relativ modernen Stil zu wiederholen und umzugestalten.  Diese architektonische Lösung ist aufgrund der Besonderheiten des Zusammenspiels verschiedener Teile der Anwendung nicht für andere geeignet.  In jedem Fall ist es bei der Auswahl einer Architektur hilfreich, die Erfahrungen anderer vom Übergang von einem Monolithen zu einer Reihe von Diensten zu untersuchen. <br><br>  Wir haben darum gebeten, unsere Fallstudie über die Entwicklung und Bereitstellung von Mikrodiensten zu teilen. Alexei Baitov, leitender Ingenieur von 2GIS.  Lassen Sie uns über Architekturlösungen, Bereitstellung und Skalierbarkeit sprechen.  Fragen wir nach Trends und nur nach praktischen Werkzeugen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f87/346/860/f8734686085fb6cf3580ff6fa636e8bf.jpg"><br><a name="habracut"></a><br>  <b>- Alexey, bitte erzähl uns ein wenig über dich und dein Team in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2GIS</a> .</b>  <b>Woran arbeiten Sie gerade?</b> <br><br><img src="https://habrastorage.org/webt/gk/aa/_8/gkaa_8zwcfej8txrfq901zub1qs.jpeg" align="left">  Ich bin 2003 als Systemadministrator zur IT gekommen und habe mich 2011 in die Entwicklung gestürzt.  Während dieser Zeit arbeitete er in PHP, JavaScript, implementierte eine Reihe von RESTful-Diensten und einen Python-Treiber für Git.  Ich arbeite seit 2015 in 2GIS. <br><br>  Er war an der Entwicklung von zwei Microservice-Architekturen beteiligt.  Der erste bestand aus einem Dienst.  Es war ein asynchroner Reverse-Proxy mit einem Cache.  Tatsächlich war er damit beschäftigt, Nachrichten zu senden.  Ich war der einzige, der an der Erarbeitung der Anforderungen, der Entwicklung und dem Aufbau von DevOps beteiligt war, aber Experten unserer 2GIS-Firma haben mir geholfen. <br><br>  Der Dienst wurde in Go geschrieben.  Durch die schnelle Kompilierung konnte ich nicht warten und konnte mich auf die kontinuierliche Bereitstellung konzentrieren.  Dann haben wir gerade angefangen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitLab CI</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prometheus</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grafana</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deis</a> (Open-Source-Analogon von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heroku</a> ) zu verwenden.  Wir haben ein Team von Infrastruktur und Betrieb, das zum Zeitpunkt meiner Entwicklung all diese Infrastrukturlösungen auf das produktionsbereite Niveau gebracht hat.  Ich habe mich dazu entschlossen und einen unabhängigen Microservice erfolgreich implementiert. <br><br>  Vor zwei Jahren wechselte ich bei einem neuen Projekt zu einem anderen Team, wo ich mich in Scala mit funktionaler Programmierung beschäftigte.  Unser Team hat von Grund auf eine Microservice-Architektur für die Speicherung von 2GIS-Werbematerialien in Scala, C # und JavaScript entwickelt.  Ich habe den Grundstein für alle Services mit den Tools und Erfahrungen gelegt, die für den Aufbau von DevOps-Praktiken (kontinuierliche Bereitstellung und Wartung) gesammelt wurden.  Die Architektur hat sich vom Prototyp zum Industriebetrieb entwickelt.  Sie hat zwei Monolithen aufgenommen, besteht nun aus 15 Diensten und wird ständig erweitert. <br><br>  <b>- Stimmen Sie zu, dass Microservices im Wesentlichen eine Reihe von unabhängig bereitgestellten Diensten sind, die gemeinsame Merkmale aufweisen, dh eine Reihe bestimmter Funktionen verleiht ihnen das Erscheinungsbild eines Microservices?</b>  <b>Muss diese Definition erweitert werden?</b>  <b>Oder haben Unternehmen tatsächlich ein anderes Verständnis der Microservice-Architektur?</b> <br><br>  Ich mag die folgende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Definition</a> .  Die Microservice-Architektur ist ein Architekturstil, der eine Anwendung als eine Sammlung lose gekoppelter Services strukturiert, die eine bestimmte Geschäftslogik implementieren.  Services in einer Microservice-Architektur weisen möglicherweise keine gemeinsamen Merkmale auf, werden jedoch in einer gemeinsamen Geschäftslogik kombiniert. <br><blockquote>  Natürlich wird jedes Unternehmen seinen eigenen Microservice haben.  Dies ist eine Reihe von Vorgehensweisen: verteilte Architektur, kontinuierliche Integration und Bereitstellung usw.  Wenn Sie das Konzept der Praxis auf die verwendeten Tools erweitern, sind die Optionen für die Implementierung von Microservices sehr unterschiedlich. </blockquote>  <b>- Es gibt unterschiedliche Meinungen über die Zusammensetzung des Teams, die in das Schreiben und Unterstützen von Microservices einbezogen werden sollten.</b>  <b>Was denkst du darüber?</b>  <b>Was ist die optimale Teamgröße und wie sollte sie durch die Interaktion bei der Entwicklung einer Microservice-Architektur aufgebaut werden?</b>  <b>Gibt es ein gutes Beispiel für Teamarbeit aus Ihrer Praxis?</b> <br><br>  Es wird als richtig angesehen, einen Dienst so zu entwickeln, dass sein gesamter Themenbereich in den Kopf eines Entwicklers passt.  Gleichzeitig können mehrere Personen an der Entwicklung dieses Dienstes teilnehmen.  Dies hilft, den Busfaktor zu vermeiden, wenn der Entwickler in den Urlaub fuhr oder krank wurde.  Durch die korrekte Aufteilung in Dienste kann eine neue Person schnell in den Kontext eintreten. <br><br>  Die Microservice-Architektur sagt uns, dass sie häufig mehrere Services enthält.  Somit kann ein Entwickler nicht tun.  Die Microservice-Architektur baut auf dem Produktmodell (oder der allgemeinen Geschäftslogik) auf.  Entwickler werden so ausgewählt, dass sich herausstellt, dass sie dieses Modell implementieren und sich gleichzeitig auf den Kunden konzentrieren. <br><br>  Die Konzentration auf den Kunden wird durch direkten Kontakt zwischen dem Entwickler und dem Kunden organisiert.  Entwickler müssen sehen, wie ihr Produkt verwendet wird.  Daraus folgen Wünsche nach Wissen auf technologischem Gebiet, die Fähigkeit, das Produkt an den Kunden zu liefern und das Produkt so schnell wie möglich zu begleiten. <br><br>  Über die Größe des Teams ist es schwer zu sagen.  Jeder kennt wahrscheinlich bereits die Aussage von Jeff Bezos, dem Gründer von Amazon, dass die Größe des Teams in der serviceorientierten Entwicklung klein genug sein sollte, damit jeder zwei Pizzen füttern kann.  In den Kommentaren zu Habré gab es eine Diskussion zu diesem Thema und sie schrieben, dass eine Person möglicherweise nicht genug eine Pizza hat und daher ein Team aus ein oder zwei Personen bestehen sollte.  Martin Fowler zitierte eine Aussage über zwei Pizzen und sagte, es handele sich um große amerikanische Pizzen. Danach gab er an, dass das Team nicht 50, sondern etwa 12 Personen haben sollte.  Ich glaube, dass alles vom Produktmodell abhängt.  Aber Fowlers Klarstellung über "nicht mehr als 12 Personen" hat in meiner Praxis bisher gewonnen.  Mir ist aufgefallen, dass es innerhalb des Teams wünschenswert ist, sich nach technologischen Interessen zu teilen, um Gleichgesinnte zu finden. <br><br>  Es ist nicht erforderlich, dass jeder im Team alle in der Arbeit verwendeten technologischen Bereiche gut kennt, aber das Gesamtwissen des Teams sollte einheitlich tief sein.  Beispielsweise sind zwei Personen am ersten Aufbau einer Bereitstellung beteiligt, und in Zukunft werden sie diese höchstwahrscheinlich auch erheblich verbessern.  Gleichzeitig sollte das gesamte Team den Bereitstellungsprozess gut verstehen.  Dadurch kann sie ihre Wünsche äußern und Änderungen vornehmen.  Warum zwei Leute?  Denn manchmal kann eine Person in einen kreativen Stupor geraten.  Und in der Diskussion wird die Wahrheit geboren. <br><br>  Wir haben natürlich auf diesem Prinzip aufgebaut, vereint durch technologische Interessen.  In diesem Fall kann der Entwickler auch DevOps-Praktiken festlegen, und der QS-Techniker kann einen zusätzlichen Nichtproduktionsdienst entwickeln (z. B. Erwärmen des Caches oder Suchen nach Anomalien in Daten in verschiedenen Umgebungen). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c0c/d3d/188/c0cd3d1883cefa481f26765dda16cba2.png"><br><br>  <b>- Fast jeder Bericht über Microservices beginnt mit der Geschichte, dass „hier wir einen Eisberg hatten und wir sägten, sägten, sägten ... Die neuen Teile der Anwendung wurden auf der Basis von Microservices erstellt, und dann begannen sie, die„ Teile “vom Hauptmotor zu trennen ... ""</b> <b><br><br></b>  <b>Sagen Sie mir, sind Sie ein Befürworter der Entwicklung von Grund auf neu oder kann es Situationen geben, in denen es sich lohnt, aus einem Monolithen eine schrittweise Schlussfolgerung zu ziehen?</b>  <b>Wie bestimme ich die Exit-Strategie?</b> <br><br>  Ich bin ein Befürworter der Entwicklung von Grund auf neu.  Dies funktioniert jedoch nur, wenn der Funktionsumfang nicht zu kompliziert ist.  Normalerweise wird ein kleiner MVP-Monolith hergestellt.  Und manchmal ist es notwendig, die interne Implementierung mehrmals radikal zu ändern.  Dies kann sowohl durch eine Änderung der technischen Aufgabe als auch durch die Tatsache verursacht werden, dass ein Verständnis für die Implementierung entsteht - Abstraktionen auf hoher Ebene erscheinen auf der Ebene des Geschäftsmodells.  Danach können Sie mit der Microservice-Architektur fortfahren. <br><br>  Wenn Sie diese Abstraktionen jedoch gleich zu Beginn durcharbeiten und in verschiedenen Notationen (UML, BPMN, IDEF) zeichnen, damit alle Teilnehmer des Prozesses verstehen, womit sie arbeiten, ist es durchaus möglich, sofort eine Microservice-Architektur zu implementieren. <br><br>  Unser Weg zur Microservice-Architektur war nicht gerade.  Zuerst gab es einen Monolithen.  Er verarbeitete Werbematerialien in Textform.  Vor dreieinhalb Jahren mussten wir mit grafischen Werbematerialien (Bilder, Logos) arbeiten.  Es bestand der Wunsch, in die Geschäftslogik einzuführen, was bei der Arbeit mit Textwerbematerialien fehlte. <br><blockquote>  Um ein neues Geschäftsmodell zu testen, haben wir die Arbeit mit grafischen Werbematerialien als zweitem Monolithen auf einem anderen Technologie-Stack implementiert.  Nach anderthalb Betriebsjahren stellten wir fest, dass dieser Ansatz korrekt war. </blockquote>  Während dieser Zeit haben wir eine Menge Wunschliste bekommen, die die Rauheit der Geschäftslogik enthüllte. <br><br>  Die Implementierung des zweiten Monolithen war schwierig auf den ersten auszudehnen.  Aus diesem Grund haben wir beschlossen, die Entwicklung nicht in zwei Monolithen gleichzeitig durchzuführen, sondern sie im Rahmen der dritten Architektur nach dem sehr neuen Geschäftsmodell zu kombinieren.  Ein Team von sieben Entwicklern, einem QS-Ingenieur und zwei Analysten wurde erstellt.  Zwei Entwickler aus diesem Team haben zuvor den ersten Monolithen erstellt und unterstützt, und einen weiteren - den zweiten Monolithen.  Das heißt, unser Team bereits am Eingang kannte die Fallstricke früherer Monolithen gut. <br><br>  Der erste Monolith wurde in C # geschrieben.  Der zweite ist in PHP.  Wir wollten die debuggten, umfangreichen Codeteile des ersten Monolithen nicht verlieren, und gleichzeitig waren Multithreading, sicherer Code und starke Typisierung erforderlich.  Der PHP-Code fiel teilweise nicht unter diese Anforderungen.  Daher blieb C # die Basis und implementierte das, was es im Rahmen des ersten Monolithen gut tat - Arbeiten mit dem Inhalt von Werbematerialien - aber auf der Basis eines anderen Speichers: S3-kompatibler Speicher und Kafka. <br><br>  Um mit dem sehr neuen Geschäftsmodell zu arbeiten, wurden diesmal Scala und die PostgreSQL-Datenbank ausgewählt.  Scala hat unsere technischen Anforderungen erfüllt.  Darüber hinaus befanden sich Scala-Entwickler auf derselben Etage wie C # -Entwickler.  Dies verkürzte die Zeit für die Teamkommunikation.  Das Gesetz von Conway hat funktioniert - die Struktur des Unternehmens bestimmte die Struktur des Antrags.  Der PHP-Entwickler hat sich zu einem Scala-Entwickler entwickelt.  Ich habe gerade die Arbeit an einem unabhängigen Mikroservice auf Golang mit einem vollständigen CI / CD-Zyklus beendet. Danach bin ich dem Team beigetreten und wurde auch Scala-Entwickler. <br><br>  Es ist interessant, was genau ich für die Arbeit mit Scala-Geschäftslogik und nicht mit C # vorgeschlagen habe.  Tatsache ist, dass wir nicht genügend C # -Entwickler hatten.  PHP-shnik und ich wollten für Scala umschulten.  Außerdem hatten wir die Gelegenheit, einen erfahrenen Scala-Entwickler zu gewinnen.  Ein weiterer Punkt: Wenn wir alles in C # implementieren würden, könnten wir entweder eine Microservice-Architektur oder einen anderen Monolithen am Ausgang erhalten.  Die Aufteilung in Scala und C #, unterschiedliche Speicheranforderungen und die Verfügbarkeit erfahrener Entwickler in jedem der erforderlichen Bereiche - all dies wies direkt auf die Microservice-Architektur hin.  Davon haben wir nur profitiert.  Vor einem Jahr wurde die Microservice-Architektur für die Arbeit mit Grafik- und Textmaterialien kommerziell in Betrieb genommen und ist bis heute erfolgreich in Betrieb. <br><br>  Auf die Frage, ob es möglich ist, eine Microservice-Architektur von Grund auf neu zu erstellen.  Vor anderthalb Jahren, als wir an der Microservice-Architektur arbeiteten, hatten wir die Forderung, eine neue Richtung in unseren Produkten einzuschlagen - Video-Werbematerialien.  Es war notwendig, schnell ein neues Verkaufsmodell zu testen.  Unsere Architektur steckte noch in den Kinderschuhen.  Die Arbeit mit Videomaterial deckte einen neuen Technologiebereich ab.  Wir haben beschlossen, den Entwicklungsvektor nicht zu ändern, und MVP für Videomaterial als eigenständige Mikroservice-Architektur in C # und vertrauenswürdigem Video-Hosting implementiert.  Dies ist eine erfolgreiche Erfahrung, und wir haben einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> zu diesem Thema.  Somit haben wir zwei parallel existierende Microservice-Architekturen.  MVP hat nicht viel entwickelt, Wishlist hat sich auch darauf angesammelt, und bald werden wir alles im Rahmen einer einzigen Microservice-Architektur kombinieren - wir werden ein einziges Repository mit Werbetext-, Grafik- und Videomaterial erhalten. <br><br>  <b>- Es gibt sofort zwei wichtige Faktoren, die für Microservices sprechen.</b>  <b>Das erste ist die Fähigkeit, einzelne Teile in die Cloud auszugeben, und infolgedessen eine kolossale Skalierbarkeit.</b>  <b>Die zweite ist die Möglichkeit, einen separaten Dienst in einer anderen Sprache zu erstellen.</b>  <b>Welche weiteren Vorteile der Umstellung auf Microservices sehen Sie?</b>  <b>Nun, von den Minuspunkten möchte ich natürlich auch hören.</b> <br><br>  Wenn wir über die technologische Komponente sprechen, umfassen die Vorteile zusätzlich zu den oben genannten die Möglichkeit, einen anderen Stapel von Technologien zu verwenden.  Und wenn er nicht zu uns passt, werden wir einen anderen wählen.  Neue Technologien umgehen die Probleme alter Lösungen.  Die Microservice-Architektur bietet auch Stabilität und Unabhängigkeit: Die Verschlechterung eines Dienstes sollte nicht zur vollständigen Verschlechterung des gesamten Systems führen.  Die Service-Composability ermöglicht die Wiederverwendung von Service-Funktionen in anderen Microservice-Architekturen.  Aus Sicht der Organisationskomponente können Sie durch die Aufteilung in Services die Entwicklung in verteilte Teams oder ein großes Team aufteilen. <br><blockquote>  Die Hauptnachteile der Microservice-Architektur: Sie ist viel komplizierter und ihre Implementierung ist teurer. </blockquote>  Sie müssen auch darauf vorbereitet sein, Serviceverträge zu unterstützen, das richtige RAS-Protokoll auszuwählen, Probleme der sicheren dienstübergreifenden Interaktion und mögliche Fehler zu beheben sowie verteilte Transaktionen zu deduplizieren und zu verwalten. <br><br>  Im Allgemeinen finden Sie im öffentlichen Bereich viele Informationen und Materialien zur Arbeit damit.  Tatsächlich hängt alles von der Aufgabe ab.  In meiner Praxis waren die Pluspunkte immer wichtiger als die Minuspunkte. <br><br>  Es lohnt sich immer noch, an die Worte von Sam Newman zu erinnern: Je weniger der Service, desto mehr manifestieren sich alle Vor- und Nachteile der Microservice-Architektur. <br><br>  <b>- Sie haben einige interessante Berichte über Microservices.</b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bereitstellung von Microservices</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Continuous Deployment-Ansatz in der Microservice-Architektur</a> .</b>  <b>Auf einer der Folien der ersten befinden sich Bereitstellungsvorlagen, und im Bericht sagen Sie, dass für Sie der Trendansatz die Verteilung über Container ist.</b>  <b>In dieser Zeit hat sich nichts geändert?</b>  <b>Ein Haufen Docker + Kubernetes hat seine Relevanz nicht verloren?</b> <br><br>  Wir übertragen immer mehr Dienste auf dieses Paket.  Ich denke, wir haben die richtige Richtung gewählt und planen vorerst, daran festzuhalten.  Wenn sich etwas ändert, werde ich Ihnen dies in einem neuen Bericht oder Interview mitteilen. <br><br>  <b>- Wie reibungslos ist die kontinuierliche Bereitstellung und Übertragung von Microservices auf Produkte?</b> <br><br>  Es hängt alles davon ab, wie der Prozess aufgebaut wird.  Auf den ersten Blick scheint alles einfach zu sein.  Dienste sind unabhängig und werden separat bereitgestellt.  Eine schwache Kohärenz wird durch unterschiedliche Ansätze bei der Entwicklung des Vertrags sichergestellt.  Und hier muss man wählen.  Sie können beispielsweise die Versionierung eines Vertrags implementieren oder einen Dienst hinzufügen, um einen Vertrag zu trennen (Vertragsentkopplung). <br><br>  Wenn in einer Microservice-Architektur in der aktiven Entwicklung 10 oder mehr Dienste gleichzeitig vorhanden sind und jeder seine eigene Versionierung hat, liegt ein Problem der Versionskonsistenz vor.  Wir dürfen versuchen, die Kompatibilität von Diensten verschiedener Versionen nicht zu verwechseln. <br><br>  Kontinuierliche Bereitstellung bedeutet, dass wir die Anwendung jederzeit in jeder Umgebung bereitstellen können. <br><blockquote>  Eine Anwendung in der Microservice-Architektur ist eine Sammlung von Diensten.  Daher müssen wir zu jedem Zeitpunkt eine stabile Kombination von Serviceversionen kennen.  Und woanders müssen wir eine Reihe von Domänenadressen und anderen Parametern haben, die für verschiedene Umgebungen spezifisch sind, um Dienste zu konfigurieren und miteinander zu verknüpfen. </blockquote>  All dies muss irgendwo gespeichert werden, um Änderungen an mehreren Stellen zu korrigieren (Microservices sind schließlich unabhängig) und um nicht verwirrt zu werden. <br><br>  Kontinuierliche Bereitstellung bedeutet, dass jederzeit ein Rollback auf eine beliebige Version möglich ist.  Dementsprechend kann es sein, dass Sie mehrere Dienste gleichzeitig zurücksetzen müssen und die korrekte umgekehrte Reihenfolge der Dienstbereitstellung beachten müssen. <br><br>  In einem meiner Berichte spreche ich über unseren Ansatz zur Entwicklung von Verträgen, wie sie das Problem der Konsistenz von Versionen gelöst haben und wie sie den Bereitstellungsprozess in der Mikrodienstarchitektur von mehr als zehn Diensten aufgebaut haben.  Eine kontinuierliche Bereitstellung ist möglicherweise nicht problemlos, aber alles ist lösbar. <br><br>  <b>- Was könnten die ersten Tools für einen kontinuierlichen Einsatz von Microservices sein?</b>  <b>Welche Optionen würden Sie für die Arbeit mit Microservices empfehlen?</b> <br><br>  Die kontinuierliche Bereitstellung ist eine Folge von Pipelines, einschließlich kontinuierlicher Integration, Integrationstests und Servicebereitstellung für die Orchestrierungsumgebung.  Die beliebtesten Step-Sequencing-Tools sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jenkins 2 Pipelines</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TeamCity Build Chains</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bitbucket Pipelines</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitLab CI Pipelines</a> .  Zuerst müssen Sie die kontinuierliche Integration (CI) automatisieren.  Wir benötigen einen Remote-CI-Server, um Tests für diese Assembly zu erstellen und auszuführen. <br><br>  Die aufgeführten Tools bieten ihre Lösungen.  Wir verwenden GitLab CI und GitLab Runners fungieren als solche Server.  Das Build-Artefakt ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker-</a> Image.  Im Rahmen der Integrationstests können Sie mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gatling</a> Last- und kapazitive Tests durchführen, um insbesondere die Ressourcen zu ermitteln, die für die Funktion in einer Orchestrierungsumgebung (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes</a> ) erforderlich sind (Prozessor und Speicher).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helm</a> wird häufig für die Bereitstellung verwendet. Mit ihm können Sie die Microservice-Architektur für verschiedene Umgebungen beschreiben.  In unserer Firma verwenden wir keinen Helm.  Wir haben unser eigenes Bereitstellungstool, das erstellt wurde, als Helm in der Classic-Version war und keine unterschiedlichen Umgebungen unterstützte.  Beide Tools haben ähnliche nützliche Eigenschaften, aber die Implementierung und Verteilung sind unterschiedlich.  Mit unserem eigenen Tool können wir Verbesserungen vornehmen und alles an unsere Infrastruktur anpassen. <br><br>  <b>- Welche Technologien sind für kleine und mittlere Unternehmen, die Microservices implementieren möchten, optimal?</b>  <b>Ist das ein zu teures Vergnügen für sie?</b> <br><br>  Zunehmend <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stoße</a> ich auf Bestätigungen, dass kleine und mittlere Unternehmen nicht in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lage</a> sind, ihre eigene Orchestrierungsumgebung zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen</a> (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker Swarm</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache Mesos</a> ).                  .       (  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Cloud Platform</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amazon Web Services</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Microsoft Azure</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oracle Cloud</a> )    . <br><br>     GitLab  GitLab CI.               . GitLab     Helm    .    Helm    .  Helm   ,           ,     ,        . <br><br>     ,     ,    ,      open source,       . <br><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spinnaker</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heroku</a> —  ,    ,       . <br><br> <b>—   ,        ,    ,  .             .     ?</b> <br><br>      ,        .     ,          ,           . <br><br>      (       )       .               . <br><br>        .       .          ,    (package).                . <br><br>   ( )   Docker-,           Git.     ,      .       ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> .  ,              . <br><br>             ,       .  :       API.                  .       :    .     ,     API.  ,   API   ,   — .      ,         API,             . <br><br>         .     ,       ;         API,      ;   ,     ,     . <br><br> <b>,    ,        .    ,      ?</b> <br><br>  —  - .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  ,        API,      ,            .    .            . <br><br> ,   ,      .       ,    ,              .    ,      ,      . <br><br> <b>—         ,      .   2. ,       ?   ?</b> <br><br>      .    .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mesosphere</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenShift</a>       PaaS  IaaS .    Deis     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   Deis</a>    .  open source  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Heroku</a> ,       Heroku Buildpack', Dockerfile'   Docker-.        .    make            Deis.       . <br><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deis2</a> .       Deis,        Kubernetes. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> Infrastructure &amp; Operations</a> ,         ,       Kubernetes  Deis2. ,     ,     Deis2,    ,     —    Kubernetes.   . Deis2   :       , pod          pod'   namespace.         Infrastructure &amp; Operations. Kubernetes    .         Deis2  Kubernetes.       Deis2   Kubernetes. <br><br> <b>— ,          ,       ,      ?      ?</b> <br><br>      Helm.     ,        .  Helm       . <br><blockquote> Helm    ,    —   :        ,   . </blockquote>  Helm   chart'     chart,         ,   . <br><br>   2        ,         10 .       (          backing : Postgres, Kafka, Zookeeper, Ceph).  -   ,  yaml-    ,      IDE,       .  ,    .  Python,          Python       .   ,      .      ,    . ,     .       ,     ,       .          .   , ,   ,         (  )   .  ,    ,  Helm,        Kubernetes  -  ,    yaml. <br><br>     API        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API Gateway</a> .        ,   —  . <br><br>        ,    :    .       ,  ,     . <br><blockquote>  DevOps     ,         .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DevOpsConf Russia</a> . <br><br> DevOpsConf Russia  <b>1  2    </b>      RootConf,  , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,   .    DevOps       ,   . <br><br>     DevOps  ,      ,      –     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  15 . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418941/">https://habr.com/ru/post/de418941/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418929/index.html">Unit Testing und Python</a></li>
<li><a href="../de418931/index.html">RubyMine 2018.2: Anhängen eines Debuggers an Remote-Prozesse, Chruby, verbesserte Code-Analyse und vieles mehr</a></li>
<li><a href="../de418933/index.html">OnePlus Review 6. Als die Chinesen alles genauso machten wie beim letzten Mal</a></li>
<li><a href="../de418935/index.html">DZ Online Tech: ABBYY. Wie kann man in neuronalen Netzen nicht verwirrt werden?</a></li>
<li><a href="../de418937/index.html">Wir feiern das 8-jährige Jubiläum mit der ersten Veröffentlichung an der GeekUniversity</a></li>
<li><a href="../de418943/index.html">Computer singen, Cyborgs und Wellenmusik - diskutieren Sie ungewöhnliche Sounds und Audio-Gadgets</a></li>
<li><a href="../de418945/index.html">Beste ICOs August 2018 (Abstimmung)</a></li>
<li><a href="../de418951/index.html">UE4 | Inventar für Multiplayer # 2 | Verbinden Sie Blueprint mit C ++</a></li>
<li><a href="../de418953/index.html">Antiquitäten: Vintage Antivirus und angewandte digitale Archäologie</a></li>
<li><a href="../de418955/index.html">Dodo: Ein IT-Unternehmen, das Pizza herstellt. Programmierung und IT-Prozesse / AichiHype</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>