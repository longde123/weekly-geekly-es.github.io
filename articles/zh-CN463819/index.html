<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🌾 🙆🏽 🚤 PostgreSQL锁：2.字符串锁 🎚️ 📌 🚣🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="上一次，我们讨论了对象级锁 ，特别是关系上的锁。 今天，我们将了解PostgreSQL中行锁的排列方式以及它们如何与对象锁一起使用，让我们讨论等待队列以及那些不合时宜的人。 



 行锁 
 装置 
 让我提醒您上一篇文章的几个重要结论。 



- 服务器共享内存中必须存在某个锁。 
- 锁的粒...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL锁：2.字符串锁</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/463819/"> 上一次，我们讨论了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对象级锁</a> ，特别是关系上的锁。 今天，我们将了解PostgreSQL中行锁的排列方式以及它们如何与对象锁一起使用，让我们讨论等待队列以及那些不合时宜的人。 <br><br><img src="https://habrastorage.org/webt/6x/u5/jj/6xu5jj3edymfhel21v9obwhsxai.png"><br><br><h1> 行锁 </h1><br><h2> 装置 </h2><br> 让我提醒您上一篇文章的几个重要结论。 <br><br><ul><li> 服务器共享内存中必须存在某个锁。 </li><li> 锁的粒度越高，同时运行的进程之间的竞争（争用）就越少。 </li><li> 另一方面，粒度越高，锁占用的内存空间就越大。 </li></ul><br> 我们当然希望更改一行不阻塞同一表的其他行。 但是我们不能以自己的锁开始每一行。 <br><br> 有多种方法可以解决此问题。 在某些DBMS中，锁的级别有所增加：如果行级别的锁太多，则将它们替换为另一个普通的锁（例如，页面级或整个表）。 <br><br> 稍后我们将看到，PostgreSQL也使用这种机制，但仅用于谓词锁定。 线路锁不同。 <br><a name="habracut"></a><br> 在PostgreSQL中，行被锁定的信息仅排他地存储在数据页内的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">行版本中</a> （而不存储在RAM中）。 也就是说，从通常意义上讲，这根本不是一个障碍，而只是一个信号。 该符号实际上是xmax事务编号以及其他信息位的组合。 稍后，我们将详细了解其工作原理。 <br><br>  <strong>优点</strong>是我们可以在不占用任何资源的情况下根据需要阻塞任意多行。 <br><br> 但是有一个<strong>缺点</strong> ：由于关于锁的信息没有显示在RAM中，因此其他进程无法排队。 而且没有监视的可能性（要计算锁，您需要读取整个表）。 <br><br> 很好，监视很好，但是需要对队列进行一些操作。 为此，您仍然必须使用“常规”锁。 实际上，如果我们需要等到行被释放后，我们就必须等到阻塞事务结束时，即在提交或回滚时释放所有锁。 为此，您可以请求阻止交易的阻止编号（我记得，该交易由交易本身以特殊模式持有）。 因此，使用的锁数与同时运行的进程数成正比，而不与要更改的行数成正比。 <br><br><h2> 特殊模式 </h2><br> 总共有4种可以锁定线路的模式。 其中，两种模式代表<em>排他</em>锁，一次只能拥有一个事务。 <br><br><ul><li>  FOR UPDATE模式意味着一行的完整更改（或删除）。 </li><li>  FOR NO KEY UPDATE模式-仅更改不包含在唯一索引中的那些字段（换句话说，进行这样的更改，所有外键均保持不变）。 </li></ul><br>  UPDATE命令本身会选择最小的适当锁定模式。 通常行以FOR NO KEY UPDATE模式锁定。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">记得</a>您在删除或更改行时，当前交易版本号被写入当前当前版本的xmax字段中。 它显示该事务已删除该行的版本。 因此，相同的xmax数用作阻止的标志。 实际上，如果该行版本中的xmax对应于一个活动（尚未完成）的事务，并且我们要更新该特定行，则我们必须等待该事务完成，因此不需要其他符号。 <br><br> 让我们看看。 创建一个帐户表，与上一篇文章相同。 <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( acc_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">300.00</span></span>);</code> </pre> <br> 当然，要查看页面，我们需要已经熟悉的pageinspect扩展。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect;</code> </pre><br> 为了方便起见，创建一个仅显示我们感兴趣的信息的视图：xmax和一些信息位。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">128</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> lock_only, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">4096</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> is_multi, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask2 &amp; <span class="hljs-number"><span class="hljs-number">8192</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> keys_upd, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">16</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> keyshr_lock, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">16</span></span>+<span class="hljs-number"><span class="hljs-number">64</span></span>) = <span class="hljs-number"><span class="hljs-number">16</span></span>+<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> shr_lock <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> lp;</code> </pre><br> 因此，我们开始交易并更新第一个帐户的金额（密钥不变）和第二个帐户的编号（密钥改变）： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br> 我们调查一下视图： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530492 | | | | | (0,2) | 530492 | | | t | | (2 rows)</code> </pre><br> 锁定模式由keys_updated信息位确定。 <br><br> 当使用SELECT FOR UPDATE命令锁定行时，也会使用相同的xmax字段，但是在这种情况下，会放下一个附加的信息位（xmax_lock_only），这表明该行的版本仅被锁定，而未被删除，并且仍然相关。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR NO KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530493 | t | | | | (0,2) | 530493 | t | | t | | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><br><h2> 共享模式 </h2><br> 另外两种模式表示可以由多个事务持有的共享锁。 <br><br><ul><li> 当您需要读取字符串时，可以使用FOR SHARE模式，但是您不能允许其他事务以任何方式更改它。 </li><li>  FOR KEY SHARE模式允许更改字符串，但只能更改非关键字段。  PostgreSQL在检查外键时会自动使用此模式。 </li></ul><br> 让我们看看。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><br> 在行版本中，我们看到： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530494 | t | | | t | (0,2) | 530494 | t | | | t | t (2 rows)</code> </pre><br> 在这两种情况下，keyshr_lock位置1，并且可以通过再查看一个信息位来识别SHARE模式。 <br><br> 通用模式兼容性矩阵如下所示。 <br><br><div class="scrollable-table"><table><tbody><tr><th> 模式 </th><th> 关键共享 </th><th> 分享 </th><th> 无关键更新 </th><th> 更新 </th></tr><tr><td> 关键共享 </td><td></td><td></td><td></td><td>  X </td></tr><tr><td> 分享 </td><td></td><td></td><td>  X </td><td>  X </td></tr><tr><td> 无关键更新 </td><td></td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> 更新 </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr></tbody></table></div><br> 它表明： <br><br><ul><li> 例外模式相互冲突； </li><li> 共享模式彼此兼容； </li><li> 共享的FOR KEY SHARE模式与独占的FOR NO KEY UPDATE模式兼容（也就是说，您可以同时更新非关键字段，并确保关键不变。） </li></ul><br><h2> 多重交易 </h2><br> 到目前为止，我们认为锁定由xmax字段中阻止事务的数量表示。 但是共享锁可以由多个事务持有，并且不能将多个数字写入同一xmax字段。 如何成为 <br><br> 对于共享锁，使用了所谓的<em>多</em>事务（MultiXact）。 这是一个分配了单独编号的交易组。 该编号与常规交易编号具有相同的维度，但是编号是独立分配的（也就是说，系统可以具有相同的交易编号和多交易编号）。 为了彼此区分，使用了另一个信息位（xmax_is_multi），有关该组成员和锁定模式的详细信息位于$ PGDATA / pg_multixact /目录中的文件中。 当然，最后使用的数据存储在服务器共享内存的缓冲区中，以加快访问速度。 <br><br> 在现有锁中添加另一个由另一个事务执行的例外锁（我们可以这样做，因为FOR KEY SHARE和FOR NO KEY UPDATE模式彼此兼容）： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 61 | | t | | | (0,2) | 530494 | t | | | t | t (2 rows)</code> </pre><br> 在第一行中，我们看到通常的数字已由多事务处理数字代替-xmax_is_multi位证明了这一点。 <br><br> 为了不深入研究多事务实现的内部，可以使用另一个扩展，该扩展允许您方便地查看有关所有类型的行锁的所有信息。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgrowlocks; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------------------------- locked_row | (0,1) locker | 61 multi | t xids | {530494,530495} modes | {"Key Share","No Key Update"} pids | {5892,5928} -[ RECORD 2 ]----------------------------- locked_row | (0,2) locker | 530494 multi | f xids | {530494} modes | {"For Share"} pids | {5892}</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h2> 冻结设定 </h2><br> 由于将单独的数字分配给写在行版本的xmax字段中的多重事务，由于计数器位容量的限制，它们遇到与常规数字相同的xid环绕<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">问题</a> 。 <br><br> 因此，对于多笔交易编号，还必须执行冻结的模拟-用新的编号替换旧的编号（如果冻结时仅由一个交易持有，则用常规的交易编号替换）。 <br><br> 请注意，仅对xmin字段执行普通交易编号的冻结（因为该行的版本具有非空的xmax字段，那么它要么是不相关的版本，它将被清除，或者xmax交易被取消并且其编号对我们不感兴趣）。 但是对于多重事务，我们正在谈论该行当前版本的xmax字段，该字段可以保持相关，但是在共享模式下，它经常被不同事务阻塞。 <br><br> 对于多<em>事务</em>冻结，与通常冻结的参数类似的参数<em>负责</em> ： <em>vacuum_multixact_freeze_min_age</em> ， <em>vacuum_multixact_freeze_table_age</em> ， <em>autovacuum_multixact_freeze_max_age</em> 。 <br><br><h1> 谁是极端？ </h1><br> 逐渐接近甜头。 让我们看看几个事务将更新同一行时的锁情况。 <br><br> 让我们首先在pg_locks上构建一个视图。 首先，我们将得出的结论更为紧凑，其次，我们将自己限制在有趣的锁上（实际上，我们将放弃虚拟交易编号，帐户表上的索引，pg_locks和视图本身的锁），通常，所有不相关的内容以及只分散注意力）。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, locktype, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> locktype <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'relation'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'transactionid'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> transactionid::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'tuple'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>||<span class="hljs-string"><span class="hljs-string">':'</span></span>||tuple::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> lockid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> locktype <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'relation'</span></span>,<span class="hljs-string"><span class="hljs-string">'transactionid'</span></span>,<span class="hljs-string"><span class="hljs-string">'tuple'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (locktype != <span class="hljs-string"><span class="hljs-string">'relation'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><br> 现在开始第一个事务并更新该行。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> txid_current | pg_backend_pid --------------+---------------- 530497 | 5892 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br> 那锁呢？ <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5892</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5892 | relation | accounts | RowExclusiveLock | t 5892 | transactionid | 530497 | ExclusiveLock | t (2 rows)</code> </pre><br> 事务保存表和自己的数字锁。 到目前为止，一切都可以期待。 <br><br> 我们开始第二笔交易，并尝试更新同一行。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| txid_current | pg_backend_pid | --------------+---------------- | 530498 | 5928 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br> 那第二笔交易锁呢？ <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | transactionid | 530498 | ExclusiveLock | t 5928 | transactionid | 530497 | ShareLock | f 5928 | tuple | accounts:1 | ExclusiveLock | t (4 rows)</code> </pre><br> 这里更有趣。 除了锁定表和自己的号码外，我们还会看到两个锁。 第二笔交易发现该行被首先锁定，并“挂起”等待其编号（已授予= f）。 但是，行版本锁（locktype = tuple）的来源和来源为何？ <br><br><blockquote> 不要混淆行版本锁（元组锁）和行锁（行锁）。 第一个是常规元组类型锁，在pg_locks中可见。 第二个是数据页中的标记：xmax和信息位。 <br></blockquote><br> 当事务要更改行时，它将执行以下操作序列： <br><br><ol><li> 在字符串（元组）的可变版本上捕获排他锁。 </li><li> 如果xmax和信息位指示该行已锁定，则它要求锁定xmax事务号。 </li><li> 规定其xmax和必要的信息位。 </li><li> 释放行版本锁。 </li></ol><br> 当该行由第一个事务更新时，它也抓住了行版本锁（步骤1），但立即释放了它（步骤4）。 <br><br> 当第二笔交易到达时，她捕获了行版本锁（项目1），但被迫要求对第一笔交易（项目2）的编号进行锁定并挂起。 <br><br> 如果出现第三次类似的交易会怎样？ 她将尝试捕获该行版本的锁（项目1），并且将在此步骤中挂起。 看看吧。 <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| txid_current | pg_backend_pid || --------------+---------------- || 530499 | 5964 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5964</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 5964 | relation | accounts | RowExclusiveLock | t 5964 | tuple | accounts:1 | ExclusiveLock | f 5964 | transactionid | 530499 | ExclusiveLock | t (3 rows)</code> </pre><br> 希望更新同一行的第四，第五个等事务与事务3不会有任何不同，它们都将“挂起”在同一行版本锁上。 <br><br> 将另一个事务添加到堆。 <br><br><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; ||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">||| txid_current | pg_backend_pid ||| --------------+---------------- ||| 530500 | 6000 ||| (1 row)</code> </pre><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">6000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 6000 | relation | accounts | RowExclusiveLock | t 6000 | transactionid | 530500 | ExclusiveLock | t 6000 | tuple | accounts:1 | ExclusiveLock | f (3 rows)</code> </pre><br> 可以在pg_stat_activity视图中看到当前期望的一般情况，其中添加了有关阻塞过程的信息： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, wait_event_type, wait_event, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | wait_event_type | wait_event | pg_blocking_pids ------+-----------------+---------------+------------------ 5892 | | | {} 5928 | Lock | transactionid | {5892} 5964 | Lock | tuple | {5928} 6000 | Lock | tuple | {5928,5964} (4 rows)</code> </pre><br> 事实证明，这是一种“队列”，其中有第一个（保留字符串的锁版本的队列），而所有其他队列都排在第一个后面。 <br><br> 为什么我们需要如此复杂的设计？ 假设我们没有该字符串的版本锁。 然后第二个和第三个（依此类推）事务将等待第一个事务的编号阻塞。 在第一个事务完成时，被阻塞的资源消失了（ <em>您在这里做什么，嗯？事务已结束</em> ），现在这完全取决于操作系统将首先唤醒哪个等待的进程，因此，将有时间锁定该行。 所有其他进程也将被唤醒，但是它们将不得不再次排队-现在在另一个进程之后。 <br><br> 这充满了这样的事实，即某些交易可以无限期地等待交易，如果由于不幸的情况而导致交易总是围绕其他交易进行。 用英语将这种情况称为锁定饥饿。 <br><br> 在我们的例子中，结果大致相同，但还好一点：第二个事务保证了它可以访问下一个资源。 但是接下来（第三和第四）会发生什么呢？ <br><br> 如果第一个事务以回滚结束，一切都会好起来的：传入的事务将按照它们排列的顺序进行。 <br><br> 但是-运气不好-如果第一个事务以一次提交完成，那么不仅事务号消失了，而且行的版本也消失了！ 也就是说，该版本当然仍然存在，但不再相关，因此有必要更新（同一行的）完全不同的最新版本。 轮到的资源消失了，每个人都在争夺拥有新资源的机会。 <br><br> 让第一笔交易完成。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 第二笔交易将被唤醒并执行段落。  3和4。 <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | transactionid | 530498 | ExclusiveLock | t (2 rows)</code> </pre><br> 那第三笔交易呢？ 她跳过了步骤1（因为资源已消失），并停留在步骤2： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5964</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5964 | relation | accounts | RowExclusiveLock | t 5964 | transactionid | 530498 | ShareLock | f 5964 | transactionid | 530499 | ExclusiveLock | t (3 rows)</code> </pre><br> 同样的事情发生在第四笔交易中： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">6000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 6000 | relation | accounts | RowExclusiveLock | t 6000 | transactionid | 530498 | ShareLock | f 6000 | transactionid | 530500 | ExclusiveLock | t (3 rows)</code> </pre><br> 也就是说，第三和第四笔交易都在等待第二笔交易的完成。 队伍变成了<strike>南瓜</strike>人群。 <br><br> 我们完成了所有已开始的交易。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">|| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">||| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><blockquote> 有关阻塞字符串的更多详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">README.tuplock</a> 。 <br></blockquote><br><h1> 你不是站在这里 </h1><br> 因此，两级阻止方案的思想是减少永恒等待“运气不好”交易的可能性。 然而，正如我们已经看到的那样，这种情况很有可能发生。 而且，如果应用程序使用共享锁，那么一切都会变得更糟。 <br><br> 让第一个事务以共享模式锁定该行。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> txid_current | pg_backend_pid --------------+---------------- 530501 | 5892 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><pre> <code class="plaintext hljs"> acc_no | amount --------+-------- 1 | 100.00 (1 row)</code> </pre><br> 第二个事务尝试更新同一行，但不能-SHARE和NO KEY UPDATE模式不兼容。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| txid_current | pg_backend_pid | --------------+---------------- | 530502 | 5928 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br> 第二个事务等待第一个事务完成，并保持行版本锁定-现在，一切都像上次一样。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+-------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | tuple | accounts:10 | ExclusiveLock | t 5928 | transactionid | 530501 | ShareLock | f 5928 | transactionid | 530502 | ExclusiveLock | t (4 rows)</code> </pre><br> 然后出现第三个需要共享锁的事务。 问题在于它不会尝试捕获行版本的锁（因为它不会更改行），而只是不按顺序爬网-与第一个事务兼容。 <br><br><pre> <code class="pgsql hljs">|| <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| txid_current | pg_backend_pid || --------------+---------------- || 530503 | 5964 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><pre> <code class="plaintext hljs">|| acc_no | amount || --------+-------- || 1 | 100.00 || (1 row)</code> </pre><br> 现在有两个事务阻止了该行： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]--------------- locked_row | (0,10) locker | 62 multi | t xids | {530501,530503} modes | {Share,Share} pids | {5892,5964}</code> </pre><br> 当第一笔交易完成后，现在会发生什么？ 第二笔交易将被唤醒，但是将看到行锁在任何地方都没有消失，并且将再次处于“队列”中-这次是第三笔交易： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+-------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | tuple | accounts:10 | ExclusiveLock | t 5928 | transactionid | 530503 | ShareLock | f 5928 | transactionid | 530502 | ExclusiveLock | t (4 rows)</code> </pre><br> 并且只有在第三个事务完成时（并且如果在此期间没有其他共享锁出现），第二个事务就可以执行更新。 <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br> 也许是时候得出一些实际结论了。 <br><br><ul><li> 在许多并行进程中同时更新表中的同一行并不是一个好主意。 </li><li> 如果在应用程序中使用SHARE类型的共享锁，请谨慎使用。 </li><li> 检查外键应该不会造成干扰，因为键字段通常不会更改，并且KEY SHARE和NO KEY UPDATE模式兼容。 </li></ul><br><br><h1> 要求不要借 </h1><br> 通常，SQL命令期望释放所需的资源。 但是，有时如果无法立即获得锁定，则希望拒绝执行该命令。 为此，可以使用诸如SELECT，LOCK，ALTER之类的命令来使用短语NOWAIT。 <br><br> 例如： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOWAIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| ERROR: could not obtain lock on row in relation "accounts"</code> </pre><br> 如果资源繁忙，该命令将立即失败。 在应用程序代码中，这样的错误可以被拦截和处理。 <br><br> 您不能为UPDATE和DELETE命令指定NOWAIT短语，但是您可以首先执行SELECT FOR UPDATE NOWAIT，然后，如果可能的话，更新或删除该行。 <br><br> 还有一个不等待的选项-将SELECT FOR命令与短语SKIP LOCKED一起使用。 这样的命令将跳过锁定的行，但处理自由行。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> acc_no <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SKIP LOCKED</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs">| acc_no | amount | --------+-------- | 2 | 200.00 | (1 row)</code> </pre><br> 在此示例中，第一行（被阻止）被跳过，我们立即收到（并被阻止）第二行。 <br><br> 实际上，这使您可以组织队列的多线程处理。 您不应该为该命令提供另一个应用程序-如果您想使用它，那么很可能您将看不到一些更简单的解决方案。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><pre> <code class="plaintext hljs">| =&gt; ROLLBACK;</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">待续</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN463819/">https://habr.com/ru/post/zh-CN463819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN463805/index.html">想要成为游戏设计师的七本书</a></li>
<li><a href="../zh-CN463811/index.html">为Android Q准备应用程序。第1部分</a></li>
<li><a href="../zh-CN463813/index.html">Mikrotik RouterOS上的多厢货车和路由</a></li>
<li><a href="../zh-CN463815/index.html">为什么外国银行对您的资金来源感兴趣？</a></li>
<li><a href="../zh-CN463817/index.html">20位产品经理和所有最多的多维矩阵结构。 与Skyeng的对话</a></li>
<li><a href="../zh-CN463821/index.html">AMO，Bitrix，1C等：如何选择从哪里开始？</a></li>
<li><a href="../zh-CN463823/index.html">Rust 1.37.0版本：配置文件引导的优化，未命名的常量和货物供应商</a></li>
<li><a href="../zh-CN463825/index.html">Google表格项目管理工具</a></li>
<li><a href="../zh-CN463829/index.html">FreePBX 配置Asterisk，以通过电子邮件通知队列中未接来电</a></li>
<li><a href="../zh-CN463831/index.html">俄罗斯的IT教育有什么问题</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>